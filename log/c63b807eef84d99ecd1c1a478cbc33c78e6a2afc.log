c63b807eef84d99ecd1c1a478cbc33c78e6a2afc
==================================================
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=56400
==================================================
Mark Emlyn
==================================================
Fri May 9 15:25:43 2014 +0000
==================================================
AbandonedTrace.java
index 935d3823a6..d76ba3b112 100644
--- a/build.xml
+++ b/build.xml
@@ -97,6 +97,7 @@
   <property name="catalina-ant.jar" value="${tomcat.build}/lib/catalina-ant.jar"/>
   <property name="catalina-storeconfig.jar" value="${tomcat.build}/lib/catalina-storeconfig.jar"/>
   <property name="tomcat-coyote.jar" value="${tomcat.build}/lib/tomcat-coyote.jar"/>
+  <property name="tomcat-dbcp.jar" value="${tomcat.build}/lib/tomcat-dbcp.jar"/>
   <property name="tomcat-jni.jar" value="${tomcat.build}/lib/tomcat-jni.jar"/>
   <property name="tomcat-spdy.jar" value="${tomcat.build}/lib/tomcat-spdy.jar"/>
   <property name="tomcat-api.jar" value="${tomcat.build}/lib/tomcat-api.jar"/>
@@ -106,9 +107,6 @@
   <property name="jasper.jar" value="${tomcat.build}/lib/jasper.jar"/>
   <property name="jasper-el.jar" value="${tomcat.build}/lib/jasper-el.jar"/>
 
-  <property name="tomcat-dbcp.home" value="${base.path}/tomcat${version.major}-deps/dbcp" />
-  <property name="tomcat-dbcp.jar" value="${tomcat-dbcp.home}/tomcat-dbcp.jar"/>
-
   <!-- Standard Source JARs -->
   <property name="bootstrap-src.jar" value="${tomcat.src.jars}/bootstrap-src.jar"/>
   <property name="tomcat-juli-src.jar" value="${tomcat.src.jars}/tomcat-juli-src.jar"/>
@@ -127,6 +125,7 @@
   <property name="tomcat-jni-src.jar" value="${tomcat.src.jars}/tomcat-jni-src.jar"/>
   <property name="tomcat-spdy-src.jar" value="${tomcat.src.jars}/tomcat-spdy-src.jar"/>
   <property name="tomcat-coyote-src.jar" value="${tomcat.src.jars}/tomcat-coyote-src.jar"/>
+  <property name="tomcat-dbcp-src.jar" value="${tomcat.src.jars}/tomcat-dbcp-src.jar"/>
   <property name="tomcat-api-src.jar" value="${tomcat.src.jars}/tomcat-api-src.jar"/>
   <property name="tomcat-util-src.jar" value="${tomcat.src.jars}/tomcat-util-src.jar"/>
   <property name="tomcat-util-scan-src.jar" value="${tomcat.src.jars}/tomcat-util-scan-src.jar"/>
@@ -134,8 +133,6 @@
   <property name="jasper-src.jar" value="${tomcat.src.jars}/jasper-src.jar"/>
   <property name="jasper-el-src.jar" value="${tomcat.src.jars}/jasper-el-src.jar"/>
 
-  <property name="tomcat-dbcp-src.jar" value="${tomcat-dbcp.home}/tomcat-dbcp-src.jar"/>
-
   <!-- Embedded JARs & source JARs -->
   <property name="tomcat-embed-core.jar" value="${tomcat.embed}/tomcat-embed-core.jar"/>
   <property name="tomcat-embed-jasper.jar" value="${tomcat.embed}/tomcat-embed-jasper.jar"/>
@@ -557,9 +554,6 @@
         <exclude name="java/org/apache/**/parser/ParseException.java" />
         <exclude name="java/org/apache/**/parser/SimpleCharStream.java" />
         <exclude name="java/org/apache/**/parser/Token*.java" />
-        <!-- Exclude these else Gump runs validate on them -->
-        <exclude name="**/org/apache/tomcat/dbcp/**"/>
-        <exclude name="**/tomcat-deps/**"/>
         <!-- Exclude simple test files -->
         <exclude name="test/webapp/bug53257/**/*.txt"/>
         <exclude name="test/webapp-fragments/WEB-INF/classes/*.txt"/>
@@ -618,9 +612,6 @@
         <exclude name="nbproject/**"/>
         <exclude name="output/**"/>
         <exclude name="modules/**"/>
-        <!-- Exclude these else Gump runs validate on them -->
-        <exclude name="**/org/apache/tomcat/dbcp/**"/>
-        <exclude name="**/tomcat-deps/**"/>
       </fileset>
       <fileset dir="modules/jdbc-pool" >
         <patternset refid="text.files" />
@@ -697,7 +688,7 @@
 
   </target>
 
-  <target name="package" depends="compile,build-tomcat-dbcp" >
+  <target name="package" depends="compile,build-manifests" >
     <!-- Common Annotations 1.0 JAR File -->
     <jarIt jarfile="${annotations-api.jar}"
       filesDir="${tomcat.classes}"
@@ -811,6 +802,11 @@
       filesDir="${tomcat.classes}"
       filesId="files.jasper-el" />
 
+    <!-- Re-packaged Apache Commons DBCP-->
+    <jarIt jarfile="${tomcat-dbcp.jar}"
+      filesDir="${tomcat.classes}"
+      filesId="files.tomcat-dbcp" />
+
     <!-- i18n JARs -->
     <jar jarfile="${tomcat.build}/lib/tomcat-i18n-es.jar"
       manifest="${tomcat.manifests}/default.manifest">
@@ -1072,8 +1068,6 @@
     <!-- Add sources for examples -->
     <antcall target="examples-sources" />
 
-    <copy file="${tomcat-dbcp.jar}" todir="${tomcat.build}/lib"
-      failonerror="false"/>
     <copy file="${jdt.jar}" todir="${tomcat.build}/lib" />
   </target>
 
@@ -1224,7 +1218,7 @@
 
   <target name="embed-sources"
           description="Create source jars for embedded jars"
-          depends="build-manifests" >
+          depends="build-manifests,package-src-jar" >
 
     <mkdir dir="${tomcat.embed.sources}" />
 
@@ -2084,7 +2078,7 @@ Apache Tomcat ${version} native binaries for Win64 AMD64/EMT64 platform.
   </target>
 
   <target name="release"
-    depends="clean,clean-depend,release-init,dist-deployer,installer,package-zip,package-winzip,package-tgz,package-deployer-zip,package-deployer-tgz,javadoc,package-docs-tgz,package-src-zip,package-src-tgz,package-src-jar"
+    depends="clean,release-init,dist-deployer,installer,package-zip,package-winzip,package-tgz,package-deployer-zip,package-deployer-tgz,javadoc,package-docs-tgz,package-src-zip,package-src-tgz,package-src-jar"
     description="Create a Tomcat packaged distribution">
 
     <copy file="KEYS"
@@ -2574,18 +2568,16 @@ Apache Tomcat ${version} native binaries for Win64 AMD64/EMT64 platform.
       filesId="files.jasper-el" />
 
     <!-- Repackaged DBCP -->
-    <copy file="${tomcat-dbcp-src.jar}" todir="${tomcat.src.jars}" />
+    <jarIt jarfile="${tomcat-dbcp-src.jar}"
+      filesDir="java"
+      filesId="files.tomcat-dbcp" />
+
     <!-- jdbc-pool JAR File -->
     <copy file="${tomcat-jdbc-src.jar}" todir="${tomcat.src.jars}" />
   </target>
 
   <!-- ========================= Cleaning Targets ========================== -->
 
-  <target name="clean-depend"
-          description="Deletes the dependencies that are built from source">
-    <delete dir="${tomcat-dbcp.home}"/>
-  </target>
-
   <target name="clean"
           description="Delete the default output folders">
     <delete dir="${tomcat.output}" />
@@ -2637,29 +2629,6 @@ Apache Tomcat ${version} native binaries for Win64 AMD64/EMT64 platform.
       <param name="destdir" value="${commons-daemon.home}"/>
     </antcall>
 
-    <!-- Download src and build Tomcat DBCP bundle -->
-    <antcall target="downloadgz-2">
-      <param name="sourcefile.1" value="${commons-pool-src.loc.1}"/>
-      <param name="sourcefile.2" value="${commons-pool-src.loc.2}"/>
-      <param name="destfile" value="${commons-pool.home}/build.xml" />
-    </antcall>
-    <antcall target="downloadgz-2">
-      <param name="sourcefile.1" value="${commons-dbcp-src.loc.1}"/>
-      <param name="sourcefile.2" value="${commons-dbcp-src.loc.2}"/>
-      <param name="destfile" value="${commons-dbcp.home}/build.xml" />
-    </antcall>
-    <mkdir dir="${tomcat-dbcp.home}"/>
-    <!-- Rebuild dbcp only if built jars do not exist -->
-    <!-- or new versions of pool or dbcp have been downloaded. -->
-    <condition property="no.build.dbcp">
-      <and>
-        <uptodate srcfile="${commons-pool.home}" targetfile="${tomcat-dbcp.jar}" />
-        <uptodate srcfile="${commons-pool.home}" targetfile="${tomcat-dbcp-src.jar}" />
-        <uptodate srcfile="${commons-dbcp.home}" targetfile="${tomcat-dbcp.jar}" />
-        <uptodate srcfile="${commons-dbcp.home}" targetfile="${tomcat-dbcp-src.jar}" />
-      </and>
-    </condition>
-
     <!-- Download JDT (Eclipse compiler) -->
     <antcall target="downloadfile-2">
       <param name="sourcefile.1" value="${jdt.loc.1}"/>
@@ -2750,87 +2719,6 @@ Apache Tomcat ${version} native binaries for Win64 AMD64/EMT64 platform.
 
   </target>
 
-
-  <!-- =============== Targets for dependencies that need to =============== -->
-  <!-- ================  be built rather than used directly ================ -->
-
-  <target name="build-tomcat-dbcp" depends="build-manifests" unless="no.build.dbcp">
-    <copy todir="${tomcat-dbcp.home}/src">
-      <fileset dir="${commons-pool.home}/src/main">
-        <include name="**/*.java" />
-        <exclude name="**/test/**" />
-        <exclude name="**/proxy/**" />
-      </fileset>
-    </copy>
-    <copy todir="${tomcat-dbcp.home}/src">
-      <fileset dir="${commons-dbcp.home}/src/main">
-        <include name="**/*.java" />
-        <exclude name="**/test/**" />
-        <exclude name="**/managed/**" />
-      </fileset>
-    </copy>
-    <copy todir="${tomcat-dbcp.home}/src/java">
-      <fileset dir="${commons-dbcp.home}/src/main/resources">
-        <include name="**/*.properties" />
-      </fileset>
-    </copy>
-
-    <!-- Package rename to avoid clashes with the same classes in webapps -->
-    <replace dir="${tomcat-dbcp.home}/src/java/org/apache/commons"
-        encoding="ISO-8859-1">
-      <replacefilter token="org.apache.commons"
-            value="org.apache.tomcat.dbcp" />
-    </replace>
-
-   <!-- Depend on JULI rather than Commons-Logging -->
-    <replace dir="${tomcat-dbcp.home}/src/java/org/apache/commons"
-        encoding="ISO-8859-1">
-      <replacefilter token="org.apache.tomcat.dbcp.logging"
-            value="org.apache.juli.logging" />
-    </replace>
-
-    <mkdir dir="${tomcat-dbcp.home}/src/java/org/apache/tomcat/dbcp" />
-    <move todir="${tomcat-dbcp.home}/src/java/org/apache/tomcat/dbcp">
-      <fileset dir="${tomcat-dbcp.home}/src/java/org/apache/commons" />
-    </move>
-    <mkdir dir="${tomcat-dbcp.home}/classes"/>
-    <!-- Make sure the build fails if the DBCP sources haven't been copied -->
-    <!-- correctly. Other problems should be detected by the following     -->
-    <!-- compilation step failing.                                         -->
-    <fail message="Repackaged DBCP factory is missing">
-      <condition>
-        <not>
-          <resourceexists>
-            <file file="${tomcat-dbcp.home}/src/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSourceFactory.java"/>
-          </resourceexists>
-        </not>
-      </condition>
-    </fail>
-    <javac destdir="${tomcat-dbcp.home}/classes"
-           debug="${compile.debug}"
-           deprecation="${compile.deprecation}"
-           source="${compile.source}"
-           target="${compile.target}"
-           sourcepath="${tomcat-dbcp.home}/src/java"
-           srcdir="${tomcat-dbcp.home}/src/java"
-           encoding="ISO-8859-1"
-           includeantruntime="false">
-      <include name="**" />
-      <classpath path="${tomcat.classes}" />
-    </javac>
-    <copy todir="${tomcat-dbcp.home}/classes">
-      <fileset dir="${tomcat-dbcp.home}/src/java">
-        <include name="**/*.properties" />
-      </fileset>
-    </copy>
-    <jarIt jarfile="${tomcat-dbcp.jar}"
-      filesDir="${tomcat-dbcp.home}/classes"
-      filesId="files.tomcat-dbcp" />
-    <jarIt jarfile="${tomcat-dbcp-src.jar}"
-      filesDir="${tomcat-dbcp.home}/src/java"
-      filesId="files.tomcat-dbcp" />
-  </target>
-
   <!-- =============== Utility Targets to support downloads ================ -->
 
   <target name="proxyflags">

==================================================
BasicDataSource.java
new file mode 100644
index 0000000000..fee75f03d8
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/AbandonedTrace.java
@@ -0,0 +1,169 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.tomcat.dbcp.pool2.TrackedUse;
+
+/**
+ * Tracks db connection usage for recovering and reporting
+ * abandoned db connections.
+ *
+ * The JDBC Connection, Statement, and ResultSet classes
+ * extend this class.
+ *
+ * @author Glenn L. Nielsen
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class AbandonedTrace implements TrackedUse {
+
+    /** A list of objects created by children of this object */
+    private final List<WeakReference<AbandonedTrace>> traceList = new ArrayList<>();
+    /** Last time this connection was used */
+    private volatile long lastUsed = 0;
+
+    /**
+     * Create a new AbandonedTrace without config and
+     * without doing abandoned tracing.
+     */
+    public AbandonedTrace() {
+        init(null);
+    }
+
+    /**
+     * Construct a new AbandonedTrace with a parent object.
+     *
+     * @param parent AbandonedTrace parent object
+     */
+    public AbandonedTrace(AbandonedTrace parent) {
+        init(parent);
+    }
+
+    /**
+     * Initialize abandoned tracing for this object.
+     *
+     * @param parent AbandonedTrace parent object
+     */
+    private void init(AbandonedTrace parent) {
+        if (parent != null) {
+            parent.addTrace(this);
+        }
+    }
+
+    /**
+     * Get the last time this object was used in ms.
+     *
+     * @return long time in ms
+     */
+    @Override
+    public long getLastUsed() {
+        return lastUsed;
+    }
+
+    /**
+     * Set the time this object was last used to the
+     * current time in ms.
+     */
+    protected void setLastUsed() {
+        lastUsed = System.currentTimeMillis();
+    }
+
+    /**
+     * Set the time in ms this object was last used.
+     *
+     * @param time time in ms
+     */
+    protected void setLastUsed(long time) {
+        lastUsed = time;
+    }
+
+    /**
+     * Add an object to the list of objects being
+     * traced.
+     *
+     * @param trace AbandonedTrace object to add
+     */
+    protected void addTrace(AbandonedTrace trace) {
+        synchronized (this.traceList) {
+            this.traceList.add(new WeakReference<>(trace));
+        }
+        setLastUsed();
+    }
+
+    /**
+     * Clear the list of objects being traced by this
+     * object.
+     */
+    protected void clearTrace() {
+        synchronized(this.traceList) {
+            this.traceList.clear();
+        }
+    }
+
+    /**
+     * Get a list of objects being traced by this object.
+     *
+     * @return List of objects
+     */
+    protected List<AbandonedTrace> getTrace() {
+        int size = traceList.size();
+        if (size == 0) {
+            return Collections.emptyList();
+        }
+        ArrayList<AbandonedTrace> result = new ArrayList<>(size);
+        synchronized (this.traceList) {
+            Iterator<WeakReference<AbandonedTrace>> iter = traceList.iterator();
+            while (iter.hasNext()) {
+                WeakReference<AbandonedTrace> ref = iter.next();
+                if (ref.get() == null) {
+                    // Clean-up since we are here anyway
+                    iter.remove();
+                } else {
+                    result.add(ref.get());
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Remove a child object this object is tracing.
+     *
+     * @param trace AbandonedTrace object to remove
+     */
+    protected void removeTrace(AbandonedTrace trace) {
+        synchronized(this.traceList) {
+            Iterator<WeakReference<AbandonedTrace>> iter = traceList.iterator();
+            while (iter.hasNext()) {
+                WeakReference<AbandonedTrace> ref = iter.next();
+                if (trace.equals(ref.get())) {
+                    iter.remove();
+                    break;
+                } else if (ref.get() == null) {
+                    // Clean-up since we are here anyway
+                    iter.remove();
+                }
+            }
+        }
+    }
+}

==================================================
BasicDataSourceFactory.java
new file mode 100644
index 0000000000..30be4e7b40
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java
@@ -0,0 +1,2270 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.io.OutputStreamWriter;
+import java.io.PrintWriter;
+import java.lang.management.ManagementFactory;
+import java.nio.charset.StandardCharsets;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
+import java.sql.Connection;
+import java.sql.Driver;
+import java.sql.DriverManager;
+import java.sql.SQLException;
+import java.sql.SQLFeatureNotSupportedException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Properties;
+import java.util.logging.Logger;
+
+import javax.management.InstanceAlreadyExistsException;
+import javax.management.JMException;
+import javax.management.MBeanRegistration;
+import javax.management.MBeanRegistrationException;
+import javax.management.MBeanServer;
+import javax.management.MalformedObjectNameException;
+import javax.management.NotCompliantMBeanException;
+import javax.management.ObjectName;
+import javax.sql.DataSource;
+
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import org.apache.tomcat.dbcp.pool2.PooledObject;
+import org.apache.tomcat.dbcp.pool2.impl.AbandonedConfig;
+import org.apache.tomcat.dbcp.pool2.impl.BaseObjectPoolConfig;
+import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPoolConfig;
+import org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool;
+import org.apache.tomcat.dbcp.pool2.impl.GenericObjectPoolConfig;
+
+/**
+ * <p>Basic implementation of <code>javax.sql.DataSource</code> that is
+ * configured via JavaBeans properties.  This is not the only way to
+ * combine the <em>commons-dbcp</em> and <em>commons-pool</em> packages,
+ * but provides a "one stop shopping" solution for basic requirements.</p>
+ *
+ * @author Glenn L. Nielsen
+ * @author Craig R. McClanahan
+ * @author Dirk Verbeeck
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBeanRegistration {
+
+    private static final Log log = LogFactory.getLog(BasicDataSource.class);
+
+    static {
+        // Attempt to prevent deadlocks - see DBCP - 272
+        DriverManager.getDrivers();
+        try {
+            // Load classes now to prevent AccessControlExceptions later
+            // A number of classes are loaded when getConnection() is called
+            // but the following classes are not loaded and therefore require
+            // explicit loading.
+            if (Utils.IS_SECURITY_ENABLED) {
+                ClassLoader loader = BasicDataSource.class.getClassLoader();
+                String dbcpPackageName = BasicDataSource.class.getPackage().getName();
+                loader.loadClass(dbcpPackageName + ".BasicDataSource$PaGetConnection");
+                loader.loadClass(dbcpPackageName + ".DelegatingCallableStatement");
+                loader.loadClass(dbcpPackageName + ".DelegatingDatabaseMetaData");
+                loader.loadClass(dbcpPackageName + ".DelegatingPreparedStatement");
+                loader.loadClass(dbcpPackageName + ".DelegatingResultSet");
+                loader.loadClass(dbcpPackageName + ".PoolableCallableStatement");
+                loader.loadClass(dbcpPackageName + ".PoolablePreparedStatement");
+                loader.loadClass(dbcpPackageName + ".PoolingConnection$StatementType");
+                loader.loadClass(dbcpPackageName + ".PStmtKey");
+
+                String poolPackageName = PooledObject.class.getPackage().getName();
+                loader.loadClass(poolPackageName + ".impl.LinkedBlockingDeque$Node");
+                loader.loadClass(poolPackageName + ".impl.GenericKeyedObjectPool$ObjectDeque");
+            }
+        } catch (ClassNotFoundException cnfe) {
+            throw new IllegalStateException("Unable to pre-load classes", cnfe);
+        }
+    }
+
+    // ------------------------------------------------------------- Properties
+
+    /**
+     * The default auto-commit state of connections created by this pool.
+     */
+    private volatile Boolean defaultAutoCommit = null;
+
+    /**
+     * Returns the default auto-commit property.
+     *
+     * @return true if default auto-commit is enabled
+     */
+    @Override
+    public Boolean getDefaultAutoCommit() {
+        return defaultAutoCommit;
+    }
+
+    /**
+     * <p>Sets default auto-commit state of connections returned by this
+     * datasource.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param defaultAutoCommit default auto-commit value
+     */
+    public void setDefaultAutoCommit(Boolean defaultAutoCommit) {
+        this.defaultAutoCommit = defaultAutoCommit;
+    }
+
+
+    /**
+     * The default read-only state of connections created by this pool.
+     */
+    private transient Boolean defaultReadOnly = null;
+
+    /**
+     * Returns the default readOnly property.
+     *
+     * @return true if connections are readOnly by default
+     */
+    @Override
+    public Boolean getDefaultReadOnly() {
+        return defaultReadOnly;
+    }
+
+    /**
+     * <p>Sets defaultReadonly property.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param defaultReadOnly default read-only value
+     */
+    public void setDefaultReadOnly(Boolean defaultReadOnly) {
+        this.defaultReadOnly = defaultReadOnly;
+    }
+
+    /**
+     * The default TransactionIsolation state of connections created by this pool.
+     */
+    private volatile int defaultTransactionIsolation =
+        PoolableConnectionFactory.UNKNOWN_TRANSACTIONISOLATION;
+
+    /**
+     * Returns the default transaction isolation state of returned connections.
+     *
+     * @return the default value for transaction isolation state
+     * @see Connection#getTransactionIsolation
+     */
+    @Override
+    public int getDefaultTransactionIsolation() {
+        return this.defaultTransactionIsolation;
+    }
+
+    /**
+     * <p>Sets the default transaction isolation state for returned
+     * connections.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param defaultTransactionIsolation the default transaction isolation
+     * state
+     * @see Connection#getTransactionIsolation
+     */
+    public void setDefaultTransactionIsolation(int defaultTransactionIsolation) {
+        this.defaultTransactionIsolation = defaultTransactionIsolation;
+    }
+
+
+    private Integer defaultQueryTimeout = null;
+
+    /**
+     * Obtain the default query timeout that will be used for {@link java.sql.Statement Statement}s
+     * created from this connection. <code>null</code> means that the driver
+     * default will be used.
+     */
+    public Integer getDefaultQueryTimeout() {
+        return defaultQueryTimeout;
+    }
+
+
+    /**
+     * Set the default query timeout that will be used for {@link java.sql.Statement Statement}s
+     * created from this connection. <code>null</code> means that the driver
+     * default will be used.
+     */
+    public void setDefaultQueryTimeout(Integer defaultQueryTimeout) {
+        this.defaultQueryTimeout = defaultQueryTimeout;
+    }
+
+
+    /**
+     * The default "catalog" of connections created by this pool.
+     */
+    private volatile String defaultCatalog = null;
+
+    /**
+     * Returns the default catalog.
+     *
+     * @return the default catalog
+     */
+    @Override
+    public String getDefaultCatalog() {
+        return this.defaultCatalog;
+    }
+
+    /**
+     * <p>Sets the default catalog.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param defaultCatalog the default catalog
+     */
+    public void setDefaultCatalog(String defaultCatalog) {
+        if (defaultCatalog != null && defaultCatalog.trim().length() > 0) {
+            this.defaultCatalog = defaultCatalog;
+        }
+        else {
+            this.defaultCatalog = null;
+        }
+    }
+
+    /**
+     * The property that controls if the pooled connections cache some state
+     * rather than query the database for current state to improve performance.
+     */
+    private boolean cacheState = true;
+
+    /**
+     * Returns the state caching flag.
+     *
+     * @return  the state caching flag
+     */
+    @Override
+    public boolean getCacheState() {
+        return cacheState;
+    }
+
+    /**
+     * Sets the state caching flag.
+     *
+     * @param cacheState    The new value for the state caching flag
+     */
+    public void setCacheState(boolean cacheState) {
+        this.cacheState = cacheState;
+    }
+
+    /**
+     * The instance of the JDBC Driver to use.
+     */
+    private Driver driver = null;
+
+    /**
+     * Returns the JDBC Driver that has been configured for use by this pool.
+     * <p>
+     * Note: This getter only returns the last value set by a call to
+     * {@link #setDriver(Driver)}. It does not return any driver instance that
+     * may have been created from the value set via
+     * {@link #setDriverClassName(String)}.
+     *
+     * @return the JDBC Driver that has been configured for use by this pool
+     */
+    public synchronized Driver getDriver() {
+        return driver;
+    }
+
+    /**
+     * Sets the JDBC Driver instance to use for this pool.
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param driver
+     */
+    public synchronized void setDriver(Driver driver) {
+        this.driver = driver;
+    }
+
+    /**
+     * The fully qualified Java class name of the JDBC driver to be used.
+     */
+    private String driverClassName = null;
+
+    /**
+     * Returns the jdbc driver class name.
+     * <p>
+     * Note: This getter only returns the last value set by a call to
+     * {@link #setDriverClassName(String)}. It does not return the class name of
+     * any driver that may have been set via {@link #setDriver(Driver)}.
+     *
+     * @return the jdbc driver class name
+     */
+    @Override
+    public synchronized String getDriverClassName() {
+        return this.driverClassName;
+    }
+
+    /**
+     * <p>Sets the jdbc driver class name.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param driverClassName the class name of the jdbc driver
+     */
+    public synchronized void setDriverClassName(String driverClassName) {
+        if (driverClassName != null && driverClassName.trim().length() > 0) {
+            this.driverClassName = driverClassName;
+        }
+        else {
+            this.driverClassName = null;
+        }
+    }
+
+    /**
+     * The class loader instance to use to load the JDBC driver. If not
+     * specified, {@link Class#forName(String)} is used to load the JDBC driver.
+     * If specified, {@link Class#forName(String, boolean, ClassLoader)} is
+     * used.
+     */
+    private ClassLoader driverClassLoader = null;
+
+    /**
+     * Returns the class loader specified for loading the JDBC driver. Returns
+     * <code>null</code> if no class loader has been explicitly specified.
+     * <p>
+     * Note: This getter only returns the last value set by a call to
+     * {@link #setDriverClassLoader(ClassLoader)}. It does not return the class
+     * loader of any driver that may have been set via
+     * {@link #setDriver(Driver)}.
+     */
+    public synchronized ClassLoader getDriverClassLoader() {
+        return this.driverClassLoader;
+    }
+
+    /**
+     * <p>Sets the class loader to be used to load the JDBC driver.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param driverClassLoader the class loader with which to load the JDBC
+     *                          driver
+     */
+    public synchronized void setDriverClassLoader(
+            ClassLoader driverClassLoader) {
+        this.driverClassLoader = driverClassLoader;
+    }
+
+    /**
+     * True means that borrowObject returns the most recently used ("last in")
+     * connection in the pool (if there are idle connections available).  False
+     * means that the pool behaves as a FIFO queue - connections are taken from
+     * the idle instance pool in the order that they are returned to the pool.
+     */
+    private boolean lifo = BaseObjectPoolConfig.DEFAULT_LIFO;
+
+    /**
+     * Returns the LIFO property.
+     *
+     * @return true if connection pool behaves as a LIFO queue.
+     */
+    @Override
+    public synchronized boolean getLifo() {
+        return this.lifo;
+    }
+
+    /**
+     * Sets the LIFO property. True means the pool behaves as a LIFO queue;
+     * false means FIFO.
+     *
+     * @param lifo the new value for the LIFO property
+     *
+     */
+    public synchronized void setLifo(boolean lifo) {
+        this.lifo = lifo;
+        if (connectionPool != null) {
+            connectionPool.setLifo(lifo);
+        }
+    }
+
+    /**
+     * The maximum number of active connections that can be allocated from
+     * this pool at the same time, or negative for no limit.
+     */
+    private int maxTotal = GenericObjectPoolConfig.DEFAULT_MAX_TOTAL;
+
+    /**
+     * <p>Returns the maximum number of active connections that can be
+     * allocated at the same time.
+     * </p>
+     * <p>A negative number means that there is no limit.</p>
+     *
+     * @return the maximum number of active connections
+     */
+    @Override
+    public synchronized int getMaxTotal() {
+        return this.maxTotal;
+    }
+
+    /**
+     * Sets the maximum total number of idle and borrows connections that can be
+     * active at the same time. Use a negative value for no limit.
+     *
+     * @param maxTotal the new value for maxTotal
+     * @see #getMaxTotal()
+     */
+    public synchronized void setMaxTotal(int maxTotal) {
+        this.maxTotal = maxTotal;
+        if (connectionPool != null) {
+            connectionPool.setMaxTotal(maxTotal);
+        }
+    }
+
+    /**
+     * The maximum number of connections that can remain idle in the
+     * pool, without extra ones being destroyed, or negative for no limit.
+     * If maxIdle is set too low on heavily loaded systems it is possible you
+     * will see connections being closed and almost immediately new connections
+     * being opened. This is a result of the active threads momentarily closing
+     * connections faster than they are opening them, causing the number of idle
+     * connections to rise above maxIdle. The best value for maxIdle for heavily
+     * loaded system will vary but the default is a good starting point.
+     */
+    private int maxIdle = GenericObjectPoolConfig.DEFAULT_MAX_IDLE;
+
+    /**
+     * <p>Returns the maximum number of connections that can remain idle in the
+     * pool. Excess idle connections are destroyed on return to the pool.
+     * </p>
+     * <p>A negative value indicates that there is no limit</p>
+     *
+     * @return the maximum number of idle connections
+     */
+    @Override
+    public synchronized int getMaxIdle() {
+        return this.maxIdle;
+    }
+
+    /**
+     * Sets the maximum number of connections that can remain idle in the
+     * pool. Excess idle connections are destroyed on return to the pool.
+     *
+     * @see #getMaxIdle()
+     * @param maxIdle the new value for maxIdle
+     */
+    public synchronized void setMaxIdle(int maxIdle) {
+        this.maxIdle = maxIdle;
+        if (connectionPool != null) {
+            connectionPool.setMaxIdle(maxIdle);
+        }
+    }
+
+    /**
+     * The minimum number of active connections that can remain idle in the
+     * pool, without extra ones being created when the evictor runs, or 0 to create none.
+     * The pool attempts to ensure that minIdle connections are available when the idle object evictor
+     * runs. The value of this property has no effect unless {@link #timeBetweenEvictionRunsMillis}
+     * has a positive value.
+     */
+    private int minIdle = GenericObjectPoolConfig.DEFAULT_MIN_IDLE;
+
+    /**
+     * Returns the minimum number of idle connections in the pool. The pool attempts
+     * to ensure that minIdle connections are available when the idle object evictor
+     * runs. The value of this property has no effect unless {@link #timeBetweenEvictionRunsMillis}
+     * has a positive value.
+     *
+     * @return the minimum number of idle connections
+     * @see GenericObjectPool#getMinIdle()
+     */
+    @Override
+    public synchronized int getMinIdle() {
+        return this.minIdle;
+    }
+
+    /**
+     * Sets the minimum number of idle connections in the pool. The pool attempts
+     * to ensure that minIdle connections are available when the idle object evictor
+     * runs. The value of this property has no effect unless {@link #timeBetweenEvictionRunsMillis}
+     * has a positive value.
+     *
+     * @param minIdle the new value for minIdle
+     * @see GenericObjectPool#setMinIdle(int)
+     */
+    public synchronized void setMinIdle(int minIdle) {
+       this.minIdle = minIdle;
+       if (connectionPool != null) {
+           connectionPool.setMinIdle(minIdle);
+       }
+    }
+
+    /**
+     * The initial number of connections that are created when the pool
+     * is started.
+     */
+    private int initialSize = 0;
+
+    /**
+     * Returns the initial size of the connection pool.
+     *
+     * @return the number of connections created when the pool is initialized
+     */
+    @Override
+    public synchronized int getInitialSize() {
+        return this.initialSize;
+    }
+
+    /**
+     * <p>Sets the initial size of the connection pool.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param initialSize the number of connections created when the pool
+     * is initialized
+     */
+    public synchronized void setInitialSize(int initialSize) {
+        this.initialSize = initialSize;
+    }
+
+    /**
+     * The maximum number of milliseconds that the pool will wait (when there
+     * are no available connections) for a connection to be returned before
+     * throwing an exception, or <= 0 to wait indefinitely.
+     */
+    private long maxWaitMillis =
+            BaseObjectPoolConfig.DEFAULT_MAX_WAIT_MILLIS;
+
+    /**
+     * Returns the maximum number of milliseconds that the pool will wait
+     * for a connection to be returned before throwing an exception. A value
+     * less than or equal to zero means the pool is set to wait indefinitely.
+     *
+     * @return the maxWaitMillis property value
+     */
+    @Override
+    public synchronized long getMaxWaitMillis() {
+        return this.maxWaitMillis;
+    }
+
+    /**
+     * Sets the MaxWaitMillis property. Use -1 to make the pool wait
+     * indefinitely.
+     *
+     * @param maxWaitMillis the new value for MaxWaitMillis
+     * @see #getMaxWaitMillis()
+     */
+    public synchronized void setMaxWaitMillis(long maxWaitMillis) {
+        this.maxWaitMillis = maxWaitMillis;
+        if (connectionPool != null) {
+            connectionPool.setMaxWaitMillis(maxWaitMillis);
+        }
+    }
+
+    /**
+     * Prepared statement pooling for this pool. When this property is set to <code>true</code>
+     * both PreparedStatements and CallableStatements are pooled.
+     */
+    private boolean poolPreparedStatements = false;
+
+    /**
+     * Returns true if we are pooling statements.
+     *
+     * @return true if prepared and callable statements are pooled
+     */
+    @Override
+    public synchronized boolean isPoolPreparedStatements() {
+        return this.poolPreparedStatements;
+    }
+
+    /**
+     * <p>Sets whether to pool statements or not.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param poolingStatements pooling on or off
+     */
+    public synchronized void setPoolPreparedStatements(boolean poolingStatements) {
+        this.poolPreparedStatements = poolingStatements;
+    }
+
+    /**
+     * <p>The maximum number of open statements that can be allocated from
+     * the statement pool at the same time, or negative for no limit.  Since
+     * a connection usually only uses one or two statements at a time, this is
+     * mostly used to help detect resource leaks.</p>
+     *
+     * <p>Note: As of version 1.3, CallableStatements (those produced by {@link Connection#prepareCall})
+     * are pooled along with PreparedStatements (produced by {@link Connection#prepareStatement})
+     * and <code>maxOpenPreparedStatements</code> limits the total number of prepared or callable statements
+     * that may be in use at a given time.</p>
+     */
+    private int maxOpenPreparedStatements =
+        GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL;
+
+    /**
+     * Gets the value of the <code>maxOpenPreparedStatements</code> property.
+     *
+     * @return the maximum number of open statements
+     */
+    @Override
+    public synchronized int getMaxOpenPreparedStatements() {
+        return this.maxOpenPreparedStatements;
+    }
+
+    /**
+     * <p>Sets the value of the <code>maxOpenPreparedStatements</code>
+     * property.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param maxOpenStatements the new maximum number of prepared statements
+     */
+    public synchronized void setMaxOpenPreparedStatements(int maxOpenStatements) {
+        this.maxOpenPreparedStatements = maxOpenStatements;
+    }
+
+    /**
+     * The indication of whether objects will be validated as soon as they have
+     * been created by the pool. If the object fails to validate, the borrow
+     * operation that triggered the creation will fail.
+     */
+    private boolean testOnCreate = false;
+
+    /**
+     * Returns the {@link #testOnCreate} property.
+     *
+     * @return true if objects are validated immediately after they are created
+     * by the pool
+     *
+     * @see #testOnCreate
+     */
+    @Override
+    public synchronized boolean getTestOnCreate() {
+        return this.testOnCreate;
+    }
+
+    /**
+     * Sets the {@link #testOnCreate} property. This property determines
+     * whether or not the pool will validate objects immediately after they are
+     * created by the pool
+     *
+     * @param testOnCreate new value for testOnCreate property
+     */
+    public synchronized void setTestOnCreate(boolean testOnCreate) {
+        this.testOnCreate = testOnCreate;
+        if (connectionPool != null) {
+            connectionPool.setTestOnCreate(testOnCreate);
+        }
+    }
+
+    /**
+     * The indication of whether objects will be validated before being
+     * borrowed from the pool.  If the object fails to validate, it will be
+     * dropped from the pool, and we will attempt to borrow another.
+     */
+    private boolean testOnBorrow = true;
+
+    /**
+     * Returns the {@link #testOnBorrow} property.
+     *
+     * @return true if objects are validated before being borrowed from the
+     * pool
+     *
+     * @see #testOnBorrow
+     */
+    @Override
+    public synchronized boolean getTestOnBorrow() {
+        return this.testOnBorrow;
+    }
+
+    /**
+     * Sets the {@link #testOnBorrow} property. This property determines
+     * whether or not the pool will validate objects before they are borrowed
+     * from the pool.
+     *
+     * @param testOnBorrow new value for testOnBorrow property
+     */
+    public synchronized void setTestOnBorrow(boolean testOnBorrow) {
+        this.testOnBorrow = testOnBorrow;
+        if (connectionPool != null) {
+            connectionPool.setTestOnBorrow(testOnBorrow);
+        }
+    }
+
+    /**
+     * The indication of whether objects will be validated before being
+     * returned to the pool.
+     */
+    private boolean testOnReturn = false;
+
+    /**
+     * Returns the value of the {@link #testOnReturn} property.
+     *
+     * @return true if objects are validated before being returned to the
+     * pool
+     * @see #testOnReturn
+     */
+    public synchronized boolean getTestOnReturn() {
+        return this.testOnReturn;
+    }
+
+    /**
+     * Sets the <code>testOnReturn</code> property. This property determines
+     * whether or not the pool will validate objects before they are returned
+     * to the pool.
+     *
+     * @param testOnReturn new value for testOnReturn property
+     */
+    public synchronized void setTestOnReturn(boolean testOnReturn) {
+        this.testOnReturn = testOnReturn;
+        if (connectionPool != null) {
+            connectionPool.setTestOnReturn(testOnReturn);
+        }
+    }
+
+    /**
+     * The number of milliseconds to sleep between runs of the idle object
+     * evictor thread.  When non-positive, no idle object evictor thread will
+     * be run.
+     */
+    private long timeBetweenEvictionRunsMillis =
+        BaseObjectPoolConfig.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
+
+    /**
+     * Returns the value of the {@link #timeBetweenEvictionRunsMillis}
+     * property.
+     *
+     * @return the time (in milliseconds) between evictor runs
+     * @see #timeBetweenEvictionRunsMillis
+     */
+    @Override
+    public synchronized long getTimeBetweenEvictionRunsMillis() {
+        return this.timeBetweenEvictionRunsMillis;
+    }
+
+    /**
+     * Sets the {@link #timeBetweenEvictionRunsMillis} property.
+     *
+     * @param timeBetweenEvictionRunsMillis the new time between evictor runs
+     * @see #timeBetweenEvictionRunsMillis
+     */
+    public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
+        this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
+        if (connectionPool != null) {
+            connectionPool.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
+        }
+    }
+
+    /**
+     * The number of objects to examine during each run of the idle object
+     * evictor thread (if any).
+     */
+    private int numTestsPerEvictionRun =
+        BaseObjectPoolConfig.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
+
+    /**
+     * Returns the value of the {@link #numTestsPerEvictionRun} property.
+     *
+     * @return the number of objects to examine during idle object evictor
+     * runs
+     * @see #numTestsPerEvictionRun
+     */
+    @Override
+    public synchronized int getNumTestsPerEvictionRun() {
+        return this.numTestsPerEvictionRun;
+    }
+
+    /**
+     * Sets the value of the {@link #numTestsPerEvictionRun} property.
+     *
+     * @param numTestsPerEvictionRun the new {@link #numTestsPerEvictionRun}
+     * value
+     * @see #numTestsPerEvictionRun
+     */
+    public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
+        this.numTestsPerEvictionRun = numTestsPerEvictionRun;
+        if (connectionPool != null) {
+            connectionPool.setNumTestsPerEvictionRun(numTestsPerEvictionRun);
+        }
+    }
+
+    /**
+     * The minimum amount of time an object may sit idle in the pool before it
+     * is eligible for eviction by the idle object evictor (if any).
+     */
+    private long minEvictableIdleTimeMillis =
+        BaseObjectPoolConfig.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
+
+    /**
+     * Returns the {@link #minEvictableIdleTimeMillis} property.
+     *
+     * @return the value of the {@link #minEvictableIdleTimeMillis} property
+     * @see #minEvictableIdleTimeMillis
+     */
+    @Override
+    public synchronized long getMinEvictableIdleTimeMillis() {
+        return this.minEvictableIdleTimeMillis;
+    }
+
+    /**
+     * Sets the {@link #minEvictableIdleTimeMillis} property.
+     *
+     * @param minEvictableIdleTimeMillis the minimum amount of time an object
+     * may sit idle in the pool
+     * @see #minEvictableIdleTimeMillis
+     */
+    public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
+        this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
+        if (connectionPool != null) {
+            connectionPool.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
+        }
+    }
+
+    /**
+     * The minimum amount of time a connection may sit idle in the pool before
+     * it is eligible for eviction by the idle object evictor, with the extra
+     * condition that at least "minIdle" connections remain in the pool.
+     * Note that {@code minEvictableIdleTimeMillis} takes precedence over this
+     * parameter.  See {@link #getSoftMinEvictableIdleTimeMillis()}.
+     */
+    private long softMinEvictableIdleTimeMillis =
+        BaseObjectPoolConfig.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
+
+    /**
+     * Sets the minimum amount of time a connection may sit idle in the pool
+     * before it is eligible for eviction by the idle object evictor, with the
+     * extra condition that at least "minIdle" connections remain in the pool.
+     *
+     * @param softMinEvictableIdleTimeMillis minimum amount of time a
+     * connection may sit idle in the pool before it is eligible for eviction,
+     * assuming there are minIdle idle connections in the pool.
+     * @see #getSoftMinEvictableIdleTimeMillis
+     */
+    public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
+        this.softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
+        if (connectionPool != null) {
+            connectionPool.setSoftMinEvictableIdleTimeMillis(softMinEvictableIdleTimeMillis);
+        }
+    }
+
+    /**
+     * <p>Returns the minimum amount of time a connection may sit idle in the
+     * pool before it is eligible for eviction by the idle object evictor, with
+     * the extra condition that at least "minIdle" connections remain in the
+     * pool.</p>
+     *
+     * <p>When {@link #getMinEvictableIdleTimeMillis() miniEvictableIdleTimeMillis}
+     * is set to a positive value, miniEvictableIdleTimeMillis is examined
+     * first by the idle connection evictor - i.e. when idle connections are
+     * visited by the evictor, idle time is first compared against
+     * {@code minEvictableIdleTimeMillis} (without considering the number of idle
+     * connections in the pool) and then against
+     * {@code softMinEvictableIdleTimeMillis}, including the {@code minIdle},
+     * constraint.</p>
+     *
+     * @return minimum amount of time a connection may sit idle in the pool before
+     * it is eligible for eviction, assuming there are minIdle idle connections
+     * in the pool
+     */
+    @Override
+    public synchronized long getSoftMinEvictableIdleTimeMillis() {
+        return softMinEvictableIdleTimeMillis;
+    }
+
+    private String evictionPolicyClassName =
+            BaseObjectPoolConfig.DEFAULT_EVICTION_POLICY_CLASS_NAME;
+
+    /**
+     * Gets the EvictionPolicy implementation in use with this connection pool.
+     */
+    public synchronized String getEvictionPolicyClassName() {
+        return evictionPolicyClassName;
+    }
+
+    /**
+     * Sets the EvictionPolicy implementation to use with this connection pool.
+     *
+     * @param evictionPolicyClassName   The fully qualified class name of the
+     *                                  EvictionPolicy implementation
+     */
+    public synchronized void setEvictionPolicyClassName(
+            String evictionPolicyClassName) {
+        if (connectionPool != null) {
+            connectionPool.setEvictionPolicyClassName(evictionPolicyClassName);
+        }
+        this.evictionPolicyClassName = evictionPolicyClassName;
+    }
+
+    /**
+     * The indication of whether objects will be validated by the idle object
+     * evictor (if any).  If an object fails to validate, it will be dropped
+     * from the pool.
+     */
+    private boolean testWhileIdle = false;
+
+    /**
+     * Returns the value of the {@link #testWhileIdle} property.
+     *
+     * @return true if objects examined by the idle object evictor are
+     * validated
+     * @see #testWhileIdle
+     */
+    @Override
+    public synchronized boolean getTestWhileIdle() {
+        return this.testWhileIdle;
+    }
+
+    /**
+     * Sets the <code>testWhileIdle</code> property. This property determines
+     * whether or not the idle object evictor will validate connections.
+     *
+     * @param testWhileIdle new value for testWhileIdle property
+     */
+    public synchronized void setTestWhileIdle(boolean testWhileIdle) {
+        this.testWhileIdle = testWhileIdle;
+        if (connectionPool != null) {
+            connectionPool.setTestWhileIdle(testWhileIdle);
+        }
+    }
+
+    /**
+     * [Read Only] The current number of active connections that have been
+     * allocated from this data source.
+     *
+     * @return the current number of active connections
+     */
+    @Override
+    public synchronized int getNumActive() {
+        if (connectionPool != null) {
+            return connectionPool.getNumActive();
+        }
+        return 0;
+    }
+
+
+    /**
+     * [Read Only] The current number of idle connections that are waiting
+     * to be allocated from this data source.
+     *
+     * @return the current number of idle connections
+     */
+    @Override
+    public synchronized int getNumIdle() {
+        if (connectionPool != null) {
+            return connectionPool.getNumIdle();
+        }
+        return 0;
+    }
+
+    /**
+     * The connection password to be passed to our JDBC driver to establish
+     * a connection.
+     */
+    private volatile String password = null;
+
+    /**
+     * Returns the password passed to the JDBC driver to establish connections.
+     *
+     * @return the connection password
+     */
+    @Override
+    public String getPassword() {
+        return this.password;
+    }
+
+    /**
+     * <p>Sets the {@link #password}.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param password new value for the password
+     */
+    public void setPassword(String password) {
+        this.password = password;
+    }
+
+    /**
+     * The connection URL to be passed to our JDBC driver to establish
+     * a connection.
+     */
+    private String url = null;
+
+    /**
+     * Returns the JDBC connection {@link #url} property.
+     *
+     * @return the {@link #url} passed to the JDBC driver to establish
+     * connections
+     */
+    @Override
+    public synchronized String getUrl() {
+        return this.url;
+    }
+
+    /**
+     * <p>Sets the {@link #url}.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param url the new value for the JDBC connection url
+     */
+    public synchronized void setUrl(String url) {
+        this.url = url;
+    }
+
+    /**
+     * The connection username to be passed to our JDBC driver to
+     * establish a connection.
+     */
+    private String username = null;
+
+    /**
+     * Returns the JDBC connection {@link #username} property.
+     *
+     * @return the {@link #username} passed to the JDBC driver to establish
+     * connections
+     */
+    @Override
+    public String getUsername() {
+        return this.username;
+    }
+
+    /**
+     * <p>Sets the {@link #username}.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param username the new value for the JDBC connection username
+     */
+    public void setUsername(String username) {
+        this.username = username;
+    }
+
+    /**
+     * The SQL query that will be used to validate connections from this pool
+     * before returning them to the caller.  If specified, this query
+     * <strong>MUST</strong> be an SQL SELECT statement that returns at least
+     * one row. If not specified, {@link Connection#isValid(int)} will be used
+     * to validate connections.
+     */
+    private volatile String validationQuery = null;
+
+    /**
+     * Returns the validation query used to validate connections before
+     * returning them.
+     *
+     * @return the SQL validation query
+     * @see #validationQuery
+     */
+    @Override
+    public String getValidationQuery() {
+        return this.validationQuery;
+    }
+
+    /**
+     * <p>Sets the {@link #validationQuery}.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param validationQuery the new value for the validation query
+     */
+    public void setValidationQuery(String validationQuery) {
+        if (validationQuery != null && validationQuery.trim().length() > 0) {
+            this.validationQuery = validationQuery;
+        } else {
+            this.validationQuery = null;
+        }
+    }
+
+    /**
+     * Timeout in seconds before connection validation queries fail.
+     */
+    private volatile int validationQueryTimeout = -1;
+
+    /**
+     * Returns the validation query timeout.
+     *
+     * @return the timeout in seconds before connection validation queries fail.
+     */
+    @Override
+    public int getValidationQueryTimeout() {
+        return validationQueryTimeout;
+    }
+
+    /**
+     * Sets the validation query timeout, the amount of time, in seconds, that
+     * connection validation will wait for a response from the database when
+     * executing a validation query.  Use a value less than or equal to 0 for
+     * no timeout.
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param timeout new validation query timeout value in seconds
+     */
+    public void setValidationQueryTimeout(int timeout) {
+        this.validationQueryTimeout = timeout;
+    }
+
+    /**
+     * These SQL statements run once after a Connection is created.
+     * <p>
+     * This property can be used for example to run ALTER SESSION SET
+     * NLS_SORT=XCYECH in an Oracle Database only once after connection
+     * creation.
+     * </p>
+     */
+    private volatile List<String> connectionInitSqls;
+
+    /**
+     * Returns the list of SQL statements executed when a physical connection
+     * is first created. Returns an empty list if there are no initialization
+     * statements configured.
+     *
+     * @return initialization SQL statements
+     */
+    public List<String> getConnectionInitSqls() {
+        List<String> result = connectionInitSqls;
+        if (result == null) {
+            return Collections.emptyList();
+        }
+        return result;
+    }
+
+    /**
+     * Provides the same data as {@link #getConnectionInitSqls()} but in an
+     * array so it is accessible via JMX.
+     */
+    @Override
+    public String[] getConnectionInitSqlsAsArray() {
+        Collection<String> result = getConnectionInitSqls();
+        return result.toArray(new String[result.size()]);
+    }
+
+    /**
+     * Sets the list of SQL statements to be executed when a physical
+     * connection is first created.
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param connectionInitSqls Collection of SQL statements to execute
+     * on connection creation
+     */
+    public void setConnectionInitSqls(Collection<String> connectionInitSqls) {
+        if (connectionInitSqls != null && connectionInitSqls.size() > 0) {
+            ArrayList<String> newVal = null;
+            for (String s : connectionInitSqls) {
+            if (s != null && s.trim().length() > 0) {
+                    if (newVal == null) {
+                        newVal = new ArrayList<>();
+                    }
+                    newVal.add(s);
+                }
+            }
+            this.connectionInitSqls = newVal;
+        } else {
+            this.connectionInitSqls = null;
+        }
+    }
+
+
+    /**
+     * Controls access to the underlying connection.
+     */
+    private boolean accessToUnderlyingConnectionAllowed = false;
+
+    /**
+     * Returns the value of the accessToUnderlyingConnectionAllowed property.
+     *
+     * @return true if access to the underlying connection is allowed, false
+     * otherwise.
+     */
+    @Override
+    public synchronized boolean isAccessToUnderlyingConnectionAllowed() {
+        return this.accessToUnderlyingConnectionAllowed;
+    }
+
+    /**
+     * <p>Sets the value of the accessToUnderlyingConnectionAllowed property.
+     * It controls if the PoolGuard allows access to the underlying connection.
+     * (Default: false)</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param allow Access to the underlying connection is granted when true.
+     */
+    public synchronized void setAccessToUnderlyingConnectionAllowed(boolean allow) {
+        this.accessToUnderlyingConnectionAllowed = allow;
+    }
+
+
+    private long maxConnLifetimeMillis = -1;
+
+    /**
+     * Returns the maximum permitted lifetime of a connection in milliseconds. A
+     * value of zero or less indicates an infinite lifetime.
+     */
+    @Override
+    public long getMaxConnLifetimeMillis() {
+        return maxConnLifetimeMillis;
+    }
+
+    /**
+     * <p>Sets the maximum permitted lifetime of a connection in
+     * milliseconds. A value of zero or less indicates an infinite lifetime.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     */
+    public void setMaxConnLifetimeMillis(long maxConnLifetimeMillis) {
+        this.maxConnLifetimeMillis = maxConnLifetimeMillis;
+    }
+
+    private String jmxName = null;
+
+    /**
+     * Returns the JMX name that has been requested for this DataSource. If the
+     * requested name is not valid, an alternative may be chosen.
+     */
+    public String getJmxName() {
+        return jmxName;
+    }
+
+    /**
+     * Sets the JMX name that has been requested for this DataSource. If the
+     * requested name is not valid, an alternative may be chosen. This
+     * DataSource will attempt to register itself using this name. If another
+     * component registers this DataSource with JMX and this name is valid this
+     * name will be used in preference to any specified by the other component.
+     */
+    public void setJmxName(String jmxName) {
+        this.jmxName = jmxName;
+    }
+
+
+    private boolean enableAutoCommitOnReturn = true;
+
+    /**
+     * Returns the value of the flag that controls whether or not connections
+     * being returned to the pool will checked and configured with
+     * {@link Connection#setAutoCommit(boolean) Connection.setAutoCommit(true)}
+     * if the auto commit setting is <code>false</false> when the connection
+     * is returned. It is <code>true</code> by default.
+     */
+    public boolean getEnableAutoCommitOnReturn() {
+        return enableAutoCommitOnReturn;
+    }
+
+    /**
+     * Sets the value of the flag that controls whether or not connections
+     * being returned to the pool will checked and configured with
+     * {@link Connection#setAutoCommit(boolean) Connection.setAutoCommit(true)}
+     * if the auto commit setting is <code>false</false> when the connection
+     * is returned. It is <code>true</code> by default.
+     */
+    public void setEnableAutoCommitOnReturn(boolean enableAutoCommitOnReturn) {
+        this.enableAutoCommitOnReturn = enableAutoCommitOnReturn;
+    }
+
+
+    private boolean rollbackOnReturn = true;
+
+    /**
+     * Gets the current value of the flag that controls if a connection will be
+     * rolled back when it is returned to the pool if auto commit is not enabled
+     * and the connection is not read only.
+     */
+    public boolean getRollbackOnReturn() {
+        return rollbackOnReturn;
+    }
+
+    /**
+     * Sets the flag that controls if a connection will be rolled back when it
+     * is returned to the pool if auto commit is not enabled and the connection
+     * is not read only.
+     */
+    public void setRollbackOnReturn(boolean rollbackOnReturn) {
+        this.rollbackOnReturn = rollbackOnReturn;
+    }
+
+
+    // ----------------------------------------------------- Instance Variables
+
+    /**
+     * The object pool that internally manages our connections.
+     */
+    private volatile GenericObjectPool<PoolableConnection> connectionPool = null;
+
+    protected GenericObjectPool<PoolableConnection> getConnectionPool() {
+        return connectionPool;
+    }
+
+    /**
+     * The connection properties that will be sent to our JDBC driver when
+     * establishing new connections.  <strong>NOTE</strong> - The "user" and
+     * "password" properties will be passed explicitly, so they do not need
+     * to be included here.
+     */
+    private Properties connectionProperties = new Properties();
+
+    // For unit testing
+    Properties getConnectionProperties() {
+        return connectionProperties;
+    }
+
+    /**
+     * The data source we will use to manage connections.  This object should
+     * be acquired <strong>ONLY</strong> by calls to the
+     * <code>createDataSource()</code> method.
+     */
+    private volatile DataSource dataSource = null;
+
+    /**
+     * The PrintWriter to which log messages should be directed.
+     */
+    private volatile PrintWriter logWriter = new PrintWriter(new OutputStreamWriter(
+            System.out, StandardCharsets.UTF_8));
+
+
+    // ----------------------------------------------------- DataSource Methods
+
+
+    /**
+     * Create (if necessary) and return a connection to the database.
+     *
+     * @throws SQLException if a database access error occurs
+     * @return a database connection
+     */
+    @Override
+    public Connection getConnection() throws SQLException {
+        if (Utils.IS_SECURITY_ENABLED) {
+            PrivilegedExceptionAction<Connection> action = new PaGetConnection();
+            try {
+                return AccessController.doPrivileged(action);
+            } catch (PrivilegedActionException e) {
+                Throwable cause = e.getCause();
+                if (cause instanceof SQLException) {
+                    throw (SQLException) cause;
+                }
+                throw new SQLException(e);
+            }
+        }
+        return createDataSource().getConnection();
+    }
+
+
+    /**
+     * <strong>BasicDataSource does NOT support this method. </strong>
+     *
+     * @param user Database user on whose behalf the Connection
+     *   is being made
+     * @param pass The database user's password
+     *
+     * @throws UnsupportedOperationException
+     * @throws SQLException if a database access error occurs
+     * @return nothing - always throws UnsupportedOperationException
+     */
+    @Override
+    public Connection getConnection(String user, String pass) throws SQLException {
+        // This method isn't supported by the PoolingDataSource returned by
+        // the createDataSource
+        throw new UnsupportedOperationException("Not supported by BasicDataSource");
+    }
+
+
+    /**
+     * <strong>BasicDataSource does NOT support this method. </strong>
+     *
+     * <p>Returns the login timeout (in seconds) for connecting to the database.
+     * </p>
+     * <p>Calls {@link #createDataSource()}, so has the side effect
+     * of initializing the connection pool.</p>
+     *
+     * @throws SQLException if a database access error occurs
+     * @throws UnsupportedOperationException If the DataSource implementation
+     *   does not support the login timeout feature.
+     * @return login timeout in seconds
+     */
+    @Override
+    public int getLoginTimeout() throws SQLException {
+        // This method isn't supported by the PoolingDataSource returned by
+        // the createDataSource
+        throw new UnsupportedOperationException("Not supported by BasicDataSource");
+    }
+
+
+    /**
+     * <p>Returns the log writer being used by this data source.</p>
+     * <p>
+     * Calls {@link #createDataSource()}, so has the side effect
+     * of initializing the connection pool.</p>
+     *
+     * @throws SQLException if a database access error occurs
+     * @return log writer in use
+     */
+    @Override
+    public PrintWriter getLogWriter() throws SQLException {
+        return createDataSource().getLogWriter();
+    }
+
+
+    /**
+     * <strong>BasicDataSource does NOT support this method. </strong>
+     *
+     * <p>Set the login timeout (in seconds) for connecting to the
+     * database.</p>
+     * <p>
+     * Calls {@link #createDataSource()}, so has the side effect
+     * of initializing the connection pool.</p>
+     *
+     * @param loginTimeout The new login timeout, or zero for no timeout
+     * @throws UnsupportedOperationException If the DataSource implementation
+     *   does not support the login timeout feature.
+     * @throws SQLException if a database access error occurs
+     */
+    @Override
+    public void setLoginTimeout(int loginTimeout) throws SQLException {
+        // This method isn't supported by the PoolingDataSource returned by
+        // the createDataSource
+        throw new UnsupportedOperationException("Not supported by BasicDataSource");
+    }
+
+
+    /**
+     * <p>Sets the log writer being used by this data source.</p>
+     * <p>
+     * Calls {@link #createDataSource()}, so has the side effect
+     * of initializing the connection pool.</p>
+     *
+     * @param logWriter The new log writer
+     * @throws SQLException if a database access error occurs
+     */
+    @Override
+    public void setLogWriter(PrintWriter logWriter) throws SQLException {
+        createDataSource().setLogWriter(logWriter);
+        this.logWriter = logWriter;
+    }
+
+    private AbandonedConfig abandonedConfig;
+
+    /**
+     * <p>Flag to remove abandoned connections if they exceed the
+     * removeAbandonedTimeout when borrowObject is invoked.</p>
+     *
+     * <p>The default value is false.<p>
+     *
+     * <p>If set to true a connection is considered abandoned and eligible
+     * for removal if it has not been used for more than
+     * {@link #getRemoveAbandonedTimeout() removeAbandonedTimeout} seconds.</p>
+     *
+     * <p>Abandoned connections are identified and removed when
+     * {@link #getConnection()} is invoked and the following conditions hold
+     * <ul><li>{@link #getRemoveAbandonedOnBorrow()} or
+     *         {@link #getRemoveAbandonedOnMaintenance()} = true</li>
+     *     <li>{@link #getNumActive()} > {@link #getMaxTotal()} - 3 </li>
+     *     <li>{@link #getNumIdle()} < 2 </li></ul></p>
+     *
+     * @see #getRemoveAbandonedTimeout()
+     */
+    @Override
+    public boolean getRemoveAbandonedOnBorrow() {
+        if (abandonedConfig != null) {
+            return abandonedConfig.getRemoveAbandonedOnBorrow();
+        }
+        return false;
+    }
+
+    /**
+     * <p>Flag to remove abandoned connections if they exceed the
+     * removeAbandonedTimeout when borrowObject is invoked.</p>
+     *
+     * <p>If set to true a connection is considered abandoned and eligible
+     * for removal if it has been idle longer than the
+     * {@link #getRemoveAbandonedTimeout() removeAbandonedTimeout}.</p>
+     *
+     * <p>Setting this to true can recover db connections from poorly written
+     * applications which fail to close a connection.</p>
+     *
+     * @param removeAbandonedOnMaintenance true means abandoned connections will
+     *                                     be removed when borrowObject is
+     *                                     invoked
+     */
+    public void setRemoveAbandonedOnMaintenance(
+            boolean removeAbandonedOnMaintenance) {
+        if (abandonedConfig == null) {
+            abandonedConfig = new AbandonedConfig();
+        }
+        abandonedConfig.setRemoveAbandonedOnMaintenance(
+                removeAbandonedOnMaintenance);
+    }
+
+    /**
+     * <p>Flag to remove abandoned connections if they exceed the
+     * removeAbandonedTimeout during pool maintenance.</p>
+     *
+     * <p>The default value is false.<p>
+     *
+     * <p>If set to true a connection is considered abandoned and eligible
+     * for removal if it has not been used for more than
+     * {@link #getRemoveAbandonedTimeout() removeAbandonedTimeout} seconds.</p>
+     *
+     * <p>Abandoned connections are identified and removed when
+     * {@link #getConnection()} is invoked and the following conditions hold
+     * <ul><li>{@link #getRemoveAbandonedOnBorrow()} or
+     *         {@link #getRemoveAbandonedOnMaintenance()} = true</li>
+     *     <li>{@link #getNumActive()} > {@link #getMaxTotal()} - 3 </li>
+     *     <li>{@link #getNumIdle()} < 2 </li></ul></p>
+     *
+     * @see #getRemoveAbandonedTimeout()
+     */
+    @Override
+    public boolean getRemoveAbandonedOnMaintenance() {
+        if (abandonedConfig != null) {
+            return abandonedConfig.getRemoveAbandonedOnMaintenance();
+        }
+        return false;
+    }
+
+    /**
+     * <p>Flag to remove abandoned connections if they exceed the
+     * removeAbandonedTimeout during pool maintenance.</p>
+     *
+     * <p>If set to true a connection is considered abandoned and eligible
+     * for removal if it has been idle longer than the
+     * {@link #getRemoveAbandonedTimeout() removeAbandonedTimeout}.</p>
+     *
+     * <p>Setting this to true can recover db connections from poorly written
+     * applications which fail to close a connection.</p>
+     *
+     * @param removeAbandonedOnBorrow true means abandoned connections will be
+     *                                removed during pool maintenance
+     */
+    public void setRemoveAbandonedOnBorrow(boolean removeAbandonedOnBorrow) {
+        if (abandonedConfig == null) {
+            abandonedConfig = new AbandonedConfig();
+        }
+        abandonedConfig.setRemoveAbandonedOnBorrow(removeAbandonedOnBorrow);
+    }
+
+    /**
+     * <p>Timeout in seconds before an abandoned connection can be removed.</p>
+     *
+     * <p>Creating a Statement, PreparedStatement or CallableStatement or using
+     * one of these to execute a query (using one of the execute methods)
+     * resets the lastUsed property of the parent connection.</p>
+     *
+     * <p>Abandoned connection cleanup happens when
+     * <code><ul>
+     * <li>{@link #getRemoveAbandonedOnBorrow()} or
+     *     {@link #getRemoveAbandonedOnMaintenance()} = true</li>
+     * <li>{@link #getNumIdle() numIdle} &lt; 2</li>
+     * <li>{@link #getNumActive() numActive} &gt; {@link #getMaxTotal() maxTotal} - 3</li>
+     * </ul></code></p>
+     *
+     * <p>The default value is 300 seconds.</p>
+     */
+    @Override
+    public int getRemoveAbandonedTimeout() {
+        if (abandonedConfig != null) {
+            return abandonedConfig.getRemoveAbandonedTimeout();
+        }
+        return 300;
+    }
+
+    /**
+     * <p>Sets the timeout in seconds before an abandoned connection can be
+     * removed.</p>
+     *
+     * <p>Setting this property has no effect if
+     * {@link #getRemoveAbandonedOnBorrow()} and
+     * {@link #getRemoveAbandonedOnMaintenance()} are false.</p>
+     *
+     * @param removeAbandonedTimeout new abandoned timeout in seconds
+     * @see #getRemoveAbandonedTimeout()
+     * @see #getRemoveAbandonedOnBorrow()
+     * @see #getRemoveAbandonedOnMaintenance()
+     */
+    public void setRemoveAbandonedTimeout(int removeAbandonedTimeout) {
+        if (abandonedConfig == null) {
+            abandonedConfig = new AbandonedConfig();
+        }
+        abandonedConfig.setRemoveAbandonedTimeout(removeAbandonedTimeout);
+    }
+
+    /**
+     * <p>Flag to log stack traces for application code which abandoned
+     * a Statement or Connection.
+     * </p>
+     * <p>Defaults to false.
+     * </p>
+     * <p>Logging of abandoned Statements and Connections adds overhead
+     * for every Connection open or new Statement because a stack
+     * trace has to be generated. </p>
+     */
+    @Override
+    public boolean getLogAbandoned() {
+        if (abandonedConfig != null) {
+            return abandonedConfig.getLogAbandoned();
+        }
+        return false;
+    }
+
+    /**
+     * @param logAbandoned new logAbandoned property value
+     */
+    public void setLogAbandoned(boolean logAbandoned) {
+        if (abandonedConfig == null) {
+            abandonedConfig = new AbandonedConfig();
+        }
+        abandonedConfig.setLogAbandoned(logAbandoned);
+    }
+
+    /**
+     * Gets the log writer to be used by this configuration to log
+     * information on abandoned objects.
+     */
+    public PrintWriter getAbandonedLogWriter() {
+        if (abandonedConfig != null) {
+            return abandonedConfig.getLogWriter();
+        }
+        return null;
+    }
+
+    /**
+     * Sets the log writer to be used by this configuration to log
+     * information on abandoned objects.
+     *
+     * @param logWriter The new log writer
+     */
+    public void setAbandonedLogWriter(PrintWriter logWriter) {
+        if (abandonedConfig == null) {
+            abandonedConfig = new AbandonedConfig();
+        }
+        abandonedConfig.setLogWriter(logWriter);
+    }
+
+    /**
+     * If the connection pool implements {@link org.apache.tomcat.dbcp.pool2.UsageTracking UsageTracking}, should the
+     * connection pool record a stack trace every time a method is called on a
+     * pooled connection and retain the most recent stack trace to aid debugging
+     * of abandoned connections?
+     *
+     * @return <code>true</code> if usage tracking is enabled
+     */
+    @Override
+    public boolean getAbandonedUsageTracking() {
+        if (abandonedConfig != null) {
+            return abandonedConfig.getUseUsageTracking();
+        }
+        return false;
+    }
+
+    /**
+     * If the connection pool implements {@link org.apache.tomcat.dbcp.pool2.UsageTracking UsageTracking}, configure
+     * whether the connection pool should record a stack trace every time a
+     * method is called on a pooled connection and retain the most recent stack
+     * trace to aid debugging of abandoned connections.
+     *
+     * @param   usageTracking    A value of <code>true</code> will enable
+     *                              the recording of a stack trace on every use
+     *                              of a pooled connection
+     */
+    public void setAbandonedUsageTracking(boolean usageTracking) {
+        if (abandonedConfig == null) {
+            abandonedConfig = new AbandonedConfig();
+        }
+        abandonedConfig.setUseUsageTracking(usageTracking);
+    }
+
+    // --------------------------------------------------------- Public Methods
+
+    /**
+     * Add a custom connection property to the set that will be passed to our
+     * JDBC driver. This <strong>MUST</strong> be called before the first
+     * connection is retrieved (along with all the other configuration
+     * property setters). Calls to this method after the connection pool
+     * has been initialized have no effect.
+     *
+     * @param name Name of the custom connection property
+     * @param value Value of the custom connection property
+     */
+    public void addConnectionProperty(String name, String value) {
+        connectionProperties.put(name, value);
+    }
+
+    /**
+     * Remove a custom connection property.
+     *
+     * @param name Name of the custom connection property to remove
+     * @see #addConnectionProperty(String, String)
+     */
+    public void removeConnectionProperty(String name) {
+        connectionProperties.remove(name);
+    }
+
+    /**
+     * Sets the connection properties passed to driver.connect(...).
+     *
+     * Format of the string must be [propertyName=property;]*
+     *
+     * NOTE - The "user" and "password" properties will be added
+     * explicitly, so they do not need to be included here.
+     *
+     * @param connectionProperties the connection properties used to
+     * create new connections
+     */
+    public void setConnectionProperties(String connectionProperties) {
+        if (connectionProperties == null) {
+            throw new NullPointerException("connectionProperties is null");
+        }
+
+        String[] entries = connectionProperties.split(";");
+        Properties properties = new Properties();
+        for (String entry : entries) {
+            if (entry.length() > 0) {
+                int index = entry.indexOf('=');
+                if (index > 0) {
+                    String name = entry.substring(0, index);
+                    String value = entry.substring(index + 1);
+                    properties.setProperty(name, value);
+                } else {
+                    // no value is empty string which is how java.util.Properties works
+                    properties.setProperty(entry, "");
+                }
+            }
+        }
+        this.connectionProperties = properties;
+    }
+
+    private boolean closed;
+
+    /**
+     * <p>Closes and releases all idle connections that are currently stored in the connection pool
+     * associated with this data source.</p>
+     *
+     * <p>Connections that are checked out to clients when this method is invoked are not affected.
+     * When client applications subsequently invoke {@link Connection#close()} to return
+     * these connections to the pool, the underlying JDBC connections are closed.</p>
+     *
+     * <p>Attempts to acquire connections using {@link #getConnection()} after this method has been
+     * invoked result in SQLExceptions.<p>
+     *
+     * <p>This method is idempotent - i.e., closing an already closed BasicDataSource has no effect
+     * and does not generate exceptions.</p>
+     *
+     * @throws SQLException if an error occurs closing idle connections
+     */
+    public synchronized void close() throws SQLException {
+        if (registeredJmxName != null) {
+            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
+            try {
+                mbs.unregisterMBean(registeredJmxName);
+            } catch (JMException e) {
+                log.warn("Failed to unregister the JMX name: " + registeredJmxName, e);
+            } finally {
+                registeredJmxName = null;
+            }
+        }
+        closed = true;
+        GenericObjectPool<?> oldpool = connectionPool;
+        connectionPool = null;
+        dataSource = null;
+        try {
+            if (oldpool != null) {
+                oldpool.close();
+            }
+        } catch(RuntimeException e) {
+            throw e;
+        } catch(Exception e) {
+            throw new SQLException("Cannot close connection pool", e);
+        }
+    }
+
+    /**
+     * If true, this data source is closed and no more connections can be retrieved from this datasource.
+     * @return true, if the data source is closed; false otherwise
+     */
+    @Override
+    public synchronized boolean isClosed() {
+        return closed;
+    }
+
+    @Override
+    public boolean isWrapperFor(Class<?> iface) throws SQLException {
+        return false;
+    }
+
+    @Override
+    public <T> T unwrap(Class<T> iface) throws SQLException {
+        throw new SQLException("BasicDataSource is not a wrapper.");
+    }
+
+    @Override
+    public Logger getParentLogger() throws SQLFeatureNotSupportedException {
+        throw new SQLFeatureNotSupportedException();
+    }
+
+    // ------------------------------------------------------ Protected Methods
+
+
+    /**
+     * <p>Create (if necessary) and return the internal data source we are
+     * using to manage our connections.</p>
+     *
+     * @throws SQLException if the object pool cannot be created.
+     */
+    protected DataSource createDataSource()
+        throws SQLException {
+        if (closed) {
+            throw new SQLException("Data source is closed");
+        }
+
+        // Return the pool if we have already created it
+        // This is double-checked locking. This is safe since dataSource is
+        // volatile and the code is targeted at Java 5 onwards.
+        if (dataSource != null) {
+            return dataSource;
+        }
+        synchronized (this) {
+            if (dataSource != null) {
+                return dataSource;
+            }
+
+            jmxRegister();
+
+            // create factory which returns raw physical connections
+            ConnectionFactory driverConnectionFactory = createConnectionFactory();
+
+            // Set up the poolable connection factory
+            boolean success = false;
+            PoolableConnectionFactory poolableConnectionFactory;
+            try {
+                poolableConnectionFactory = createPoolableConnectionFactory(
+                        driverConnectionFactory);
+                poolableConnectionFactory.setPoolStatements(
+                        poolPreparedStatements);
+                poolableConnectionFactory.setMaxOpenPrepatedStatements(
+                        maxOpenPreparedStatements);
+                success = true;
+            } catch (SQLException se) {
+                throw se;
+            } catch (RuntimeException rte) {
+                throw rte;
+            } catch (Exception ex) {
+                throw new SQLException("Error creating connection factory", ex);
+            }
+
+            if (success) {
+                // create a pool for our connections
+                createConnectionPool(poolableConnectionFactory);
+            }
+
+            // Create the pooling data source to manage connections
+            success = false;
+            try {
+                dataSource = createDataSourceInstance();
+                dataSource.setLogWriter(logWriter);
+                success = true;
+            } catch (SQLException se) {
+                throw se;
+            } catch (RuntimeException rte) {
+                throw rte;
+            } catch (Exception ex) {
+                throw new SQLException("Error creating datasource", ex);
+            } finally {
+                if (!success) {
+                    closeConnectionPool();
+                }
+            }
+
+            // If initialSize > 0, preload the pool
+            try {
+                for (int i = 0 ; i < initialSize ; i++) {
+                    connectionPool.addObject();
+                }
+            } catch (Exception e) {
+                closeConnectionPool();
+                throw new SQLException("Error preloading the connection pool", e);
+            }
+
+            // If timeBetweenEvictionRunsMillis > 0, start the pool's evictor task
+            startPoolMaintenance();
+
+            return dataSource;
+        }
+    }
+
+    /**
+     * Creates a JDBC connection factory for this datasource.  The JDBC driver
+     * is loaded using the following algorithm:
+     * <ol>
+     * <li>If a Driver instance has been specified via
+     * {@link #setDriver(Driver)} use it</li>
+     * <li>If no Driver instance was specified and {@link #driverClassName} is
+     * specified that class is loaded using the {@link ClassLoader} of this
+     * class or, if {@link #driverClassLoader} is set, {@link #driverClassName}
+     * is loaded with the specified {@link ClassLoader}.</li>
+     * <li>If {@link #driverClassName} is specified and the previous attempt
+     * fails, the class is loaded using the context class loader of the current
+     * thread.</li>
+     * <li>If a driver still isn't loaded one is loaded via the
+     * {@link DriverManager} using the specified {@link #url}.
+     * </ol>
+     * This method exists so subclasses can replace the implementation class.
+     */
+    protected ConnectionFactory createConnectionFactory() throws SQLException {
+        // Load the JDBC driver class
+        Driver driverToUse = this.driver;
+
+        if (driverToUse == null) {
+            Class<?> driverFromCCL = null;
+            if (driverClassName != null) {
+                try {
+                    try {
+                        if (driverClassLoader == null) {
+                            driverFromCCL = Class.forName(driverClassName);
+                        } else {
+                            driverFromCCL = Class.forName(
+                                    driverClassName, true, driverClassLoader);
+                        }
+                    } catch (ClassNotFoundException cnfe) {
+                        driverFromCCL = Thread.currentThread(
+                                ).getContextClassLoader().loadClass(
+                                        driverClassName);
+                    }
+                } catch (Exception t) {
+                    String message = "Cannot load JDBC driver class '" +
+                        driverClassName + "'";
+                    logWriter.println(message);
+                    t.printStackTrace(logWriter);
+                    throw new SQLException(message, t);
+                }
+            }
+
+            try {
+                if (driverFromCCL == null) {
+                    driverToUse = DriverManager.getDriver(url);
+                } else {
+                    // Usage of DriverManager is not possible, as it does not
+                    // respect the ContextClassLoader
+                    // N.B. This cast may cause ClassCastException which is handled below
+                    driverToUse = (Driver) driverFromCCL.newInstance();
+                    if (!driverToUse.acceptsURL(url)) {
+                        throw new SQLException("No suitable driver", "08001");
+                    }
+                }
+            } catch (Exception t) {
+                String message = "Cannot create JDBC driver of class '" +
+                    (driverClassName != null ? driverClassName : "") +
+                    "' for connect URL '" + url + "'";
+                logWriter.println(message);
+                t.printStackTrace(logWriter);
+                throw new SQLException(message, t);
+            }
+        }
+
+        // Set up the driver connection factory we will use
+        String user = username;
+        if (user != null) {
+            connectionProperties.put("user", user);
+        } else {
+            log("DBCP DataSource configured without a 'username'");
+        }
+
+        String pwd = password;
+        if (pwd != null) {
+            connectionProperties.put("password", pwd);
+        } else {
+            log("DBCP DataSource configured without a 'password'");
+        }
+
+        ConnectionFactory driverConnectionFactory =
+                new DriverConnectionFactory(driverToUse, url, connectionProperties);
+        return driverConnectionFactory;
+    }
+
+    /**
+     * Creates a connection pool for this datasource.  This method only exists
+     * so subclasses can replace the implementation class.
+     *
+     * This implementation configures all pool properties other than
+     * timeBetweenEvictionRunsMillis.  Setting that property is deferred to
+     * {@link #startPoolMaintenance()}, since setting timeBetweenEvictionRunsMillis
+     * to a positive value causes {@link GenericObjectPool}'s eviction timer
+     * to be started.
+     */
+    protected void createConnectionPool(PoolableConnectionFactory factory) {
+        // Create an object pool to contain our active connections
+        GenericObjectPoolConfig config = new GenericObjectPoolConfig();
+        updateJmxName(config);
+        GenericObjectPool<PoolableConnection> gop;
+        if (abandonedConfig != null &&
+                (abandonedConfig.getRemoveAbandonedOnBorrow() ||
+                 abandonedConfig.getRemoveAbandonedOnMaintenance())) {
+            gop = new GenericObjectPool<>(factory, config, abandonedConfig);
+        }
+        else {
+            gop = new GenericObjectPool<>(factory, config);
+        }
+        gop.setMaxTotal(maxTotal);
+        gop.setMaxIdle(maxIdle);
+        gop.setMinIdle(minIdle);
+        gop.setMaxWaitMillis(maxWaitMillis);
+        gop.setTestOnCreate(testOnCreate);
+        gop.setTestOnBorrow(testOnBorrow);
+        gop.setTestOnReturn(testOnReturn);
+        gop.setNumTestsPerEvictionRun(numTestsPerEvictionRun);
+        gop.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
+        gop.setTestWhileIdle(testWhileIdle);
+        gop.setLifo(lifo);
+        gop.setSwallowedExceptionListener(new SwallowedExceptionLogger(log));
+        factory.setPool(gop);
+        connectionPool = gop;
+    }
+
+    /**
+     * Closes the connection pool, silently swallowing any exception that occurs.
+     */
+    private void closeConnectionPool() {
+        GenericObjectPool<?> oldpool = connectionPool;
+        connectionPool = null;
+        try {
+            if (oldpool != null) {
+                oldpool.close();
+            }
+        } catch(Exception e) {
+            /* Ignore */
+        }
+    }
+
+    /**
+     * Starts the connection pool maintenance task, if configured.
+     */
+    protected void startPoolMaintenance() {
+        if (connectionPool != null && timeBetweenEvictionRunsMillis > 0) {
+            connectionPool.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
+        }
+    }
+
+    /**
+     * Creates the actual data source instance.  This method only exists so
+     * that subclasses can replace the implementation class.
+     *
+     * @throws SQLException if unable to create a datasource instance
+     */
+    protected DataSource createDataSourceInstance() throws SQLException {
+        PoolingDataSource<PoolableConnection> pds = new PoolingDataSource<>(connectionPool);
+        pds.setAccessToUnderlyingConnectionAllowed(isAccessToUnderlyingConnectionAllowed());
+        return pds;
+    }
+
+    /**
+     * Creates the PoolableConnectionFactory and attaches it to the connection pool.  This method only exists
+     * so subclasses can replace the default implementation.
+     *
+     * @param driverConnectionFactory JDBC connection factory
+     * @throws SQLException if an error occurs creating the PoolableConnectionFactory
+     */
+    protected PoolableConnectionFactory createPoolableConnectionFactory(
+            ConnectionFactory driverConnectionFactory) throws SQLException {
+        PoolableConnectionFactory connectionFactory = null;
+        try {
+            connectionFactory = new PoolableConnectionFactory(driverConnectionFactory, registeredJmxName);
+            connectionFactory.setValidationQuery(validationQuery);
+            connectionFactory.setValidationQueryTimeout(validationQueryTimeout);
+            connectionFactory.setConnectionInitSql(connectionInitSqls);
+            connectionFactory.setDefaultReadOnly(defaultReadOnly);
+            connectionFactory.setDefaultAutoCommit(defaultAutoCommit);
+            connectionFactory.setDefaultTransactionIsolation(defaultTransactionIsolation);
+            connectionFactory.setDefaultCatalog(defaultCatalog);
+            connectionFactory.setCacheState(cacheState);
+            connectionFactory.setPoolStatements(poolPreparedStatements);
+            connectionFactory.setMaxOpenPrepatedStatements(maxOpenPreparedStatements);
+            connectionFactory.setMaxConnLifetimeMillis(maxConnLifetimeMillis);
+            connectionFactory.setRollbackOnReturn(getRollbackOnReturn());
+            connectionFactory.setEnableAutoCommitOnReturn(getEnableAutoCommitOnReturn());
+            connectionFactory.setDefaultQueryTimeout(getDefaultQueryTimeout());
+            validateConnectionFactory(connectionFactory);
+        } catch (RuntimeException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new SQLException("Cannot create PoolableConnectionFactory (" + e.getMessage() + ")", e);
+        }
+        return connectionFactory;
+    }
+
+    protected static void validateConnectionFactory(
+            PoolableConnectionFactory connectionFactory) throws Exception {
+        PoolableConnection conn = null;
+        PooledObject<PoolableConnection> p = null;
+        try {
+            p = connectionFactory.makeObject();
+            conn = p.getObject();
+            connectionFactory.activateObject(p);
+            connectionFactory.validateConnection(conn);
+            connectionFactory.passivateObject(p);
+        }
+        finally {
+            if (p != null) {
+                connectionFactory.destroyObject(p);
+            }
+        }
+    }
+
+    protected void log(String message) {
+        if (logWriter != null) {
+            logWriter.println(message);
+        }
+    }
+
+    /**
+     * Actual name under which this component has been registered.
+     */
+    private ObjectName registeredJmxName = null;
+
+    private void jmxRegister() {
+        // Return immediately if this DataSource has already been registered
+        if (registeredJmxName != null) {
+            return;
+        }
+        // Return immediately if no JMX name has been specified
+        String requestedName = getJmxName();
+        if (requestedName == null) {
+            return;
+        }
+        ObjectName oname;
+        try {
+             oname = new ObjectName(requestedName);
+        } catch (MalformedObjectNameException e) {
+            log.warn("The requested JMX name [" + requestedName +
+                    "] was not valid and will be ignored.");
+            return;
+        }
+
+        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
+        try {
+            mbs.registerMBean(this, oname);
+        } catch (InstanceAlreadyExistsException | MBeanRegistrationException
+                | NotCompliantMBeanException e) {
+            log.warn("Failed to complete JMX registration", e);
+        }
+    }
+
+    @Override
+    public ObjectName preRegister(MBeanServer server, ObjectName name) {
+        String requestedName = getJmxName();
+        if (requestedName != null) {
+            try {
+                registeredJmxName = new ObjectName(requestedName);
+            } catch (MalformedObjectNameException e) {
+                log.warn("The requested JMX name [" + requestedName +
+                        "] was not valid and will be ignored.");
+            }
+        }
+        if (registeredJmxName == null) {
+            registeredJmxName = name;
+        }
+        return registeredJmxName;
+    }
+
+    @Override
+    public void postRegister(Boolean registrationDone) {
+        // NO-OP
+    }
+
+    @Override
+    public void preDeregister() throws Exception {
+        // NO-OP
+    }
+
+    @Override
+    public void postDeregister() {
+        // NO-OP
+    }
+
+    private void updateJmxName(GenericObjectPoolConfig config) {
+        if (registeredJmxName == null) {
+            return;
+        }
+        StringBuilder base = new StringBuilder(registeredJmxName.toString());
+        base.append(Constants.JMX_CONNECTION_POOL_BASE_EXT);
+        config.setJmxNameBase(base.toString());
+        config.setJmxNamePrefix(Constants.JMX_CONNECTION_POOL_PREFIX);
+    }
+
+    protected ObjectName getRegisteredJmxName() {
+        return registeredJmxName;
+    }
+
+    /**
+     * @since 2.0
+     */
+    private class PaGetConnection implements PrivilegedExceptionAction<Connection> {
+
+        @Override
+        public Connection run() throws SQLException {
+            return createDataSource().getConnection();
+        }
+    }
+}

==================================================
BasicDataSourceMXBean.java
new file mode 100644
index 0000000000..71d9484936
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSourceFactory.java
@@ -0,0 +1,461 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.io.ByteArrayInputStream;
+import java.nio.charset.StandardCharsets;
+import java.sql.Connection;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Enumeration;
+import java.util.Hashtable;
+import java.util.Properties;
+import java.util.StringTokenizer;
+
+import javax.naming.Context;
+import javax.naming.Name;
+import javax.naming.RefAddr;
+import javax.naming.Reference;
+import javax.naming.spi.ObjectFactory;
+
+/**
+ * <p>JNDI object factory that creates an instance of
+ * <code>BasicDataSource</code> that has been configured based on the
+ * <code>RefAddr</code> values of the specified <code>Reference</code>, which
+ * must match the names and data types of the <code>BasicDataSource</code> bean
+ * properties with the following exceptions:</p>
+ * <ul>
+ * <li><code>connectionInitSqls</code> must be passed to this factory as a
+ *     single String using semi-colon to delimt the statements whereas
+ *     <code>BasicDataSource</code> requires a collection of Strings.</li>
+ * </ul>
+ *
+ * @author Craig R. McClanahan
+ * @author Dirk Verbeeck
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class BasicDataSourceFactory implements ObjectFactory {
+
+    private static final String PROP_DEFAULTAUTOCOMMIT = "defaultAutoCommit";
+    private static final String PROP_DEFAULTREADONLY = "defaultReadOnly";
+    private static final String PROP_DEFAULTTRANSACTIONISOLATION = "defaultTransactionIsolation";
+    private static final String PROP_DEFAULTCATALOG = "defaultCatalog";
+    private static final String PROP_CACHESTATE ="cacheState";
+    private static final String PROP_DRIVERCLASSNAME = "driverClassName";
+    private static final String PROP_LIFO = "lifo";
+    private static final String PROP_MAXTOTAL = "maxTotal";
+    private static final String PROP_MAXIDLE = "maxIdle";
+    private static final String PROP_MINIDLE = "minIdle";
+    private static final String PROP_INITIALSIZE = "initialSize";
+    private static final String PROP_MAXWAITMILLIS = "maxWaitMillis";
+    private static final String PROP_TESTONCREATE = "testOnCreate";
+    private static final String PROP_TESTONBORROW = "testOnBorrow";
+    private static final String PROP_TESTONRETURN = "testOnReturn";
+    private static final String PROP_TIMEBETWEENEVICTIONRUNSMILLIS = "timeBetweenEvictionRunsMillis";
+    private static final String PROP_NUMTESTSPEREVICTIONRUN = "numTestsPerEvictionRun";
+    private static final String PROP_MINEVICTABLEIDLETIMEMILLIS = "minEvictableIdleTimeMillis";
+    private static final String PROP_SOFTMINEVICTABLEIDLETIMEMILLIS = "softMinEvictableIdleTimeMillis";
+    private static final String PROP_EVICTIONPOLICYCLASSNAME = "evictionPolicyClassName";
+    private static final String PROP_TESTWHILEIDLE = "testWhileIdle";
+    private static final String PROP_PASSWORD = "password";
+    private static final String PROP_URL = "url";
+    private static final String PROP_USERNAME = "username";
+    private static final String PROP_VALIDATIONQUERY = "validationQuery";
+    private static final String PROP_VALIDATIONQUERY_TIMEOUT = "validationQueryTimeout";
+    private static final String PROP_JMX_NAME = "jmxName";
+
+    /**
+     * The property name for connectionInitSqls.
+     * The associated value String must be of the form [query;]*
+     */
+    private static final String PROP_CONNECTIONINITSQLS = "connectionInitSqls";
+    private static final String PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED = "accessToUnderlyingConnectionAllowed";
+    private static final String PROP_REMOVEABANDONEDONBORROW = "removeAbandonedOnBorrow";
+    private static final String PROP_REMOVEABANDONEDONMAINTENANCE = "removeAbandonedOnMaintenance";
+    private static final String PROP_REMOVEABANDONEDTIMEOUT = "removeAbandonedTimeout";
+    private static final String PROP_LOGABANDONED = "logAbandoned";
+    private static final String PROP_POOLPREPAREDSTATEMENTS = "poolPreparedStatements";
+    private static final String PROP_MAXOPENPREPAREDSTATEMENTS = "maxOpenPreparedStatements";
+    private static final String PROP_CONNECTIONPROPERTIES = "connectionProperties";
+    private static final String PROP_MAXCONNLIFETIMEMILLIS = "maxConnLifetimeMillis";
+    private static final String PROP_ROLLBACK_ON_RETURN = "rollbackOnReturn";
+    private static final String PROP_ENABLE_AUTOCOMMIT_ON_RETURN = "enableAutoCommitOnReturn";
+    private static final String PROP_DEFAULT_QUERYTIMEOUT = "defaultQueryTimeout";
+
+    private static final String[] ALL_PROPERTIES = {
+        PROP_DEFAULTAUTOCOMMIT,
+        PROP_DEFAULTREADONLY,
+        PROP_DEFAULTTRANSACTIONISOLATION,
+        PROP_DEFAULTCATALOG,
+        PROP_CACHESTATE,
+        PROP_DRIVERCLASSNAME,
+        PROP_LIFO,
+        PROP_MAXTOTAL,
+        PROP_MAXIDLE,
+        PROP_MINIDLE,
+        PROP_INITIALSIZE,
+        PROP_MAXWAITMILLIS,
+        PROP_TESTONCREATE,
+        PROP_TESTONBORROW,
+        PROP_TESTONRETURN,
+        PROP_TIMEBETWEENEVICTIONRUNSMILLIS,
+        PROP_NUMTESTSPEREVICTIONRUN,
+        PROP_MINEVICTABLEIDLETIMEMILLIS,
+        PROP_SOFTMINEVICTABLEIDLETIMEMILLIS,
+        PROP_EVICTIONPOLICYCLASSNAME,
+        PROP_TESTWHILEIDLE,
+        PROP_PASSWORD,
+        PROP_URL,
+        PROP_USERNAME,
+        PROP_VALIDATIONQUERY,
+        PROP_VALIDATIONQUERY_TIMEOUT,
+        PROP_CONNECTIONINITSQLS,
+        PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED,
+        PROP_REMOVEABANDONEDONBORROW,
+        PROP_REMOVEABANDONEDONMAINTENANCE,
+        PROP_REMOVEABANDONEDTIMEOUT,
+        PROP_LOGABANDONED,
+        PROP_POOLPREPAREDSTATEMENTS,
+        PROP_MAXOPENPREPAREDSTATEMENTS,
+        PROP_CONNECTIONPROPERTIES,
+        PROP_MAXCONNLIFETIMEMILLIS,
+        PROP_ROLLBACK_ON_RETURN,
+        PROP_ENABLE_AUTOCOMMIT_ON_RETURN,
+        PROP_DEFAULT_QUERYTIMEOUT
+    };
+
+    // -------------------------------------------------- ObjectFactory Methods
+
+    /**
+     * <p>Create and return a new <code>BasicDataSource</code> instance.  If no
+     * instance can be created, return <code>null</code> instead.</p>
+     *
+     * @param obj The possibly null object containing location or
+     *  reference information that can be used in creating an object
+     * @param name The name of this object relative to <code>nameCtx</code>
+     * @param nameCtx The context relative to which the <code>name</code>
+     *  parameter is specified, or <code>null</code> if <code>name</code>
+     *  is relative to the default initial context
+     * @param environment The possibly null environment that is used in
+     *  creating this object
+     *
+     * @exception Exception if an exception occurs creating the instance
+     */
+    @Override
+    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?,?> environment)
+        throws Exception {
+
+        // We only know how to deal with <code>javax.naming.Reference</code>s
+        // that specify a class name of "javax.sql.DataSource"
+        if (obj == null || !(obj instanceof Reference)) {
+            return null;
+        }
+        Reference ref = (Reference) obj;
+        if (!"javax.sql.DataSource".equals(ref.getClassName())) {
+            return null;
+        }
+
+        Properties properties = new Properties();
+        for (String propertyName : ALL_PROPERTIES) {
+            RefAddr ra = ref.get(propertyName);
+            if (ra != null) {
+                String propertyValue = ra.getContent().toString();
+                properties.setProperty(propertyName, propertyValue);
+            }
+        }
+
+        return createDataSource(properties);
+    }
+
+    /**
+     * Creates and configures a {@link BasicDataSource} instance based on the
+     * given properties.
+     *
+     * @param properties the datasource configuration properties
+     * @throws Exception if an error occurs creating the data source
+     */
+    public static BasicDataSource createDataSource(Properties properties) throws Exception {
+        BasicDataSource dataSource = new BasicDataSource();
+        String value = null;
+
+        value = properties.getProperty(PROP_DEFAULTAUTOCOMMIT);
+        if (value != null) {
+            dataSource.setDefaultAutoCommit(Boolean.valueOf(value));
+        }
+
+        value = properties.getProperty(PROP_DEFAULTREADONLY);
+        if (value != null) {
+            dataSource.setDefaultReadOnly(Boolean.valueOf(value));
+        }
+
+        value = properties.getProperty(PROP_DEFAULTTRANSACTIONISOLATION);
+        if (value != null) {
+            int level = PoolableConnectionFactory.UNKNOWN_TRANSACTIONISOLATION;
+            if ("NONE".equalsIgnoreCase(value)) {
+                level = Connection.TRANSACTION_NONE;
+            }
+            else if ("READ_COMMITTED".equalsIgnoreCase(value)) {
+                level = Connection.TRANSACTION_READ_COMMITTED;
+            }
+            else if ("READ_UNCOMMITTED".equalsIgnoreCase(value)) {
+                level = Connection.TRANSACTION_READ_UNCOMMITTED;
+            }
+            else if ("REPEATABLE_READ".equalsIgnoreCase(value)) {
+                level = Connection.TRANSACTION_REPEATABLE_READ;
+            }
+            else if ("SERIALIZABLE".equalsIgnoreCase(value)) {
+                level = Connection.TRANSACTION_SERIALIZABLE;
+            }
+            else {
+                try {
+                    level = Integer.parseInt(value);
+                } catch (NumberFormatException e) {
+                    System.err.println("Could not parse defaultTransactionIsolation: " + value);
+                    System.err.println("WARNING: defaultTransactionIsolation not set");
+                    System.err.println("using default value of database driver");
+                    level = PoolableConnectionFactory.UNKNOWN_TRANSACTIONISOLATION;
+                }
+            }
+            dataSource.setDefaultTransactionIsolation(level);
+        }
+
+        value = properties.getProperty(PROP_DEFAULTCATALOG);
+        if (value != null) {
+            dataSource.setDefaultCatalog(value);
+        }
+
+        value = properties.getProperty(PROP_CACHESTATE);
+        if (value != null) {
+            dataSource.setCacheState(Boolean.valueOf(value).booleanValue());
+        }
+
+        value = properties.getProperty(PROP_DRIVERCLASSNAME);
+        if (value != null) {
+            dataSource.setDriverClassName(value);
+        }
+
+        value = properties.getProperty(PROP_LIFO);
+        if (value != null) {
+            dataSource.setLifo(Boolean.valueOf(value).booleanValue());
+        }
+
+        value = properties.getProperty(PROP_MAXTOTAL);
+        if (value != null) {
+            dataSource.setMaxTotal(Integer.parseInt(value));
+        }
+
+        value = properties.getProperty(PROP_MAXIDLE);
+        if (value != null) {
+            dataSource.setMaxIdle(Integer.parseInt(value));
+        }
+
+        value = properties.getProperty(PROP_MINIDLE);
+        if (value != null) {
+            dataSource.setMinIdle(Integer.parseInt(value));
+        }
+
+        value = properties.getProperty(PROP_INITIALSIZE);
+        if (value != null) {
+            dataSource.setInitialSize(Integer.parseInt(value));
+        }
+
+        value = properties.getProperty(PROP_MAXWAITMILLIS);
+        if (value != null) {
+            dataSource.setMaxWaitMillis(Long.parseLong(value));
+        }
+
+        value = properties.getProperty(PROP_TESTONCREATE);
+        if (value != null) {
+            dataSource.setTestOnCreate(Boolean.valueOf(value).booleanValue());
+        }
+
+        value = properties.getProperty(PROP_TESTONBORROW);
+        if (value != null) {
+            dataSource.setTestOnBorrow(Boolean.valueOf(value).booleanValue());
+        }
+
+        value = properties.getProperty(PROP_TESTONRETURN);
+        if (value != null) {
+            dataSource.setTestOnReturn(Boolean.valueOf(value).booleanValue());
+        }
+
+        value = properties.getProperty(PROP_TIMEBETWEENEVICTIONRUNSMILLIS);
+        if (value != null) {
+            dataSource.setTimeBetweenEvictionRunsMillis(Long.parseLong(value));
+        }
+
+        value = properties.getProperty(PROP_NUMTESTSPEREVICTIONRUN);
+        if (value != null) {
+            dataSource.setNumTestsPerEvictionRun(Integer.parseInt(value));
+        }
+
+        value = properties.getProperty(PROP_MINEVICTABLEIDLETIMEMILLIS);
+        if (value != null) {
+            dataSource.setMinEvictableIdleTimeMillis(Long.parseLong(value));
+        }
+
+        value = properties.getProperty(PROP_SOFTMINEVICTABLEIDLETIMEMILLIS);
+        if (value != null) {
+            dataSource.setSoftMinEvictableIdleTimeMillis(Long.parseLong(value));
+        }
+
+        value = properties.getProperty(PROP_EVICTIONPOLICYCLASSNAME);
+        if (value != null) {
+            dataSource.setEvictionPolicyClassName(value);
+        }
+
+        value = properties.getProperty(PROP_TESTWHILEIDLE);
+        if (value != null) {
+            dataSource.setTestWhileIdle(Boolean.valueOf(value).booleanValue());
+        }
+
+        value = properties.getProperty(PROP_PASSWORD);
+        if (value != null) {
+            dataSource.setPassword(value);
+        }
+
+        value = properties.getProperty(PROP_URL);
+        if (value != null) {
+            dataSource.setUrl(value);
+        }
+
+        value = properties.getProperty(PROP_USERNAME);
+        if (value != null) {
+            dataSource.setUsername(value);
+        }
+
+        value = properties.getProperty(PROP_VALIDATIONQUERY);
+        if (value != null) {
+            dataSource.setValidationQuery(value);
+        }
+
+        value = properties.getProperty(PROP_VALIDATIONQUERY_TIMEOUT);
+        if (value != null) {
+            dataSource.setValidationQueryTimeout(Integer.parseInt(value));
+        }
+
+        value = properties.getProperty(PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED);
+        if (value != null) {
+            dataSource.setAccessToUnderlyingConnectionAllowed(Boolean.valueOf(value).booleanValue());
+        }
+
+        value = properties.getProperty(PROP_REMOVEABANDONEDONBORROW);
+        if (value != null) {
+            dataSource.setRemoveAbandonedOnBorrow(Boolean.valueOf(value).booleanValue());
+        }
+
+        value = properties.getProperty(PROP_REMOVEABANDONEDONMAINTENANCE);
+        if (value != null) {
+            dataSource.setRemoveAbandonedOnMaintenance(Boolean.valueOf(value).booleanValue());
+        }
+
+        value = properties.getProperty(PROP_REMOVEABANDONEDTIMEOUT);
+        if (value != null) {
+            dataSource.setRemoveAbandonedTimeout(Integer.parseInt(value));
+        }
+
+        value = properties.getProperty(PROP_LOGABANDONED);
+        if (value != null) {
+            dataSource.setLogAbandoned(Boolean.valueOf(value).booleanValue());
+        }
+
+        value = properties.getProperty(PROP_POOLPREPAREDSTATEMENTS);
+        if (value != null) {
+            dataSource.setPoolPreparedStatements(Boolean.valueOf(value).booleanValue());
+        }
+
+        value = properties.getProperty(PROP_MAXOPENPREPAREDSTATEMENTS);
+        if (value != null) {
+            dataSource.setMaxOpenPreparedStatements(Integer.parseInt(value));
+        }
+
+        value = properties.getProperty(PROP_CONNECTIONINITSQLS);
+        if (value != null) {
+            StringTokenizer tokenizer = new StringTokenizer(value, ";");
+            // Have to jump through these hoops as StringTokenizer implements
+            // Enumeration<Object> rather than Enumeration<String>
+            Collection<String> tokens =
+                    new ArrayList<>(tokenizer.countTokens());
+            while (tokenizer.hasMoreTokens()) {
+                tokens.add(tokenizer.nextToken());
+            }
+            dataSource.setConnectionInitSqls(tokens);
+        }
+
+        value = properties.getProperty(PROP_CONNECTIONPROPERTIES);
+        if (value != null) {
+          Properties p = getProperties(value);
+          Enumeration<?> e = p.propertyNames();
+          while (e.hasMoreElements()) {
+            String propertyName = (String) e.nextElement();
+            dataSource.addConnectionProperty(propertyName, p.getProperty(propertyName));
+          }
+        }
+
+        value = properties.getProperty(PROP_MAXCONNLIFETIMEMILLIS);
+        if (value != null) {
+            dataSource.setMaxConnLifetimeMillis(Long.parseLong(value));
+        }
+
+        value = properties.getProperty(PROP_JMX_NAME);
+        if (value != null) {
+            dataSource.setJmxName(value);
+        }
+
+        value = properties.getProperty(PROP_ENABLE_AUTOCOMMIT_ON_RETURN);
+        if (value != null) {
+            dataSource.setEnableAutoCommitOnReturn(Boolean.valueOf(value).booleanValue());
+        }
+
+        value = properties.getProperty(PROP_ROLLBACK_ON_RETURN);
+        if (value != null) {
+            dataSource.setRollbackOnReturn(Boolean.valueOf(value).booleanValue());
+        }
+
+        value = properties.getProperty(PROP_DEFAULT_QUERYTIMEOUT);
+        if (value != null) {
+            dataSource.setDefaultQueryTimeout(Integer.valueOf(value));
+        }
+
+
+        // DBCP-215
+        // Trick to make sure that initialSize connections are created
+        if (dataSource.getInitialSize() > 0) {
+            dataSource.getLogWriter();
+        }
+
+        // Return the configured DataSource instance
+        return dataSource;
+    }
+
+    /**
+     * <p>Parse properties from the string. Format of the string must be [propertyName=property;]*<p>
+     * @param propText
+     * @return Properties
+     * @throws Exception
+     */
+    private static Properties getProperties(String propText) throws Exception {
+      Properties p = new Properties();
+      if (propText != null) {
+        p.load(new ByteArrayInputStream(
+                propText.replace(';', '\n').getBytes(StandardCharsets.ISO_8859_1)));
+      }
+      return p;
+    }
+}

==================================================
ConnectionFactory.java
new file mode 100644
index 0000000000..88a75f4654
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSourceMXBean.java
@@ -0,0 +1,247 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2;
+
+/**
+ * Defines the methods that will be made available via JMX.
+ *
+ * @since 2.0
+ */
+public interface BasicDataSourceMXBean {
+
+    /**
+     * See {@link BasicDataSource#getAbandonedUsageTracking()}
+     * @return {@link BasicDataSource#getAbandonedUsageTracking()}
+     */
+    boolean getAbandonedUsageTracking();
+
+    /**
+     * See {@link BasicDataSource#getDefaultAutoCommit()}
+     * @return {@link BasicDataSource#getDefaultAutoCommit()}
+     */
+    Boolean getDefaultAutoCommit();
+
+    /**
+     * See {@link BasicDataSource#getDefaultReadOnly()}
+     * @return {@link BasicDataSource#getDefaultReadOnly()}
+     */
+    Boolean getDefaultReadOnly();
+
+    /**
+     * See {@link BasicDataSource#getDefaultTransactionIsolation()}
+     * @return {@link BasicDataSource#getDefaultTransactionIsolation()}
+     */
+    int getDefaultTransactionIsolation();
+
+    /**
+     * See {@link BasicDataSource#getDefaultCatalog()}
+     * @return {@link BasicDataSource#getDefaultCatalog()}
+     */
+    String getDefaultCatalog();
+
+    /**
+     * See {@link BasicDataSource#getCacheState()}
+     * @return {@link BasicDataSource#getCacheState()}
+     */
+    boolean getCacheState();
+
+    /**
+     * See {@link BasicDataSource#getDriverClassName()}
+     * @return {@link BasicDataSource#getDriverClassName()}
+     */
+    String getDriverClassName();
+
+    /**
+     * See {@link BasicDataSource#getLifo()}
+     * @return {@link BasicDataSource#getLifo()}
+     */
+    boolean getLifo();
+
+    /**
+     * See {@link BasicDataSource#getMaxTotal()}
+     * @return {@link BasicDataSource#getMaxTotal()}
+     */
+    int getMaxTotal();
+
+    /**
+     * See {@link BasicDataSource#getMaxIdle()}
+     * @return {@link BasicDataSource#getMaxIdle()}
+     */
+    int getMaxIdle();
+
+    /**
+     * See {@link BasicDataSource#getMinIdle()}
+     * @return {@link BasicDataSource#getMinIdle()}
+     */
+    int getMinIdle();
+
+    /**
+     * See {@link BasicDataSource#getInitialSize()}
+     * @return {@link BasicDataSource#getInitialSize()}
+     */
+    int getInitialSize();
+
+    /**
+     * See {@link BasicDataSource#getMaxWaitMillis()}
+     * @return {@link BasicDataSource#getMaxWaitMillis()}
+     */
+    long getMaxWaitMillis();
+
+    /**
+     * See {@link BasicDataSource#isPoolPreparedStatements()}
+     * @return {@link BasicDataSource#isPoolPreparedStatements()}
+     */
+    boolean isPoolPreparedStatements();
+
+    /**
+     * See {@link BasicDataSource#getMaxOpenPreparedStatements()}
+     * @return {@link BasicDataSource#getMaxOpenPreparedStatements()}
+     */
+    int getMaxOpenPreparedStatements();
+
+    /**
+     * See {@link BasicDataSource#getTestOnCreate()}
+     * @return {@link BasicDataSource#getTestOnCreate()}
+     */
+    boolean getTestOnCreate();
+
+    /**
+     * See {@link BasicDataSource#getTestOnBorrow()}
+     * @return {@link BasicDataSource#getTestOnBorrow()}
+     */
+    boolean getTestOnBorrow();
+
+    /**
+     * See {@link BasicDataSource#getTimeBetweenEvictionRunsMillis()}
+     * @return {@link BasicDataSource#getTimeBetweenEvictionRunsMillis()}
+     */
+    long getTimeBetweenEvictionRunsMillis();
+
+    /**
+     * See {@link BasicDataSource#getNumTestsPerEvictionRun()}
+     * @return {@link BasicDataSource#getNumTestsPerEvictionRun()}
+     */
+    int getNumTestsPerEvictionRun();
+
+    /**
+     * See {@link BasicDataSource#getMinEvictableIdleTimeMillis()}
+     * @return {@link BasicDataSource#getMinEvictableIdleTimeMillis()}
+     */
+    long getMinEvictableIdleTimeMillis();
+
+    /**
+     * See {@link BasicDataSource#getSoftMinEvictableIdleTimeMillis()}
+     * @return {@link BasicDataSource#getSoftMinEvictableIdleTimeMillis()}
+     */
+    long getSoftMinEvictableIdleTimeMillis();
+
+    /**
+     * See {@link BasicDataSource#getTestWhileIdle()}
+     * @return {@link BasicDataSource#getTestWhileIdle()}
+     */
+    boolean getTestWhileIdle();
+
+    /**
+     * See {@link BasicDataSource#getNumActive()}
+     * @return {@link BasicDataSource#getNumActive()}
+     */
+    int getNumActive();
+
+    /**
+     * See {@link BasicDataSource#getNumIdle()}
+     * @return {@link BasicDataSource#getNumIdle()}
+     */
+    int getNumIdle();
+
+    /**
+     * See {@link BasicDataSource#getPassword()}
+     * @return {@link BasicDataSource#getPassword()}
+     */
+    String getPassword();
+
+    /**
+     * See {@link BasicDataSource#getUrl()}
+     * @return {@link BasicDataSource#getUrl()}
+     */
+    String getUrl();
+
+    /**
+     * See {@link BasicDataSource#getUsername()}
+     * @return {@link BasicDataSource#getUsername()}
+     */
+    String getUsername();
+
+    /**
+     * See {@link BasicDataSource#getValidationQuery()}
+     * @return {@link BasicDataSource#getValidationQuery()}
+     */
+    String getValidationQuery();
+
+    /**
+     * See {@link BasicDataSource#getValidationQueryTimeout()}
+     * @return {@link BasicDataSource#getValidationQueryTimeout()}
+     */
+    int getValidationQueryTimeout();
+
+    /**
+     * See {@link BasicDataSource#getConnectionInitSqlsAsArray()}
+     * @return {@link BasicDataSource#getConnectionInitSqlsAsArray()}
+     */
+    String[] getConnectionInitSqlsAsArray();
+
+    /**
+     * See {@link BasicDataSource#isAccessToUnderlyingConnectionAllowed()}
+     * @return {@link BasicDataSource#isAccessToUnderlyingConnectionAllowed()}
+     */
+    boolean isAccessToUnderlyingConnectionAllowed();
+
+    /**
+     * See {@link BasicDataSource#getMaxConnLifetimeMillis()}
+     * @return {@link BasicDataSource#getMaxConnLifetimeMillis()}
+     */
+    long getMaxConnLifetimeMillis();
+
+    /**
+     * See {@link BasicDataSource#getRemoveAbandonedOnBorrow()}
+     * @return {@link BasicDataSource#getRemoveAbandonedOnBorrow()}
+     */
+    boolean getRemoveAbandonedOnBorrow();
+
+    /**
+     * See {@link BasicDataSource#getRemoveAbandonedOnMaintenance()}
+     * @return {@link BasicDataSource#getRemoveAbandonedOnMaintenance()}
+     */
+    boolean getRemoveAbandonedOnMaintenance();
+
+    /**
+     * See {@link BasicDataSource#getRemoveAbandonedTimeout()}
+     * @return {@link BasicDataSource#getRemoveAbandonedTimeout()}
+     */
+    int getRemoveAbandonedTimeout();
+
+    /**
+     * See {@link BasicDataSource#getLogAbandoned()}
+     * @return {@link BasicDataSource#getLogAbandoned()}
+     */
+    boolean getLogAbandoned();
+
+    /**
+     * See {@link BasicDataSource#isClosed()}
+     * @return {@link BasicDataSource#isClosed()}
+     */
+    boolean isClosed();
+}

==================================================
Constants.java
new file mode 100644
index 0000000000..0564709f0d
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/ConnectionFactory.java
@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+
+/**
+ * Abstract factory interface for creating {@link java.sql.Connection}s.
+ *
+ * @author Rodney Waldhoff
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public interface ConnectionFactory {
+    /**
+     * Create a new {@link java.sql.Connection} in an
+     * implementation specific fashion.
+     *
+     * @return a new {@link java.sql.Connection}
+     * @throws SQLException if a database error occurs creating the connection
+     */
+    Connection createConnection() throws SQLException;
+}

==================================================
DataSourceConnectionFactory.java
new file mode 100644
index 0000000000..dd3506dafd
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/Constants.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2;
+
+/**
+ * Constants for use with JMX
+ * @since 2.0
+ */
+public class Constants {
+    public static final String JMX_CONNECTION_POOL_BASE_EXT = ",connectionpool=";
+    public static final String JMX_CONNECTION_POOL_PREFIX = "connections";
+
+    public static final String JMX_CONNECTION_BASE_EXT =
+            JMX_CONNECTION_POOL_BASE_EXT +
+            JMX_CONNECTION_POOL_PREFIX +
+            ",connection=";
+
+    public static final String JMX_STATEMENT_POOL_BASE_EXT =
+            JMX_CONNECTION_BASE_EXT;
+    public static final String JMX_STATEMENT_POOL_PREFIX = ",statementpool=statements";
+}

==================================================
DelegatingCallableStatement.java
new file mode 100644
index 0000000000..62fa139aa3
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DataSourceConnectionFactory.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+
+import javax.sql.DataSource;
+
+/**
+ * A {@link DataSource}-based implementation of {@link ConnectionFactory}.
+ *
+ * @author Rodney Waldhoff
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class DataSourceConnectionFactory implements ConnectionFactory {
+    public DataSourceConnectionFactory(DataSource source) {
+        this(source,null,null);
+    }
+
+    public DataSourceConnectionFactory(DataSource source, String uname, String passwd) {
+        _source = source;
+        _uname = uname;
+        _passwd = passwd;
+    }
+
+    @Override
+    public Connection createConnection() throws SQLException {
+        if(null == _uname && null == _passwd) {
+            return _source.getConnection();
+        }
+        return _source.getConnection(_uname,_passwd);
+    }
+
+    private final String _uname;
+    private final String _passwd;
+    private final DataSource _source;
+}

==================================================
DelegatingConnection.java
new file mode 100644
index 0000000000..e137fc929c
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingCallableStatement.java
@@ -0,0 +1,783 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.io.InputStream;
+import java.io.Reader;
+import java.math.BigDecimal;
+import java.net.URL;
+import java.sql.Array;
+import java.sql.Blob;
+import java.sql.CallableStatement;
+import java.sql.Clob;
+import java.sql.Date;
+import java.sql.NClob;
+import java.sql.Ref;
+import java.sql.RowId;
+import java.sql.SQLException;
+import java.sql.SQLXML;
+import java.sql.Time;
+import java.sql.Timestamp;
+import java.util.Calendar;
+import java.util.Map;
+
+/**
+ * A base delegating implementation of {@link CallableStatement}.
+ * <p>
+ * All of the methods from the {@link CallableStatement} interface
+ * simply call the corresponding method on the "delegate"
+ * provided in my constructor.
+ * <p>
+ * Extends AbandonedTrace to implement Statement tracking and
+ * logging of code which created the Statement. Tracking the
+ * Statement ensures that the Connection which created it can
+ * close any open Statement's on Connection close.
+ *
+ * @author Glenn L. Nielsen
+ * @author James House
+ * @author Dirk Verbeeck
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class DelegatingCallableStatement extends DelegatingPreparedStatement
+        implements CallableStatement {
+
+    /**
+     * Create a wrapper for the Statement which traces this
+     * Statement to the Connection which created it and the
+     * code which created it.
+     *
+     * @param c the {@link DelegatingConnection} that created this statement
+     * @param s the {@link CallableStatement} to delegate all calls to
+     */
+    public DelegatingCallableStatement(DelegatingConnection<?> c,
+                                       CallableStatement s) {
+        super(c, s);
+    }
+
+    @Override
+    public void registerOutParameter(int parameterIndex, int sqlType) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter( parameterIndex,  sqlType); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void registerOutParameter(int parameterIndex, int sqlType, int scale) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter( parameterIndex,  sqlType,  scale); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public boolean wasNull() throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).wasNull(); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public String getString(int parameterIndex) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getString( parameterIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public boolean getBoolean(int parameterIndex) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBoolean( parameterIndex); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public byte getByte(int parameterIndex) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getByte( parameterIndex); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public short getShort(int parameterIndex) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getShort( parameterIndex); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public int getInt(int parameterIndex) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getInt( parameterIndex); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public long getLong(int parameterIndex) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getLong( parameterIndex); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public float getFloat(int parameterIndex) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getFloat( parameterIndex); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public double getDouble(int parameterIndex) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDouble( parameterIndex); } catch (SQLException e) { handleException(e); return 0; } }
+
+    /** @deprecated */
+    @Override
+    @Deprecated
+    public BigDecimal getBigDecimal(int parameterIndex, int scale) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBigDecimal( parameterIndex,  scale); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public byte[] getBytes(int parameterIndex) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBytes( parameterIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Date getDate(int parameterIndex) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDate( parameterIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Time getTime(int parameterIndex) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTime( parameterIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Timestamp getTimestamp(int parameterIndex) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTimestamp( parameterIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Object getObject(int parameterIndex) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getObject( parameterIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public BigDecimal getBigDecimal(int parameterIndex) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBigDecimal( parameterIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Object getObject(int i, Map<String,Class<?>> map) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getObject( i, map); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Ref getRef(int i) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getRef( i); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Blob getBlob(int i) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBlob( i); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Clob getClob(int i) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getClob( i); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Array getArray(int i) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getArray( i); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Date getDate(int parameterIndex, Calendar cal) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDate( parameterIndex,  cal); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Time getTime(int parameterIndex, Calendar cal) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTime( parameterIndex,  cal); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Timestamp getTimestamp(int parameterIndex, Calendar cal) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTimestamp( parameterIndex,  cal); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public void registerOutParameter(int paramIndex, int sqlType, String typeName) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter( paramIndex,  sqlType,  typeName); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void registerOutParameter(String parameterName, int sqlType) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter(parameterName, sqlType); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void registerOutParameter(String parameterName, int sqlType, int scale) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter(parameterName, sqlType, scale); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void registerOutParameter(String parameterName, int sqlType, String typeName) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter(parameterName, sqlType, typeName); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public URL getURL(int parameterIndex) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getURL(parameterIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public void setURL(String parameterName, URL val) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setURL(parameterName, val); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setNull(String parameterName, int sqlType) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setNull(parameterName, sqlType); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setBoolean(String parameterName, boolean x) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setBoolean(parameterName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setByte(String parameterName, byte x) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setByte(parameterName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setShort(String parameterName, short x) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setShort(parameterName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setInt(String parameterName, int x) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setInt(parameterName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setLong(String parameterName, long x) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setLong(parameterName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setFloat(String parameterName, float x) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setFloat(parameterName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setDouble(String parameterName, double x) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setDouble(parameterName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setBigDecimal(String parameterName, BigDecimal x) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setBigDecimal(parameterName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setString(String parameterName, String x) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setString(parameterName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setBytes(String parameterName, byte [] x) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setBytes(parameterName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setDate(String parameterName, Date x) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setDate(parameterName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setTime(String parameterName, Time x) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setTime(parameterName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setTimestamp(String parameterName, Timestamp x) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setTimestamp(parameterName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setAsciiStream(String parameterName, InputStream x, int length) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setAsciiStream(parameterName, x, length); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setBinaryStream(String parameterName, InputStream x, int length) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setBinaryStream(parameterName, x, length); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setObject(String parameterName, Object x, int targetSqlType, int scale) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setObject(parameterName, x, targetSqlType, scale); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setObject(String parameterName, Object x, int targetSqlType) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setObject(parameterName, x, targetSqlType); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setObject(String parameterName, Object x) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setObject(parameterName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setCharacterStream(String parameterName, Reader reader, int length) throws SQLException
+    { checkOpen(); ((CallableStatement)getDelegate()).setCharacterStream(parameterName, reader, length); }
+
+    @Override
+    public void setDate(String parameterName, Date x, Calendar cal) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setDate(parameterName, x, cal); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setTime(String parameterName, Time x, Calendar cal) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setTime(parameterName, x, cal); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setTimestamp(String parameterName, Timestamp x, Calendar cal) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setTimestamp(parameterName, x, cal); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setNull(String parameterName, int sqlType, String typeName) throws SQLException
+    { checkOpen(); try { ((CallableStatement)getDelegate()).setNull(parameterName, sqlType, typeName); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public String getString(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getString(parameterName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public boolean getBoolean(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBoolean(parameterName); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public byte getByte(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getByte(parameterName); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public short getShort(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getShort(parameterName); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public int getInt(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getInt(parameterName); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public long getLong(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getLong(parameterName); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public float getFloat(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getFloat(parameterName); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public double getDouble(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDouble(parameterName); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public byte[] getBytes(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBytes(parameterName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Date getDate(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDate(parameterName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Time getTime(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTime(parameterName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Timestamp getTimestamp(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTimestamp(parameterName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Object getObject(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getObject(parameterName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public BigDecimal getBigDecimal(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBigDecimal(parameterName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Object getObject(String parameterName, Map<String,Class<?>> map) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getObject(parameterName, map); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Ref getRef(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getRef(parameterName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Blob getBlob(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBlob(parameterName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Clob getClob(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getClob(parameterName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Array getArray(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getArray(parameterName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Date getDate(String parameterName, Calendar cal) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDate(parameterName, cal); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Time getTime(String parameterName, Calendar cal) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTime(parameterName, cal); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Timestamp getTimestamp(String parameterName, Calendar cal) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTimestamp(parameterName, cal); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public URL getURL(String parameterName) throws SQLException
+    { checkOpen(); try { return ((CallableStatement)getDelegate()).getURL(parameterName); } catch (SQLException e) { handleException(e); return null; } }
+
+
+    @Override
+    public RowId getRowId(int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return ((CallableStatement)getDelegate()).getRowId(parameterIndex);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public RowId getRowId(String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return ((CallableStatement)getDelegate()).getRowId(parameterName);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public void setRowId(String parameterName, RowId value) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setRowId(parameterName, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setNString(String parameterName, String value) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setNString(parameterName, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setNCharacterStream(String parameterName, Reader reader, long length) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setNCharacterStream(parameterName, reader, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setNClob(String parameterName, NClob value) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setNClob(parameterName, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setClob(String parameterName, Reader reader, long length) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setClob(parameterName, reader, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setBlob(String parameterName, InputStream inputStream, long length) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setBlob(parameterName, inputStream, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setNClob(String parameterName, Reader reader, long length) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setNClob(parameterName, reader, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public NClob getNClob(int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return ((CallableStatement)getDelegate()).getNClob(parameterIndex);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public NClob getNClob(String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return ((CallableStatement)getDelegate()).getNClob(parameterName);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public void setSQLXML(String parameterName, SQLXML value) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setSQLXML(parameterName, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public SQLXML getSQLXML(int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return ((CallableStatement)getDelegate()).getSQLXML(parameterIndex);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public SQLXML getSQLXML(String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return ((CallableStatement)getDelegate()).getSQLXML(parameterName);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public String getNString(int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return ((CallableStatement)getDelegate()).getNString(parameterIndex);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public String getNString(String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return ((CallableStatement)getDelegate()).getNString(parameterName);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public Reader getNCharacterStream(int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return ((CallableStatement)getDelegate()).getNCharacterStream(parameterIndex);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public Reader getNCharacterStream(String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return ((CallableStatement)getDelegate()).getNCharacterStream(parameterName);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public Reader getCharacterStream(int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return ((CallableStatement)getDelegate()).getCharacterStream(parameterIndex);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public Reader getCharacterStream(String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return ((CallableStatement)getDelegate()).getCharacterStream(parameterName);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public void setBlob(String parameterName, Blob blob) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setBlob(parameterName, blob);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setClob(String parameterName, Clob clob) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setClob(parameterName, clob);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setAsciiStream(String parameterName, InputStream inputStream, long length) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setAsciiStream(parameterName, inputStream, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setBinaryStream(String parameterName, InputStream inputStream, long length) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setBinaryStream(parameterName, inputStream, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setCharacterStream(String parameterName, Reader reader, long length) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setCharacterStream(parameterName, reader, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setAsciiStream(String parameterName, InputStream inputStream) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setAsciiStream(parameterName, inputStream);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setBinaryStream(String parameterName, InputStream inputStream) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setBinaryStream(parameterName, inputStream);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setCharacterStream(String parameterName, Reader reader) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setCharacterStream(parameterName, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setNCharacterStream(String parameterName, Reader reader) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setNCharacterStream(parameterName, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setClob(String parameterName, Reader reader) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setClob(parameterName, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setBlob(String parameterName, InputStream inputStream) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setBlob(parameterName, inputStream);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setNClob(String parameterName, Reader reader) throws SQLException {
+        checkOpen();
+        try {
+            ((CallableStatement)getDelegate()).setNClob(parameterName, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public <T> T getObject(int parameterIndex, Class<T> type)
+            throws SQLException {
+        checkOpen();
+        try {
+            return ((CallableStatement)getDelegate()).getObject(parameterIndex, type);
+}
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public <T> T getObject(String parameterName, Class<T> type)
+            throws SQLException {
+        checkOpen();
+        try {
+            return ((CallableStatement)getDelegate()).getObject(parameterName, type);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+
+}

==================================================
DelegatingDatabaseMetaData.java
new file mode 100644
index 0000000000..a0f47aa966
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingConnection.java
@@ -0,0 +1,1031 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.sql.Array;
+import java.sql.Blob;
+import java.sql.CallableStatement;
+import java.sql.ClientInfoStatus;
+import java.sql.Clob;
+import java.sql.Connection;
+import java.sql.DatabaseMetaData;
+import java.sql.NClob;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLClientInfoException;
+import java.sql.SQLException;
+import java.sql.SQLWarning;
+import java.sql.SQLXML;
+import java.sql.Savepoint;
+import java.sql.Statement;
+import java.sql.Struct;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.concurrent.Executor;
+
+/**
+ * A base delegating implementation of {@link Connection}.
+ * <p>
+ * All of the methods from the {@link Connection} interface
+ * simply check to see that the {@link Connection} is active,
+ * and call the corresponding method on the "delegate"
+ * provided in my constructor.
+ * <p>
+ * Extends AbandonedTrace to implement Connection tracking and
+ * logging of code which created the Connection. Tracking the
+ * Connection ensures that the AbandonedObjectPool can close
+ * this connection and recycle it if its pool of connections
+ * is nearing exhaustion and this connection's last usage is
+ * older than the removeAbandonedTimeout.
+ *
+ * @param <C> the Connection type
+ *
+ * @author Rodney Waldhoff
+ * @author Glenn L. Nielsen
+ * @author James House
+ * @author Dirk Verbeeck
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class DelegatingConnection<C extends Connection> extends AbandonedTrace
+        implements Connection {
+
+    private static final Map<String, ClientInfoStatus> EMPTY_FAILED_PROPERTIES =
+        Collections.<String, ClientInfoStatus>emptyMap();
+
+    /** My delegate {@link Connection}. */
+    private volatile C _conn = null;
+
+    private volatile boolean _closed = false;
+
+    private boolean _cacheState = true;
+    private Boolean _autoCommitCached = null;
+    private Boolean _readOnlyCached = null;
+    private Integer defaultQueryTimeout = null;
+
+    /**
+     * Create a wrapper for the Connection which traces this
+     * Connection in the AbandonedObjectPool.
+     *
+     * @param c the {@link Connection} to delegate all calls to.
+     */
+    public DelegatingConnection(C c) {
+        super();
+        _conn = c;
+    }
+
+
+    /**
+     * Returns a string representation of the metadata associated with
+     * the innnermost delegate connection.
+     */
+    @Override
+    public String toString() {
+        String s = null;
+
+        Connection c = this.getInnermostDelegateInternal();
+        if (c != null) {
+            try {
+                if (c.isClosed()) {
+                    s = "connection is closed";
+                }
+                else {
+                    StringBuffer sb = new StringBuffer();
+                    sb.append(hashCode());
+                    DatabaseMetaData meta = c.getMetaData();
+                    if (meta != null) {
+                        sb.append(", URL=");
+                        sb.append(meta.getURL());
+                        sb.append(", UserName=");
+                        sb.append(meta.getUserName());
+                        sb.append(", ");
+                        sb.append(meta.getDriverName());
+                        s = sb.toString();
+                    }
+                }
+            }
+            catch (SQLException ex) {
+                // Ignore
+            }
+        }
+
+        if (s == null) {
+            s = super.toString();
+        }
+
+        return s;
+    }
+
+    /**
+     * Returns my underlying {@link Connection}.
+     * @return my underlying {@link Connection}.
+     */
+    public C getDelegate() {
+        return getDelegateInternal();
+    }
+
+    protected final C getDelegateInternal() {
+        return _conn;
+    }
+
+    /**
+     * Compares innermost delegate to the given connection.
+     *
+     * @param c connection to compare innermost delegate with
+     * @return true if innermost delegate equals <code>c</code>
+     */
+    public boolean innermostDelegateEquals(Connection c) {
+        Connection innerCon = getInnermostDelegateInternal();
+        if (innerCon == null) {
+            return c == null;
+        }
+        return innerCon.equals(c);
+    }
+
+
+    /**
+     * If my underlying {@link Connection} is not a
+     * <tt>DelegatingConnection</tt>, returns it,
+     * otherwise recursively invokes this method on
+     * my delegate.
+     * <p>
+     * Hence this method will return the first
+     * delegate that is not a <tt>DelegatingConnection</tt>,
+     * or <tt>null</tt> when no non-<tt>DelegatingConnection</tt>
+     * delegate can be found by traversing this chain.
+     * <p>
+     * This method is useful when you may have nested
+     * <tt>DelegatingConnection</tt>s, and you want to make
+     * sure to obtain a "genuine" {@link Connection}.
+     */
+    public Connection getInnermostDelegate() {
+        return getInnermostDelegateInternal();
+    }
+
+
+    /**
+     * Although this method is public, it is part of the internal API and should
+     * not be used by clients. The signature of this method may change at any
+     * time including in ways that break backwards compatibility.
+     */
+    public final Connection getInnermostDelegateInternal() {
+        Connection c = _conn;
+        while(c != null && c instanceof DelegatingConnection) {
+            c = ((DelegatingConnection<?>)c).getDelegateInternal();
+            if(this == c) {
+                return null;
+            }
+        }
+        return c;
+    }
+
+    /** Sets my delegate. */
+    public void setDelegate(C c) {
+        _conn = c;
+    }
+
+    /**
+     * Closes the underlying connection, and close any Statements that were not
+     * explicitly closed. Sub-classes that override this method must:
+     * <ol>
+     * <li>Call passivate()</li>
+     * <li>Call close (or the equivalent appropriate action) on the wrapped
+     *     connection</li>
+     * <li>Set _closed to <code>false</code></li>
+     * </ol>
+     */
+    @Override
+    public void close() throws SQLException {
+        if (!_closed) {
+            closeInternal();
+        }
+    }
+
+    protected boolean isClosedInternal() {
+        return _closed;
+    }
+
+    protected void setClosedInternal(boolean closed) {
+        this._closed = closed;
+    }
+
+    protected final void closeInternal() throws SQLException {
+        try {
+            passivate();
+        } finally {
+            try {
+                _conn.close();
+            } finally {
+                _closed = true;
+            }
+        }
+    }
+
+    protected void handleException(SQLException e) throws SQLException {
+        throw e;
+    }
+
+    private void initializeStatement(DelegatingStatement ds) throws SQLException {
+        if (defaultQueryTimeout != null &&
+                defaultQueryTimeout.intValue() != ds.getQueryTimeout()) {
+            ds.setQueryTimeout(defaultQueryTimeout.intValue());
+        }
+    }
+
+    @Override
+    public Statement createStatement() throws SQLException {
+        checkOpen();
+        try {
+            DelegatingStatement ds =
+                    new DelegatingStatement(this, _conn.createStatement());
+            initializeStatement(ds);
+            return ds;
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public Statement createStatement(int resultSetType,
+                                     int resultSetConcurrency) throws SQLException {
+        checkOpen();
+        try {
+            DelegatingStatement ds = new DelegatingStatement(
+                    this, _conn.createStatement(resultSetType,resultSetConcurrency));
+            initializeStatement(ds);
+            return ds;
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public PreparedStatement prepareStatement(String sql) throws SQLException {
+        checkOpen();
+        try {
+            DelegatingPreparedStatement dps = new DelegatingPreparedStatement(
+                    this, _conn.prepareStatement(sql));
+            initializeStatement(dps);
+            return dps;
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public PreparedStatement prepareStatement(String sql,
+                                              int resultSetType,
+                                              int resultSetConcurrency) throws SQLException {
+        checkOpen();
+        try {
+            DelegatingPreparedStatement dps = new DelegatingPreparedStatement(
+                    this, _conn.prepareStatement(sql,resultSetType,resultSetConcurrency));
+            initializeStatement(dps);
+            return dps;
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public CallableStatement prepareCall(String sql) throws SQLException {
+        checkOpen();
+        try {
+            DelegatingCallableStatement dcs =
+                    new DelegatingCallableStatement(this, _conn.prepareCall(sql));
+            initializeStatement(dcs);
+            return dcs;
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public CallableStatement prepareCall(String sql,
+                                         int resultSetType,
+                                         int resultSetConcurrency) throws SQLException {
+        checkOpen();
+        try {
+            DelegatingCallableStatement dcs = new DelegatingCallableStatement(
+                    this, _conn.prepareCall(sql, resultSetType,resultSetConcurrency));
+            initializeStatement(dcs);
+            return dcs;
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+
+    @Override
+    public void clearWarnings() throws SQLException {
+        checkOpen();
+        try {
+            _conn.clearWarnings();
+        } catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+
+    @Override
+    public void commit() throws SQLException {
+        checkOpen();
+        try {
+            _conn.commit();
+        } catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+
+    /**
+     * Returns the state caching flag.
+     *
+     * @return  the state caching flag
+     */
+    public boolean getCacheState() {
+        return _cacheState;
+    }
+
+    @Override
+    public boolean getAutoCommit() throws SQLException {
+        checkOpen();
+        if (_cacheState && _autoCommitCached != null) {
+            return _autoCommitCached.booleanValue();
+        }
+        try {
+            _autoCommitCached = Boolean.valueOf(_conn.getAutoCommit());
+            return _autoCommitCached.booleanValue();
+        } catch (SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
+
+    @Override
+    public String getCatalog() throws SQLException {
+        checkOpen();
+        try {
+            return _conn.getCatalog();
+        } catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+
+    @Override
+    public DatabaseMetaData getMetaData() throws SQLException {
+        checkOpen();
+        try {
+            return new DelegatingDatabaseMetaData(this, _conn.getMetaData());
+        } catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+
+    @Override
+    public int getTransactionIsolation() throws SQLException {
+        checkOpen();
+        try {
+            return _conn.getTransactionIsolation();
+        } catch (SQLException e) {
+            handleException(e);
+            return -1;
+        }
+    }
+
+
+    @Override
+    public Map<String,Class<?>> getTypeMap() throws SQLException {
+        checkOpen();
+        try {
+            return _conn.getTypeMap();
+        } catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+
+    @Override
+    public SQLWarning getWarnings() throws SQLException {
+        checkOpen();
+        try {
+            return _conn.getWarnings();
+        } catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+
+    @Override
+    public boolean isReadOnly() throws SQLException {
+        checkOpen();
+        if (_cacheState && _readOnlyCached != null) {
+            return _readOnlyCached.booleanValue();
+        }
+        try {
+            _readOnlyCached = Boolean.valueOf(_conn.isReadOnly());
+            return _readOnlyCached.booleanValue();
+        } catch (SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
+
+    @Override
+    public String nativeSQL(String sql) throws SQLException {
+        checkOpen();
+        try {
+            return _conn.nativeSQL(sql);
+        } catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+
+    @Override
+    public void rollback() throws SQLException {
+        checkOpen();
+        try {
+            _conn.rollback();
+        } catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+
+    /**
+     * Obtain the default query timeout that will be used for {@link Statement}s
+     * created from this connection. <code>null</code> means that the driver
+     * default will be used.
+     */
+    public Integer getDefaultQueryTimeout() {
+        return defaultQueryTimeout;
+    }
+
+
+    /**
+     * Set the default query timeout that will be used for {@link Statement}s
+     * created from this connection. <code>null</code> means that the driver
+     * default will be used.
+     */
+    public void setDefaultQueryTimeout(Integer defaultQueryTimeout) {
+        this.defaultQueryTimeout = defaultQueryTimeout;
+    }
+
+
+    /**
+     * Sets the state caching flag.
+     *
+     * @param cacheState    The new value for the state caching flag
+     */
+    public void setCacheState(boolean cacheState) {
+        this._cacheState = cacheState;
+    }
+
+    /**
+     * Can be used to clear cached state when it is known that the underlying
+     * connection may have been accessed directly.
+     */
+    public void clearCachedState() {
+        _autoCommitCached = null;
+        _readOnlyCached = null;
+        if (_conn instanceof DelegatingConnection) {
+            ((DelegatingConnection<?>)_conn).clearCachedState();
+        }
+    }
+
+    @Override
+    public void setAutoCommit(boolean autoCommit) throws SQLException {
+        checkOpen();
+        try {
+            _conn.setAutoCommit(autoCommit);
+            if (_cacheState) {
+                _autoCommitCached = Boolean.valueOf(autoCommit);
+            }
+        } catch (SQLException e) {
+            _autoCommitCached = null;
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setCatalog(String catalog) throws SQLException
+    { checkOpen(); try { _conn.setCatalog(catalog); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setReadOnly(boolean readOnly) throws SQLException {
+        checkOpen();
+        try {
+            _conn.setReadOnly(readOnly);
+            if (_cacheState) {
+                _readOnlyCached = Boolean.valueOf(readOnly);
+            }
+        } catch (SQLException e) {
+            _readOnlyCached = null;
+            handleException(e);
+        }
+    }
+
+
+    @Override
+    public void setTransactionIsolation(int level) throws SQLException {
+        checkOpen();
+        try {
+            _conn.setTransactionIsolation(level);
+        } catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+
+    @Override
+    public void setTypeMap(Map<String,Class<?>> map) throws SQLException {
+        checkOpen();
+        try {
+            _conn.setTypeMap(map);
+        } catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+
+    @Override
+    public boolean isClosed() throws SQLException {
+        return _closed || _conn.isClosed();
+    }
+
+    protected void checkOpen() throws SQLException {
+        if(_closed) {
+            if (null != _conn) {
+                String label = "";
+                try {
+                    label = _conn.toString();
+                } catch (Exception ex) {
+                    // ignore, leave label empty
+                }
+                throw new SQLException
+                    ("Connection " + label + " is closed.");
+            }
+            throw new SQLException
+                ("Connection is null.");
+        }
+    }
+
+    protected void activate() {
+        _closed = false;
+        setLastUsed();
+        if(_conn instanceof DelegatingConnection) {
+            ((DelegatingConnection<?>)_conn).activate();
+        }
+    }
+
+    protected void passivate() throws SQLException {
+        // The JDBC spec requires that a Connection close any open
+        // Statement's when it is closed.
+        // DBCP-288. Not all the traced objects will be statements
+        List<AbandonedTrace> traces = getTrace();
+        if(traces != null && traces.size() > 0) {
+            Iterator<AbandonedTrace> traceIter = traces.iterator();
+            while (traceIter.hasNext()) {
+                Object trace = traceIter.next();
+                if (trace instanceof Statement) {
+                    ((Statement) trace).close();
+                } else if (trace instanceof ResultSet) {
+                    // DBCP-265: Need to close the result sets that are
+                    // generated via DatabaseMetaData
+                    ((ResultSet) trace).close();
+                }
+            }
+            clearTrace();
+        }
+        setLastUsed(0);
+    }
+
+
+    @Override
+    public int getHoldability() throws SQLException {
+        checkOpen();
+        try {
+            return _conn.getHoldability();
+        } catch (SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
+
+
+    @Override
+    public void setHoldability(int holdability) throws SQLException {
+        checkOpen();
+        try {
+            _conn.setHoldability(holdability);
+        } catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+
+    @Override
+    public Savepoint setSavepoint() throws SQLException {
+        checkOpen();
+        try {
+            return _conn.setSavepoint();
+        } catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+
+    @Override
+    public Savepoint setSavepoint(String name) throws SQLException {
+        checkOpen();
+        try {
+            return _conn.setSavepoint(name);
+        } catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+
+    @Override
+    public void rollback(Savepoint savepoint) throws SQLException {
+        checkOpen();
+        try {
+            _conn.rollback(savepoint);
+        } catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+
+    @Override
+    public void releaseSavepoint(Savepoint savepoint)
+            throws SQLException {
+        checkOpen();
+        try {
+            _conn.releaseSavepoint(savepoint);
+        } catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+
+    @Override
+    public Statement createStatement(int resultSetType,
+                                     int resultSetConcurrency,
+                                     int resultSetHoldability) throws SQLException {
+        checkOpen();
+        try {
+            DelegatingStatement ds = new DelegatingStatement(this,
+                    _conn.createStatement(resultSetType, resultSetConcurrency,
+                            resultSetHoldability));
+            initializeStatement(ds);
+            return ds;
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public PreparedStatement prepareStatement(String sql, int resultSetType,
+                                              int resultSetConcurrency,
+                                              int resultSetHoldability) throws SQLException {
+        checkOpen();
+        try {
+            DelegatingPreparedStatement dps = new DelegatingPreparedStatement(
+                    this, _conn.prepareStatement(sql, resultSetType,
+                            resultSetConcurrency, resultSetHoldability));
+            initializeStatement(dps);
+            return dps;
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public CallableStatement prepareCall(String sql, int resultSetType,
+                                         int resultSetConcurrency,
+                                         int resultSetHoldability) throws SQLException {
+        checkOpen();
+        try {
+            DelegatingCallableStatement dcs = new DelegatingCallableStatement(
+                    this, _conn.prepareCall(sql, resultSetType,
+                            resultSetConcurrency, resultSetHoldability));
+            initializeStatement(dcs);
+            return dcs;
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
+        checkOpen();
+        try {
+            DelegatingPreparedStatement dps = new DelegatingPreparedStatement(
+                    this, _conn.prepareStatement(sql, autoGeneratedKeys));
+            initializeStatement(dps);
+            return dps;
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public PreparedStatement prepareStatement(String sql, int columnIndexes[]) throws SQLException {
+        checkOpen();
+        try {
+            DelegatingPreparedStatement dps = new DelegatingPreparedStatement(
+                    this, _conn.prepareStatement(sql, columnIndexes));
+            initializeStatement(dps);
+            return dps;
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public PreparedStatement prepareStatement(String sql, String columnNames[]) throws SQLException {
+        checkOpen();
+        try {
+            DelegatingPreparedStatement dps =  new DelegatingPreparedStatement(
+                    this, _conn.prepareStatement(sql, columnNames));
+            initializeStatement(dps);
+            return dps;
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+
+    @Override
+    public boolean isWrapperFor(Class<?> iface) throws SQLException {
+        if (iface.isAssignableFrom(getClass())) {
+            return true;
+        } else if (iface.isAssignableFrom(_conn.getClass())) {
+            return true;
+        } else {
+            return _conn.isWrapperFor(iface);
+        }
+    }
+
+    @Override
+    public <T> T unwrap(Class<T> iface) throws SQLException {
+        if (iface.isAssignableFrom(getClass())) {
+            return iface.cast(this);
+        } else if (iface.isAssignableFrom(_conn.getClass())) {
+            return iface.cast(_conn);
+        } else {
+            return _conn.unwrap(iface);
+        }
+    }
+
+    @Override
+    public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
+        checkOpen();
+        try {
+            return _conn.createArrayOf(typeName, elements);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public Blob createBlob() throws SQLException {
+        checkOpen();
+        try {
+            return _conn.createBlob();
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public Clob createClob() throws SQLException {
+        checkOpen();
+        try {
+            return _conn.createClob();
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public NClob createNClob() throws SQLException {
+        checkOpen();
+        try {
+            return _conn.createNClob();
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public SQLXML createSQLXML() throws SQLException {
+        checkOpen();
+        try {
+            return _conn.createSQLXML();
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
+        checkOpen();
+        try {
+            return _conn.createStruct(typeName, attributes);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public boolean isValid(int timeout) throws SQLException {
+        if (isClosed()) {
+            return false;
+        }
+        try {
+            return _conn.isValid(timeout);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
+    @Override
+    public void setClientInfo(String name, String value) throws SQLClientInfoException {
+        try {
+            checkOpen();
+            _conn.setClientInfo(name, value);
+        }
+        catch (SQLClientInfoException e) {
+            throw e;
+        }
+        catch (SQLException e) {
+            throw new SQLClientInfoException("Connection is closed.", EMPTY_FAILED_PROPERTIES, e);
+        }
+    }
+
+    @Override
+    public void setClientInfo(Properties properties) throws SQLClientInfoException {
+        try {
+            checkOpen();
+            _conn.setClientInfo(properties);
+        }
+        catch (SQLClientInfoException e) {
+            throw e;
+        }
+        catch (SQLException e) {
+            throw new SQLClientInfoException("Connection is closed.", EMPTY_FAILED_PROPERTIES, e);
+        }
+    }
+
+    @Override
+    public Properties getClientInfo() throws SQLException {
+        checkOpen();
+        try {
+            return _conn.getClientInfo();
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public String getClientInfo(String name) throws SQLException {
+        checkOpen();
+        try {
+            return _conn.getClientInfo(name);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public void setSchema(String schema) throws SQLException {
+        checkOpen();
+        try {
+            _conn.setSchema(schema);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public String getSchema() throws SQLException {
+        checkOpen();
+        try {
+            return _conn.getSchema();
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public void abort(Executor executor) throws SQLException {
+        checkOpen();
+        try {
+            _conn.abort(executor);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setNetworkTimeout(Executor executor, int milliseconds)
+            throws SQLException {
+        checkOpen();
+        try {
+            _conn.setNetworkTimeout(executor, milliseconds);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public int getNetworkTimeout() throws SQLException {
+        checkOpen();
+        try {
+            return _conn.getNetworkTimeout();
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
+}

==================================================
DelegatingPreparedStatement.java
new file mode 100644
index 0000000000..5d808a8a70
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingDatabaseMetaData.java
@@ -0,0 +1,1388 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.sql.Connection;
+import java.sql.DatabaseMetaData;
+import java.sql.ResultSet;
+import java.sql.RowIdLifetime;
+import java.sql.SQLException;
+
+/**
+ * <p>A base delegating implementation of {@link DatabaseMetaData}.</p>
+ *
+ * <p>Methods that create {@link ResultSet} objects are wrapped to
+ * create {@link DelegatingResultSet} objects and the remaining methods
+ * simply call the corresponding method on the "delegate"
+ * provided in the constructor.</p>
+ * @since 2.0
+ */
+public class DelegatingDatabaseMetaData implements DatabaseMetaData {
+
+    /** My delegate {@link DatabaseMetaData} */
+    private final DatabaseMetaData _meta;
+
+    /** The connection that created me. **/
+    private final DelegatingConnection<?> _conn;
+
+    public DelegatingDatabaseMetaData(DelegatingConnection<?> c,
+            DatabaseMetaData m) {
+        super();
+        _conn = c;
+        _meta = m;
+    }
+
+    public DatabaseMetaData getDelegate() {
+        return _meta;
+    }
+
+    /**
+     * If my underlying {@link ResultSet} is not a
+     * <tt>DelegatingResultSet</tt>, returns it,
+     * otherwise recursively invokes this method on
+     * my delegate.
+     * <p>
+     * Hence this method will return the first
+     * delegate that is not a <tt>DelegatingResultSet</tt>,
+     * or <tt>null</tt> when no non-<tt>DelegatingResultSet</tt>
+     * delegate can be found by transversing this chain.
+     * <p>
+     * This method is useful when you may have nested
+     * <tt>DelegatingResultSet</tt>s, and you want to make
+     * sure to obtain a "genuine" {@link ResultSet}.
+     */
+    public DatabaseMetaData getInnermostDelegate() {
+        DatabaseMetaData m = _meta;
+        while(m != null && m instanceof DelegatingDatabaseMetaData) {
+            m = ((DelegatingDatabaseMetaData)m).getDelegate();
+            if(this == m) {
+                return null;
+            }
+        }
+        return m;
+    }
+
+    protected void handleException(SQLException e) throws SQLException {
+        if (_conn != null) {
+            _conn.handleException(e);
+        }
+        else {
+            throw e;
+        }
+    }
+
+    @Override
+    public boolean allProceduresAreCallable() throws SQLException {
+        { try { return _meta.allProceduresAreCallable(); }
+          catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean allTablesAreSelectable() throws SQLException {
+        { try { return _meta.allTablesAreSelectable(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean dataDefinitionCausesTransactionCommit() throws SQLException {
+        { try { return _meta.dataDefinitionCausesTransactionCommit(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean dataDefinitionIgnoredInTransactions() throws SQLException {
+        { try { return _meta.dataDefinitionIgnoredInTransactions(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean deletesAreDetected(int type) throws SQLException {
+        { try { return _meta.deletesAreDetected(type); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean doesMaxRowSizeIncludeBlobs() throws SQLException {
+        { try { return _meta.doesMaxRowSizeIncludeBlobs(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public ResultSet getAttributes(String catalog, String schemaPattern,
+            String typeNamePattern, String attributeNamePattern)
+            throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,_meta.getAttributes(
+                    catalog, schemaPattern, typeNamePattern,
+                    attributeNamePattern));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public ResultSet getBestRowIdentifier(String catalog, String schema,
+            String table, int scope, boolean nullable) throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getBestRowIdentifier(catalog, schema, table, scope,
+                            nullable));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public String getCatalogSeparator() throws SQLException {
+        { try { return _meta.getCatalogSeparator(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public String getCatalogTerm() throws SQLException {
+        { try { return _meta.getCatalogTerm(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public ResultSet getCatalogs() throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getCatalogs());
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public ResultSet getColumnPrivileges(String catalog, String schema,
+            String table, String columnNamePattern) throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getColumnPrivileges(catalog, schema, table,
+                            columnNamePattern));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public ResultSet getColumns(String catalog, String schemaPattern,
+            String tableNamePattern, String columnNamePattern)
+            throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getColumns(catalog, schemaPattern, tableNamePattern,
+                            columnNamePattern));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public Connection getConnection() throws SQLException {
+        return _conn;
+    }
+
+    @Override
+    public ResultSet getCrossReference(String parentCatalog,
+            String parentSchema, String parentTable, String foreignCatalog,
+            String foreignSchema, String foreignTable) throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getCrossReference(parentCatalog, parentSchema,
+                            parentTable, foreignCatalog, foreignSchema,
+                            foreignTable));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public int getDatabaseMajorVersion() throws SQLException {
+        { try { return _meta.getDatabaseMajorVersion(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getDatabaseMinorVersion() throws SQLException {
+        { try { return _meta.getDatabaseMinorVersion(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public String getDatabaseProductName() throws SQLException {
+        { try { return _meta.getDatabaseProductName(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public String getDatabaseProductVersion() throws SQLException {
+        { try { return _meta.getDatabaseProductVersion(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public int getDefaultTransactionIsolation() throws SQLException {
+        { try { return _meta.getDefaultTransactionIsolation(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getDriverMajorVersion() {return _meta.getDriverMajorVersion();}
+
+    @Override
+    public int getDriverMinorVersion() {return _meta.getDriverMinorVersion();}
+
+    @Override
+    public String getDriverName() throws SQLException {
+        { try { return _meta.getDriverName(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public String getDriverVersion() throws SQLException {
+        { try { return _meta.getDriverVersion(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public ResultSet getExportedKeys(String catalog, String schema, String table)
+            throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getExportedKeys(catalog, schema, table));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public String getExtraNameCharacters() throws SQLException {
+        { try { return _meta.getExtraNameCharacters(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public String getIdentifierQuoteString() throws SQLException {
+        { try { return _meta.getIdentifierQuoteString(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public ResultSet getImportedKeys(String catalog, String schema, String table)
+            throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getImportedKeys(catalog, schema, table));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public ResultSet getIndexInfo(String catalog, String schema, String table,
+            boolean unique, boolean approximate) throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getIndexInfo(catalog, schema, table, unique,
+                            approximate));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public int getJDBCMajorVersion() throws SQLException {
+        { try { return _meta.getJDBCMajorVersion(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getJDBCMinorVersion() throws SQLException {
+        { try { return _meta.getJDBCMinorVersion(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxBinaryLiteralLength() throws SQLException {
+        { try { return _meta.getMaxBinaryLiteralLength(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxCatalogNameLength() throws SQLException {
+        { try { return _meta.getMaxCatalogNameLength(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxCharLiteralLength() throws SQLException {
+        { try { return _meta.getMaxCharLiteralLength(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxColumnNameLength() throws SQLException {
+        { try { return _meta.getMaxColumnNameLength(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxColumnsInGroupBy() throws SQLException {
+        { try { return _meta.getMaxColumnsInGroupBy(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxColumnsInIndex() throws SQLException {
+        { try { return _meta.getMaxColumnsInIndex(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxColumnsInOrderBy() throws SQLException {
+        { try { return _meta.getMaxColumnsInOrderBy(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxColumnsInSelect() throws SQLException {
+        { try { return _meta.getMaxColumnsInSelect(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxColumnsInTable() throws SQLException {
+        { try { return _meta.getMaxColumnsInTable(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxConnections() throws SQLException {
+        { try { return _meta.getMaxConnections(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxCursorNameLength() throws SQLException {
+        { try { return _meta.getMaxCursorNameLength(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxIndexLength() throws SQLException {
+        { try { return _meta.getMaxIndexLength(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxProcedureNameLength() throws SQLException {
+        { try { return _meta.getMaxProcedureNameLength(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxRowSize() throws SQLException {
+        { try { return _meta.getMaxRowSize(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxSchemaNameLength() throws SQLException {
+        { try { return _meta.getMaxSchemaNameLength(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxStatementLength() throws SQLException {
+        { try { return _meta.getMaxStatementLength(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxStatements() throws SQLException {
+        { try { return _meta.getMaxStatements(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxTableNameLength() throws SQLException {
+        { try { return _meta.getMaxTableNameLength(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxTablesInSelect() throws SQLException {
+        { try { return _meta.getMaxTablesInSelect(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public int getMaxUserNameLength() throws SQLException {
+        { try { return _meta.getMaxUserNameLength(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public String getNumericFunctions() throws SQLException {
+        { try { return _meta.getNumericFunctions(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public ResultSet getPrimaryKeys(String catalog, String schema, String table)
+            throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getPrimaryKeys(catalog, schema, table));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public ResultSet getProcedureColumns(String catalog, String schemaPattern,
+            String procedureNamePattern, String columnNamePattern)
+            throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getProcedureColumns(catalog, schemaPattern,
+                            procedureNamePattern, columnNamePattern));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public String getProcedureTerm() throws SQLException {
+        { try { return _meta.getProcedureTerm(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public ResultSet getProcedures(String catalog, String schemaPattern,
+            String procedureNamePattern) throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getProcedures(catalog, schemaPattern,
+                            procedureNamePattern));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public int getResultSetHoldability() throws SQLException {
+        { try { return _meta.getResultSetHoldability(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public String getSQLKeywords() throws SQLException {
+        { try { return _meta.getSQLKeywords(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public int getSQLStateType() throws SQLException {
+        { try { return _meta.getSQLStateType(); }
+        catch (SQLException e) { handleException(e); return 0; } }
+    }
+
+    @Override
+    public String getSchemaTerm() throws SQLException {
+        { try { return _meta.getSchemaTerm(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public ResultSet getSchemas() throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getSchemas());
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public String getSearchStringEscape() throws SQLException {
+        { try { return _meta.getSearchStringEscape(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public String getStringFunctions() throws SQLException {
+        { try { return _meta.getStringFunctions(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public ResultSet getSuperTables(String catalog, String schemaPattern,
+            String tableNamePattern) throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getSuperTables(catalog, schemaPattern,
+                            tableNamePattern));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public ResultSet getSuperTypes(String catalog, String schemaPattern,
+            String typeNamePattern) throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getSuperTypes(catalog, schemaPattern,
+                            typeNamePattern));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public String getSystemFunctions() throws SQLException {
+        { try { return _meta.getSystemFunctions(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public ResultSet getTablePrivileges(String catalog, String schemaPattern,
+            String tableNamePattern) throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getTablePrivileges(catalog, schemaPattern,
+                            tableNamePattern));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public ResultSet getTableTypes() throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getTableTypes());
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public ResultSet getTables(String catalog, String schemaPattern,
+            String tableNamePattern, String[] types) throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getTables(catalog, schemaPattern, tableNamePattern,
+                            types));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public String getTimeDateFunctions() throws SQLException {
+        { try { return _meta.getTimeDateFunctions(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public ResultSet getTypeInfo() throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getTypeInfo());
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public ResultSet getUDTs(String catalog, String schemaPattern,
+            String typeNamePattern, int[] types) throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getUDTs(catalog, schemaPattern, typeNamePattern,
+                            types));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public String getURL() throws SQLException {
+        { try { return _meta.getURL(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public String getUserName() throws SQLException {
+        { try { return _meta.getUserName(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public ResultSet getVersionColumns(String catalog, String schema,
+            String table) throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getVersionColumns(catalog, schema, table));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public boolean insertsAreDetected(int type) throws SQLException {
+        { try { return _meta.insertsAreDetected(type); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean isCatalogAtStart() throws SQLException {
+        { try { return _meta.isCatalogAtStart(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean isReadOnly() throws SQLException {
+        { try { return _meta.isReadOnly(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean locatorsUpdateCopy() throws SQLException {
+        { try { return _meta.locatorsUpdateCopy(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean nullPlusNonNullIsNull() throws SQLException {
+        { try { return _meta.nullPlusNonNullIsNull(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean nullsAreSortedAtEnd() throws SQLException {
+        { try { return _meta.nullsAreSortedAtEnd(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean nullsAreSortedAtStart() throws SQLException {
+        { try { return _meta.nullsAreSortedAtStart(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean nullsAreSortedHigh() throws SQLException {
+        { try { return _meta.nullsAreSortedHigh(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean nullsAreSortedLow() throws SQLException {
+        { try { return _meta.nullsAreSortedLow(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean othersDeletesAreVisible(int type) throws SQLException {
+        { try { return _meta.othersDeletesAreVisible(type); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean othersInsertsAreVisible(int type) throws SQLException {
+        { try { return _meta.othersInsertsAreVisible(type); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean othersUpdatesAreVisible(int type) throws SQLException {
+        { try { return _meta.othersUpdatesAreVisible(type); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean ownDeletesAreVisible(int type) throws SQLException {
+        { try { return _meta.ownDeletesAreVisible(type); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean ownInsertsAreVisible(int type) throws SQLException {
+        { try { return _meta.ownInsertsAreVisible(type); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean ownUpdatesAreVisible(int type) throws SQLException {
+        { try { return _meta.ownUpdatesAreVisible(type); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean storesLowerCaseIdentifiers() throws SQLException {
+        { try { return _meta.storesLowerCaseIdentifiers(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean storesLowerCaseQuotedIdentifiers() throws SQLException {
+        { try { return _meta.storesLowerCaseQuotedIdentifiers(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean storesMixedCaseIdentifiers() throws SQLException {
+        { try { return _meta.storesMixedCaseIdentifiers(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean storesMixedCaseQuotedIdentifiers() throws SQLException {
+        { try { return _meta.storesMixedCaseQuotedIdentifiers(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean storesUpperCaseIdentifiers() throws SQLException {
+        { try { return _meta.storesUpperCaseIdentifiers(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean storesUpperCaseQuotedIdentifiers() throws SQLException {
+        { try { return _meta.storesUpperCaseQuotedIdentifiers(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsANSI92EntryLevelSQL() throws SQLException {
+        { try { return _meta.supportsANSI92EntryLevelSQL(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsANSI92FullSQL() throws SQLException {
+        { try { return _meta.supportsANSI92FullSQL(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsANSI92IntermediateSQL() throws SQLException {
+        { try { return _meta.supportsANSI92IntermediateSQL(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsAlterTableWithAddColumn() throws SQLException {
+        { try { return _meta.supportsAlterTableWithAddColumn(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsAlterTableWithDropColumn() throws SQLException {
+        { try { return _meta.supportsAlterTableWithDropColumn(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsBatchUpdates() throws SQLException {
+        { try { return _meta.supportsBatchUpdates(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsCatalogsInDataManipulation() throws SQLException {
+        { try { return _meta.supportsCatalogsInDataManipulation(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsCatalogsInIndexDefinitions() throws SQLException {
+        { try { return _meta.supportsCatalogsInIndexDefinitions(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsCatalogsInPrivilegeDefinitions() throws SQLException {
+        { try { return _meta.supportsCatalogsInPrivilegeDefinitions(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsCatalogsInProcedureCalls() throws SQLException {
+        { try { return _meta.supportsCatalogsInProcedureCalls(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsCatalogsInTableDefinitions() throws SQLException {
+        { try { return _meta.supportsCatalogsInTableDefinitions(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsColumnAliasing() throws SQLException {
+        { try { return _meta.supportsColumnAliasing(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsConvert() throws SQLException {
+        { try { return _meta.supportsConvert(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsConvert(int fromType, int toType)
+            throws SQLException {
+        { try { return _meta.supportsConvert(fromType, toType); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsCoreSQLGrammar() throws SQLException {
+        { try { return _meta.supportsCoreSQLGrammar(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsCorrelatedSubqueries() throws SQLException {
+        { try { return _meta.supportsCorrelatedSubqueries(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsDataDefinitionAndDataManipulationTransactions()
+            throws SQLException {
+        { try { return _meta.supportsDataDefinitionAndDataManipulationTransactions(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsDataManipulationTransactionsOnly()
+            throws SQLException {
+        { try { return _meta.supportsDataManipulationTransactionsOnly(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsDifferentTableCorrelationNames() throws SQLException {
+        { try { return _meta.supportsDifferentTableCorrelationNames(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsExpressionsInOrderBy() throws SQLException {
+        { try { return _meta.supportsExpressionsInOrderBy(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsExtendedSQLGrammar() throws SQLException {
+        { try { return _meta.supportsExtendedSQLGrammar(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsFullOuterJoins() throws SQLException {
+        { try { return _meta.supportsFullOuterJoins(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsGetGeneratedKeys() throws SQLException {
+        { try { return _meta.supportsGetGeneratedKeys(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsGroupBy() throws SQLException {
+        { try { return _meta.supportsGroupBy(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsGroupByBeyondSelect() throws SQLException {
+        { try { return _meta.supportsGroupByBeyondSelect(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsGroupByUnrelated() throws SQLException {
+        { try { return _meta.supportsGroupByUnrelated(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsIntegrityEnhancementFacility() throws SQLException {
+        { try { return _meta.supportsIntegrityEnhancementFacility(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsLikeEscapeClause() throws SQLException {
+        { try { return _meta.supportsLikeEscapeClause(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsLimitedOuterJoins() throws SQLException {
+        { try { return _meta.supportsLimitedOuterJoins(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsMinimumSQLGrammar() throws SQLException {
+        { try { return _meta.supportsMinimumSQLGrammar(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsMixedCaseIdentifiers() throws SQLException {
+        { try { return _meta.supportsMixedCaseIdentifiers(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {
+        { try { return _meta.supportsMixedCaseQuotedIdentifiers(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsMultipleOpenResults() throws SQLException {
+        { try { return _meta.supportsMultipleOpenResults(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsMultipleResultSets() throws SQLException {
+        { try { return _meta.supportsMultipleResultSets(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsMultipleTransactions() throws SQLException {
+        { try { return _meta.supportsMultipleTransactions(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsNamedParameters() throws SQLException {
+        { try { return _meta.supportsNamedParameters(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsNonNullableColumns() throws SQLException {
+        { try { return _meta.supportsNonNullableColumns(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsOpenCursorsAcrossCommit() throws SQLException {
+        { try { return _meta.supportsOpenCursorsAcrossCommit(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsOpenCursorsAcrossRollback() throws SQLException {
+        { try { return _meta.supportsOpenCursorsAcrossRollback(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsOpenStatementsAcrossCommit() throws SQLException {
+        { try { return _meta.supportsOpenStatementsAcrossCommit(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsOpenStatementsAcrossRollback() throws SQLException {
+        { try { return _meta.supportsOpenStatementsAcrossRollback(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsOrderByUnrelated() throws SQLException {
+        { try { return _meta.supportsOrderByUnrelated(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsOuterJoins() throws SQLException {
+        { try { return _meta.supportsOuterJoins(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsPositionedDelete() throws SQLException {
+        { try { return _meta.supportsPositionedDelete(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsPositionedUpdate() throws SQLException {
+        { try { return _meta.supportsPositionedUpdate(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsResultSetConcurrency(int type, int concurrency)
+            throws SQLException {
+        { try { return _meta.supportsResultSetConcurrency(type, concurrency); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsResultSetHoldability(int holdability)
+            throws SQLException {
+        { try { return _meta.supportsResultSetHoldability(holdability); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsResultSetType(int type) throws SQLException {
+        { try { return _meta.supportsResultSetType(type); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsSavepoints() throws SQLException {
+        { try { return _meta.supportsSavepoints(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsSchemasInDataManipulation() throws SQLException {
+        { try { return _meta.supportsSchemasInDataManipulation(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsSchemasInIndexDefinitions() throws SQLException {
+        { try { return _meta.supportsSchemasInIndexDefinitions(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsSchemasInPrivilegeDefinitions() throws SQLException {
+        { try { return _meta.supportsSchemasInPrivilegeDefinitions(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsSchemasInProcedureCalls() throws SQLException {
+        { try { return _meta.supportsSchemasInProcedureCalls(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsSchemasInTableDefinitions() throws SQLException {
+        { try { return _meta.supportsSchemasInTableDefinitions(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsSelectForUpdate() throws SQLException {
+        { try { return _meta.supportsSelectForUpdate(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsStatementPooling() throws SQLException {
+        { try { return _meta.supportsStatementPooling(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsStoredProcedures() throws SQLException {
+        { try { return _meta.supportsStoredProcedures(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsSubqueriesInComparisons() throws SQLException {
+        { try { return _meta.supportsSubqueriesInComparisons(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsSubqueriesInExists() throws SQLException {
+        { try { return _meta.supportsSubqueriesInExists(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsSubqueriesInIns() throws SQLException {
+        { try { return _meta.supportsSubqueriesInIns(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsSubqueriesInQuantifieds() throws SQLException {
+        { try { return _meta.supportsSubqueriesInQuantifieds(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsTableCorrelationNames() throws SQLException {
+        { try { return _meta.supportsTableCorrelationNames(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsTransactionIsolationLevel(int level)
+            throws SQLException {
+        { try { return _meta.supportsTransactionIsolationLevel(level); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsTransactions() throws SQLException {
+        { try { return _meta.supportsTransactions(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsUnion() throws SQLException {
+        { try { return _meta.supportsUnion(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsUnionAll() throws SQLException {
+        { try { return _meta.supportsUnionAll(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean updatesAreDetected(int type) throws SQLException {
+        { try { return _meta.updatesAreDetected(type); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean usesLocalFilePerTable() throws SQLException {
+        { try { return _meta.usesLocalFilePerTable(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean usesLocalFiles() throws SQLException {
+        { try { return _meta.usesLocalFiles(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    /* JDBC_4_ANT_KEY_BEGIN */
+
+    @Override
+    public boolean isWrapperFor(Class<?> iface) throws SQLException {
+        if (iface.isAssignableFrom(getClass())) {
+            return true;
+        } else if (iface.isAssignableFrom(_meta.getClass())) {
+            return true;
+        } else {
+            return _meta.isWrapperFor(iface);
+        }
+    }
+
+    @Override
+    public <T> T unwrap(Class<T> iface) throws SQLException {
+        if (iface.isAssignableFrom(getClass())) {
+            return iface.cast(this);
+        } else if (iface.isAssignableFrom(_meta.getClass())) {
+            return iface.cast(_meta);
+        } else {
+            return _meta.unwrap(iface);
+        }
+    }
+
+    @Override
+    public RowIdLifetime getRowIdLifetime() throws SQLException {
+        { try { return _meta.getRowIdLifetime(); }
+        catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+    }
+
+    @Override
+    public ResultSet getSchemas(String catalog, String schemaPattern)
+    throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getSchemas(catalog, schemaPattern));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public boolean autoCommitFailureClosesAllResultSets() throws SQLException {
+        { try { return _meta.autoCommitFailureClosesAllResultSets(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public boolean supportsStoredFunctionsUsingCallSyntax() throws SQLException {
+        { try { return _meta.supportsStoredFunctionsUsingCallSyntax(); }
+        catch (SQLException e) { handleException(e); return false; } }
+    }
+
+    @Override
+    public ResultSet getClientInfoProperties() throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getClientInfoProperties());
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public ResultSet getFunctions(String catalog, String schemaPattern,
+            String functionNamePattern) throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getFunctions(catalog, schemaPattern,
+                            functionNamePattern));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public ResultSet getFunctionColumns(String catalog, String schemaPattern,
+            String functionNamePattern, String columnNamePattern)
+            throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getFunctionColumns(catalog, schemaPattern,
+                            functionNamePattern, columnNamePattern));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    /* JDBC_4_ANT_KEY_END */
+
+    @Override
+    public ResultSet getPseudoColumns(String catalog, String schemaPattern,
+            String tableNamePattern, String columnNamePattern)
+            throws SQLException {
+        _conn.checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(_conn,
+                    _meta.getPseudoColumns(catalog, schemaPattern,
+                            tableNamePattern, columnNamePattern));
+}
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public boolean generatedKeyAlwaysReturned() throws SQLException {
+        _conn.checkOpen();
+        try {
+            return _meta.generatedKeyAlwaysReturned();
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+}

==================================================
DelegatingResultSet.java
new file mode 100644
index 0000000000..7d29cdcf86
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingPreparedStatement.java
@@ -0,0 +1,466 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.io.InputStream;
+import java.io.Reader;
+import java.math.BigDecimal;
+import java.sql.Array;
+import java.sql.Blob;
+import java.sql.Clob;
+import java.sql.Date;
+import java.sql.NClob;
+import java.sql.PreparedStatement;
+import java.sql.Ref;
+import java.sql.ResultSet;
+import java.sql.ResultSetMetaData;
+import java.sql.RowId;
+import java.sql.SQLException;
+import java.sql.SQLXML;
+import java.sql.Statement;
+import java.sql.Time;
+import java.sql.Timestamp;
+import java.util.Calendar;
+
+/**
+ * A base delegating implementation of {@link PreparedStatement}.
+ * <p>
+ * All of the methods from the {@link PreparedStatement} interface
+ * simply check to see that the {@link PreparedStatement} is active,
+ * and call the corresponding method on the "delegate"
+ * provided in my constructor.
+ * <p>
+ * Extends AbandonedTrace to implement Statement tracking and
+ * logging of code which created the Statement. Tracking the
+ * Statement ensures that the Connection which created it can
+ * close any open Statement's on Connection close.
+ *
+ * @author Rodney Waldhoff
+ * @author Glenn L. Nielsen
+ * @author James House
+ * @author Dirk Verbeeck
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class DelegatingPreparedStatement extends DelegatingStatement
+        implements PreparedStatement {
+
+    /**
+     * Create a wrapper for the Statement which traces this
+     * Statement to the Connection which created it and the
+     * code which created it.
+     *
+     * @param s the {@link PreparedStatement} to delegate all calls to.
+     * @param c the {@link DelegatingConnection} that created this statement.
+     */
+    public DelegatingPreparedStatement(DelegatingConnection<?> c,
+                                       PreparedStatement s) {
+        super(c, s);
+    }
+
+    @Override
+    public ResultSet executeQuery() throws SQLException {
+        checkOpen();
+        if (getConnectionInternal() != null) {
+            getConnectionInternal().setLastUsed();
+        }
+        try {
+            return DelegatingResultSet.wrapResultSet(this,((PreparedStatement)getDelegate()).executeQuery());
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public int executeUpdate() throws SQLException {
+        checkOpen();
+        if (getConnectionInternal() != null) {
+            getConnectionInternal().setLastUsed();
+        }
+        try {
+            return ((PreparedStatement) getDelegate()).executeUpdate();
+        } catch (SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
+
+    @Override
+    public void setNull(int parameterIndex, int sqlType) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setNull(parameterIndex,sqlType); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setBoolean(int parameterIndex, boolean x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setBoolean(parameterIndex,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setByte(int parameterIndex, byte x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setByte(parameterIndex,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setShort(int parameterIndex, short x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setShort(parameterIndex,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setInt(int parameterIndex, int x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setInt(parameterIndex,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setLong(int parameterIndex, long x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setLong(parameterIndex,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setFloat(int parameterIndex, float x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setFloat(parameterIndex,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setDouble(int parameterIndex, double x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setDouble(parameterIndex,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setBigDecimal(parameterIndex,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setString(int parameterIndex, String x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setString(parameterIndex,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setBytes(int parameterIndex, byte[] x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setBytes(parameterIndex,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setDate(int parameterIndex, Date x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setDate(parameterIndex,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setTime(int parameterIndex, Time x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setTime(parameterIndex,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setTimestamp(int parameterIndex, Timestamp x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setTimestamp(parameterIndex,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setAsciiStream(parameterIndex,x,length); } catch (SQLException e) { handleException(e); } }
+
+    /** @deprecated */
+    @Deprecated
+    @Override
+    public void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setUnicodeStream(parameterIndex,x,length); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setBinaryStream(parameterIndex,x,length); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void clearParameters() throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).clearParameters(); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setObject(int parameterIndex, Object x, int targetSqlType, int scale) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setObject(parameterIndex, x, targetSqlType, scale); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setObject(parameterIndex, x, targetSqlType); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setObject(int parameterIndex, Object x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setObject(parameterIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public boolean execute() throws SQLException {
+        checkOpen();
+        if (getConnectionInternal() != null) {
+            getConnectionInternal().setLastUsed();
+        }
+        try {
+            return ((PreparedStatement) getDelegate()).execute();
+        } catch (SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
+    @Override
+    public void addBatch() throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).addBatch(); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setCharacterStream(int parameterIndex, Reader reader, int length) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setCharacterStream(parameterIndex,reader,length); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setRef(int i, Ref x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setRef(i,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setBlob(int i, Blob x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setBlob(i,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setClob(int i, Clob x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setClob(i,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setArray(int i, Array x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setArray(i,x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public ResultSetMetaData getMetaData() throws SQLException
+    { checkOpen(); try { return ((PreparedStatement)getDelegate()).getMetaData(); } catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+
+    @Override
+    public void setDate(int parameterIndex, Date x, Calendar cal) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setDate(parameterIndex,x,cal); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setTime(int parameterIndex, Time x, Calendar cal) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setTime(parameterIndex,x,cal); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setTimestamp(parameterIndex,x,cal); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setNull(int paramIndex, int sqlType, String typeName) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setNull(paramIndex,sqlType,typeName); } catch (SQLException e) { handleException(e); } }
+
+    /**
+     * Returns a String representation of this object.
+     *
+     * @return String
+     */
+    @Override
+    public String toString() {
+        Statement statement = getDelegate();
+        return statement == null ? "NULL" : statement.toString();
+    }
+
+    @Override
+    public void setURL(int parameterIndex, java.net.URL x) throws SQLException
+    { checkOpen(); try { ((PreparedStatement)getDelegate()).setURL(parameterIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public java.sql.ParameterMetaData getParameterMetaData() throws SQLException
+    { checkOpen(); try { return ((PreparedStatement)getDelegate()).getParameterMetaData(); } catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+
+
+    @Override
+    public void setRowId(int parameterIndex, RowId value) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setRowId(parameterIndex, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setNString(int parameterIndex, String value) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setNString(parameterIndex, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setNCharacterStream(parameterIndex, value, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setNClob(int parameterIndex, NClob value) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setNClob(parameterIndex, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setClob(int parameterIndex, Reader reader, long length) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setClob(parameterIndex, reader, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setBlob(int parameterIndex, InputStream inputStream, long length) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setBlob(parameterIndex, inputStream, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setNClob(int parameterIndex, Reader reader, long length) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setNClob(parameterIndex, reader, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setSQLXML(int parameterIndex, SQLXML value) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setSQLXML(parameterIndex, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setAsciiStream(int parameterIndex, InputStream inputStream, long length) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setAsciiStream(parameterIndex, inputStream, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setBinaryStream(int parameterIndex, InputStream inputStream, long length) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setBinaryStream(parameterIndex, inputStream, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setCharacterStream(parameterIndex, reader, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setAsciiStream(int parameterIndex, InputStream inputStream) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setAsciiStream(parameterIndex, inputStream);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setBinaryStream(int parameterIndex, InputStream inputStream) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setBinaryStream(parameterIndex, inputStream);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setCharacterStream(int parameterIndex, Reader reader) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setCharacterStream(parameterIndex, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setNCharacterStream(int parameterIndex, Reader reader) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setNCharacterStream(parameterIndex, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setClob(int parameterIndex, Reader reader) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setClob(parameterIndex, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setBlob(int parameterIndex, InputStream inputStream) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setBlob(parameterIndex, inputStream);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void setNClob(int parameterIndex, Reader reader) throws SQLException {
+        checkOpen();
+        try {
+            ((PreparedStatement)getDelegate()).setNClob(parameterIndex, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+}

==================================================
DelegatingStatement.java
new file mode 100644
index 0000000000..342c74cb21
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingResultSet.java
@@ -0,0 +1,1283 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.io.InputStream;
+import java.io.Reader;
+import java.math.BigDecimal;
+import java.sql.Array;
+import java.sql.Blob;
+import java.sql.Clob;
+import java.sql.Connection;
+import java.sql.Date;
+import java.sql.NClob;
+import java.sql.Ref;
+import java.sql.ResultSet;
+import java.sql.ResultSetMetaData;
+import java.sql.RowId;
+import java.sql.SQLException;
+import java.sql.SQLWarning;
+import java.sql.SQLXML;
+import java.sql.Statement;
+import java.sql.Time;
+import java.sql.Timestamp;
+import java.util.Calendar;
+import java.util.Map;
+
+/**
+ * A base delegating implementation of {@link ResultSet}.
+ * <p>
+ * All of the methods from the {@link ResultSet} interface
+ * simply call the corresponding method on the "delegate"
+ * provided in my constructor.
+ * <p>
+ * Extends AbandonedTrace to implement result set tracking and
+ * logging of code which created the ResultSet. Tracking the
+ * ResultSet ensures that the Statement which created it can
+ * close any open ResultSet's on Statement close.
+ *
+ * @author Glenn L. Nielsen
+ * @author James House
+ * @author Dirk Verbeeck
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public final class DelegatingResultSet extends AbandonedTrace implements ResultSet {
+
+    /** My delegate. **/
+    private final ResultSet _res;
+
+    /** The Statement that created me, if any. **/
+    private Statement _stmt;
+
+    /** The Connection that created me, if any. **/
+    private Connection _conn;
+
+    /**
+     * Create a wrapper for the ResultSet which traces this
+     * ResultSet to the Statement which created it and the
+     * code which created it.
+     * <p>
+     * Private to ensure all construction is
+     * {@link #wrapResultSet(Statement, ResultSet)}
+     *
+     * @param stmt Statement which created this ResultSet
+     * @param res ResultSet to wrap
+     */
+    private DelegatingResultSet(Statement stmt, ResultSet res) {
+        super((AbandonedTrace)stmt);
+        this._stmt = stmt;
+        this._res = res;
+    }
+
+    /**
+     * Create a wrapper for the ResultSet which traces this
+     * ResultSet to the Connection which created it (via, for
+     * example DatabaseMetadata, and the code which created it.
+     * <p>
+     * Private to ensure all construction is
+     * {@link #wrapResultSet(Connection, ResultSet)}
+     *
+     * @param conn Connection which created this ResultSet
+     * @param res ResultSet to wrap
+     */
+    private DelegatingResultSet(Connection conn, ResultSet res) {
+        super((AbandonedTrace)conn);
+        this._conn = conn;
+        this._res = res;
+    }
+
+    public static ResultSet wrapResultSet(Statement stmt, ResultSet rset) {
+        if(null == rset) {
+            return null;
+        }
+        return new DelegatingResultSet(stmt,rset);
+    }
+
+    public static ResultSet wrapResultSet(Connection conn, ResultSet rset) {
+        if(null == rset) {
+            return null;
+        }
+        return new DelegatingResultSet(conn,rset);
+    }
+
+    public ResultSet getDelegate() {
+        return _res;
+    }
+
+    /**
+     * If my underlying {@link ResultSet} is not a
+     * <tt>DelegatingResultSet</tt>, returns it,
+     * otherwise recursively invokes this method on
+     * my delegate.
+     * <p>
+     * Hence this method will return the first
+     * delegate that is not a <tt>DelegatingResultSet</tt>,
+     * or <tt>null</tt> when no non-<tt>DelegatingResultSet</tt>
+     * delegate can be found by transversing this chain.
+     * <p>
+     * This method is useful when you may have nested
+     * <tt>DelegatingResultSet</tt>s, and you want to make
+     * sure to obtain a "genuine" {@link ResultSet}.
+     */
+    public ResultSet getInnermostDelegate() {
+        ResultSet r = _res;
+        while(r != null && r instanceof DelegatingResultSet) {
+            r = ((DelegatingResultSet)r).getDelegate();
+            if(this == r) {
+                return null;
+            }
+        }
+        return r;
+    }
+
+    @Override
+    public Statement getStatement() throws SQLException {
+        return _stmt;
+    }
+
+    /**
+     * Wrapper for close of ResultSet which removes this
+     * result set from being traced then calls close on
+     * the original ResultSet.
+     */
+    @Override
+    public void close() throws SQLException {
+        try {
+            if(_stmt != null) {
+                ((AbandonedTrace)_stmt).removeTrace(this);
+                _stmt = null;
+            }
+            if(_conn != null) {
+                ((AbandonedTrace)_conn).removeTrace(this);
+                _conn = null;
+            }
+            _res.close();
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    protected void handleException(SQLException e) throws SQLException {
+        if (_stmt != null && _stmt instanceof DelegatingStatement) {
+            ((DelegatingStatement)_stmt).handleException(e);
+        }
+        else if (_conn != null && _conn instanceof DelegatingConnection) {
+            ((DelegatingConnection<?>)_conn).handleException(e);
+        }
+        else {
+            throw e;
+        }
+    }
+
+    @Override
+    public boolean next() throws SQLException
+    { try { return _res.next(); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public boolean wasNull() throws SQLException
+    { try { return _res.wasNull(); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public String getString(int columnIndex) throws SQLException
+    { try { return _res.getString(columnIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public boolean getBoolean(int columnIndex) throws SQLException
+    { try { return _res.getBoolean(columnIndex); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public byte getByte(int columnIndex) throws SQLException
+    { try { return _res.getByte(columnIndex); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public short getShort(int columnIndex) throws SQLException
+    { try { return _res.getShort(columnIndex); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public int getInt(int columnIndex) throws SQLException
+    { try { return _res.getInt(columnIndex); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public long getLong(int columnIndex) throws SQLException
+    { try { return _res.getLong(columnIndex); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public float getFloat(int columnIndex) throws SQLException
+    { try { return _res.getFloat(columnIndex); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public double getDouble(int columnIndex) throws SQLException
+    { try { return _res.getDouble(columnIndex); } catch (SQLException e) { handleException(e); return 0; } }
+
+    /** @deprecated */
+    @Deprecated
+    @Override
+    public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException
+    { try { return _res.getBigDecimal(columnIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public byte[] getBytes(int columnIndex) throws SQLException
+    { try { return _res.getBytes(columnIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Date getDate(int columnIndex) throws SQLException
+    { try { return _res.getDate(columnIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Time getTime(int columnIndex) throws SQLException
+    { try { return _res.getTime(columnIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Timestamp getTimestamp(int columnIndex) throws SQLException
+    { try { return _res.getTimestamp(columnIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public InputStream getAsciiStream(int columnIndex) throws SQLException
+    { try { return _res.getAsciiStream(columnIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    /** @deprecated */
+    @Deprecated
+    @Override
+    public InputStream getUnicodeStream(int columnIndex) throws SQLException
+    { try { return _res.getUnicodeStream(columnIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public InputStream getBinaryStream(int columnIndex) throws SQLException
+    { try { return _res.getBinaryStream(columnIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public String getString(String columnName) throws SQLException
+    { try { return _res.getString(columnName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public boolean getBoolean(String columnName) throws SQLException
+    { try { return _res.getBoolean(columnName); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public byte getByte(String columnName) throws SQLException
+    { try { return _res.getByte(columnName); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public short getShort(String columnName) throws SQLException
+    { try { return _res.getShort(columnName); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public int getInt(String columnName) throws SQLException
+    { try { return _res.getInt(columnName); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public long getLong(String columnName) throws SQLException
+    { try { return _res.getLong(columnName); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public float getFloat(String columnName) throws SQLException
+    { try { return _res.getFloat(columnName); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public double getDouble(String columnName) throws SQLException
+    { try { return _res.getDouble(columnName); } catch (SQLException e) { handleException(e); return 0; } }
+
+    /** @deprecated */
+    @Deprecated
+    @Override
+    public BigDecimal getBigDecimal(String columnName, int scale) throws SQLException
+    { try { return _res.getBigDecimal(columnName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public byte[] getBytes(String columnName) throws SQLException
+    { try { return _res.getBytes(columnName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Date getDate(String columnName) throws SQLException
+    { try { return _res.getDate(columnName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Time getTime(String columnName) throws SQLException
+    { try { return _res.getTime(columnName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Timestamp getTimestamp(String columnName) throws SQLException
+    { try { return _res.getTimestamp(columnName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public InputStream getAsciiStream(String columnName) throws SQLException
+    { try { return _res.getAsciiStream(columnName); } catch (SQLException e) { handleException(e); return null; } }
+
+    /** @deprecated */
+    @Deprecated
+    @Override
+    public InputStream getUnicodeStream(String columnName) throws SQLException
+    { try { return _res.getUnicodeStream(columnName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public InputStream getBinaryStream(String columnName) throws SQLException
+    { try { return _res.getBinaryStream(columnName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public SQLWarning getWarnings() throws SQLException
+    { try { return _res.getWarnings(); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public void clearWarnings() throws SQLException
+    { try { _res.clearWarnings(); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public String getCursorName() throws SQLException
+    { try { return _res.getCursorName(); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public ResultSetMetaData getMetaData() throws SQLException
+    { try { return _res.getMetaData(); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Object getObject(int columnIndex) throws SQLException
+    { try { return _res.getObject(columnIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Object getObject(String columnName) throws SQLException
+    { try { return _res.getObject(columnName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public int findColumn(String columnName) throws SQLException
+    { try { return _res.findColumn(columnName); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public Reader getCharacterStream(int columnIndex) throws SQLException
+    { try { return _res.getCharacterStream(columnIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Reader getCharacterStream(String columnName) throws SQLException
+    { try { return _res.getCharacterStream(columnName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public BigDecimal getBigDecimal(int columnIndex) throws SQLException
+    { try { return _res.getBigDecimal(columnIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public BigDecimal getBigDecimal(String columnName) throws SQLException
+    { try { return _res.getBigDecimal(columnName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public boolean isBeforeFirst() throws SQLException
+    { try { return _res.isBeforeFirst(); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public boolean isAfterLast() throws SQLException
+    { try { return _res.isAfterLast(); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public boolean isFirst() throws SQLException
+    { try { return _res.isFirst(); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public boolean isLast() throws SQLException
+    { try { return _res.isLast(); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public void beforeFirst() throws SQLException
+    { try { _res.beforeFirst(); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void afterLast() throws SQLException
+    { try { _res.afterLast(); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public boolean first() throws SQLException
+    { try { return _res.first(); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public boolean last() throws SQLException
+    { try { return _res.last(); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public int getRow() throws SQLException
+    { try { return _res.getRow(); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public boolean absolute(int row) throws SQLException
+    { try { return _res.absolute(row); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public boolean relative(int rows) throws SQLException
+    { try { return _res.relative(rows); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public boolean previous() throws SQLException
+    { try { return _res.previous(); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public void setFetchDirection(int direction) throws SQLException
+    { try { _res.setFetchDirection(direction); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public int getFetchDirection() throws SQLException
+    { try { return _res.getFetchDirection(); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public void setFetchSize(int rows) throws SQLException
+    { try { _res.setFetchSize(rows); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public int getFetchSize() throws SQLException
+    { try { return _res.getFetchSize(); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public int getType() throws SQLException
+    { try { return _res.getType(); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public int getConcurrency() throws SQLException
+    { try { return _res.getConcurrency(); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public boolean rowUpdated() throws SQLException
+    { try { return _res.rowUpdated(); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public boolean rowInserted() throws SQLException
+    { try { return _res.rowInserted(); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public boolean rowDeleted() throws SQLException
+    { try { return _res.rowDeleted(); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public void updateNull(int columnIndex) throws SQLException
+    { try { _res.updateNull(columnIndex); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateBoolean(int columnIndex, boolean x) throws SQLException
+    { try { _res.updateBoolean(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateByte(int columnIndex, byte x) throws SQLException
+    { try { _res.updateByte(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateShort(int columnIndex, short x) throws SQLException
+    { try { _res.updateShort(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateInt(int columnIndex, int x) throws SQLException
+    { try { _res.updateInt(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateLong(int columnIndex, long x) throws SQLException
+    { try { _res.updateLong(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateFloat(int columnIndex, float x) throws SQLException
+    { try { _res.updateFloat(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateDouble(int columnIndex, double x) throws SQLException
+    { try { _res.updateDouble(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException
+    { try { _res.updateBigDecimal(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateString(int columnIndex, String x) throws SQLException
+    { try { _res.updateString(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateBytes(int columnIndex, byte[] x) throws SQLException
+    { try { _res.updateBytes(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateDate(int columnIndex, Date x) throws SQLException
+    { try { _res.updateDate(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateTime(int columnIndex, Time x) throws SQLException
+    { try { _res.updateTime(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateTimestamp(int columnIndex, Timestamp x) throws SQLException
+    { try { _res.updateTimestamp(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateAsciiStream(int columnIndex, InputStream x, int length) throws SQLException
+    { try { _res.updateAsciiStream(columnIndex, x, length); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateBinaryStream(int columnIndex, InputStream x, int length) throws SQLException
+    { try { _res.updateBinaryStream(columnIndex, x, length); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateCharacterStream(int columnIndex, Reader x, int length) throws SQLException
+    { try { _res.updateCharacterStream(columnIndex, x, length); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateObject(int columnIndex, Object x, int scale) throws SQLException
+    { try { _res.updateObject(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateObject(int columnIndex, Object x) throws SQLException
+    { try { _res.updateObject(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateNull(String columnName) throws SQLException
+    { try { _res.updateNull(columnName); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateBoolean(String columnName, boolean x) throws SQLException
+    { try { _res.updateBoolean(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateByte(String columnName, byte x) throws SQLException
+    { try { _res.updateByte(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateShort(String columnName, short x) throws SQLException
+    { try { _res.updateShort(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateInt(String columnName, int x) throws SQLException
+    { try { _res.updateInt(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateLong(String columnName, long x) throws SQLException
+    { try { _res.updateLong(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateFloat(String columnName, float x) throws SQLException
+    { try { _res.updateFloat(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateDouble(String columnName, double x) throws SQLException
+    { try { _res.updateDouble(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateBigDecimal(String columnName, BigDecimal x) throws SQLException
+    { try { _res.updateBigDecimal(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateString(String columnName, String x) throws SQLException
+    { try { _res.updateString(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateBytes(String columnName, byte[] x) throws SQLException
+    { try { _res.updateBytes(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateDate(String columnName, Date x) throws SQLException
+    { try { _res.updateDate(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateTime(String columnName, Time x) throws SQLException
+    { try { _res.updateTime(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateTimestamp(String columnName, Timestamp x) throws SQLException
+    { try { _res.updateTimestamp(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateAsciiStream(String columnName, InputStream x, int length) throws SQLException
+    { try { _res.updateAsciiStream(columnName, x, length); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateBinaryStream(String columnName, InputStream x, int length) throws SQLException
+    { try { _res.updateBinaryStream(columnName, x, length); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateCharacterStream(String columnName, Reader reader, int length) throws SQLException
+    { try { _res.updateCharacterStream(columnName, reader, length); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateObject(String columnName, Object x, int scale) throws SQLException
+    { try { _res.updateObject(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateObject(String columnName, Object x) throws SQLException
+    { try { _res.updateObject(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void insertRow() throws SQLException
+    { try { _res.insertRow(); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateRow() throws SQLException
+    { try { _res.updateRow(); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void deleteRow() throws SQLException
+    { try { _res.deleteRow(); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void refreshRow() throws SQLException
+    { try { _res.refreshRow(); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void cancelRowUpdates() throws SQLException
+    { try { _res.cancelRowUpdates(); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void moveToInsertRow() throws SQLException
+    { try { _res.moveToInsertRow(); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void moveToCurrentRow() throws SQLException
+    { try { _res.moveToCurrentRow(); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public Object getObject(int i, Map<String,Class<?>> map) throws SQLException
+    { try { return _res.getObject(i, map); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Ref getRef(int i) throws SQLException
+    { try { return _res.getRef(i); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Blob getBlob(int i) throws SQLException
+    { try { return _res.getBlob(i); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Clob getClob(int i) throws SQLException
+    { try { return _res.getClob(i); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Array getArray(int i) throws SQLException
+    { try { return _res.getArray(i); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Object getObject(String colName, Map<String,Class<?>> map) throws SQLException
+    { try { return _res.getObject(colName, map); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Ref getRef(String colName) throws SQLException
+    { try { return _res.getRef(colName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Blob getBlob(String colName) throws SQLException
+    { try { return _res.getBlob(colName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Clob getClob(String colName) throws SQLException
+    { try { return _res.getClob(colName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Array getArray(String colName) throws SQLException
+    { try { return _res.getArray(colName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Date getDate(int columnIndex, Calendar cal) throws SQLException
+    { try { return _res.getDate(columnIndex, cal); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Date getDate(String columnName, Calendar cal) throws SQLException
+    { try { return _res.getDate(columnName, cal); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Time getTime(int columnIndex, Calendar cal) throws SQLException
+    { try { return _res.getTime(columnIndex, cal); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Time getTime(String columnName, Calendar cal) throws SQLException
+    { try { return _res.getTime(columnName, cal); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException
+    { try { return _res.getTimestamp(columnIndex, cal); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public Timestamp getTimestamp(String columnName, Calendar cal) throws SQLException
+    { try { return _res.getTimestamp(columnName, cal); } catch (SQLException e) { handleException(e); return null; } }
+
+
+    @Override
+    public java.net.URL getURL(int columnIndex) throws SQLException
+    { try { return _res.getURL(columnIndex); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public java.net.URL getURL(String columnName) throws SQLException
+    { try { return _res.getURL(columnName); } catch (SQLException e) { handleException(e); return null; } }
+
+    @Override
+    public void updateRef(int columnIndex, Ref x) throws SQLException
+    { try { _res.updateRef(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateRef(String columnName, Ref x) throws SQLException
+    { try { _res.updateRef(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateBlob(int columnIndex, Blob x) throws SQLException
+    { try { _res.updateBlob(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateBlob(String columnName, Blob x) throws SQLException
+    { try { _res.updateBlob(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateClob(int columnIndex, Clob x) throws SQLException
+    { try { _res.updateClob(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateClob(String columnName, Clob x) throws SQLException
+    { try { _res.updateClob(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateArray(int columnIndex, Array x) throws SQLException
+    { try { _res.updateArray(columnIndex, x); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void updateArray(String columnName, Array x) throws SQLException
+    { try { _res.updateArray(columnName, x); } catch (SQLException e) { handleException(e); } }
+
+
+    @Override
+    public boolean isWrapperFor(Class<?> iface) throws SQLException {
+        if (iface.isAssignableFrom(getClass())) {
+            return true;
+        } else if (iface.isAssignableFrom(_res.getClass())) {
+            return true;
+        } else {
+            return _res.isWrapperFor(iface);
+        }
+    }
+
+    @Override
+    public <T> T unwrap(Class<T> iface) throws SQLException {
+        if (iface.isAssignableFrom(getClass())) {
+            return iface.cast(this);
+        } else if (iface.isAssignableFrom(_res.getClass())) {
+            return iface.cast(_res);
+        } else {
+            return _res.unwrap(iface);
+        }
+    }
+
+    @Override
+    public RowId getRowId(int columnIndex) throws SQLException {
+        try {
+            return _res.getRowId(columnIndex);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public RowId getRowId(String columnLabel) throws SQLException {
+        try {
+            return _res.getRowId(columnLabel);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public void updateRowId(int columnIndex, RowId value) throws SQLException {
+        try {
+            _res.updateRowId(columnIndex, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateRowId(String columnLabel, RowId value) throws SQLException {
+        try {
+            _res.updateRowId(columnLabel, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public int getHoldability() throws SQLException {
+        try {
+            return _res.getHoldability();
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
+
+    @Override
+    public boolean isClosed() throws SQLException {
+        try {
+            return _res.isClosed();
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
+    @Override
+    public void updateNString(int columnIndex, String value) throws SQLException {
+        try {
+            _res.updateNString(columnIndex, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateNString(String columnLabel, String value) throws SQLException {
+        try {
+            _res.updateNString(columnLabel, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateNClob(int columnIndex, NClob value) throws SQLException {
+        try {
+            _res.updateNClob(columnIndex, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateNClob(String columnLabel, NClob value) throws SQLException {
+        try {
+            _res.updateNClob(columnLabel, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public NClob getNClob(int columnIndex) throws SQLException {
+        try {
+            return _res.getNClob(columnIndex);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public NClob getNClob(String columnLabel) throws SQLException {
+        try {
+            return _res.getNClob(columnLabel);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public SQLXML getSQLXML(int columnIndex) throws SQLException {
+        try {
+            return _res.getSQLXML(columnIndex);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public SQLXML getSQLXML(String columnLabel) throws SQLException {
+        try {
+            return _res.getSQLXML(columnLabel);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public void updateSQLXML(int columnIndex, SQLXML value) throws SQLException {
+        try {
+            _res.updateSQLXML(columnIndex, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateSQLXML(String columnLabel, SQLXML value) throws SQLException {
+        try {
+            _res.updateSQLXML(columnLabel, value);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public String getNString(int columnIndex) throws SQLException {
+        try {
+            return _res.getNString(columnIndex);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public String getNString(String columnLabel) throws SQLException {
+        try {
+            return _res.getNString(columnLabel);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public Reader getNCharacterStream(int columnIndex) throws SQLException {
+        try {
+            return _res.getNCharacterStream(columnIndex);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public Reader getNCharacterStream(String columnLabel) throws SQLException {
+        try {
+            return _res.getNCharacterStream(columnLabel);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public void updateNCharacterStream(int columnIndex, Reader reader, long length) throws SQLException {
+        try {
+            _res.updateNCharacterStream(columnIndex, reader, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateNCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
+        try {
+            _res.updateNCharacterStream(columnLabel, reader, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateAsciiStream(int columnIndex, InputStream inputStream, long length) throws SQLException {
+        try {
+            _res.updateAsciiStream(columnIndex, inputStream, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateBinaryStream(int columnIndex, InputStream inputStream, long length) throws SQLException {
+        try {
+            _res.updateBinaryStream(columnIndex, inputStream, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateCharacterStream(int columnIndex, Reader reader, long length) throws SQLException {
+        try {
+            _res.updateCharacterStream(columnIndex, reader, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateAsciiStream(String columnLabel, InputStream inputStream, long length) throws SQLException {
+        try {
+            _res.updateAsciiStream(columnLabel, inputStream, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateBinaryStream(String columnLabel, InputStream inputStream, long length) throws SQLException {
+        try {
+            _res.updateBinaryStream(columnLabel, inputStream, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
+        try {
+            _res.updateCharacterStream(columnLabel, reader, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateBlob(int columnIndex, InputStream inputStream, long length) throws SQLException {
+        try {
+            _res.updateBlob(columnIndex, inputStream, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateBlob(String columnLabel, InputStream inputStream, long length) throws SQLException {
+        try {
+            _res.updateBlob(columnLabel, inputStream, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateClob(int columnIndex, Reader reader, long length) throws SQLException {
+        try {
+            _res.updateClob(columnIndex, reader, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateClob(String columnLabel, Reader reader, long length) throws SQLException {
+        try {
+            _res.updateClob(columnLabel, reader, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateNClob(int columnIndex, Reader reader, long length) throws SQLException {
+        try {
+            _res.updateNClob(columnIndex, reader, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateNClob(String columnLabel, Reader reader, long length) throws SQLException {
+        try {
+            _res.updateNClob(columnLabel, reader, length);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateNCharacterStream(int columnIndex, Reader reader) throws SQLException {
+        try {
+            _res.updateNCharacterStream(columnIndex, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateNCharacterStream(String columnLabel, Reader reader) throws SQLException {
+        try {
+            _res.updateNCharacterStream(columnLabel, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateAsciiStream(int columnIndex, InputStream inputStream) throws SQLException {
+        try {
+            _res.updateAsciiStream(columnIndex, inputStream);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateBinaryStream(int columnIndex, InputStream inputStream) throws SQLException {
+        try {
+            _res.updateBinaryStream(columnIndex, inputStream);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateCharacterStream(int columnIndex, Reader reader) throws SQLException {
+        try {
+            _res.updateCharacterStream(columnIndex, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateAsciiStream(String columnLabel, InputStream inputStream) throws SQLException {
+        try {
+            _res.updateAsciiStream(columnLabel, inputStream);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateBinaryStream(String columnLabel, InputStream inputStream) throws SQLException {
+        try {
+            _res.updateBinaryStream(columnLabel, inputStream);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateCharacterStream(String columnLabel, Reader reader) throws SQLException {
+        try {
+            _res.updateCharacterStream(columnLabel, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateBlob(int columnIndex, InputStream inputStream) throws SQLException {
+        try {
+            _res.updateBlob(columnIndex, inputStream);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateBlob(String columnLabel, InputStream inputStream) throws SQLException {
+        try {
+            _res.updateBlob(columnLabel, inputStream);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateClob(int columnIndex, Reader reader) throws SQLException {
+        try {
+            _res.updateClob(columnIndex, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateClob(String columnLabel, Reader reader) throws SQLException {
+        try {
+            _res.updateClob(columnLabel, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateNClob(int columnIndex, Reader reader) throws SQLException {
+        try {
+            _res.updateNClob(columnIndex, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public void updateNClob(String columnLabel, Reader reader) throws SQLException {
+        try {
+            _res.updateNClob(columnLabel, reader);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
+        try {
+            return _res.getObject(columnIndex, type);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public <T> T getObject(String columnLabel, Class<T> type)
+            throws SQLException {
+        try {
+            return _res.getObject(columnLabel, type);
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+}

==================================================
DriverConnectionFactory.java
new file mode 100644
index 0000000000..b95d8105e1
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingStatement.java
@@ -0,0 +1,553 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.sql.Connection;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.SQLWarning;
+import java.sql.Statement;
+import java.util.List;
+
+/**
+ * A base delegating implementation of {@link Statement}.
+ * <p>
+ * All of the methods from the {@link Statement} interface
+ * simply check to see that the {@link Statement} is active,
+ * and call the corresponding method on the "delegate"
+ * provided in my constructor.
+ * <p>
+ * Extends AbandonedTrace to implement Statement tracking and
+ * logging of code which created the Statement. Tracking the
+ * Statement ensures that the Connection which created it can
+ * close any open Statement's on Connection close.
+ *
+ * @author Rodney Waldhoff
+ * @author Glenn L. Nielsen
+ * @author James House
+ * @author Dirk Verbeeck
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class DelegatingStatement extends AbandonedTrace implements Statement {
+    /** My delegate. */
+    private Statement _stmt = null;
+    /** The connection that created me. **/
+    private DelegatingConnection<?> _conn = null;
+
+    /**
+     * Create a wrapper for the Statement which traces this
+     * Statement to the Connection which created it and the
+     * code which created it.
+     *
+     * @param s the {@link Statement} to delegate all calls to.
+     * @param c the {@link DelegatingConnection} that created this statement.
+     */
+    public DelegatingStatement(DelegatingConnection<?> c, Statement s) {
+        super(c);
+        _stmt = s;
+        _conn = c;
+    }
+
+    /**
+     * Returns my underlying {@link Statement}.
+     * @return my underlying {@link Statement}.
+     * @see #getInnermostDelegate
+     */
+    public Statement getDelegate() {
+        return _stmt;
+    }
+
+
+    /**
+     * If my underlying {@link Statement} is not a
+     * <tt>DelegatingStatement</tt>, returns it,
+     * otherwise recursively invokes this method on
+     * my delegate.
+     * <p>
+     * Hence this method will return the first
+     * delegate that is not a <tt>DelegatingStatement</tt>
+     * or <tt>null</tt> when no non-<tt>DelegatingStatement</tt>
+     * delegate can be found by transversing this chain.
+     * <p>
+     * This method is useful when you may have nested
+     * <tt>DelegatingStatement</tt>s, and you want to make
+     * sure to obtain a "genuine" {@link Statement}.
+     * @see #getDelegate
+     */
+    public Statement getInnermostDelegate() {
+        Statement s = _stmt;
+        while(s != null && s instanceof DelegatingStatement) {
+            s = ((DelegatingStatement)s).getDelegate();
+            if(this == s) {
+                return null;
+            }
+        }
+        return s;
+    }
+
+    /** Sets my delegate. */
+    public void setDelegate(Statement s) {
+        _stmt = s;
+    }
+
+    private boolean _closed = false;
+
+    protected boolean isClosedInternal() {
+        return _closed;
+    }
+
+    protected void setClosedInternal(boolean closed) {
+        this._closed = closed;
+    }
+
+    protected void checkOpen() throws SQLException {
+        if(isClosed()) {
+            throw new SQLException
+                (this.getClass().getName() + " with address: \"" +
+                this.toString() + "\" is closed.");
+        }
+    }
+
+    /**
+     * Close this DelegatingStatement, and close
+     * any ResultSets that were not explicitly closed.
+     */
+    @Override
+    public void close() throws SQLException {
+        if (isClosed()) {
+            return;
+        }
+        try {
+            try {
+                if (_conn != null) {
+                    _conn.removeTrace(this);
+                    _conn = null;
+                }
+
+                // The JDBC spec requires that a statment close any open
+                // ResultSet's when it is closed.
+                // FIXME The PreparedStatement we're wrapping should handle this for us.
+                // See bug 17301 for what could happen when ResultSets are closed twice.
+                List<AbandonedTrace> resultSets = getTrace();
+                if( resultSets != null) {
+                    ResultSet[] set = resultSets.toArray(new ResultSet[resultSets.size()]);
+                    for (ResultSet element : set) {
+                        element.close();
+                    }
+                    clearTrace();
+                }
+
+                if (_stmt != null) {
+                    _stmt.close();
+                }
+            }
+            catch (SQLException e) {
+                handleException(e);
+            }
+        }
+        finally {
+            _closed = true;
+            _stmt = null;
+        }
+    }
+
+    protected void handleException(SQLException e) throws SQLException {
+        if (_conn != null) {
+            _conn.handleException(e);
+        }
+        else {
+            throw e;
+        }
+    }
+
+    protected void activate() throws SQLException {
+        if(_stmt instanceof DelegatingStatement) {
+            ((DelegatingStatement)_stmt).activate();
+        }
+    }
+
+    protected void passivate() throws SQLException {
+        if(_stmt instanceof DelegatingStatement) {
+            ((DelegatingStatement)_stmt).passivate();
+        }
+    }
+
+    @Override
+    public Connection getConnection() throws SQLException {
+        checkOpen();
+        return getConnectionInternal(); // return the delegating connection that created this
+    }
+
+    protected DelegatingConnection<?> getConnectionInternal() {
+        return _conn;
+    }
+
+    @Override
+    public ResultSet executeQuery(String sql) throws SQLException {
+        checkOpen();
+        if (_conn != null) {
+            _conn.setLastUsed();
+        }
+        try {
+            return DelegatingResultSet.wrapResultSet(this,_stmt.executeQuery(sql));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public ResultSet getResultSet() throws SQLException {
+        checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(this,_stmt.getResultSet());
+        }
+        catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public int executeUpdate(String sql) throws SQLException {
+        checkOpen();
+        if (_conn != null) {
+            _conn.setLastUsed();
+        }
+        try {
+            return _stmt.executeUpdate(sql);
+        } catch (SQLException e) {
+            handleException(e); return 0;
+        }
+    }
+
+    @Override
+    public int getMaxFieldSize() throws SQLException
+    { checkOpen(); try { return _stmt.getMaxFieldSize(); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public void setMaxFieldSize(int max) throws SQLException
+    { checkOpen(); try { _stmt.setMaxFieldSize(max); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public int getMaxRows() throws SQLException
+    { checkOpen(); try { return _stmt.getMaxRows(); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public void setMaxRows(int max) throws SQLException
+    { checkOpen(); try { _stmt.setMaxRows(max); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setEscapeProcessing(boolean enable) throws SQLException
+    { checkOpen(); try { _stmt.setEscapeProcessing(enable); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public int getQueryTimeout() throws SQLException
+    { checkOpen(); try { return _stmt.getQueryTimeout(); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public void setQueryTimeout(int seconds) throws SQLException
+    { checkOpen(); try { _stmt.setQueryTimeout(seconds); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void cancel() throws SQLException
+    { checkOpen(); try { _stmt.cancel(); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public SQLWarning getWarnings() throws SQLException
+    { checkOpen(); try { return _stmt.getWarnings(); } catch (SQLException e) { handleException(e); throw new AssertionError(); } }
+
+    @Override
+    public void clearWarnings() throws SQLException
+    { checkOpen(); try { _stmt.clearWarnings(); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void setCursorName(String name) throws SQLException
+    { checkOpen(); try { _stmt.setCursorName(name); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public boolean execute(String sql) throws SQLException {
+        checkOpen();
+        if (_conn != null) {
+            _conn.setLastUsed();
+        }
+        try {
+            return _stmt.execute(sql);
+        } catch (SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
+    @Override
+    public int getUpdateCount() throws SQLException
+    { checkOpen(); try { return _stmt.getUpdateCount(); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public boolean getMoreResults() throws SQLException
+    { checkOpen(); try { return _stmt.getMoreResults(); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public void setFetchDirection(int direction) throws SQLException
+    { checkOpen(); try { _stmt.setFetchDirection(direction); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public int getFetchDirection() throws SQLException
+    { checkOpen(); try { return _stmt.getFetchDirection(); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public void setFetchSize(int rows) throws SQLException
+    { checkOpen(); try { _stmt.setFetchSize(rows); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public int getFetchSize() throws SQLException
+    { checkOpen(); try { return _stmt.getFetchSize(); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public int getResultSetConcurrency() throws SQLException
+    { checkOpen(); try { return _stmt.getResultSetConcurrency(); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public int getResultSetType() throws SQLException
+    { checkOpen(); try { return _stmt.getResultSetType(); } catch (SQLException e) { handleException(e); return 0; } }
+
+    @Override
+    public void addBatch(String sql) throws SQLException
+    { checkOpen(); try { _stmt.addBatch(sql); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public void clearBatch() throws SQLException
+    { checkOpen(); try { _stmt.clearBatch(); } catch (SQLException e) { handleException(e); } }
+
+    @Override
+    public int[] executeBatch() throws SQLException {
+        checkOpen();
+        if (_conn != null) {
+            _conn.setLastUsed();
+        }
+        try {
+            return _stmt.executeBatch();
+        } catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    /**
+     * Returns a String representation of this object.
+     *
+     * @return String
+     */
+    @Override
+    public String toString() {
+    return _stmt == null ? "NULL" : _stmt.toString();
+    }
+
+    @Override
+    public boolean getMoreResults(int current) throws SQLException
+    { checkOpen(); try { return _stmt.getMoreResults(current); } catch (SQLException e) { handleException(e); return false; } }
+
+    @Override
+    public ResultSet getGeneratedKeys() throws SQLException {
+        checkOpen();
+        try {
+            return DelegatingResultSet.wrapResultSet(this, _stmt.getGeneratedKeys());
+        } catch (SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
+
+    @Override
+    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
+        checkOpen();
+        if (_conn != null) {
+            _conn.setLastUsed();
+        }
+        try {
+            return _stmt.executeUpdate(sql, autoGeneratedKeys);
+        } catch (SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
+
+    @Override
+    public int executeUpdate(String sql, int columnIndexes[]) throws SQLException {
+        checkOpen();
+        if (_conn != null) {
+            _conn.setLastUsed();
+        }
+        try {
+            return _stmt.executeUpdate(sql, columnIndexes);
+        } catch (SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
+
+    @Override
+    public int executeUpdate(String sql, String columnNames[]) throws SQLException {
+        checkOpen();
+        if (_conn != null) {
+            _conn.setLastUsed();
+        }
+        try {
+            return _stmt.executeUpdate(sql, columnNames);
+        } catch (SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
+
+    @Override
+    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
+        checkOpen();
+        if (_conn != null) {
+            _conn.setLastUsed();
+        }
+        try {
+            return _stmt.execute(sql, autoGeneratedKeys);
+        } catch (SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
+    @Override
+    public boolean execute(String sql, int columnIndexes[]) throws SQLException {
+        checkOpen();
+        if (_conn != null) {
+            _conn.setLastUsed();
+        }
+        try {
+            return _stmt.execute(sql, columnIndexes);
+        } catch (SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
+    @Override
+    public boolean execute(String sql, String columnNames[]) throws SQLException {
+        checkOpen();
+        if (_conn != null) {
+            _conn.setLastUsed();
+        }
+        try {
+            return _stmt.execute(sql, columnNames);
+        } catch (SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
+    @Override
+    public int getResultSetHoldability() throws SQLException
+    { checkOpen(); try { return _stmt.getResultSetHoldability(); } catch (SQLException e) { handleException(e); return 0; } }
+
+    /*
+     * Note was protected prior to JDBC 4
+     */
+    @Override
+    public boolean isClosed() throws SQLException {
+        return _closed;
+    }
+
+
+    @Override
+    public boolean isWrapperFor(Class<?> iface) throws SQLException {
+        if (iface.isAssignableFrom(getClass())) {
+            return true;
+        } else if (iface.isAssignableFrom(_stmt.getClass())) {
+            return true;
+        } else {
+            return _stmt.isWrapperFor(iface);
+        }
+    }
+
+    @Override
+    public <T> T unwrap(Class<T> iface) throws SQLException {
+        if (iface.isAssignableFrom(getClass())) {
+            return iface.cast(this);
+        } else if (iface.isAssignableFrom(_stmt.getClass())) {
+            return iface.cast(_stmt);
+        } else {
+            return _stmt.unwrap(iface);
+        }
+    }
+
+    @Override
+    public void setPoolable(boolean poolable) throws SQLException {
+        checkOpen();
+        try {
+            _stmt.setPoolable(poolable);
+        }
+        catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public boolean isPoolable() throws SQLException {
+        checkOpen();
+        try {
+            return _stmt.isPoolable();
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
+    @Override
+    public void closeOnCompletion() throws SQLException {
+        checkOpen();
+        try {
+            _stmt.closeOnCompletion();
+        } catch (SQLException e) {
+            handleException(e);
+        }
+    }
+
+    @Override
+    public boolean isCloseOnCompletion() throws SQLException {
+        checkOpen();
+        try {
+            return _stmt.isCloseOnCompletion();
+        } catch (SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        // This is required because of statement pooling. The poolable
+        // statements will always be strongly held by the statement pool. If the
+        // delegating statements that wrap the poolable statement are not
+        // strongly held they will be garbage collected but at that point the
+        // poolable statements need to be returned to the pool else there will
+        // be a leak of statements from the pool. Closing this statement will
+        // close all the wrapped statements and return any poolable statements
+        // to the pool.
+        close();
+        super.finalize();
+    }
+}

==================================================
DriverManagerConnectionFactory.java
new file mode 100644
index 0000000000..e89941badd
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DriverConnectionFactory.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2;
+import java.sql.Connection;
+import java.sql.Driver;
+import java.sql.SQLException;
+import java.util.Properties;
+
+/**
+ * A {@link Driver}-based implementation of {@link ConnectionFactory}.
+ *
+ * @author Rodney Waldhoff
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class DriverConnectionFactory implements ConnectionFactory {
+    public DriverConnectionFactory(Driver driver, String connectUri, Properties props) {
+        _driver = driver;
+        _connectUri = connectUri;
+        _props = props;
+    }
+
+    @Override
+    public Connection createConnection() throws SQLException {
+        return _driver.connect(_connectUri,_props);
+    }
+
+    private final Driver _driver;
+    private final String _connectUri;
+    private final Properties _props;
+
+    @Override
+    public String toString() {
+        return this.getClass().getName() + " [" + String.valueOf(_driver) + ";" +
+                String.valueOf(_connectUri) + ";"  + String.valueOf(_props) + "]";
+    }
+}

==================================================
PStmtKey.java
new file mode 100644
index 0000000000..b9fb03a574
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DriverManagerConnectionFactory.java
@@ -0,0 +1,86 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2;
+import java.sql.Connection;
+import java.sql.DriverManager;
+import java.sql.SQLException;
+import java.util.Properties;
+
+/**
+ * A {@link DriverManager}-based implementation of {@link ConnectionFactory}.
+ *
+ * @author Rodney Waldhoff
+ * @author Ignacio J. Ortega
+ * @author Dirk Verbeeck
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class DriverManagerConnectionFactory implements ConnectionFactory {
+
+    static {
+        // Related to DBCP-212
+        // Driver manager does not sync loading of drivers that use the service
+        // provider interface. This will cause issues is multi-threaded
+        // environments. This hack makes sure the drivers are loaded before
+        // DBCP tries to use them.
+        DriverManager.getDrivers();
+    }
+
+
+    /**
+     * Constructor for DriverManagerConnectionFactory.
+     * @param connectUri a database url of the form
+     * <code> jdbc:<em>subprotocol</em>:<em>subname</em></code>
+     * @param props a list of arbitrary string tag/value pairs as
+     * connection arguments; normally at least a "user" and "password"
+     * property should be included.
+     */
+    public DriverManagerConnectionFactory(String connectUri, Properties props) {
+        _connectUri = connectUri;
+        _props = props;
+    }
+
+    /**
+     * Constructor for DriverManagerConnectionFactory.
+     * @param connectUri a database url of the form
+     * <code>jdbc:<em>subprotocol</em>:<em>subname</em></code>
+     * @param uname the database user
+     * @param passwd the user's password
+     */
+    public DriverManagerConnectionFactory(String connectUri, String uname, String passwd) {
+        _connectUri = connectUri;
+        _uname = uname;
+        _passwd = passwd;
+    }
+
+    @Override
+    public Connection createConnection() throws SQLException {
+        if(null == _props) {
+            if(_uname == null && _passwd == null) {
+                return DriverManager.getConnection(_connectUri);
+            }
+            return DriverManager.getConnection(_connectUri,_uname,_passwd);
+        }
+        return DriverManager.getConnection(_connectUri,_props);
+    }
+
+    private String _connectUri = null;
+    private String _uname = null;
+    private String _passwd = null;
+    private Properties _props = null;
+}

==================================================
PoolableCallableStatement.java
new file mode 100644
index 0000000000..83aae957e1
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PStmtKey.java
@@ -0,0 +1,192 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2;
+
+import org.apache.tomcat.dbcp.dbcp2.PoolingConnection.StatementType;
+
+/**
+ * A key uniquely identifying {@link java.sql.PreparedStatement PreparedStatement}s.
+ * @since 2.0
+ */
+public class PStmtKey {
+
+    /** SQL defining Prepared or Callable Statement */
+    private final String _sql;
+
+    /** Result set type */
+    private final Integer _resultSetType;
+
+    /** Result set concurrency */
+    private final Integer _resultSetConcurrency;
+
+    /** Database catalog */
+    private final String _catalog;
+
+    /** Auto generated keys */
+    private final Integer _autoGeneratedKeys;
+
+    /** Statement type */
+    private final StatementType _stmtType;
+
+
+    public PStmtKey(String sql) {
+        this(sql, null, StatementType.PREPARED_STATEMENT, null);
+    }
+
+    public PStmtKey(String sql, String catalog) {
+        this(sql, catalog, StatementType.PREPARED_STATEMENT, null);
+    }
+
+    public PStmtKey(String sql, String catalog, int autoGeneratedKeys) {
+        this(sql, catalog, StatementType.PREPARED_STATEMENT, Integer.valueOf(autoGeneratedKeys));
+    }
+
+    public PStmtKey(String sql, String catalog, StatementType stmtType, Integer autoGeneratedKeys) {
+        _sql = sql;
+        _catalog = catalog;
+        _stmtType = stmtType;
+        _autoGeneratedKeys = autoGeneratedKeys;
+        _resultSetType = null;
+        _resultSetConcurrency = null;
+    }
+
+    public  PStmtKey(String sql, int resultSetType, int resultSetConcurrency) {
+        this(sql, null, resultSetType, resultSetConcurrency, StatementType.PREPARED_STATEMENT);
+    }
+
+    public PStmtKey(String sql, String catalog, int resultSetType, int resultSetConcurrency) {
+        this(sql, catalog, resultSetType, resultSetConcurrency, StatementType.PREPARED_STATEMENT);
+    }
+
+    public PStmtKey(String sql, String catalog, int resultSetType, int resultSetConcurrency, StatementType stmtType) {
+        _sql = sql;
+        _catalog = catalog;
+        _resultSetType = Integer.valueOf(resultSetType);
+        _resultSetConcurrency = Integer.valueOf(resultSetConcurrency);
+        _stmtType = stmtType;
+        _autoGeneratedKeys = null;
+    }
+
+
+    public String getSql() {
+        return _sql;
+    }
+
+    public Integer getResultSetType() {
+        return _resultSetType;
+    }
+
+    public Integer getResultSetConcurrency() {
+        return _resultSetConcurrency;
+    }
+
+    public Integer getAutoGeneratedKeys() {
+        return _autoGeneratedKeys;
+    }
+
+    public String getCatalog() {
+        return _catalog;
+    }
+
+    public StatementType getStmtType() {
+        return _stmtType;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        PStmtKey other = (PStmtKey) obj;
+        if (_catalog == null) {
+            if (other._catalog != null) {
+                return false;
+            }
+        } else if (!_catalog.equals(other._catalog)) {
+            return false;
+        }
+        if (_resultSetConcurrency == null) {
+            if (other._resultSetConcurrency != null) {
+                return false;
+            }
+        } else if (!_resultSetConcurrency.equals(other._resultSetConcurrency)) {
+            return false;
+        }
+        if (_resultSetType == null) {
+            if (other._resultSetType != null) {
+                return false;
+            }
+        } else if (!_resultSetType.equals(other._resultSetType)) {
+            return false;
+        }
+        if (_autoGeneratedKeys == null) {
+            if (other._autoGeneratedKeys != null) {
+                return false;
+            }
+        } else if (!_autoGeneratedKeys.equals(other._autoGeneratedKeys)) {
+            return false;
+        }
+        if (_sql == null) {
+            if (other._sql != null) {
+                return false;
+            }
+        } else if (!_sql.equals(other._sql)) {
+            return false;
+        }
+        if (_stmtType != other._stmtType) {
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + (_catalog == null ? 0 : _catalog.hashCode());
+        result = prime * result + (_resultSetConcurrency == null ? 0 : _resultSetConcurrency.hashCode());
+        result = prime * result + (_resultSetType == null ? 0 : _resultSetType.hashCode());
+        result = prime * result + (_sql == null ? 0 : _sql.hashCode());
+        result = prime * result + (_autoGeneratedKeys == null ? 0 : _autoGeneratedKeys.hashCode());
+        result = prime * result + _stmtType.hashCode();
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuffer buf = new StringBuffer();
+        buf.append("PStmtKey: sql=");
+        buf.append(_sql);
+        buf.append(", catalog=");
+        buf.append(_catalog);
+        buf.append(", resultSetType=");
+        buf.append(_resultSetType);
+        buf.append(", resultSetConcurrency=");
+        buf.append(_resultSetConcurrency);
+        buf.append(", autoGeneratedKeys=");
+        buf.append(_autoGeneratedKeys);
+        buf.append(", statmentType=");
+        buf.append(_stmtType);
+        return buf.toString();
+    }
+}

==================================================
PoolableConnection.java
new file mode 100644
index 0000000000..518340dd42
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolableCallableStatement.java
@@ -0,0 +1,131 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.sql.CallableStatement;
+import java.sql.Connection;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.util.List;
+
+import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
+
+/**
+ * A {@link DelegatingCallableStatement} that cooperates with
+ * {@link PoolingConnection} to implement a pool of {@link CallableStatement}s.
+ * <p>
+ * The {@link #close} method returns this statement to its containing pool. (See {@link PoolingConnection}.)
+ *
+ * @see PoolingConnection
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class PoolableCallableStatement extends DelegatingCallableStatement {
+
+    /**
+     * The {@link KeyedObjectPool} from which this CallableStatement was obtained.
+     */
+    private final KeyedObjectPool<PStmtKey,DelegatingPreparedStatement> _pool;
+
+    /**
+     * Key for this statement in the containing {@link KeyedObjectPool}.
+     */
+    private final PStmtKey _key;
+
+    /**
+     * Constructor.
+     *
+     * @param stmt the underlying {@link CallableStatement}
+     * @param key the key for this statement in the {@link KeyedObjectPool}
+     * @param pool the {@link KeyedObjectPool} from which this CallableStatement was obtained
+     * @param conn the {@link DelegatingConnection} that created this CallableStatement
+     */
+    public PoolableCallableStatement(CallableStatement stmt, PStmtKey key,
+            KeyedObjectPool<PStmtKey,DelegatingPreparedStatement> pool,
+            DelegatingConnection<Connection> conn) {
+        super(conn, stmt);
+        _pool = pool;
+        _key = key;
+
+        // Remove from trace now because this statement will be
+        // added by the activate method.
+        if(getConnectionInternal() != null) {
+            getConnectionInternal().removeTrace(this);
+        }
+    }
+
+    /**
+     * Returns the CallableStatement to the pool.  If {{@link #isClosed()}, this is a No-op.
+     */
+    @Override
+    public void close() throws SQLException {
+        // calling close twice should have no effect
+        if (!isClosed()) {
+            try {
+                _pool.returnObject(_key,this);
+            } catch(SQLException e) {
+                throw e;
+            } catch(RuntimeException e) {
+                throw e;
+            } catch(Exception e) {
+                throw new SQLException("Cannot close CallableStatement (return to pool failed)", e);
+            }
+        }
+    }
+
+    /**
+     * Activates after retrieval from the pool. Adds a trace for this CallableStatement to the Connection
+     * that created it.
+     */
+    @Override
+    protected void activate() throws SQLException {
+        setClosedInternal(false);
+        if( getConnectionInternal() != null ) {
+            getConnectionInternal().addTrace( this );
+        }
+        super.activate();
+    }
+
+    /**
+     * Passivates to prepare for return to the pool.  Removes the trace associated with this CallableStatement
+     * from the Connection that created it.  Also closes any associated ResultSets.
+     */
+    @Override
+    protected void passivate() throws SQLException {
+        setClosedInternal(true);
+        if( getConnectionInternal() != null ) {
+            getConnectionInternal().removeTrace(this);
+        }
+
+        // The JDBC spec requires that a statment close any open
+        // ResultSet's when it is closed.
+        // FIXME The PreparedStatement we're wrapping should handle this for us.
+        // See DBCP-10 for what could happen when ResultSets are closed twice.
+        List<AbandonedTrace> resultSets = getTrace();
+        if(resultSets != null) {
+            ResultSet[] set = resultSets.toArray(new ResultSet[resultSets.size()]);
+            for (ResultSet element : set) {
+                element.close();
+            }
+            clearTrace();
+        }
+
+        super.passivate();
+    }
+
+}

==================================================
PoolableConnectionFactory.java
new file mode 100644
index 0000000000..05f352724a
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolableConnection.java
@@ -0,0 +1,246 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.lang.management.ManagementFactory;
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+
+import javax.management.InstanceAlreadyExistsException;
+import javax.management.InstanceNotFoundException;
+import javax.management.MBeanRegistrationException;
+import javax.management.MBeanServer;
+import javax.management.NotCompliantMBeanException;
+import javax.management.ObjectName;
+
+import org.apache.tomcat.dbcp.pool2.ObjectPool;
+
+/**
+ * A delegating connection that, rather than closing the underlying
+ * connection, returns itself to an {@link ObjectPool} when
+ * closed.
+ *
+ * @author Rodney Waldhoff
+ * @author Glenn L. Nielsen
+ * @author James House
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class PoolableConnection extends DelegatingConnection<Connection>
+        implements PoolableConnectionMXBean {
+
+    private static MBeanServer MBEAN_SERVER = ManagementFactory.getPlatformMBeanServer();
+
+    /** The pool to which I should return. */
+    private ObjectPool<PoolableConnection> _pool = null;
+
+    private final ObjectName _jmxName;
+
+    // Use a prepared statement for validation, retaining the last used SQL to
+    // check if the validation query has changed.
+    private PreparedStatement validationPreparedStatement = null;
+    private String lastValidationSql = null;
+
+    /**
+     *
+     * @param conn my underlying connection
+     * @param pool the pool to which I should return when closed
+     */
+    public PoolableConnection(Connection conn,
+            ObjectPool<PoolableConnection> pool, ObjectName jmxName) {
+        super(conn);
+        _pool = pool;
+        _jmxName = jmxName;
+
+        if (jmxName != null) {
+            try {
+                MBEAN_SERVER.registerMBean(this, jmxName);
+            } catch (InstanceAlreadyExistsException |
+                    MBeanRegistrationException | NotCompliantMBeanException e) {
+                // For now, simply skip registration
+            }
+        }
+    }
+
+
+    @Override
+    protected void passivate() throws SQLException {
+        super.passivate();
+        setClosedInternal(true);
+    }
+
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * This method should not be used by a client to determine whether or not a
+     * connection should be return to the connection pool (by calling
+     * {@link #close()}). Clients should always attempt to return a connection
+     * to the pool once it is no longer required.
+     */
+    @Override
+    public boolean isClosed() throws SQLException {
+        if (isClosedInternal()) {
+            return true;
+        }
+
+        if (getDelegateInternal().isClosed()) {
+            // Something has gone wrong. The underlying connection has been
+            // closed without the connection being returned to the pool. Return
+            // it now.
+            close();
+            return true;
+        }
+
+        return false;
+    }
+
+
+    /**
+     * Returns me to my pool.
+     */
+     @Override
+    public synchronized void close() throws SQLException {
+        if (isClosedInternal()) {
+            // already closed
+            return;
+        }
+
+        boolean isUnderlyingConectionClosed;
+        try {
+            isUnderlyingConectionClosed = getDelegateInternal().isClosed();
+        } catch (SQLException e) {
+            try {
+                _pool.invalidateObject(this);
+            } catch(IllegalStateException ise) {
+                // pool is closed, so close the connection
+                passivate();
+                getInnermostDelegate().close();
+            } catch (Exception ie) {
+                // DO NOTHING the original exception will be rethrown
+            }
+            throw new SQLException("Cannot close connection (isClosed check failed)", e);
+        }
+
+        /* Can't set close before this code block since the connection needs to
+         * be open when validation runs. Can't set close after this code block
+         * since by then the connection will have been returned to the pool and
+         * may have been borrowed by another thread. Therefore, the close flag
+         * is set in passivate().
+         */
+        if (isUnderlyingConectionClosed) {
+            // Abnormal close: underlying connection closed unexpectedly, so we
+            // must destroy this proxy
+            try {
+                _pool.invalidateObject(this);
+            } catch(IllegalStateException e) {
+                // pool is closed, so close the connection
+                passivate();
+                getInnermostDelegate().close();
+            } catch (Exception e) {
+                throw new SQLException("Cannot close connection (invalidating pooled object failed)", e);
+            }
+        } else {
+            // Normal close: underlying connection is still open, so we
+            // simply need to return this proxy to the pool
+            try {
+                _pool.returnObject(this);
+            } catch(IllegalStateException e) {
+                // pool is closed, so close the connection
+                passivate();
+                getInnermostDelegate().close();
+            } catch(SQLException e) {
+                throw e;
+            } catch(RuntimeException e) {
+                throw e;
+            } catch(Exception e) {
+                throw new SQLException("Cannot close connection (return to pool failed)", e);
+            }
+        }
+    }
+
+    /**
+     * Actually close my underlying {@link Connection}.
+     */
+    @Override
+    public void reallyClose() throws SQLException {
+        if (_jmxName != null) {
+            try {
+                MBEAN_SERVER.unregisterMBean(_jmxName);
+            } catch (MBeanRegistrationException | InstanceNotFoundException e) {
+                // Ignore
+            }
+        }
+
+
+        if (validationPreparedStatement != null) {
+            try {
+                validationPreparedStatement.close();
+            } catch (SQLException sqle) {
+                // Ignore
+            }
+        }
+
+        super.closeInternal();
+    }
+
+
+    /**
+     * Expose the {@link #toString()} method via a bean getter so it can be read
+     * as a property via JMX.
+     */
+    @Override
+    public String getToString() {
+        return toString();
+    }
+
+
+    public void validate(String sql, int timeout) throws SQLException {
+        if (sql == null || sql.length() == 0) {
+            if (timeout < 0) {
+                timeout = 0;
+            }
+            if (!isValid(timeout)) {
+                throw new SQLException("isValid() returned false");
+            }
+            return;
+        }
+
+        if (!sql.equals(lastValidationSql)) {
+            lastValidationSql = sql;
+            // Has to be the innermost delegate else the prepared statement will
+            // be closed when the pooled connection is passivated.
+            validationPreparedStatement =
+                    getInnermostDelegateInternal().prepareStatement(sql);
+        }
+
+        if (timeout > 0) {
+            validationPreparedStatement.setQueryTimeout(timeout);
+        }
+
+        try (ResultSet rs = validationPreparedStatement.executeQuery()) {
+            if(!rs.next()) {
+                throw new SQLException("validationQuery didn't return a row");
+            }
+        } catch (SQLException sqle) {
+            throw sqle;
+        }
+    }
+}
+

==================================================
PoolableConnectionMXBean.java
new file mode 100644
index 0000000000..ebad5d7e03
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolableConnectionFactory.java
@@ -0,0 +1,418 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.Collection;
+import java.util.concurrent.atomic.AtomicLong;
+
+import javax.management.ObjectName;
+
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
+import org.apache.tomcat.dbcp.pool2.ObjectPool;
+import org.apache.tomcat.dbcp.pool2.PooledObject;
+import org.apache.tomcat.dbcp.pool2.PooledObjectFactory;
+import org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject;
+import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool;
+import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPoolConfig;
+
+/**
+ * A {@link PooledObjectFactory} that creates
+ * {@link PoolableConnection}s.
+ *
+ * @author Rodney Waldhoff
+ * @author Glenn L. Nielsen
+ * @author James House
+ * @author Dirk Verbeeck
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class PoolableConnectionFactory
+        implements PooledObjectFactory<PoolableConnection> {
+
+    private static final Log log =
+            LogFactory.getLog(PoolableConnectionFactory.class);
+
+    /**
+     * Create a new <tt>PoolableConnectionFactory</tt>.
+     * @param connFactory the {@link ConnectionFactory} from which to obtain
+     * base {@link Connection}s
+     */
+    public PoolableConnectionFactory(ConnectionFactory connFactory,
+            ObjectName dataSourceJmxName) {
+        _connFactory = connFactory;
+        this.dataSourceJmxName = dataSourceJmxName;
+    }
+
+    /**
+     * Sets the query I use to {@link #validateObject validate} {@link Connection}s.
+     * Should return at least one row. If not specified,
+     * {@link Connection#isValid(int)} will be used to validate connections.
+     *
+     * @param validationQuery a query to use to {@link #validateObject validate} {@link Connection}s.
+     */
+    public void setValidationQuery(String validationQuery) {
+        _validationQuery = validationQuery;
+    }
+
+    /**
+     * Sets the validation query timeout, the amount of time, in seconds, that
+     * connection validation will wait for a response from the database when
+     * executing a validation query.  Use a value less than or equal to 0 for
+     * no timeout.
+     *
+     * @param timeout new validation query timeout value in seconds
+     */
+    public void setValidationQueryTimeout(int timeout) {
+        _validationQueryTimeout = timeout;
+    }
+
+    /**
+     * Sets the SQL statements I use to initialize newly created {@link Connection}s.
+     * Using <tt>null</tt> turns off connection initialization.
+     * @param connectionInitSqls SQL statement to initialize {@link Connection}s.
+     */
+    public void setConnectionInitSql(Collection<String> connectionInitSqls) {
+        _connectionInitSqls = connectionInitSqls;
+    }
+
+    /**
+     * Sets the {@link ObjectPool} in which to pool {@link Connection}s.
+     * @param pool the {@link ObjectPool} in which to pool those {@link Connection}s
+     */
+    public synchronized void setPool(ObjectPool<PoolableConnection> pool) {
+        if(null != _pool && pool != _pool) {
+            try {
+                _pool.close();
+            } catch(Exception e) {
+                // ignored !?!
+            }
+        }
+        _pool = pool;
+    }
+
+    /**
+     * Returns the {@link ObjectPool} in which {@link Connection}s are pooled.
+     * @return the connection pool
+     */
+    public synchronized ObjectPool<PoolableConnection> getPool() {
+        return _pool;
+    }
+
+    /**
+     * Sets the default "read only" setting for borrowed {@link Connection}s
+     * @param defaultReadOnly the default "read only" setting for borrowed {@link Connection}s
+     */
+    public void setDefaultReadOnly(Boolean defaultReadOnly) {
+        _defaultReadOnly = defaultReadOnly;
+    }
+
+    /**
+     * Sets the default "auto commit" setting for borrowed {@link Connection}s
+     * @param defaultAutoCommit the default "auto commit" setting for borrowed {@link Connection}s
+     */
+    public void setDefaultAutoCommit(Boolean defaultAutoCommit) {
+        _defaultAutoCommit = defaultAutoCommit;
+    }
+
+    /**
+     * Sets the default "Transaction Isolation" setting for borrowed {@link Connection}s
+     * @param defaultTransactionIsolation the default "Transaction Isolation" setting for returned {@link Connection}s
+     */
+    public void setDefaultTransactionIsolation(int defaultTransactionIsolation) {
+        _defaultTransactionIsolation = defaultTransactionIsolation;
+    }
+
+    /**
+     * Sets the default "catalog" setting for borrowed {@link Connection}s
+     * @param defaultCatalog the default "catalog" setting for borrowed {@link Connection}s
+     */
+    public void setDefaultCatalog(String defaultCatalog) {
+        _defaultCatalog = defaultCatalog;
+    }
+
+    public void setCacheState(boolean cacheState) {
+        this._cacheState = cacheState;
+    }
+
+    public void setPoolStatements(boolean poolStatements) {
+        this.poolStatements = poolStatements;
+    }
+
+    public void setMaxOpenPrepatedStatements(int maxOpenPreparedStatements) {
+        this.maxOpenPreparedStatements = maxOpenPreparedStatements;
+    }
+
+    /**
+     * Sets the maximum lifetime in milliseconds of a connection after which the
+     * connection will always fail activation, passivation and validation. A
+     * value of zero or less indicates an infinite lifetime. The default value
+     * is -1.
+     */
+    public void setMaxConnLifetimeMillis(long maxConnLifetimeMillis) {
+        this.maxConnLifetimeMillis = maxConnLifetimeMillis;
+    }
+
+
+    public boolean isEnableAutoCommitOnReturn() {
+        return enableAutoCommitOnReturn;
+    }
+
+    public void setEnableAutoCommitOnReturn(boolean enableAutoCommitOnReturn) {
+        this.enableAutoCommitOnReturn = enableAutoCommitOnReturn;
+    }
+
+
+    public boolean isRollbackOnReturn() {
+        return rollbackOnReturn;
+    }
+
+    public void setRollbackOnReturn(boolean rollbackOnReturn) {
+        this.rollbackOnReturn = rollbackOnReturn;
+    }
+
+
+    public Integer getDefaultQueryTimeout() {
+        return defaultQueryTimeout;
+    }
+
+    public void setDefaultQueryTimeout(Integer defaultQueryTimeout) {
+        this.defaultQueryTimeout = defaultQueryTimeout;
+    }
+
+
+    @Override
+    public PooledObject<PoolableConnection> makeObject() throws Exception {
+        Connection conn = _connFactory.createConnection();
+        if (conn == null) {
+            throw new IllegalStateException("Connection factory returned null from createConnection");
+        }
+        try {
+            initializeConnection(conn);
+        } catch (SQLException sqle) {
+            // Make sure the connection is closed
+            try {
+                conn.close();
+            } catch (SQLException ignore) {
+                // ignore
+            }
+            // Rethrow original exception so it is visible to caller
+            throw sqle;
+        }
+
+        long connIndex = connectionIndex.getAndIncrement();
+
+        if(poolStatements) {
+            conn = new PoolingConnection(conn);
+            GenericKeyedObjectPoolConfig config = new GenericKeyedObjectPoolConfig();
+            config.setMaxTotalPerKey(-1);
+            config.setBlockWhenExhausted(false);
+            config.setMaxWaitMillis(0);
+            config.setMaxIdlePerKey(1);
+            config.setMaxTotal(maxOpenPreparedStatements);
+            if (dataSourceJmxName != null) {
+                StringBuilder base = new StringBuilder(dataSourceJmxName.toString());
+                base.append(Constants.JMX_CONNECTION_BASE_EXT);
+                base.append(Long.toString(connIndex));
+                config.setJmxNameBase(base.toString());
+                config.setJmxNamePrefix(Constants.JMX_STATEMENT_POOL_PREFIX);
+            }
+            KeyedObjectPool<PStmtKey,DelegatingPreparedStatement> stmtPool =
+                    new GenericKeyedObjectPool<>((PoolingConnection)conn, config);
+            ((PoolingConnection)conn).setStatementPool(stmtPool);
+            ((PoolingConnection) conn).setCacheState(_cacheState);
+        }
+
+        // Register this connection with JMX
+        ObjectName connJmxName;
+        if (dataSourceJmxName == null) {
+            connJmxName = null;
+        } else {
+            connJmxName = new ObjectName(dataSourceJmxName.toString() +
+                    Constants.JMX_CONNECTION_BASE_EXT + connIndex);
+        }
+
+        PoolableConnection pc = new PoolableConnection(conn,_pool, connJmxName);
+
+        return new DefaultPooledObject<>(pc);
+    }
+
+    protected void initializeConnection(Connection conn) throws SQLException {
+        Collection<String> sqls = _connectionInitSqls;
+        if(conn.isClosed()) {
+            throw new SQLException("initializeConnection: connection closed");
+        }
+        if(null != sqls) {
+            try (Statement stmt = conn.createStatement();) {
+                for (String sql : sqls) {
+                    if (sql == null) {
+                        throw new NullPointerException(
+                                "null connectionInitSqls element");
+                    }
+                    stmt.execute(sql);
+                }
+            }
+        }
+    }
+
+    @Override
+    public void destroyObject(PooledObject<PoolableConnection> p)
+            throws Exception {
+        p.getObject().reallyClose();
+    }
+
+    @Override
+    public boolean validateObject(PooledObject<PoolableConnection> p) {
+        try {
+            validateLifetime(p);
+
+            validateConnection(p.getObject());
+            return true;
+        } catch (Exception e) {
+            if (log.isDebugEnabled()) {
+                log.debug(Utils.getMessage(
+                        "poolableConnectionFactory.validateObject.fail"), e);
+            }
+            return false;
+        }
+    }
+
+    public void validateConnection(PoolableConnection conn) throws SQLException {
+        if(conn.isClosed()) {
+            throw new SQLException("validateConnection: connection closed");
+        }
+        conn.validate(_validationQuery, _validationQueryTimeout);
+    }
+
+    @Override
+    public void passivateObject(PooledObject<PoolableConnection> p)
+            throws Exception {
+
+        validateLifetime(p);
+
+        PoolableConnection conn = p.getObject();
+        Boolean connAutoCommit = null;
+        if (rollbackOnReturn) {
+            connAutoCommit = Boolean.valueOf(conn.getAutoCommit());
+            if(!connAutoCommit.booleanValue() && !conn.isReadOnly()) {
+                conn.rollback();
+            }
+        }
+
+        conn.clearWarnings();
+
+        // DBCP-97 / DBCP-399 / DBCP-351 Idle connections in the pool should
+        // have autoCommit enabled
+        if (enableAutoCommitOnReturn) {
+            if (connAutoCommit == null) {
+                connAutoCommit = Boolean.valueOf(conn.getAutoCommit());
+            }
+            if(!connAutoCommit.booleanValue()) {
+                conn.setAutoCommit(true);
+            }
+        }
+
+        conn.passivate();
+    }
+
+    @Override
+    public void activateObject(PooledObject<PoolableConnection> p)
+            throws Exception {
+
+        validateLifetime(p);
+
+        PoolableConnection conn = p.getObject();
+        conn.activate();
+
+        if (_defaultAutoCommit != null &&
+                conn.getAutoCommit() != _defaultAutoCommit.booleanValue()) {
+            conn.setAutoCommit(_defaultAutoCommit.booleanValue());
+        }
+        if (_defaultTransactionIsolation != UNKNOWN_TRANSACTIONISOLATION &&
+                conn.getTransactionIsolation() != _defaultTransactionIsolation) {
+            conn.setTransactionIsolation(_defaultTransactionIsolation);
+        }
+        if (_defaultReadOnly != null &&
+                conn.isReadOnly() != _defaultReadOnly.booleanValue()) {
+            conn.setReadOnly(_defaultReadOnly.booleanValue());
+        }
+        if (_defaultCatalog != null &&
+                !_defaultCatalog.equals(conn.getCatalog())) {
+            conn.setCatalog(_defaultCatalog);
+        }
+        conn.setDefaultQueryTimeout(defaultQueryTimeout);
+    }
+
+    private void validateLifetime(PooledObject<PoolableConnection> p)
+            throws Exception {
+        if (maxConnLifetimeMillis > 0) {
+            long lifetime = System.currentTimeMillis() - p.getCreateTime();
+            if (lifetime > maxConnLifetimeMillis) {
+                throw new Exception(Utils.getMessage(
+                        "connectionFactory.lifetimeExceeded",
+                        Long.valueOf(lifetime),
+                        Long.valueOf(maxConnLifetimeMillis)));
+            }
+        }
+    }
+
+    protected ConnectionFactory getConnectionFactory() {
+        return _connFactory;
+    }
+
+    protected boolean getPoolStatements() {
+        return poolStatements;
+    }
+
+    protected int getMaxOpenPreparedStatements() {
+        return maxOpenPreparedStatements;
+    }
+
+    protected boolean getCacheState() {
+        return _cacheState;
+    }
+
+    private final ConnectionFactory _connFactory;
+    private final ObjectName dataSourceJmxName;
+    private volatile String _validationQuery = null;
+    private volatile int _validationQueryTimeout = -1;
+    private Collection<String> _connectionInitSqls = null;
+    private volatile ObjectPool<PoolableConnection> _pool = null;
+    private Boolean _defaultReadOnly = null;
+    private Boolean _defaultAutoCommit = null;
+    private boolean enableAutoCommitOnReturn = true;
+    private boolean rollbackOnReturn = true;
+    private int _defaultTransactionIsolation = UNKNOWN_TRANSACTIONISOLATION;
+    private String _defaultCatalog;
+    private boolean _cacheState;
+    private boolean poolStatements = false;
+    private int maxOpenPreparedStatements =
+        GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL_PER_KEY;
+    private long maxConnLifetimeMillis = -1;
+    private final AtomicLong connectionIndex = new AtomicLong(0);
+    private Integer defaultQueryTimeout = null;
+
+    /**
+     * Internal constant to indicate the level is not set.
+     */
+    static final int UNKNOWN_TRANSACTIONISOLATION = -1;
+}

==================================================
PoolablePreparedStatement.java
new file mode 100644
index 0000000000..dbf9f7ac70
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolableConnectionMXBean.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.sql.SQLException;
+
+/**
+ * Defines the attributes and methods that will be exposed via JMX for
+ * {@link PoolableConnection} instances.
+ * @since 2.0
+ */
+public interface PoolableConnectionMXBean {
+    // Read-only properties
+    boolean isClosed() throws SQLException;
+    //SQLWarning getWarnings() throws SQLException;
+    String getToString();
+
+    // Read-write properties
+    boolean getAutoCommit() throws SQLException;
+    void setAutoCommit(boolean autoCommit) throws SQLException;
+
+    boolean getCacheState();
+    void setCacheState(boolean cacheState);
+
+    String getCatalog() throws SQLException;
+    void setCatalog(String catalog) throws SQLException;
+
+    int getHoldability() throws SQLException;
+    void setHoldability(int holdability) throws SQLException;
+
+    boolean isReadOnly() throws SQLException;
+    void setReadOnly(boolean readOnly) throws SQLException;
+
+    String getSchema() throws SQLException;
+    void setSchema(String schema) throws SQLException;
+
+    int getTransactionIsolation() throws SQLException;
+    void setTransactionIsolation(int level) throws SQLException;
+
+    // Methods
+    void clearCachedState();
+    void clearWarnings() throws SQLException;
+    void close() throws SQLException;
+    void reallyClose() throws SQLException;
+}

==================================================
PoolingConnection.java
new file mode 100644
index 0000000000..6ba6297646
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolablePreparedStatement.java
@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.util.List;
+
+import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
+
+/**
+ * A {@link DelegatingPreparedStatement} that cooperates with
+ * {@link PoolingConnection} to implement a pool of {@link PreparedStatement}s.
+ * <p>
+ * My {@link #close} method returns me to my containing pool. (See {@link PoolingConnection}.)
+ *
+ * @param <K> the key type
+ *
+ * @see PoolingConnection
+ * @author Rodney Waldhoff
+ * @author Glenn L. Nielsen
+ * @author James House
+ * @author Dirk Verbeeck
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class PoolablePreparedStatement<K> extends DelegatingPreparedStatement {
+    /**
+     * The {@link KeyedObjectPool} from which I was obtained.
+     */
+    private final KeyedObjectPool<K,PoolablePreparedStatement<K>> _pool;
+
+    /**
+     * My "key" as used by {@link KeyedObjectPool}.
+     */
+    private final K _key;
+
+    private volatile boolean batchAdded = false;
+
+    /**
+     * Constructor
+     * @param stmt my underlying {@link PreparedStatement}
+     * @param key my key" as used by {@link KeyedObjectPool}
+     * @param pool the {@link KeyedObjectPool} from which I was obtained.
+     * @param conn the {@link java.sql.Connection Connection} from which I was created
+     */
+    public PoolablePreparedStatement(PreparedStatement stmt, K key,
+            KeyedObjectPool<K, PoolablePreparedStatement<K>> pool,
+            DelegatingConnection<?> conn) {
+        super(conn, stmt);
+        _pool = pool;
+        _key = key;
+
+        // Remove from trace now because this statement will be
+        // added by the activate method.
+        if(getConnectionInternal() != null) {
+            getConnectionInternal().removeTrace(this);
+        }
+    }
+
+    /**
+     * Add batch.
+     */
+    @Override
+    public void addBatch() throws SQLException {
+        super.addBatch();
+        batchAdded = true;
+    }
+
+    /**
+     * Clear Batch.
+     */
+    @Override
+    public void clearBatch() throws SQLException {
+        batchAdded = false;
+        super.clearBatch();
+    }
+
+    /**
+     * Return me to my pool.
+     */
+    @Override
+    public void close() throws SQLException {
+        // calling close twice should have no effect
+        if (!isClosed()) {
+            try {
+                _pool.returnObject(_key, this);
+            } catch(SQLException e) {
+                throw e;
+            } catch(RuntimeException e) {
+                throw e;
+            } catch(Exception e) {
+                throw new SQLException("Cannot close preparedstatement (return to pool failed)", e);
+            }
+        }
+    }
+
+    @Override
+    public void activate() throws SQLException{
+        setClosedInternal(false);
+        if(getConnectionInternal() != null) {
+            getConnectionInternal().addTrace(this);
+        }
+        super.activate();
+    }
+
+    @Override
+    public void passivate() throws SQLException {
+        // DBCP-372. clearBatch with throw an exception if called when the
+        // connection is marked as closed.
+        if (batchAdded) {
+            clearBatch();
+        }
+        setClosedInternal(true);
+        if(getConnectionInternal() != null) {
+            getConnectionInternal().removeTrace(this);
+        }
+
+        // The JDBC spec requires that a statement closes any open
+        // ResultSet's when it is closed.
+        // FIXME The PreparedStatement we're wrapping should handle this for us.
+        // See bug 17301 for what could happen when ResultSets are closed twice.
+        List<AbandonedTrace> resultSets = getTrace();
+        if( resultSets != null) {
+            ResultSet[] set = resultSets.toArray(new ResultSet[resultSets.size()]);
+            for (ResultSet element : set) {
+                element.close();
+            }
+            clearTrace();
+        }
+
+        super.passivate();
+    }
+}

==================================================
PoolingDataSource.java
new file mode 100644
index 0000000000..d20a625dfe
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java
@@ -0,0 +1,421 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.sql.CallableStatement;
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.util.NoSuchElementException;
+
+import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
+import org.apache.tomcat.dbcp.pool2.KeyedPooledObjectFactory;
+import org.apache.tomcat.dbcp.pool2.PooledObject;
+import org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject;
+
+/**
+ * A {@link DelegatingConnection} that pools {@link PreparedStatement}s.
+ * <p>
+ * The {@link #prepareStatement} and {@link #prepareCall} methods, rather than
+ * creating a new PreparedStatement each time, may actually pull the statement
+ * from a pool of unused statements.
+ * The {@link PreparedStatement#close} method of the returned statement doesn't
+ * actually close the statement, but rather returns it to the pool.
+ * (See {@link PoolablePreparedStatement}, {@link PoolableCallableStatement}.)
+ *
+ *
+ * @see PoolablePreparedStatement
+ * @author Rodney Waldhoff
+ * @author Dirk Verbeeck
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class PoolingConnection extends DelegatingConnection<Connection>
+        implements KeyedPooledObjectFactory<PStmtKey,DelegatingPreparedStatement> {
+
+    /** Pool of {@link PreparedStatement}s. and {@link CallableStatement}s */
+    private KeyedObjectPool<PStmtKey,DelegatingPreparedStatement> _pstmtPool = null;
+
+    /**
+     * Constructor.
+     * @param c the underlying {@link Connection}.
+     */
+    public PoolingConnection(Connection c) {
+        super(c);
+    }
+
+
+    public void setStatementPool(
+            KeyedObjectPool<PStmtKey,DelegatingPreparedStatement> pool) {
+        _pstmtPool = pool;
+    }
+
+
+    /**
+     * Close and free all {@link PreparedStatement}s or
+     * {@link CallableStatement}s from the pool, and close the underlying
+     * connection.
+     */
+    @Override
+    public synchronized void close() throws SQLException {
+        try {
+            if (null != _pstmtPool) {
+                KeyedObjectPool<PStmtKey,DelegatingPreparedStatement> oldpool = _pstmtPool;
+                _pstmtPool = null;
+                try {
+                    oldpool.close();
+                } catch(RuntimeException e) {
+                    throw e;
+                } catch(Exception e) {
+                    throw new SQLException("Cannot close connection", e);
+                }
+            }
+        } finally {
+            try {
+                getDelegateInternal().close();
+            } finally {
+                setClosedInternal(true);
+            }
+        }
+    }
+
+    /**
+     * Create or obtain a {@link PreparedStatement} from the pool.
+     * @param sql the sql string used to define the PreparedStatement
+     * @return a {@link PoolablePreparedStatement}
+     */
+    @Override
+    public PreparedStatement prepareStatement(String sql) throws SQLException {
+        if (null == _pstmtPool) {
+            throw new SQLException(
+                    "Statement pool is null - closed or invalid PoolingConnection.");
+        }
+        try {
+            return _pstmtPool.borrowObject(createKey(sql));
+        } catch(NoSuchElementException e) {
+            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
+        } catch(RuntimeException e) {
+            throw e;
+        } catch(Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
+        }
+    }
+
+    @Override
+    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
+        if (null == _pstmtPool) {
+            throw new SQLException(
+                    "Statement pool is null - closed or invalid PoolingConnection.");
+        }
+        try {
+            return _pstmtPool.borrowObject(createKey(sql, autoGeneratedKeys));
+        }
+        catch (NoSuchElementException e) {
+            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
+        }
+        catch (RuntimeException e) {
+            throw e;
+        }
+        catch (Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
+        }
+    }
+
+    /**
+     * Create or obtain a {@link PreparedStatement} from the pool.
+     * @param sql the sql string used to define the PreparedStatement
+     * @param resultSetType result set type
+     * @param resultSetConcurrency result set concurrency
+     * @return a {@link PoolablePreparedStatement}
+     */
+    @Override
+    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
+        if (null == _pstmtPool) {
+            throw new SQLException(
+                    "Statement pool is null - closed or invalid PoolingConnection.");
+        }
+        try {
+            return _pstmtPool.borrowObject(createKey(sql,resultSetType,resultSetConcurrency));
+        } catch(NoSuchElementException e) {
+            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
+        } catch(RuntimeException e) {
+            throw e;
+        } catch(Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
+        }
+    }
+
+    /**
+     * Create or obtain a {@link CallableStatement} from the pool.
+     * @param sql the sql string used to define the CallableStatement
+     * @return a {@link PoolableCallableStatement}
+     * @throws SQLException
+     */
+    @Override
+    public CallableStatement prepareCall(String sql) throws SQLException {
+        try {
+            return (CallableStatement) _pstmtPool.borrowObject(createKey(sql, StatementType.CALLABLE_STATEMENT));
+        } catch (NoSuchElementException e) {
+            throw new SQLException("MaxOpenCallableStatements limit reached", e);
+        } catch (RuntimeException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new SQLException("Borrow callableStatement from pool failed", e);
+        }
+    }
+
+    /**
+     * Create or obtain a {@link CallableStatement} from the pool.
+     * @param sql the sql string used to define the CallableStatement
+     * @param resultSetType result set type
+     * @param resultSetConcurrency result set concurrency
+     * @return a {@link PoolableCallableStatement}
+     * @throws SQLException
+     */
+    @Override
+    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
+        try {
+            return (CallableStatement) _pstmtPool.borrowObject(createKey(sql, resultSetType,
+                            resultSetConcurrency, StatementType.CALLABLE_STATEMENT));
+        } catch (NoSuchElementException e) {
+            throw new SQLException("MaxOpenCallableStatements limit reached", e);
+        } catch (RuntimeException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new SQLException("Borrow callableStatement from pool failed", e);
+        }
+    }
+
+
+//    TODO: possible enhancement, cache these preparedStatements as well
+
+//    public PreparedStatement prepareStatement(String sql, int resultSetType,
+//                                              int resultSetConcurrency,
+//                                              int resultSetHoldability)
+//        throws SQLException {
+//        return super.prepareStatement(
+//            sql, resultSetType, resultSetConcurrency, resultSetHoldability);
+//    }
+//
+//    public PreparedStatement prepareStatement(String sql, int columnIndexes[])
+//        throws SQLException {
+//        return super.prepareStatement(sql, columnIndexes);
+//    }
+//
+//    public PreparedStatement prepareStatement(String sql, String columnNames[])
+//        throws SQLException {
+//        return super.prepareStatement(sql, columnNames);
+//    }
+
+    protected PStmtKey createKey(String sql, int autoGeneratedKeys) {
+        String catalog = null;
+        try {
+            catalog = getCatalog();
+        } catch (SQLException e) {
+            // Ignored
+        }
+        return new PStmtKey(normalizeSQL(sql), catalog, autoGeneratedKeys);
+    }
+
+    /**
+     * Create a PStmtKey for the given arguments.
+     * @param sql the sql string used to define the statement
+     * @param resultSetType result set type
+     * @param resultSetConcurrency result set concurrency
+     */
+    protected PStmtKey createKey(String sql, int resultSetType, int resultSetConcurrency) {
+        String catalog = null;
+        try {
+            catalog = getCatalog();
+        } catch (SQLException e) {
+            // Ignored
+        }
+        return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency);
+    }
+
+    /**
+     * Create a PStmtKey for the given arguments.
+     * @param sql the sql string used to define the statement
+     * @param resultSetType result set type
+     * @param resultSetConcurrency result set concurrency
+     * @param stmtType statement type
+     */
+    protected PStmtKey createKey(String sql, int resultSetType, int resultSetConcurrency, StatementType stmtType) {
+        String catalog = null;
+        try {
+            catalog = getCatalog();
+        } catch (SQLException e) {
+            // Ignored
+        }
+        return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency, stmtType);
+    }
+
+    /**
+     * Create a PStmtKey for the given arguments.
+     * @param sql the sql string used to define the statement
+     */
+    protected PStmtKey createKey(String sql) {
+        String catalog = null;
+        try {
+            catalog = getCatalog();
+        } catch (SQLException e) {
+            // Ignored
+        }
+        return new PStmtKey(normalizeSQL(sql), catalog);
+    }
+
+    /**
+     * Create a PStmtKey for the given arguments.
+     * @param sql the SQL string used to define the statement
+     * @param stmtType statement type
+     */
+    protected PStmtKey createKey(String sql, StatementType stmtType) {
+        String catalog = null;
+        try {
+            catalog = getCatalog();
+        } catch (SQLException e) {
+            // Ignored
+        }
+        return new PStmtKey(normalizeSQL(sql), catalog, stmtType, null);
+    }
+
+    /**
+     * Normalize the given SQL statement, producing a
+     * cannonical form that is semantically equivalent to the original.
+     */
+    protected String normalizeSQL(String sql) {
+        return sql.trim();
+    }
+
+    /**
+     * {@link KeyedPooledObjectFactory} method for creating
+     * {@link PoolablePreparedStatement}s or {@link PoolableCallableStatement}s.
+     * The <code>stmtType</code> field in the key determines whether
+     * a PoolablePreparedStatement or PoolableCallableStatement is created.
+     *
+     * @param key the key for the {@link PreparedStatement} to be created
+     * @see #createKey(String, int, int, StatementType)
+     */
+    @Override
+    public PooledObject<DelegatingPreparedStatement> makeObject(PStmtKey key)
+            throws Exception {
+        if(null == key) {
+            throw new IllegalArgumentException("Prepared statement key is null or invalid.");
+        }
+        if (null == key.getResultSetType() && null == key.getResultSetConcurrency() && null == key.getAutoGeneratedKeys()) {
+            if (key.getStmtType() == StatementType.PREPARED_STATEMENT ) {
+                @SuppressWarnings({"rawtypes", "unchecked"}) // Unable to find way to avoid this
+                PoolablePreparedStatement pps = new PoolablePreparedStatement(
+                        getDelegate().prepareStatement(key.getSql()), key, _pstmtPool, this);
+                return new DefaultPooledObject<DelegatingPreparedStatement>(pps);
+            }
+            return new DefaultPooledObject<DelegatingPreparedStatement>(
+                    new PoolableCallableStatement(getDelegate().prepareCall( key.getSql()), key, _pstmtPool, this));
+        } else if (null == key.getResultSetType() && null == key.getResultSetConcurrency()){
+            @SuppressWarnings({"rawtypes", "unchecked"}) // Unable to find way to avoid this
+            PoolablePreparedStatement pps = new PoolablePreparedStatement(
+                    getDelegate().prepareStatement(key.getSql(), key.getAutoGeneratedKeys().intValue()), key, _pstmtPool, this);
+            return new DefaultPooledObject<DelegatingPreparedStatement>(pps);
+        } else { // Both _resultSetType and _resultSetConcurrency are non-null here (both or neither are set by constructors)
+            if(key.getStmtType() == StatementType.PREPARED_STATEMENT) {
+                @SuppressWarnings({"rawtypes", "unchecked"}) // Unable to find way to avoid this
+                PoolablePreparedStatement pps = new PoolablePreparedStatement(getDelegate().prepareStatement(
+                        key.getSql(), key.getResultSetType().intValue(),key.getResultSetConcurrency().intValue()), key, _pstmtPool, this);
+                return new DefaultPooledObject<DelegatingPreparedStatement>(pps);
+            }
+            return new DefaultPooledObject<DelegatingPreparedStatement>(
+                    new PoolableCallableStatement( getDelegate().prepareCall(
+                            key.getSql(),key.getResultSetType().intValue(), key.getResultSetConcurrency().intValue()), key, _pstmtPool, this));
+        }
+    }
+
+    /**
+     * {@link KeyedPooledObjectFactory} method for destroying
+     * PoolablePreparedStatements and PoolableCallableStatements.
+     * Closes the underlying statement.
+     *
+     * @param key ignored
+     * @param p the wrapped pooled statement to be destroyed.
+     */
+    @Override
+    public void destroyObject(PStmtKey key,
+            PooledObject<DelegatingPreparedStatement> p)
+            throws Exception {
+        p.getObject().getInnermostDelegate().close();
+    }
+
+    /**
+     * {@link KeyedPooledObjectFactory} method for validating
+     * pooled statements. Currently always returns true.
+     *
+     * @param key ignored
+     * @param p ignored
+     * @return <tt>true</tt>
+     */
+    @Override
+    public boolean validateObject(PStmtKey key,
+            PooledObject<DelegatingPreparedStatement> p) {
+        return true;
+    }
+
+    /**
+     * {@link KeyedPooledObjectFactory} method for activating
+     * pooled statements.
+     *
+     * @param key ignored
+     * @param p wrapped pooled statement to be activated
+     */
+    @Override
+    public void activateObject(PStmtKey key,
+            PooledObject<DelegatingPreparedStatement> p) throws Exception {
+        p.getObject().activate();
+    }
+
+    /**
+     * {@link KeyedPooledObjectFactory} method for passivating
+     * {@link PreparedStatement}s or {@link CallableStatement}s.
+     * Invokes {@link PreparedStatement#clearParameters}.
+     *
+     * @param key ignored
+     * @param p a wrapped {@link PreparedStatement}
+     */
+    @Override
+    public void passivateObject(PStmtKey key,
+            PooledObject<DelegatingPreparedStatement> p) throws Exception {
+        DelegatingPreparedStatement dps = p.getObject();
+        dps.clearParameters();
+        dps.passivate();
+    }
+
+    @Override
+    public String toString() {
+        if (_pstmtPool != null ) {
+            return "PoolingConnection: " + _pstmtPool.toString();
+        }
+        return "PoolingConnection: null";
+    }
+
+    /**
+     * The possible statement types.
+     * @since 2.0
+     */
+    protected static enum StatementType {
+        CALLABLE_STATEMENT,
+        PREPARED_STATEMENT
+    }
+}

==================================================
PoolingDriver.java
new file mode 100644
index 0000000000..1afed6791f
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolingDataSource.java
@@ -0,0 +1,242 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.io.PrintWriter;
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.sql.SQLFeatureNotSupportedException;
+import java.util.NoSuchElementException;
+import java.util.logging.Logger;
+
+import javax.sql.DataSource;
+
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import org.apache.tomcat.dbcp.pool2.ObjectPool;
+import org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool;
+
+/**
+ * A simple {@link DataSource} implementation that obtains
+ * {@link Connection}s from the specified {@link ObjectPool}.
+ *
+ * @param <C> The connection type
+ *
+ * @author Rodney Waldhoff
+ * @author Glenn L. Nielsen
+ * @author James House
+ * @author Dirk Verbeeck
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class PoolingDataSource<C extends Connection> implements DataSource {
+
+    private static final Log log = LogFactory.getLog(PoolingDataSource.class);
+
+    /** Controls access to the underlying connection */
+    private boolean accessToUnderlyingConnectionAllowed = false;
+
+    public PoolingDataSource(ObjectPool<C> pool) {
+        if (null == pool) {
+            throw new NullPointerException("Pool must not be null.");
+        }
+        _pool = pool;
+        // Verify that _pool's factory refers back to it.  If not, log a warning and try to fix.
+        if (_pool instanceof GenericObjectPool<?>) {
+            PoolableConnectionFactory pcf = (PoolableConnectionFactory) ((GenericObjectPool<?>) _pool).getFactory();
+            if (pcf == null) {
+                throw new NullPointerException("PoolableConnectionFactory must not be null.");
+            }
+            if (pcf.getPool() != _pool) {
+                log.warn(Utils.getMessage("poolingDataSource.factoryConfig"));
+                @SuppressWarnings("unchecked") // PCF must have a pool of PCs
+                ObjectPool<PoolableConnection> p = (ObjectPool<PoolableConnection>) _pool;
+                pcf.setPool(p);
+            }
+        }
+    }
+
+    /**
+     * Returns the value of the accessToUnderlyingConnectionAllowed property.
+     *
+     * @return true if access to the underlying is allowed, false otherwise.
+     */
+    public boolean isAccessToUnderlyingConnectionAllowed() {
+        return this.accessToUnderlyingConnectionAllowed;
+    }
+
+    /**
+     * Sets the value of the accessToUnderlyingConnectionAllowed property.
+     * It controls if the PoolGuard allows access to the underlying connection.
+     * (Default: false)
+     *
+     * @param allow Access to the underlying connection is granted when true.
+     */
+    public void setAccessToUnderlyingConnectionAllowed(boolean allow) {
+        this.accessToUnderlyingConnectionAllowed = allow;
+    }
+
+    /* JDBC_4_ANT_KEY_BEGIN */
+    @Override
+    public boolean isWrapperFor(Class<?> iface) throws SQLException {
+        return false;
+    }
+
+    @Override
+    public <T> T unwrap(Class<T> iface) throws SQLException {
+        throw new SQLException("PoolingDataSource is not a wrapper.");
+    }
+    /* JDBC_4_ANT_KEY_END */
+
+    @Override
+    public Logger getParentLogger() throws SQLFeatureNotSupportedException {
+        throw new SQLFeatureNotSupportedException();
+    }
+
+    //--- DataSource methods -----------------------------------------
+
+    /**
+     * Return a {@link java.sql.Connection} from my pool,
+     * according to the contract specified by {@link ObjectPool#borrowObject}.
+     */
+    @Override
+    public Connection getConnection() throws SQLException {
+        try {
+            C conn = _pool.borrowObject();
+            if (conn == null) {
+                return null;
+            }
+            return new PoolGuardConnectionWrapper<>(conn);
+        } catch(SQLException e) {
+            throw e;
+        } catch(NoSuchElementException e) {
+            throw new SQLException("Cannot get a connection, pool error " + e.getMessage(), e);
+        } catch(RuntimeException e) {
+            throw e;
+        } catch(Exception e) {
+            throw new SQLException("Cannot get a connection, general error", e);
+        }
+    }
+
+    /**
+     * Throws {@link UnsupportedOperationException}
+     * @throws UnsupportedOperationException
+     */
+    @Override
+    public Connection getConnection(String uname, String passwd) throws SQLException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Returns my log writer.
+     * @return my log writer
+     * @see DataSource#getLogWriter
+     */
+    @Override
+    public PrintWriter getLogWriter() {
+        return _logWriter;
+    }
+
+    /**
+     * Throws {@link UnsupportedOperationException}.
+     * @throws UnsupportedOperationException As this
+     *   implementation does not support this feature.
+     */
+    @Override
+    public int getLoginTimeout() {
+        throw new UnsupportedOperationException("Login timeout is not supported.");
+    }
+
+    /**
+     * Throws {@link UnsupportedOperationException}.
+     * @throws UnsupportedOperationException As this
+     *   implementation does not support this feature.
+     */
+    @Override
+    public void setLoginTimeout(int seconds) {
+        throw new UnsupportedOperationException("Login timeout is not supported.");
+    }
+
+    /**
+     * Sets my log writer.
+     * @see DataSource#setLogWriter
+     */
+    @Override
+    public void setLogWriter(PrintWriter out) {
+        _logWriter = out;
+    }
+
+    /** My log writer. */
+    private PrintWriter _logWriter = null;
+
+    private final ObjectPool<C> _pool;
+
+    protected ObjectPool<C> getPool() {
+        return _pool;
+    }
+
+    /**
+     * PoolGuardConnectionWrapper is a Connection wrapper that makes sure a
+     * closed connection cannot be used anymore.
+     * @since 2.0
+     */
+    private class PoolGuardConnectionWrapper<D extends Connection>
+            extends DelegatingConnection<D> {
+
+        PoolGuardConnectionWrapper(D delegate) {
+            super(delegate);
+        }
+
+        /**
+         * @see org.apache.tomcat.dbcp.dbcp2.DelegatingConnection#getDelegate()
+         */
+        @Override
+        public D getDelegate() {
+            if (isAccessToUnderlyingConnectionAllowed()) {
+                return super.getDelegate();
+            }
+            return null;
+        }
+
+        /**
+         * @see org.apache.tomcat.dbcp.dbcp2.DelegatingConnection#getInnermostDelegate()
+         */
+        @Override
+        public Connection getInnermostDelegate() {
+            if (isAccessToUnderlyingConnectionAllowed()) {
+                return super.getInnermostDelegate();
+            }
+            return null;
+        }
+
+        @Override
+        public void close() throws SQLException {
+            if (getDelegateInternal() != null) {
+                super.close();
+                super.setDelegate(null);
+            }
+        }
+
+        @Override
+        public boolean isClosed() throws SQLException {
+            if (getDelegateInternal() == null) {
+                return true;
+            }
+            return super.isClosed();
+        }
+    }
+}

==================================================
SwallowedExceptionLogger.java
new file mode 100644
index 0000000000..551bdaec95
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolingDriver.java
@@ -0,0 +1,241 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.sql.Connection;
+import java.sql.Driver;
+import java.sql.DriverManager;
+import java.sql.DriverPropertyInfo;
+import java.sql.SQLException;
+import java.sql.SQLFeatureNotSupportedException;
+import java.util.HashMap;
+import java.util.NoSuchElementException;
+import java.util.Properties;
+import java.util.Set;
+import java.util.logging.Logger;
+
+import org.apache.tomcat.dbcp.pool2.ObjectPool;
+
+
+/**
+ * A {@link Driver} implementation that obtains
+ * {@link Connection}s from a registered
+ * {@link ObjectPool}.
+ *
+ * @author Rodney Waldhoff
+ * @author Dirk Verbeeck
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class PoolingDriver implements Driver {
+    /** Register myself with the {@link DriverManager}. */
+    static {
+        try {
+            DriverManager.registerDriver(new PoolingDriver());
+        } catch(Exception e) {
+        }
+    }
+
+    /** The map of registered pools. */
+    protected static final HashMap<String,ObjectPool<? extends Connection>> pools =
+            new HashMap<>();
+
+    /** Controls access to the underlying connection */
+    private final boolean accessToUnderlyingConnectionAllowed;
+
+    public PoolingDriver() {
+        this(true);
+    }
+
+    /**
+     * For unit testing purposes.
+     */
+    protected PoolingDriver(boolean accessToUnderlyingConnectionAllowed) {
+        this.accessToUnderlyingConnectionAllowed = accessToUnderlyingConnectionAllowed;
+    }
+
+
+    /**
+     * Returns the value of the accessToUnderlyingConnectionAllowed property.
+     *
+     * @return true if access to the underlying is allowed, false otherwise.
+     */
+    protected boolean isAccessToUnderlyingConnectionAllowed() {
+        return accessToUnderlyingConnectionAllowed;
+    }
+
+    public synchronized ObjectPool<? extends Connection> getConnectionPool(String name)
+            throws SQLException {
+        ObjectPool<? extends Connection> pool = pools.get(name);
+        if (null == pool) {
+            throw new SQLException("Pool not registered.");
+        }
+        return pool;
+    }
+
+    public synchronized void registerPool(String name,
+            ObjectPool<? extends Connection> pool) {
+        pools.put(name,pool);
+    }
+
+    public synchronized void closePool(String name) throws SQLException {
+        ObjectPool<? extends Connection> pool = pools.get(name);
+        if (pool != null) {
+            pools.remove(name);
+            try {
+                pool.close();
+            }
+            catch (Exception e) {
+                throw new SQLException("Error closing pool " + name, e);
+            }
+        }
+    }
+
+    public synchronized String[] getPoolNames(){
+        Set<String> names = pools.keySet();
+        return names.toArray(new String[names.size()]);
+    }
+
+    @Override
+    public boolean acceptsURL(String url) throws SQLException {
+        try {
+            return url.startsWith(URL_PREFIX);
+        } catch(NullPointerException e) {
+            return false;
+        }
+    }
+
+    @Override
+    public Connection connect(String url, Properties info) throws SQLException {
+        if(acceptsURL(url)) {
+            ObjectPool<? extends Connection> pool =
+                getConnectionPool(url.substring(URL_PREFIX_LEN));
+
+            try {
+                Connection conn = pool.borrowObject();
+                if (conn == null) {
+                    return null;
+                }
+                return new PoolGuardConnectionWrapper(pool, conn);
+            } catch(SQLException e) {
+                throw e;
+            } catch(NoSuchElementException e) {
+                throw new SQLException("Cannot get a connection, pool error: " + e.getMessage(), e);
+            } catch(RuntimeException e) {
+                throw e;
+            } catch(Exception e) {
+                throw new SQLException("Cannot get a connection, general error: " + e.getMessage(), e);
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public Logger getParentLogger() throws SQLFeatureNotSupportedException {
+        throw new SQLFeatureNotSupportedException();
+    }
+
+    /**
+     * Invalidates the given connection.
+     *
+     * @param conn connection to invalidate
+     * @throws SQLException if the connection is not a
+     * <code>PoolGuardConnectionWrapper</code> or an error occurs invalidating
+     * the connection
+     */
+    public void invalidateConnection(Connection conn) throws SQLException {
+        if (conn instanceof PoolGuardConnectionWrapper) { // normal case
+            PoolGuardConnectionWrapper pgconn = (PoolGuardConnectionWrapper) conn;
+            @SuppressWarnings("unchecked")
+            ObjectPool<Connection> pool = (ObjectPool<Connection>) pgconn.pool;
+            try {
+                pool.invalidateObject(pgconn.getDelegateInternal());
+            }
+            catch (Exception e) {
+            }
+        }
+        else {
+            throw new SQLException("Invalid connection class");
+        }
+    }
+
+    @Override
+    public int getMajorVersion() {
+        return MAJOR_VERSION;
+    }
+
+    @Override
+    public int getMinorVersion() {
+        return MINOR_VERSION;
+    }
+
+    @Override
+    public boolean jdbcCompliant() {
+        return true;
+    }
+
+    @Override
+    public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) {
+        return new DriverPropertyInfo[0];
+    }
+
+    /** My URL prefix */
+    protected static final String URL_PREFIX = "jdbc:apache:commons:dbcp:";
+    protected static final int URL_PREFIX_LEN = URL_PREFIX.length();
+
+    // version numbers
+    protected static final int MAJOR_VERSION = 1;
+    protected static final int MINOR_VERSION = 0;
+
+    /**
+     * PoolGuardConnectionWrapper is a Connection wrapper that makes sure a
+     * closed connection cannot be used anymore.
+     * @since 2.0
+     */
+    private class PoolGuardConnectionWrapper extends DelegatingConnection<Connection> {
+
+        private final ObjectPool<? extends Connection> pool;
+
+        PoolGuardConnectionWrapper(ObjectPool<? extends Connection> pool,
+                Connection delegate) {
+            super(delegate);
+            this.pool = pool;
+        }
+
+        /**
+         * @see org.apache.tomcat.dbcp.dbcp2.DelegatingConnection#getDelegate()
+         */
+        @Override
+        public Connection getDelegate() {
+            if (isAccessToUnderlyingConnectionAllowed()) {
+                return super.getDelegate();
+            }
+            return null;
+        }
+
+        /**
+         * @see org.apache.tomcat.dbcp.dbcp2.DelegatingConnection#getInnermostDelegate()
+         */
+        @Override
+        public Connection getInnermostDelegate() {
+            if (isAccessToUnderlyingConnectionAllowed()) {
+                return super.getInnermostDelegate();
+            }
+            return null;
+        }
+    }
+}

==================================================
Utils.java
new file mode 100644
index 0000000000..d010ec0133
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/SwallowedExceptionLogger.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2;
+
+import org.apache.juli.logging.Log;
+import org.apache.tomcat.dbcp.pool2.SwallowedExceptionListener;
+
+/**
+ * Class for logging swallowed exceptions
+ * @since 2.0
+ */
+public class SwallowedExceptionLogger implements SwallowedExceptionListener{
+
+    private final Log log;
+
+    public SwallowedExceptionLogger(Log log) {
+        this.log = log;
+    }
+
+    @Override
+    public void onSwallowException(Exception e) {
+        log.warn(Utils.getMessage(
+                "swallowedExceptionLogger.onSwallowedException"), e);
+    }
+}

==================================================
ConnectionImpl.java
new file mode 100644
index 0000000000..23517f16bd
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/Utils.java
@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.sql.Connection;
+import java.sql.ResultSet;
+import java.sql.Statement;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+
+/**
+ * Utility methods
+ * @since 2.0
+ */
+public final class Utils {
+
+    private static final ResourceBundle messages = ResourceBundle.getBundle(
+            Utils.class.getPackage().getName() + ".LocalStrings");
+
+    public static final boolean IS_SECURITY_ENABLED =
+            System.getSecurityManager() != null;
+
+
+    private Utils() {
+        // not instantiable
+    }
+
+    /**
+     * Closes the ResultSet (which may be null).
+     *
+     * @param rset a ResultSet, may be {@code null}
+     */
+    public static void closeQuietly(ResultSet rset) {
+        if (rset != null) {
+            try {
+                rset.close();
+            } catch (Exception e) {
+                // ignored
+            }
+        }
+    }
+
+    /**
+     * Closes the Connection (which may be null).
+     *
+     * @param conn a Connection, may be {@code null}
+     */
+    public static void closeQuietly(Connection conn) {
+        if (conn != null) {
+            try {
+                conn.close();
+            } catch (Exception e) {
+                // ignored
+            }
+        }
+    }
+
+    /**
+     * Closes the Statement (which may be null).
+     *
+     * @param stmt a Statement, may be {@code null}
+     */
+    public static void closeQuietly(Statement stmt) {
+        if (stmt != null) {
+            try {
+                stmt.close();
+            } catch (Exception e) {
+                // ignored
+            }
+        }
+    }
+
+
+    /**
+     * Obtain the correct i18n message for the given key.
+     */
+    public static String getMessage(String key) {
+        return getMessage(key, (Object[]) null);
+    }
+
+
+    /**
+     * Obtain the correct i18n message for the given key with placeholders
+     * replaced by the supplied arguments.
+     */
+    public static String getMessage(String key, Object... args) {
+        String msg =  messages.getString(key);
+        if (args == null || args.length == 0) {
+            return msg;
+        }
+        MessageFormat mf = new MessageFormat(msg);
+        return mf.format(args, new StringBuffer(), null).toString();
+    }
+}

==================================================
DriverAdapterCPDS.java
new file mode 100644
index 0000000000..48d0cb2a78
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/ConnectionImpl.java
@@ -0,0 +1,232 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2.cpdsadapter;
+
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+
+import org.apache.tomcat.dbcp.dbcp2.DelegatingConnection;
+import org.apache.tomcat.dbcp.dbcp2.DelegatingPreparedStatement;
+
+/**
+ * This class is the <code>Connection</code> that will be returned
+ * from <code>PooledConnectionImpl.getConnection()</code>.
+ * Most methods are wrappers around the jdbc 1.x <code>Connection</code>.
+ * A few exceptions include preparedStatement and close.
+ * In accordance with the jdbc specification this Connection cannot
+ * be used after closed() is called.  Any further usage will result in an
+ * SQLException.
+ *
+ * ConnectionImpl extends DelegatingConnection to enable access to the
+ * underlying connection.
+ *
+ * @author John D. McNally
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+class ConnectionImpl extends DelegatingConnection<Connection> {
+
+    private final boolean accessToUnderlyingConnectionAllowed;
+
+    /** The object that instantiated this object */
+     private final PooledConnectionImpl pooledConnection;
+
+    /**
+     * Creates a <code>ConnectionImpl</code>.
+     *
+     * @param pooledConnection The PooledConnection that is calling the ctor.
+     * @param connection The JDBC 1.x Connection to wrap.
+     * @param accessToUnderlyingConnectionAllowed if true, then access is allowed to the underlying connectiion
+     */
+    ConnectionImpl(PooledConnectionImpl pooledConnection,
+            Connection connection,
+            boolean accessToUnderlyingConnectionAllowed) {
+        super(connection);
+        this.pooledConnection = pooledConnection;
+        this.accessToUnderlyingConnectionAllowed =
+            accessToUnderlyingConnectionAllowed;
+    }
+
+    /**
+     * Marks the Connection as closed, and notifies the pool that the
+     * pooled connection is available.
+     * In accordance with the jdbc specification this Connection cannot
+     * be used after closed() is called.  Any further usage will result in an
+     * SQLException.
+     *
+     * @exception SQLException The database connection couldn't be closed.
+     */
+    @Override
+    public void close() throws SQLException {
+        if (!isClosedInternal()) {
+            try {
+                passivate();
+            } finally {
+                setClosedInternal(true);
+                pooledConnection.notifyListeners();
+            }
+        }
+    }
+
+    /**
+     * If pooling of <code>PreparedStatement</code>s is turned on in the
+     * {@link DriverAdapterCPDS}, a pooled object may be returned, otherwise
+     * delegate to the wrapped jdbc 1.x {@link java.sql.Connection}.
+     *
+     * @param sql SQL statement to be prepared
+     * @return the prepared statement
+     * @exception SQLException if this connection is closed or an error occurs
+     * in the wrapped connection.
+     */
+    @Override
+    public PreparedStatement prepareStatement(String sql) throws SQLException {
+        checkOpen();
+        try {
+            return new DelegatingPreparedStatement
+                (this, pooledConnection.prepareStatement(sql));
+        }
+        catch (SQLException e) {
+            handleException(e); // Does not return
+            return null;
+        }
+    }
+
+    /**
+     * If pooling of <code>PreparedStatement</code>s is turned on in the
+     * {@link DriverAdapterCPDS}, a pooled object may be returned, otherwise
+     * delegate to the wrapped jdbc 1.x {@link java.sql.Connection}.
+     *
+     * @exception SQLException if this connection is closed or an error occurs
+     * in the wrapped connection.
+     */
+    @Override
+    public PreparedStatement prepareStatement(String sql, int resultSetType,
+                                              int resultSetConcurrency)
+            throws SQLException {
+        checkOpen();
+        try {
+            return new DelegatingPreparedStatement
+                (this, pooledConnection.prepareStatement
+                    (sql,resultSetType,resultSetConcurrency));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public PreparedStatement prepareStatement(String sql, int resultSetType,
+                                              int resultSetConcurrency,
+                                              int resultSetHoldability)
+            throws SQLException {
+        checkOpen();
+        try {
+            return new DelegatingPreparedStatement(this,
+                    pooledConnection.prepareStatement(sql, resultSetType,
+                            resultSetConcurrency, resultSetHoldability));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
+            throws SQLException {
+        checkOpen();
+        try {
+            return new DelegatingPreparedStatement(this,
+                    pooledConnection.prepareStatement(sql, autoGeneratedKeys));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public PreparedStatement prepareStatement(String sql, int columnIndexes[])
+            throws SQLException {
+        checkOpen();
+        try {
+            return new DelegatingPreparedStatement(this,
+                    pooledConnection.prepareStatement(sql, columnIndexes));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    @Override
+    public PreparedStatement prepareStatement(String sql, String columnNames[])
+            throws SQLException {
+        checkOpen();
+        try {
+            return new DelegatingPreparedStatement(this,
+                    pooledConnection.prepareStatement(sql, columnNames));
+        }
+        catch (SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
+
+    //
+    // Methods for accessing the delegate connection
+    //
+
+    /**
+     * If false, getDelegate() and getInnermostDelegate() will return null.
+     * @return true if access is allowed to the underlying connection
+     * @see ConnectionImpl
+     */
+    public boolean isAccessToUnderlyingConnectionAllowed() {
+        return accessToUnderlyingConnectionAllowed;
+    }
+
+    /**
+     * Get the delegated connection, if allowed.
+     * @return the internal connection, or null if access is not allowed.
+     * @see #isAccessToUnderlyingConnectionAllowed()
+     */
+    @Override
+    public Connection getDelegate() {
+        if (isAccessToUnderlyingConnectionAllowed()) {
+            return getDelegateInternal();
+        }
+        return null;
+    }
+
+    /**
+     * Get the innermost connection, if allowed.
+     * @return the innermost internal connection, or null if access is not allowed.
+     * @see #isAccessToUnderlyingConnectionAllowed()
+     */
+    @Override
+    public Connection getInnermostDelegate() {
+        if (isAccessToUnderlyingConnectionAllowed()) {
+            return super.getInnermostDelegateInternal();
+        }
+        return null;
+    }
+
+}

==================================================
PStmtKeyCPDS.java
new file mode 100644
index 0000000000..5397d133a2
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/DriverAdapterCPDS.java
@@ -0,0 +1,706 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2.cpdsadapter;
+
+import java.io.PrintWriter;
+import java.io.Serializable;
+import java.sql.DriverManager;
+import java.sql.SQLException;
+import java.sql.SQLFeatureNotSupportedException;
+import java.util.Hashtable;
+import java.util.Properties;
+import java.util.logging.Logger;
+
+import javax.naming.Context;
+import javax.naming.Name;
+import javax.naming.NamingException;
+import javax.naming.RefAddr;
+import javax.naming.Reference;
+import javax.naming.Referenceable;
+import javax.naming.StringRefAddr;
+import javax.naming.spi.ObjectFactory;
+import javax.sql.ConnectionPoolDataSource;
+import javax.sql.PooledConnection;
+
+import org.apache.tomcat.dbcp.dbcp2.PoolablePreparedStatement;
+import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
+import org.apache.tomcat.dbcp.pool2.impl.BaseObjectPoolConfig;
+import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool;
+import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPoolConfig;
+
+/**
+ * <p>
+ * An adapter for jdbc drivers that do not include an implementation
+ * of {@link javax.sql.ConnectionPoolDataSource}, but still include a
+ * {@link java.sql.DriverManager} implementation.
+ * <code>ConnectionPoolDataSource</code>s are not used within general
+ * applications.  They are used by <code>DataSource</code> implementations
+ * that pool <code>Connection</code>s, such as
+ * {@link org.apache.tomcat.dbcp.dbcp2.datasources.SharedPoolDataSource}.  A J2EE
+ * container will normally provide some method of initializing the
+ * <code>ConnectionPoolDataSource</code> whose attributes are presented
+ * as bean getters/setters and then deploying it via JNDI.  It is then
+ * available as a source of physical connections to the database, when
+ * the pooling <code>DataSource</code> needs to create a new
+ * physical connection.
+ * </p>
+ *
+ * <p>
+ * Although normally used within a JNDI environment, the DriverAdapterCPDS
+ * can be instantiated and initialized as any bean and then attached
+ * directly to a pooling <code>DataSource</code>.
+ * <code>Jdbc2PoolDataSource</code> can use the
+ * <code>ConnectionPoolDataSource</code> with or without the use of JNDI.
+ * </p>
+ *
+ * <p>
+ * The DriverAdapterCPDS also provides <code>PreparedStatement</code> pooling
+ * which is not generally available in jbdc2
+ * <code>ConnectionPoolDataSource</code> implementation, but is
+ * addressed within the jdbc3 specification.  The <code>PreparedStatement</code>
+ * pool in DriverAdapterCPDS has been in the dbcp package for some time, but
+ * it has not undergone extensive testing in the configuration used here.
+ * It should be considered experimental and can be toggled with the
+ * poolPreparedStatements attribute.
+ * </p>
+ *
+ * <p>
+ * The <a href="package-summary.html">package documentation</a> contains an
+ * example using catalina and JNDI.  The <a
+ * href="../datasources/package-summary.html">datasources package documentation</a>
+ * shows how to use <code>DriverAdapterCPDS</code> as a source for
+ * <code>Jdbc2PoolDataSource</code> without the use of JNDI.
+ * </p>
+ *
+ * @author John D. McNally
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class DriverAdapterCPDS
+    implements ConnectionPoolDataSource, Referenceable, Serializable,
+               ObjectFactory {
+
+    private static final long serialVersionUID = -4820523787212147844L;
+
+
+    private static final String GET_CONNECTION_CALLED
+            = "A PooledConnection was already requested from this source, "
+            + "further initialization is not allowed.";
+
+    /** Description */
+    private String description;
+    /** Password */
+    private String password;
+    /** Url name */
+    private String url;
+    /** User name */
+    private String user;
+    /** Driver class name */
+    private String driver;
+
+    /** Login TimeOut in seconds */
+    private int loginTimeout;
+    /** Log stream. NOT USED */
+    private transient PrintWriter logWriter = null;
+
+    // PreparedStatement pool properties
+    private boolean poolPreparedStatements;
+    private int maxIdle = 10;
+    private long _timeBetweenEvictionRunsMillis =
+            BaseObjectPoolConfig.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
+    private int _numTestsPerEvictionRun = -1;
+    private int _minEvictableIdleTimeMillis = -1;
+    private int _maxPreparedStatements = -1;
+
+    /** Whether or not getConnection has been called */
+    private volatile boolean getConnectionCalled = false;
+
+    /** Connection properties passed to JDBC Driver */
+    private Properties connectionProperties = null;
+
+    static {
+        // Attempt to prevent deadlocks - see DBCP - 272
+        DriverManager.getDrivers();
+    }
+
+    /**
+     * Controls access to the underlying connection
+     */
+    private boolean accessToUnderlyingConnectionAllowed = false;
+
+    /**
+     * Default no-arg constructor for Serialization
+     */
+    public DriverAdapterCPDS() {
+    }
+
+    /**
+     * Attempt to establish a database connection using the default
+     * user and password.
+     */
+    @Override
+    public PooledConnection getPooledConnection() throws SQLException {
+        return getPooledConnection(getUser(), getPassword());
+    }
+
+    /**
+     * Attempt to establish a database connection.
+     * @param username name to be used for the connection
+     * @param pass password to be used fur the connection
+     */
+    @Override
+    public PooledConnection getPooledConnection(String username, String pass)
+            throws SQLException {
+        getConnectionCalled = true;
+        PooledConnectionImpl pci = null;
+        // Workaround for buggy WebLogic 5.1 classloader - ignore the
+        // exception upon first invocation.
+        try {
+            if (connectionProperties != null) {
+                connectionProperties.put("user", username);
+                connectionProperties.put("password", pass);
+                pci = new PooledConnectionImpl(DriverManager.getConnection(
+                        getUrl(), connectionProperties));
+            } else {
+                pci = new PooledConnectionImpl(DriverManager.getConnection(
+                        getUrl(), username, pass));
+            }
+            pci.setAccessToUnderlyingConnectionAllowed(isAccessToUnderlyingConnectionAllowed());
+        }
+        catch (ClassCircularityError e)
+        {
+            if (connectionProperties != null) {
+                pci = new PooledConnectionImpl(DriverManager.getConnection(
+                        getUrl(), connectionProperties));
+            } else {
+                pci = new PooledConnectionImpl(DriverManager.getConnection(
+                        getUrl(), username, pass));
+            }
+            pci.setAccessToUnderlyingConnectionAllowed(isAccessToUnderlyingConnectionAllowed());
+        }
+        KeyedObjectPool<PStmtKeyCPDS, PoolablePreparedStatement<PStmtKeyCPDS>> stmtPool = null;
+        if (isPoolPreparedStatements()) {
+            GenericKeyedObjectPoolConfig config = new GenericKeyedObjectPoolConfig();
+            config.setMaxTotalPerKey(Integer.MAX_VALUE);
+            config.setBlockWhenExhausted(false);
+            config.setMaxWaitMillis(0);
+            config.setMaxIdlePerKey(getMaxIdle());
+            if (getMaxPreparedStatements() <= 0)
+            {
+                // since there is no limit, create a prepared statement pool with an eviction thread
+                //  evictor settings are the same as the connection pool settings.
+                config.setTimeBetweenEvictionRunsMillis(getTimeBetweenEvictionRunsMillis());
+                config.setNumTestsPerEvictionRun(getNumTestsPerEvictionRun());
+                config.setMinEvictableIdleTimeMillis(getMinEvictableIdleTimeMillis());
+            }
+            else
+            {
+                // since there is limit, create a prepared statement pool without an eviction thread
+                //  pool has LRU functionality so when the limit is reached, 15% of the pool is cleared.
+                // see org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool.clearOldest method
+                config.setMaxTotal(getMaxPreparedStatements());
+                config.setTimeBetweenEvictionRunsMillis(-1);
+                config.setNumTestsPerEvictionRun(0);
+                config.setMinEvictableIdleTimeMillis(0);
+            }
+            stmtPool = new GenericKeyedObjectPool<>(pci, config);
+            pci.setStatementPool(stmtPool);
+        }
+        return pci;
+    }
+
+    @Override
+    public Logger getParentLogger() throws SQLFeatureNotSupportedException {
+        throw new SQLFeatureNotSupportedException();
+    }
+
+    // ----------------------------------------------------------------------
+    // Referenceable implementation
+
+    /**
+     * <CODE>Referenceable</CODE> implementation.
+     */
+    @Override
+    public Reference getReference() throws NamingException {
+        // this class implements its own factory
+        String factory = getClass().getName();
+
+        Reference ref = new Reference(getClass().getName(), factory, null);
+
+        ref.add(new StringRefAddr("description", getDescription()));
+        ref.add(new StringRefAddr("driver", getDriver()));
+        ref.add(new StringRefAddr("loginTimeout",
+                                  String.valueOf(getLoginTimeout())));
+        ref.add(new StringRefAddr("password", getPassword()));
+        ref.add(new StringRefAddr("user", getUser()));
+        ref.add(new StringRefAddr("url", getUrl()));
+
+        ref.add(new StringRefAddr("poolPreparedStatements",
+                                  String.valueOf(isPoolPreparedStatements())));
+        ref.add(new StringRefAddr("maxIdle",
+                                  String.valueOf(getMaxIdle())));
+        ref.add(new StringRefAddr("timeBetweenEvictionRunsMillis",
+            String.valueOf(getTimeBetweenEvictionRunsMillis())));
+        ref.add(new StringRefAddr("numTestsPerEvictionRun",
+            String.valueOf(getNumTestsPerEvictionRun())));
+        ref.add(new StringRefAddr("minEvictableIdleTimeMillis",
+            String.valueOf(getMinEvictableIdleTimeMillis())));
+        ref.add(new StringRefAddr("maxPreparedStatements",
+            String.valueOf(getMaxPreparedStatements())));
+
+        return ref;
+    }
+
+
+    // ----------------------------------------------------------------------
+    // ObjectFactory implementation
+
+    /**
+     * implements ObjectFactory to create an instance of this class
+     */
+    @Override
+    public Object getObjectInstance(Object refObj, Name name,
+                                    Context context, Hashtable<?,?> env)
+            throws Exception {
+        // The spec says to return null if we can't create an instance
+        // of the reference
+        DriverAdapterCPDS cpds = null;
+        if (refObj instanceof Reference) {
+            Reference ref = (Reference)refObj;
+            if (ref.getClassName().equals(getClass().getName())) {
+                RefAddr ra = ref.get("description");
+                if (ra != null && ra.getContent() != null) {
+                    setDescription(ra.getContent().toString());
+                }
+
+                ra = ref.get("driver");
+                if (ra != null && ra.getContent() != null) {
+                    setDriver(ra.getContent().toString());
+                }
+                ra = ref.get("url");
+                if (ra != null && ra.getContent() != null) {
+                    setUrl(ra.getContent().toString());
+                }
+                ra = ref.get("user");
+                if (ra != null && ra.getContent() != null) {
+                    setUser(ra.getContent().toString());
+                }
+                ra = ref.get("password");
+                if (ra != null && ra.getContent() != null) {
+                    setPassword(ra.getContent().toString());
+                }
+
+                ra = ref.get("poolPreparedStatements");
+                if (ra != null && ra.getContent() != null) {
+                    setPoolPreparedStatements(Boolean.valueOf(
+                        ra.getContent().toString()).booleanValue());
+                }
+                ra = ref.get("maxIdle");
+                if (ra != null && ra.getContent() != null) {
+                    setMaxIdle(Integer.parseInt(ra.getContent().toString()));
+                }
+
+                ra = ref.get("timeBetweenEvictionRunsMillis");
+                if (ra != null && ra.getContent() != null) {
+                    setTimeBetweenEvictionRunsMillis(
+                        Integer.parseInt(ra.getContent().toString()));
+                }
+
+                ra = ref.get("numTestsPerEvictionRun");
+                if (ra != null && ra.getContent() != null) {
+                    setNumTestsPerEvictionRun(
+                        Integer.parseInt(ra.getContent().toString()));
+                }
+
+                ra = ref.get("minEvictableIdleTimeMillis");
+                if (ra != null && ra.getContent() != null) {
+                    setMinEvictableIdleTimeMillis(
+                        Integer.parseInt(ra.getContent().toString()));
+                }
+                ra = ref.get("maxPreparedStatements");
+                if (ra != null && ra.getContent() != null) {
+                    setMaxPreparedStatements(
+                        Integer.parseInt(ra.getContent().toString()));
+                }
+
+                ra = ref.get("accessToUnderlyingConnectionAllowed");
+                if (ra != null && ra.getContent() != null) {
+                    setAccessToUnderlyingConnectionAllowed(
+                            Boolean.valueOf(ra.getContent().toString()).booleanValue());
+                }
+
+                cpds = this;
+            }
+        }
+        return cpds;
+    }
+
+    /**
+     * Throws an IllegalStateException, if a PooledConnection has already
+     * been requested.
+     */
+    private void assertInitializationAllowed() throws IllegalStateException {
+        if (getConnectionCalled) {
+            throw new IllegalStateException(GET_CONNECTION_CALLED);
+        }
+    }
+
+    // ----------------------------------------------------------------------
+    // Properties
+
+    /**
+     * Get the connection properties passed to the JDBC driver.
+     *
+     * @return the JDBC connection properties used when creating connections.
+     */
+    public Properties getConnectionProperties() {
+        return connectionProperties;
+    }
+
+    /**
+     * <p>Set the connection properties passed to the JDBC driver.</p>
+     *
+     * <p>If <code>props</code> contains "user" and/or "password"
+     * properties, the corresponding instance properties are set. If these
+     * properties are not present, they are filled in using
+     * {@link #getUser()}, {@link #getPassword()} when {@link #getPooledConnection()}
+     * is called, or using the actual parameters to the method call when
+     * {@link #getPooledConnection(String, String)} is called. Calls to
+     * {@link #setUser(String)} or {@link #setPassword(String)} overwrite the values
+     * of these properties if <code>connectionProperties</code> is not null.</p>
+     *
+     * @param props Connection properties to use when creating new connections.
+     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     */
+    public void setConnectionProperties(Properties props) {
+        assertInitializationAllowed();
+        connectionProperties = props;
+        if (connectionProperties.containsKey("user")) {
+            setUser(connectionProperties.getProperty("user"));
+        }
+        if (connectionProperties.containsKey("password")) {
+            setPassword(connectionProperties.getProperty("password"));
+        }
+    }
+
+    /**
+     * Get the value of description.  This property is here for use by
+     * the code which will deploy this datasource.  It is not used
+     * internally.
+     *
+     * @return value of description, may be null.
+     * @see #setDescription(String)
+     */
+    public String getDescription() {
+        return description;
+    }
+
+    /**
+     * Set the value of description.  This property is here for use by
+     * the code which will deploy this datasource.  It is not used
+     * internally.
+     *
+     * @param v  Value to assign to description.
+     */
+    public void setDescription(String  v) {
+        this.description = v;
+    }
+
+    /**
+     * Get the value of password for the default user.
+     * @return value of password.
+     */
+    public String getPassword() {
+        return password;
+    }
+
+    /**
+     * Set the value of password for the default user.
+     * @param v  Value to assign to password.
+     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     */
+    public void setPassword(String v) {
+        assertInitializationAllowed();
+        this.password = v;
+        if (connectionProperties != null) {
+            connectionProperties.setProperty("password", v);
+        }
+    }
+
+    /**
+     * Get the value of url used to locate the database for this datasource.
+     * @return value of url.
+     */
+    public String getUrl() {
+        return url;
+    }
+
+    /**
+     * Set the value of url used to locate the database for this datasource.
+     * @param v  Value to assign to url.
+     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+    */
+    public void setUrl(String v) {
+        assertInitializationAllowed();
+        this.url = v;
+    }
+
+    /**
+     * Get the value of default user (login or username).
+     * @return value of user.
+     */
+    public String getUser() {
+        return user;
+    }
+
+    /**
+     * Set the value of default user (login or username).
+     * @param v  Value to assign to user.
+     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     */
+    public void setUser(String v) {
+        assertInitializationAllowed();
+        this.user = v;
+        if (connectionProperties != null) {
+            connectionProperties.setProperty("user", v);
+        }
+    }
+
+    /**
+     * Get the driver classname.
+     * @return value of driver.
+     */
+    public String getDriver() {
+        return driver;
+    }
+
+    /**
+     * Set the driver classname.  Setting the driver classname cause the
+     * driver to be registered with the DriverManager.
+     * @param v  Value to assign to driver.
+     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     */
+    public void setDriver(String v) throws ClassNotFoundException {
+        assertInitializationAllowed();
+        this.driver = v;
+        // make sure driver is registered
+        Class.forName(v);
+    }
+
+    /**
+     * Gets the maximum time in seconds that this data source can wait
+     * while attempting to connect to a database. NOT USED.
+     */
+    @Override
+    public int getLoginTimeout() {
+        return loginTimeout;
+    }
+
+    /**
+     * Get the log writer for this data source. NOT USED.
+     */
+    @Override
+    public PrintWriter getLogWriter() {
+        return logWriter;
+    }
+
+    /**
+     * Sets the maximum time in seconds that this data source will wait
+     * while attempting to connect to a database. NOT USED.
+     */
+    @Override
+    public void setLoginTimeout(int seconds) {
+        loginTimeout = seconds;
+    }
+
+    /**
+     * Set the log writer for this data source. NOT USED.
+     */
+    @Override
+    public void setLogWriter(PrintWriter out) {
+        logWriter = out;
+    }
+
+
+    // ------------------------------------------------------------------
+    // PreparedStatement pool properties
+
+
+    /**
+     * Flag to toggle the pooling of <code>PreparedStatement</code>s
+     * @return value of poolPreparedStatements.
+     */
+    public boolean isPoolPreparedStatements() {
+        return poolPreparedStatements;
+    }
+
+    /**
+     * Flag to toggle the pooling of <code>PreparedStatement</code>s
+     * @param v  true to pool statements.
+     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     */
+    public void setPoolPreparedStatements(boolean v) {
+        assertInitializationAllowed();
+        this.poolPreparedStatements = v;
+    }
+
+    /**
+     * The maximum number of statements that can remain idle in the
+     * pool, without extra ones being released, or negative for no limit.
+     * @return the value of maxIdle
+     */
+    public int getMaxIdle() {
+        return this.maxIdle;
+    }
+
+    /**
+     * The maximum number of statements that can remain idle in the
+     * pool, without extra ones being released, or negative for no limit.
+     *
+     * @param maxIdle The maximum number of statements that can remain idle
+     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     */
+    public void setMaxIdle(int maxIdle) {
+        assertInitializationAllowed();
+        this.maxIdle = maxIdle;
+    }
+
+    /**
+     * Returns the number of milliseconds to sleep between runs of the
+     * idle object evictor thread.
+     * When non-positive, no idle object evictor thread will be
+     * run.
+     * @return the value of the evictor thread timer
+     * @see #setTimeBetweenEvictionRunsMillis(long)
+     */
+    public long getTimeBetweenEvictionRunsMillis() {
+        return _timeBetweenEvictionRunsMillis;
+    }
+
+    /**
+     * Sets the number of milliseconds to sleep between runs of the
+     * idle object evictor thread.
+     * When non-positive, no idle object evictor thread will be
+     * run.
+     * @param timeBetweenEvictionRunsMillis
+     * @see #getTimeBetweenEvictionRunsMillis()
+     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     */
+    public void setTimeBetweenEvictionRunsMillis(
+            long timeBetweenEvictionRunsMillis) {
+        assertInitializationAllowed();
+        _timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
+    }
+
+    /**
+     * Returns the number of statements to examine during each run of the
+     * idle object evictor thread (if any).
+     *
+     * *see #setNumTestsPerEvictionRun
+     * *see #setTimeBetweenEvictionRunsMillis
+     */
+    public int getNumTestsPerEvictionRun() {
+        return _numTestsPerEvictionRun;
+    }
+
+    /**
+     * Sets the number of statements to examine during each run of the
+     * idle object evictor thread (if any).
+     * <p>
+     * When a negative value is supplied, <tt>ceil({*link #numIdle})/abs({*link #getNumTestsPerEvictionRun})</tt>
+     * tests will be run.  I.e., when the value is <i>-n</i>, roughly one <i>n</i>th of the
+     * idle objects will be tested per run.
+     *
+     * @param numTestsPerEvictionRun number of statements to examine per run
+     * @see #getNumTestsPerEvictionRun()
+     * @see #setTimeBetweenEvictionRunsMillis(long)
+     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     */
+    public void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
+        assertInitializationAllowed();
+        _numTestsPerEvictionRun = numTestsPerEvictionRun;
+    }
+
+    /**
+     * Returns the minimum amount of time a statement may sit idle in the pool
+     * before it is eligible for eviction by the idle object evictor
+     * (if any).
+     *
+     * *see #setMinEvictableIdleTimeMillis
+     * *see #setTimeBetweenEvictionRunsMillis
+     */
+    public int getMinEvictableIdleTimeMillis() {
+        return _minEvictableIdleTimeMillis;
+    }
+
+    /**
+     * Sets the minimum amount of time a statement may sit idle in the pool
+     * before it is eligible for eviction by the idle object evictor
+     * (if any).
+     * When non-positive, no objects will be evicted from the pool
+     * due to idle time alone.
+     * @param minEvictableIdleTimeMillis minimum time to set (in ms)
+     * @see #getMinEvictableIdleTimeMillis()
+     * @see #setTimeBetweenEvictionRunsMillis(long)
+     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     */
+    public void setMinEvictableIdleTimeMillis(int minEvictableIdleTimeMillis) {
+        assertInitializationAllowed();
+        _minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
+    }
+
+    /**
+     * Returns the value of the accessToUnderlyingConnectionAllowed property.
+     *
+     * @return true if access to the underlying is allowed, false otherwise.
+     */
+    public synchronized boolean isAccessToUnderlyingConnectionAllowed() {
+        return this.accessToUnderlyingConnectionAllowed;
+    }
+
+    /**
+     * Sets the value of the accessToUnderlyingConnectionAllowed property.
+     * It controls if the PoolGuard allows access to the underlying connection.
+     * (Default: false)
+     *
+     * @param allow Access to the underlying connection is granted when true.
+     */
+    public synchronized void setAccessToUnderlyingConnectionAllowed(boolean allow) {
+        this.accessToUnderlyingConnectionAllowed = allow;
+    }
+
+    /**
+     * Returns the maximun number of prepared statements.
+     *
+     * @return maxPrepartedStatements value
+     */
+    public int getMaxPreparedStatements()
+    {
+        return _maxPreparedStatements;
+    }
+
+    /**
+     * Sets the maximum number of prepared statements.
+     * @param maxPreparedStatements the new maximum number of prepared
+     * statements
+     */
+    public void setMaxPreparedStatements(int maxPreparedStatements)
+    {
+        _maxPreparedStatements = maxPreparedStatements;
+    }
+}

==================================================
PooledConnectionImpl.java
new file mode 100644
index 0000000000..03d6c63337
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/PStmtKeyCPDS.java
@@ -0,0 +1,137 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2.cpdsadapter;
+
+import java.util.Arrays;
+
+import org.apache.tomcat.dbcp.dbcp2.PStmtKey;
+
+/**
+ * A key uniquely identifying a {@link java.sql.PreparedStatement PreparedStatement}.
+ * @since 2.0
+ */
+public class PStmtKeyCPDS extends PStmtKey {
+    private final Integer _resultSetHoldability;
+    private final int _columnIndexes[];
+    private final String _columnNames[];
+
+    public PStmtKeyCPDS(String sql) {
+        super(sql);
+        _resultSetHoldability = null;
+        _columnIndexes = null;
+        _columnNames = null;
+    }
+
+    public PStmtKeyCPDS(String sql, int autoGeneratedKeys) {
+        super(sql, null, autoGeneratedKeys);
+        _resultSetHoldability = null;
+        _columnIndexes = null;
+        _columnNames = null;
+    }
+
+    public PStmtKeyCPDS(String sql, int resultSetType, int resultSetConcurrency) {
+        super(sql, resultSetType, resultSetConcurrency);
+        _resultSetHoldability = null;
+        _columnIndexes = null;
+        _columnNames = null;
+    }
+
+    public PStmtKeyCPDS(String sql, int resultSetType, int resultSetConcurrency,
+            int resultSetHoldability) {
+        super(sql, resultSetType, resultSetConcurrency);
+        _resultSetHoldability = Integer.valueOf(resultSetHoldability);
+        _columnIndexes = null;
+        _columnNames = null;
+    }
+
+    public PStmtKeyCPDS(String sql, int columnIndexes[]) {
+        super(sql);
+        _columnIndexes = Arrays.copyOf(columnIndexes, columnIndexes.length);
+        _resultSetHoldability = null;
+        _columnNames = null;
+    }
+
+    public PStmtKeyCPDS(String sql, String columnNames[]) {
+        super(sql);
+        _columnNames = Arrays.copyOf(columnNames, columnNames.length);
+        _resultSetHoldability = null;
+        _columnIndexes = null;
+    }
+
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (!super.equals(obj)) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        PStmtKeyCPDS other = (PStmtKeyCPDS) obj;
+        if (!Arrays.equals(_columnIndexes, other._columnIndexes)) {
+            return false;
+        }
+        if (!Arrays.equals(_columnNames, other._columnNames)) {
+            return false;
+        }
+        if (_resultSetHoldability == null) {
+            if (other._resultSetHoldability != null) {
+                return false;
+            }
+        } else if (!_resultSetHoldability.equals(other._resultSetHoldability)) {
+            return false;
+        }
+        return true;
+    }
+
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = super.hashCode();
+        result = prime * result + Arrays.hashCode(_columnIndexes);
+        result = prime * result + Arrays.hashCode(_columnNames);
+        result = prime * result + (_resultSetHoldability == null ? 0 : _resultSetHoldability.hashCode());
+        return result;
+    }
+
+
+    @Override
+    public String toString() {
+        StringBuffer buf = new StringBuffer();
+        buf.append("PStmtKey: sql=");
+        buf.append(getSql());
+        buf.append(", catalog=");
+        buf.append(getCatalog());
+        buf.append(", resultSetType=");
+        buf.append(getResultSetType());
+        buf.append(", resultSetConcurrency=");
+        buf.append(getResultSetConcurrency());
+        buf.append(", statmentType=");
+        buf.append(getStmtType());
+        buf.append(", resultSetHoldability=");
+        buf.append(_resultSetHoldability);
+        buf.append(", columnIndexes=");
+        buf.append(Arrays.toString(_columnIndexes));
+        buf.append(", columnNames=");
+        buf.append(Arrays.toString(_columnNames));
+        return buf.toString();
+    }
+}

==================================================
package-info.java
new file mode 100644
index 0000000000..00651c3534
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/PooledConnectionImpl.java
@@ -0,0 +1,520 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2.cpdsadapter;
+
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.util.Vector;
+
+import javax.sql.ConnectionEvent;
+import javax.sql.ConnectionEventListener;
+import javax.sql.PooledConnection;
+import javax.sql.StatementEventListener;
+
+import org.apache.tomcat.dbcp.dbcp2.DelegatingConnection;
+import org.apache.tomcat.dbcp.dbcp2.PoolablePreparedStatement;
+import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
+import org.apache.tomcat.dbcp.pool2.KeyedPooledObjectFactory;
+import org.apache.tomcat.dbcp.pool2.PooledObject;
+import org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject;
+
+/**
+ * Implementation of PooledConnection that is returned by
+ * PooledConnectionDataSource.
+ *
+ * @author John D. McNally
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+class PooledConnectionImpl implements PooledConnection,
+        KeyedPooledObjectFactory<PStmtKeyCPDS,PoolablePreparedStatement<PStmtKeyCPDS>> {
+
+    private static final String CLOSED
+            = "Attempted to use PooledConnection after closed() was called.";
+
+    /**
+     * The JDBC database connection that represents the physical db connection.
+     */
+    private Connection connection = null;
+
+    /**
+     * A DelegatingConnection used to create a PoolablePreparedStatementStub
+     */
+    private final DelegatingConnection<?> delegatingConnection;
+
+    /**
+     * The JDBC database logical connection.
+     */
+    private Connection logicalConnection = null;
+
+    /**
+     * ConnectionEventListeners
+     */
+    private final Vector<ConnectionEventListener> eventListeners;
+
+    /**
+     * StatementEventListeners
+     */
+    private final Vector<StatementEventListener> statementEventListeners =
+            new Vector<>();
+
+    /**
+     * flag set to true, once close() is called.
+     */
+    private boolean isClosed;
+
+    /** My pool of {*link PreparedStatement}s. */
+    private KeyedObjectPool<PStmtKeyCPDS, PoolablePreparedStatement<PStmtKeyCPDS>> pstmtPool = null;
+
+    /**
+     * Controls access to the underlying connection
+     */
+    private boolean accessToUnderlyingConnectionAllowed = false;
+
+    /**
+     * Wrap the real connection.
+     * @param connection the connection to be wrapped
+     */
+    PooledConnectionImpl(Connection connection) {
+        this.connection = connection;
+        if (connection instanceof DelegatingConnection) {
+            this.delegatingConnection = (DelegatingConnection<?>) connection;
+        } else {
+            this.delegatingConnection = new DelegatingConnection<>(connection);
+        }
+        eventListeners = new Vector<>();
+        isClosed = false;
+    }
+
+    public void setStatementPool(
+            KeyedObjectPool<PStmtKeyCPDS, PoolablePreparedStatement<PStmtKeyCPDS>> statementPool) {
+        pstmtPool = statementPool;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void addConnectionEventListener(ConnectionEventListener listener) {
+        if (!eventListeners.contains(listener)) {
+            eventListeners.add(listener);
+        }
+    }
+
+    /* JDBC_4_ANT_KEY_BEGIN */
+    @Override
+    public void addStatementEventListener(StatementEventListener listener) {
+        if (!statementEventListeners.contains(listener)) {
+            statementEventListeners.add(listener);
+        }
+    }
+    /* JDBC_4_ANT_KEY_END */
+
+    /**
+     * Closes the physical connection and marks this
+     * <code>PooledConnection</code> so that it may not be used
+     * to generate any more logical <code>Connection</code>s.
+     *
+     * @exception SQLException if an error occurs or the connection is already closed
+     */
+    @Override
+    public void close() throws SQLException {
+        assertOpen();
+        isClosed = true;
+        try {
+            if (pstmtPool != null) {
+                try {
+                    pstmtPool.close();
+                } finally {
+                    pstmtPool = null;
+                }
+            }
+        } catch (RuntimeException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new SQLException("Cannot close connection (return to pool failed)", e);
+        } finally {
+            try {
+                connection.close();
+            } finally {
+                connection = null;
+            }
+        }
+    }
+
+    /**
+     * Throws an SQLException, if isClosed is true
+     */
+    private void assertOpen() throws SQLException {
+        if (isClosed) {
+            throw new SQLException(CLOSED);
+        }
+    }
+
+    /**
+     * Returns a JDBC connection.
+     *
+     * @return The database connection.
+     * @throws SQLException if the connection is not open or the previous logical connection is still open
+     */
+    @Override
+    public Connection getConnection() throws SQLException {
+        assertOpen();
+        // make sure the last connection is marked as closed
+        if (logicalConnection != null && !logicalConnection.isClosed()) {
+            // should notify pool of error so the pooled connection can
+            // be removed !FIXME!
+            throw new SQLException("PooledConnection was reused, without"
+                    + "its previous Connection being closed.");
+        }
+
+        // the spec requires that this return a new Connection instance.
+        logicalConnection = new ConnectionImpl(
+                this, connection, isAccessToUnderlyingConnectionAllowed());
+        return logicalConnection;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void removeConnectionEventListener(
+            ConnectionEventListener listener) {
+        eventListeners.remove(listener);
+    }
+
+    /* JDBC_4_ANT_KEY_BEGIN */
+    @Override
+    public void removeStatementEventListener(StatementEventListener listener) {
+        statementEventListeners.remove(listener);
+    }
+    /* JDBC_4_ANT_KEY_END */
+
+    /**
+     * Closes the physical connection and checks that the logical connection
+     * was closed as well.
+     */
+    @Override
+    protected void finalize() throws Throwable {
+        // Closing the Connection ensures that if anyone tries to use it,
+        // an error will occur.
+        try {
+            connection.close();
+        } catch (Exception ignored) {
+        }
+
+        // make sure the last connection is marked as closed
+        if (logicalConnection != null && !logicalConnection.isClosed()) {
+            throw new SQLException("PooledConnection was gc'ed, without"
+                    + "its last Connection being closed.");
+        }
+    }
+
+    /**
+     * sends a connectionClosed event.
+     */
+    void notifyListeners() {
+        ConnectionEvent event = new ConnectionEvent(this);
+        Object[] listeners = eventListeners.toArray();
+        for (Object listener : listeners) {
+            ((ConnectionEventListener) listener).connectionClosed(event);
+        }
+    }
+
+    // -------------------------------------------------------------------
+    // The following code implements a PreparedStatement pool
+
+    /**
+     * Create or obtain a {@link PreparedStatement} from my pool.
+     * @param sql the SQL statement
+     * @return a {@link PoolablePreparedStatement}
+     */
+    PreparedStatement prepareStatement(String sql) throws SQLException {
+        if (pstmtPool == null) {
+            return connection.prepareStatement(sql);
+        }
+        try {
+            return pstmtPool.borrowObject(createKey(sql));
+        } catch (RuntimeException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
+        }
+    }
+
+    /**
+     * Create or obtain a {@link PreparedStatement} from my pool.
+     * @param sql a <code>String</code> object that is the SQL statement to
+     *            be sent to the database; may contain one or more '?' IN
+     *            parameters
+     * @param resultSetType a result set type; one of
+     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or
+     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
+     * @param resultSetConcurrency a concurrency type; one of
+     *         <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *         <code>ResultSet.CONCUR_UPDATABLE</code>
+     *
+     * @return a {@link PoolablePreparedStatement}
+     * @see Connection#prepareStatement(String, int, int)
+     */
+    PreparedStatement prepareStatement(String sql, int resultSetType,
+                                       int resultSetConcurrency)
+            throws SQLException {
+        if (pstmtPool == null) {
+            return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
+        }
+        try {
+            return pstmtPool.borrowObject(
+                    createKey(sql,resultSetType,resultSetConcurrency));
+        } catch (RuntimeException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
+        }
+    }
+
+    /**
+     * Create or obtain a {@link PreparedStatement} from my pool.
+     * @param sql an SQL statement that may contain one or more '?' IN
+     *        parameter placeholders
+     * @param autoGeneratedKeys a flag indicating whether auto-generated keys
+     *        should be returned; one of
+     *        <code>Statement.RETURN_GENERATED_KEYS</code> or
+     *        <code>Statement.NO_GENERATED_KEYS</code>
+     * @return a {@link PoolablePreparedStatement}
+     * @see Connection#prepareStatement(String, int)
+     */
+    PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
+            throws SQLException {
+        if (pstmtPool == null) {
+            return connection.prepareStatement(sql, autoGeneratedKeys);
+        }
+        try {
+            return pstmtPool.borrowObject(createKey(sql,autoGeneratedKeys));
+        } catch (RuntimeException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
+        }
+    }
+
+    PreparedStatement prepareStatement(String sql, int resultSetType,
+            int resultSetConcurrency, int resultSetHoldability)
+    throws SQLException {
+        if (pstmtPool == null) {
+            return connection.prepareStatement(sql, resultSetType,
+                    resultSetConcurrency, resultSetHoldability);
+        }
+        try {
+            return pstmtPool.borrowObject(createKey(sql, resultSetType,
+                    resultSetConcurrency, resultSetHoldability));
+        } catch (RuntimeException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
+        }
+    }
+
+    PreparedStatement prepareStatement(String sql, int columnIndexes[])
+    throws SQLException {
+        if (pstmtPool == null) {
+            return connection.prepareStatement(sql, columnIndexes);
+        }
+        try {
+            return pstmtPool.borrowObject(createKey(sql, columnIndexes));
+        } catch (RuntimeException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
+        }
+    }
+
+    PreparedStatement prepareStatement(String sql, String columnNames[])
+    throws SQLException {
+        if (pstmtPool == null) {
+            return connection.prepareStatement(sql, columnNames);
+        }
+        try {
+            return pstmtPool.borrowObject(createKey(sql, columnNames));
+        } catch (RuntimeException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
+        }
+    }
+
+    /**
+     * Create a {*link PooledConnectionImpl.PStmtKey} for the given arguments.
+     */
+    protected PStmtKeyCPDS createKey(String sql, int autoGeneratedKeys) {
+        return new PStmtKeyCPDS(normalizeSQL(sql), autoGeneratedKeys);
+    }
+
+    /**
+     * Create a {*link PooledConnectionImpl.PStmtKey} for the given arguments.
+     */
+    protected PStmtKeyCPDS createKey(String sql, int resultSetType,
+            int resultSetConcurrency, int resultSetHoldability) {
+        return new PStmtKeyCPDS(normalizeSQL(sql), resultSetType,
+                resultSetConcurrency, resultSetHoldability);
+    }
+
+    /**
+     * Create a {*link PooledConnectionImpl.PStmtKey} for the given arguments.
+     */
+    protected PStmtKeyCPDS createKey(String sql, int columnIndexes[]) {
+        return new PStmtKeyCPDS(normalizeSQL(sql), columnIndexes);
+    }
+
+    /**
+     * Create a {*link PooledConnectionImpl.PStmtKey} for the given arguments.
+     */
+    protected PStmtKeyCPDS createKey(String sql, String columnNames[]) {
+        return new PStmtKeyCPDS(normalizeSQL(sql), columnNames);
+    }
+
+    /**
+     * Create a {*link PooledConnectionImpl.PStmtKey} for the given arguments.
+     */
+    protected PStmtKeyCPDS createKey(String sql, int resultSetType,
+                               int resultSetConcurrency) {
+        return new PStmtKeyCPDS(normalizeSQL(sql), resultSetType,
+                            resultSetConcurrency);
+    }
+
+    /**
+     * Create a {*link PooledConnectionImpl.PStmtKey} for the given arguments.
+     */
+    protected PStmtKeyCPDS createKey(String sql) {
+        return new PStmtKeyCPDS(normalizeSQL(sql));
+    }
+
+    /**
+     * Normalize the given SQL statement, producing a
+     * cannonical form that is semantically equivalent to the original.
+     */
+    protected String normalizeSQL(String sql) {
+        return sql.trim();
+    }
+
+    /**
+     * My {*link KeyedPoolableObjectFactory} method for creating
+     * {*link PreparedStatement}s.
+     * @param key the key for the {*link PreparedStatement} to be created
+     */
+    @Override
+    public PooledObject<PoolablePreparedStatement<PStmtKeyCPDS>> makeObject(PStmtKeyCPDS key) throws Exception {
+        if (null == key) {
+            throw new IllegalArgumentException();
+        }
+        // _openPstmts++;
+        if (null == key.getResultSetType()
+                && null == key.getResultSetConcurrency()) {
+            if (null == key.getAutoGeneratedKeys()) {
+                return new DefaultPooledObject<>(new PoolablePreparedStatement<>(
+                        connection.prepareStatement(key.getSql()),
+                        key, pstmtPool, delegatingConnection));
+            }
+            return new DefaultPooledObject<>(new PoolablePreparedStatement<>(
+                            connection.prepareStatement(key.getSql(),
+                                    key.getAutoGeneratedKeys().intValue()),
+                            key, pstmtPool, delegatingConnection));
+        }
+        return new DefaultPooledObject<>(new PoolablePreparedStatement<>(
+                connection.prepareStatement(key.getSql(),
+                        key.getResultSetType().intValue(),
+                        key.getResultSetConcurrency().intValue()),
+                        key, pstmtPool, delegatingConnection));
+    }
+
+    /**
+     * My {*link KeyedPoolableObjectFactory} method for destroying
+     * {*link PreparedStatement}s.
+     * @param key ignored
+     * @param p the wrapped {*link PreparedStatement} to be destroyed.
+     */
+    @Override
+    public void destroyObject(PStmtKeyCPDS key,
+            PooledObject<PoolablePreparedStatement<PStmtKeyCPDS>> p)
+            throws Exception {
+        p.getObject().getInnermostDelegate().close();
+    }
+
+    /**
+     * My {*link KeyedPoolableObjectFactory} method for validating
+     * {*link PreparedStatement}s.
+     * @param key ignored
+     * @param p ignored
+     * @return <tt>true</tt>
+     */
+    @Override
+    public boolean validateObject(PStmtKeyCPDS key,
+            PooledObject<PoolablePreparedStatement<PStmtKeyCPDS>> p) {
+        return true;
+    }
+
+    /**
+     * My {*link KeyedPoolableObjectFactory} method for activating
+     * {*link PreparedStatement}s.
+     * @param key ignored
+     * @param p ignored
+     */
+    @Override
+    public void activateObject(PStmtKeyCPDS key,
+            PooledObject<PoolablePreparedStatement<PStmtKeyCPDS>> p)
+            throws Exception {
+        p.getObject().activate();
+    }
+
+    /**
+     * My {*link KeyedPoolableObjectFactory} method for passivating
+     * {*link PreparedStatement}s.  Currently invokes {*link PreparedStatement#clearParameters}.
+     * @param key ignored
+     * @param p a wrapped {*link PreparedStatement}
+     */
+    @Override
+    public void passivateObject(PStmtKeyCPDS key,
+            PooledObject<PoolablePreparedStatement<PStmtKeyCPDS>> p)
+            throws Exception {
+        PoolablePreparedStatement<PStmtKeyCPDS> ppss = p.getObject();
+        ppss.clearParameters();
+        ppss.passivate();
+    }
+
+    /**
+     * Returns the value of the accessToUnderlyingConnectionAllowed property.
+     *
+     * @return true if access to the underlying is allowed, false otherwise.
+     */
+    public synchronized boolean isAccessToUnderlyingConnectionAllowed() {
+        return this.accessToUnderlyingConnectionAllowed;
+    }
+
+    /**
+     * Sets the value of the accessToUnderlyingConnectionAllowed property.
+     * It controls if the PoolGuard allows access to the underlying connection.
+     * (Default: false)
+     *
+     * @param allow Access to the underlying connection is granted when true.
+     */
+    public synchronized void setAccessToUnderlyingConnectionAllowed(boolean allow) {
+        this.accessToUnderlyingConnectionAllowed = allow;
+    }
+}

==================================================
CPDSConnectionFactory.java
new file mode 100644
index 0000000000..0866fff376
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/package-info.java
@@ -0,0 +1,79 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * <p>
+ * This package contains one public class which is a
+ * <code>ConnectionPoolDataSource</code> (CPDS) implementation that can be used to
+ * adapt older <code>Driver</code> based jdbc implementations. Below is an
+ * example of setting up the CPDS to be available via JNDI in the
+ * catalina servlet container.
+ * </p>
+ * <p>In server.xml, the following would be added to the &lt;Context&gt; for your
+ * webapp:
+ * </p>
+ *
+ * <pre>
+ *  &lt;Resource name="jdbc/bookstoreCPDS" auth="Container"
+ *             type="org.apache.tomcat.dbcp.dbcp2.cpdsadapter.DriverAdapterCPDS"/&gt;
+ *   &lt;ResourceParams name="jdbc/bookstoreCPDS"&gt;
+ *     &lt;parameter&gt;
+ *       &lt;name&gt;factory&lt;/name&gt;
+ *       &lt;value&gt;org.apache.tomcat.dbcp.dbcp2.cpdsadapter.DriverAdapterCPDS&lt;/value&gt;
+ *     &lt;/parameter&gt;
+ *         &lt;parameter&gt;&lt;name&gt;user&lt;/name&gt;&lt;value&gt;root&lt;/value&gt;&lt;/parameter&gt;
+ *         &lt;parameter&gt;&lt;name&gt;password&lt;/name&gt;&lt;value&gt;&lt;/value&gt;&lt;/parameter&gt;
+ *         &lt;parameter&gt;
+ *             &lt;name&gt;driver&lt;/name&gt;
+ *             &lt;value&gt;org.gjt.mm.mysql.Driver&lt;/value&gt;&lt;/parameter&gt;
+ *         &lt;parameter&gt;
+ *              &lt;name&gt;url&lt;/name&gt;
+ *              &lt;value&gt;jdbc:mysql://localhost:3306/bookstore&lt;/value&gt;
+ *         &lt;/parameter&gt;
+ *   &lt;/ResourceParams&gt;
+ * </pre>
+ *
+ * <p>
+ * In web.xml.  Note that elements must be given in the order of the dtd
+ * described in the servlet specification:
+ * </p>
+ *
+ * <pre>
+ * &lt;resource-ref&gt;
+ *   &lt;description&gt;
+ *     Resource reference to a factory for java.sql.Connection
+ *     instances that may be used for talking to a particular
+ *     database that is configured in the server.xml file.
+ *   &lt;/description&gt;
+ *   &lt;res-ref-name&gt;
+ *     jdbc/bookstoreCPDS
+ *   &lt;/res-ref-name&gt;
+ *   &lt;res-type&gt;
+ *     org.apache.tomcat.dbcp.dbcp2.cpdsadapter.DriverAdapterCPDS
+ *   &lt;/res-type&gt;
+ *   &lt;res-auth&gt;
+ *     Container
+ *   &lt;/res-auth&gt;
+ * &lt;/resource-ref&gt;
+ * </pre>
+ *
+ * <p>
+ * Catalina deploys all objects configured similarly to above within the
+ * <strong>java:comp/env</strong> namespace.
+ * </p>
+ */
+package org.apache.tomcat.dbcp.dbcp2.cpdsadapter;

==================================================
InstanceKeyDataSource.java
new file mode 100644
index 0000000000..b233a21547
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/CPDSConnectionFactory.java
@@ -0,0 +1,368 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2.datasources;
+
+import java.sql.Connection;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.Collections;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import javax.sql.ConnectionEvent;
+import javax.sql.ConnectionEventListener;
+import javax.sql.ConnectionPoolDataSource;
+import javax.sql.PooledConnection;
+
+import org.apache.tomcat.dbcp.dbcp2.Utils;
+import org.apache.tomcat.dbcp.pool2.ObjectPool;
+import org.apache.tomcat.dbcp.pool2.PooledObject;
+import org.apache.tomcat.dbcp.pool2.PooledObjectFactory;
+import org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject;
+
+/**
+ * A {@link PooledObjectFactory} that creates
+ * {@link org.apache.tomcat.dbcp.dbcp2.PoolableConnection PoolableConnection}s.
+ *
+ * @author John D. McNally
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+class CPDSConnectionFactory
+        implements PooledObjectFactory<PooledConnectionAndInfo>,
+        ConnectionEventListener, PooledConnectionManager {
+
+    private static final String NO_KEY_MESSAGE
+            = "close() was called on a Connection, but "
+            + "I have no record of the underlying PooledConnection.";
+
+    private final ConnectionPoolDataSource _cpds;
+    private final String _validationQuery;
+    private final int _validationQueryTimeout;
+    private final boolean _rollbackAfterValidation;
+    private ObjectPool<PooledConnectionAndInfo> _pool;
+    private final String _username;
+    private String _password = null;
+    private long maxConnLifetimeMillis = -1;
+
+
+    /**
+     * Map of PooledConnections for which close events are ignored.
+     * Connections are muted when they are being validated.
+     */
+    private final Set<PooledConnection> validatingSet =
+            Collections.newSetFromMap(new ConcurrentHashMap<PooledConnection,Boolean>());
+
+    /**
+     * Map of PooledConnectionAndInfo instances
+     */
+    private final Map<PooledConnection, PooledConnectionAndInfo> pcMap =
+        new ConcurrentHashMap<>();
+
+    /**
+     * Create a new <tt>PoolableConnectionFactory</tt>.
+     *
+     * @param cpds the ConnectionPoolDataSource from which to obtain
+     * PooledConnection's
+     * @param validationQuery a query to use to {@link #validateObject
+     * validate} {@link Connection}s. Should return at least one row.
+     * May be <tt>null</tt> in which case {@link Connection#isValid(int)} will
+     * be used to validate connections.
+     * @param validationQueryTimeout Timeout in seconds before validation fails
+     * @param rollbackAfterValidation whether a rollback should be issued
+     * after {@link #validateObject validating} {@link Connection}s.
+     * @param username
+     * @param password
+     */
+    public CPDSConnectionFactory(ConnectionPoolDataSource cpds,
+                                 String validationQuery,
+                                 int validationQueryTimeout,
+                                 boolean rollbackAfterValidation,
+                                 String username,
+                                 String password) {
+        _cpds = cpds;
+        _validationQuery = validationQuery;
+        _validationQueryTimeout = validationQueryTimeout;
+        _username = username;
+        _password = password;
+        _rollbackAfterValidation = rollbackAfterValidation;
+    }
+
+    /**
+     * Returns the object pool used to pool connections created by this factory.
+     *
+     * @return ObjectPool managing pooled connections
+     */
+    public ObjectPool<PooledConnectionAndInfo> getPool() {
+        return _pool;
+    }
+
+    /**
+     *
+     * @param pool the {@link ObjectPool} in which to pool those {@link
+     * Connection}s
+     */
+    public void setPool(ObjectPool<PooledConnectionAndInfo> pool) {
+        this._pool = pool;
+    }
+
+    @Override
+    public synchronized PooledObject<PooledConnectionAndInfo> makeObject() {
+        PooledConnectionAndInfo pci;
+        try {
+            PooledConnection pc = null;
+            if (_username == null) {
+                pc = _cpds.getPooledConnection();
+            } else {
+                pc = _cpds.getPooledConnection(_username, _password);
+            }
+
+            if (pc == null) {
+                throw new IllegalStateException("Connection pool data source returned null from getPooledConnection");
+            }
+
+            // should we add this object as a listener or the pool.
+            // consider the validateObject method in decision
+            pc.addConnectionEventListener(this);
+            pci = new PooledConnectionAndInfo(pc, _username, _password);
+            pcMap.put(pc, pci);
+        } catch (SQLException e) {
+            throw new RuntimeException(e.getMessage());
+        }
+        return new DefaultPooledObject<>(pci);
+    }
+
+    /**
+     * Closes the PooledConnection and stops listening for events from it.
+     */
+    @Override
+    public void destroyObject(PooledObject<PooledConnectionAndInfo> p) throws Exception {
+        doDestroyObject(p.getObject());
+    }
+
+    private void doDestroyObject(PooledConnectionAndInfo pci) throws Exception{
+        PooledConnection pc = pci.getPooledConnection();
+        pc.removeConnectionEventListener(this);
+        pcMap.remove(pc);
+        pc.close();
+    }
+
+    @Override
+    public boolean validateObject(PooledObject<PooledConnectionAndInfo> p) {
+        try {
+            validateLifetime(p);
+        } catch (Exception e) {
+            return false;
+        }
+        boolean valid = false;
+        PooledConnection pconn = p.getObject().getPooledConnection();
+        if (null == _validationQuery) {
+            int timeout = _validationQueryTimeout;
+            if (timeout < 0) {
+                timeout = 0;
+            }
+            try {
+                valid = pconn.getConnection().isValid(timeout);
+            } catch (SQLException e) {
+                valid = false;
+            }
+        } else {
+            Connection conn = null;
+            Statement stmt = null;
+            ResultSet rset = null;
+            // logical Connection from the PooledConnection must be closed
+            // before another one can be requested and closing it will
+            // generate an event. Keep track so we know not to return
+            // the PooledConnection
+            validatingSet.add(pconn);
+            try {
+                conn = pconn.getConnection();
+                stmt = conn.createStatement();
+                rset = stmt.executeQuery(_validationQuery);
+                if (rset.next()) {
+                    valid = true;
+                } else {
+                    valid = false;
+                }
+                if (_rollbackAfterValidation) {
+                    conn.rollback();
+                }
+            } catch (Exception e) {
+                valid = false;
+            } finally {
+                Utils.closeQuietly(rset);
+                Utils.closeQuietly(stmt);
+                Utils.closeQuietly(conn);
+                validatingSet.remove(pconn);
+            }
+        }
+        return valid;
+    }
+
+    @Override
+    public void passivateObject(PooledObject<PooledConnectionAndInfo> p)
+            throws Exception {
+        validateLifetime(p);
+    }
+
+    @Override
+    public void activateObject(PooledObject<PooledConnectionAndInfo> p)
+            throws Exception {
+        validateLifetime(p);
+    }
+
+    // ***********************************************************************
+    // java.sql.ConnectionEventListener implementation
+    // ***********************************************************************
+
+    /**
+     * This will be called if the Connection returned by the getConnection
+     * method came from a PooledConnection, and the user calls the close()
+     * method of this connection object. What we need to do here is to
+     * release this PooledConnection from our pool...
+     */
+    @Override
+    public void connectionClosed(ConnectionEvent event) {
+        PooledConnection pc = (PooledConnection) event.getSource();
+        // if this event occurred because we were validating, ignore it
+        // otherwise return the connection to the pool.
+        if (!validatingSet.contains(pc)) {
+            PooledConnectionAndInfo pci = pcMap.get(pc);
+            if (pci == null) {
+                throw new IllegalStateException(NO_KEY_MESSAGE);
+            }
+
+            try {
+                _pool.returnObject(pci);
+            } catch (Exception e) {
+                System.err.println("CLOSING DOWN CONNECTION AS IT COULD "
+                        + "NOT BE RETURNED TO THE POOL");
+                pc.removeConnectionEventListener(this);
+                try {
+                    doDestroyObject(pci);
+                } catch (Exception e2) {
+                    System.err.println("EXCEPTION WHILE DESTROYING OBJECT "
+                            + pci);
+                    e2.printStackTrace();
+                }
+            }
+        }
+    }
+
+    /**
+     * If a fatal error occurs, close the underlying physical connection so as
+     * not to be returned in the future
+     */
+    @Override
+    public void connectionErrorOccurred(ConnectionEvent event) {
+        PooledConnection pc = (PooledConnection)event.getSource();
+        if (null != event.getSQLException()) {
+            System.err.println(
+                    "CLOSING DOWN CONNECTION DUE TO INTERNAL ERROR ("
+                    + event.getSQLException() + ")");
+        }
+        pc.removeConnectionEventListener(this);
+
+        PooledConnectionAndInfo pci = pcMap.get(pc);
+        if (pci == null) {
+            throw new IllegalStateException(NO_KEY_MESSAGE);
+        }
+        try {
+            _pool.invalidateObject(pci);
+        } catch (Exception e) {
+            System.err.println("EXCEPTION WHILE DESTROYING OBJECT " + pci);
+            e.printStackTrace();
+        }
+    }
+
+    // ***********************************************************************
+    // PooledConnectionManager implementation
+    // ***********************************************************************
+
+    /**
+     * Invalidates the PooledConnection in the pool.  The CPDSConnectionFactory
+     * closes the connection and pool counters are updated appropriately.
+     * Also closes the pool.  This ensures that all idle connections are closed
+     * and connections that are checked out are closed on return.
+     */
+    @Override
+    public void invalidate(PooledConnection pc) throws SQLException {
+        PooledConnectionAndInfo pci = pcMap.get(pc);
+        if (pci == null) {
+            throw new IllegalStateException(NO_KEY_MESSAGE);
+        }
+        try {
+            _pool.invalidateObject(pci);  // Destroy instance and update pool counters
+            _pool.close();  // Clear any other instances in this pool and kill others as they come back
+        } catch (Exception ex) {
+            throw new SQLException("Error invalidating connection", ex);
+        }
+    }
+
+    /**
+     * Sets the database password used when creating new connections.
+     *
+     * @param password new password
+     */
+    @Override
+    public synchronized void setPassword(String password) {
+        _password = password;
+    }
+
+    /**
+     * Sets the maximum lifetime in milliseconds of a connection after which the
+     * connection will always fail activation, passivation and validation. A
+     * value of zero or less indicates an infinite lifetime. The default value
+     * is -1.
+     */
+    public void setMaxConnLifetimeMillis(long maxConnLifetimeMillis) {
+        this.maxConnLifetimeMillis = maxConnLifetimeMillis;
+    }
+
+    /**
+     * Verifies that the username matches the user whose connections are being managed by this
+     * factory and closes the pool if this is the case; otherwise does nothing.
+     */
+    @Override
+    public void closePool(String username) throws SQLException {
+        synchronized (this) {
+            if (username == null || !username.equals(_username)) {
+                return;
+            }
+        }
+        try {
+            _pool.close();
+        } catch (Exception ex) {
+            throw new SQLException("Error closing connection pool", ex);
+        }
+    }
+
+    private void validateLifetime(PooledObject<PooledConnectionAndInfo> p)
+            throws Exception {
+        if (maxConnLifetimeMillis > 0) {
+            long lifetime = System.currentTimeMillis() - p.getCreateTime();
+            if (lifetime > maxConnLifetimeMillis) {
+                throw new Exception(Utils.getMessage(
+                        "connectionFactory.lifetimeExceeded",
+                        Long.valueOf(lifetime),
+                        Long.valueOf(maxConnLifetimeMillis)));
+            }
+        }
+    }
+}

==================================================
InstanceKeyDataSourceFactory.java
new file mode 100644
index 0000000000..3a59d1f034
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/InstanceKeyDataSource.java
@@ -0,0 +1,1067 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2.datasources;
+
+import java.io.OutputStreamWriter;
+import java.io.PrintWriter;
+import java.io.Serializable;
+import java.nio.charset.StandardCharsets;
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.sql.SQLFeatureNotSupportedException;
+import java.util.NoSuchElementException;
+import java.util.Properties;
+import java.util.logging.Logger;
+
+import javax.naming.Context;
+import javax.naming.InitialContext;
+import javax.naming.Referenceable;
+import javax.sql.ConnectionPoolDataSource;
+import javax.sql.DataSource;
+import javax.sql.PooledConnection;
+
+import org.apache.tomcat.dbcp.pool2.impl.BaseObjectPoolConfig;
+import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPoolConfig;
+
+/**
+ * <p>The base class for <code>SharedPoolDataSource</code> and
+ * <code>PerUserPoolDataSource</code>.  Many of the configuration properties
+ * are shared and defined here.  This class is declared public in order
+ * to allow particular usage with commons-beanutils; do not make direct
+ * use of it outside of commons-dbcp.
+ * </p>
+ *
+ * <p>
+ * A J2EE container will normally provide some method of initializing the
+ * <code>DataSource</code> whose attributes are presented
+ * as bean getters/setters and then deploying it via JNDI.  It is then
+ * available to an application as a source of pooled logical connections to
+ * the database.  The pool needs a source of physical connections.  This
+ * source is in the form of a <code>ConnectionPoolDataSource</code> that
+ * can be specified via the {@link #setDataSourceName(String)} used to
+ * lookup the source via JNDI.
+ * </p>
+ *
+ * <p>
+ * Although normally used within a JNDI environment, A DataSource
+ * can be instantiated and initialized as any bean.  In this case the
+ * <code>ConnectionPoolDataSource</code> will likely be instantiated in
+ * a similar manner.  This class allows the physical source of connections
+ * to be attached directly to this pool using the
+ * {@link #setConnectionPoolDataSource(ConnectionPoolDataSource)} method.
+ * </p>
+ *
+ * <p>
+ * The dbcp package contains an adapter,
+ * {@link org.apache.tomcat.dbcp.dbcp2.cpdsadapter.DriverAdapterCPDS},
+ * that can be used to allow the use of <code>DataSource</code>'s based on this
+ * class with jdbc driver implementations that do not supply a
+ * <code>ConnectionPoolDataSource</code>, but still
+ * provide a {@link java.sql.Driver} implementation.
+ * </p>
+ *
+ * <p>
+ * The <a href="package-summary.html">package documentation</a> contains an
+ * example using Apache Tomcat and JNDI and it also contains a non-JNDI example.
+ * </p>
+ *
+ * @author John D. McNally
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public abstract class InstanceKeyDataSource
+        implements DataSource, Referenceable, Serializable {
+
+    private static final long serialVersionUID = -6819270431752240878L;
+
+    private static final String GET_CONNECTION_CALLED
+            = "A Connection was already requested from this source, "
+            + "further initialization is not allowed.";
+    private static final String BAD_TRANSACTION_ISOLATION
+        = "The requested TransactionIsolation level is invalid.";
+
+    /**
+    * Internal constant to indicate the level is not set.
+    */
+    protected static final int UNKNOWN_TRANSACTIONISOLATION = -1;
+
+    /** Guards property setters - once true, setters throw IllegalStateException */
+    private volatile boolean getConnectionCalled = false;
+
+    /** Underlying source of PooledConnections */
+    private ConnectionPoolDataSource dataSource = null;
+
+    /** DataSource Name used to find the ConnectionPoolDataSource */
+    private String dataSourceName = null;
+
+    /** Description */
+    private String description = null;
+
+    /** Environment that may be used to set up a jndi initial context. */
+    private Properties jndiEnvironment = null;
+
+    /** Login TimeOut in seconds */
+    private int loginTimeout = 0;
+
+    /** Log stream */
+    private PrintWriter logWriter = null;
+
+    /** Instance key */
+    private String instanceKey = null;
+
+    // Pool properties
+    private boolean defaultBlockWhenExhausted =
+            BaseObjectPoolConfig.DEFAULT_BLOCK_WHEN_EXHAUSTED;
+    private String defaultEvictionPolicyClassName =
+            BaseObjectPoolConfig.DEFAULT_EVICTION_POLICY_CLASS_NAME;
+    private boolean defaultLifo = BaseObjectPoolConfig.DEFAULT_LIFO;
+    private int defaultMaxIdle =
+            GenericKeyedObjectPoolConfig.DEFAULT_MAX_IDLE_PER_KEY;
+    private int defaultMaxTotal =
+            GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL;
+    private long defaultMaxWaitMillis =
+            BaseObjectPoolConfig.DEFAULT_MAX_WAIT_MILLIS;
+    private long defaultMinEvictableIdleTimeMillis =
+            BaseObjectPoolConfig.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
+    private int defaultMinIdle =
+            GenericKeyedObjectPoolConfig.DEFAULT_MIN_IDLE_PER_KEY;
+    private int defaultNumTestsPerEvictionRun =
+            BaseObjectPoolConfig.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
+    private long defaultSoftMinEvictableIdleTimeMillis =
+            BaseObjectPoolConfig.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
+    private boolean defaultTestOnCreate =
+            BaseObjectPoolConfig.DEFAULT_TEST_ON_CREATE;
+    private boolean defaultTestOnBorrow =
+            BaseObjectPoolConfig.DEFAULT_TEST_ON_BORROW;
+    private boolean defaultTestOnReturn =
+            BaseObjectPoolConfig.DEFAULT_TEST_ON_RETURN;
+    private boolean defaultTestWhileIdle =
+            BaseObjectPoolConfig.DEFAULT_TEST_WHILE_IDLE;
+    private long defaultTimeBetweenEvictionRunsMillis =
+            BaseObjectPoolConfig.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
+
+    // Connection factory properties
+    private String validationQuery = null;
+    private int validationQueryTimeout = -1;
+    private boolean rollbackAfterValidation = false;
+    private long maxConnLifetimeMillis = -1;
+
+    // Connection properties
+    private Boolean defaultAutoCommit = null;
+    private int defaultTransactionIsolation = UNKNOWN_TRANSACTIONISOLATION;
+    private Boolean defaultReadOnly = null;
+
+
+    /**
+     * Default no-arg constructor for Serialization
+     */
+    public InstanceKeyDataSource() {
+    }
+
+    /**
+     * Throws an IllegalStateException, if a PooledConnection has already
+     * been requested.
+     */
+    protected void assertInitializationAllowed()
+        throws IllegalStateException {
+        if (getConnectionCalled) {
+            throw new IllegalStateException(GET_CONNECTION_CALLED);
+        }
+    }
+
+    /**
+     * Close the connection pool being maintained by this datasource.
+     */
+    public abstract void close() throws Exception;
+
+    protected abstract PooledConnectionManager getConnectionManager(UserPassKey upkey);
+
+    /* JDBC_4_ANT_KEY_BEGIN */
+    @Override
+    public boolean isWrapperFor(Class<?> iface) throws SQLException {
+        return false;
+    }
+
+    @Override
+    public <T> T unwrap(Class<T> iface) throws SQLException {
+        throw new SQLException("InstanceKeyDataSource is not a wrapper.");
+    }
+    /* JDBC_4_ANT_KEY_END */
+
+    @Override
+    public Logger getParentLogger() throws SQLFeatureNotSupportedException {
+        throw new SQLFeatureNotSupportedException();
+    }
+
+
+    // -------------------------------------------------------------------
+    // Properties
+
+    /**
+     * Gets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getBlockWhenExhausted()} for each per
+     * user pool.
+     */
+    public boolean getDefaultBlockWhenExhausted() {
+        return this.defaultBlockWhenExhausted;
+    }
+
+    /**
+     * Sets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getBlockWhenExhausted()} for each per
+     * user pool.
+     */
+    public void setDefaultBlockWhenExhausted(boolean blockWhenExhausted) {
+        assertInitializationAllowed();
+        this.defaultBlockWhenExhausted = blockWhenExhausted;
+    }
+
+
+    /**
+     * Gets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getEvictionPolicyClassName()} for
+     * each per user pool.
+     */
+    public String getDefaultEvictionPolicyClassName() {
+        return this.defaultEvictionPolicyClassName;
+    }
+
+    /**
+     * Sets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getEvictionPolicyClassName()} for
+     * each per user pool.
+     */
+    public void setDefaultEvictionPolicyClassName(
+            String evictionPolicyClassName) {
+        assertInitializationAllowed();
+        this.defaultEvictionPolicyClassName = evictionPolicyClassName;
+    }
+
+
+    /**
+     * Gets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getLifo()} for each per user pool.
+     */
+    public boolean getDefaultLifo() {
+        return this.defaultLifo;
+    }
+
+    /**
+     * Sets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getLifo()} for each per user pool.
+     */
+    public void setDefaultLifo(boolean lifo) {
+        assertInitializationAllowed();
+        this.defaultLifo = lifo;
+    }
+
+
+    /**
+     * Gets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getMaxIdlePerKey()} for each per user
+     * pool.
+     */
+    public int getDefaultMaxIdle() {
+        return this.defaultMaxIdle;
+    }
+
+    /**
+     * Sets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getMaxIdlePerKey()} for each per user
+     * pool.
+     */
+    public void setDefaultMaxIdle(int maxIdle) {
+        assertInitializationAllowed();
+        this.defaultMaxIdle = maxIdle;
+    }
+
+
+    /**
+     * Gets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getMaxTotalPerKey()} for each per
+     * user pool.
+     */
+    public int getDefaultMaxTotal() {
+        return this.defaultMaxTotal;
+    }
+
+    /**
+     * Sets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getMaxTotalPerKey()} for each per
+     * user pool.
+     */
+    public void setDefaultMaxTotal(int maxTotal) {
+        assertInitializationAllowed();
+        this.defaultMaxTotal = maxTotal;
+    }
+
+
+    /**
+     * Gets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getMaxWaitMillis()} for each per user
+     * pool.
+     */
+    public long getDefaultMaxWaitMillis() {
+        return this.defaultMaxWaitMillis;
+    }
+
+    /**
+     * Sets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getMaxWaitMillis()} for each per user
+     * pool.
+     */
+    public void setDefaultMaxWaitMillis(long maxWaitMillis) {
+        assertInitializationAllowed();
+        this.defaultMaxWaitMillis = maxWaitMillis;
+    }
+
+
+    /**
+     * Gets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getMinEvictableIdleTimeMillis()} for
+     * each per user pool.
+     */
+    public long getDefaultMinEvictableIdleTimeMillis() {
+        return this.defaultMinEvictableIdleTimeMillis;
+    }
+
+    /**
+     * Sets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getMinEvictableIdleTimeMillis()} for
+     * each per user pool.
+     */
+    public void setDefaultMinEvictableIdleTimeMillis(
+            long minEvictableIdleTimeMillis) {
+        assertInitializationAllowed();
+        this.defaultMinEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
+    }
+
+
+    /**
+     * Gets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getMinIdlePerKey()} for each per user
+     * pool.
+     */
+    public int getDefaultMinIdle() {
+        return this.defaultMinIdle;
+    }
+
+    /**
+     * Sets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getMinIdlePerKey()} for each per user
+     * pool.
+     */
+    public void setDefaultMinIdle(int minIdle) {
+        assertInitializationAllowed();
+        this.defaultMinIdle = minIdle;
+    }
+
+
+    /**
+     * Gets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getNumTestsPerEvictionRun()} for each
+     * per user pool.
+     */
+    public int getDefaultNumTestsPerEvictionRun() {
+        return this.defaultNumTestsPerEvictionRun;
+    }
+
+    /**
+     * Sets the default value for
+     * {@link GenericKeyedObjectPoolConfig#getNumTestsPerEvictionRun()} for each
+     * per user pool.
+     */
+    public void setDefaultNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
+        assertInitializationAllowed();
+        this.defaultNumTestsPerEvictionRun = numTestsPerEvictionRun;
+    }
+
+
+    /**
+     * Gets the default value for
+     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getSoftMinEvictableIdleTimeMillis()} for each
+     * per user pool.
+     */
+    public long getDefaultSoftMinEvictableIdleTimeMillis() {
+        return this.defaultSoftMinEvictableIdleTimeMillis;
+    }
+
+    /**
+     * Sets the default value for
+     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getSoftMinEvictableIdleTimeMillis()} for each per user pool.
+     */
+    public void setDefaultSoftMinEvictableIdleTimeMillis(
+            long softMinEvictableIdleTimeMillis) {
+        assertInitializationAllowed();
+        this.defaultSoftMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
+    }
+
+
+    /**
+     * Gets the default value for
+     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestOnCreate()} for each per user pool.
+     */
+    public boolean getDefaultTestOnCreate() {
+        return this.defaultTestOnCreate;
+    }
+
+    /**
+     * Sets the default value for
+     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestOnCreate()} for each per user pool.
+     */
+    public void setDefaultTestOnCreate(boolean testOnCreate) {
+        assertInitializationAllowed();
+        this.defaultTestOnCreate = testOnCreate;
+    }
+
+
+    /**
+     * Gets the default value for
+     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestOnBorrow()} for each per user pool.
+     */
+    public boolean getDefaultTestOnBorrow() {
+        return this.defaultTestOnBorrow;
+    }
+
+    /**
+     * Sets the default value for
+     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestOnBorrow()} for each per user pool.
+     */
+    public void setDefaultTestOnBorrow(boolean testOnBorrow) {
+        assertInitializationAllowed();
+        this.defaultTestOnBorrow = testOnBorrow;
+    }
+
+
+    /**
+     * Gets the default value for
+     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestOnReturn()} for each per user pool.
+     */
+    public boolean getDefaultTestOnReturn() {
+        return this.defaultTestOnReturn;
+    }
+
+    /**
+     * Sets the default value for
+     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestOnReturn()} for each per user pool.
+     */
+    public void setDefaultTestOnReturn(boolean testOnReturn) {
+        assertInitializationAllowed();
+        this.defaultTestOnReturn = testOnReturn;
+    }
+
+
+    /**
+     * Gets the default value for
+     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestWhileIdle()} for each per user pool.
+     */
+    public boolean getDefaultTestWhileIdle() {
+        return this.defaultTestWhileIdle;
+    }
+
+    /**
+     * Sets the default value for
+     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestWhileIdle()} for each per user pool.
+     */
+    public void setDefaultTestWhileIdle(boolean testWhileIdle) {
+        assertInitializationAllowed();
+        this.defaultTestWhileIdle = testWhileIdle;
+    }
+
+
+    /**
+     * Gets the default value for
+     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTimeBetweenEvictionRunsMillis ()} for each
+     * per user pool.
+     */
+    public long getDefaultTimeBetweenEvictionRunsMillis () {
+        return this.defaultTimeBetweenEvictionRunsMillis ;
+    }
+
+    /**
+     * Sets the default value for
+     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTimeBetweenEvictionRunsMillis ()} for each
+     * per user pool.
+     */
+    public void setDefaultTimeBetweenEvictionRunsMillis (
+            long timeBetweenEvictionRunsMillis ) {
+        assertInitializationAllowed();
+        this.defaultTimeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis ;
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    /**
+     * Get the value of connectionPoolDataSource.  This method will return
+     * null, if the backing datasource is being accessed via jndi.
+     *
+     * @return value of connectionPoolDataSource.
+     */
+    public ConnectionPoolDataSource getConnectionPoolDataSource() {
+        return dataSource;
+    }
+
+    /**
+     * Set the backend ConnectionPoolDataSource.  This property should not be
+     * set if using jndi to access the datasource.
+     *
+     * @param v  Value to assign to connectionPoolDataSource.
+     */
+    public void setConnectionPoolDataSource(ConnectionPoolDataSource v) {
+        assertInitializationAllowed();
+        if (dataSourceName != null) {
+            throw new IllegalStateException(
+                "Cannot set the DataSource, if JNDI is used.");
+        }
+        if (dataSource != null)
+        {
+            throw new IllegalStateException(
+                "The CPDS has already been set. It cannot be altered.");
+        }
+        dataSource = v;
+        instanceKey = InstanceKeyDataSourceFactory.registerNewInstance(this);
+    }
+
+    /**
+     * Get the name of the ConnectionPoolDataSource which backs this pool.
+     * This name is used to look up the datasource from a jndi service
+     * provider.
+     *
+     * @return value of dataSourceName.
+     */
+    public String getDataSourceName() {
+        return dataSourceName;
+    }
+
+    /**
+     * Set the name of the ConnectionPoolDataSource which backs this pool.
+     * This name is used to look up the datasource from a jndi service
+     * provider.
+     *
+     * @param v  Value to assign to dataSourceName.
+     */
+    public void setDataSourceName(String v) {
+        assertInitializationAllowed();
+        if (dataSource != null) {
+            throw new IllegalStateException(
+                "Cannot set the JNDI name for the DataSource, if already " +
+                "set using setConnectionPoolDataSource.");
+        }
+        if (dataSourceName != null)
+        {
+            throw new IllegalStateException(
+                "The DataSourceName has already been set. " +
+                "It cannot be altered.");
+        }
+        this.dataSourceName = v;
+        instanceKey = InstanceKeyDataSourceFactory.registerNewInstance(this);
+    }
+
+    /**
+     * Get the value of defaultAutoCommit, which defines the state of
+     * connections handed out from this pool.  The value can be changed
+     * on the Connection using Connection.setAutoCommit(boolean).
+     * The default is <code>null</code> which will use the default value for the
+     * drive.
+     *
+     * @return value of defaultAutoCommit.
+     */
+    public Boolean isDefaultAutoCommit() {
+        return defaultAutoCommit;
+    }
+
+    /**
+     * Set the value of defaultAutoCommit, which defines the state of
+     * connections handed out from this pool.  The value can be changed
+     * on the Connection using Connection.setAutoCommit(boolean).
+     * The default is <code>null</code> which will use the default value for the
+     * drive.
+     *
+     * @param v  Value to assign to defaultAutoCommit.
+     */
+    public void setDefaultAutoCommit(Boolean v) {
+        assertInitializationAllowed();
+        this.defaultAutoCommit = v;
+    }
+
+    /**
+     * Get the value of defaultReadOnly, which defines the state of
+     * connections handed out from this pool.  The value can be changed
+     * on the Connection using Connection.setReadOnly(boolean).
+     * The default is <code>null</code> which will use the default value for the
+     * drive.
+     *
+     * @return value of defaultReadOnly.
+     */
+    public Boolean isDefaultReadOnly() {
+        return defaultReadOnly;
+    }
+
+    /**
+     * Set the value of defaultReadOnly, which defines the state of
+     * connections handed out from this pool.  The value can be changed
+     * on the Connection using Connection.setReadOnly(boolean).
+     * The default is <code>null</code> which will use the default value for the
+     * drive.
+     *
+     * @param v  Value to assign to defaultReadOnly.
+     */
+    public void setDefaultReadOnly(Boolean v) {
+        assertInitializationAllowed();
+        this.defaultReadOnly = v;
+    }
+
+    /**
+     * Get the value of defaultTransactionIsolation, which defines the state of
+     * connections handed out from this pool.  The value can be changed
+     * on the Connection using Connection.setTransactionIsolation(int).
+     * If this method returns -1, the default is JDBC driver dependent.
+     *
+     * @return value of defaultTransactionIsolation.
+     */
+    public int getDefaultTransactionIsolation() {
+        return defaultTransactionIsolation;
+    }
+
+    /**
+     * Set the value of defaultTransactionIsolation, which defines the state of
+     * connections handed out from this pool.  The value can be changed
+     * on the Connection using Connection.setTransactionIsolation(int).
+     * The default is JDBC driver dependent.
+     *
+     * @param v  Value to assign to defaultTransactionIsolation
+     */
+    public void setDefaultTransactionIsolation(int v) {
+        assertInitializationAllowed();
+        switch (v) {
+        case Connection.TRANSACTION_NONE:
+        case Connection.TRANSACTION_READ_COMMITTED:
+        case Connection.TRANSACTION_READ_UNCOMMITTED:
+        case Connection.TRANSACTION_REPEATABLE_READ:
+        case Connection.TRANSACTION_SERIALIZABLE:
+            break;
+        default:
+            throw new IllegalArgumentException(BAD_TRANSACTION_ISOLATION);
+        }
+        this.defaultTransactionIsolation = v;
+    }
+
+    /**
+     * Get the description.  This property is defined by jdbc as for use with
+     * GUI (or other) tools that might deploy the datasource.  It serves no
+     * internal purpose.
+     *
+     * @return value of description.
+     */
+    public String getDescription() {
+        return description;
+    }
+
+    /**
+     * Set the description.  This property is defined by jdbc as for use with
+     * GUI (or other) tools that might deploy the datasource.  It serves no
+     * internal purpose.
+     *
+     * @param v  Value to assign to description.
+     */
+    public void setDescription(String v) {
+        this.description = v;
+    }
+
+    protected String getInstanceKey() {
+        return instanceKey;
+    }
+
+    /**
+     * Get the value of jndiEnvironment which is used when instantiating
+     * a jndi InitialContext.  This InitialContext is used to locate the
+     * backend ConnectionPoolDataSource.
+     *
+     * @return value of jndiEnvironment.
+     */
+    public String getJndiEnvironment(String key) {
+        String value = null;
+        if (jndiEnvironment != null) {
+            value = jndiEnvironment.getProperty(key);
+        }
+        return value;
+    }
+
+    /**
+     * Sets the value of the given JNDI environment property to be used when
+     * instantiating a JNDI InitialContext. This InitialContext is used to
+     * locate the backend ConnectionPoolDataSource.
+     *
+     * @param key the JNDI environment property to set.
+     * @param value the value assigned to specified JNDI environment property.
+     */
+    public void setJndiEnvironment(String key, String value) {
+        if (jndiEnvironment == null) {
+            jndiEnvironment = new Properties();
+        }
+        jndiEnvironment.setProperty(key, value);
+    }
+
+    /**
+     * Sets the JNDI environment to be used when instantiating a JNDI
+     * InitialContext. This InitialContext is used to locate the backend
+     * ConnectionPoolDataSource.
+     *
+     * @param properties the JNDI environment property to set which will
+     *                   overwrite any current settings
+     */
+    void setJndiEnvironment(Properties properties) {
+        if (jndiEnvironment == null) {
+            jndiEnvironment = new Properties();
+        } else {
+            jndiEnvironment.clear();
+        }
+        jndiEnvironment.putAll(properties);
+    }
+
+    /**
+     * Get the value of loginTimeout.
+     * @return value of loginTimeout.
+     */
+    @Override
+    public int getLoginTimeout() {
+        return loginTimeout;
+    }
+
+    /**
+     * Set the value of loginTimeout.
+     * @param v  Value to assign to loginTimeout.
+     */
+    @Override
+    public void setLoginTimeout(int v) {
+        this.loginTimeout = v;
+    }
+
+    /**
+     * Get the value of logWriter.
+     * @return value of logWriter.
+     */
+    @Override
+    public PrintWriter getLogWriter() {
+        if (logWriter == null) {
+            logWriter = new PrintWriter(
+                    new OutputStreamWriter(System.out, StandardCharsets.UTF_8));
+        }
+        return logWriter;
+    }
+
+    /**
+     * Set the value of logWriter.
+     * @param v  Value to assign to logWriter.
+     */
+    @Override
+    public void setLogWriter(PrintWriter v) {
+        this.logWriter = v;
+    }
+
+    /**
+     * The SQL query that will be used to validate connections from this pool
+     * before returning them to the caller.  If specified, this query
+     * <strong>MUST</strong> be an SQL SELECT statement that returns at least
+     * one row. If not specified, {@link Connection#isValid(int)} will be used
+     * to validate connections.
+     */
+    public String getValidationQuery() {
+        return this.validationQuery;
+    }
+
+    /**
+     * The SQL query that will be used to validate connections from this pool
+     * before returning them to the caller.  If specified, this query
+     * <strong>MUST</strong> be an SQL SELECT statement that returns at least
+     * one row. If not specified, connections will be validated using
+     * {@link Connection#isValid(int)}.
+     */
+    public void setValidationQuery(String validationQuery) {
+        assertInitializationAllowed();
+        this.validationQuery = validationQuery;
+    }
+
+    /**
+     * Returns the timeout in seconds before the validation query fails.
+     */
+    public int getValidationQueryTimeout() {
+        return validationQueryTimeout;
+    }
+
+    /**
+     * Sets the timeout in seconds before the validation query fails.
+     *
+     * @param validationQueryTimeout    The new timeout in seconds
+     */
+    public void setValidationQueryTimeout(int validationQueryTimeout) {
+        this.validationQueryTimeout = validationQueryTimeout;
+    }
+
+    /**
+     * Whether a rollback will be issued after executing the SQL query
+     * that will be used to validate connections from this pool
+     * before returning them to the caller.
+     *
+     * @return true if a rollback will be issued after executing the
+     * validation query
+     */
+    public boolean isRollbackAfterValidation() {
+        return this.rollbackAfterValidation;
+    }
+
+    /**
+     * Whether a rollback will be issued after executing the SQL query
+     * that will be used to validate connections from this pool
+     * before returning them to the caller. Default behavior is NOT
+     * to issue a rollback. The setting will only have an effect
+     * if a validation query is set
+     *
+     * @param rollbackAfterValidation new property value
+     */
+    public void setRollbackAfterValidation(boolean rollbackAfterValidation) {
+        assertInitializationAllowed();
+        this.rollbackAfterValidation = rollbackAfterValidation;
+    }
+
+    /**
+     * Returns the maximum permitted lifetime of a connection in milliseconds. A
+     * value of zero or less indicates an infinite lifetime.
+     */
+    public long getMaxConnLifetimeMillis() {
+        return maxConnLifetimeMillis;
+    }
+
+    /**
+     * <p>Sets the maximum permitted lifetime of a connection in
+     * milliseconds. A value of zero or less indicates an infinite lifetime.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     */
+    public void setMaxConnLifetimeMillis(long maxConnLifetimeMillis) {
+        this.maxConnLifetimeMillis = maxConnLifetimeMillis;
+    }
+
+    // ----------------------------------------------------------------------
+    // Instrumentation Methods
+
+    // ----------------------------------------------------------------------
+    // DataSource implementation
+
+    /**
+     * Attempt to establish a database connection.
+     */
+    @Override
+    public Connection getConnection() throws SQLException {
+        return getConnection(null, null);
+    }
+
+    /**
+     * Attempt to retrieve a database connection using {@link #getPooledConnectionAndInfo(String, String)}
+     * with the provided username and password.  The password on the {@link PooledConnectionAndInfo}
+     * instance returned by <code>getPooledConnectionAndInfo</code> is compared to the <code>password</code>
+     * parameter.  If the comparison fails, a database connection using the supplied username and password
+     * is attempted.  If the connection attempt fails, an SQLException is thrown, indicating that the given password
+     * did not match the password used to create the pooled connection.  If the connection attempt succeeds, this
+     * means that the database password has been changed.  In this case, the <code>PooledConnectionAndInfo</code>
+     * instance retrieved with the old password is destroyed and the <code>getPooledConnectionAndInfo</code> is
+     * repeatedly invoked until a <code>PooledConnectionAndInfo</code> instance with the new password is returned.
+     *
+     */
+    @Override
+    public Connection getConnection(String username, String password)
+            throws SQLException {
+        if (instanceKey == null) {
+            throw new SQLException("Must set the ConnectionPoolDataSource "
+                    + "through setDataSourceName or setConnectionPoolDataSource"
+                    + " before calling getConnection.");
+        }
+        getConnectionCalled = true;
+        PooledConnectionAndInfo info = null;
+        try {
+            info = getPooledConnectionAndInfo(username, password);
+        } catch (NoSuchElementException e) {
+            closeDueToException(info);
+            throw new SQLException("Cannot borrow connection from pool", e);
+        } catch (RuntimeException e) {
+            closeDueToException(info);
+            throw e;
+        } catch (SQLException e) {
+            closeDueToException(info);
+            throw e;
+        } catch (Exception e) {
+            closeDueToException(info);
+            throw new SQLException("Cannot borrow connection from pool", e);
+        }
+
+        if (!(null == password ? null == info.getPassword()
+                : password.equals(info.getPassword()))) {  // Password on PooledConnectionAndInfo does not match
+            try { // See if password has changed by attempting connection
+                testCPDS(username, password);
+            } catch (SQLException ex) {
+                // Password has not changed, so refuse client, but return connection to the pool
+                closeDueToException(info);
+                throw new SQLException("Given password did not match password used"
+                                       + " to create the PooledConnection.");
+            } catch (javax.naming.NamingException ne) {
+                throw new SQLException(
+                        "NamingException encountered connecting to database", ne);
+            }
+            /*
+             * Password must have changed -> destroy connection and keep retrying until we get a new, good one,
+             * destroying any idle connections with the old passowrd as we pull them from the pool.
+             */
+            final UserPassKey upkey = info.getUserPassKey();
+            final PooledConnectionManager manager = getConnectionManager(upkey);
+            manager.invalidate(info.getPooledConnection()); // Destroy and remove from pool
+            manager.setPassword(upkey.getPassword()); // Reset the password on the factory if using CPDSConnectionFactory
+            info = null;
+            for (int i = 0; i < 10; i++) { // Bound the number of retries - only needed if bad instances return
+                try {
+                    info = getPooledConnectionAndInfo(username, password);
+                } catch (NoSuchElementException e) {
+                    closeDueToException(info);
+                    throw new SQLException("Cannot borrow connection from pool", e);
+                } catch (RuntimeException e) {
+                    closeDueToException(info);
+                    throw e;
+                } catch (SQLException e) {
+                    closeDueToException(info);
+                    throw e;
+                } catch (Exception e) {
+                    closeDueToException(info);
+                    throw new SQLException("Cannot borrow connection from pool", e);
+                }
+                if (info != null && password != null && password.equals(info.getPassword())) {
+                    break;
+                }
+                if (info != null) {
+                    manager.invalidate(info.getPooledConnection());
+                }
+                info = null;
+            }
+            if (info == null) {
+                throw new SQLException("Cannot borrow connection from pool - password change failure.");
+            }
+        }
+
+        Connection con = info.getPooledConnection().getConnection();
+        try {
+            setupDefaults(con, username);
+            con.clearWarnings();
+            return con;
+        } catch (SQLException ex) {
+            try {
+                con.close();
+            } catch (Exception exc) {
+                getLogWriter().println(
+                     "ignoring exception during close: " + exc);
+            }
+            throw ex;
+        }
+    }
+
+    protected abstract PooledConnectionAndInfo
+        getPooledConnectionAndInfo(String username, String password)
+        throws SQLException;
+
+    protected abstract void setupDefaults(Connection con, String username)
+        throws SQLException;
+
+
+    private void closeDueToException(PooledConnectionAndInfo info) {
+        if (info != null) {
+            try {
+                info.getPooledConnection().getConnection().close();
+            } catch (Exception e) {
+                // do not throw this exception because we are in the middle
+                // of handling another exception.  But record it because
+                // it potentially leaks connections from the pool.
+                getLogWriter().println("[ERROR] Could not return connection to "
+                    + "pool during exception handling. " + e.getMessage());
+            }
+        }
+    }
+
+    protected ConnectionPoolDataSource
+        testCPDS(String username, String password)
+        throws javax.naming.NamingException, SQLException {
+        // The source of physical db connections
+        ConnectionPoolDataSource cpds = this.dataSource;
+        if (cpds == null) {
+            Context ctx = null;
+            if (jndiEnvironment == null) {
+                ctx = new InitialContext();
+            } else {
+                ctx = new InitialContext(jndiEnvironment);
+            }
+            Object ds = ctx.lookup(dataSourceName);
+            if (ds instanceof ConnectionPoolDataSource) {
+                cpds = (ConnectionPoolDataSource) ds;
+            } else {
+                throw new SQLException("Illegal configuration: "
+                    + "DataSource " + dataSourceName
+                    + " (" + ds.getClass().getName() + ")"
+                    + " doesn't implement javax.sql.ConnectionPoolDataSource");
+            }
+        }
+
+        // try to get a connection with the supplied username/password
+        PooledConnection conn = null;
+        try {
+            if (username != null) {
+                conn = cpds.getPooledConnection(username, password);
+            }
+            else {
+                conn = cpds.getPooledConnection();
+            }
+            if (conn == null) {
+                throw new SQLException(
+                    "Cannot connect using the supplied username/password");
+            }
+        }
+        finally {
+            if (conn != null) {
+                try {
+                    conn.close();
+                }
+                catch (SQLException e) {
+                    // at least we could connect
+                }
+            }
+        }
+        return cpds;
+    }
+}

==================================================
KeyedCPDSConnectionFactory.java
new file mode 100644
index 0000000000..d98250272b
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/InstanceKeyDataSourceFactory.java
@@ -0,0 +1,330 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2.datasources;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+
+import java.util.Hashtable;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Properties;
+import java.util.concurrent.ConcurrentHashMap;
+
+import javax.naming.Context;
+import javax.naming.Name;
+import javax.naming.RefAddr;
+import javax.naming.Reference;
+import javax.naming.spi.ObjectFactory;
+
+/**
+ * A JNDI ObjectFactory which creates <code>SharedPoolDataSource</code>s
+ * or <code>PerUserPoolDataSource</code>s
+ *
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+abstract class InstanceKeyDataSourceFactory implements ObjectFactory {
+
+    private static final Map<String, InstanceKeyDataSource> instanceMap =
+            new ConcurrentHashMap<>();
+
+    static synchronized String registerNewInstance(InstanceKeyDataSource ds) {
+        int max = 0;
+        Iterator<String> i = instanceMap.keySet().iterator();
+        while (i.hasNext()) {
+            String s = i.next();
+            if (s != null) {
+                try {
+                    max = Math.max(max, Integer.parseInt(s));
+                } catch (NumberFormatException e) {
+                    // no sweat, ignore those keys
+                }
+            }
+        }
+        String instanceKey = String.valueOf(max + 1);
+        // put a placeholder here for now, so other instances will not
+        // take our key.  we will replace with a pool when ready.
+        instanceMap.put(instanceKey, ds);
+        return instanceKey;
+    }
+
+    static void removeInstance(String key) {
+        if (key != null) {
+            instanceMap.remove(key);
+        }
+    }
+
+    /**
+     * Close all pools associated with this class.
+     */
+    public static void closeAll() throws Exception {
+        //Get iterator to loop over all instances of this datasource.
+        Iterator<Entry<String,InstanceKeyDataSource>> instanceIterator =
+            instanceMap.entrySet().iterator();
+        while (instanceIterator.hasNext()) {
+            instanceIterator.next().getValue().close();
+        }
+        instanceMap.clear();
+    }
+
+
+    /**
+     * implements ObjectFactory to create an instance of SharedPoolDataSource
+     * or PerUserPoolDataSource
+     */
+    @Override
+    public Object getObjectInstance(Object refObj, Name name,
+                                    Context context, Hashtable<?,?> env)
+        throws IOException, ClassNotFoundException {
+        // The spec says to return null if we can't create an instance
+        // of the reference
+        Object obj = null;
+        if (refObj instanceof Reference) {
+            Reference ref = (Reference) refObj;
+            if (isCorrectClass(ref.getClassName())) {
+                RefAddr ra = ref.get("instanceKey");
+                if (ra != null && ra.getContent() != null) {
+                    // object was bound to jndi via Referenceable api.
+                    obj = instanceMap.get(ra.getContent());
+                }
+                else
+                {
+                    // tomcat jndi creates a Reference out of server.xml
+                    // <ResourceParam> configuration and passes it to an
+                    // instance of the factory given in server.xml.
+                    String key = null;
+                    if (name != null)
+                    {
+                        key = name.toString();
+                        obj = instanceMap.get(key);
+                    }
+                    if (obj == null)
+                    {
+                        InstanceKeyDataSource ds = getNewInstance(ref);
+                        setCommonProperties(ref, ds);
+                        obj = ds;
+                        if (key != null)
+                        {
+                            instanceMap.put(key, ds);
+                        }
+                    }
+                }
+            }
+        }
+        return obj;
+    }
+
+    private void setCommonProperties(Reference ref,
+                                     InstanceKeyDataSource ikds)
+        throws IOException, ClassNotFoundException {
+
+        RefAddr ra = ref.get("dataSourceName");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDataSourceName(ra.getContent().toString());
+        }
+
+        ra = ref.get("description");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDescription(ra.getContent().toString());
+        }
+
+        ra = ref.get("jndiEnvironment");
+        if (ra != null  && ra.getContent() != null) {
+            byte[] serialized = (byte[]) ra.getContent();
+            ikds.setJndiEnvironment((Properties) deserialize(serialized));
+        }
+
+        ra = ref.get("loginTimeout");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setLoginTimeout(
+                Integer.parseInt(ra.getContent().toString()));
+        }
+
+        // Pool properties
+        ra = ref.get("blockWhenExhausted");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultBlockWhenExhausted(Boolean.valueOf(
+                ra.getContent().toString()).booleanValue());
+        }
+
+        ra = ref.get("evictionPolicyClassName");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultEvictionPolicyClassName(ra.getContent().toString());
+        }
+
+        // Pool properties
+        ra = ref.get("lifo");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultLifo(Boolean.valueOf(
+                ra.getContent().toString()).booleanValue());
+        }
+
+        ra = ref.get("maxIdlePerKey");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultMaxIdle(
+                Integer.parseInt(ra.getContent().toString()));
+        }
+
+        ra = ref.get("maxTotalPerKey");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultMaxTotal(
+                Integer.parseInt(ra.getContent().toString()));
+        }
+
+        ra = ref.get("maxWaitMillis");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultMaxWaitMillis(
+                Long.parseLong(ra.getContent().toString()));
+        }
+
+        ra = ref.get("minEvictableIdleTimeMillis");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultMinEvictableIdleTimeMillis(
+                Long.parseLong(ra.getContent().toString()));
+        }
+
+        ra = ref.get("minIdlePerKey");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultMinIdle(
+                Integer.parseInt(ra.getContent().toString()));
+        }
+
+        ra = ref.get("numTestsPerEvictionRun");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultNumTestsPerEvictionRun(
+                Integer.parseInt(ra.getContent().toString()));
+        }
+
+        ra = ref.get("softMinEvictableIdleTimeMillis");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultSoftMinEvictableIdleTimeMillis(
+                Long.parseLong(ra.getContent().toString()));
+        }
+
+        ra = ref.get("testOnCreate");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultTestOnCreate(Boolean.valueOf(
+                ra.getContent().toString()).booleanValue());
+        }
+
+        ra = ref.get("testOnBorrow");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultTestOnBorrow(Boolean.valueOf(
+                ra.getContent().toString()).booleanValue());
+        }
+
+        ra = ref.get("testOnReturn");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultTestOnReturn(Boolean.valueOf(
+                ra.getContent().toString()).booleanValue());
+        }
+
+        ra = ref.get("testWhileIdle");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultTestWhileIdle(Boolean.valueOf(
+                ra.getContent().toString()).booleanValue());
+        }
+
+        ra = ref.get("timeBetweenEvictionRunsMillis");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultTimeBetweenEvictionRunsMillis(
+                Long.parseLong(ra.getContent().toString()));
+        }
+
+
+        // Connection factory properties
+
+        ra = ref.get("validationQuery");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setValidationQuery(ra.getContent().toString());
+        }
+
+        ra = ref.get("validationQueryTimeout");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setValidationQueryTimeout(Integer.parseInt(
+                    ra.getContent().toString()));
+        }
+
+        ra = ref.get("rollbackAfterValidation");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setRollbackAfterValidation(Boolean.valueOf(
+                ra.getContent().toString()).booleanValue());
+        }
+
+        ra = ref.get("maxConnLifetimeMillis");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setMaxConnLifetimeMillis(
+                Long.parseLong(ra.getContent().toString()));
+        }
+
+
+        // Connection properties
+
+        ra = ref.get("defaultAutoCommit");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultAutoCommit(Boolean.valueOf(ra.getContent().toString()));
+        }
+
+        ra = ref.get("defaultTransactionIsolation");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultTransactionIsolation(
+                Integer.parseInt(ra.getContent().toString()));
+        }
+
+        ra = ref.get("defaultReadOnly");
+        if (ra != null && ra.getContent() != null) {
+            ikds.setDefaultReadOnly(Boolean.valueOf(ra.getContent().toString()));
+        }
+    }
+
+
+    /**
+     * @return true if and only if className is the value returned
+     * from getClass().getName().toString()
+     */
+    protected abstract boolean isCorrectClass(String className);
+
+    /**
+     * Creates an instance of the subclass and sets any properties
+     * contained in the Reference.
+     */
+    protected abstract InstanceKeyDataSource getNewInstance(Reference ref)
+        throws IOException, ClassNotFoundException;
+
+    /**
+     * used to set some properties saved within a Reference
+     */
+    protected static final Object deserialize(byte[] data)
+        throws IOException, ClassNotFoundException {
+        ObjectInputStream in = null;
+        try {
+            in = new ObjectInputStream(new ByteArrayInputStream(data));
+            return in.readObject();
+        } finally {
+            if (in != null) {
+                try {
+                    in.close();
+                } catch (IOException ex) {
+                }
+            }
+        }
+    }
+}
+

==================================================
PerUserPoolDataSource.java
new file mode 100644
index 0000000000..299eb44cd9
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/KeyedCPDSConnectionFactory.java
@@ -0,0 +1,363 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2.datasources;
+
+import java.sql.Connection;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.Collections;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import javax.sql.ConnectionEvent;
+import javax.sql.ConnectionEventListener;
+import javax.sql.ConnectionPoolDataSource;
+import javax.sql.PooledConnection;
+
+import org.apache.tomcat.dbcp.dbcp2.Utils;
+import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
+import org.apache.tomcat.dbcp.pool2.KeyedPooledObjectFactory;
+import org.apache.tomcat.dbcp.pool2.PooledObject;
+import org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject;
+
+/**
+ * A {*link PoolableObjectFactory} that creates
+ * {*link PoolableConnection}s.
+ *
+ * @author John D. McNally
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+class KeyedCPDSConnectionFactory
+    implements KeyedPooledObjectFactory<UserPassKey,PooledConnectionAndInfo>,
+    ConnectionEventListener, PooledConnectionManager {
+
+    private static final String NO_KEY_MESSAGE
+            = "close() was called on a Connection, but "
+            + "I have no record of the underlying PooledConnection.";
+
+    private final ConnectionPoolDataSource _cpds;
+    private final String _validationQuery;
+    private final int _validationQueryTimeout;
+    private final boolean _rollbackAfterValidation;
+    private KeyedObjectPool<UserPassKey,PooledConnectionAndInfo> _pool;
+    private long maxConnLifetimeMillis = -1;
+
+    /**
+     * Map of PooledConnections for which close events are ignored.
+     * Connections are muted when they are being validated.
+     */
+    private final Set<PooledConnection> validatingSet =
+            Collections.newSetFromMap(new ConcurrentHashMap<PooledConnection,Boolean>());
+
+    /**
+     * Map of PooledConnectionAndInfo instances
+     */
+    private final Map<PooledConnection, PooledConnectionAndInfo> pcMap =
+        new ConcurrentHashMap<>();
+
+
+    /**
+     * Create a new <tt>KeyedPoolableConnectionFactory</tt>.
+     * @param cpds the ConnectionPoolDataSource from which to obtain
+     * PooledConnections
+     * @param validationQuery a query to use to {@link #validateObject validate}
+     * {@link Connection}s.  Should return at least one row. May be
+     * <tt>null</tt> in which case3 {@link Connection#isValid(int)} will be used
+     * to validate connections.
+     * @param rollbackAfterValidation whether a rollback should be issued after
+     * {@link #validateObject validating} {@link Connection}s.
+     */
+    public KeyedCPDSConnectionFactory(ConnectionPoolDataSource cpds,
+                                      String validationQuery,
+                                      int validationQueryTimeout,
+                                      boolean rollbackAfterValidation) {
+        _cpds = cpds;
+        _validationQuery = validationQuery;
+        _validationQueryTimeout = validationQueryTimeout;
+        _rollbackAfterValidation = rollbackAfterValidation;
+    }
+
+    public void setPool(KeyedObjectPool<UserPassKey,PooledConnectionAndInfo> pool) {
+        this._pool = pool;
+    }
+
+    /**
+     * Returns the keyed object pool used to pool connections created by this factory.
+     *
+     * @return KeyedObjectPool managing pooled connections
+     */
+    public KeyedObjectPool<UserPassKey,PooledConnectionAndInfo> getPool() {
+        return _pool;
+    }
+
+    /**
+     * Creates a new {@link PooledConnectionAndInfo} from the given {@link UserPassKey}.
+     *
+     * @param upkey {@link UserPassKey} containing user credentials
+     * @throws SQLException if the connection could not be created.
+     * @see org.apache.tomcat.dbcp.pool2.KeyedPooledObjectFactory#makeObject(java.lang.Object)
+     */
+    @Override
+    public synchronized PooledObject<PooledConnectionAndInfo> makeObject(UserPassKey upkey)
+            throws Exception {
+        PooledConnectionAndInfo pci = null;
+
+        PooledConnection pc = null;
+        String username = upkey.getUsername();
+        String password = upkey.getPassword();
+        if (username == null) {
+            pc = _cpds.getPooledConnection();
+        } else {
+            pc = _cpds.getPooledConnection(username, password);
+        }
+
+        if (pc == null) {
+            throw new IllegalStateException("Connection pool data source returned null from getPooledConnection");
+        }
+
+        // should we add this object as a listener or the pool.
+        // consider the validateObject method in decision
+        pc.addConnectionEventListener(this);
+        pci = new PooledConnectionAndInfo(pc, username, password);
+        pcMap.put(pc, pci);
+
+        return new DefaultPooledObject<>(pci);
+    }
+
+    /**
+     * Closes the PooledConnection and stops listening for events from it.
+     */
+    @Override
+    public void destroyObject(UserPassKey key, PooledObject<PooledConnectionAndInfo> p)
+            throws Exception {
+        PooledConnection pc = p.getObject().getPooledConnection();
+        pc.removeConnectionEventListener(this);
+        pcMap.remove(pc);
+        pc.close();
+    }
+
+    /**
+     * Validates a pooled connection.
+     *
+     * @param key ignored
+     * @param p wrapped {@link PooledConnectionAndInfo} containing the
+     *          connection to validate
+     * @return true if validation suceeds
+     */
+    @Override
+    public boolean validateObject(UserPassKey key,
+            PooledObject<PooledConnectionAndInfo> p) {
+        try {
+            validateLifetime(p);
+        } catch (Exception e) {
+            return false;
+        }
+        boolean valid = false;
+        PooledConnection pconn = p.getObject().getPooledConnection();
+        if (null == _validationQuery) {
+            int timeout = _validationQueryTimeout;
+            if (timeout < 0) {
+                timeout = 0;
+            }
+            try {
+                valid = pconn.getConnection().isValid(timeout);
+            } catch (SQLException e) {
+                valid = false;
+            }
+        } else {
+            Connection conn = null;
+            Statement stmt = null;
+            ResultSet rset = null;
+            // logical Connection from the PooledConnection must be closed
+            // before another one can be requested and closing it will
+            // generate an event. Keep track so we know not to return
+            // the PooledConnection
+            validatingSet.add(pconn);
+            try {
+                conn = pconn.getConnection();
+                stmt = conn.createStatement();
+                rset = stmt.executeQuery(_validationQuery);
+                if (rset.next()) {
+                    valid = true;
+                } else {
+                    valid = false;
+                }
+                if (_rollbackAfterValidation) {
+                    conn.rollback();
+                }
+            } catch(Exception e) {
+                valid = false;
+            } finally {
+                Utils.closeQuietly(rset);
+                Utils.closeQuietly(stmt);
+                Utils.closeQuietly(conn);
+                validatingSet.remove(pconn);
+            }
+        }
+        return valid;
+    }
+
+    @Override
+    public void passivateObject(UserPassKey key,
+            PooledObject<PooledConnectionAndInfo> p) throws Exception {
+        validateLifetime(p);
+    }
+
+    @Override
+    public void activateObject(UserPassKey key,
+            PooledObject<PooledConnectionAndInfo> p) throws Exception {
+        validateLifetime(p);
+    }
+
+    // ***********************************************************************
+    // java.sql.ConnectionEventListener implementation
+    // ***********************************************************************
+
+    /**
+     * This will be called if the Connection returned by the getConnection
+     * method came from a PooledConnection, and the user calls the close()
+     * method of this connection object. What we need to do here is to
+     * release this PooledConnection from our pool...
+     */
+    @Override
+    public void connectionClosed(ConnectionEvent event) {
+        PooledConnection pc = (PooledConnection)event.getSource();
+        // if this event occurred because we were validating, or if this
+        // connection has been marked for removal, ignore it
+        // otherwise return the connection to the pool.
+        if (!validatingSet.contains(pc)) {
+            PooledConnectionAndInfo pci = pcMap.get(pc);
+            if (pci == null) {
+                throw new IllegalStateException(NO_KEY_MESSAGE);
+            }
+            try {
+                _pool.returnObject(pci.getUserPassKey(), pci);
+            } catch (Exception e) {
+                System.err.println("CLOSING DOWN CONNECTION AS IT COULD " +
+                "NOT BE RETURNED TO THE POOL");
+                pc.removeConnectionEventListener(this);
+                try {
+                    _pool.invalidateObject(pci.getUserPassKey(), pci);
+                } catch (Exception e3) {
+                    System.err.println("EXCEPTION WHILE DESTROYING OBJECT " +
+                            pci);
+                    e3.printStackTrace();
+                }
+            }
+        }
+    }
+
+    /**
+     * If a fatal error occurs, close the underlying physical connection so as
+     * not to be returned in the future
+     */
+    @Override
+    public void connectionErrorOccurred(ConnectionEvent event) {
+        PooledConnection pc = (PooledConnection)event.getSource();
+        if (null != event.getSQLException()) {
+            System.err
+                .println("CLOSING DOWN CONNECTION DUE TO INTERNAL ERROR (" +
+                         event.getSQLException() + ")");
+        }
+        pc.removeConnectionEventListener(this);
+
+        PooledConnectionAndInfo info = pcMap.get(pc);
+        if (info == null) {
+            throw new IllegalStateException(NO_KEY_MESSAGE);
+        }
+        try {
+            _pool.invalidateObject(info.getUserPassKey(), info);
+        } catch (Exception e) {
+            System.err.println("EXCEPTION WHILE DESTROYING OBJECT " + info);
+            e.printStackTrace();
+        }
+    }
+
+    // ***********************************************************************
+    // PooledConnectionManager implementation
+    // ***********************************************************************
+
+    /**
+     * Invalidates the PooledConnection in the pool.  The KeyedCPDSConnectionFactory
+     * closes the connection and pool counters are updated appropriately.
+     * Also clears any idle instances associated with the username that was used
+     * to create the PooledConnection.  Connections associated with this user
+     * are not affected and they will not be automatically closed on return to the pool.
+     */
+    @Override
+    public void invalidate(PooledConnection pc) throws SQLException {
+        PooledConnectionAndInfo info = pcMap.get(pc);
+        if (info == null) {
+            throw new IllegalStateException(NO_KEY_MESSAGE);
+        }
+        UserPassKey key = info.getUserPassKey();
+        try {
+            _pool.invalidateObject(key, info);  // Destroy and update pool counters
+            _pool.clear(key); // Remove any idle instances with this key
+        } catch (Exception ex) {
+            throw new SQLException("Error invalidating connection", ex);
+        }
+    }
+
+    /**
+     * Does nothing.  This factory does not cache user credentials.
+     */
+    @Override
+    public void setPassword(String password) {
+    }
+
+    /**
+     * Sets the maximum lifetime in milliseconds of a connection after which the
+     * connection will always fail activation, passivation and validation. A
+     * value of zero or less indicates an infinite lifetime. The default value
+     * is -1.
+     */
+    public void setMaxConnLifetimeMillis(long maxConnLifetimeMillis) {
+        this.maxConnLifetimeMillis = maxConnLifetimeMillis;
+    }
+
+    /**
+     * This implementation does not fully close the KeyedObjectPool, as
+     * this would affect all users.  Instead, it clears the pool associated
+     * with the given user.  This method is not currently used.
+     */
+    @Override
+    public void closePool(String username) throws SQLException {
+        try {
+            _pool.clear(new UserPassKey(username, null));
+        } catch (Exception ex) {
+            throw new SQLException("Error closing connection pool", ex);
+        }
+    }
+
+    private void validateLifetime(PooledObject<PooledConnectionAndInfo> p)
+            throws Exception {
+        if (maxConnLifetimeMillis > 0) {
+            long lifetime = System.currentTimeMillis() - p.getCreateTime();
+            if (lifetime > maxConnLifetimeMillis) {
+                throw new Exception(Utils.getMessage(
+                        "connectionFactory.lifetimeExceeded",
+                        Long.valueOf(lifetime),
+                        Long.valueOf(maxConnLifetimeMillis)));
+            }
+        }
+    }
+}

==================================================
PerUserPoolDataSourceFactory.java
new file mode 100644
index 0000000000..7d4719128b
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/PerUserPoolDataSource.java
@@ -0,0 +1,1088 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2.datasources;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NoSuchElementException;
+
+import javax.naming.NamingException;
+import javax.naming.Reference;
+import javax.naming.StringRefAddr;
+import javax.sql.ConnectionPoolDataSource;
+
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import org.apache.tomcat.dbcp.dbcp2.SwallowedExceptionLogger;
+import org.apache.tomcat.dbcp.pool2.ObjectPool;
+import org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool;
+
+/**
+ * <p>A pooling <code>DataSource</code> appropriate for deployment within
+ * J2EE environment.  There are many configuration options, most of which are
+ * defined in the parent class.  This datasource uses individual pools per
+ * user, and some properties can be set specifically for a given user, if the
+ * deployment environment can support initialization of mapped properties.
+ * So for example, a pool of admin or write-access Connections can be
+ * guaranteed a certain number of connections, separate from a maximum
+ * set for users with read-only connections.</p>
+ *
+ * <p>User passwords can be changed without re-initializing the datasource.
+ * When a <code>getConnection(username, password)</code> request is processed
+ * with a password that is different from those used to create connections in
+ * the pool associated with <code>username</code>, an attempt is made to create
+ * a new connection using the supplied password and if this succeeds, the
+ * existing pool is cleared and a new pool is created for connections using the
+ * new password.</p>
+ *
+ * @author John D. McNally
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class PerUserPoolDataSource extends InstanceKeyDataSource {
+
+    private static final long serialVersionUID = 7872747993848065028L;
+
+    private static final Log log =
+            LogFactory.getLog(PerUserPoolDataSource.class);
+
+    // Per user pool properties
+    private Map<String,Boolean> perUserBlockWhenExhausted = null;
+    private Map<String,String> perUserEvictionPolicyClassName = null;
+    private Map<String,Boolean> perUserLifo = null;
+    private Map<String,Integer> perUserMaxIdle = null;
+    private Map<String,Integer> perUserMaxTotal = null;
+    private Map<String,Long> perUserMaxWaitMillis = null;
+    private Map<String,Long> perUserMinEvictableIdleTimeMillis = null;
+    private Map<String,Integer> perUserMinIdle = null;
+    private Map<String,Integer> perUserNumTestsPerEvictionRun = null;
+    private Map<String,Long> perUserSoftMinEvictableIdleTimeMillis = null;
+    private Map<String,Boolean> perUserTestOnCreate = null;
+    private Map<String,Boolean> perUserTestOnBorrow = null;
+    private Map<String,Boolean> perUserTestOnReturn = null;
+    private Map<String,Boolean> perUserTestWhileIdle = null;
+    private Map<String,Long> perUserTimeBetweenEvictionRunsMillis = null;
+
+    // Per user connection properties
+    private Map<String,Boolean> perUserDefaultAutoCommit = null;
+    private Map<String,Integer> perUserDefaultTransactionIsolation = null;
+    private Map<String,Boolean> perUserDefaultReadOnly = null;
+
+    /**
+     * Map to keep track of Pools for a given user
+     */
+    private transient Map<PoolKey, PooledConnectionManager> managers =
+            new HashMap<>();
+
+    /**
+     * Default no-arg constructor for Serialization
+     */
+    public PerUserPoolDataSource() {
+    }
+
+    /**
+     * Close pool(s) being maintained by this datasource.
+     */
+    @Override
+    public void close() {
+        for (PooledConnectionManager manager : managers.values()) {
+            try {
+              ((CPDSConnectionFactory) manager).getPool().close();
+            } catch (Exception closePoolException) {
+                    //ignore and try to close others.
+            }
+        }
+        InstanceKeyDataSourceFactory.removeInstance(getInstanceKey());
+    }
+
+    // -------------------------------------------------------------------
+    // Properties
+
+    /**
+     * Gets the user specific value for
+     * {@link GenericObjectPool#getBlockWhenExhausted()} for the
+     * specified user's pool or the default if no user specific value is defined.
+     */
+    public boolean getPerUserBlockWhenExhausted(String key) {
+        Boolean value = null;
+        if (perUserBlockWhenExhausted != null) {
+            value = perUserBlockWhenExhausted.get(key);
+        }
+        if (value == null) {
+            return getDefaultBlockWhenExhausted();
+        }
+        return value.booleanValue();
+    }
+
+    /**
+     * Sets a user specific value for
+     * {@link GenericObjectPool#getBlockWhenExhausted()} for the specified
+     * user's pool.
+     */
+    public void setPerUserBlockWhenExhausted(String username,
+            Boolean value) {
+        assertInitializationAllowed();
+        if (perUserBlockWhenExhausted == null) {
+            perUserBlockWhenExhausted = new HashMap<>();
+        }
+        perUserBlockWhenExhausted.put(username, value);
+    }
+
+    void setPerUserBlockWhenExhausted(
+            Map<String,Boolean> userDefaultBlockWhenExhausted) {
+        assertInitializationAllowed();
+        if (perUserBlockWhenExhausted == null) {
+            perUserBlockWhenExhausted = new HashMap<>();
+        } else {
+            perUserBlockWhenExhausted.clear();
+        }
+        perUserBlockWhenExhausted.putAll(userDefaultBlockWhenExhausted);
+    }
+
+
+    /**
+     * Gets the user specific value for
+     * {@link GenericObjectPool#getEvictionPolicyClassName()} for the
+     * specified user's pool or the default if no user specific value is defined.
+     */
+    public String getPerUserEvictionPolicyClassName(String key) {
+        String value = null;
+        if (perUserEvictionPolicyClassName != null) {
+            value = perUserEvictionPolicyClassName.get(key);
+        }
+        if (value == null) {
+            return getDefaultEvictionPolicyClassName();
+        }
+        return value;
+    }
+
+    /**
+     * Sets a user specific value for
+     * {@link GenericObjectPool#getEvictionPolicyClassName()} for the specified
+     * user's pool.
+     */
+    public void setPerUserEvictionPolicyClassName(String username,
+            String value) {
+        assertInitializationAllowed();
+        if (perUserEvictionPolicyClassName == null) {
+            perUserEvictionPolicyClassName = new HashMap<>();
+        }
+        perUserEvictionPolicyClassName.put(username, value);
+    }
+
+    void setPerUserEvictionPolicyClassName(
+            Map<String,String> userDefaultEvictionPolicyClassName) {
+        assertInitializationAllowed();
+        if (perUserEvictionPolicyClassName == null) {
+            perUserEvictionPolicyClassName = new HashMap<>();
+        } else {
+            perUserEvictionPolicyClassName.clear();
+        }
+        perUserEvictionPolicyClassName.putAll(userDefaultEvictionPolicyClassName);
+    }
+
+
+    /**
+     * Gets the user specific value for {@link GenericObjectPool#getLifo()} for
+     * the specified user's pool or the default if no user specific value is
+     * defined.
+     */
+    public boolean getPerUserLifo(String key) {
+        Boolean value = null;
+        if (perUserLifo != null) {
+            value = perUserLifo.get(key);
+        }
+        if (value == null) {
+            return getDefaultLifo();
+        }
+        return value.booleanValue();
+    }
+
+    /**
+     * Sets a user specific value for
+     * {@link GenericObjectPool#getLifo()} for the specified
+     * user's pool.
+     */
+    public void setPerUserLifo(String username, Boolean value) {
+        assertInitializationAllowed();
+        if (perUserLifo == null) {
+            perUserLifo = new HashMap<>();
+        }
+        perUserLifo.put(username, value);
+    }
+
+    void setPerUserLifo(Map<String,Boolean> userDefaultLifo) {
+        assertInitializationAllowed();
+        if (perUserLifo == null) {
+            perUserLifo = new HashMap<>();
+        } else {
+            perUserLifo.clear();
+        }
+        perUserLifo.putAll(userDefaultLifo);
+    }
+
+
+    /**
+     * Gets the user specific value for
+     * {@link GenericObjectPool#getMaxIdle()} for the
+     * specified user's pool or the default if no user specific value is defined.
+     */
+    public int getPerUserMaxIdle(String key) {
+        Integer value = null;
+        if (perUserMaxIdle != null) {
+            value = perUserMaxIdle.get(key);
+        }
+        if (value == null) {
+            return getDefaultMaxIdle();
+        }
+        return value.intValue();
+    }
+
+    /**
+     * Sets a user specific value for
+     * {@link GenericObjectPool#getMaxIdle()} for the specified
+     * user's pool.
+     */
+    public void setPerUserMaxIdle(String username, Integer value) {
+        assertInitializationAllowed();
+        if (perUserMaxIdle == null) {
+            perUserMaxIdle = new HashMap<>();
+        }
+        perUserMaxIdle.put(username, value);
+    }
+
+    void setPerUserMaxIdle(Map<String,Integer> userDefaultMaxIdle) {
+        assertInitializationAllowed();
+        if (perUserMaxIdle == null) {
+            perUserMaxIdle = new HashMap<>();
+        } else {
+            perUserMaxIdle.clear();
+        }
+        perUserMaxIdle.putAll(userDefaultMaxIdle);
+    }
+
+
+    /**
+     * Gets the user specific value for
+     * {@link GenericObjectPool#getMaxTotal()} for the
+     * specified user's pool or the default if no user specific value is defined.
+     */
+    public int getPerUserMaxTotal(String key) {
+        Integer value = null;
+        if (perUserMaxTotal != null) {
+            value = perUserMaxTotal.get(key);
+        }
+        if (value == null) {
+            return getDefaultMaxTotal();
+        }
+        return value.intValue();
+    }
+
+    /**
+     * Sets a user specific value for
+     * {@link GenericObjectPool#getMaxTotal()} for the specified
+     * user's pool.
+     */
+    public void setPerUserMaxTotal(String username, Integer value) {
+        assertInitializationAllowed();
+        if (perUserMaxTotal == null) {
+            perUserMaxTotal = new HashMap<>();
+        }
+        perUserMaxTotal.put(username, value);
+    }
+
+    void setPerUserMaxTotal(Map<String,Integer> userDefaultMaxTotal) {
+        assertInitializationAllowed();
+        if (perUserMaxTotal == null) {
+            perUserMaxTotal = new HashMap<>();
+        } else {
+            perUserMaxTotal.clear();
+        }
+        perUserMaxTotal.putAll(userDefaultMaxTotal);
+    }
+
+
+    /**
+     * Gets the user specific value for
+     * {@link GenericObjectPool#getMaxWaitMillis()} for the
+     * specified user's pool or the default if no user specific value is defined.
+     */
+    public long getPerUserMaxWaitMillis(String key) {
+        Long value = null;
+        if (perUserMaxWaitMillis != null) {
+            value = perUserMaxWaitMillis.get(key);
+        }
+        if (value == null) {
+            return getDefaultMaxWaitMillis();
+        }
+        return value.longValue();
+    }
+
+    /**
+     * Sets a user specific value for
+     * {@link GenericObjectPool#getMaxWaitMillis()} for the specified
+     * user's pool.
+     */
+    public void setPerUserMaxWaitMillis(String username, Long value) {
+        assertInitializationAllowed();
+        if (perUserMaxWaitMillis == null) {
+            perUserMaxWaitMillis = new HashMap<>();
+        }
+        perUserMaxWaitMillis.put(username, value);
+    }
+
+    void setPerUserMaxWaitMillis(
+            Map<String,Long> userDefaultMaxWaitMillis) {
+        assertInitializationAllowed();
+        if (perUserMaxWaitMillis == null) {
+            perUserMaxWaitMillis = new HashMap<>();
+        } else {
+            perUserMaxWaitMillis.clear();
+        }
+        perUserMaxWaitMillis.putAll(userDefaultMaxWaitMillis);
+    }
+
+
+    /**
+     * Gets the user specific value for
+     * {@link GenericObjectPool#getMinEvictableIdleTimeMillis()} for the
+     * specified user's pool or the default if no user specific value is defined.
+     */
+    public long getPerUserMinEvictableIdleTimeMillis(String key) {
+        Long value = null;
+        if (perUserMinEvictableIdleTimeMillis != null) {
+            value = perUserMinEvictableIdleTimeMillis.get(key);
+        }
+        if (value == null) {
+            return getDefaultMinEvictableIdleTimeMillis();
+        }
+        return value.longValue();
+    }
+
+    /**
+     * Sets a user specific value for
+     * {@link GenericObjectPool#getMinEvictableIdleTimeMillis()} for the
+     * specified user's pool.
+     */
+    public void setPerUserMinEvictableIdleTimeMillis(String username,
+            Long value) {
+        assertInitializationAllowed();
+        if (perUserMinEvictableIdleTimeMillis == null) {
+            perUserMinEvictableIdleTimeMillis = new HashMap<>();
+        }
+        perUserMinEvictableIdleTimeMillis.put(username, value);
+    }
+
+    void setPerUserMinEvictableIdleTimeMillis(
+            Map<String,Long> userDefaultMinEvictableIdleTimeMillis) {
+        assertInitializationAllowed();
+        if (perUserMinEvictableIdleTimeMillis == null) {
+            perUserMinEvictableIdleTimeMillis = new HashMap<>();
+        } else {
+            perUserMinEvictableIdleTimeMillis.clear();
+        }
+        perUserMinEvictableIdleTimeMillis.putAll(
+                userDefaultMinEvictableIdleTimeMillis);
+    }
+
+
+    /**
+     * Gets the user specific value for
+     * {@link GenericObjectPool#getMinIdle()} for the
+     * specified user's pool or the default if no user specific value is defined.
+     */
+    public int getPerUserMinIdle(String key) {
+        Integer value = null;
+        if (perUserMinIdle != null) {
+            value = perUserMinIdle.get(key);
+        }
+        if (value == null) {
+            return getDefaultMinIdle();
+        }
+        return value.intValue();
+    }
+
+    /**
+     * Sets a user specific value for
+     * {@link GenericObjectPool#getMinIdle()} for the specified
+     * user's pool.
+     */
+    public void setPerUserMinIdle(String username, Integer value) {
+        assertInitializationAllowed();
+        if (perUserMinIdle == null) {
+            perUserMinIdle = new HashMap<>();
+        }
+        perUserMinIdle.put(username, value);
+    }
+
+    void setPerUserMinIdle(Map<String,Integer> userDefaultMinIdle) {
+        assertInitializationAllowed();
+        if (perUserMinIdle == null) {
+            perUserMinIdle = new HashMap<>();
+        } else {
+            perUserMinIdle.clear();
+        }
+        perUserMinIdle.putAll(userDefaultMinIdle);
+    }
+
+
+    /**
+     * Gets the user specific value for
+     * {@link GenericObjectPool#getNumTestsPerEvictionRun()} for the
+     * specified user's pool or the default if no user specific value is defined.
+     */
+    public int getPerUserNumTestsPerEvictionRun(String key) {
+        Integer value = null;
+        if (perUserNumTestsPerEvictionRun != null) {
+            value = perUserNumTestsPerEvictionRun.get(key);
+        }
+        if (value == null) {
+            return getDefaultNumTestsPerEvictionRun();
+        }
+        return value.intValue();
+    }
+
+    /**
+     * Sets a user specific value for
+     * {@link GenericObjectPool#getNumTestsPerEvictionRun()} for the specified
+     * user's pool.
+     */
+    public void setPerUserNumTestsPerEvictionRun(String username,
+            Integer value) {
+        assertInitializationAllowed();
+        if (perUserNumTestsPerEvictionRun == null) {
+            perUserNumTestsPerEvictionRun = new HashMap<>();
+        }
+        perUserNumTestsPerEvictionRun.put(username, value);
+    }
+
+    void setPerUserNumTestsPerEvictionRun(
+            Map<String,Integer> userDefaultNumTestsPerEvictionRun) {
+        assertInitializationAllowed();
+        if (perUserNumTestsPerEvictionRun == null) {
+            perUserNumTestsPerEvictionRun = new HashMap<>();
+        } else {
+            perUserNumTestsPerEvictionRun.clear();
+        }
+        perUserNumTestsPerEvictionRun.putAll(userDefaultNumTestsPerEvictionRun);
+    }
+
+
+    /**
+     * Gets the user specific value for
+     * {@link GenericObjectPool#getSoftMinEvictableIdleTimeMillis()} for the
+     * specified user's pool or the default if no user specific value is defined.
+     */
+    public long getPerUserSoftMinEvictableIdleTimeMillis(String key) {
+        Long value = null;
+        if (perUserSoftMinEvictableIdleTimeMillis != null) {
+            value = perUserSoftMinEvictableIdleTimeMillis.get(key);
+        }
+        if (value == null) {
+            return getDefaultSoftMinEvictableIdleTimeMillis();
+        }
+        return value.longValue();
+    }
+
+    /**
+     * Sets a user specific value for
+     * {@link GenericObjectPool#getSoftMinEvictableIdleTimeMillis()} for the
+     * specified user's pool.
+     */
+    public void setPerUserSoftMinEvictableIdleTimeMillis(String username,
+            Long value) {
+        assertInitializationAllowed();
+        if (perUserSoftMinEvictableIdleTimeMillis == null) {
+            perUserSoftMinEvictableIdleTimeMillis = new HashMap<>();
+        }
+        perUserSoftMinEvictableIdleTimeMillis.put(username, value);
+    }
+
+    void setPerUserSoftMinEvictableIdleTimeMillis(
+            Map<String,Long> userDefaultSoftMinEvictableIdleTimeMillis) {
+        assertInitializationAllowed();
+        if (perUserSoftMinEvictableIdleTimeMillis == null) {
+            perUserSoftMinEvictableIdleTimeMillis = new HashMap<>();
+        } else {
+            perUserSoftMinEvictableIdleTimeMillis.clear();
+        }
+        perUserSoftMinEvictableIdleTimeMillis.putAll(userDefaultSoftMinEvictableIdleTimeMillis);
+    }
+
+
+    /**
+     * Gets the user specific value for
+     * {@link GenericObjectPool#getTestOnCreate()} for the
+     * specified user's pool or the default if no user specific value is defined.
+     */
+    public boolean getPerUserTestOnCreate(String key) {
+        Boolean value = null;
+        if (perUserTestOnCreate != null) {
+            value = perUserTestOnCreate.get(key);
+        }
+        if (value == null) {
+            return getDefaultTestOnCreate();
+        }
+        return value.booleanValue();
+    }
+
+    /**
+     * Sets a user specific value for
+     * {@link GenericObjectPool#getTestOnCreate()} for the specified
+     * user's pool.
+     */
+    public void setPerUserTestOnCreate(String username, Boolean value) {
+        assertInitializationAllowed();
+        if (perUserTestOnCreate == null) {
+            perUserTestOnCreate = new HashMap<>();
+        }
+        perUserTestOnCreate.put(username, value);
+    }
+
+    void setPerUserTestOnCreate(Map<String,Boolean> userDefaultTestOnCreate) {
+        assertInitializationAllowed();
+        if (perUserTestOnCreate == null) {
+            perUserTestOnCreate = new HashMap<>();
+        } else {
+            perUserTestOnCreate.clear();
+        }
+        perUserTestOnCreate.putAll(userDefaultTestOnCreate);
+    }
+
+
+    /**
+     * Gets the user specific value for
+     * {@link GenericObjectPool#getTestOnBorrow()} for the
+     * specified user's pool or the default if no user specific value is defined.
+     */
+    public boolean getPerUserTestOnBorrow(String key) {
+        Boolean value = null;
+        if (perUserTestOnBorrow != null) {
+            value = perUserTestOnBorrow.get(key);
+        }
+        if (value == null) {
+            return getDefaultTestOnBorrow();
+        }
+        return value.booleanValue();
+    }
+
+    /**
+     * Sets a user specific value for
+     * {@link GenericObjectPool#getTestOnBorrow()} for the specified
+     * user's pool.
+     */
+    public void setPerUserTestOnBorrow(String username, Boolean value) {
+        assertInitializationAllowed();
+        if (perUserTestOnBorrow == null) {
+            perUserTestOnBorrow = new HashMap<>();
+        }
+        perUserTestOnBorrow.put(username, value);
+    }
+
+    void setPerUserTestOnBorrow(Map<String,Boolean> userDefaultTestOnBorrow) {
+        assertInitializationAllowed();
+        if (perUserTestOnBorrow == null) {
+            perUserTestOnBorrow = new HashMap<>();
+        } else {
+            perUserTestOnBorrow.clear();
+        }
+        perUserTestOnBorrow.putAll(userDefaultTestOnBorrow);
+    }
+
+
+    /**
+     * Gets the user specific value for
+     * {@link GenericObjectPool#getTestOnReturn()} for the
+     * specified user's pool or the default if no user specific value is defined.
+     */
+    public boolean getPerUserTestOnReturn(String key) {
+        Boolean value = null;
+        if (perUserTestOnReturn != null) {
+            value = perUserTestOnReturn.get(key);
+        }
+        if (value == null) {
+            return getDefaultTestOnReturn();
+        }
+        return value.booleanValue();
+    }
+
+    /**
+     * Sets a user specific value for
+     * {@link GenericObjectPool#getTestOnReturn()} for the specified
+     * user's pool.
+     */
+    public void setPerUserTestOnReturn(String username, Boolean value) {
+        assertInitializationAllowed();
+        if (perUserTestOnReturn == null) {
+            perUserTestOnReturn = new HashMap<>();
+        }
+        perUserTestOnReturn.put(username, value);
+    }
+
+    void setPerUserTestOnReturn(
+            Map<String,Boolean> userDefaultTestOnReturn) {
+        assertInitializationAllowed();
+        if (perUserTestOnReturn == null) {
+            perUserTestOnReturn = new HashMap<>();
+        } else {
+            perUserTestOnReturn.clear();
+        }
+        perUserTestOnReturn.putAll(userDefaultTestOnReturn);
+    }
+
+
+    /**
+     * Gets the user specific value for
+     * {@link GenericObjectPool#getTestWhileIdle()} for the
+     * specified user's pool or the default if no user specific value is defined.
+     */
+    public boolean getPerUserTestWhileIdle(String key) {
+        Boolean value = null;
+        if (perUserTestWhileIdle != null) {
+            value = perUserTestWhileIdle.get(key);
+        }
+        if (value == null) {
+            return getDefaultTestWhileIdle();
+        }
+        return value.booleanValue();
+    }
+
+    /**
+     * Sets a user specific value for
+     * {@link GenericObjectPool#getTestWhileIdle()} for the specified
+     * user's pool.
+     */
+    public void setPerUserTestWhileIdle(String username, Boolean value) {
+        assertInitializationAllowed();
+        if (perUserTestWhileIdle == null) {
+            perUserTestWhileIdle = new HashMap<>();
+        }
+        perUserTestWhileIdle.put(username, value);
+    }
+
+    void setPerUserTestWhileIdle(
+            Map<String,Boolean> userDefaultTestWhileIdle) {
+        assertInitializationAllowed();
+        if (perUserTestWhileIdle == null) {
+            perUserTestWhileIdle = new HashMap<>();
+        } else {
+            perUserTestWhileIdle.clear();
+        }
+        perUserTestWhileIdle.putAll(userDefaultTestWhileIdle);
+    }
+
+
+    /**
+     * Gets the user specific value for
+     * {@link GenericObjectPool#getTimeBetweenEvictionRunsMillis()} for the
+     * specified user's pool or the default if no user specific value is defined.
+     */
+    public long getPerUserTimeBetweenEvictionRunsMillis(String key) {
+        Long value = null;
+        if (perUserTimeBetweenEvictionRunsMillis != null) {
+            value = perUserTimeBetweenEvictionRunsMillis.get(key);
+        }
+        if (value == null) {
+            return getDefaultTimeBetweenEvictionRunsMillis();
+        }
+        return value.longValue();
+    }
+
+    /**
+     * Sets a user specific value for
+     * {@link GenericObjectPool#getTimeBetweenEvictionRunsMillis ()} for the specified
+     * user's pool.
+     */
+    public void setPerUserTimeBetweenEvictionRunsMillis(String username,
+            Long value) {
+        assertInitializationAllowed();
+        if (perUserTimeBetweenEvictionRunsMillis == null) {
+            perUserTimeBetweenEvictionRunsMillis = new HashMap<>();
+        }
+        perUserTimeBetweenEvictionRunsMillis.put(username, value);
+    }
+
+    void setPerUserTimeBetweenEvictionRunsMillis(
+            Map<String,Long> userDefaultTimeBetweenEvictionRunsMillis ) {
+        assertInitializationAllowed();
+        if (perUserTimeBetweenEvictionRunsMillis == null) {
+            perUserTimeBetweenEvictionRunsMillis = new HashMap<>();
+        } else {
+            perUserTimeBetweenEvictionRunsMillis.clear();
+        }
+        perUserTimeBetweenEvictionRunsMillis.putAll(
+                userDefaultTimeBetweenEvictionRunsMillis );
+    }
+
+
+    /**
+     * Gets the user specific default value for
+     * {@link Connection#setAutoCommit(boolean)} for the specified user's pool.
+     */
+    public Boolean getPerUserDefaultAutoCommit(String key) {
+        Boolean value = null;
+        if (perUserDefaultAutoCommit != null) {
+            value = perUserDefaultAutoCommit.get(key);
+        }
+        return value;
+    }
+
+    /**
+     * Sets a user specific default value for
+     * {@link Connection#setAutoCommit(boolean)} for the specified user's pool.
+     */
+    public void setPerUserDefaultAutoCommit(String username, Boolean value) {
+        assertInitializationAllowed();
+        if (perUserDefaultAutoCommit == null) {
+            perUserDefaultAutoCommit = new HashMap<>();
+        }
+        perUserDefaultAutoCommit.put(username, value);
+    }
+
+    void setPerUserDefaultAutoCommit(Map<String,Boolean> userDefaultAutoCommit) {
+        assertInitializationAllowed();
+        if (perUserDefaultAutoCommit == null) {
+            perUserDefaultAutoCommit = new HashMap<>();
+        } else {
+            perUserDefaultAutoCommit.clear();
+        }
+        perUserDefaultAutoCommit.putAll(userDefaultAutoCommit);
+    }
+
+
+    /**
+     * Gets the user specific default value for
+     * {@link Connection#setReadOnly(boolean)} for the specified user's pool.
+     */
+    public Boolean getPerUserDefaultReadOnly(String key) {
+        Boolean value = null;
+        if (perUserDefaultReadOnly != null) {
+            value = perUserDefaultReadOnly.get(key);
+        }
+        return value;
+    }
+
+    /**
+     * Sets a user specific default value for
+     * {@link Connection#setReadOnly(boolean)} for the specified user's pool.
+     */
+    public void setPerUserDefaultReadOnly(String username, Boolean value) {
+        assertInitializationAllowed();
+        if (perUserDefaultReadOnly == null) {
+            perUserDefaultReadOnly = new HashMap<>();
+        }
+        perUserDefaultReadOnly.put(username, value);
+    }
+
+    void setPerUserDefaultReadOnly(Map<String,Boolean> userDefaultReadOnly) {
+        assertInitializationAllowed();
+        if (perUserDefaultReadOnly == null) {
+            perUserDefaultReadOnly = new HashMap<>();
+        } else {
+            perUserDefaultReadOnly.clear();
+        }
+        perUserDefaultReadOnly.putAll(userDefaultReadOnly);
+    }
+
+
+    /**
+     * Gets the user specific default value for
+     * {@link Connection#setTransactionIsolation(int)} for the specified user's pool.
+     */
+    public Integer getPerUserDefaultTransactionIsolation(String key) {
+        Integer value = null;
+        if (perUserDefaultTransactionIsolation != null) {
+            value = perUserDefaultTransactionIsolation.get(key);
+        }
+        return value;
+    }
+
+    /**
+     * Sets a user specific default value for
+     * {@link Connection#setTransactionIsolation(int)} for the specified user's pool.
+     */
+    public void setPerUserDefaultTransactionIsolation(String username,
+            Integer value) {
+        assertInitializationAllowed();
+        if (perUserDefaultTransactionIsolation == null) {
+            perUserDefaultTransactionIsolation = new HashMap<>();
+        }
+        perUserDefaultTransactionIsolation.put(username, value);
+    }
+
+    void setPerUserDefaultTransactionIsolation(
+            Map<String,Integer> userDefaultTransactionIsolation) {
+        assertInitializationAllowed();
+        if (perUserDefaultTransactionIsolation == null) {
+            perUserDefaultTransactionIsolation = new HashMap<>();
+        } else {
+            perUserDefaultTransactionIsolation.clear();
+        }
+        perUserDefaultTransactionIsolation.putAll(userDefaultTransactionIsolation);
+    }
+
+
+    // ----------------------------------------------------------------------
+    // Instrumentation Methods
+
+    /**
+     * Get the number of active connections in the default pool.
+     */
+    public int getNumActive() {
+        return getNumActive(null);
+    }
+
+    /**
+     * Get the number of active connections in the pool for a given user.
+     */
+    public int getNumActive(String username) {
+        ObjectPool<PooledConnectionAndInfo> pool =
+            getPool(getPoolKey(username));
+        return pool == null ? 0 : pool.getNumActive();
+    }
+
+    /**
+     * Get the number of idle connections in the default pool.
+     */
+    public int getNumIdle() {
+        return getNumIdle(null);
+    }
+
+    /**
+     * Get the number of idle connections in the pool for a given user.
+     */
+    public int getNumIdle(String username) {
+        ObjectPool<PooledConnectionAndInfo> pool =
+            getPool(getPoolKey(username));
+        return pool == null ? 0 : pool.getNumIdle();
+    }
+
+
+    // ----------------------------------------------------------------------
+    // Inherited abstract methods
+
+    @Override
+    protected PooledConnectionAndInfo
+        getPooledConnectionAndInfo(String username, String password)
+        throws SQLException {
+
+        final PoolKey key = getPoolKey(username);
+        ObjectPool<PooledConnectionAndInfo> pool;
+        PooledConnectionManager manager;
+        synchronized(this) {
+            manager = managers.get(key);
+            if (manager == null) {
+                try {
+                    registerPool(username, password);
+                    manager = managers.get(key);
+                } catch (NamingException e) {
+                    throw new SQLException("RegisterPool failed", e);
+                }
+            }
+            pool = ((CPDSConnectionFactory) manager).getPool();
+        }
+
+        PooledConnectionAndInfo info = null;
+        try {
+            info = pool.borrowObject();
+        }
+        catch (NoSuchElementException ex) {
+            throw new SQLException(
+                    "Could not retrieve connection info from pool", ex);
+        }
+        catch (Exception e) {
+            // See if failure is due to CPDSConnectionFactory authentication failure
+            try {
+                testCPDS(username, password);
+            } catch (Exception ex) {
+                throw new SQLException(
+                        "Could not retrieve connection info from pool", ex);
+            }
+            // New password works, so kill the old pool, create a new one, and borrow
+            manager.closePool(username);
+            synchronized (this) {
+                managers.remove(key);
+            }
+            try {
+                registerPool(username, password);
+                pool = getPool(key);
+            } catch (NamingException ne) {
+                throw new SQLException("RegisterPool failed", ne);
+            }
+            try {
+                info = pool.borrowObject();
+            } catch (Exception ex) {
+                throw new SQLException(
+                        "Could not retrieve connection info from pool", ex);
+            }
+        }
+        return info;
+    }
+
+    @Override
+    protected void setupDefaults(Connection con, String username)
+        throws SQLException {
+        Boolean defaultAutoCommit = isDefaultAutoCommit();
+        if (username != null) {
+            Boolean userMax = getPerUserDefaultAutoCommit(username);
+            if (userMax != null) {
+                defaultAutoCommit = userMax;
+            }
+        }
+
+        Boolean defaultReadOnly = isDefaultReadOnly();
+        if (username != null) {
+            Boolean userMax = getPerUserDefaultReadOnly(username);
+            if (userMax != null) {
+                defaultReadOnly = userMax;
+            }
+        }
+
+        int defaultTransactionIsolation = getDefaultTransactionIsolation();
+        if (username != null) {
+            Integer userMax = getPerUserDefaultTransactionIsolation(username);
+            if (userMax != null) {
+                defaultTransactionIsolation = userMax.intValue();
+            }
+        }
+
+        if (defaultAutoCommit != null &&
+                con.getAutoCommit() != defaultAutoCommit.booleanValue()) {
+            con.setAutoCommit(defaultAutoCommit.booleanValue());
+        }
+
+        if (defaultTransactionIsolation != UNKNOWN_TRANSACTIONISOLATION) {
+            con.setTransactionIsolation(defaultTransactionIsolation);
+        }
+
+        if (defaultReadOnly != null &&
+                con.isReadOnly() != defaultReadOnly.booleanValue()) {
+            con.setReadOnly(defaultReadOnly.booleanValue());
+        }
+    }
+
+    @Override
+    protected PooledConnectionManager getConnectionManager(UserPassKey upkey) {
+        return managers.get(getPoolKey(upkey.getUsername()));
+    }
+
+    /**
+     * Returns a <code>PerUserPoolDataSource</code> {@link Reference}.
+     */
+    @Override
+    public Reference getReference() throws NamingException {
+        Reference ref = new Reference(getClass().getName(),
+                PerUserPoolDataSourceFactory.class.getName(), null);
+        ref.add(new StringRefAddr("instanceKey", getInstanceKey()));
+        return ref;
+    }
+
+    /**
+     * Create a pool key from the provided parameters.
+     *
+     * @param username  User name
+     * @return  The pool key
+     */
+    private PoolKey getPoolKey(String username) {
+        return new PoolKey(getDataSourceName(), username);
+    }
+
+    private synchronized void registerPool(String username, String password)
+            throws NamingException, SQLException {
+
+        ConnectionPoolDataSource cpds = testCPDS(username, password);
+
+        // Set up the factory we will use (passing the pool associates
+        // the factory with the pool, so we do not have to do so
+        // explicitly)
+        CPDSConnectionFactory factory = new CPDSConnectionFactory(cpds,
+                getValidationQuery(), getValidationQueryTimeout(),
+                isRollbackAfterValidation(), username, password);
+        factory.setMaxConnLifetimeMillis(getMaxConnLifetimeMillis());
+
+        // Create an object pool to contain our PooledConnections
+        GenericObjectPool<PooledConnectionAndInfo> pool =
+                new GenericObjectPool<>(factory);
+        factory.setPool(pool);
+        pool.setBlockWhenExhausted(getPerUserBlockWhenExhausted(username));
+        pool.setEvictionPolicyClassName(
+                getPerUserEvictionPolicyClassName(username));
+        pool.setLifo(getPerUserLifo(username));
+        pool.setMaxIdle(getPerUserMaxIdle(username));
+        pool.setMaxTotal(getPerUserMaxTotal(username));
+        pool.setMaxWaitMillis(getPerUserMaxWaitMillis(username));
+        pool.setMinEvictableIdleTimeMillis(
+                getPerUserMinEvictableIdleTimeMillis(username));
+        pool.setMinIdle(getPerUserMinIdle(username));
+        pool.setNumTestsPerEvictionRun(
+                getPerUserNumTestsPerEvictionRun(username));
+        pool.setSoftMinEvictableIdleTimeMillis(
+                getPerUserSoftMinEvictableIdleTimeMillis(username));
+        pool.setTestOnCreate(getPerUserTestOnCreate(username));
+        pool.setTestOnBorrow(getPerUserTestOnBorrow(username));
+        pool.setTestOnReturn(getPerUserTestOnReturn(username));
+        pool.setTestWhileIdle(getPerUserTestWhileIdle(username));
+        pool.setTimeBetweenEvictionRunsMillis(
+                getPerUserTimeBetweenEvictionRunsMillis(username));
+
+        pool.setSwallowedExceptionListener(new SwallowedExceptionLogger(log));
+
+        Object old = managers.put(getPoolKey(username), factory);
+        if (old != null) {
+            throw new IllegalStateException("Pool already contains an entry for this user/password: " + username);
+        }
+    }
+
+    /**
+     * Supports Serialization interface.
+     *
+     * @param in a <code>java.io.ObjectInputStream</code> value
+     * @exception IOException if an error occurs
+     * @exception ClassNotFoundException if an error occurs
+     */
+    private void readObject(ObjectInputStream in)
+        throws IOException, ClassNotFoundException {
+        try
+        {
+            in.defaultReadObject();
+            PerUserPoolDataSource oldDS = (PerUserPoolDataSource)
+                new PerUserPoolDataSourceFactory()
+                    .getObjectInstance(getReference(), null, null, null);
+            this.managers = oldDS.managers;
+        }
+        catch (NamingException e)
+        {
+            throw new IOException("NamingException: " + e);
+        }
+    }
+
+    /**
+     * Returns the object pool associated with the given PoolKey.
+     *
+     * @param key PoolKey identifying the pool
+     * @return the GenericObjectPool pooling connections for the username and datasource
+     * specified by the PoolKey
+     */
+    private ObjectPool<PooledConnectionAndInfo> getPool(PoolKey key) {
+        CPDSConnectionFactory mgr = (CPDSConnectionFactory) managers.get(key);
+        return mgr == null ? null : mgr.getPool();
+    }
+}

==================================================
PoolKey.java
new file mode 100644
index 0000000000..3f80881a71
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/PerUserPoolDataSourceFactory.java
@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2.datasources;
+
+import java.io.IOException;
+import java.util.Map;
+
+import javax.naming.RefAddr;
+import javax.naming.Reference;
+
+/**
+ * A JNDI ObjectFactory which creates <code>SharedPoolDataSource</code>s
+ *
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class PerUserPoolDataSourceFactory
+    extends InstanceKeyDataSourceFactory
+{
+    private static final String PER_USER_POOL_CLASSNAME =
+        PerUserPoolDataSource.class.getName();
+
+    @Override
+    protected boolean isCorrectClass(String className) {
+        return PER_USER_POOL_CLASSNAME.equals(className);
+    }
+
+    @SuppressWarnings("unchecked") // Avoid warnings on deserialization
+    @Override
+    protected InstanceKeyDataSource getNewInstance(Reference ref)
+        throws IOException, ClassNotFoundException {
+        PerUserPoolDataSource pupds =  new PerUserPoolDataSource();
+        RefAddr ra = ref.get("defaultMaxTotal");
+        if (ra != null && ra.getContent() != null) {
+            pupds.setDefaultMaxTotal(
+                Integer.parseInt(ra.getContent().toString()));
+        }
+
+        ra = ref.get("defaultMaxIdle");
+        if (ra != null && ra.getContent() != null) {
+            pupds.setDefaultMaxIdle(
+                Integer.parseInt(ra.getContent().toString()));
+        }
+
+        ra = ref.get("defaultMaxWaitMillis");
+        if (ra != null && ra.getContent() != null) {
+            pupds.setDefaultMaxWaitMillis(
+                Integer.parseInt(ra.getContent().toString()));
+        }
+
+        ra = ref.get("perUserDefaultAutoCommit");
+        if (ra != null  && ra.getContent() != null) {
+            byte[] serialized = (byte[]) ra.getContent();
+            pupds.setPerUserDefaultAutoCommit(
+                    (Map<String,Boolean>) deserialize(serialized));
+        }
+
+        ra = ref.get("perUserDefaultTransactionIsolation");
+        if (ra != null  && ra.getContent() != null) {
+            byte[] serialized = (byte[]) ra.getContent();
+            pupds.setPerUserDefaultTransactionIsolation(
+                    (Map<String,Integer>) deserialize(serialized));
+        }
+
+        ra = ref.get("perUserMaxTotal");
+        if (ra != null  && ra.getContent() != null) {
+            byte[] serialized = (byte[]) ra.getContent();
+            pupds.setPerUserMaxTotal(
+                    (Map<String,Integer>) deserialize(serialized));
+        }
+
+        ra = ref.get("perUserMaxIdle");
+        if (ra != null  && ra.getContent() != null) {
+            byte[] serialized = (byte[]) ra.getContent();
+            pupds.setPerUserMaxIdle(
+                    (Map<String,Integer>) deserialize(serialized));
+        }
+
+        ra = ref.get("perUserMaxWaitMillis");
+        if (ra != null  && ra.getContent() != null) {
+            byte[] serialized = (byte[]) ra.getContent();
+            pupds.setPerUserMaxWaitMillis(
+                    (Map<String,Long>) deserialize(serialized));
+        }
+
+        ra = ref.get("perUserDefaultReadOnly");
+        if (ra != null  && ra.getContent() != null) {
+            byte[] serialized = (byte[]) ra.getContent();
+            pupds.setPerUserDefaultReadOnly(
+                    (Map<String,Boolean>) deserialize(serialized));
+        }
+        return pupds;
+    }
+}
+

==================================================
PooledConnectionAndInfo.java
new file mode 100644
index 0000000000..e2d9632dc0
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/PoolKey.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2.datasources;
+
+import java.io.Serializable;
+
+/**
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+class PoolKey implements Serializable {
+    private static final long serialVersionUID = 2252771047542484533L;
+
+    private final String datasourceName;
+    private final String username;
+
+    PoolKey(String datasourceName, String username) {
+        this.datasourceName = datasourceName;
+        this.username = username;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj instanceof PoolKey) {
+            PoolKey pk = (PoolKey)obj;
+            return (null == datasourceName ? null == pk.datasourceName : datasourceName.equals(pk.datasourceName)) &&
+                (null == username ? null == pk.username : username.equals(pk.username));
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        int h = 0;
+        if (datasourceName != null) {
+            h += datasourceName.hashCode();
+        }
+        if (username != null) {
+            h = 29 * h + username.hashCode();
+        }
+        return h;
+    }
+
+    @Override
+    public String toString() {
+        StringBuffer sb = new StringBuffer(50);
+        sb.append("PoolKey(");
+        sb.append(username).append(", ").append(datasourceName);
+        sb.append(')');
+        return sb.toString();
+    }
+}

==================================================
PooledConnectionManager.java
new file mode 100644
index 0000000000..2f4fd6db8f
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/PooledConnectionAndInfo.java
@@ -0,0 +1,65 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2.datasources;
+
+import javax.sql.PooledConnection;
+
+/**
+ * Immutable poolable object holding a PooledConnection along with the username and password
+ * used to create the connection.
+ *
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+final class PooledConnectionAndInfo {
+    private final PooledConnection pooledConnection;
+    private final String password;
+    private final String username;
+    private final UserPassKey upkey;
+
+    PooledConnectionAndInfo(PooledConnection pc, String username, String password) {
+        this.pooledConnection = pc;
+        this.username = username;
+        this.password = password;
+        upkey = new UserPassKey(username, password);
+    }
+
+    PooledConnection getPooledConnection() {
+        return pooledConnection;
+    }
+
+    UserPassKey getUserPassKey() {
+        return upkey;
+    }
+
+    /**
+     * Get the value of password.
+     * @return value of password.
+     */
+    String getPassword() {
+        return password;
+    }
+
+    /**
+     * Get the value of username.
+     * @return value of username.
+     */
+    String getUsername() {
+        return username;
+    }
+}

==================================================
SharedPoolDataSource.java
new file mode 100644
index 0000000000..a5e8b5c991
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/PooledConnectionManager.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2.datasources;
+
+import java.sql.SQLException;
+
+import javax.sql.PooledConnection;
+
+/**
+ * Methods to manage PoolableConnections and the connection pools that source them.
+ *
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+interface PooledConnectionManager {
+    /**
+     * Close the PooledConnection and remove it from the connection pool
+     * to which it belongs, adjusting pool counters.
+     *
+     * @param pc PooledConnection to be invalidated
+     * @throws SQLException if an SQL error occurs closing the connection
+     */
+    void invalidate(PooledConnection pc) throws SQLException;
+
+    /**
+     * Sets the databsase password used when creating connections.
+     *
+     * @param password password used when authenticating to the database
+     */
+    void setPassword(String password);
+
+
+    /**
+     * Closes the connection pool associated with the given user.
+     *
+     * @param username user name
+     * @throws SQLException if an error occurs closing idle connections in the pool
+     */
+    void closePool(String username) throws SQLException;
+
+}

==================================================
SharedPoolDataSourceFactory.java
new file mode 100644
index 0000000000..23dac0648f
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/SharedPoolDataSource.java
@@ -0,0 +1,246 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2.datasources;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.sql.Connection;
+import java.sql.SQLException;
+
+import javax.naming.NamingException;
+import javax.naming.Reference;
+import javax.naming.StringRefAddr;
+import javax.sql.ConnectionPoolDataSource;
+
+import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
+import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool;
+import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPoolConfig;
+
+/**
+ * <p>A pooling <code>DataSource</code> appropriate for deployment within
+ * J2EE environment.  There are many configuration options, most of which are
+ * defined in the parent class. All users (based on username) share a single
+ * maximum number of Connections in this datasource.</p>
+ *
+ * <p>User passwords can be changed without re-initializing the datasource.
+ * When a <code>getConnection(username, password)</code> request is processed
+ * with a password that is different from those used to create connections in the
+ * pool associated with <code>username</code>, an attempt is made to create a
+ * new connection using the supplied password and if this succeeds, idle connections
+ * created using the old password are destroyed and new connections are created
+ * using the new password.</p>
+ *
+ * @author John D. McNally
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class SharedPoolDataSource extends InstanceKeyDataSource {
+
+    private static final long serialVersionUID = -1458539734480586454L;
+
+    // Pool properties
+    private int maxTotal = GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL;
+
+
+    private transient KeyedObjectPool<UserPassKey,PooledConnectionAndInfo> pool = null;
+    private transient KeyedCPDSConnectionFactory factory = null;
+
+    /**
+     * Default no-arg constructor for Serialization
+     */
+    public SharedPoolDataSource() {
+    }
+
+    /**
+     * Close pool being maintained by this datasource.
+     */
+    @Override
+    public void close() throws Exception {
+        if (pool != null) {
+            pool.close();
+        }
+        InstanceKeyDataSourceFactory.removeInstance(getInstanceKey());
+    }
+
+
+    // -------------------------------------------------------------------
+    // Properties
+
+    /**
+     * Set {@link GenericKeyedObjectPool#getMaxTotal()} for this pool.
+     */
+    public int getMaxTotal() {
+        return this.maxTotal;
+    }
+
+    /**
+     * Get {@link GenericKeyedObjectPool#getMaxTotal()} for this pool.
+     */
+    public void setMaxTotal(int maxTotal) {
+        assertInitializationAllowed();
+        this.maxTotal = maxTotal;
+    }
+
+
+    // ----------------------------------------------------------------------
+    // Instrumentation Methods
+
+    /**
+     * Get the number of active connections in the pool.
+     */
+    public int getNumActive() {
+        return pool == null ? 0 : pool.getNumActive();
+    }
+
+    /**
+     * Get the number of idle connections in the pool.
+     */
+    public int getNumIdle() {
+        return pool == null ? 0 : pool.getNumIdle();
+    }
+
+    // ----------------------------------------------------------------------
+    // Inherited abstract methods
+
+    @Override
+    protected PooledConnectionAndInfo
+        getPooledConnectionAndInfo(String username, String password)
+        throws SQLException {
+
+        synchronized(this) {
+            if (pool == null) {
+                try {
+                    registerPool(username, password);
+                } catch (NamingException e) {
+                    throw new SQLException("RegisterPool failed", e);
+                }
+            }
+        }
+
+        PooledConnectionAndInfo info = null;
+
+        UserPassKey key = new UserPassKey(username, password);
+
+        try {
+            info = pool.borrowObject(key);
+        }
+        catch (Exception e) {
+            throw new SQLException(
+                    "Could not retrieve connection info from pool", e);
+        }
+        return info;
+    }
+
+    @Override
+    protected PooledConnectionManager getConnectionManager(UserPassKey upkey)  {
+        return factory;
+    }
+
+    /**
+     * Returns a <code>SharedPoolDataSource</code> {@link Reference}.
+     */
+    @Override
+    public Reference getReference() throws NamingException {
+        Reference ref = new Reference(getClass().getName(),
+            SharedPoolDataSourceFactory.class.getName(), null);
+        ref.add(new StringRefAddr("instanceKey", getInstanceKey()));
+        return ref;
+    }
+
+    private void registerPool(String username, String password)
+            throws NamingException, SQLException {
+
+        ConnectionPoolDataSource cpds = testCPDS(username, password);
+
+        // Create an object pool to contain our PooledConnections
+        factory = new KeyedCPDSConnectionFactory(cpds, getValidationQuery(),
+                getValidationQueryTimeout(), isRollbackAfterValidation());
+        factory.setMaxConnLifetimeMillis(getMaxConnLifetimeMillis());
+
+        GenericKeyedObjectPoolConfig config =
+                new GenericKeyedObjectPoolConfig();
+        config.setBlockWhenExhausted(getDefaultBlockWhenExhausted());
+        config.setEvictionPolicyClassName(getDefaultEvictionPolicyClassName());
+        config.setLifo(getDefaultLifo());
+        config.setMaxIdlePerKey(getDefaultMaxIdle());
+        config.setMaxTotal(getMaxTotal());
+        config.setMaxTotalPerKey(getDefaultMaxTotal());
+        config.setMaxWaitMillis(getDefaultMaxWaitMillis());
+        config.setMinEvictableIdleTimeMillis(
+                getDefaultMinEvictableIdleTimeMillis());
+        config.setMinIdlePerKey(getDefaultMinIdle());
+        config.setNumTestsPerEvictionRun(getDefaultNumTestsPerEvictionRun());
+        config.setSoftMinEvictableIdleTimeMillis(
+                getDefaultSoftMinEvictableIdleTimeMillis());
+        config.setTestOnCreate(getDefaultTestOnCreate());
+        config.setTestOnBorrow(getDefaultTestOnBorrow());
+        config.setTestOnReturn(getDefaultTestOnReturn());
+        config.setTestWhileIdle(getDefaultTestWhileIdle());
+        config.setTimeBetweenEvictionRunsMillis(
+                getDefaultTimeBetweenEvictionRunsMillis());
+
+        KeyedObjectPool<UserPassKey,PooledConnectionAndInfo> tmpPool =
+                new GenericKeyedObjectPool<>(factory, config);
+        factory.setPool(tmpPool);
+        pool = tmpPool;
+    }
+
+    @Override
+    protected void setupDefaults(Connection con, String username) throws SQLException {
+        Boolean defaultAutoCommit = isDefaultAutoCommit();
+        if (defaultAutoCommit != null &&
+                con.getAutoCommit() != defaultAutoCommit.booleanValue()) {
+            con.setAutoCommit(defaultAutoCommit.booleanValue());
+        }
+
+        int defaultTransactionIsolation = getDefaultTransactionIsolation();
+        if (defaultTransactionIsolation != UNKNOWN_TRANSACTIONISOLATION) {
+            con.setTransactionIsolation(defaultTransactionIsolation);
+        }
+
+        Boolean defaultReadOnly = isDefaultReadOnly();
+        if (defaultReadOnly != null &&
+                con.isReadOnly() != defaultReadOnly.booleanValue()) {
+            con.setReadOnly(defaultReadOnly.booleanValue());
+        }
+    }
+
+    /**
+     * Supports Serialization interface.
+     *
+     * @param in a <code>java.io.ObjectInputStream</code> value
+     * @exception IOException if an error occurs
+     * @exception ClassNotFoundException if an error occurs
+     */
+    private void readObject(ObjectInputStream in)
+        throws IOException, ClassNotFoundException {
+        try
+        {
+            in.defaultReadObject();
+            SharedPoolDataSource oldDS = (SharedPoolDataSource)
+                new SharedPoolDataSourceFactory()
+                    .getObjectInstance(getReference(), null, null, null);
+            this.pool = oldDS.pool;
+        }
+        catch (NamingException e)
+        {
+            throw new IOException("NamingException: " + e);
+        }
+    }
+}
+

==================================================
UserPassKey.java
new file mode 100644
index 0000000000..a04d938bd9
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/SharedPoolDataSourceFactory.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2.datasources;
+
+import javax.naming.RefAddr;
+import javax.naming.Reference;
+
+/**
+ * A JNDI ObjectFactory which creates <code>SharedPoolDataSource</code>s
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+public class SharedPoolDataSourceFactory
+    extends InstanceKeyDataSourceFactory
+{
+    private static final String SHARED_POOL_CLASSNAME =
+        SharedPoolDataSource.class.getName();
+
+    @Override
+    protected boolean isCorrectClass(String className) {
+        return SHARED_POOL_CLASSNAME.equals(className);
+    }
+
+    @Override
+    protected InstanceKeyDataSource getNewInstance(Reference ref) {
+        SharedPoolDataSource spds = new SharedPoolDataSource();
+        RefAddr ra = ref.get("maxTotal");
+        if (ra != null && ra.getContent() != null) {
+            spds.setMaxTotal(
+                Integer.parseInt(ra.getContent().toString()));
+        }
+        return spds;
+    }
+}
+

==================================================
package-info.java
new file mode 100644
index 0000000000..f086922ebb
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/UserPassKey.java
@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2.datasources;
+
+import java.io.Serializable;
+
+/**
+ * <p>Holds a username, password pair.  Serves as a poolable object key for the KeyedObjectPool
+ * backing a SharedPoolDataSource.  Two instances with the same username are considered equal.
+ * This ensures that there will be only one keyed pool for each user in the pool.  The password
+ * is used (along with the username) by the KeyedCPDSConnectionFactory when creating new connections.</p>
+ *
+ * <p>{@link InstanceKeyDataSource#getConnection(String, String)} validates that the password used to create
+ * a connection matches the password provided by the client.</p>
+ *
+ * @version $Revision$ $Date$
+ * @since 2.0
+ */
+class UserPassKey implements Serializable {
+    private static final long serialVersionUID = 5142970911626584817L;
+    private final String password;
+    private final String username;
+
+    UserPassKey(String username, String password) {
+        this.username = username;
+        this.password = password;
+    }
+
+    /**
+     * Get the value of password.
+     * @return value of password.
+     */
+    public String getPassword() {
+        return password;
+    }
+
+    /**
+     * Get the value of username.
+     * @return value of username.
+     */
+    public String getUsername() {
+        return username;
+    }
+
+    /**
+     * @return <code>true</code> if the username fields for both
+     * objects are equal.  Two instances with the same username
+     * but different passwords are considered equal.
+     *
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == null) {
+            return false;
+        }
+
+        if (obj == this) {
+            return true;
+        }
+
+        if (!(obj instanceof UserPassKey)) {
+            return false;
+        }
+
+        UserPassKey key = (UserPassKey) obj;
+
+        return this.username == null ?
+                key.username == null :
+                this.username.equals(key.username);
+    }
+
+    /**
+     * Returns the hash of the username.
+     */
+    @Override
+    public int hashCode() {
+        return this.username != null ?
+                this.username.hashCode() : 0;
+    }
+
+    @Override
+    public String toString() {
+        StringBuffer sb = new StringBuffer(50);
+        sb.append("UserPassKey(");
+        sb.append(username).append(", ").append(password).append(')');
+        return sb.toString();
+    }
+}

==================================================
package-info.java
new file mode 100644
index 0000000000..a07331255b
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/overview.html
@@ -0,0 +1,27 @@
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<!-- $Id$ -->
+<html>
+   <head>
+      <title>Overview of the org.apache.commons.dbcp component</title>
+   </head>
+   <body>
+      <p>
+         Commons Database Connection Pooling
+      </p>
+   </body>
+</html>

==================================================
BaseKeyedPooledObjectFactory.java
new file mode 100644
index 0000000000..41b445ce73
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/package-info.java
@@ -0,0 +1,131 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * <p>
+ *    Database Connection Pool API.
+ * </p>
+ *
+ * <b>Overview in Dialog Form</b>
+ * <p>
+ *    Q: How do I use the DBCP package?
+ * </p><p>
+ *    A: There are two primary ways to access the DBCP pool, as a
+ *    {@link java.sql.Driver Driver}, or as a {@link javax.sql.DataSource DataSource}.
+ *    You'll want to create an instance of {@link org.apache.tomcat.dbcp.dbcp2.PoolingDriver} or
+ *    {@link org.apache.tomcat.dbcp.dbcp2.PoolingDataSource}.  When using one of these
+ *    interfaces, you can just use your JDBC objects the way you normally would.
+ *    Closing a {@link java.sql.Connection} will simply return it to its pool.
+ * </p>
+ * <p>
+ *    Q: But {@link org.apache.tomcat.dbcp.dbcp2.PoolingDriver PoolingDriver} and
+ *    {@link org.apache.tomcat.dbcp.dbcp2.PoolingDataSource PoolingDataSource} both expect an
+ *    {@link org.apache.tomcat.dbcp.pool2.ObjectPool ObjectPool} as an input.  Where do I
+ *    get one of those?
+ * </p><p>
+ *    A: The {@link org.apache.tomcat.dbcp.pool2.ObjectPool ObjectPool} interface is defined
+ *    in Commons Pool. You can use one of the provided implementations such as
+ *    {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool},
+ *    {@link org.apache.tomcat.dbcp.pool2.proxy.ProxiedObjectPool ProxiedObjectPool} or
+ *    {@link org.apache.tomcat.dbcp.pool2.impl.SoftReferenceObjectPool SoftReferenceObjectPool}
+ *    or you can create your own.
+ * </p>
+ * <p>
+ *    Q: Ok, I've found an {@link org.apache.tomcat.dbcp.pool2.ObjectPool ObjectPool}
+ *    implementation that I think suits my connection pooling needs.  But it wants
+ *    a {@link org.apache.tomcat.dbcp.pool2.PooledObjectFactory PooledObjectFactory}.
+ *    What should I use for that?
+ * </p><p>
+ *    A: The DBCP package provides a class for this purpose. It's called
+ *    {@link org.apache.tomcat.dbcp.dbcp2.PoolableConnectionFactory}.
+ *    It implements the factory and lifecycle methods of
+ *    {@link org.apache.tomcat.dbcp.pool2.PooledObjectFactory}
+ *    for {@link java.sql.Connection}s.  But it doesn't create the actual database
+ *    {@link java.sql.Connection}s itself, it uses a
+ *    {@link org.apache.tomcat.dbcp.dbcp2.ConnectionFactory} for that.
+ *    The {@link org.apache.tomcat.dbcp.dbcp2.PoolableConnectionFactory} will take
+ *    {@link java.sql.Connection}s created by the {@link org.apache.tomcat.dbcp.dbcp2.ConnectionFactory}
+ *    and wrap them with classes that implement the pooling behaviour.
+ * </p><p>
+ *    Several implementations of {@link org.apache.tomcat.dbcp.dbcp2.ConnectionFactory} are
+ *    provided--one that uses {@link java.sql.DriverManager} to create connections
+ *    ({@link org.apache.tomcat.dbcp.dbcp2.DriverManagerConnectionFactory}),
+ *    one that uses a {@link java.sql.Driver} to create connections
+ *    ({@link org.apache.tomcat.dbcp.dbcp2.DriverConnectionFactory}),
+ *    one that uses a {@link javax.sql.DataSource} to create connections
+ *    ({@link org.apache.tomcat.dbcp.dbcp2.DataSourceConnectionFactory}).
+ * </p>
+ * <p>
+ *    Q: I think I'm starting to get it, but can you walk me though it again?
+ * </p><p>
+ *    A: Sure.  Let's assume you want to create a {@link javax.sql.DataSource}
+ *    that pools {@link java.sql.Connection}s.  Let's also assume that
+ *    those pooled {@link java.sql.Connection}s should be obtained from
+ *    the {@link java.sql.DriverManager}.
+ *    You'll want to create a {@link org.apache.tomcat.dbcp.dbcp2.PoolingDataSource}.
+ * </p><p>
+ *    The {@link org.apache.tomcat.dbcp.dbcp2.PoolingDataSource} uses an underlying
+ *    {@link org.apache.tomcat.dbcp.pool2.ObjectPool} to create and store its
+ *    {@link java.sql.Connection}.
+ * </p><p>
+ *    To create a {@link org.apache.tomcat.dbcp.pool2.ObjectPool}, you'll need
+ *    a {@link org.apache.tomcat.dbcp.pool2.PooledObjectFactory} that creates
+ *    the actual {@link java.sql.Connection}s.  That's what
+ *    {@link org.apache.tomcat.dbcp.dbcp2.PoolableConnectionFactory} is for.
+ * </p><p>
+ *    To create the {@link org.apache.tomcat.dbcp.dbcp2.PoolableConnectionFactory},
+ *    you'll need at least two things:
+ *    <ol>
+ *     <li>
+ * A {@link org.apache.tomcat.dbcp.dbcp2.ConnectionFactory} from which
+ * the actual database {@link java.sql.Connection}s will be obtained.
+ *     </li>
+ *     <li>
+ * An empty and factory-less {@link org.apache.tomcat.dbcp.pool2.ObjectPool}
+ * in which the {@link java.sql.Connection}s will be stored.
+ * <br></br>
+ * When you pass an {@link org.apache.tomcat.dbcp.pool2.ObjectPool} into the
+ * {@link org.apache.tomcat.dbcp.dbcp2.PoolableConnectionFactory}, it will
+ * automatically register itself as the {@link org.apache.tomcat.dbcp.pool2.PooledObjectFactory}
+ * for that pool.
+ *     </li>
+ *    </ol>
+ * </p><p>
+ *    In code, that might look like this:
+ * <pre>GenericObjectPool connectionPool = new GenericObjectPool(null);
+ * ConnectionFactory connectionFactory = new DriverManagerConnectionFactory("jdbc:some:connect:string", "username", "password");
+ * PoolableConnectionFactory poolableConnectionFactory = new PoolableConnectionFactory(connectionFactory,connectionPool,null,null,false,true);
+ * PoolingDataSource dataSource = new PoolingDataSource(connectionPool);</pre>
+ * </p><p>
+ *    To create a {@link org.apache.tomcat.dbcp.dbcp2.PoolingDriver}, we do the same thing,
+ *    except that instead of creating a {@link javax.sql.DataSource} on the last line,
+ *    we create a {@link org.apache.tomcat.dbcp.dbcp2.PoolingDriver}, and register the
+ *    <tt>connectionPool</tt> with it.  E.g.,:
+ * <pre>GenericObjectPool connectionPool = new GenericObjectPool(null);
+ * ConnectionFactory connectionFactory = new DriverManagerConnectionFactory("jdbc:some:connect:string", "username", "password");
+ * PoolableConnectionFactory poolableConnectionFactory = new PoolableConnectionFactory(connectionFactory,connectionPool,null,null,false,true);
+ * PoolingDriver driver = new PoolingDriver();
+ * driver.registerPool("example",connectionPool);</pre>
+ * </p><p>
+ *    Since the {@link org.apache.tomcat.dbcp.dbcp2.PoolingDriver} registers itself
+ *    with the {@link java.sql.DriverManager} when it is created, now you can just
+ *    go to the {@link java.sql.DriverManager} to create your {@link java.sql.Connection}s,
+ *    like you normally would:
+ * <pre>Connection conn = DriverManager.getConnection("jdbc:apache:commons:dbcp:example");</pre>
+ * </p>
+ */
+package org.apache.tomcat.dbcp.dbcp2;

==================================================
BaseObjectPool.java
new file mode 100644
index 0000000000..9c5de8bb2c
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/BaseKeyedPooledObjectFactory.java
@@ -0,0 +1,117 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2;
+
+/**
+ * A base implementation of <code>KeyedPooledObjectFactory</code>.
+ * <p>
+ * All operations defined here are essentially no-op's.
+ * </p>
+ * This class is immutable, and therefore thread-safe.
+ *
+ * @see KeyedPooledObjectFactory
+ *
+ * @param <K> The type of keys managed by this factory.
+ * @param <V> Type of element managed by this factory.
+ *
+ * @version $Revision: 1333925 $
+ *
+ * @since 2.0
+ */
+public abstract class BaseKeyedPooledObjectFactory<K,V>
+        implements KeyedPooledObjectFactory<K,V> {
+
+    /**
+     * Create an instance that can be served by the pool.
+     *
+     * @param key the key used when constructing the object
+     * @return an instance that can be served by the pool
+     *
+     * @throws Exception if there is a problem creating a new instance,
+     *    this will be propagated to the code requesting an object.
+     */
+    public abstract V create(K key)
+        throws Exception;
+
+    /**
+     * Wrap the provided instance with an implementation of
+     * {@link PooledObject}.
+     *
+     * @param value the instance to wrap
+     *
+     * @return The provided instance, wrapped by a {@link PooledObject}
+     */
+    public abstract PooledObject<V> wrap(V value);
+
+    @Override
+    public PooledObject<V> makeObject(K key) throws Exception {
+        return wrap(create(key));
+    }
+
+    /**
+     * Destroy an instance no longer needed by the pool.
+     * <p>
+     * The default implementation is a no-op.
+     *
+     * @param key the key used when selecting the instance
+     * @param p a {@code PooledObject} wrapping the the instance to be destroyed
+     */
+    @Override
+    public void destroyObject(K key, PooledObject<V> p)
+        throws Exception {
+    }
+
+    /**
+     * Ensures that the instance is safe to be returned by the pool.
+     * <p>
+     * The default implementation always returns <tt>true</tt>.
+     *
+     * @param key the key used when selecting the object
+     * @param p a {@code PooledObject} wrapping the the instance to be validated
+     * @return always <code>true</code> in the default implementation
+     */
+    @Override
+    public boolean validateObject(K key, PooledObject<V> p) {
+        return true;
+    }
+
+    /**
+     * Reinitialize an instance to be returned by the pool.
+     * <p>
+     * The default implementation is a no-op.
+     *
+     * @param key the key used when selecting the object
+     * @param p a {@code PooledObject} wrapping the the instance to be activated
+     */
+    @Override
+    public void activateObject(K key, PooledObject<V> p)
+        throws Exception {
+    }
+
+    /**
+     * Uninitialize an instance to be returned to the idle object pool.
+     * <p>
+     * The default implementation is a no-op.
+     *
+     * @param key the key used when selecting the object
+     * @param p a {@code PooledObject} wrapping the the instance to be passivated
+     */
+    @Override
+    public void passivateObject(K key, PooledObject<V> p)
+        throws Exception {
+    }
+}

==================================================
BasePooledObjectFactory.java
new file mode 100644
index 0000000000..b07d18f73f
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/BaseObjectPool.java
@@ -0,0 +1,121 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2;
+
+/**
+ * A simple base implementation of {@link ObjectPool}.
+ * Optional operations are implemented to either do nothing, return a value
+ * indicating it is unsupported or throw {@link UnsupportedOperationException}.
+ * <p>
+ * This class is intended to be thread-safe.
+ *
+ * @param <T> Type of element pooled in this pool.
+ *
+ * @version $Revision$
+ *
+ * @since 2.0
+ */
+public abstract class BaseObjectPool<T> implements ObjectPool<T> {
+
+    @Override
+    public abstract T borrowObject() throws Exception;
+
+    @Override
+    public abstract void returnObject(T obj) throws Exception;
+
+    @Override
+    public abstract void invalidateObject(T obj) throws Exception;
+
+    /**
+     * Not supported in this base implementation.
+     *
+     * @return a negative value.
+     */
+    @Override
+    public int getNumIdle() {
+        return -1;
+    }
+
+    /**
+     * Not supported in this base implementation.
+     *
+     * @return a negative value.
+     */
+    @Override
+    public int getNumActive() {
+        return -1;
+    }
+
+    /**
+     * Not supported in this base implementation.
+     *
+     * @throws UnsupportedOperationException if the pool does not implement this
+     *          method
+     */
+    @Override
+    public void clear() throws Exception, UnsupportedOperationException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Not supported in this base implementation. Subclasses should override
+     * this behavior.
+     *
+     * @throws UnsupportedOperationException if the pool does not implement this
+     *          method
+     */
+    @Override
+    public void addObject() throws Exception, UnsupportedOperationException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * This affects the behavior of <code>isClosed</code> and
+     * <code>assertOpen</code>.
+     */
+    @Override
+    public void close() {
+        closed = true;
+    }
+
+    /**
+     * Has this pool instance been closed.
+     *
+     * @return <code>true</code> when this pool has been closed.
+     */
+    public final boolean isClosed() {
+        return closed;
+    }
+
+    /**
+     * Throws an <code>IllegalStateException</code> when this pool has been
+     * closed.
+     *
+     * @throws IllegalStateException when this pool has been closed.
+     *
+     * @see #isClosed()
+     */
+    protected final void assertOpen() throws IllegalStateException {
+        if (isClosed()) {
+            throw new IllegalStateException("Pool not open");
+        }
+    }
+
+    private volatile boolean closed = false;
+}

==================================================
KeyedObjectPool.java
new file mode 100644
index 0000000000..7be98dcee0
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/BasePooledObjectFactory.java
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2;
+
+/**
+ * A base implementation of <code>PoolableObjectFactory</code>.
+ * <p>
+ * All operations defined here are essentially no-op's.
+ * <p>
+ * This class is immutable, and therefore thread-safe
+ *
+ * @param <T> Type of element managed in this factory.
+ *
+ * @see PooledObjectFactory
+ * @see BaseKeyedPooledObjectFactory
+ *
+ * @version $Revision: 1333925 $
+ *
+ * @since 2.0
+ */
+public abstract class BasePooledObjectFactory<T> implements PooledObjectFactory<T> {
+    /**
+     * Creates an object instance, to be wrapped in a {@link PooledObject}.
+     * <p>This method <strong>must</strong> support concurrent, multi-threaded
+     * activation.</p>
+     *
+     * @return an instance to be served by the pool
+     *
+     * @throws Exception if there is a problem creating a new instance,
+     *    this will be propagated to the code requesting an object.
+     */
+    public abstract T create() throws Exception;
+
+    /**
+     * Wrap the provided instance with an implementation of
+     * {@link PooledObject}.
+     *
+     * @param obj the instance to wrap
+     *
+     * @return The provided instance, wrapped by a {@link PooledObject}
+     */
+    public abstract PooledObject<T> wrap(T obj);
+
+    @Override
+    public PooledObject<T> makeObject() throws Exception {
+        return wrap(create());
+    }
+
+    /**
+     *  No-op.
+     *
+     *  @param p ignored
+     */
+    @Override
+    public void destroyObject(PooledObject<T> p)
+        throws Exception  {
+    }
+
+    /**
+     * This implementation always returns {@code true}.
+     *
+     * @param p ignored
+     *
+     * @return {@code true}
+     */
+    @Override
+    public boolean validateObject(PooledObject<T> p) {
+        return true;
+    }
+
+    /**
+     *  No-op.
+     *
+     *  @param p ignored
+     */
+    @Override
+    public void activateObject(PooledObject<T> p) throws Exception {
+    }
+
+    /**
+     *  No-op.
+     *
+     * @param p ignored
+     */
+    @Override
+    public void passivateObject(PooledObject<T> p)
+        throws Exception {
+    }
+}

==================================================
KeyedPooledObjectFactory.java
new file mode 100644
index 0000000000..4097d7d75c
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/KeyedObjectPool.java
@@ -0,0 +1,230 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2;
+
+import java.util.NoSuchElementException;
+
+/**
+ * A "keyed" pooling interface.
+ * <p>
+ * A keyed pool maintains a pool of instances for each key value.
+ * <p>
+ * Example of use:
+ * <pre style="border:solid thin; padding: 1ex;"
+ * > Object obj = <code style="color:#00C">null</code>;
+ * Object key = <code style="color:#C00">"Key"</code>;
+ *
+ * <code style="color:#00C">try</code> {
+ *     obj = pool.borrowObject(key);
+ *     <code style="color:#0C0">//...use the object...</code>
+ * } <code style="color:#00C">catch</code>(Exception e) {
+ *     <code style="color:#0C0">// invalidate the object</code>
+ *     pool.invalidateObject(key, obj);
+ *     <code style="color:#0C0">// do not return the object to the pool twice</code>
+ *     obj = <code style="color:#00C">null</code>;
+ * } <code style="color:#00C">finally</code> {
+ *     <code style="color:#0C0">// make sure the object is returned to the pool</code>
+ *     <code style="color:#00C">if</code>(<code style="color:#00C">null</code> != obj) {
+ *         pool.returnObject(key, obj);
+ *     }
+ * }</pre>
+ * <p>
+ * {@link KeyedObjectPool} implementations <i>may</i> choose to store at most
+ * one instance per key value, or may choose to maintain a pool of instances
+ * for each key (essentially creating a {@link java.util.Map Map} of
+ * {@link ObjectPool pools}).
+ * <p>
+ * See {@link org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool
+ * GenericKeyedObjectPool} for an implementation.
+ *
+ * @param <K> The type of keys maintained by this pool.
+ * @param <V> Type of element pooled in this pool.
+ *
+ * @see KeyedPooledObjectFactory
+ * @see ObjectPool
+ * @see org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool GenericKeyedObjectPool
+ *
+ * @version $Revision$
+ *
+ * @since 2.0
+ */
+public interface KeyedObjectPool<K,V> {
+    /**
+     * Obtains an instance from this pool for the specified <code>key</code>.
+     * <p>
+     * Instances returned from this method will have been either newly created
+     * with {@link KeyedPooledObjectFactory#makeObject makeObject} or will be
+     * a previously idle object and have been activated with
+     * {@link KeyedPooledObjectFactory#activateObject activateObject} and then
+     * (optionally) validated with
+     * {@link KeyedPooledObjectFactory#validateObject validateObject}.
+     * <p>
+     * By contract, clients <strong>must</strong> return the borrowed object
+     * using {@link #returnObject returnObject},
+     * {@link #invalidateObject invalidateObject}, or a related method as
+     * defined in an implementation or sub-interface, using a <code>key</code>
+     * that is {@link Object#equals equivalent} to the one used to borrow the
+     * instance in the first place.
+     * <p>
+     * The behaviour of this method when the pool has been exhausted is not
+     * strictly specified (although it may be specified by implementations).
+     *
+     * @param key the key used to obtain the object
+     *
+     * @return an instance from this pool.
+     *
+     * @throws IllegalStateException
+     *              after {@link #close close} has been called on this pool
+     * @throws Exception
+     *              when {@link KeyedPooledObjectFactory#makeObject
+     *              makeObject} throws an exception
+     * @throws NoSuchElementException
+     *              when the pool is exhausted and cannot or will not return
+     *              another instance
+     */
+    V borrowObject(K key) throws Exception, NoSuchElementException, IllegalStateException;
+
+    /**
+     * Return an instance to the pool. By contract, <code>obj</code>
+     * <strong>must</strong> have been obtained using
+     * {@link #borrowObject borrowObject} or a related method as defined in an
+     * implementation or sub-interface using a <code>key</code> that is
+     * equivalent to the one used to borrow the instance in the first place.
+     *
+     * @param key the key used to obtain the object
+     * @param obj a {@link #borrowObject borrowed} instance to be returned.
+     *
+     * @throws IllegalStateException
+     *              if an attempt is made to return an object to the pool that
+     *              is in any state other than allocated (i.e. borrowed).
+     *              Attempting to return an object more than once or attempting
+     *              to return an object that was never borrowed from the pool
+     *              will trigger this exception.
+     *
+     * @throws Exception if an instance cannot be returned to the pool
+     */
+    void returnObject(K key, V obj) throws Exception;
+
+    /**
+     * Invalidates an object from the pool.
+     * <p>
+     * By contract, <code>obj</code> <strong>must</strong> have been obtained
+     * using {@link #borrowObject borrowObject} or a related method as defined
+     * in an implementation or sub-interface using a <code>key</code> that is
+     * equivalent to the one used to borrow the <code>Object</code> in the first
+     * place.
+     * <p>
+     * This method should be used when an object that has been borrowed is
+     * determined (due to an exception or other problem) to be invalid.
+     *
+     * @param key the key used to obtain the object
+     * @param obj a {@link #borrowObject borrowed} instance to be returned.
+     *
+     * @throws Exception if the instance cannot be invalidated
+     */
+    void invalidateObject(K key, V obj) throws Exception;
+
+    /**
+     * Create an object using the {@link KeyedPooledObjectFactory factory} or
+     * other implementation dependent mechanism, passivate it, and then place it
+     * in the idle object pool. <code>addObject</code> is useful for
+     * "pre-loading" a pool with idle objects (Optional operation).
+     *
+     * @param key the key a new instance should be added to
+     *
+     * @throws Exception
+     *              when {@link KeyedPooledObjectFactory#makeObject} fails.
+     * @throws IllegalStateException
+     *              after {@link #close} has been called on this pool.
+     * @throws UnsupportedOperationException
+     *              when this pool cannot add new idle objects.
+     */
+    void addObject(K key) throws Exception, IllegalStateException,
+            UnsupportedOperationException;
+
+    /**
+     * Returns the number of instances corresponding to the given
+     * <code>key</code> currently idle in this pool. Returns a negative value if
+     * this information is not available.
+     *
+     * @param key the key to query
+     * @return the number of instances corresponding to the given
+     * <code>key</code> currently idle in this pool.
+     */
+    int getNumIdle(K key);
+
+    /**
+     * Returns the number of instances currently borrowed from but not yet
+     * returned to the pool corresponding to the given <code>key</code>.
+     * Returns a negative value if this information is not available.
+     *
+     * @param key the key to query
+     * @return the number of instances currently borrowed from but not yet
+     * returned to the pool corresponding to the given <code>key</code>.
+=     */
+    int getNumActive(K key);
+
+    /**
+     * Returns the total number of instances currently idle in this pool.
+     * Returns a negative value if this information is not available.
+     * @return the total number of instances currently idle in this pool.
+ =    */
+    int getNumIdle();
+
+    /**
+     * Returns the total number of instances current borrowed from this pool but
+     * not yet returned. Returns a negative value if this information is not
+     * available.
+     * @return the total number of instances current borrowed from this pool but
+     * not yet returned.
+     */
+    int getNumActive();
+
+    /**
+     * Clears the pool, removing all pooled instances (optional operation).
+     *
+     * @throws UnsupportedOperationException when this implementation doesn't
+     *                                       support the operation
+     *
+     * @throws Exception if the pool cannot be cleared
+     */
+    void clear() throws Exception, UnsupportedOperationException;
+
+    /**
+     * Clears the specified pool, removing all pooled instances corresponding to
+     * the given <code>key</code> (optional operation).
+     *
+     * @param key the key to clear
+     *
+     * @throws UnsupportedOperationException when this implementation doesn't
+     *                                       support the operation
+     *
+     * @throws Exception if the key cannot be cleared
+     */
+    void clear(K key) throws Exception, UnsupportedOperationException;
+
+    /**
+     * Close this pool, and free any resources associated with it.
+     * <p>
+     * Calling {@link #addObject addObject} or
+     * {@link #borrowObject borrowObject} after invoking this method on a pool
+     * will cause them to throw an {@link IllegalStateException}.
+     * <p>
+     * Implementations should silently fail if not all resources can be freed.
+     */
+    void close();
+}

==================================================
ObjectPool.java
new file mode 100644
index 0000000000..ddc5282e5e
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/KeyedPooledObjectFactory.java
@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2;
+
+/**
+ * An interface defining life-cycle methods for
+ * instances to be served by a {@link KeyedObjectPool}.
+ * <p>
+ * By contract, when an {@link KeyedObjectPool}
+ * delegates to a {@link KeyedPooledObjectFactory},
+ * <ol>
+ *  <li>
+ *   {@link #makeObject} is called whenever a new instance is needed.
+ *  </li>
+ *  <li>
+ *   {@link #activateObject} is invoked on every instance that has been
+ *   {@link #passivateObject passivated} before it is
+ *   {@link KeyedObjectPool#borrowObject borrowed} from the pool.
+ *  </li>
+ *  <li>
+ *   {@link #validateObject} may be invoked on {@link #activateObject activated}
+ *   instances to make sure they can be
+ *   {@link KeyedObjectPool#borrowObject borrowed} from the pool.
+ *   <code>validateObject</code> may also be used to test an
+ *   instance being {@link KeyedObjectPool#returnObject returned} to the pool
+ *   before it is {@link #passivateObject passivated}. It will only be invoked
+ *   on an activated instance.
+ *  </li>
+ *  <li>
+ *   {@link #passivateObject passivateObject}
+ *   is invoked on every instance when it is returned to the pool.
+ *  </li>
+ *  <li>
+ *   {@link #destroyObject destroyObject}
+ *   is invoked on every instance when it is being "dropped" from the
+ *   pool (whether due to the response from <code>validateObject</code>,
+ *   or for reasons specific to the pool implementation.) There is no
+ *   guarantee that the instance being destroyed will
+ *   be considered active, passive or in a generally consistent state.
+ *  </li>
+ * </ol>
+ * {@link KeyedPooledObjectFactory} must be thread-safe. The only promise
+ * an {@link KeyedObjectPool} makes is that the same instance of an object will
+ * not be passed to more than one method of a
+ * <code>KeyedPoolableObjectFactory</code> at a time.
+ * <p>
+ * While clients of a {@link KeyedObjectPool} borrow and return instances of
+ * the underlying value type V, the factory methods act on instances of
+ * {@link PooledObject PooledObject&lt;V&gt;}.  These are the object wrappers that
+ * pools use to track and maintain state informations about the objects that
+ * they manage.
+ *
+ * @see KeyedObjectPool
+ * @see BaseKeyedPooledObjectFactory
+ *
+ * @param <K> The type of keys managed by this factory.
+ * @param <V> Type of element managed by this factory.
+ *
+ * @version $Revision: 1333925 $
+ *
+ * @since 2.0
+ */
+public interface KeyedPooledObjectFactory<K,V> {
+    /**
+     * Create an instance that can be served by the pool and
+     * wrap it in a {@link PooledObject} to be managed by the pool.
+     *
+     * @param key the key used when constructing the object
+     *
+     * @return a {@code PooledObject} wrapping an instance that can
+     * be served by the pool.
+     *
+     * @throws Exception if there is a problem creating a new instance,
+     *    this will be propagated to the code requesting an object.
+     */
+    PooledObject<V> makeObject(K key) throws Exception;
+
+    /**
+     * Destroy an instance no longer needed by the pool.
+     * <p>
+     * It is important for implementations of this method to be aware that there
+     * is no guarantee about what state <code>obj</code> will be in and the
+     * implementation should be prepared to handle unexpected errors.
+     * <p>
+     * Also, an implementation must take in to consideration that instances lost
+     * to the garbage collector may never be destroyed.
+     *
+     * @param key the key used when selecting the instance
+     * @param p a {@code PooledObject} wrapping the instance to be destroyed
+     *
+     * @throws Exception should be avoided as it may be swallowed by
+     *    the pool implementation.
+     *
+     * @see #validateObject
+     * @see KeyedObjectPool#invalidateObject
+     */
+    void destroyObject(K key, PooledObject<V> p) throws Exception;
+
+    /**
+     * Ensures that the instance is safe to be returned by the pool.
+     *
+     * @param key the key used when selecting the object
+     * @param p a {@code PooledObject} wrapping the instance to be validated
+     *
+     * @return <code>false</code> if <code>obj</code> is not valid and should
+     *         be dropped from the pool, <code>true</code> otherwise.
+     */
+    boolean validateObject(K key, PooledObject<V> p);
+
+    /**
+     * Reinitialize an instance to be returned by the pool.
+     *
+     * @param key the key used when selecting the object
+     * @param p a {@code PooledObject} wrapping the instance to be activated
+     *
+     * @throws Exception if there is a problem activating <code>obj</code>,
+     *    this exception may be swallowed by the pool.
+     *
+     * @see #destroyObject
+     */
+    void activateObject(K key, PooledObject<V> p) throws Exception;
+
+    /**
+     * Uninitialize an instance to be returned to the idle object pool.
+     *
+     * @param key the key used when selecting the object
+     * @param p a {@code PooledObject} wrapping the instance to be passivated
+     *
+     * @throws Exception if there is a problem passivating <code>obj</code>,
+     *    this exception may be swallowed by the pool.
+     *
+     * @see #destroyObject
+     */
+    void passivateObject(K key, PooledObject<V> p) throws Exception;
+}
+

==================================================
PoolUtils.java
new file mode 100644
index 0000000000..20de0bf227
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/ObjectPool.java
@@ -0,0 +1,178 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2;
+
+import java.util.NoSuchElementException;
+
+/**
+ * A pooling simple interface.
+ * <p>
+ * Example of use:
+ * <pre style="border:solid thin; padding: 1ex;"
+ * > Object obj = <code style="color:#00C">null</code>;
+ *
+ * <code style="color:#00C">try</code> {
+ *     obj = pool.borrowObject();
+ *     <code style="color:#00C">try</code> {
+ *         <code style="color:#0C0">//...use the object...</code>
+ *     } <code style="color:#00C">catch</code>(Exception e) {
+ *         <code style="color:#0C0">// invalidate the object</code>
+ *         pool.invalidateObject(obj);
+ *         <code style="color:#0C0">// do not return the object to the pool twice</code>
+ *         obj = <code style="color:#00C">null</code>;
+ *     } <code style="color:#00C">finally</code> {
+ *         <code style="color:#0C0">// make sure the object is returned to the pool</code>
+ *         <code style="color:#00C">if</code>(<code style="color:#00C">null</code> != obj) {
+ *             pool.returnObject(obj);
+ *        }
+ *     }
+ * } <code style="color:#00C">catch</code>(Exception e) {
+ *       <code style="color:#0C0">// failed to borrow an object</code>
+ * }</pre>
+ * <p>
+ * See {@link BaseObjectPool} for a simple base implementation.
+ *
+ * @param <T> Type of element pooled in this pool.
+ *
+ * @see PooledObjectFactory
+ * @see KeyedObjectPool
+ * @see BaseObjectPool
+ *
+ * @version $Revision$
+ *
+ * @since 2.0
+ */
+public interface ObjectPool<T> {
+    /**
+     * Obtains an instance from this pool.
+     * <p>
+     * Instances returned from this method will have been either newly created
+     * with {@link PooledObjectFactory#makeObject} or will be a previously
+     * idle object and have been activated with
+     * {@link PooledObjectFactory#activateObject} and then validated with
+     * {@link PooledObjectFactory#validateObject}.
+     * <p>
+     * By contract, clients <strong>must</strong> return the borrowed instance
+     * using {@link #returnObject}, {@link #invalidateObject}, or a related
+     * method as defined in an implementation or sub-interface.
+     * <p>
+     * The behaviour of this method when the pool has been exhausted
+     * is not strictly specified (although it may be specified by
+     * implementations).
+     *
+     * @return an instance from this pool.
+     *
+     * @throws IllegalStateException
+     *              after {@link #close close} has been called on this pool.
+     * @throws Exception
+     *              when {@link PooledObjectFactory#makeObject} throws an
+     *              exception.
+     * @throws NoSuchElementException
+     *              when the pool is exhausted and cannot or will not return
+     *              another instance.
+     */
+    T borrowObject() throws Exception, NoSuchElementException,
+            IllegalStateException;
+
+    /**
+     * Return an instance to the pool. By contract, <code>obj</code>
+     * <strong>must</strong> have been obtained using {@link #borrowObject()} or
+     * a related method as defined in an implementation or sub-interface.
+     *
+     * @param obj a {@link #borrowObject borrowed} instance to be returned.
+     *
+     * @throws IllegalStateException
+     *              if an attempt is made to return an object to the pool that
+     *              is in any state other than allocated (i.e. borrowed).
+     *              Attempting to return an object more than once or attempting
+     *              to return an object that was never borrowed from the pool
+     *              will trigger this exception.
+     *
+     * @throws Exception if an instance cannot be returned to the pool
+     */
+    void returnObject(T obj) throws Exception;
+
+    /**
+     * Invalidates an object from the pool.
+     * <p>
+     * By contract, <code>obj</code> <strong>must</strong> have been obtained
+     * using {@link #borrowObject} or a related method as defined in an
+     * implementation or sub-interface.
+     * <p>
+     * This method should be used when an object that has been borrowed is
+     * determined (due to an exception or other problem) to be invalid.
+     *
+     * @param obj a {@link #borrowObject borrowed} instance to be disposed.
+     *
+     * @throws Exception if the instance cannot be invalidated
+     */
+    void invalidateObject(T obj) throws Exception;
+
+    /**
+     * Create an object using the {@link PooledObjectFactory factory} or other
+     * implementation dependent mechanism, passivate it, and then place it in
+     * the idle object pool. <code>addObject</code> is useful for "pre-loading"
+     * a pool with idle objects. (Optional operation).
+     *
+     * @throws Exception
+     *              when {@link PooledObjectFactory#makeObject} fails.
+     * @throws IllegalStateException
+     *              after {@link #close} has been called on this pool.
+     * @throws UnsupportedOperationException
+     *              when this pool cannot add new idle objects.
+     */
+    void addObject() throws Exception, IllegalStateException,
+            UnsupportedOperationException;
+
+    /**
+     * Return the number of instances currently idle in this pool. This may be
+     * considered an approximation of the number of objects that can be
+     * {@link #borrowObject borrowed} without creating any new instances.
+     * Returns a negative value if this information is not available.
+     * @return the number of instances currently idle in this pool.
+     */
+    int getNumIdle();
+
+    /**
+     * Return the number of instances currently borrowed from this pool. Returns
+     * a negative value if this information is not available.
+     * @return the number of instances currently borrowed from this pool.
+     */
+    int getNumActive();
+
+    /**
+     * Clears any objects sitting idle in the pool, releasing any associated
+     * resources (optional operation). Idle objects cleared must be
+     * {@link PooledObjectFactory#destroyObject(PooledObject)}.
+     *
+     * @throws UnsupportedOperationException
+     *              if this implementation does not support the operation
+     *
+     * @throws Exception if the pool cannot be cleared
+     */
+    void clear() throws Exception, UnsupportedOperationException;
+
+    /**
+     * Close this pool, and free any resources associated with it.
+     * <p>
+     * Calling {@link #addObject} or {@link #borrowObject} after invoking this
+     * method on a pool will cause them to throw an {@link IllegalStateException}.
+     * <p>
+     * Implementations should silently fail if not all resources can be freed.
+     */
+    void close();
+}

==================================================
PooledObject.java
new file mode 100644
index 0000000000..c8f767207e
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/PoolUtils.java
@@ -0,0 +1,1803 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
+
+/**
+ * This class consists exclusively of static methods that operate on or return
+ * ObjectPool or KeyedObjectPool related interfaces.
+ *
+ * @version $Revision$
+ *
+ * @since 2.0
+ */
+public final class PoolUtils {
+
+    /**
+     * Timer used to periodically check pools idle object count. Because a
+     * {@link Timer} creates a {@link Thread}, an IODH is used.
+     */
+    static class TimerHolder {
+        static final Timer MIN_IDLE_TIMER = new Timer(true);
+    }
+
+    /**
+     * PoolUtils instances should NOT be constructed in standard programming.
+     * Instead, the class should be used procedurally: PoolUtils.adapt(aPool);.
+     * This constructor is public to permit tools that require a JavaBean
+     * instance to operate.
+     */
+    public PoolUtils() {
+    }
+
+    /**
+     * Should the supplied Throwable be re-thrown (eg if it is an instance of
+     * one of the Throwables that should never be swallowed). Used by the pool
+     * error handling for operations that throw exceptions that normally need to
+     * be ignored.
+     *
+     * @param t
+     *            The Throwable to check
+     * @throws ThreadDeath
+     *             if that is passed in
+     * @throws VirtualMachineError
+     *             if that is passed in
+     */
+    public static void checkRethrow(Throwable t) {
+        if (t instanceof ThreadDeath) {
+            throw (ThreadDeath) t;
+        }
+        if (t instanceof VirtualMachineError) {
+            throw (VirtualMachineError) t;
+        }
+        // All other instances of Throwable will be silently swallowed
+    }
+
+    /**
+     * Periodically check the idle object count for the pool. At most one idle
+     * object will be added per period. If there is an exception when calling
+     * {@link ObjectPool#addObject()} then no more checks will be performed.
+     *
+     * @param pool
+     *            the pool to check periodically.
+     * @param minIdle
+     *            if the {@link ObjectPool#getNumIdle()} is less than this then
+     *            add an idle object.
+     * @param period
+     *            the frequency to check the number of idle objects in a pool,
+     *            see {@link Timer#schedule(TimerTask, long, long)}.
+     * @param <T> the type of objects in the pool
+     * @return the {@link TimerTask} that will periodically check the pools idle
+     *         object count.
+     * @throws IllegalArgumentException
+     *             when <code>pool</code> is <code>null</code> or when
+     *             <code>minIdle</code> is negative or when <code>period</code>
+     *             isn't valid for {@link Timer#schedule(TimerTask, long, long)}
+     */
+    public static <T> TimerTask checkMinIdle(final ObjectPool<T> pool,
+            final int minIdle, final long period)
+            throws IllegalArgumentException {
+        if (pool == null) {
+            throw new IllegalArgumentException("keyedPool must not be null.");
+        }
+        if (minIdle < 0) {
+            throw new IllegalArgumentException("minIdle must be non-negative.");
+        }
+        final TimerTask task = new ObjectPoolMinIdleTimerTask<>(pool, minIdle);
+        getMinIdleTimer().schedule(task, 0L, period);
+        return task;
+    }
+
+    /**
+     * Periodically check the idle object count for the key in the keyedPool. At
+     * most one idle object will be added per period. If there is an exception
+     * when calling {@link KeyedObjectPool#addObject(Object)} then no more
+     * checks for that key will be performed.
+     *
+     * @param keyedPool
+     *            the keyedPool to check periodically.
+     * @param key
+     *            the key to check the idle count of.
+     * @param minIdle
+     *            if the {@link KeyedObjectPool#getNumIdle(Object)} is less than
+     *            this then add an idle object.
+     * @param period
+     *            the frequency to check the number of idle objects in a
+     *            keyedPool, see {@link Timer#schedule(TimerTask, long, long)}.
+     * @param <K> the type of the pool key
+     * @param <V> the type of pool entries
+     * @return the {@link TimerTask} that will periodically check the pools idle
+     *         object count.
+     * @throws IllegalArgumentException
+     *             when <code>keyedPool</code>, <code>key</code> is
+     *             <code>null</code> or when <code>minIdle</code> is negative or
+     *             when <code>period</code> isn't valid for
+     *             {@link Timer#schedule(TimerTask, long, long)}.
+     */
+    public static <K, V> TimerTask checkMinIdle(
+            final KeyedObjectPool<K, V> keyedPool, final K key,
+            final int minIdle, final long period)
+            throws IllegalArgumentException {
+        if (keyedPool == null) {
+            throw new IllegalArgumentException("keyedPool must not be null.");
+        }
+        if (key == null) {
+            throw new IllegalArgumentException("key must not be null.");
+        }
+        if (minIdle < 0) {
+            throw new IllegalArgumentException("minIdle must be non-negative.");
+        }
+        final TimerTask task = new KeyedObjectPoolMinIdleTimerTask<>(
+                keyedPool, key, minIdle);
+        getMinIdleTimer().schedule(task, 0L, period);
+        return task;
+    }
+
+    /**
+     * Periodically check the idle object count for each key in the
+     * <code>Collection</code> <code>keys</code> in the keyedPool. At most one
+     * idle object will be added per period.
+     *
+     * @param keyedPool
+     *            the keyedPool to check periodically.
+     * @param keys
+     *            a collection of keys to check the idle object count.
+     * @param minIdle
+     *            if the {@link KeyedObjectPool#getNumIdle(Object)} is less than
+     *            this then add an idle object.
+     * @param period
+     *            the frequency to check the number of idle objects in a
+     *            keyedPool, see {@link Timer#schedule(TimerTask, long, long)}.
+     * @param <K> the type of the pool key
+     * @param <V> the type of pool entries
+     * @return a {@link Map} of key and {@link TimerTask} pairs that will
+     *         periodically check the pools idle object count.
+     * @throws IllegalArgumentException
+     *             when <code>keyedPool</code>, <code>keys</code>, or any of the
+     *             values in the collection is <code>null</code> or when
+     *             <code>minIdle</code> is negative or when <code>period</code>
+     *             isn't valid for {@link Timer#schedule(TimerTask, long, long)}
+     *             .
+     * @see #checkMinIdle(KeyedObjectPool, Object, int, long)
+     */
+    public static <K, V> Map<K, TimerTask> checkMinIdle(
+            final KeyedObjectPool<K, V> keyedPool, final Collection<K> keys,
+            final int minIdle, final long period)
+            throws IllegalArgumentException {
+        if (keys == null) {
+            throw new IllegalArgumentException("keys must not be null.");
+        }
+        final Map<K, TimerTask> tasks = new HashMap<>(keys.size());
+        final Iterator<K> iter = keys.iterator();
+        while (iter.hasNext()) {
+            final K key = iter.next();
+            final TimerTask task = checkMinIdle(keyedPool, key, minIdle, period);
+            tasks.put(key, task);
+        }
+        return tasks;
+    }
+
+    /**
+     * Call <code>addObject()</code> on <code>pool</code> <code>count</code>
+     * number of times.
+     *
+     * @param pool
+     *            the pool to prefill.
+     * @param count
+     *            the number of idle objects to add.
+     * @param <T> the type of objects in the pool
+     * @throws Exception
+     *             when {@link ObjectPool#addObject()} fails.
+     * @throws IllegalArgumentException
+     *             when <code>pool</code> is <code>null</code>.
+     */
+    public static <T> void prefill(final ObjectPool<T> pool, final int count)
+            throws Exception, IllegalArgumentException {
+        if (pool == null) {
+            throw new IllegalArgumentException("pool must not be null.");
+        }
+        for (int i = 0; i < count; i++) {
+            pool.addObject();
+        }
+    }
+
+    /**
+     * Call <code>addObject(Object)</code> on <code>keyedPool</code> with
+     * <code>key</code> <code>count</code> number of times.
+     *
+     * @param keyedPool
+     *            the keyedPool to prefill.
+     * @param key
+     *            the key to add objects for.
+     * @param count
+     *            the number of idle objects to add for <code>key</code>.
+     * @param <K> the type of the pool key
+     * @param <V> the type of pool entries
+     * @throws Exception
+     *             when {@link KeyedObjectPool#addObject(Object)} fails.
+     * @throws IllegalArgumentException
+     *             when <code>keyedPool</code> or <code>key</code> is
+     *             <code>null</code>.
+     */
+    public static <K, V> void prefill(final KeyedObjectPool<K, V> keyedPool,
+            final K key, final int count) throws Exception,
+            IllegalArgumentException {
+        if (keyedPool == null) {
+            throw new IllegalArgumentException("keyedPool must not be null.");
+        }
+        if (key == null) {
+            throw new IllegalArgumentException("key must not be null.");
+        }
+        for (int i = 0; i < count; i++) {
+            keyedPool.addObject(key);
+        }
+    }
+
+    /**
+     * Call <code>addObject(Object)</code> on <code>keyedPool</code> with each
+     * key in <code>keys</code> for <code>count</code> number of times. This has
+     * the same effect as calling {@link #prefill(KeyedObjectPool, Object, int)}
+     * for each key in the <code>keys</code> collection.
+     *
+     * @param keyedPool
+     *            the keyedPool to prefill.
+     * @param keys
+     *            {@link Collection} of keys to add objects for.
+     * @param count
+     *            the number of idle objects to add for each <code>key</code>.
+     * @param <K> the type of the pool key
+     * @param <V> the type of pool entries
+     * @throws Exception
+     *             when {@link KeyedObjectPool#addObject(Object)} fails.
+     * @throws IllegalArgumentException
+     *             when <code>keyedPool</code>, <code>keys</code>, or any value
+     *             in <code>keys</code> is <code>null</code>.
+     * @see #prefill(KeyedObjectPool, Object, int)
+     */
+    public static <K, V> void prefill(final KeyedObjectPool<K, V> keyedPool,
+            final Collection<K> keys, final int count) throws Exception,
+            IllegalArgumentException {
+        if (keys == null) {
+            throw new IllegalArgumentException("keys must not be null.");
+        }
+        final Iterator<K> iter = keys.iterator();
+        while (iter.hasNext()) {
+            prefill(keyedPool, iter.next(), count);
+        }
+    }
+
+    /**
+     * Returns a synchronized (thread-safe) ObjectPool backed by the specified
+     * ObjectPool.
+     * <p>
+     * <b>Note:</b> This should not be used on pool implementations that already
+     * provide proper synchronization such as the pools provided in the Commons
+     * Pool library. Wrapping a pool that {@link #wait() waits} for poolable
+     * objects to be returned before allowing another one to be borrowed with
+     * another layer of synchronization will cause liveliness issues or a
+     * deadlock.
+     * </p>
+     *
+     * @param pool
+     *            the ObjectPool to be "wrapped" in a synchronized ObjectPool.
+     * @param <T> the type of objects in the pool
+     * @return a synchronized view of the specified ObjectPool.
+     */
+    public static <T> ObjectPool<T> synchronizedPool(final ObjectPool<T> pool) {
+        if (pool == null) {
+            throw new IllegalArgumentException("pool must not be null.");
+        }
+        /*
+         * assert !(pool instanceof GenericObjectPool) :
+         * "GenericObjectPool is already thread-safe"; assert !(pool instanceof
+         * SoftReferenceObjectPool) :
+         * "SoftReferenceObjectPool is already thread-safe"; assert !(pool
+         * instanceof StackObjectPool) :
+         * "StackObjectPool is already thread-safe"; assert
+         * !"org.apache.commons.pool.composite.CompositeObjectPool"
+         * .equals(pool.getClass().getName()) :
+         * "CompositeObjectPools are already thread-safe";
+         */
+        return new SynchronizedObjectPool<>(pool);
+    }
+
+    /**
+     * Returns a synchronized (thread-safe) KeyedObjectPool backed by the
+     * specified KeyedObjectPool.
+     * <p>
+     * <b>Note:</b> This should not be used on pool implementations that already
+     * provide proper synchronization such as the pools provided in the Commons
+     * Pool library. Wrapping a pool that {@link #wait() waits} for poolable
+     * objects to be returned before allowing another one to be borrowed with
+     * another layer of synchronization will cause liveliness issues or a
+     * deadlock.
+     * </p>
+     *
+     * @param keyedPool
+     *            the KeyedObjectPool to be "wrapped" in a synchronized
+     *            KeyedObjectPool.
+     * @param <K> the type of the pool key
+     * @param <V> the type of pool entries
+     * @return a synchronized view of the specified KeyedObjectPool.
+     */
+    public static <K, V> KeyedObjectPool<K, V> synchronizedPool(
+            final KeyedObjectPool<K, V> keyedPool) {
+        /*
+         * assert !(keyedPool instanceof GenericKeyedObjectPool) :
+         * "GenericKeyedObjectPool is already thread-safe"; assert !(keyedPool
+         * instanceof StackKeyedObjectPool) :
+         * "StackKeyedObjectPool is already thread-safe"; assert
+         * !"org.apache.commons.pool.composite.CompositeKeyedObjectPool"
+         * .equals(keyedPool.getClass().getName()) :
+         * "CompositeKeyedObjectPools are already thread-safe";
+         */
+        return new SynchronizedKeyedObjectPool<>(keyedPool);
+    }
+
+    /**
+     * Returns a synchronized (thread-safe) PooledObjectFactory backed by the
+     * specified PooledObjectFactory.
+     *
+     * @param factory
+     *            the PooledObjectFactory to be "wrapped" in a synchronized
+     *            PooledObjectFactory.
+     * @param <T> the type of objects in the pool
+     * @return a synchronized view of the specified PooledObjectFactory.
+     */
+    public static <T> PooledObjectFactory<T> synchronizedPooledFactory(
+            final PooledObjectFactory<T> factory) {
+        return new SynchronizedPooledObjectFactory<>(factory);
+    }
+
+    /**
+     * Returns a synchronized (thread-safe) KeyedPooledObjectFactory backed by
+     * the specified KeyedPoolableObjectFactory.
+     *
+     * @param keyedFactory
+     *            the KeyedPooledObjectFactory to be "wrapped" in a
+     *            synchronized KeyedPooledObjectFactory.
+     * @param <K> the type of the pool key
+     * @param <V> the type of pool entries
+     * @return a synchronized view of the specified KeyedPooledObjectFactory.
+     */
+    public static <K, V> KeyedPooledObjectFactory<K, V> synchronizedKeyedPooledFactory(
+            final KeyedPooledObjectFactory<K, V> keyedFactory) {
+        return new SynchronizedKeyedPooledObjectFactory<>(keyedFactory);
+    }
+
+    /**
+     * Returns a pool that adaptively decreases its size when idle objects are
+     * no longer needed. This is intended as an always thread-safe alternative
+     * to using an idle object evictor provided by many pool implementations.
+     * This is also an effective way to shrink FIFO ordered pools that
+     * experience load spikes.
+     *
+     * @param pool
+     *            the ObjectPool to be decorated so it shrinks its idle count
+     *            when possible.
+     * @param <T> the type of objects in the pool
+     * @return a pool that adaptively decreases its size when idle objects are
+     *         no longer needed.
+     * @see #erodingPool(ObjectPool, float)
+     */
+    public static <T> ObjectPool<T> erodingPool(final ObjectPool<T> pool) {
+        return erodingPool(pool, 1f);
+    }
+
+    /**
+     * Returns a pool that adaptively decreases its size when idle objects are
+     * no longer needed. This is intended as an always thread-safe alternative
+     * to using an idle object evictor provided by many pool implementations.
+     * This is also an effective way to shrink FIFO ordered pools that
+     * experience load spikes.
+     * <p>
+     * The factor parameter provides a mechanism to tweak the rate at which the
+     * pool tries to shrink its size. Values between 0 and 1 cause the pool to
+     * try to shrink its size more often. Values greater than 1 cause the pool
+     * to less frequently try to shrink its size.
+     * </p>
+     *
+     * @param pool
+     *            the ObjectPool to be decorated so it shrinks its idle count
+     *            when possible.
+     * @param factor
+     *            a positive value to scale the rate at which the pool tries to
+     *            reduce its size. If 0 &lt; factor &lt; 1 then the pool
+     *            shrinks more aggressively. If 1 &lt; factor then the pool
+     *            shrinks less aggressively.
+     * @param <T> the type of objects in the pool
+     * @return a pool that adaptively decreases its size when idle objects are
+     *         no longer needed.
+     * @see #erodingPool(ObjectPool)
+     */
+    public static <T> ObjectPool<T> erodingPool(final ObjectPool<T> pool,
+            final float factor) {
+        if (pool == null) {
+            throw new IllegalArgumentException("pool must not be null.");
+        }
+        if (factor <= 0f) {
+            throw new IllegalArgumentException("factor must be positive.");
+        }
+        return new ErodingObjectPool<>(pool, factor);
+    }
+
+    /**
+     * Returns a pool that adaptively decreases its size when idle objects are
+     * no longer needed. This is intended as an always thread-safe alternative
+     * to using an idle object evictor provided by many pool implementations.
+     * This is also an effective way to shrink FIFO ordered pools that
+     * experience load spikes.
+     *
+     * @param keyedPool
+     *            the KeyedObjectPool to be decorated so it shrinks its idle
+     *            count when possible.
+     * @param <K> the type of the pool key
+     * @param <V> the type of pool entries
+     * @return a pool that adaptively decreases its size when idle objects are
+     *         no longer needed.
+     * @see #erodingPool(KeyedObjectPool, float)
+     * @see #erodingPool(KeyedObjectPool, float, boolean)
+     */
+    public static <K, V> KeyedObjectPool<K, V> erodingPool(
+            final KeyedObjectPool<K, V> keyedPool) {
+        return erodingPool(keyedPool, 1f);
+    }
+
+    /**
+     * Returns a pool that adaptively decreases its size when idle objects are
+     * no longer needed. This is intended as an always thread-safe alternative
+     * to using an idle object evictor provided by many pool implementations.
+     * This is also an effective way to shrink FIFO ordered pools that
+     * experience load spikes.
+     * <p>
+     * The factor parameter provides a mechanism to tweak the rate at which the
+     * pool tries to shrink its size. Values between 0 and 1 cause the pool to
+     * try to shrink its size more often. Values greater than 1 cause the pool
+     * to less frequently try to shrink its size.
+     * </p>
+     *
+     * @param keyedPool
+     *            the KeyedObjectPool to be decorated so it shrinks its idle
+     *            count when possible.
+     * @param factor
+     *            a positive value to scale the rate at which the pool tries to
+     *            reduce its size. If 0 &lt; factor &lt; 1 then the pool
+     *            shrinks more aggressively. If 1 &lt; factor then the pool
+     *            shrinks less aggressively.
+     * @param <K> the type of the pool key
+     * @param <V> the type of pool entries
+     * @return a pool that adaptively decreases its size when idle objects are
+     *         no longer needed.
+     * @see #erodingPool(KeyedObjectPool, float, boolean)
+     */
+    public static <K, V> KeyedObjectPool<K, V> erodingPool(
+            final KeyedObjectPool<K, V> keyedPool, final float factor) {
+        return erodingPool(keyedPool, factor, false);
+    }
+
+    /**
+     * Returns a pool that adaptively decreases its size when idle objects are
+     * no longer needed. This is intended as an always thread-safe alternative
+     * to using an idle object evictor provided by many pool implementations.
+     * This is also an effective way to shrink FIFO ordered pools that
+     * experience load spikes.
+     * <p>
+     * The factor parameter provides a mechanism to tweak the rate at which the
+     * pool tries to shrink its size. Values between 0 and 1 cause the pool to
+     * try to shrink its size more often. Values greater than 1 cause the pool
+     * to less frequently try to shrink its size.
+     * </p>
+     * <p>
+     * The perKey parameter determines if the pool shrinks on a whole pool basis
+     * or a per key basis. When perKey is false, the keys do not have an effect
+     * on the rate at which the pool tries to shrink its size. When perKey is
+     * true, each key is shrunk independently.
+     * </p>
+     *
+     * @param keyedPool
+     *            the KeyedObjectPool to be decorated so it shrinks its idle
+     *            count when possible.
+     * @param factor
+     *            a positive value to scale the rate at which the pool tries to
+     *            reduce its size. If 0 &lt; factor &lt; 1 then the pool
+     *            shrinks more aggressively. If 1 &lt; factor then the pool
+     *            shrinks less aggressively.
+     * @param perKey
+     *            when true, each key is treated independently.
+     * @param <K> the type of the pool key
+     * @param <V> the type of pool entries
+     * @return a pool that adaptively decreases its size when idle objects are
+     *         no longer needed.
+     * @see #erodingPool(KeyedObjectPool)
+     * @see #erodingPool(KeyedObjectPool, float)
+     */
+    public static <K, V> KeyedObjectPool<K, V> erodingPool(
+            final KeyedObjectPool<K, V> keyedPool, final float factor,
+            final boolean perKey) {
+        if (keyedPool == null) {
+            throw new IllegalArgumentException("keyedPool must not be null.");
+        }
+        if (factor <= 0f) {
+            throw new IllegalArgumentException("factor must be positive.");
+        }
+        if (perKey) {
+            return new ErodingPerKeyKeyedObjectPool<>(keyedPool, factor);
+        }
+        return new ErodingKeyedObjectPool<>(keyedPool, factor);
+    }
+
+    /**
+     * Get the <code>Timer</code> for checking keyedPool's idle count.
+     *
+     * @return the {@link Timer} for checking keyedPool's idle count.
+     */
+    private static Timer getMinIdleTimer() {
+        return TimerHolder.MIN_IDLE_TIMER;
+    }
+
+    /**
+     * Timer task that adds objects to the pool until the number of idle
+     * instances reaches the configured minIdle. Note that this is not the same
+     * as the pool's minIdle setting.
+     */
+    private static class ObjectPoolMinIdleTimerTask<T> extends TimerTask {
+
+        /** Minimum number of idle instances. Not the same as pool.getMinIdle(). */
+        private final int minIdle;
+
+        /** Object pool */
+        private final ObjectPool<T> pool;
+
+        /**
+         * Create a new ObjectPoolMinIdleTimerTask for the given pool with the
+         * given minIdle setting.
+         *
+         * @param pool
+         *            object pool
+         * @param minIdle
+         *            number of idle instances to maintain
+         * @throws IllegalArgumentException
+         *             if the pool is null
+         */
+        ObjectPoolMinIdleTimerTask(final ObjectPool<T> pool, final int minIdle)
+                throws IllegalArgumentException {
+            if (pool == null) {
+                throw new IllegalArgumentException("pool must not be null.");
+            }
+            this.pool = pool;
+            this.minIdle = minIdle;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void run() {
+            boolean success = false;
+            try {
+                if (pool.getNumIdle() < minIdle) {
+                    pool.addObject();
+                }
+                success = true;
+
+            } catch (Exception e) {
+                cancel();
+            } finally {
+                // detect other types of Throwable and cancel this Timer
+                if (!success) {
+                    cancel();
+                }
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            final StringBuilder sb = new StringBuilder();
+            sb.append("ObjectPoolMinIdleTimerTask");
+            sb.append("{minIdle=").append(minIdle);
+            sb.append(", pool=").append(pool);
+            sb.append('}');
+            return sb.toString();
+        }
+    }
+
+    /**
+     * Timer task that adds objects to the pool until the number of idle
+     * instances for the given key reaches the configured minIdle. Note that
+     * this is not the same as the pool's minIdle setting.
+     */
+    private static class KeyedObjectPoolMinIdleTimerTask<K, V> extends
+            TimerTask {
+        /** Minimum number of idle instances. Not the same as pool.getMinIdle(). */
+        private final int minIdle;
+
+        /** Key to ensure minIdle for */
+        private final K key;
+
+        /** Keyed object pool */
+        private final KeyedObjectPool<K, V> keyedPool;
+
+        /**
+         * Create a new KeyedObjecPoolMinIdleTimerTask.
+         *
+         * @param keyedPool
+         *            keyed object pool
+         * @param key
+         *            key to ensure minimum number of idle instances
+         * @param minIdle
+         *            minimum number of idle instances
+         * @throws IllegalArgumentException
+         *             if the key is null
+         */
+        KeyedObjectPoolMinIdleTimerTask(final KeyedObjectPool<K, V> keyedPool,
+                final K key, final int minIdle) throws IllegalArgumentException {
+            if (keyedPool == null) {
+                throw new IllegalArgumentException(
+                        "keyedPool must not be null.");
+            }
+            this.keyedPool = keyedPool;
+            this.key = key;
+            this.minIdle = minIdle;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void run() {
+            boolean success = false;
+            try {
+                if (keyedPool.getNumIdle(key) < minIdle) {
+                    keyedPool.addObject(key);
+                }
+                success = true;
+
+            } catch (Exception e) {
+                cancel();
+
+            } finally {
+                // detect other types of Throwable and cancel this Timer
+                if (!success) {
+                    cancel();
+                }
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            final StringBuilder sb = new StringBuilder();
+            sb.append("KeyedObjectPoolMinIdleTimerTask");
+            sb.append("{minIdle=").append(minIdle);
+            sb.append(", key=").append(key);
+            sb.append(", keyedPool=").append(keyedPool);
+            sb.append('}');
+            return sb.toString();
+        }
+    }
+
+    /**
+     * A synchronized (thread-safe) ObjectPool backed by the specified
+     * ObjectPool.
+     * <p>
+     * <b>Note:</b> This should not be used on pool implementations that already
+     * provide proper synchronization such as the pools provided in the Commons
+     * Pool library. Wrapping a pool that {@link #wait() waits} for poolable
+     * objects to be returned before allowing another one to be borrowed with
+     * another layer of synchronization will cause liveliness issues or a
+     * deadlock.
+     * </p>
+     */
+    private static class SynchronizedObjectPool<T> implements ObjectPool<T> {
+
+        /**
+         * Object whose monitor is used to synchronize methods on the wrapped
+         * pool.
+         */
+        private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
+
+        /** the underlying object pool */
+        private final ObjectPool<T> pool;
+
+        /**
+         * Create a new SynchronizedObjectPool wrapping the given pool.
+         *
+         * @param pool
+         *            the ObjectPool to be "wrapped" in a synchronized
+         *            ObjectPool.
+         * @throws IllegalArgumentException
+         *             if the pool is null
+         */
+        SynchronizedObjectPool(final ObjectPool<T> pool)
+                throws IllegalArgumentException {
+            if (pool == null) {
+                throw new IllegalArgumentException("pool must not be null.");
+            }
+            this.pool = pool;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public T borrowObject() throws Exception, NoSuchElementException,
+                IllegalStateException {
+            WriteLock writeLock = readWriteLock.writeLock();
+            writeLock.lock();
+            try {
+                return pool.borrowObject();
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void returnObject(final T obj) {
+            WriteLock writeLock = readWriteLock.writeLock();
+            writeLock.lock();
+            try {
+                pool.returnObject(obj);
+            } catch (Exception e) {
+                // swallowed as of Pool 2
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void invalidateObject(final T obj) {
+            WriteLock writeLock = readWriteLock.writeLock();
+            writeLock.lock();
+            try {
+                pool.invalidateObject(obj);
+            } catch (Exception e) {
+                // swallowed as of Pool 2
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void addObject() throws Exception, IllegalStateException,
+                UnsupportedOperationException {
+            WriteLock writeLock = readWriteLock.writeLock();
+            writeLock.lock();
+            try {
+                pool.addObject();
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getNumIdle() {
+            ReadLock readLock = readWriteLock.readLock();
+            readLock.lock();
+            try {
+                return pool.getNumIdle();
+            } finally {
+                readLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getNumActive() {
+            ReadLock readLock = readWriteLock.readLock();
+            readLock.lock();
+            try {
+                return pool.getNumActive();
+            } finally {
+                readLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void clear() throws Exception, UnsupportedOperationException {
+            WriteLock writeLock = readWriteLock.writeLock();
+            writeLock.lock();
+            try {
+                pool.clear();
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void close() {
+            WriteLock writeLock = readWriteLock.writeLock();
+            writeLock.lock();
+            try {
+                pool.close();
+            } catch (Exception e) {
+                // swallowed as of Pool 2
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            final StringBuilder sb = new StringBuilder();
+            sb.append("SynchronizedObjectPool");
+            sb.append("{pool=").append(pool);
+            sb.append('}');
+            return sb.toString();
+        }
+    }
+
+    /**
+     * A synchronized (thread-safe) KeyedObjectPool backed by the specified
+     * KeyedObjectPool.
+     * <p>
+     * <b>Note:</b> This should not be used on pool implementations that already
+     * provide proper synchronization such as the pools provided in the Commons
+     * Pool library. Wrapping a pool that {@link #wait() waits} for poolable
+     * objects to be returned before allowing another one to be borrowed with
+     * another layer of synchronization will cause liveliness issues or a
+     * deadlock.
+     * </p>
+     */
+    private static class SynchronizedKeyedObjectPool<K, V> implements
+            KeyedObjectPool<K, V> {
+
+        /**
+         * Object whose monitor is used to synchronize methods on the wrapped
+         * pool.
+         */
+        private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
+
+        /** Underlying object pool */
+        private final KeyedObjectPool<K, V> keyedPool;
+
+        /**
+         * Create a new SynchronizedKeyedObjectPool wrapping the given pool
+         *
+         * @param keyedPool
+         *            KeyedObjectPool to wrap
+         * @throws IllegalArgumentException
+         *             if keyedPool is null
+         */
+        SynchronizedKeyedObjectPool(final KeyedObjectPool<K, V> keyedPool)
+                throws IllegalArgumentException {
+            if (keyedPool == null) {
+                throw new IllegalArgumentException(
+                        "keyedPool must not be null.");
+            }
+            this.keyedPool = keyedPool;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public V borrowObject(final K key) throws Exception,
+                NoSuchElementException, IllegalStateException {
+            WriteLock writeLock = readWriteLock.writeLock();
+            writeLock.lock();
+            try {
+                return keyedPool.borrowObject(key);
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void returnObject(final K key, final V obj) {
+            WriteLock writeLock = readWriteLock.writeLock();
+            writeLock.lock();
+            try {
+                keyedPool.returnObject(key, obj);
+            } catch (Exception e) {
+                // swallowed
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void invalidateObject(final K key, final V obj) {
+            WriteLock writeLock = readWriteLock.writeLock();
+            writeLock.lock();
+            try {
+                keyedPool.invalidateObject(key, obj);
+            } catch (Exception e) {
+                // swallowed as of Pool 2
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void addObject(final K key) throws Exception,
+                IllegalStateException, UnsupportedOperationException {
+            WriteLock writeLock = readWriteLock.writeLock();
+            writeLock.lock();
+            try {
+                keyedPool.addObject(key);
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getNumIdle(final K key) {
+            ReadLock readLock = readWriteLock.readLock();
+            readLock.lock();
+            try {
+                return keyedPool.getNumIdle(key);
+            } finally {
+                readLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getNumActive(final K key) {
+            ReadLock readLock = readWriteLock.readLock();
+            readLock.lock();
+            try {
+                return keyedPool.getNumActive(key);
+            } finally {
+                readLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getNumIdle() {
+            ReadLock readLock = readWriteLock.readLock();
+            readLock.lock();
+            try {
+                return keyedPool.getNumIdle();
+            } finally {
+                readLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getNumActive() {
+            ReadLock readLock = readWriteLock.readLock();
+            readLock.lock();
+            try {
+                return keyedPool.getNumActive();
+            } finally {
+                readLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void clear() throws Exception, UnsupportedOperationException {
+            WriteLock writeLock = readWriteLock.writeLock();
+            writeLock.lock();
+            try {
+                keyedPool.clear();
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void clear(final K key) throws Exception,
+                UnsupportedOperationException {
+            WriteLock writeLock = readWriteLock.writeLock();
+            writeLock.lock();
+            try {
+                keyedPool.clear(key);
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void close() {
+            WriteLock writeLock = readWriteLock.writeLock();
+            writeLock.lock();
+            try {
+                keyedPool.close();
+            } catch (Exception e) {
+                // swallowed as of Pool 2
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            final StringBuilder sb = new StringBuilder();
+            sb.append("SynchronizedKeyedObjectPool");
+            sb.append("{keyedPool=").append(keyedPool);
+            sb.append('}');
+            return sb.toString();
+        }
+    }
+
+    /**
+     * A fully synchronized PooledObjectFactory that wraps a
+     * PooledObjectFactory and synchronizes access to the wrapped factory
+     * methods.
+     * <p>
+     * <b>Note:</b> This should not be used on pool implementations that already
+     * provide proper synchronization such as the pools provided in the Commons
+     * Pool library.
+     * </p>
+     */
+    private static class SynchronizedPooledObjectFactory<T> implements
+            PooledObjectFactory<T> {
+        /** Synchronization lock */
+        private final WriteLock writeLock = new ReentrantReadWriteLock().writeLock();
+
+        /** Wrapped factory */
+        private final PooledObjectFactory<T> factory;
+
+        /**
+         * Create a SynchronizedPoolableObjectFactory wrapping the given
+         * factory.
+         *
+         * @param factory
+         *            underlying factory to wrap
+         * @throws IllegalArgumentException
+         *             if the factory is null
+         */
+        SynchronizedPooledObjectFactory(final PooledObjectFactory<T> factory)
+                throws IllegalArgumentException {
+            if (factory == null) {
+                throw new IllegalArgumentException("factory must not be null.");
+            }
+            this.factory = factory;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public PooledObject<T> makeObject() throws Exception {
+            writeLock.lock();
+            try {
+                return factory.makeObject();
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void destroyObject(final PooledObject<T> p) throws Exception {
+            writeLock.lock();
+            try {
+                factory.destroyObject(p);
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean validateObject(final PooledObject<T> p) {
+            writeLock.lock();
+            try {
+                return factory.validateObject(p);
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void activateObject(final PooledObject<T> p) throws Exception {
+            writeLock.lock();
+            try {
+                factory.activateObject(p);
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void passivateObject(final PooledObject<T> p) throws Exception {
+            writeLock.lock();
+            try {
+                factory.passivateObject(p);
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            final StringBuilder sb = new StringBuilder();
+            sb.append("SynchronizedPoolableObjectFactory");
+            sb.append("{factory=").append(factory);
+            sb.append('}');
+            return sb.toString();
+        }
+    }
+
+    /**
+     * A fully synchronized KeyedPooledObjectFactory that wraps a
+     * KeyedPooledObjectFactory and synchronizes access to the wrapped factory
+     * methods.
+     * <p>
+     * <b>Note:</b> This should not be used on pool implementations that already
+     * provide proper synchronization such as the pools provided in the Commons
+     * Pool library.
+     * </p>
+     */
+    private static class SynchronizedKeyedPooledObjectFactory<K, V>
+            implements KeyedPooledObjectFactory<K, V> {
+        /** Synchronization lock */
+        private final WriteLock writeLock = new ReentrantReadWriteLock().writeLock();
+
+        /** Wrapped factory */
+        private final KeyedPooledObjectFactory<K, V> keyedFactory;
+
+        /**
+         * Create a SynchronizedKeyedPoolableObjectFactory wrapping the given
+         * factory.
+         *
+         * @param keyedFactory
+         *            underlying factory to wrap
+         * @throws IllegalArgumentException
+         *             if the factory is null
+         */
+        SynchronizedKeyedPooledObjectFactory(
+                final KeyedPooledObjectFactory<K, V> keyedFactory)
+                throws IllegalArgumentException {
+            if (keyedFactory == null) {
+                throw new IllegalArgumentException(
+                        "keyedFactory must not be null.");
+            }
+            this.keyedFactory = keyedFactory;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public PooledObject<V> makeObject(final K key) throws Exception {
+            writeLock.lock();
+            try {
+                return keyedFactory.makeObject(key);
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void destroyObject(final K key, final PooledObject<V> p) throws Exception {
+            writeLock.lock();
+            try {
+                keyedFactory.destroyObject(key, p);
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean validateObject(final K key, final PooledObject<V> p) {
+            writeLock.lock();
+            try {
+                return keyedFactory.validateObject(key, p);
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void activateObject(final K key, final PooledObject<V> p) throws Exception {
+            writeLock.lock();
+            try {
+                keyedFactory.activateObject(key, p);
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void passivateObject(final K key, final PooledObject<V> p) throws Exception {
+            writeLock.lock();
+            try {
+                keyedFactory.passivateObject(key, p);
+            } finally {
+                writeLock.unlock();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            final StringBuilder sb = new StringBuilder();
+            sb.append("SynchronizedKeyedPoolableObjectFactory");
+            sb.append("{keyedFactory=").append(keyedFactory);
+            sb.append('}');
+            return sb.toString();
+        }
+    }
+
+    /**
+     * Encapsulate the logic for when the next poolable object should be
+     * discarded. Each time update is called, the next time to shrink is
+     * recomputed, based on the float factor, number of idle instances in the
+     * pool and high water mark. Float factor is assumed to be between 0 and 1.
+     * Values closer to 1 cause less frequent erosion events. Erosion event
+     * timing also depends on numIdle. When this value is relatively high (close
+     * to previously established high water mark), erosion occurs more
+     * frequently.
+     */
+    private static class ErodingFactor {
+        /** Determines frequency of "erosion" events */
+        private final float factor;
+
+        /** Time of next shrink event */
+        private transient volatile long nextShrink;
+
+        /** High water mark - largest numIdle encountered */
+        private transient volatile int idleHighWaterMark;
+
+        /**
+         * Create a new ErodingFactor with the given erosion factor.
+         *
+         * @param factor
+         *            erosion factor
+         */
+        public ErodingFactor(final float factor) {
+            this.factor = factor;
+            nextShrink = System.currentTimeMillis() + (long) (900000 * factor); // now
+                                                                                // +
+                                                                                // 15
+                                                                                // min
+                                                                                // *
+                                                                                // factor
+            idleHighWaterMark = 1;
+        }
+
+        /**
+         * Updates internal state using the supplied time and numIdle.
+         *
+         * @param now
+         *            current time
+         * @param numIdle
+         *            number of idle elements in the pool
+         */
+        public void update(final long now, final int numIdle) {
+            final int idle = Math.max(0, numIdle);
+            idleHighWaterMark = Math.max(idle, idleHighWaterMark);
+            final float maxInterval = 15f;
+            final float minutes = maxInterval +
+                    ((1f - maxInterval) / idleHighWaterMark) * idle;
+            nextShrink = now + (long) (minutes * 60000f * factor);
+        }
+
+        /**
+         * Returns the time of the next erosion event.
+         *
+         * @return next shrink time
+         */
+        public long getNextShrink() {
+            return nextShrink;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return "ErodingFactor{" + "factor=" + factor +
+                    ", idleHighWaterMark=" + idleHighWaterMark + '}';
+        }
+    }
+
+    /**
+     * Decorates an object pool, adding "eroding" behavior. Based on the
+     * configured {@link #factor erosion factor}, objects returning to the pool
+     * may be invalidated instead of being added to idle capacity.
+     */
+    private static class ErodingObjectPool<T> implements ObjectPool<T> {
+        /** Underlying object pool */
+        private final ObjectPool<T> pool;
+
+        /** Erosion factor */
+        private final ErodingFactor factor;
+
+        /**
+         * Create an ErodingObjectPool wrapping the given pool using the
+         * specified erosion factor.
+         *
+         * @param pool
+         *            underlying pool
+         * @param factor
+         *            erosion factor - determines the frequency of erosion
+         *            events
+         * @see #factor
+         */
+        public ErodingObjectPool(final ObjectPool<T> pool, final float factor) {
+            this.pool = pool;
+            this.factor = new ErodingFactor(factor);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public T borrowObject() throws Exception, NoSuchElementException,
+                IllegalStateException {
+            return pool.borrowObject();
+        }
+
+        /**
+         * Returns obj to the pool, unless erosion is triggered, in which case
+         * obj is invalidated. Erosion is triggered when there are idle
+         * instances in the pool and more than the {@link #factor erosion
+         * factor}-determined time has elapsed since the last returnObject
+         * activation.
+         *
+         * @param obj
+         *            object to return or invalidate
+         * @see #factor
+         */
+        @Override
+        public void returnObject(final T obj) {
+            boolean discard = false;
+            final long now = System.currentTimeMillis();
+            synchronized (pool) {
+                if (factor.getNextShrink() < now) { // XXX: Pool 3: move test
+                                                    // out of sync block
+                    final int numIdle = pool.getNumIdle();
+                    if (numIdle > 0) {
+                        discard = true;
+                    }
+
+                    factor.update(now, numIdle);
+                }
+            }
+            try {
+                if (discard) {
+                    pool.invalidateObject(obj);
+                } else {
+                    pool.returnObject(obj);
+                }
+            } catch (Exception e) {
+                // swallowed
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void invalidateObject(final T obj) {
+            try {
+                pool.invalidateObject(obj);
+            } catch (Exception e) {
+                // swallowed
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void addObject() throws Exception, IllegalStateException,
+                UnsupportedOperationException {
+            pool.addObject();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getNumIdle() {
+            return pool.getNumIdle();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getNumActive() {
+            return pool.getNumActive();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void clear() throws Exception, UnsupportedOperationException {
+            pool.clear();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void close() {
+            try {
+                pool.close();
+            } catch (Exception e) {
+                // swallowed
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return "ErodingObjectPool{" + "factor=" + factor + ", pool=" +
+                    pool + '}';
+        }
+    }
+
+    /**
+     * Decorates a keyed object pool, adding "eroding" behavior. Based on the
+     * configured erosion factor, objects returning to the pool
+     * may be invalidated instead of being added to idle capacity.
+     */
+    private static class ErodingKeyedObjectPool<K, V> implements
+            KeyedObjectPool<K, V> {
+        /** Underlying pool */
+        private final KeyedObjectPool<K, V> keyedPool;
+
+        /** Erosion factor */
+        private final ErodingFactor erodingFactor;
+
+        /**
+         * Create an ErodingObjectPool wrapping the given pool using the
+         * specified erosion factor.
+         *
+         * @param keyedPool
+         *            underlying pool
+         * @param factor
+         *            erosion factor - determines the frequency of erosion
+         *            events
+         * @see #erodingFactor
+         */
+        public ErodingKeyedObjectPool(final KeyedObjectPool<K, V> keyedPool,
+                final float factor) {
+            this(keyedPool, new ErodingFactor(factor));
+        }
+
+        /**
+         * Create an ErodingObjectPool wrapping the given pool using the
+         * specified erosion factor.
+         *
+         * @param keyedPool
+         *            underlying pool - must not be null
+         * @param erodingFactor
+         *            erosion factor - determines the frequency of erosion
+         *            events
+         * @see #factor
+         */
+        protected ErodingKeyedObjectPool(final KeyedObjectPool<K, V> keyedPool,
+                final ErodingFactor erodingFactor) {
+            if (keyedPool == null) {
+                throw new IllegalArgumentException(
+                        "keyedPool must not be null.");
+            }
+            this.keyedPool = keyedPool;
+            this.erodingFactor = erodingFactor;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public V borrowObject(final K key) throws Exception,
+                NoSuchElementException, IllegalStateException {
+            return keyedPool.borrowObject(key);
+        }
+
+        /**
+         * Returns obj to the pool, unless erosion is triggered, in which case
+         * obj is invalidated. Erosion is triggered when there are idle
+         * instances in the pool associated with the given key and more than the
+         * configured {@link #erodingFactor erosion factor} time has elapsed
+         * since the last returnObject activation.
+         *
+         * @param obj
+         *            object to return or invalidate
+         * @param key
+         *            key
+         * @see #erodingFactor
+         */
+        @Override
+        public void returnObject(final K key, final V obj) throws Exception {
+            boolean discard = false;
+            final long now = System.currentTimeMillis();
+            final ErodingFactor factor = getErodingFactor(key);
+            synchronized (keyedPool) {
+                if (factor.getNextShrink() < now) {
+                    final int numIdle = getNumIdle(key);
+                    if (numIdle > 0) {
+                        discard = true;
+                    }
+
+                    factor.update(now, numIdle);
+                }
+            }
+            try {
+                if (discard) {
+                    keyedPool.invalidateObject(key, obj);
+                } else {
+                    keyedPool.returnObject(key, obj);
+                }
+            } catch (Exception e) {
+                // swallowed
+            }
+        }
+
+        /**
+         * Returns the eroding factor for the given key
+         *
+         * @param key
+         *            key
+         * @return eroding factor for the given keyed pool
+         */
+        protected ErodingFactor getErodingFactor(final K key) {
+            return erodingFactor;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void invalidateObject(final K key, final V obj) {
+            try {
+                keyedPool.invalidateObject(key, obj);
+            } catch (Exception e) {
+                // swallowed
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void addObject(final K key) throws Exception,
+                IllegalStateException, UnsupportedOperationException {
+            keyedPool.addObject(key);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getNumIdle() {
+            return keyedPool.getNumIdle();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getNumIdle(final K key) {
+            return keyedPool.getNumIdle(key);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getNumActive() {
+            return keyedPool.getNumActive();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getNumActive(final K key) {
+            return keyedPool.getNumActive(key);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void clear() throws Exception, UnsupportedOperationException {
+            keyedPool.clear();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void clear(final K key) throws Exception,
+                UnsupportedOperationException {
+            keyedPool.clear(key);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void close() {
+            try {
+                keyedPool.close();
+            } catch (Exception e) {
+                // swallowed
+            }
+        }
+
+        /**
+         * Returns the underlying pool
+         *
+         * @return the keyed pool that this ErodingKeyedObjectPool wraps
+         */
+        protected KeyedObjectPool<K, V> getKeyedPool() {
+            return keyedPool;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return "ErodingKeyedObjectPool{" + "factor=" +
+                    erodingFactor + ", keyedPool=" + keyedPool + '}';
+        }
+    }
+
+    /**
+     * Extends ErodingKeyedObjectPool to allow erosion to take place on a
+     * per-key basis. Timing of erosion events is tracked separately for
+     * separate keyed pools.
+     */
+    private static class ErodingPerKeyKeyedObjectPool<K, V> extends
+            ErodingKeyedObjectPool<K, V> {
+        /** Erosion factor - same for all pools */
+        private final float factor;
+
+        /** Map of ErodingFactor instances keyed on pool keys */
+        private final Map<K, ErodingFactor> factors = Collections.synchronizedMap(new HashMap<K, ErodingFactor>());
+
+        /**
+         * Create a new ErordingPerKeyKeyedObjectPool decorating the given keyed
+         * pool with the specified erosion factor.
+         *
+         * @param keyedPool
+         *            underlying keyed pool
+         * @param factor
+         *            erosion factor
+         */
+        public ErodingPerKeyKeyedObjectPool(
+                final KeyedObjectPool<K, V> keyedPool, final float factor) {
+            super(keyedPool, null);
+            this.factor = factor;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        protected ErodingFactor getErodingFactor(final K key) {
+            ErodingFactor eFactor = factors.get(key);
+            // this may result in two ErodingFactors being created for a key
+            // since they are small and cheap this is okay.
+            if (eFactor == null) {
+                eFactor = new ErodingFactor(this.factor);
+                factors.put(key, eFactor);
+            }
+            return eFactor;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return "ErodingPerKeyKeyedObjectPool{" + "factor=" + factor +
+                    ", keyedPool=" + getKeyedPool() + '}';
+        }
+    }
+}
\ No newline at end of file

==================================================
PooledObjectFactory.java
new file mode 100644
index 0000000000..591a5f8782
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/PooledObject.java
@@ -0,0 +1,208 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2;
+
+import java.io.PrintWriter;
+import java.util.Deque;
+
+/**
+ * Defines the wrapper that is used to track the additional information, such as
+ * state, for the pooled objects.
+ * <p>
+ * Implementations of this class are required to be thread-safe.
+ *
+ * @param <T> the type of object in the pool
+ *
+ * @version $Revision: $
+ *
+ * @since 2.0
+ */
+public interface PooledObject<T> extends Comparable<PooledObject<T>> {
+
+    /**
+     * Obtain the underlying object that is wrapped by this instance of
+     * {@link PooledObject}.
+     *
+     * @return The wrapped object
+     */
+    T getObject();
+
+    /**
+     * Obtain the time (using the same basis as
+     * {@link System#currentTimeMillis()}) that this object was created.
+     *
+     * @return The creation time for the wrapped object
+     */
+    long getCreateTime();
+
+    /**
+     * Obtain the time in milliseconds that this object last spent in the the
+     * active state (it may still be active in which case subsequent calls will
+     * return an increased value).
+     *
+     * @return The time in milliseconds last spent in the active state
+     */
+    long getActiveTimeMillis();
+
+    /**
+     * Obtain the time in milliseconds that this object last spend in the the
+     * idle state (it may still be idle in which case subsequent calls will
+     * return an increased value).
+     *
+     * @return The time in milliseconds last spent in the idle state
+     */
+    long getIdleTimeMillis();
+
+    /**
+     * Obtain the time the wrapped object was last borrowed.
+     *
+     * @return The time the object was last borrowed
+     */
+    long getLastBorrowTime();
+
+    /**
+     * Obtain the time the wrapped object was last returned.
+     *
+     * @return The time the object was last returned
+     */
+    long getLastReturnTime();
+
+    /**
+     * Return an estimate of the last time this object was used.  If the class
+     * of the pooled object implements {@link TrackedUse}, what is returned is
+     * the maximum of {@link TrackedUse#getLastUsed()} and
+     * {@link #getLastBorrowTime()}; otherwise this method gives the same
+     * value as {@link #getLastBorrowTime()}.
+     *
+     * @return the last time this object was used
+     */
+    long getLastUsedTime();
+
+    /**
+     * Orders instances based on idle time - i.e. the length of time since the
+     * instance was returned to the pool. Used by the GKOP idle object evictor.
+     *<p>
+     * Note: This class has a natural ordering that is inconsistent with
+     *       equals if distinct objects have the same identity hash code.
+     * <p>
+     * {@inheritDoc}
+     */
+    @Override
+    int compareTo(PooledObject<T> other);
+
+    @Override
+    boolean equals(Object obj);
+
+    @Override
+    int hashCode();
+
+    /**
+     * Provides a String form of the wrapper for debug purposes. The format is
+     * not fixed and may change at any time.
+     * <p>
+     * {@inheritDoc}
+     */
+    @Override
+    String toString();
+
+    /**
+     * Attempt to place the pooled object in the
+     * {@link PooledObjectState#EVICTION} state.
+     *
+     * @return <code>true</code> if the object was placed in the
+     *         {@link PooledObjectState#EVICTION} state otherwise
+     *         <code>false</code>
+     */
+    boolean startEvictionTest();
+
+    /**
+     * Called to inform the object that the eviction test has ended.
+     *
+     * @param idleQueue The queue of idle objects to which the object should be
+     *                  returned
+     *
+     * @return  Currently not used
+     */
+    boolean endEvictionTest(Deque<PooledObject<T>> idleQueue);
+
+    /**
+     * Allocates the object.
+     *
+     * @return {@code true} if the original state was {@link PooledObjectState#IDLE IDLE}
+     */
+    boolean allocate();
+
+    /**
+     * Deallocates the object and sets it {@link PooledObjectState#IDLE IDLE}
+     * if it is currently {@link PooledObjectState#ALLOCATED ALLOCATED}.
+     *
+     * @return {@code true} if the state was {@link PooledObjectState#ALLOCATED ALLOCATED}
+     */
+    boolean deallocate();
+
+    /**
+     * Sets the state to {@link PooledObjectState#INVALID INVALID}
+     */
+    void invalidate();
+
+    /**
+     * Is abandoned object tracking being used? If this is true the
+     * implementation will need to record the stack trace of the last caller to
+     * borrow this object.
+     *
+     * @param   logAbandoned    The new configuration setting for abandoned
+     *                          object tracking
+     */
+    void setLogAbandoned(boolean logAbandoned);
+
+    /**
+     * Record the current stack trace as the last time the object was used.
+     */
+    void use();
+
+    /**
+     * Prints the stack trace of the code that borrowed this pooled object and
+     * the stack trace of the last code to use this object (if available) to
+     * the supplied writer.
+     *
+     * @param   writer  The destination for the debug output
+     */
+    void printStackTrace(PrintWriter writer);
+
+    /**
+     * Returns the state of this object.
+     * @return state
+     */
+    PooledObjectState getState();
+
+    /**
+     * Marks the pooled object as abandoned.
+     */
+    void markAbandoned();
+
+    /**
+     * Marks the object as returning to the pool.
+     */
+    void markReturning();
+
+    // TODO: Uncomment this for version 3 (can't add it to 2.x as it will break
+    //       API compatibility)
+    ///**
+    // * Get the number of times this object has been borrowed.
+    // */
+    //long getBorrowedCount();
+}

==================================================
PooledObjectState.java
new file mode 100644
index 0000000000..519401eb6d
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/PooledObjectFactory.java
@@ -0,0 +1,139 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2;
+
+/**
+ * An interface defining life-cycle methods for instances to be served by an
+ * {@link ObjectPool}.
+ * <p>
+ * By contract, when an {@link ObjectPool} delegates to a
+ * {@link PooledObjectFactory},
+ * <ol>
+ *  <li>
+ *   {@link #makeObject} is called whenever a new instance is needed.
+ *  </li>
+ *  <li>
+ *   {@link #activateObject} is invoked on every instance that has been
+ *   {@link #passivateObject passivated} before it is
+ *   {@link ObjectPool#borrowObject borrowed} from the pool.
+ *  </li>
+ *  <li>
+ *   {@link #validateObject} may be invoked on {@link #activateObject activated}
+ *   instances to make sure they can be {@link ObjectPool#borrowObject borrowed}
+ *   from the pool. {@link #validateObject} may also be used to
+ *   test an instance being {@link ObjectPool#returnObject returned} to the pool
+ *   before it is {@link #passivateObject passivated}. It will only be invoked
+ *   on an activated instance.
+ *  </li>
+ *  <li>
+ *   {@link #passivateObject} is invoked on every instance when it is returned
+ *   to the pool.
+ *  </li>
+ *  <li>
+ *   {@link #destroyObject} is invoked on every instance when it is being
+ *   "dropped" from the pool (whether due to the response from
+ *   {@link #validateObject}, or for reasons specific to the pool
+ *   implementation.) There is no guarantee that the instance being destroyed
+ *   will be considered active, passive or in a generally consistent state.
+ *  </li>
+ * </ol>
+ * {@link PooledObjectFactory} must be thread-safe. The only promise
+ * an {@link ObjectPool} makes is that the same instance of an object will not
+ * be passed to more than one method of a <code>PoolableObjectFactory</code>
+ * at a time.
+ * <p>
+ * While clients of a {@link KeyedObjectPool} borrow and return instances of
+ * the underlying value type {@code V}, the factory methods act on instances of
+ * {@link PooledObject PooledObject&lt;V&gt;}.  These are the object wrappers that
+ * pools use to track and maintain state information about the objects that
+ * they manage.
+ *
+ * @param <T> Type of element managed in this factory.
+ *
+ * @see ObjectPool
+ *
+ * @version $Revision: 1333925 $
+ *
+ * @since 2.0
+ */
+public interface PooledObjectFactory<T> {
+  /**
+   * Create an instance that can be served by the pool and wrap it in a
+   * {@link PooledObject} to be managed by the pool.
+   *
+   * @return a {@code PooledObject} wrapping an instance that can be served by the pool
+   *
+   * @throws Exception if there is a problem creating a new instance,
+   *    this will be propagated to the code requesting an object.
+   */
+  PooledObject<T> makeObject() throws Exception;
+
+  /**
+   * Destroys an instance no longer needed by the pool.
+   * <p>
+   * It is important for implementations of this method to be aware that there
+   * is no guarantee about what state <code>obj</code> will be in and the
+   * implementation should be prepared to handle unexpected errors.
+   * <p>
+   * Also, an implementation must take in to consideration that instances lost
+   * to the garbage collector may never be destroyed.
+   * </p>
+   *
+   * @param p a {@code PooledObject} wrapping the instance to be destroyed
+   *
+   * @throws Exception should be avoided as it may be swallowed by
+   *    the pool implementation.
+   *
+   * @see #validateObject
+   * @see ObjectPool#invalidateObject
+   */
+  void destroyObject(PooledObject<T> p) throws Exception;
+
+  /**
+   * Ensures that the instance is safe to be returned by the pool.
+   *
+   * @param p a {@code PooledObject} wrapping the instance to be validated
+   *
+   * @return <code>false</code> if <code>obj</code> is not valid and should
+   *         be dropped from the pool, <code>true</code> otherwise.
+   */
+  boolean validateObject(PooledObject<T> p);
+
+  /**
+   * Reinitialize an instance to be returned by the pool.
+   *
+   * @param p a {@code PooledObject} wrapping the instance to be activated
+   *
+   * @throws Exception if there is a problem activating <code>obj</code>,
+   *    this exception may be swallowed by the pool.
+   *
+   * @see #destroyObject
+   */
+  void activateObject(PooledObject<T> p) throws Exception;
+
+  /**
+   * Uninitialize an instance to be returned to the idle object pool.
+   *
+   * @param p a {@code PooledObject} wrapping the instance to be passivated
+   *
+   * @throws Exception if there is a problem passivating <code>obj</code>,
+   *    this exception may be swallowed by the pool.
+   *
+   * @see #destroyObject
+   */
+  void passivateObject(PooledObject<T> p) throws Exception;
+}

==================================================
SwallowedExceptionListener.java
new file mode 100644
index 0000000000..5d7c632074
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/PooledObjectState.java
@@ -0,0 +1,88 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2;
+
+/**
+ * Provides the possible states that a {@link PooledObject} may be in.
+ *
+ * @version $Revision: $
+ *
+ * @since 2.0
+ */
+public enum PooledObjectState {
+    /**
+     * In the queue, not in use.
+     */
+    IDLE,
+
+    /**
+     * In use.
+     */
+    ALLOCATED,
+
+    /**
+     * In the queue, currently being tested for possible eviction.
+     */
+    EVICTION,
+
+    /**
+     * Not in the queue, currently being tested for possible eviction. An
+     * attempt to borrow the object was made while being tested which removed it
+     * from the queue. It should be returned to the head of the queue once
+     * eviction testing completes.
+     * TODO: Consider allocating object and ignoring the result of the eviction
+     *       test.
+     */
+    EVICTION_RETURN_TO_HEAD,
+
+    /**
+     * In the queue, currently being validated.
+     */
+    VALIDATION,
+
+    /**
+     * Not in queue, currently being validated. The object was borrowed while
+     * being validated and since testOnBorrow was configured, it was removed
+     * from the queue and pre-allocated. It should be allocated once validation
+     * completes.
+     */
+    VALIDATION_PREALLOCATED,
+
+    /**
+     * Not in queue, currently being validated. An attempt to borrow the object
+     * was made while previously being tested for eviction which removed it from
+     * the queue. It should be returned to the head of the queue once validation
+     * completes.
+     */
+    VALIDATION_RETURN_TO_HEAD,
+
+    /**
+     * Failed maintenance (e.g. eviction test or validation) and will be / has
+     * been destroyed
+     */
+    INVALID,
+
+    /**
+     * Deemed abandoned, to be invalidated.
+     */
+    ABANDONED,
+
+    /**
+     * Returning to the pool.
+     */
+    RETURNING
+}

==================================================
TrackedUse.java
new file mode 100644
index 0000000000..53995c1c28
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/SwallowedExceptionListener.java
@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2;
+
+/**
+ * Pools that unavoidably swallow exceptions may be configured with an instance
+ * of this listener so the user may receive notification of when this happens.
+ * The listener should not throw an exception when called but pools calling
+ * listeners should protect themselves against exceptions anyway.
+ *
+ * @since 2.0
+ */
+public interface SwallowedExceptionListener {
+
+    /**
+     * This method is called every time the implementation unavoidably swallows
+     * an exception.
+     *
+     * @param e The exception that was swallowed
+     */
+    void onSwallowException(Exception e);
+}

==================================================
UsageTracking.java
new file mode 100644
index 0000000000..5166a022ef
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/TrackedUse.java
@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2;
+
+/**
+ * This interface allows pooled objects to make information available about when
+ * and how they were used available to the object pool. The object pool may, but
+ * is not required, to use this information to make more informed decisions when
+ * determining the state of a pooled object - for instance whether or not the
+ * object has been abandoned.
+ *
+ * @version $Revision:$
+ *
+ * @since 2.0
+ */
+public interface TrackedUse {
+
+    /**
+     * Get the last time this object was used in ms.
+     *
+     * @return long time in ms
+     */
+    long getLastUsed();
+}

==================================================
AbandonedConfig.java
new file mode 100644
index 0000000000..8b2dd4aa7f
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/UsageTracking.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2;
+
+/**
+ * This interface may be implemented by an object pool to enable clients
+ * (primarily those clients that wrap pools to provide pools with extended
+ * features) to provide additional information to the pool relating to object
+ * using allowing more informed decisions and reporting to be made regarding
+ * abandoned objects.
+ *
+ * @param <T>   The type of object provided by the pool.
+ *
+ * @since 2.0
+ */
+public interface UsageTracking<T> {
+
+    /**
+     * This method is called every time a pooled object to enable the pool to
+     * better track borrowed objects.
+     *
+     * @param pooledObject  The object that is being used
+     */
+    void use(T pooledObject);
+}

==================================================
BaseGenericObjectPool.java
new file mode 100644
index 0000000000..d962ba77a0
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/AbandonedConfig.java
@@ -0,0 +1,234 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.pool2.impl;
+
+import java.io.PrintWriter;
+
+/**
+ * Configuration settings for abandoned object removal.
+ *
+ * @version $Revision:$
+ *
+ * @since 2.0
+ */
+public class AbandonedConfig {
+
+    /**
+     * Whether or not borrowObject performs abandoned object removal.
+     */
+    private boolean removeAbandonedOnBorrow = false;
+
+    /**
+     * <p>Flag to remove abandoned objects if they exceed the
+     * removeAbandonedTimeout when borrowObject is invoked.</p>
+     *
+     * <p>The default value is false.</p>
+     *
+     * <p>If set to true, abandoned objects are removed by borrowObject if
+     * there are fewer than 2 idle objects available in the pool and
+     * <code>getNumActive() &gt; getMaxTotal() - 3</code></p>
+     *
+     * @return true if abandoned objects are to be removed by borrowObject
+     */
+    public boolean getRemoveAbandonedOnBorrow() {
+        return (this.removeAbandonedOnBorrow);
+    }
+
+    /**
+     * <p>Flag to remove abandoned objects if they exceed the
+     * removeAbandonedTimeout when borrowObject is invoked.</p>
+     *
+     * @param removeAbandonedOnBorrow true means abandoned objects will be
+     *   removed by borrowObject
+     * @see #getRemoveAbandonedOnBorrow()
+     */
+    public void setRemoveAbandonedOnBorrow(boolean removeAbandonedOnBorrow) {
+        this.removeAbandonedOnBorrow = removeAbandonedOnBorrow;
+    }
+
+    /**
+     * Whether or not pool maintenance (evictor) performs abandoned object
+     * removal.
+     */
+    private boolean removeAbandonedOnMaintenance = false;
+
+    /**
+     * <p>Flag to remove abandoned objects if they exceed the
+     * removeAbandonedTimeout when pool maintenance (the "evictor")
+     * runs.</p>
+     *
+     * <p>The default value is false.</p>
+     *
+     * <p>If set to true, abandoned objects are removed by the pool
+     * maintenance thread when it runs.  This setting has no effect
+     * unless maintenance is enabled by setting
+     *{@link GenericObjectPool#getTimeBetweenEvictionRunsMillis() timeBetweenEvictionRunsMillis}
+     * to a positive number.</p>
+     *
+     * @return true if abandoned objects are to be removed by the evictor
+     */
+    public boolean getRemoveAbandonedOnMaintenance() {
+        return (this.removeAbandonedOnMaintenance);
+    }
+
+    /**
+     * <p>Flag to remove abandoned objects if they exceed the
+     * removeAbandonedTimeout when pool maintenance runs.</p>
+     *
+     * @param removeAbandonedOnMaintenance true means abandoned objects will be
+     *   removed by pool maintenance
+     * @see #getRemoveAbandonedOnMaintenance
+     */
+    public void setRemoveAbandonedOnMaintenance(boolean removeAbandonedOnMaintenance) {
+        this.removeAbandonedOnMaintenance = removeAbandonedOnMaintenance;
+    }
+
+    /**
+     * Timeout in seconds before an abandoned object can be removed.
+     */
+    private int removeAbandonedTimeout = 300;
+
+    /**
+     * <p>Timeout in seconds before an abandoned object can be removed.</p>
+     *
+     * <p>The time of most recent use of an object is the maximum (latest) of
+     * {@link org.apache.tomcat.dbcp.pool2.TrackedUse#getLastUsed()}
+     * (if this class of the object implements
+     * TrackedUse) and the time when the object was borrowed from the pool.</p>
+     *
+     * <p>The default value is 300 seconds.</p>
+     *
+     * @return the abandoned object timeout in seconds
+     */
+    public int getRemoveAbandonedTimeout() {
+        return (this.removeAbandonedTimeout);
+    }
+
+    /**
+     * <p>Sets the timeout in seconds before an abandoned object can be
+     * removed</p>
+     *
+     * <p>Setting this property has no effect if
+     * {@link #getRemoveAbandonedOnBorrow() removeAbandonedOnBorrow} and
+     * {@link #getRemoveAbandonedOnMaintenance() removeAbandonedOnMaintenance}
+     * are both false.</p>
+     *
+     * @param removeAbandonedTimeout new abandoned timeout in seconds
+     * @see #getRemoveAbandonedTimeout()
+     */
+    public void setRemoveAbandonedTimeout(int removeAbandonedTimeout) {
+        this.removeAbandonedTimeout = removeAbandonedTimeout;
+    }
+
+    /**
+     * Determines whether or not to log stack traces for application code
+     * which abandoned an object.
+     */
+    private boolean logAbandoned = false;
+
+    /**
+     * Flag to log stack traces for application code which abandoned
+     * an object.
+     *
+     * Defaults to false.
+     * Logging of abandoned objects adds overhead for every object created
+     * because a stack trace has to be generated.
+     *
+     * @return boolean true if stack trace logging is turned on for abandoned
+     * objects
+     *
+     */
+    public boolean getLogAbandoned() {
+        return (this.logAbandoned);
+    }
+
+    /**
+     * Sets the flag to log stack traces for application code which abandoned
+     * an object.
+     *
+     * @param logAbandoned true turns on abandoned stack trace logging
+     * @see #getLogAbandoned()
+     *
+     */
+    public void setLogAbandoned(boolean logAbandoned) {
+        this.logAbandoned = logAbandoned;
+    }
+
+    /**
+     * PrintWriter to use to log information on abandoned objects.
+     * Use of default system encoding is deliberate.
+     */
+    private PrintWriter logWriter = new PrintWriter(System.out);
+
+    /**
+     * Returns the log writer being used by this configuration to log
+     * information on abandoned objects. If not set, a PrintWriter based on
+     * System.out with the system default encoding is used.
+     *
+     * @return log writer in use
+     */
+    public PrintWriter getLogWriter() {
+        return logWriter;
+    }
+
+    /**
+     * Sets the log writer to be used by this configuration to log
+     * information on abandoned objects.
+     *
+     * @param logWriter The new log writer
+     */
+    public void setLogWriter(PrintWriter logWriter) {
+        this.logWriter = logWriter;
+    }
+
+    /**
+     * If the pool implements {@link UsageTracking}, should the pool record a
+     * stack trace every time a method is called on a pooled object and retain
+     * the most recent stack trace to aid debugging of abandoned objects?
+     */
+    private boolean useUsageTracking = false;
+
+    /**
+     * If the pool implements
+     * {@link org.apache.tomcat.dbcp.pool2.UsageTracking}, should the pool
+     * record a
+     * stack trace every time a method is called on a pooled object and retain
+     * the most recent stack trace to aid debugging of abandoned objects?
+     *
+     * @return <code>true</code> if usage tracking is enabled
+     */
+    public boolean getUseUsageTracking() {
+        return useUsageTracking;
+    }
+
+    /**
+     * If the pool implements
+     * {@link org.apache.tomcat.dbcp.pool2.UsageTracking}, configure whether the
+     * pool
+     * should record a stack trace every time a method is called on a pooled
+     * object and retain the most recent stack trace to aid debugging of
+     * abandoned objects.
+     *
+     * @param   useUsageTracking    A value of <code>true</code> will enable
+     *                              the recording of a stack trace on every use
+     *                              of a pooled object
+     */
+    public void setUseUsageTracking(boolean useUsageTracking) {
+        this.useUsageTracking = useUsageTracking;
+    }
+}

==================================================
BaseObjectPoolConfig.java
new file mode 100644
index 0000000000..8e950840c8
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/BaseGenericObjectPool.java
@@ -0,0 +1,1050 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.lang.management.ManagementFactory;
+import java.util.Iterator;
+import java.util.TimerTask;
+import java.util.concurrent.atomic.AtomicLong;
+
+import javax.management.InstanceAlreadyExistsException;
+import javax.management.InstanceNotFoundException;
+import javax.management.MBeanRegistrationException;
+import javax.management.MBeanServer;
+import javax.management.MalformedObjectNameException;
+import javax.management.NotCompliantMBeanException;
+import javax.management.ObjectName;
+
+import org.apache.tomcat.dbcp.pool2.PooledObject;
+import org.apache.tomcat.dbcp.pool2.SwallowedExceptionListener;
+
+/**
+ * Base class that provides common functionality for {@link GenericObjectPool}
+ * and {@link GenericKeyedObjectPool}. The primary reason this class exists is
+ * reduce code duplication between the two pool implementations.
+ *
+ * @param <T> Type of element pooled in this pool.
+ *
+ * This class is intended to be thread-safe.
+ *
+ * @version $Revision: $
+ *
+ * @since 2.0
+ */
+public abstract class BaseGenericObjectPool<T> {
+
+    // Constants
+    /**
+     * The size of the caches used to store historical data for some attributes
+     * so that rolling means may be calculated.
+     */
+    public static final int MEAN_TIMING_STATS_CACHE_SIZE = 100;
+
+    // Configuration attributes
+    private volatile int maxTotal =
+            GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL;
+    private volatile boolean blockWhenExhausted =
+            BaseObjectPoolConfig.DEFAULT_BLOCK_WHEN_EXHAUSTED;
+    private volatile long maxWaitMillis =
+            BaseObjectPoolConfig.DEFAULT_MAX_WAIT_MILLIS;
+    private volatile boolean lifo = BaseObjectPoolConfig.DEFAULT_LIFO;
+    private volatile boolean testOnCreate =
+            BaseObjectPoolConfig.DEFAULT_TEST_ON_CREATE;
+    private volatile boolean testOnBorrow =
+            BaseObjectPoolConfig.DEFAULT_TEST_ON_BORROW;
+    private volatile boolean testOnReturn =
+            BaseObjectPoolConfig.DEFAULT_TEST_ON_RETURN;
+    private volatile boolean testWhileIdle =
+            BaseObjectPoolConfig.DEFAULT_TEST_WHILE_IDLE;
+    private volatile long timeBetweenEvictionRunsMillis =
+            BaseObjectPoolConfig.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
+    private volatile int numTestsPerEvictionRun =
+            BaseObjectPoolConfig.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
+    private volatile long minEvictableIdleTimeMillis =
+            BaseObjectPoolConfig.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
+    private volatile long softMinEvictableIdleTimeMillis =
+            BaseObjectPoolConfig.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
+    private volatile EvictionPolicy<T> evictionPolicy;
+
+
+    // Internal (primarily state) attributes
+    final Object closeLock = new Object();
+    volatile boolean closed = false;
+    final Object evictionLock = new Object();
+    private Evictor evictor = null; // @GuardedBy("evictionLock")
+    Iterator<PooledObject<T>> evictionIterator = null; // @GuardedBy("evictionLock")
+    /*
+     * Class loader for evictor thread to use since in a J2EE or similar
+     * environment the context class loader for the evictor thread may have
+     * visibility of the correct factory. See POOL-161.
+     */
+    private final ClassLoader factoryClassLoader;
+
+
+    // Monitoring (primarily JMX) attributes
+    private final ObjectName oname;
+    private final String creationStackTrace;
+    private final AtomicLong borrowedCount = new AtomicLong(0);
+    private final AtomicLong returnedCount = new AtomicLong(0);
+    final AtomicLong createdCount = new AtomicLong(0);
+    final AtomicLong destroyedCount = new AtomicLong(0);
+    final AtomicLong destroyedByEvictorCount = new AtomicLong(0);
+    final AtomicLong destroyedByBorrowValidationCount = new AtomicLong(0);
+    private final StatsStore activeTimes = new StatsStore(MEAN_TIMING_STATS_CACHE_SIZE);
+    private final StatsStore idleTimes = new StatsStore(MEAN_TIMING_STATS_CACHE_SIZE);
+    private final StatsStore waitTimes = new StatsStore(MEAN_TIMING_STATS_CACHE_SIZE);
+    private final Object maxBorrowWaitTimeMillisLock = new Object();
+    private volatile long maxBorrowWaitTimeMillis = 0; // @GuardedBy("maxBorrowWaitTimeMillisLock")
+    private SwallowedExceptionListener swallowedExceptionListener = null;
+
+
+    /**
+     * Handles JMX registration (if required) and the initialization required for
+     * monitoring.
+     *
+     * @param config        Pool configuration
+     * @param jmxNameBase   The default base JMX name for the new pool unless
+     *                      overridden by the config
+     * @param jmxNamePrefix Prefix to be used for JMX name for the new pool
+     */
+    public BaseGenericObjectPool(BaseObjectPoolConfig config,
+            String jmxNameBase, String jmxNamePrefix) {
+        if (config.getJmxEnabled()) {
+            this.oname = jmxRegister(config, jmxNameBase, jmxNamePrefix);
+        } else {
+            this.oname = null;
+        }
+
+        // Populate the creation stack trace
+        this.creationStackTrace = getStackTrace(new Exception());
+
+        // save the current CCL to be used later by the evictor Thread
+        factoryClassLoader = Thread.currentThread().getContextClassLoader();
+    }
+
+
+    /**
+     * Returns the maximum number of objects that can be allocated by the pool
+     * (checked out to clients, or idle awaiting checkout) at a given time. When
+     * negative, there is no limit to the number of objects that can be
+     * managed by the pool at one time.
+     *
+     * @return the cap on the total number of object instances managed by the
+     *         pool.
+     *
+     * @see #setMaxTotal
+     */
+    public final int getMaxTotal() {
+        return maxTotal;
+    }
+
+    /**
+     * Sets the cap on the number of objects that can be allocated by the pool
+     * (checked out to clients, or idle awaiting checkout) at a given time. Use
+     * a negative value for no limit.
+     *
+     * @param maxTotal  The cap on the total number of object instances managed
+     *                  by the pool. Negative values mean that there is no limit
+     *                  to the number of objects allocated by the pool.
+     *
+     * @see #getMaxTotal
+     */
+    public final void setMaxTotal(int maxTotal) {
+        this.maxTotal = maxTotal;
+    }
+
+    /**
+     * Returns whether to block when the <code>borrowObject()</code> method is
+     * invoked when the pool is exhausted (the maximum number of "active"
+     * objects has been reached).
+     *
+     * @return <code>true</code> if <code>borrowObject()</code> should block
+     *         when the pool is exhausted
+     *
+     * @see #setBlockWhenExhausted
+     */
+    public final boolean getBlockWhenExhausted() {
+        return blockWhenExhausted;
+    }
+
+    /**
+     * Sets whether to block when the <code>borrowObject()</code> method is
+     * invoked when the pool is exhausted (the maximum number of "active"
+     * objects has been reached).
+     *
+     * @param blockWhenExhausted    <code>true</code> if
+     *                              <code>borrowObject()</code> should block
+     *                              when the pool is exhausted
+     *
+     * @see #getBlockWhenExhausted
+     */
+    public final void setBlockWhenExhausted(boolean blockWhenExhausted) {
+        this.blockWhenExhausted = blockWhenExhausted;
+    }
+
+    /**
+     * Returns the maximum amount of time (in milliseconds) the
+     * <code>borrowObject()</code> method should block before throwing an
+     * exception when the pool is exhausted and
+     * {@link #getBlockWhenExhausted} is true. When less than 0, the
+     * <code>borrowObject()</code> method may block indefinitely.
+     *
+     * @return the maximum number of milliseconds <code>borrowObject()</code>
+     *         will block.
+     *
+     * @see #setMaxWaitMillis
+     * @see #setBlockWhenExhausted
+     */
+    public final long getMaxWaitMillis() {
+        return maxWaitMillis;
+    }
+
+    /**
+     * Sets the maximum amount of time (in milliseconds) the
+     * <code>borrowObject()</code> method should block before throwing an
+     * exception when the pool is exhausted and
+     * {@link #getBlockWhenExhausted} is true. When less than 0, the
+     * <code>borrowObject()</code> method may block indefinitely.
+     *
+     * @param maxWaitMillis the maximum number of milliseconds
+     *                      <code>borrowObject()</code> will block or negative
+     *                      for indefinitely.
+     *
+     * @see #getMaxWaitMillis
+     * @see #setBlockWhenExhausted
+     */
+    public final void setMaxWaitMillis(long maxWaitMillis) {
+        this.maxWaitMillis = maxWaitMillis;
+    }
+
+    /**
+     * Returns whether the pool has LIFO (last in, first out) behaviour with
+     * respect to idle objects - always returning the most recently used object
+     * from the pool, or as a FIFO (first in, first out) queue, where the pool
+     * always returns the oldest object in the idle object pool.
+     *
+     * @return <code>true</code> if the pool is configured with LIFO behaviour
+     *         or <code>false</code> if the pool is configured with FIFO
+     *         behaviour
+     *
+     * @see #setLifo
+     */
+    public final boolean getLifo() {
+        return lifo;
+    }
+
+    /**
+     * Sets whether the pool has LIFO (last in, first out) behaviour with
+     * respect to idle objects - always returning the most recently used object
+     * from the pool, or as a FIFO (first in, first out) queue, where the pool
+     * always returns the oldest object in the idle object pool.
+     *
+     * @param lifo  <code>true</code> if the pool is to be configured with LIFO
+     *              behaviour or <code>false</code> if the pool is to be
+     *              configured with FIFO behaviour
+     *
+     * @see #getLifo()
+     */
+    public final void setLifo(boolean lifo) {
+        this.lifo = lifo;
+    }
+
+    /**
+     * Returns whether objects created for the pool will be validated before
+     * being returned from the <code>borrowObject()</code> method. Validation is
+     * performed by the <code>validateObject()</code> method of the factory
+     * associated with the pool. If the object fails to validate, then
+     * <code>borrowObject()</code> will fail.
+     *
+     * @return <code>true</code> if newly created objects are validated before
+     *         being returned from the <code>borrowObject()</code> method
+     *
+     * @see #setTestOnCreate
+     *
+     * @since 2.2
+     */
+    public final boolean getTestOnCreate() {
+        return testOnCreate;
+    }
+
+    /**
+     * Sets whether objects created for the pool will be validated before
+     * being returned from the <code>borrowObject()</code> method. Validation is
+     * performed by the <code>validateObject()</code> method of the factory
+     * associated with the pool. If the object fails to validate, then
+     * <code>borrowObject()</code> will fail.
+     *
+     * @param testOnCreate  <code>true</code> if newly created objects should be
+     *                      validated before being returned from the
+     *                      <code>borrowObject()</code> method
+     *
+     * @see #getTestOnCreate
+     *
+     * @since 2.2
+     */
+    public final void setTestOnCreate(boolean testOnCreate) {
+        this.testOnCreate = testOnCreate;
+    }
+
+    /**
+     * Returns whether objects borrowed from the pool will be validated before
+     * being returned from the <code>borrowObject()</code> method. Validation is
+     * performed by the <code>validateObject()</code> method of the factory
+     * associated with the pool. If the object fails to validate, it will be
+     * removed from the pool and destroyed, and a new attempt will be made to
+     * borrow an object from the pool.
+     *
+     * @return <code>true</code> if objects are validated before being returned
+     *         from the <code>borrowObject()</code> method
+     *
+     * @see #setTestOnBorrow
+     */
+    public final boolean getTestOnBorrow() {
+        return testOnBorrow;
+    }
+
+    /**
+     * Sets whether objects borrowed from the pool will be validated before
+     * being returned from the <code>borrowObject()</code> method. Validation is
+     * performed by the <code>validateObject()</code> method of the factory
+     * associated with the pool. If the object fails to validate, it will be
+     * removed from the pool and destroyed, and a new attempt will be made to
+     * borrow an object from the pool.
+     *
+     * @param testOnBorrow  <code>true</code> if objects should be validated
+     *                      before being returned from the
+     *                      <code>borrowObject()</code> method
+     *
+     * @see #getTestOnBorrow
+     */
+    public final void setTestOnBorrow(boolean testOnBorrow) {
+        this.testOnBorrow = testOnBorrow;
+    }
+
+    /**
+     * Returns whether objects borrowed from the pool will be validated when
+     * they are returned to the pool via the <code>returnObject()</code> method.
+     * Validation is performed by the <code>validateObject()</code> method of
+     * the factory associated with the pool. Returning objects that fail validation
+     * are destroyed rather then being returned the pool.
+     *
+     * @return <code>true</code> if objects are validated on return to
+     *         the pool via the <code>returnObject()</code> method
+     *
+     * @see #setTestOnReturn
+     */
+    public final boolean getTestOnReturn() {
+        return testOnReturn;
+    }
+
+    /**
+     * Sets whether objects borrowed from the pool will be validated when
+     * they are returned to the pool via the <code>returnObject()</code> method.
+     * Validation is performed by the <code>validateObject()</code> method of
+     * the factory associated with the pool. Returning objects that fail validation
+     * are destroyed rather then being returned the pool.
+     *
+     * @param testOnReturn <code>true</code> if objects are validated on
+     *                     return to the pool via the
+     *                     <code>returnObject()</code> method
+     *
+     * @see #getTestOnReturn
+     */
+    public final void setTestOnReturn(boolean testOnReturn) {
+        this.testOnReturn = testOnReturn;
+    }
+
+    /**
+     * Returns whether objects sitting idle in the pool will be validated by the
+     * idle object evictor (if any - see
+     * {@link #setTimeBetweenEvictionRunsMillis(long)}). Validation is performed
+     * by the <code>validateObject()</code> method of the factory associated
+     * with the pool. If the object fails to validate, it will be removed from
+     * the pool and destroyed.
+     *
+     * @return <code>true</code> if objects will be validated by the evictor
+     *
+     * @see #setTestWhileIdle
+     * @see #setTimeBetweenEvictionRunsMillis
+     */
+    public final boolean getTestWhileIdle() {
+        return testWhileIdle;
+    }
+
+    /**
+     * Returns whether objects sitting idle in the pool will be validated by the
+     * idle object evictor (if any - see
+     * {@link #setTimeBetweenEvictionRunsMillis(long)}). Validation is performed
+     * by the <code>validateObject()</code> method of the factory associated
+     * with the pool. If the object fails to validate, it will be removed from
+     * the pool and destroyed.  Note that setting this property has no effect
+     * unless the idle object evictor is enabled by setting
+     * <code>timeBetweenEvictionRunsMillis</code> to a positive value.
+     *
+     * @param testWhileIdle
+     *            <code>true</code> so objects will be validated by the evictor
+     *
+     * @see #getTestWhileIdle
+     * @see #setTimeBetweenEvictionRunsMillis
+     */
+    public final void setTestWhileIdle(boolean testWhileIdle) {
+        this.testWhileIdle = testWhileIdle;
+    }
+
+    /**
+     * Returns the number of milliseconds to sleep between runs of the idle
+     * object evictor thread. When non-positive, no idle object evictor thread
+     * will be run.
+     *
+     * @return number of milliseconds to sleep between evictor runs
+     *
+     * @see #setTimeBetweenEvictionRunsMillis
+     */
+    public final long getTimeBetweenEvictionRunsMillis() {
+        return timeBetweenEvictionRunsMillis;
+    }
+
+    /**
+     * Sets the number of milliseconds to sleep between runs of the idle
+     * object evictor thread. When non-positive, no idle object evictor thread
+     * will be run.
+     *
+     * @param timeBetweenEvictionRunsMillis
+     *            number of milliseconds to sleep between evictor runs
+     *
+     * @see #getTimeBetweenEvictionRunsMillis
+     */
+    public final void setTimeBetweenEvictionRunsMillis(
+            long timeBetweenEvictionRunsMillis) {
+        this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
+        startEvictor(timeBetweenEvictionRunsMillis);
+    }
+
+    /**
+     * Returns the maximum number of objects to examine during each run (if any)
+     * of the idle object evictor thread. When positive, the number of tests
+     * performed for a run will be the minimum of the configured value and the
+     * number of idle instances in the pool. When negative, the number of tests
+     * performed will be <code>ceil({@link #getNumIdle}/
+     * abs({@link #getNumTestsPerEvictionRun}))</code> which means that when the
+     * value is <code>-n</code> roughly one nth of the idle objects will be
+     * tested per run.
+     *
+     * @return max number of objects to examine during each evictor run
+     *
+     * @see #setNumTestsPerEvictionRun
+     * @see #setTimeBetweenEvictionRunsMillis
+     */
+    public final int getNumTestsPerEvictionRun() {
+        return numTestsPerEvictionRun;
+    }
+
+    /**
+     * Sets the maximum number of objects to examine during each run (if any)
+     * of the idle object evictor thread. When positive, the number of tests
+     * performed for a run will be the minimum of the configured value and the
+     * number of idle instances in the pool. When negative, the number of tests
+     * performed will be <code>ceil({@link #getNumIdle}/
+     * abs({@link #getNumTestsPerEvictionRun}))</code> which means that when the
+     * value is <code>-n</code> roughly one nth of the idle objects will be
+     * tested per run.
+     *
+     * @param numTestsPerEvictionRun
+     *            max number of objects to examine during each evictor run
+     *
+     * @see #getNumTestsPerEvictionRun
+     * @see #setTimeBetweenEvictionRunsMillis
+     */
+    public final void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
+        this.numTestsPerEvictionRun = numTestsPerEvictionRun;
+    }
+
+    /**
+     * Returns the minimum amount of time an object may sit idle in the pool
+     * before it is eligible for eviction by the idle object evictor (if any -
+     * see {@link #setTimeBetweenEvictionRunsMillis(long)}). When non-positive,
+     * no objects will be evicted from the pool due to idle time alone.
+     *
+     * @return minimum amount of time an object may sit idle in the pool before
+     *         it is eligible for eviction
+     *
+     * @see #setMinEvictableIdleTimeMillis
+     * @see #setTimeBetweenEvictionRunsMillis
+     */
+    public final long getMinEvictableIdleTimeMillis() {
+        return minEvictableIdleTimeMillis;
+    }
+
+    /**
+     * Sets the minimum amount of time an object may sit idle in the pool
+     * before it is eligible for eviction by the idle object evictor (if any -
+     * see {@link #setTimeBetweenEvictionRunsMillis(long)}). When non-positive,
+     * no objects will be evicted from the pool due to idle time alone.
+     *
+     * @param minEvictableIdleTimeMillis
+     *            minimum amount of time an object may sit idle in the pool
+     *            before it is eligible for eviction
+     *
+     * @see #getMinEvictableIdleTimeMillis
+     * @see #setTimeBetweenEvictionRunsMillis
+     */
+    public final void setMinEvictableIdleTimeMillis(
+            long minEvictableIdleTimeMillis) {
+        this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
+    }
+
+    /**
+     * Returns the minimum amount of time an object may sit idle in the pool
+     * before it is eligible for eviction by the idle object evictor (if any -
+     * see {@link #setTimeBetweenEvictionRunsMillis(long)}),
+     * with the extra condition that at least <code>minIdle</code> object
+     * instances remain in the pool. This setting is overridden by
+     * {@link #getMinEvictableIdleTimeMillis} (that is, if
+     * {@link #getMinEvictableIdleTimeMillis} is positive, then
+     * {@link #getSoftMinEvictableIdleTimeMillis} is ignored).
+     *
+     * @return minimum amount of time an object may sit idle in the pool before
+     *         it is eligible for eviction if minIdle instances are available
+     *
+     * @see #setSoftMinEvictableIdleTimeMillis
+     */
+    public final long getSoftMinEvictableIdleTimeMillis() {
+        return softMinEvictableIdleTimeMillis;
+    }
+
+    /**
+     * Sets the minimum amount of time an object may sit idle in the pool
+     * before it is eligible for eviction by the idle object evictor (if any -
+     * see {@link #setTimeBetweenEvictionRunsMillis(long)}),
+     * with the extra condition that at least <code>minIdle</code> object
+     * instances remain in the pool. This setting is overridden by
+     * {@link #getMinEvictableIdleTimeMillis} (that is, if
+     * {@link #getMinEvictableIdleTimeMillis} is positive, then
+     * {@link #getSoftMinEvictableIdleTimeMillis} is ignored).
+     *
+     * @param softMinEvictableIdleTimeMillis
+     *            minimum amount of time an object may sit idle in the pool
+     *            before it is eligible for eviction if minIdle instances are
+     *            available
+     *
+     * @see #getSoftMinEvictableIdleTimeMillis
+     */
+    public final void setSoftMinEvictableIdleTimeMillis(
+            long softMinEvictableIdleTimeMillis) {
+        this.softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
+    }
+
+    /**
+     * Returns the name of the {@link EvictionPolicy} implementation that is
+     * used by this pool.
+     *
+     * @return  The fully qualified class name of the {@link EvictionPolicy}
+     *
+     * @see #setEvictionPolicyClassName(String)
+     */
+    public final String getEvictionPolicyClassName() {
+        return evictionPolicy.getClass().getName();
+    }
+
+    /**
+     * Sets the name of the {@link EvictionPolicy} implementation that is
+     * used by this pool.
+     *
+     * @param evictionPolicyClassName   the fully qualified class name of the
+     *                                  new eviction policy
+     *
+     * @see #getEvictionPolicyClassName()
+     */
+    public final void setEvictionPolicyClassName(
+            String evictionPolicyClassName) {
+        try {
+            Class<?> clazz = Class.forName(evictionPolicyClassName);
+            Object policy = clazz.newInstance();
+            if (policy instanceof EvictionPolicy<?>) {
+                @SuppressWarnings("unchecked") // safe, because we just checked the class
+                EvictionPolicy<T> evicPolicy = (EvictionPolicy<T>) policy;
+                this.evictionPolicy = evicPolicy;
+            }
+        } catch (ClassNotFoundException e) {
+            throw new IllegalArgumentException(
+                    "Unable to create EvictionPolicy instance of type " +
+                    evictionPolicyClassName, e);
+        } catch (InstantiationException e) {
+            throw new IllegalArgumentException(
+                    "Unable to create EvictionPolicy instance of type " +
+                    evictionPolicyClassName, e);
+        } catch (IllegalAccessException e) {
+            throw new IllegalArgumentException(
+                    "Unable to create EvictionPolicy instance of type " +
+                    evictionPolicyClassName, e);
+        }
+    }
+
+
+    /**
+     * Closes the pool, destroys the remaining idle objects and, if registered
+     * in JMX, deregisters it.
+     */
+    public abstract void close();
+
+    /**
+     * Has this pool instance been closed.
+     * @return <code>true</code> when this pool has been closed.
+     */
+    public final boolean isClosed() {
+        return closed;
+    }
+
+    /**
+     * <p>Perform <code>numTests</code> idle object eviction tests, evicting
+     * examined objects that meet the criteria for eviction. If
+     * <code>testWhileIdle</code> is true, examined objects are validated
+     * when visited (and removed if invalid); otherwise only objects that
+     * have been idle for more than <code>minEvicableIdleTimeMillis</code>
+     * are removed.</p>
+     *
+     * @throws Exception when there is a problem evicting idle objects.
+     */
+    public abstract void evict() throws Exception;
+
+    /**
+     * Returns the {@link EvictionPolicy} defined for this pool.
+     * @return the eviction policy
+     */
+    final EvictionPolicy<T> getEvictionPolicy() {
+        return evictionPolicy;
+    }
+
+    /**
+     * Verifies that the pool is open.
+     * @throws IllegalStateException if the pool is closed.
+     */
+    final void assertOpen() throws IllegalStateException {
+        if (isClosed()) {
+            throw new IllegalStateException("Pool not open");
+        }
+    }
+
+    /**
+     * <p>Starts the evictor with the given delay. If there is an evictor
+     * running when this method is called, it is stopped and replaced with a
+     * new evictor with the specified delay.</p>
+     *
+     * <p>This method needs to be final, since it is called from a constructor.
+     * See POOL-195.</p>
+     *
+     * @param delay time in milliseconds before start and between eviction runs
+     */
+    final void startEvictor(long delay) {
+        synchronized (evictionLock) {
+            if (null != evictor) {
+                EvictionTimer.cancel(evictor);
+                evictor = null;
+                evictionIterator = null;
+            }
+            if (delay > 0) {
+                evictor = new Evictor();
+                EvictionTimer.schedule(evictor, delay, delay);
+            }
+        }
+    }
+
+    /**
+     * Tries to ensure that the configured minimum number of idle instances are
+     * available in the pool.
+     * @throws Exception if an error occurs creating idle instances
+     */
+    abstract void ensureMinIdle() throws Exception;
+
+
+    // Monitoring (primarily JMX) related methods
+
+    /**
+     * Provides the name under which the pool has been registered with the
+     * platform MBean server or <code>null</code> if the pool has not been
+     * registered.
+     * @return the JMX name
+     */
+    public final ObjectName getJmxName() {
+        return oname;
+    }
+
+    /**
+     * Provides the stack trace for the call that created this pool. JMX
+     * registration may trigger a memory leak so it is important that pools are
+     * deregistered when no longer used by calling the {@link #close()} method.
+     * This method is provided to assist with identifying code that creates but
+     * does not close it thereby creating a memory leak.
+     * @return pool creation stack trace
+     */
+    public final String getCreationStackTrace() {
+        return creationStackTrace;
+    }
+
+    /**
+     * The total number of objects successfully borrowed from this pool over the
+     * lifetime of the pool.
+     * @return the borrowed object count
+     */
+    public final long getBorrowedCount() {
+        return borrowedCount.get();
+    }
+
+    /**
+     * The total number of objects returned to this pool over the lifetime of
+     * the pool. This excludes attempts to return the same object multiple
+     * times.
+     * @return the returned object count
+     */
+    public final long getReturnedCount() {
+        return returnedCount.get();
+    }
+
+    /**
+     * The total number of objects created for this pool over the lifetime of
+     * the pool.
+     * @return the created object count
+     */
+    public final long getCreatedCount() {
+        return createdCount.get();
+    }
+
+    /**
+     * The total number of objects destroyed by this pool over the lifetime of
+     * the pool.
+     * @return the destroyed object count
+     */
+    public final long getDestroyedCount() {
+        return destroyedCount.get();
+    }
+
+    /**
+     * The total number of objects destroyed by the evictor associated with this
+     * pool over the lifetime of the pool.
+     * @return the evictor destroyed object count
+     */
+    public final long getDestroyedByEvictorCount() {
+        return destroyedByEvictorCount.get();
+    }
+
+    /**
+     * The total number of objects destroyed by this pool as a result of failing
+     * validation during <code>borrowObject()</code> over the lifetime of the
+     * pool.
+     * @return validation destroyed object count
+     */
+    public final long getDestroyedByBorrowValidationCount() {
+        return destroyedByBorrowValidationCount.get();
+    }
+
+    /**
+     * The mean time objects are active for based on the last {@link
+     * #MEAN_TIMING_STATS_CACHE_SIZE} objects returned to the pool.
+     * @return mean time an object has been checked out from the pool among
+     * recently returned objects
+     */
+    public final long getMeanActiveTimeMillis() {
+        return activeTimes.getMean();
+    }
+
+    /**
+     * The mean time objects are idle for based on the last {@link
+     * #MEAN_TIMING_STATS_CACHE_SIZE} objects borrowed from the pool.
+     * @return mean time an object has been idle in the pool among recently
+     * borrowed objects
+     */
+    public final long getMeanIdleTimeMillis() {
+        return idleTimes.getMean();
+    }
+
+    /**
+     * The mean time threads wait to borrow an object based on the last {@link
+     * #MEAN_TIMING_STATS_CACHE_SIZE} objects borrowed from the pool.
+     * @return mean time in milliseconds that a recently served thread has had
+     * to wait to borrow an object from the pool
+     */
+    public final long getMeanBorrowWaitTimeMillis() {
+        return waitTimes.getMean();
+    }
+
+    /**
+     * The maximum time a thread has waited to borrow objects from the pool.
+     * @return maximum wait time in milliseconds since the pool was created
+     */
+    public final long getMaxBorrowWaitTimeMillis() {
+        return maxBorrowWaitTimeMillis;
+    }
+
+    /**
+     * The number of instances currently idle in this pool.
+     * @return count of instances available for checkout from the pool
+     */
+    public abstract int getNumIdle();
+
+    /**
+     * The listener used (if any) to receive notifications of exceptions
+     * unavoidably swallowed by the pool.
+     *
+     * @return The listener or <code>null</code> for no listener
+     */
+    public final SwallowedExceptionListener getSwallowedExceptionListener() {
+        return swallowedExceptionListener;
+    }
+
+    /**
+     * The listener used (if any) to receive notifications of exceptions
+     * unavoidably swallowed by the pool.
+     *
+     * @param swallowedExceptionListener    The listener or <code>null</code>
+     *                                      for no listener
+     */
+    public final void setSwallowedExceptionListener(
+            SwallowedExceptionListener swallowedExceptionListener) {
+        this.swallowedExceptionListener = swallowedExceptionListener;
+    }
+
+    /**
+     * Swallows an exception and notifies the configured listener for swallowed
+     * exceptions queue.
+     *
+     * @param e exception to be swallowed
+     */
+    final void swallowException(Exception e) {
+        SwallowedExceptionListener listener = getSwallowedExceptionListener();
+
+        if (listener == null) {
+            return;
+        }
+
+        try {
+            listener.onSwallowException(e);
+        } catch (OutOfMemoryError oome) {
+            throw oome;
+        } catch (VirtualMachineError vme) {
+            throw vme;
+        } catch (Throwable t) {
+            // Ignore. Enjoy the irony.
+        }
+    }
+
+    /**
+     * Updates statistics after an object is borrowed from the pool.
+     * @param p object borrowed from the pool
+     * @param waitTime time (in milliseconds) that the borrowing thread had to wait
+     */
+    final void updateStatsBorrow(PooledObject<T> p, long waitTime) {
+        borrowedCount.incrementAndGet();
+        idleTimes.add(p.getIdleTimeMillis());
+        waitTimes.add(waitTime);
+        synchronized (maxBorrowWaitTimeMillisLock) {
+            if (waitTime > maxBorrowWaitTimeMillis) {
+                maxBorrowWaitTimeMillis = waitTime;
+            }
+        }
+    }
+
+    /**
+     * Updates statistics after an object is returned to the pool.
+     * @param activeTime the amount of time (in milliseconds) that the returning
+     * object was checked out
+     */
+    final void updateStatsReturn(long activeTime) {
+        returnedCount.incrementAndGet();
+        activeTimes.add(activeTime);
+    }
+
+    /**
+     * Unregisters this pool's MBean.
+     */
+    final void jmxUnregister() {
+        if (oname != null) {
+            try {
+                ManagementFactory.getPlatformMBeanServer().unregisterMBean(
+                        oname);
+            } catch (MBeanRegistrationException e) {
+                swallowException(e);
+            } catch (InstanceNotFoundException e) {
+                swallowException(e);
+            }
+        }
+    }
+
+    /**
+     * Registers the pool with the platform MBean server.
+     * The registered name will be
+     * <code>jmxNameBase + jmxNamePrefix + i</code> where i is the least
+     * integer greater than or equal to 1 such that the name is not already
+     * registered. Swallows MBeanRegistrationException, NotCompliantMBeanException
+     * returning null.
+     *
+     * @param config Pool configuration
+     * @param jmxNameBase default base JMX name for this pool
+     * @param jmxNamePrefix name prefix
+     * @return registered ObjectName, null if registration fails
+     */
+    private ObjectName jmxRegister(BaseObjectPoolConfig config,
+            String jmxNameBase, String jmxNamePrefix) {
+        ObjectName objectName = null;
+        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
+        int i = 1;
+        boolean registered = false;
+        String base = config.getJmxNameBase();
+        if (base == null) {
+            base = jmxNameBase;
+        }
+        while (!registered) {
+            try {
+                ObjectName objName;
+                // Skip the numeric suffix for the first pool in case there is
+                // only one so the names are cleaner.
+                if (i == 1) {
+                    objName = new ObjectName(base + jmxNamePrefix);
+                } else {
+                    objName = new ObjectName(base + jmxNamePrefix + i);
+                }
+                mbs.registerMBean(this, objName);
+                objectName = objName;
+                registered = true;
+            } catch (MalformedObjectNameException e) {
+                if (BaseObjectPoolConfig.DEFAULT_JMX_NAME_PREFIX.equals(
+                        jmxNamePrefix) && jmxNameBase.equals(base)) {
+                    // Shouldn't happen. Skip registration if it does.
+                    registered = true;
+                } else {
+                    // Must be an invalid name. Use the defaults instead.
+                    jmxNamePrefix =
+                            BaseObjectPoolConfig.DEFAULT_JMX_NAME_PREFIX;
+                    base = jmxNameBase;
+                }
+            } catch (InstanceAlreadyExistsException e) {
+                // Increment the index and try again
+                i++;
+            } catch (MBeanRegistrationException e) {
+                // Shouldn't happen. Skip registration if it does.
+                registered = true;
+            } catch (NotCompliantMBeanException e) {
+                // Shouldn't happen. Skip registration if it does.
+                registered = true;
+            }
+        }
+        return objectName;
+    }
+
+    /**
+     * Gets the stack trace of an exception as a string.
+     * @param e exception to trace
+     * @return exception stack trace as a string
+     */
+    private String getStackTrace(Exception e) {
+        // Need the exception in string form to prevent the retention of
+        // references to classes in the stack trace that could trigger a memory
+        // leak in a container environment.
+        Writer w = new StringWriter();
+        PrintWriter pw = new PrintWriter(w);
+        e.printStackTrace(pw);
+        return w.toString();
+    }
+
+    // Inner classes
+
+    /**
+     * The idle object evictor {@link TimerTask}.
+     *
+     * @see GenericKeyedObjectPool#setTimeBetweenEvictionRunsMillis
+     */
+    class Evictor extends TimerTask {
+        /**
+         * Run pool maintenance.  Evict objects qualifying for eviction and then
+         * ensure that the minimum number of idle instances are available.
+         * Since the Timer that invokes Evictors is shared for all Pools but
+         * pools may exist in different class loaders, the Evictor ensures that
+         * any actions taken are under the class loader of the factory
+         * associated with the pool.
+         */
+        @Override
+        public void run() {
+            ClassLoader savedClassLoader =
+                    Thread.currentThread().getContextClassLoader();
+            try {
+                // Set the class loader for the factory
+                Thread.currentThread().setContextClassLoader(
+                        factoryClassLoader);
+
+                // Evict from the pool
+                try {
+                    evict();
+                } catch(Exception e) {
+                    swallowException(e);
+                } catch(OutOfMemoryError oome) {
+                    // Log problem but give evictor thread a chance to continue
+                    // in case error is recoverable
+                    oome.printStackTrace(System.err);
+                }
+                // Re-create idle instances.
+                try {
+                    ensureMinIdle();
+                } catch (Exception e) {
+                    swallowException(e);
+                }
+            } finally {
+                // Restore the previous CCL
+                Thread.currentThread().setContextClassLoader(savedClassLoader);
+            }
+        }
+    }
+
+    private class StatsStore {
+
+        private final AtomicLong values[];
+        private final int size;
+        private int index;
+
+        public StatsStore(int size) {
+            this.size = size;
+            values = new AtomicLong[size];
+            for (int i = 0; i < size; i++) {
+                values[i] = new AtomicLong(-1);
+            }
+        }
+
+        public synchronized void add(long value) {
+            values[index].set(value);
+            index++;
+            if (index == size) {
+                index = 0;
+            }
+        }
+
+        public long getMean() {
+            double result = 0;
+            int counter = 0;
+            for (int i = 0; i < size; i++) {
+                long value = values[i].get();
+                if (value != -1) {
+                    counter++;
+                    result = result * ((counter - 1) / (double) counter) +
+                            value/(double) counter;
+                }
+            }
+            return (long) result;
+
+        }
+    }
+}

==================================================
DefaultEvictionPolicy.java
new file mode 100644
index 0000000000..83db76edcc
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/BaseObjectPoolConfig.java
@@ -0,0 +1,603 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+/**
+ * Provides the implementation for the common attributes shared by the
+ * sub-classes. New instances of this class will be created using the defaults
+ * defined by the public constants.
+ * <p>
+ * This class is not thread-safe.
+ *
+ * @version $Revision: $
+ *
+ * @since 2.0
+ */
+public abstract class BaseObjectPoolConfig implements Cloneable {
+
+    /**
+     * The default value for the {@code lifo} configuration attribute.
+     * @see GenericObjectPool#getLifo()
+     * @see GenericKeyedObjectPool#getLifo()
+     */
+    public static final boolean DEFAULT_LIFO = true;
+
+    /**
+     * The default value for the {@code maxWait} configuration attribute.
+     * @see GenericObjectPool#getMaxWaitMillis()
+     * @see GenericKeyedObjectPool#getMaxWaitMillis()
+     */
+    public static final long DEFAULT_MAX_WAIT_MILLIS = -1L;
+
+    /**
+     * The default value for the {@code minEvictableIdleTimeMillis}
+     * configuration attribute.
+     * @see GenericObjectPool#getMinEvictableIdleTimeMillis()
+     * @see GenericKeyedObjectPool#getMinEvictableIdleTimeMillis()
+     */
+    public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS =
+            1000L * 60L * 30L;
+
+    /**
+     * The default value for the {@code softMinEvictableIdleTimeMillis}
+     * configuration attribute.
+     * @see GenericObjectPool#getSoftMinEvictableIdleTimeMillis()
+     * @see GenericKeyedObjectPool#getSoftMinEvictableIdleTimeMillis()
+     */
+    public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
+
+    /**
+     * The default value for the {@code numTestsPerEvictionRun} configuration
+     * attribute.
+     * @see GenericObjectPool#getNumTestsPerEvictionRun()
+     * @see GenericKeyedObjectPool#getNumTestsPerEvictionRun()
+     */
+    public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
+
+    /**
+     * The default value for the {@code testOnCreate} configuration attribute.
+     * @see GenericObjectPool#getTestOnCreate()
+     * @see GenericKeyedObjectPool#getTestOnCreate()
+     *
+     * @since 2.2
+     */
+    public static final boolean DEFAULT_TEST_ON_CREATE = false;
+
+    /**
+     * The default value for the {@code testOnBorrow} configuration attribute.
+     * @see GenericObjectPool#getTestOnBorrow()
+     * @see GenericKeyedObjectPool#getTestOnBorrow()
+     */
+    public static final boolean DEFAULT_TEST_ON_BORROW = false;
+
+    /**
+     * The default value for the {@code testOnReturn} configuration attribute.
+     * @see GenericObjectPool#getTestOnReturn()
+     * @see GenericKeyedObjectPool#getTestOnReturn()
+     */
+    public static final boolean DEFAULT_TEST_ON_RETURN = false;
+
+    /**
+     * The default value for the {@code testWhileIdle} configuration attribute.
+     * @see GenericObjectPool#getTestWhileIdle()
+     * @see GenericKeyedObjectPool#getTestWhileIdle()
+     */
+    public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
+
+    /**
+     * The default value for the {@code timeBetweenEvictionRunsMillis}
+     * configuration attribute.
+     * @see GenericObjectPool#getTimeBetweenEvictionRunsMillis()
+     * @see GenericKeyedObjectPool#getTimeBetweenEvictionRunsMillis()
+     */
+    public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
+
+    /**
+     * The default value for the {@code blockWhenExhausted} configuration
+     * attribute.
+     * @see GenericObjectPool#getBlockWhenExhausted()
+     * @see GenericKeyedObjectPool#getBlockWhenExhausted()
+     */
+    public static final boolean DEFAULT_BLOCK_WHEN_EXHAUSTED = true;
+
+    /**
+     * The default value for enabling JMX for pools created with a configuration
+     * instance.
+     */
+    public static final boolean DEFAULT_JMX_ENABLE = true;
+
+    /**
+     * The default value for the prefix used to name JMX enabled pools created
+     * with a configuration instance.
+     * @see GenericObjectPool#getJmxName()
+     * @see GenericKeyedObjectPool#getJmxName()
+     */
+    public static final String DEFAULT_JMX_NAME_PREFIX = "pool";
+
+    /**
+     * The default value for the base name to use to name JMX enabled pools
+     * created with a configuration instance. The default is <code>null</code>
+     * which means the pool will provide the base name to use.
+     * @see GenericObjectPool#getJmxName()
+     * @see GenericKeyedObjectPool#getJmxName()
+     */
+    public static final String DEFAULT_JMX_NAME_BASE = null;
+
+    /**
+     * The default value for the {@code evictionPolicyClassName} configuration
+     * attribute.
+     * @see GenericObjectPool#getEvictionPolicyClassName()
+     * @see GenericKeyedObjectPool#getEvictionPolicyClassName()
+     */
+    public static final String DEFAULT_EVICTION_POLICY_CLASS_NAME =
+            "org.apache.tomcat.dbcp.pool2.impl.DefaultEvictionPolicy";
+
+
+    private boolean lifo = DEFAULT_LIFO;
+
+    private long maxWaitMillis = DEFAULT_MAX_WAIT_MILLIS;
+
+    private long minEvictableIdleTimeMillis =
+        DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
+
+    private long softMinEvictableIdleTimeMillis =
+            DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
+
+    private int numTestsPerEvictionRun =
+        DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
+
+    private String evictionPolicyClassName = DEFAULT_EVICTION_POLICY_CLASS_NAME;
+
+    private boolean testOnCreate = DEFAULT_TEST_ON_CREATE;
+
+    private boolean testOnBorrow = DEFAULT_TEST_ON_BORROW;
+
+    private boolean testOnReturn = DEFAULT_TEST_ON_RETURN;
+
+    private boolean testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
+
+    private long timeBetweenEvictionRunsMillis =
+        DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
+
+    private boolean blockWhenExhausted = DEFAULT_BLOCK_WHEN_EXHAUSTED;
+
+    private boolean jmxEnabled = DEFAULT_JMX_ENABLE;
+
+    // TODO Consider changing this to a single property for 3.x
+    private String jmxNamePrefix = DEFAULT_JMX_NAME_PREFIX;
+
+    private String jmxNameBase = DEFAULT_JMX_NAME_PREFIX;
+
+
+    /**
+     * Get the value for the {@code lifo} configuration attribute for pools
+     * created with this configuration instance.
+     *
+     * @return  The current setting of {@code lifo} for this configuration
+     *          instance
+     *
+     * @see GenericObjectPool#getLifo()
+     * @see GenericKeyedObjectPool#getLifo()
+     */
+    public boolean getLifo() {
+        return lifo;
+    }
+
+    /**
+     * Set the value for the {@code lifo} configuration attribute for pools
+     * created with this configuration instance.
+     *
+     * @param lifo The new setting of {@code lifo}
+     *        for this configuration instance
+     *
+     * @see GenericObjectPool#getLifo()
+     * @see GenericKeyedObjectPool#getLifo()
+     */
+    public void setLifo(boolean lifo) {
+        this.lifo = lifo;
+    }
+
+    /**
+     * Get the value for the {@code maxWait} configuration attribute for pools
+     * created with this configuration instance.
+     *
+     * @return  The current setting of {@code maxWait} for this
+     *          configuration instance
+     *
+     * @see GenericObjectPool#getMaxWaitMillis()
+     * @see GenericKeyedObjectPool#getMaxWaitMillis()
+     */
+    public long getMaxWaitMillis() {
+        return maxWaitMillis;
+    }
+
+    /**
+     * Set the value for the {@code maxWait} configuration attribute for pools
+     * created with this configuration instance.
+     *
+     * @param maxWaitMillis The new setting of {@code maxWaitMillis}
+     *        for this configuration instance
+     *
+     * @see GenericObjectPool#getMaxWaitMillis()
+     * @see GenericKeyedObjectPool#getMaxWaitMillis()
+     */
+    public void setMaxWaitMillis(long maxWaitMillis) {
+        this.maxWaitMillis = maxWaitMillis;
+    }
+
+    /**
+     * Get the value for the {@code minEvictableIdleTimeMillis} configuration
+     * attribute for pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code minEvictableIdleTimeMillis} for
+     *          this configuration instance
+     *
+     * @see GenericObjectPool#getMinEvictableIdleTimeMillis()
+     * @see GenericKeyedObjectPool#getMinEvictableIdleTimeMillis()
+     */
+    public long getMinEvictableIdleTimeMillis() {
+        return minEvictableIdleTimeMillis;
+    }
+
+    /**
+     * Set the value for the {@code minEvictableIdleTimeMillis} configuration
+     * attribute for pools created with this configuration instance.
+     *
+     * @param minEvictableIdleTimeMillis The new setting of
+     *        {@code minEvictableIdleTimeMillis} for this configuration instance
+     *
+     * @see GenericObjectPool#getMinEvictableIdleTimeMillis()
+     * @see GenericKeyedObjectPool#getMinEvictableIdleTimeMillis()
+     */
+    public void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
+        this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
+    }
+
+    /**
+     * Get the value for the {@code softMinEvictableIdleTimeMillis}
+     * configuration attribute for pools created with this configuration
+     * instance.
+     *
+     * @return  The current setting of {@code softMinEvictableIdleTimeMillis}
+     *          for this configuration instance
+     *
+     * @see GenericObjectPool#getSoftMinEvictableIdleTimeMillis()
+     * @see GenericKeyedObjectPool#getSoftMinEvictableIdleTimeMillis()
+     */
+    public long getSoftMinEvictableIdleTimeMillis() {
+        return softMinEvictableIdleTimeMillis;
+    }
+
+    /**
+     * Set the value for the {@code softMinEvictableIdleTimeMillis}
+     * configuration attribute for pools created with this configuration
+     * instance.
+     *
+     * @param softMinEvictableIdleTimeMillis The new setting of
+     *        {@code softMinEvictableIdleTimeMillis} for this configuration
+     *        instance
+     *
+     * @see GenericObjectPool#getSoftMinEvictableIdleTimeMillis()
+     * @see GenericKeyedObjectPool#getSoftMinEvictableIdleTimeMillis()
+     */
+    public void setSoftMinEvictableIdleTimeMillis(
+            long softMinEvictableIdleTimeMillis) {
+        this.softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
+    }
+
+    /**
+     * Get the value for the {@code numTestsPerEvictionRun} configuration
+     * attribute for pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code numTestsPerEvictionRun} for this
+     *          configuration instance
+     *
+     * @see GenericObjectPool#getNumTestsPerEvictionRun()
+     * @see GenericKeyedObjectPool#getNumTestsPerEvictionRun()
+     */
+    public int getNumTestsPerEvictionRun() {
+        return numTestsPerEvictionRun;
+    }
+
+    /**
+     * Set the value for the {@code numTestsPerEvictionRun} configuration
+     * attribute for pools created with this configuration instance.
+     *
+     * @param numTestsPerEvictionRun The new setting of
+     *        {@code numTestsPerEvictionRun} for this configuration instance
+     *
+     * @see GenericObjectPool#getNumTestsPerEvictionRun()
+     * @see GenericKeyedObjectPool#getNumTestsPerEvictionRun()
+     */
+    public void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
+        this.numTestsPerEvictionRun = numTestsPerEvictionRun;
+    }
+
+    /**
+     * Get the value for the {@code testOnCreate} configuration attribute for
+     * pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code testOnCreate} for this
+     *          configuration instance
+     *
+     * @see GenericObjectPool#getTestOnCreate()
+     * @see GenericKeyedObjectPool#getTestOnCreate()
+     *
+     * @since 2.2
+     */
+    public boolean getTestOnCreate() {
+        return testOnCreate;
+    }
+
+    /**
+     * Set the value for the {@code testOnCreate} configuration attribute for
+     * pools created with this configuration instance.
+     *
+     * @param testOnCreate The new setting of {@code testOnCreate}
+     *        for this configuration instance
+     *
+     * @see GenericObjectPool#getTestOnCreate()
+     * @see GenericKeyedObjectPool#getTestOnCreate()
+     *
+     * @since 2.2
+     */
+    public void setTestOnCreate(boolean testOnCreate) {
+        this.testOnCreate = testOnCreate;
+    }
+
+    /**
+     * Get the value for the {@code testOnBorrow} configuration attribute for
+     * pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code testOnBorrow} for this
+     *          configuration instance
+     *
+     * @see GenericObjectPool#getTestOnBorrow()
+     * @see GenericKeyedObjectPool#getTestOnBorrow()
+     */
+    public boolean getTestOnBorrow() {
+        return testOnBorrow;
+    }
+
+    /**
+     * Set the value for the {@code testOnBorrow} configuration attribute for
+     * pools created with this configuration instance.
+     *
+     * @param testOnBorrow The new setting of {@code testOnBorrow}
+     *        for this configuration instance
+     *
+     * @see GenericObjectPool#getTestOnBorrow()
+     * @see GenericKeyedObjectPool#getTestOnBorrow()
+     */
+    public void setTestOnBorrow(boolean testOnBorrow) {
+        this.testOnBorrow = testOnBorrow;
+    }
+
+    /**
+     * Get the value for the {@code testOnReturn} configuration attribute for
+     * pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code testOnReturn} for this
+     *          configuration instance
+     *
+     * @see GenericObjectPool#getTestOnReturn()
+     * @see GenericKeyedObjectPool#getTestOnReturn()
+     */
+    public boolean getTestOnReturn() {
+        return testOnReturn;
+    }
+
+    /**
+     * Set the value for the {@code testOnReturn} configuration attribute for
+     * pools created with this configuration instance.
+     *
+     * @param testOnReturn The new setting of {@code testOnReturn}
+     *        for this configuration instance
+     *
+     * @see GenericObjectPool#getTestOnReturn()
+     * @see GenericKeyedObjectPool#getTestOnReturn()
+     */
+    public void setTestOnReturn(boolean testOnReturn) {
+        this.testOnReturn = testOnReturn;
+    }
+
+    /**
+     * Get the value for the {@code testWhileIdle} configuration attribute for
+     * pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code testWhileIdle} for this
+     *          configuration instance
+     *
+     * @see GenericObjectPool#getTestWhileIdle()
+     * @see GenericKeyedObjectPool#getTestWhileIdle()
+     */
+    public boolean getTestWhileIdle() {
+        return testWhileIdle;
+    }
+
+    /**
+     * Set the value for the {@code testWhileIdle} configuration attribute for
+     * pools created with this configuration instance.
+     *
+     * @param testWhileIdle The new setting of {@code testWhileIdle}
+     *        for this configuration instance
+     *
+     * @see GenericObjectPool#getTestWhileIdle()
+     * @see GenericKeyedObjectPool#getTestWhileIdle()
+     */
+    public void setTestWhileIdle(boolean testWhileIdle) {
+        this.testWhileIdle = testWhileIdle;
+    }
+
+    /**
+     * Get the value for the {@code timeBetweenEvictionRunsMillis} configuration
+     * attribute for pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code timeBetweenEvictionRunsMillis} for
+     *          this configuration instance
+     *
+     * @see GenericObjectPool#getTimeBetweenEvictionRunsMillis()
+     * @see GenericKeyedObjectPool#getTimeBetweenEvictionRunsMillis()
+     */
+    public long getTimeBetweenEvictionRunsMillis() {
+        return timeBetweenEvictionRunsMillis;
+    }
+
+    /**
+     * Set the value for the {@code timeBetweenEvictionRunsMillis} configuration
+     * attribute for pools created with this configuration instance.
+     *
+     * @param timeBetweenEvictionRunsMillis The new setting of
+     *        {@code timeBetweenEvictionRunsMillis} for this configuration
+     *        instance
+     *
+     * @see GenericObjectPool#getTimeBetweenEvictionRunsMillis()
+     * @see GenericKeyedObjectPool#getTimeBetweenEvictionRunsMillis()
+     */
+    public void setTimeBetweenEvictionRunsMillis(
+            long timeBetweenEvictionRunsMillis) {
+        this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
+    }
+
+    /**
+     * Get the value for the {@code evictionPolicyClassName} configuration
+     * attribute for pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code evictionPolicyClassName} for this
+     *          configuration instance
+     *
+     * @see GenericObjectPool#getEvictionPolicyClassName()
+     * @see GenericKeyedObjectPool#getEvictionPolicyClassName()
+     */
+    public String getEvictionPolicyClassName() {
+        return evictionPolicyClassName;
+    }
+
+    /**
+     * Set the value for the {@code evictionPolicyClassName} configuration
+     * attribute for pools created with this configuration instance.
+     *
+     * @param evictionPolicyClassName The new setting of
+     *        {@code evictionPolicyClassName} for this configuration instance
+     *
+     * @see GenericObjectPool#getEvictionPolicyClassName()
+     * @see GenericKeyedObjectPool#getEvictionPolicyClassName()
+     */
+    public void setEvictionPolicyClassName(String evictionPolicyClassName) {
+        this.evictionPolicyClassName = evictionPolicyClassName;
+    }
+
+    /**
+     * Get the value for the {@code blockWhenExhausted} configuration attribute
+     * for pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code blockWhenExhausted} for this
+     *          configuration instance
+     *
+     * @see GenericObjectPool#getBlockWhenExhausted()
+     * @see GenericKeyedObjectPool#getBlockWhenExhausted()
+     */
+    public boolean getBlockWhenExhausted() {
+        return blockWhenExhausted;
+    }
+
+    /**
+     * Set the value for the {@code blockWhenExhausted} configuration attribute
+     * for pools created with this configuration instance.
+     *
+     * @param blockWhenExhausted The new setting of {@code blockWhenExhausted}
+     *        for this configuration instance
+     *
+     * @see GenericObjectPool#getBlockWhenExhausted()
+     * @see GenericKeyedObjectPool#getBlockWhenExhausted()
+     */
+    public void setBlockWhenExhausted(boolean blockWhenExhausted) {
+        this.blockWhenExhausted = blockWhenExhausted;
+    }
+
+    /**
+     * Gets the value of the flag that determines if JMX will be enabled for
+     * pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code jmxEnabled} for this configuration
+     *          instance
+     */
+    public boolean getJmxEnabled() {
+        return jmxEnabled;
+    }
+
+    /**
+     * Sets the value of the flag that determines if JMX will be enabled for
+     * pools created with this configuration instance.
+     *
+     * @param jmxEnabled The new setting of {@code jmxEnabled}
+     *        for this configuration instance
+     */
+    public void setJmxEnabled(boolean jmxEnabled) {
+        this.jmxEnabled = jmxEnabled;
+    }
+
+    /**
+     * Gets the value of the JMX name base that will be used as part of the
+     * name assigned to JMX enabled pools created with this configuration
+     * instance. A value of <code>null</code> means that the pool will define
+     * the JMX name base.
+     *
+     * @return  The current setting of {@code jmxNameBase} for this
+     *          configuration instance
+     */
+    public String getJmxNameBase() {
+        return jmxNameBase;
+    }
+
+    /**
+     * Sets the value of the JMX name base that will be used as part of the
+     * name assigned to JMX enabled pools created with this configuration
+     * instance. A value of <code>null</code> means that the pool will define
+     * the JMX name base.
+     *
+     * @param jmxNameBase The new setting of {@code jmxNameBase}
+     *        for this configuration instance
+     */
+    public void setJmxNameBase(String jmxNameBase) {
+        this.jmxNameBase = jmxNameBase;
+    }
+
+    /**
+     * Gets the value of the JMX name prefix that will be used as part of the
+     * name assigned to JMX enabled pools created with this configuration
+     * instance.
+     *
+     * @return  The current setting of {@code jmxNamePrefix} for this
+     *          configuration instance
+     */
+    public String getJmxNamePrefix() {
+        return jmxNamePrefix;
+    }
+
+    /**
+     * Sets the value of the JMX name prefix that will be used as part of the
+     * name assigned to JMX enabled pools created with this configuration
+     * instance.
+     *
+     * @param jmxNamePrefix The new setting of {@code jmxNamePrefix}
+     *        for this configuration instance
+     */
+    public void setJmxNamePrefix(String jmxNamePrefix) {
+        this.jmxNamePrefix = jmxNamePrefix;
+    }
+}

==================================================
DefaultPooledObject.java
new file mode 100644
index 0000000000..33e121df75
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/DefaultEvictionPolicy.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+import org.apache.tomcat.dbcp.pool2.PooledObject;
+
+/**
+ * Provides the default implementation of {@link EvictionPolicy} used by the
+ * pools. Objects will be evicted if the following conditions are met:
+ * <ul>
+ * <li>the object has been idle longer than
+ *     {@link GenericObjectPool#getMinEvictableIdleTimeMillis()} /
+ *     {@link GenericKeyedObjectPool#getMinEvictableIdleTimeMillis()}</li>
+ * <li>there are more than {@link GenericObjectPool#getMinIdle()} /
+ *     {@link GenericKeyedObjectPoolConfig#getMinIdlePerKey()} idle objects in
+ *     the pool and the object has been idle for longer than
+ *     {@link GenericObjectPool#getSoftMinEvictableIdleTimeMillis()} /
+ *     {@link GenericKeyedObjectPool#getSoftMinEvictableIdleTimeMillis()}
+ * </ul>
+ * This class is immutable and thread-safe.
+ *
+ * @param <T> the type of objects in the pool
+ *
+ * @version $Revision: $
+ *
+ * @since 2.0
+ */
+public class DefaultEvictionPolicy<T> implements EvictionPolicy<T> {
+
+    @Override
+    public boolean evict(EvictionConfig config, PooledObject<T> underTest,
+            int idleCount) {
+
+        if ((config.getIdleSoftEvictTime() < underTest.getIdleTimeMillis() &&
+                config.getMinIdle() < idleCount) ||
+                config.getIdleEvictTime() < underTest.getIdleTimeMillis()) {
+            return true;
+        }
+        return false;
+    }
+}

==================================================
DefaultPooledObjectInfo.java
new file mode 100644
index 0000000000..264a68b6bd
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/DefaultPooledObject.java
@@ -0,0 +1,322 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+import java.io.PrintWriter;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Deque;
+
+import org.apache.tomcat.dbcp.pool2.PooledObject;
+import org.apache.tomcat.dbcp.pool2.PooledObjectState;
+import org.apache.tomcat.dbcp.pool2.TrackedUse;
+
+/**
+ * This wrapper is used to track the additional information, such as state, for
+ * the pooled objects.
+ * <p>
+ * This class is intended to be thread-safe.
+ *
+ * @param <T> the type of object in the pool
+ *
+ * @version $Revision: $
+ *
+ * @since 2.0
+ */
+public class DefaultPooledObject<T> implements PooledObject<T> {
+
+    private final T object;
+    private PooledObjectState state = PooledObjectState.IDLE; // @GuardedBy("this") to ensure transitions are valid
+    private final long createTime = System.currentTimeMillis();
+    private volatile long lastBorrowTime = createTime;
+    private volatile long lastUseTime = createTime;
+    private volatile long lastReturnTime = createTime;
+    private volatile boolean logAbandoned = false;
+    private volatile Exception borrowedBy = null;
+    private volatile Exception usedBy = null;
+    private volatile long borrowedCount = 0;
+
+    /**
+     * Create a new instance that wraps the provided object so that the pool can
+     * track the state of the pooled object.
+     *
+     * @param object The object to wrap
+     */
+    public DefaultPooledObject(T object) {
+        this.object = object;
+    }
+
+    @Override
+    public T getObject() {
+        return object;
+    }
+
+    @Override
+    public long getCreateTime() {
+        return createTime;
+    }
+
+    @Override
+    public long getActiveTimeMillis() {
+        // Take copies to avoid threading issues
+        long rTime = lastReturnTime;
+        long bTime = lastBorrowTime;
+
+        if (rTime > bTime) {
+            return rTime - bTime;
+        } else {
+            return System.currentTimeMillis() - bTime;
+        }
+    }
+
+    @Override
+    public long getIdleTimeMillis() {
+        return System.currentTimeMillis() - lastReturnTime;
+    }
+
+    @Override
+    public long getLastBorrowTime() {
+        return lastBorrowTime;
+    }
+
+    @Override
+    public long getLastReturnTime() {
+        return lastReturnTime;
+    }
+
+    /**
+     * Get the number of times this object has been borrowed.
+     * @return The number of times this object has been borrowed.
+     * @since 2.1
+     */
+    public long getBorrowedCount() {
+        return borrowedCount;
+    }
+
+    /**
+     * Return an estimate of the last time this object was used.  If the class
+     * of the pooled object implements {@link TrackedUse}, what is returned is
+     * the maximum of {@link TrackedUse#getLastUsed()} and
+     * {@link #getLastBorrowTime()}; otherwise this method gives the same
+     * value as {@link #getLastBorrowTime()}.
+     *
+     * @return the last time this object was used
+     */
+    @Override
+    public long getLastUsedTime() {
+        if (object instanceof TrackedUse) {
+            return Math.max(((TrackedUse) object).getLastUsed(), lastUseTime);
+        } else {
+            return lastUseTime;
+        }
+    }
+
+    @Override
+    public int compareTo(PooledObject<T> other) {
+        final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
+        if (lastActiveDiff == 0) {
+            // Make sure the natural ordering is broadly consistent with equals
+            // although this will break down if distinct objects have the same
+            // identity hash code.
+            // see java.lang.Comparable Javadocs
+            return System.identityHashCode(this) - System.identityHashCode(other);
+        }
+        // handle int overflow
+        return (int)Math.min(Math.max(lastActiveDiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder result = new StringBuilder();
+        result.append("Object: ");
+        result.append(object.toString());
+        result.append(", State: ");
+        synchronized (this) {
+            result.append(state.toString());
+        }
+        return result.toString();
+        // TODO add other attributes
+    }
+
+    @Override
+    public synchronized boolean startEvictionTest() {
+        if (state == PooledObjectState.IDLE) {
+            state = PooledObjectState.EVICTION;
+            return true;
+        }
+
+        return false;
+    }
+
+    @Override
+    public synchronized boolean endEvictionTest(
+            Deque<PooledObject<T>> idleQueue) {
+        if (state == PooledObjectState.EVICTION) {
+            state = PooledObjectState.IDLE;
+            return true;
+        } else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {
+            state = PooledObjectState.IDLE;
+            if (!idleQueue.offerFirst(this)) {
+                // TODO - Should never happen
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Allocates the object.
+     *
+     * @return {@code true} if the original state was {@link PooledObjectState#IDLE IDLE}
+     */
+    @Override
+    public synchronized boolean allocate() {
+        if (state == PooledObjectState.IDLE) {
+            state = PooledObjectState.ALLOCATED;
+            lastBorrowTime = System.currentTimeMillis();
+            lastUseTime = lastBorrowTime;
+            borrowedCount++;
+            if (logAbandoned) {
+                borrowedBy = new AbandonedObjectCreatedException();
+            }
+            return true;
+        } else if (state == PooledObjectState.EVICTION) {
+            // TODO Allocate anyway and ignore eviction test
+            state = PooledObjectState.EVICTION_RETURN_TO_HEAD;
+            return false;
+        }
+        // TODO if validating and testOnBorrow == true then pre-allocate for
+        // performance
+        return false;
+    }
+
+    /**
+     * Deallocates the object and sets it {@link PooledObjectState#IDLE IDLE}
+     * if it is currently {@link PooledObjectState#ALLOCATED ALLOCATED}.
+     *
+     * @return {@code true} if the state was {@link PooledObjectState#ALLOCATED ALLOCATED}
+     */
+    @Override
+    public synchronized boolean deallocate() {
+        if (state == PooledObjectState.ALLOCATED ||
+                state == PooledObjectState.RETURNING) {
+            state = PooledObjectState.IDLE;
+            lastReturnTime = System.currentTimeMillis();
+            if (borrowedBy != null) {
+                borrowedBy = null;
+            }
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Sets the state to {@link PooledObjectState#INVALID INVALID}
+     */
+    @Override
+    public synchronized void invalidate() {
+        state = PooledObjectState.INVALID;
+    }
+
+    @Override
+    public void use() {
+        lastUseTime = System.currentTimeMillis();
+        usedBy = new Exception("The last code to use this object was:");
+    }
+
+    @Override
+    public void printStackTrace(PrintWriter writer) {
+        Exception borrowedByCopy = this.borrowedBy;
+        if (borrowedByCopy != null) {
+            borrowedByCopy.printStackTrace(writer);
+        }
+        Exception usedByCopy = this.usedBy;
+        if (usedByCopy != null) {
+            usedByCopy.printStackTrace(writer);
+        }
+    }
+
+    /**
+     * Returns the state of this object.
+     * @return state
+     */
+    @Override
+    public synchronized PooledObjectState getState() {
+        return state;
+    }
+
+    /**
+     * Marks the pooled object as abandoned.
+     */
+    @Override
+    public synchronized void markAbandoned() {
+        state = PooledObjectState.ABANDONED;
+    }
+
+    /**
+     * Marks the object as returning to the pool.
+     */
+    @Override
+    public synchronized void markReturning() {
+        state = PooledObjectState.RETURNING;
+    }
+
+    @Override
+    public void setLogAbandoned(boolean logAbandoned) {
+        this.logAbandoned = logAbandoned;
+    }
+
+    /**
+     * Used to track how an object was obtained from the pool (the stack trace
+     * of the exception will show which code borrowed the object) and when the
+     * object was borrowed.
+     */
+    static class AbandonedObjectCreatedException extends Exception {
+
+        private static final long serialVersionUID = 7398692158058772916L;
+
+        /** Date format */
+        //@GuardedBy("this")
+        private static final SimpleDateFormat format = new SimpleDateFormat
+            ("'Pooled object created' yyyy-MM-dd HH:mm:ss Z " +
+             "'by the following code has not been returned to the pool:'");
+
+        private final long _createdTime;
+
+        /**
+         * Create a new instance.
+         * <p>
+         * @see Exception#Exception()
+         */
+        public AbandonedObjectCreatedException() {
+            super();
+            _createdTime = System.currentTimeMillis();
+        }
+
+        // Override getMessage to avoid creating objects and formatting
+        // dates unless the log message will actually be used.
+        @Override
+        public String getMessage() {
+            String msg;
+            synchronized(format) {
+                msg = format.format(new Date(_createdTime));
+            }
+            return msg;
+        }
+    }
+}

==================================================
DefaultPooledObjectInfoMBean.java
new file mode 100644
index 0000000000..67204bead1
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/DefaultPooledObjectInfo.java
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.text.SimpleDateFormat;
+
+import org.apache.tomcat.dbcp.pool2.PooledObject;
+
+/**
+ * Implementation of object that is used to provide information on pooled
+ * objects via JMX.
+ *
+ * @since 2.0
+ */
+public class DefaultPooledObjectInfo implements DefaultPooledObjectInfoMBean {
+
+    private final PooledObject<?> pooledObject;
+
+    /**
+     * Create a new instance for the given pooled object.
+     *
+     * @param pooledObject The pooled object that this instance will represent
+     */
+    public DefaultPooledObjectInfo(PooledObject<?> pooledObject) {
+        this.pooledObject = pooledObject;
+    }
+
+    @Override
+    public long getCreateTime() {
+        return pooledObject.getCreateTime();
+    }
+
+    @Override
+    public String getCreateTimeFormatted() {
+        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
+        return sdf.format(Long.valueOf(pooledObject.getCreateTime()));
+    }
+
+    @Override
+    public long getLastBorrowTime() {
+        return pooledObject.getLastBorrowTime();
+    }
+
+    @Override
+    public String getLastBorrowTimeFormatted() {
+        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
+        return sdf.format(Long.valueOf(pooledObject.getLastBorrowTime()));
+    }
+
+    @Override
+    public String getLastBorrowTrace() {
+        StringWriter sw = new StringWriter();
+        pooledObject.printStackTrace(new PrintWriter(sw));
+        return sw.toString();
+    }
+
+    @Override
+    public long getLastReturnTime() {
+        return pooledObject.getLastReturnTime();
+    }
+
+    @Override
+    public String getLastReturnTimeFormatted() {
+        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
+        return sdf.format(Long.valueOf(pooledObject.getLastReturnTime()));
+    }
+
+    @Override
+    public String getPooledObjectType() {
+        return pooledObject.getObject().getClass().getName();
+    }
+
+    @Override
+    public String getPooledObjectToString() {
+        return pooledObject.getObject().toString();
+    }
+
+    @Override
+    public long getBorrowedCount() {
+        // TODO Simplify this once getBorrowedCount has been added to PooledObject
+        if (pooledObject instanceof DefaultPooledObject) {
+            return ((DefaultPooledObject<?>) pooledObject).getBorrowedCount();
+        } else {
+            return -1;
+        }
+    }
+}

==================================================
EvictionConfig.java
new file mode 100644
index 0000000000..2af7ebdc59
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/DefaultPooledObjectInfoMBean.java
@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+/**
+ * The interface that defines the information about pooled objects that will be
+ * exposed via JMX.
+ *
+ * NOTE: This interface exists only to define those attributes and methods that
+ *       will be made available via JMX. It must not be implemented by clients
+ *       as it is subject to change between major, minor and patch version
+ *       releases of commons pool. Clients that implement this interface may
+ *       not, therefore, be able to upgrade to a new minor or patch release
+ *       without requiring code changes.
+ *
+ * @since 2.0
+ */
+public interface DefaultPooledObjectInfoMBean {
+    /**
+     * Obtain the time (using the same basis as
+     * {@link System#currentTimeMillis()}) that pooled object was created.
+     *
+     * @return The creation time for the pooled object
+     */
+    long getCreateTime();
+
+    /**
+     * Obtain the time that pooled object was created.
+     *
+     * @return The creation time for the pooled object formated as
+     *         <code>yyyy-MM-dd HH:mm:ss Z</code>
+     */
+    String getCreateTimeFormatted();
+
+    /**
+     * Obtain the time (using the same basis as
+     * {@link System#currentTimeMillis()}) the polled object was last borrowed.
+     *
+     * @return The time the pooled object was last borrowed
+     */
+    long getLastBorrowTime();
+
+    /**
+     * Obtain the time that pooled object was last borrowed.
+     *
+     * @return The last borrowed time for the pooled object formated as
+     *         <code>yyyy-MM-dd HH:mm:ss Z</code>
+     */
+    String getLastBorrowTimeFormatted();
+
+    /**
+     * Obtain the stack trace recorded when the pooled object was last borrowed.
+     *
+     * @return The stack trace showing which code last borrowed the pooled
+     *         object
+     */
+    String getLastBorrowTrace();
+
+
+    /**
+     * Obtain the time (using the same basis as
+     * {@link System#currentTimeMillis()})the wrapped object was last returned.
+     *
+     * @return The time the object was last returned
+     */
+    long getLastReturnTime();
+
+    /**
+     * Obtain the time that pooled object was last returned.
+     *
+     * @return The last returned time for the pooled object formated as
+     *         <code>yyyy-MM-dd HH:mm:ss Z</code>
+     */
+    String getLastReturnTimeFormatted();
+
+    /**
+     * Obtain the name of the class of the pooled object.
+     *
+     * @return The pooled object's class name
+     *
+     * @see Class#getName()
+     */
+    String getPooledObjectType();
+
+    /**
+     * Provides a String form of the wrapper for debug purposes. The format is
+     * not fixed and may change at any time.
+     *
+     * @return A string representation of the pooled object
+     *
+     * @see Object#toString()
+     */
+    String getPooledObjectToString();
+
+    /**
+     * Get the number of times this object has been borrowed.
+     * @return The number of times this object has been borrowed.
+     * @since 2.1
+     */
+    long getBorrowedCount();
+}

==================================================
EvictionPolicy.java
new file mode 100644
index 0000000000..a505681f03
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/EvictionConfig.java
@@ -0,0 +1,101 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+/**
+ * This class is used by pool implementations to pass configuration information
+ * to {@link EvictionPolicy} instances. The {@link EvictionPolicy} may also have
+ * its own specific configuration attributes.
+ * <p>
+ * This class is immutable and thread-safe.
+ *
+ * @version $Revision: $
+ *
+ * @since 2.0
+ */
+public class EvictionConfig {
+
+    private final long idleEvictTime;
+    private final long idleSoftEvictTime;
+    private final int minIdle;
+
+
+    /**
+     * Create a new eviction configuration with the specified parameters.
+     * Instances are immutable.
+     *
+     * @param poolIdleEvictTime Expected to be provided by
+     *        {@link BaseGenericObjectPool#getMinEvictableIdleTimeMillis()}
+     * @param poolIdleSoftEvictTime Expected to be provided by
+     *        {@link BaseGenericObjectPool#getSoftMinEvictableIdleTimeMillis()}
+     * @param minIdle Expected to be provided by
+     *        {@link GenericObjectPool#getMinIdle()} or
+     *        {@link GenericKeyedObjectPool#getMinIdlePerKey()}
+     */
+    public EvictionConfig(long poolIdleEvictTime, long poolIdleSoftEvictTime,
+            int minIdle) {
+        if (poolIdleEvictTime > 0) {
+            idleEvictTime = poolIdleEvictTime;
+        } else {
+            idleEvictTime = Long.MAX_VALUE;
+        }
+        if (poolIdleSoftEvictTime > 0) {
+            idleSoftEvictTime = poolIdleSoftEvictTime;
+        } else {
+            idleSoftEvictTime  = Long.MAX_VALUE;
+        }
+        this.minIdle = minIdle;
+    }
+
+    /**
+     * Obtain the {@code idleEvictTime} for this eviction configuration
+     * instance.
+     * <p>
+     * How the evictor behaves based on this value will be determined by the
+     * configured {@link EvictionPolicy}.
+     *
+     * @return The {@code idleEvictTime} in milliseconds
+     */
+    public long getIdleEvictTime() {
+        return idleEvictTime;
+    }
+
+    /**
+     * Obtain the {@code idleSoftEvictTime} for this eviction configuration
+     * instance.
+     * <p>
+     * How the evictor behaves based on this value will be determined by the
+     * configured {@link EvictionPolicy}.
+     *
+     * @return The (@code idleSoftEvictTime} in milliseconds
+     */
+    public long getIdleSoftEvictTime() {
+        return idleSoftEvictTime;
+    }
+
+    /**
+     * Obtain the {@code minIdle} for this eviction configuration instance.
+     * <p>
+     * How the evictor behaves based on this value will be determined by the
+     * configured {@link EvictionPolicy}.
+     *
+     * @return The {@code minIdle}
+     */
+    public int getMinIdle() {
+        return minIdle;
+    }
+}

==================================================
EvictionTimer.java
new file mode 100644
index 0000000000..732a5e9091
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/EvictionPolicy.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+import org.apache.tomcat.dbcp.pool2.PooledObject;
+
+/**
+ * To provide a custom eviction policy (i.e. something other than {@link
+ * DefaultEvictionPolicy} for a pool, users must provide an implementation of
+ * this interface that provides the required eviction policy.
+ *
+ * @param <T> the type of objects in the pool
+ *
+ * @version $Revision: $
+ *
+ * @since 2.0
+ */
+public interface EvictionPolicy<T> {
+
+    /**
+     * This method is called to test if an idle object in the pool should be
+     * evicted or not.
+     *
+     * @param config    The pool configuration settings related to eviction
+     * @param underTest The pooled object being tested for eviction
+     * @param idleCount The current number of idle objects in the pool including
+     *                      the object under test
+     * @return <code>true</code> if the object should be evicted, otherwise
+     *             <code>false</code>
+     */
+    boolean evict(EvictionConfig config, PooledObject<T> underTest,
+            int idleCount);
+}

==================================================
GenericKeyedObjectPool.java
new file mode 100644
index 0000000000..09a0d555e9
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/EvictionTimer.java
@@ -0,0 +1,132 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.Timer;
+import java.util.TimerTask;
+
+/**
+ * Provides a shared idle object eviction timer for all pools. This class wraps
+ * the standard {@link Timer} and keeps track of how many pools are using it.
+ * If no pools are using the timer, it is canceled. This prevents a thread
+ * being left running which, in application server environments, can lead to
+ * memory leads and/or prevent applications from shutting down or reloading
+ * cleanly.
+ * <p>
+ * This class has package scope to prevent its inclusion in the pool public API.
+ * The class declaration below should *not* be changed to public.
+ * <p>
+ * This class is intended to be thread-safe.
+ *
+ * @since 2.0
+ */
+class EvictionTimer {
+
+    /** Timer instance */
+    private static Timer _timer; //@GuardedBy("this")
+
+    /** Static usage count tracker */
+    private static int _usageCount; //@GuardedBy("this")
+
+    /** Prevent instantiation */
+    private EvictionTimer() {
+        // Hide the default constructor
+    }
+
+    /**
+     * Add the specified eviction task to the timer. Tasks that are added with a
+     * call to this method *must* call {@link #cancel(TimerTask)} to cancel the
+     * task to prevent memory and/or thread leaks in application server
+     * environments.
+     * @param task      Task to be scheduled
+     * @param delay     Delay in milliseconds before task is executed
+     * @param period    Time in milliseconds between executions
+     */
+    static synchronized void schedule(TimerTask task, long delay, long period) {
+        if (null == _timer) {
+            // Force the new Timer thread to be created with a context class
+            // loader set to the class loader that loaded this library
+            ClassLoader ccl = AccessController.doPrivileged(
+                    new PrivilegedGetTccl());
+            try {
+                AccessController.doPrivileged(new PrivilegedSetTccl(
+                        EvictionTimer.class.getClassLoader()));
+                _timer = new Timer("commons-pool-EvictionTimer", true);
+            } finally {
+                AccessController.doPrivileged(new PrivilegedSetTccl(ccl));
+            }
+        }
+        _usageCount++;
+        _timer.schedule(task, delay, period);
+    }
+
+    /**
+     * Remove the specified eviction task from the timer.
+     * @param task      Task to be scheduled
+     */
+    static synchronized void cancel(TimerTask task) {
+        task.cancel();
+        _usageCount--;
+        if (_usageCount == 0) {
+            _timer.cancel();
+            _timer = null;
+        }
+    }
+
+    /**
+     * {@link PrivilegedAction} used to get the ContextClassLoader
+     */
+    private static class PrivilegedGetTccl implements PrivilegedAction<ClassLoader> {
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public ClassLoader run() {
+            return Thread.currentThread().getContextClassLoader();
+        }
+    }
+
+    /**
+     * {@link PrivilegedAction} used to set the ContextClassLoader
+     */
+    private static class PrivilegedSetTccl implements PrivilegedAction<Void> {
+
+        /** ClassLoader */
+        private final ClassLoader cl;
+
+        /**
+         * Create a new PrivilegedSetTccl using the given classloader
+         * @param cl ClassLoader to use
+         */
+        PrivilegedSetTccl(ClassLoader cl) {
+            this.cl = cl;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public Void run() {
+            Thread.currentThread().setContextClassLoader(cl);
+            return null;
+        }
+    }
+
+}

==================================================
GenericKeyedObjectPoolConfig.java
new file mode 100644
index 0000000000..90f3bf3dc6
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java
@@ -0,0 +1,1507 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.NoSuchElementException;
+import java.util.TreeMap;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
+import org.apache.tomcat.dbcp.pool2.KeyedPooledObjectFactory;
+import org.apache.tomcat.dbcp.pool2.PoolUtils;
+import org.apache.tomcat.dbcp.pool2.PooledObject;
+import org.apache.tomcat.dbcp.pool2.PooledObjectState;
+
+/**
+ * A configurable <code>KeyedObjectPool</code> implementation.
+ * <p>
+ * When coupled with the appropriate {@link KeyedPooledObjectFactory},
+ * <code>GenericKeyedObjectPool</code> provides robust pooling functionality for
+ * keyed objects. A <code>GenericKeyedObjectPool</code> can be viewed as a map
+ * of sub-pools, keyed on the (unique) key values provided to the
+ * {@link #preparePool preparePool}, {@link #addObject addObject} or
+ * {@link #borrowObject borrowObject} methods. Each time a new key value is
+ * provided to one of these methods, a sub-new pool is created under the given
+ * key to be managed by the containing <code>GenericKeyedObjectPool.</code>
+ * <p>
+ * Optionally, one may configure the pool to examine and possibly evict objects
+ * as they sit idle in the pool and to ensure that a minimum number of idle
+ * objects is maintained for each key. This is performed by an "idle object
+ * eviction" thread, which runs asynchronously. Caution should be used when
+ * configuring this optional feature. Eviction runs contend with client threads
+ * for access to objects in the pool, so if they run too frequently performance
+ * issues may result.
+ * <p>
+ * Implementation note: To prevent possible deadlocks, care has been taken to
+ * ensure that no call to a factory method will occur within a synchronization
+ * block. See POOL-125 and DBCP-44 for more information.
+ * <p>
+ * This class is intended to be thread-safe.
+ *
+ * @see GenericObjectPool
+ *
+ * @param <K> The type of keys maintained by this pool.
+ * @param <T> Type of element pooled in this pool.
+ *
+ * @version $Revision$
+ *
+ * @since 2.0
+ */
+public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
+        implements KeyedObjectPool<K,T>, GenericKeyedObjectPoolMXBean<K> {
+
+    /**
+     * Create a new <code>GenericKeyedObjectPool</code> using defaults from
+     * {@link GenericKeyedObjectPoolConfig}.
+     * @param factory the factory to be used to create entries
+     */
+    public GenericKeyedObjectPool(KeyedPooledObjectFactory<K,T> factory) {
+        this(factory, new GenericKeyedObjectPoolConfig());
+    }
+
+    /**
+     * Create a new <code>GenericKeyedObjectPool</code> using a specific
+     * configuration.
+     *
+     * @param factory the factory to be used to create entries
+     * @param config    The configuration to use for this pool instance. The
+     *                  configuration is used by value. Subsequent changes to
+     *                  the configuration object will not be reflected in the
+     *                  pool.
+     */
+    public GenericKeyedObjectPool(KeyedPooledObjectFactory<K,T> factory,
+            GenericKeyedObjectPoolConfig config) {
+
+        super(config, ONAME_BASE, config.getJmxNamePrefix());
+
+        if (factory == null) {
+            jmxUnregister(); // tidy up
+            throw new IllegalArgumentException("factory may not be null");
+        }
+        this.factory = factory;
+
+        setConfig(config);
+
+        startEvictor(getMinEvictableIdleTimeMillis());
+    }
+
+    /**
+     * Returns the limit on the number of object instances allocated by the pool
+     * (checked out or idle), per key. When the limit is reached, the sub-pool
+     * is said to be exhausted. A negative value indicates no limit.
+     *
+     * @return the limit on the number of active instances per key
+     *
+     * @see #setMaxTotalPerKey
+     */
+    @Override
+    public int getMaxTotalPerKey() {
+        return maxTotalPerKey;
+    }
+
+    /**
+     * Sets the limit on the number of object instances allocated by the pool
+     * (checked out or idle), per key. When the limit is reached, the sub-pool
+     * is said to be exhausted. A negative value indicates no limit.
+     *
+     * @param maxTotalPerKey the limit on the number of active instances per key
+     *
+     * @see #getMaxTotalPerKey
+     */
+    public void setMaxTotalPerKey(int maxTotalPerKey) {
+        this.maxTotalPerKey = maxTotalPerKey;
+    }
+
+
+    /**
+     * Returns the cap on the number of "idle" instances per key in the pool.
+     * If maxIdlePerKey is set too low on heavily loaded systems it is possible
+     * you will see objects being destroyed and almost immediately new objects
+     * being created. This is a result of the active threads momentarily
+     * returning objects faster than they are requesting them them, causing the
+     * number of idle objects to rise above maxIdlePerKey. The best value for
+     * maxIdlePerKey for heavily loaded system will vary but the default is a
+     * good starting point.
+     *
+     * @return the maximum number of "idle" instances that can be held in a
+     *         given keyed sub-pool or a negative value if there is no limit
+     *
+     * @see #setMaxIdlePerKey
+     */
+    @Override
+    public int getMaxIdlePerKey() {
+        return maxIdlePerKey;
+    }
+
+    /**
+     * Sets the cap on the number of "idle" instances per key in the pool.
+     * If maxIdlePerKey is set too low on heavily loaded systems it is possible
+     * you will see objects being destroyed and almost immediately new objects
+     * being created. This is a result of the active threads momentarily
+     * returning objects faster than they are requesting them them, causing the
+     * number of idle objects to rise above maxIdlePerKey. The best value for
+     * maxIdlePerKey for heavily loaded system will vary but the default is a
+     * good starting point.
+     *
+     * @param maxIdlePerKey the maximum number of "idle" instances that can be
+     *                      held in a given keyed sub-pool. Use a negative value
+     *                      for no limit
+     *
+     * @see #getMaxIdlePerKey
+     */
+    public void setMaxIdlePerKey(int maxIdlePerKey) {
+        this.maxIdlePerKey = maxIdlePerKey;
+    }
+
+    /**
+     * Sets the target for the minimum number of idle objects to maintain in
+     * each of the keyed sub-pools. This setting only has an effect if it is
+     * positive and {@link #getTimeBetweenEvictionRunsMillis()} is greater than
+     * zero. If this is the case, an attempt is made to ensure that each
+     * sub-pool has the required minimum number of instances during idle object
+     * eviction runs.
+     * <p>
+     * If the configured value of minIdlePerKey is greater than the configured
+     * value for maxIdlePerKey then the value of maxIdlePerKey will be used
+     * instead.
+     *
+     * @param minIdlePerKey The minimum size of the each keyed pool
+     *
+     * @see #getMinIdlePerKey
+     * @see #getMaxIdlePerKey()
+     * @see #setTimeBetweenEvictionRunsMillis
+     */
+    public void setMinIdlePerKey(int minIdlePerKey) {
+        this.minIdlePerKey = minIdlePerKey;
+    }
+
+    /**
+     * Returns the target for the minimum number of idle objects to maintain in
+     * each of the keyed sub-pools. This setting only has an effect if it is
+     * positive and {@link #getTimeBetweenEvictionRunsMillis()} is greater than
+     * zero. If this is the case, an attempt is made to ensure that each
+     * sub-pool has the required minimum number of instances during idle object
+     * eviction runs.
+     * <p>
+     * If the configured value of minIdlePerKey is greater than the configured
+     * value for maxIdlePerKey then the value of maxIdlePerKey will be used
+     * instead.
+     *
+     * @return minimum size of the each keyed pool
+     *
+     * @see #setTimeBetweenEvictionRunsMillis
+     */
+    @Override
+    public int getMinIdlePerKey() {
+        int maxIdlePerKeySave = getMaxIdlePerKey();
+        if (this.minIdlePerKey > maxIdlePerKeySave) {
+            return maxIdlePerKeySave;
+        } else {
+            return minIdlePerKey;
+        }
+    }
+
+    /**
+     * Sets the configuration.
+     *
+     * @param conf the new configuration to use. This is used by value.
+     *
+     * @see GenericKeyedObjectPoolConfig
+     */
+    public void setConfig(GenericKeyedObjectPoolConfig conf) {
+        setLifo(conf.getLifo());
+        setMaxIdlePerKey(conf.getMaxIdlePerKey());
+        setMaxTotalPerKey(conf.getMaxTotalPerKey());
+        setMaxTotal(conf.getMaxTotal());
+        setMinIdlePerKey(conf.getMinIdlePerKey());
+        setMaxWaitMillis(conf.getMaxWaitMillis());
+        setBlockWhenExhausted(conf.getBlockWhenExhausted());
+        setTestOnCreate(conf.getTestOnCreate());
+        setTestOnBorrow(conf.getTestOnBorrow());
+        setTestOnReturn(conf.getTestOnReturn());
+        setTestWhileIdle(conf.getTestWhileIdle());
+        setNumTestsPerEvictionRun(conf.getNumTestsPerEvictionRun());
+        setMinEvictableIdleTimeMillis(conf.getMinEvictableIdleTimeMillis());
+        setSoftMinEvictableIdleTimeMillis(
+                conf.getSoftMinEvictableIdleTimeMillis());
+        setTimeBetweenEvictionRunsMillis(
+                conf.getTimeBetweenEvictionRunsMillis());
+        setEvictionPolicyClassName(conf.getEvictionPolicyClassName());
+    }
+
+    /**
+     * Obtain a reference to the factory used to create, destroy and validate
+     * the objects used by this pool.
+     *
+     * @return the factory
+     */
+    public KeyedPooledObjectFactory<K, T> getFactory() {
+        return factory;
+    }
+
+    /**
+     * Equivalent to <code>{@link #borrowObject(Object, long) borrowObject}(key,
+     * {@link #getMaxWaitMillis()})</code>.
+     * <p>
+     * {@inheritDoc}
+     */
+    @Override
+    public T borrowObject(K key) throws Exception {
+        return borrowObject(key, getMaxWaitMillis());
+    }
+
+    /**
+     * Borrows an object from the sub-pool associated with the given key using
+     * the specified waiting time which only applies if
+     * {@link #getBlockWhenExhausted()} is true.
+     * <p>
+     * If there is one or more idle instances available in the sub-pool
+     * associated with the given key, then an idle instance will be selected
+     * based on the value of {@link #getLifo()}, activated and returned.  If
+     * activation fails, or {@link #getTestOnBorrow() testOnBorrow} is set to
+     * <code>true</code> and validation fails, the instance is destroyed and the
+     * next available instance is examined.  This continues until either a valid
+     * instance is returned or there are no more idle instances available.
+     * <p>
+     * If there are no idle instances available in the sub-pool associated with
+     * the given key, behavior depends on the {@link #getMaxTotalPerKey()
+     * maxTotalPerKey}, {@link #getMaxTotal() maxTotal}, and (if applicable)
+     * {@link #getBlockWhenExhausted()} and the value passed in to the
+     * <code>borrowMaxWaitMillis</code> parameter. If the number of instances checked
+     * out from the sub-pool under the given key is less than
+     * <code>maxTotalPerKey</code> and the total number of instances in
+     * circulation (under all keys) is less than <code>maxTotal</code>, a new
+     * instance is created, activated and (if applicable) validated and returned
+     * to the caller. If validation fails, a <code>NoSuchElementException</code>
+     * will be thrown.
+     * <p>
+     * If the associated sub-pool is exhausted (no available idle instances and
+     * no capacity to create new ones), this method will either block
+     * ({@link #getBlockWhenExhausted()} is true) or throw a
+     * <code>NoSuchElementException</code>
+     * ({@link #getBlockWhenExhausted()} is false).
+     * The length of time that this method will block when
+     * {@link #getBlockWhenExhausted()} is true is determined by the value
+     * passed in to the <code>borrowMaxWait</code> parameter.
+     * <p>
+     * When <code>maxTotal</code> is set to a positive value and this method is
+     * invoked when at the limit with no idle instances available under the requested
+     * key, an attempt is made to create room by clearing the oldest 15% of the
+     * elements from the keyed sub-pools.
+     * <p>
+     * When the pool is exhausted, multiple calling threads may be
+     * simultaneously blocked waiting for instances to become available. A
+     * "fairness" algorithm has been implemented to ensure that threads receive
+     * available instances in request arrival order.
+     *
+     * @param key pool key
+     * @param borrowMaxWaitMillis The time to wait in milliseconds for an object
+     *                            to become available
+     *
+     * @return object instance from the keyed pool
+     *
+     * @throws NoSuchElementException if a keyed object instance cannot be
+     *                                returned because the pool is exhausted.
+     *
+     * @throws Exception if a keyed object instance cannot be returned due to an
+     *                   error
+     */
+    public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
+        assertOpen();
+
+        PooledObject<T> p = null;
+
+        // Get local copy of current config so it is consistent for entire
+        // method execution
+        boolean blockWhenExhausted = getBlockWhenExhausted();
+
+        boolean create;
+        long waitTime = 0;
+        ObjectDeque<T> objectDeque = register(key);
+
+        try {
+            while (p == null) {
+                create = false;
+                if (blockWhenExhausted) {
+                    p = objectDeque.getIdleObjects().pollFirst();
+                    if (p == null) {
+                        create = true;
+                        p = create(key);
+                    }
+                    if (p == null) {
+                        if (borrowMaxWaitMillis < 0) {
+                            p = objectDeque.getIdleObjects().takeFirst();
+                        } else {
+                            waitTime = System.currentTimeMillis();
+                            p = objectDeque.getIdleObjects().pollFirst(
+                                    borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
+                            waitTime = System.currentTimeMillis() - waitTime;
+                        }
+                    }
+                    if (p == null) {
+                        throw new NoSuchElementException(
+                                "Timeout waiting for idle object");
+                    }
+                    if (!p.allocate()) {
+                        p = null;
+                    }
+                } else {
+                    p = objectDeque.getIdleObjects().pollFirst();
+                    if (p == null) {
+                        create = true;
+                        p = create(key);
+                    }
+                    if (p == null) {
+                        throw new NoSuchElementException("Pool exhausted");
+                    }
+                    if (!p.allocate()) {
+                        p = null;
+                    }
+                }
+
+                if (p != null) {
+                    try {
+                        factory.activateObject(key, p);
+                    } catch (Exception e) {
+                        try {
+                            destroy(key, p, true);
+                        } catch (Exception e1) {
+                            // Ignore - activation failure is more important
+                        }
+                        p = null;
+                        if (create) {
+                            NoSuchElementException nsee = new NoSuchElementException(
+                                    "Unable to activate object");
+                            nsee.initCause(e);
+                            throw nsee;
+                        }
+                    }
+                    if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
+                        boolean validate = false;
+                        Throwable validationThrowable = null;
+                        try {
+                            validate = factory.validateObject(key, p);
+                        } catch (Throwable t) {
+                            PoolUtils.checkRethrow(t);
+                            validationThrowable = t;
+                        }
+                        if (!validate) {
+                            try {
+                                destroy(key, p, true);
+                                destroyedByBorrowValidationCount.incrementAndGet();
+                            } catch (Exception e) {
+                                // Ignore - validation failure is more important
+                            }
+                            p = null;
+                            if (create) {
+                                NoSuchElementException nsee = new NoSuchElementException(
+                                        "Unable to validate object");
+                                nsee.initCause(validationThrowable);
+                                throw nsee;
+                            }
+                        }
+                    }
+                }
+            }
+        } finally {
+            deregister(key);
+        }
+
+        updateStatsBorrow(p, waitTime);
+
+        return p.getObject();
+    }
+
+
+    /**
+     * Returns an object to a keyed sub-pool.
+     * <p>
+     * If {@link #getMaxIdlePerKey() maxIdle} is set to a positive value and the
+     * number of idle instances under the given key has reached this value, the
+     * returning instance is destroyed.
+     * <p>
+     * If {@link #getTestOnReturn() testOnReturn} == true, the returning
+     * instance is validated before being returned to the idle instance sub-pool
+     * under the given key. In this case, if validation fails, the instance is
+     * destroyed.
+     * <p>
+     * Exceptions encountered destroying objects for any reason are swallowed
+     * but notified via a
+     * {@link org.apache.tomcat.dbcp.pool2.SwallowedExceptionListener}.
+     *
+     * @param key pool key
+     * @param obj instance to return to the keyed pool
+     *
+     * @throws IllegalStateException if an object is returned to the pool that
+     *                               was not borrowed from it or if an object is
+     *                               returned to the pool multiple times
+     */
+    @Override
+    public void returnObject(K key, T obj) {
+
+        ObjectDeque<T> objectDeque = poolMap.get(key);
+
+        PooledObject<T> p = objectDeque.getAllObjects().get(obj);
+
+        if (p == null) {
+            throw new IllegalStateException(
+                    "Returned object not currently part of this pool");
+        }
+
+        long activeTime = p.getActiveTimeMillis();
+
+        if (getTestOnReturn()) {
+            if (!factory.validateObject(key, p)) {
+                try {
+                    destroy(key, p, true);
+                } catch (Exception e) {
+                    swallowException(e);
+                }
+                if (objectDeque.idleObjects.hasTakeWaiters()) {
+                    try {
+                        addObject(key);
+                    } catch (Exception e) {
+                        swallowException(e);
+                    }
+                }
+                updateStatsReturn(activeTime);
+                return;
+            }
+        }
+
+        try {
+            factory.passivateObject(key, p);
+        } catch (Exception e1) {
+            swallowException(e1);
+            try {
+                destroy(key, p, true);
+            } catch (Exception e) {
+                swallowException(e);
+            }
+            if (objectDeque.idleObjects.hasTakeWaiters()) {
+                try {
+                    addObject(key);
+                } catch (Exception e) {
+                    swallowException(e);
+                }
+            }
+            updateStatsReturn(activeTime);
+            return;
+        }
+
+        if (!p.deallocate()) {
+            throw new IllegalStateException(
+                    "Object has already been returned to this pool");
+        }
+
+        int maxIdle = getMaxIdlePerKey();
+        LinkedBlockingDeque<PooledObject<T>> idleObjects =
+            objectDeque.getIdleObjects();
+
+        if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
+            try {
+                destroy(key, p, true);
+            } catch (Exception e) {
+                swallowException(e);
+            }
+        } else {
+            if (getLifo()) {
+                idleObjects.addFirst(p);
+            } else {
+                idleObjects.addLast(p);
+            }
+        }
+
+        if (hasBorrowWaiters()) {
+            reuseCapacity();
+        }
+
+        updateStatsReturn(activeTime);
+    }
+
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Activation of this method decrements the active count associated with
+     * the given keyed pool and attempts to destroy <code>obj.</code>
+     *
+     * @param key pool key
+     * @param obj instance to invalidate
+     *
+     * @throws Exception             if an exception occurs destroying the
+     *                               object
+     * @throws IllegalStateException if obj does not belong to the pool
+     *                               under the given key
+     */
+    @Override
+    public void invalidateObject(K key, T obj) throws Exception {
+
+        ObjectDeque<T> objectDeque = poolMap.get(key);
+
+        PooledObject<T> p = objectDeque.getAllObjects().get(obj);
+        if (p == null) {
+            throw new IllegalStateException(
+                    "Object not currently part of this pool");
+        }
+        synchronized (p) {
+            if (p.getState() != PooledObjectState.INVALID) {
+                destroy(key, p, true);
+            }
+        }
+        if (objectDeque.idleObjects.hasTakeWaiters()) {
+            addObject(key);
+        }
+    }
+
+
+    /**
+     * Clears any objects sitting idle in the pool by removing them from the
+     * idle instance sub-pools and then invoking the configured
+     * PoolableObjectFactory's
+     * {@link KeyedPooledObjectFactory#destroyObject(Object, PooledObject)}
+     * method on each idle instance.
+     * <p>
+     * Implementation notes:
+     * <ul>
+     * <li>This method does not destroy or effect in any way instances that are
+     * checked out when it is invoked.</li>
+     * <li>Invoking this method does not prevent objects being returned to the
+     * idle instance pool, even during its execution. Additional instances may
+     * be returned while removed items are being destroyed.</li>
+     * <li>Exceptions encountered destroying idle instances are swallowed
+     * but notified via a
+     * {@link org.apache.tomcat.dbcp.pool2.SwallowedExceptionListener}.</li>
+     * </ul>
+     */
+    @Override
+    public void clear() {
+        Iterator<K> iter = poolMap.keySet().iterator();
+
+        while (iter.hasNext()) {
+            clear(iter.next());
+        }
+    }
+
+
+    /**
+     * Clears the specified sub-pool, removing all pooled instances
+     * corresponding to the given <code>key</code>. Exceptions encountered
+     * destroying idle instances are swallowed but notified via a
+     * {@link org.apache.tomcat.dbcp.pool2.SwallowedExceptionListener}.
+     *
+     * @param key the key to clear
+     */
+    @Override
+    public void clear(K key) {
+
+        ObjectDeque<T> objectDeque = register(key);
+
+        try {
+            LinkedBlockingDeque<PooledObject<T>> idleObjects =
+                    objectDeque.getIdleObjects();
+
+            PooledObject<T> p = idleObjects.poll();
+
+            while (p != null) {
+                try {
+                    destroy(key, p, true);
+                } catch (Exception e) {
+                    swallowException(e);
+                }
+                p = idleObjects.poll();
+            }
+        } finally {
+            deregister(key);
+        }
+    }
+
+
+    @Override
+    public int getNumActive() {
+        return numTotal.get() - getNumIdle();
+    }
+
+
+    @Override
+    public int getNumIdle() {
+        Iterator<ObjectDeque<T>> iter = poolMap.values().iterator();
+        int result = 0;
+
+        while (iter.hasNext()) {
+            result += iter.next().getIdleObjects().size();
+        }
+
+        return result;
+    }
+
+
+    @Override
+    public int getNumActive(K key) {
+        final ObjectDeque<T> objectDeque = poolMap.get(key);
+        if (objectDeque != null) {
+            return objectDeque.getAllObjects().size() -
+                    objectDeque.getIdleObjects().size();
+        } else {
+            return 0;
+        }
+    }
+
+
+    @Override
+    public int getNumIdle(K key) {
+        final ObjectDeque<T> objectDeque = poolMap.get(key);
+        return objectDeque != null ? objectDeque.getIdleObjects().size() : 0;
+    }
+
+
+    /**
+     * Closes the keyed object pool. Once the pool is closed,
+     * {@link #borrowObject(Object)} will fail with IllegalStateException, but
+     * {@link #returnObject(Object, Object)} and
+     * {@link #invalidateObject(Object, Object)} will continue to work, with
+     * returned objects destroyed on return.
+     * <p>
+     * Destroys idle instances in the pool by invoking {@link #clear()}.
+     */
+    @Override
+    public void close() {
+        if (isClosed()) {
+            return;
+        }
+
+        synchronized (closeLock) {
+            if (isClosed()) {
+                return;
+            }
+
+            // Stop the evictor before the pool is closed since evict() calls
+            // assertOpen()
+            startEvictor(-1L);
+
+            closed = true;
+            // This clear removes any idle objects
+            clear();
+
+            jmxUnregister();
+
+            // Release any threads that were waiting for an object
+            Iterator<ObjectDeque<T>> iter = poolMap.values().iterator();
+            while (iter.hasNext()) {
+                iter.next().getIdleObjects().interuptTakeWaiters();
+            }
+            // This clear cleans up the keys now any waiting threads have been
+            // interrupted
+            clear();
+        }
+    }
+
+
+    /**
+     * Clears oldest 15% of objects in pool.  The method sorts the objects into
+     * a TreeMap and then iterates the first 15% for removal.
+     */
+    public void clearOldest() {
+
+        // build sorted map of idle objects
+        final Map<PooledObject<T>, K> map = new TreeMap<>();
+
+        for (K k : poolMap.keySet()) {
+            ObjectDeque<T> queue = poolMap.get(k);
+            // Protect against possible NPE if key has been removed in another
+            // thread. Not worth locking the keys while this loop completes.
+            if (queue != null) {
+                final LinkedBlockingDeque<PooledObject<T>> idleObjects =
+                    queue.getIdleObjects();
+                for (PooledObject<T> p : idleObjects) {
+                    // each item into the map using the PooledObject object as the
+                    // key. It then gets sorted based on the idle time
+                    map.put(p, k);
+                }
+            }
+        }
+
+        // Now iterate created map and kill the first 15% plus one to account
+        // for zero
+        int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
+        Iterator<Map.Entry<PooledObject<T>, K>> iter =
+            map.entrySet().iterator();
+
+        while (iter.hasNext() && itemsToRemove > 0) {
+            Map.Entry<PooledObject<T>, K> entry = iter.next();
+            // kind of backwards on naming.  In the map, each key is the
+            // PooledObject because it has the ordering with the timestamp
+            // value.  Each value that the key references is the key of the
+            // list it belongs to.
+            K key = entry.getValue();
+            PooledObject<T> p = entry.getKey();
+            // Assume the destruction succeeds
+            boolean destroyed = true;
+            try {
+                destroyed = destroy(key, p, false);
+            } catch (Exception e) {
+                swallowException(e);
+            }
+            if (destroyed) {
+                itemsToRemove--;
+            }
+        }
+    }
+
+    /**
+     * Attempt to create one new instance to serve from the most heavily
+     * loaded pool that can add a new instance.
+     *
+     * This method exists to ensure liveness in the pool when threads are
+     * parked waiting and capacity to create instances under the requested keys
+     * subsequently becomes available.
+     *
+     * This method is not guaranteed to create an instance and its selection
+     * of the most loaded pool that can create an instance may not always be
+     * correct, since it does not lock the pool and instances may be created,
+     * borrowed, returned or destroyed by other threads while it is executing.
+     */
+    private void reuseCapacity() {
+        final int maxTotalPerKeySave = getMaxTotalPerKey();
+
+        // Find the most loaded pool that could take a new instance
+        int maxQueueLength = 0;
+        LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
+        K loadedKey = null;
+        for (K k : poolMap.keySet()) {
+            final ObjectDeque<T> deque = poolMap.get(k);
+            if (deque != null) {
+                final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
+                final int queueLength = pool.getTakeQueueLength();
+                if (getNumActive(k) < maxTotalPerKeySave && queueLength > maxQueueLength) {
+                    maxQueueLength = queueLength;
+                    mostLoaded = pool;
+                    loadedKey = k;
+                }
+            }
+        }
+
+        // Attempt to add an instance to the most loaded pool
+        if (mostLoaded != null) {
+            register(loadedKey);
+            try {
+                PooledObject<T> p = create(loadedKey);
+                if (p != null) {
+                    addIdleObject(loadedKey, p);
+                }
+            } catch (Exception e) {
+                swallowException(e);
+            } finally {
+                deregister(loadedKey);
+            }
+        }
+    }
+
+    /**
+     * Checks to see if there are any threads currently waiting to borrow
+     * objects but are blocked waiting for more objects to become available.
+     *
+     * @return {@code true} if there is at least one thread waiting otherwise
+     *         {@code false}
+     */
+    private boolean hasBorrowWaiters() {
+        for (K k : poolMap.keySet()) {
+            final ObjectDeque<T> deque = poolMap.get(k);
+            if (deque != null) {
+                final LinkedBlockingDeque<PooledObject<T>> pool =
+                    deque.getIdleObjects();
+                if(pool.hasTakeWaiters()) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Successive activations of this method examine objects in keyed sub-pools
+     * in sequence, cycling through the keys and examining objects in
+     * oldest-to-youngest order within the keyed sub-pools.
+     */
+    @Override
+    public void evict() throws Exception {
+        assertOpen();
+
+        if (getNumIdle() == 0) {
+            return;
+        }
+
+        PooledObject<T> underTest = null;
+        EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
+
+        synchronized (evictionLock) {
+            EvictionConfig evictionConfig = new EvictionConfig(
+                    getMinEvictableIdleTimeMillis(),
+                    getSoftMinEvictableIdleTimeMillis(),
+                    getMinIdlePerKey());
+
+            boolean testWhileIdle = getTestWhileIdle();
+
+            LinkedBlockingDeque<PooledObject<T>> idleObjects = null;
+
+            for (int i = 0, m = getNumTests(); i < m; i++) {
+                if(evictionIterator == null || !evictionIterator.hasNext()) {
+                    if (evictionKeyIterator == null ||
+                            !evictionKeyIterator.hasNext()) {
+                        List<K> keyCopy = new ArrayList<>();
+                        Lock readLock = keyLock.readLock();
+                        readLock.lock();
+                        try {
+                            keyCopy.addAll(poolKeyList);
+                        } finally {
+                            readLock.unlock();
+                        }
+                        evictionKeyIterator = keyCopy.iterator();
+                    }
+                    while (evictionKeyIterator.hasNext()) {
+                        evictionKey = evictionKeyIterator.next();
+                        ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
+                        if (objectDeque == null) {
+                            continue;
+                        }
+                        idleObjects = objectDeque.getIdleObjects();
+
+                        if (getLifo()) {
+                            evictionIterator = idleObjects.descendingIterator();
+                        } else {
+                            evictionIterator = idleObjects.iterator();
+                        }
+                        if (evictionIterator.hasNext()) {
+                            break;
+                        }
+                        evictionIterator = null;
+                    }
+                }
+                if (evictionIterator == null) {
+                    // Pools exhausted
+                    return;
+                }
+                try {
+                    underTest = evictionIterator.next();
+                } catch (NoSuchElementException nsee) {
+                    // Object was borrowed in another thread
+                    // Don't count this as an eviction test so reduce i;
+                    i--;
+                    evictionIterator = null;
+                    continue;
+                }
+
+                if (!underTest.startEvictionTest()) {
+                    // Object was borrowed in another thread
+                    // Don't count this as an eviction test so reduce i;
+                    i--;
+                    continue;
+                }
+
+                if (evictionPolicy.evict(evictionConfig, underTest,
+                        poolMap.get(evictionKey).getIdleObjects().size())) {
+                    destroy(evictionKey, underTest, true);
+                    destroyedByEvictorCount.incrementAndGet();
+                } else {
+                    if (testWhileIdle) {
+                        boolean active = false;
+                        try {
+                            factory.activateObject(evictionKey, underTest);
+                            active = true;
+                        } catch (Exception e) {
+                            destroy(evictionKey, underTest, true);
+                            destroyedByEvictorCount.incrementAndGet();
+                        }
+                        if (active) {
+                            if (!factory.validateObject(evictionKey,
+                                    underTest)) {
+                                destroy(evictionKey, underTest, true);
+                                destroyedByEvictorCount.incrementAndGet();
+                            } else {
+                                try {
+                                    factory.passivateObject(evictionKey,
+                                            underTest);
+                                } catch (Exception e) {
+                                    destroy(evictionKey, underTest, true);
+                                    destroyedByEvictorCount.incrementAndGet();
+                                }
+                            }
+                        }
+                    }
+                    if (!underTest.endEvictionTest(idleObjects)) {
+                        // TODO - May need to add code here once additional
+                        // states are used
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Create a new pooled object.
+     *
+     * @param key Key associated with new pooled object
+     *
+     * @return The new, wrapped pooled object
+     *
+     * @throws Exception If the objection creation fails
+     */
+    private PooledObject<T> create(K key) throws Exception {
+        int maxTotalPerKeySave = getMaxTotalPerKey(); // Per key
+        int maxTotal = getMaxTotal();   // All keys
+
+        // Check against the overall limit
+        boolean loop = true;
+
+        while (loop) {
+            int newNumTotal = numTotal.incrementAndGet();
+            if (maxTotal > -1 && newNumTotal > maxTotal) {
+                numTotal.decrementAndGet();
+                if (getNumIdle() == 0) {
+                    return null;
+                } else {
+                    clearOldest();
+                }
+            } else {
+                loop = false;
+            }
+        }
+
+        ObjectDeque<T> objectDeque = poolMap.get(key);
+        long newCreateCount = objectDeque.getCreateCount().incrementAndGet();
+
+        // Check against the per key limit
+        if (maxTotalPerKeySave > -1 && newCreateCount > maxTotalPerKeySave ||
+                newCreateCount > Integer.MAX_VALUE) {
+            numTotal.decrementAndGet();
+            objectDeque.getCreateCount().decrementAndGet();
+            return null;
+        }
+
+
+        PooledObject<T> p = null;
+        try {
+            p = factory.makeObject(key);
+        } catch (Exception e) {
+            numTotal.decrementAndGet();
+            objectDeque.getCreateCount().decrementAndGet();
+            throw e;
+        }
+
+        createdCount.incrementAndGet();
+        objectDeque.getAllObjects().put(p.getObject(), p);
+        return p;
+    }
+
+    /**
+     * Destroy the wrapped, pooled object.
+     *
+     * @param key The key associated with the object to destroy.
+     * @param toDestroy The wrapped object to be destroyed
+     * @param always Should the object be destroyed even if it is not currently
+     *               in the set of idle objects for the given key
+     * @return {@code true} if the object was destroyed, otherwise {@code false}
+     * @throws Exception If the object destruction failed
+     */
+    private boolean destroy(K key, PooledObject<T> toDestroy, boolean always)
+            throws Exception {
+
+        ObjectDeque<T> objectDeque = register(key);
+
+        try {
+            boolean isIdle = objectDeque.getIdleObjects().remove(toDestroy);
+
+            if (isIdle || always) {
+                objectDeque.getAllObjects().remove(toDestroy.getObject());
+                toDestroy.invalidate();
+
+                try {
+                    factory.destroyObject(key, toDestroy);
+                } finally {
+                    objectDeque.getCreateCount().decrementAndGet();
+                    destroyedCount.incrementAndGet();
+                    numTotal.decrementAndGet();
+                }
+                return true;
+            } else {
+                return false;
+            }
+        } finally {
+            deregister(key);
+        }
+    }
+
+
+    /**
+     * Register the use of a key by an object.
+     * <p>
+     * register() and deregister() must always be used as a pair.
+     *
+     * @param k The key to register
+     *
+     * @return The objects currently associated with the given key. If this
+     *         method returns without throwing an exception then it will never
+     *         return null.
+     */
+    private ObjectDeque<T> register(K k) {
+        Lock lock = keyLock.readLock();
+        ObjectDeque<T> objectDeque = null;
+        try {
+            lock.lock();
+            objectDeque = poolMap.get(k);
+            if (objectDeque == null) {
+                // Upgrade to write lock
+                lock.unlock();
+                lock = keyLock.writeLock();
+                lock.lock();
+                objectDeque = poolMap.get(k);
+                if (objectDeque == null) {
+                    objectDeque = new ObjectDeque<>();
+                    objectDeque.getNumInterested().incrementAndGet();
+                    // NOTE: Keys must always be added to both poolMap and
+                    //       poolKeyList at the same time while protected by
+                    //       keyLock.writeLock()
+                    poolMap.put(k, objectDeque);
+                    poolKeyList.add(k);
+                } else {
+                    objectDeque.getNumInterested().incrementAndGet();
+                }
+            } else {
+                objectDeque.getNumInterested().incrementAndGet();
+            }
+        } finally {
+            lock.unlock();
+        }
+        return objectDeque;
+    }
+
+    /**
+     * De-register the use of a key by an object.
+     * <p>
+     * register() and deregister() must always be used as a pair.
+     *
+     * @param k The key to de-register
+     */
+    private void deregister(K k) {
+        ObjectDeque<T> objectDeque;
+
+        objectDeque = poolMap.get(k);
+        long numInterested = objectDeque.getNumInterested().decrementAndGet();
+        if (numInterested == 0 && objectDeque.getCreateCount().get() == 0) {
+            // Potential to remove key
+            Lock writeLock = keyLock.writeLock();
+            writeLock.lock();
+            try {
+                if (objectDeque.getCreateCount().get() == 0 &&
+                        objectDeque.getNumInterested().get() == 0) {
+                    // NOTE: Keys must always be removed from both poolMap and
+                    //       poolKeyList at the same time while protected by
+                    //       keyLock.writeLock()
+                    poolMap.remove(k);
+                    poolKeyList.remove(k);
+                }
+            } finally {
+                writeLock.unlock();
+            }
+        }
+    }
+
+    @Override
+    void ensureMinIdle() throws Exception {
+        int minIdlePerKeySave = getMinIdlePerKey();
+        if (minIdlePerKeySave < 1) {
+            return;
+        }
+
+        for (K k : poolMap.keySet()) {
+            ensureMinIdle(k);
+        }
+    }
+
+    /**
+     * Ensure that the configured number of minimum idle objects is available in
+     * the pool for the given key.
+     *
+     * @param key The key to check for idle objects
+     *
+     * @throws Exception If a new object is required and cannot be created
+     */
+    private void ensureMinIdle(K key) throws Exception {
+        // Calculate current pool objects
+        ObjectDeque<T> objectDeque = poolMap.get(key);
+
+        // objectDeque == null is OK here. It is handled correctly by both
+        // methods called below.
+
+        // this method isn't synchronized so the
+        // calculateDeficit is done at the beginning
+        // as a loop limit and a second time inside the loop
+        // to stop when another thread already returned the
+        // needed objects
+        int deficit = calculateDeficit(objectDeque);
+
+        for (int i = 0; i < deficit && calculateDeficit(objectDeque) > 0; i++) {
+            addObject(key);
+        }
+    }
+
+    /**
+     * Create an object using the {@link KeyedPooledObjectFactory#makeObject
+     * factory}, passivate it, and then place it in the idle object pool.
+     * <code>addObject</code> is useful for "pre-loading" a pool with idle
+     * objects.
+     *
+     * @param key the key a new instance should be added to
+     *
+     * @throws Exception when {@link KeyedPooledObjectFactory#makeObject}
+     *                   fails.
+     */
+    @Override
+    public void addObject(K key) throws Exception {
+        assertOpen();
+        register(key);
+        try {
+            PooledObject<T> p = create(key);
+            addIdleObject(key, p);
+        } finally {
+            deregister(key);
+        }
+    }
+
+    /**
+     * Add an object to the set of idle objects for a given key.
+     *
+     * @param key The key to associate with the idle object
+     * @param p The wrapped object to add.
+     *
+     * @throws Exception If the associated factory fails to passivate the object
+     */
+    private void addIdleObject(K key, PooledObject<T> p) throws Exception {
+
+        if (p != null) {
+            factory.passivateObject(key, p);
+            LinkedBlockingDeque<PooledObject<T>> idleObjects =
+                    poolMap.get(key).getIdleObjects();
+            if (getLifo()) {
+                idleObjects.addFirst(p);
+            } else {
+                idleObjects.addLast(p);
+            }
+        }
+    }
+
+    /**
+     * Registers a key for pool control and ensures that
+     * {@link #getMinIdlePerKey()} idle instances are created.
+     *
+     * @param key - The key to register for pool control.
+     *
+     * @throws Exception If the associated factory fails to create the necessary
+     *                   number of idle instances
+     */
+    public void preparePool(K key) throws Exception {
+        int minIdlePerKeySave = getMinIdlePerKey();
+        if (minIdlePerKeySave < 1) {
+            return;
+        }
+        ensureMinIdle(key);
+    }
+
+    /**
+     * Calculate the number of objects to test in a run of the idle object
+     * evictor.
+     *
+     * @return The number of objects to test for validity
+     */
+    private int getNumTests() {
+        int totalIdle = getNumIdle();
+        int numTests = getNumTestsPerEvictionRun();
+        if (numTests >= 0) {
+            return Math.min(numTests, totalIdle);
+        }
+        return(int)(Math.ceil(totalIdle/Math.abs((double)numTests)));
+    }
+
+    /**
+     * Calculate the number of objects that need to be created to attempt to
+     * maintain the minimum number of idle objects while not exceeded the limits
+     * on the maximum number of objects either per key or totally.
+     *
+     * @param objectDeque   The set of objects to check
+     *
+     * @return The number of new objects to create
+     */
+    private int calculateDeficit(ObjectDeque<T> objectDeque) {
+
+        if (objectDeque == null) {
+            return getMinIdlePerKey();
+        }
+
+        // Used more than once so keep a local copy so the value is consistent
+        int maxTotal = getMaxTotal();
+        int maxTotalPerKeySave = getMaxTotalPerKey();
+
+        int objectDefecit = 0;
+
+        // Calculate no of objects needed to be created, in order to have
+        // the number of pooled objects < maxTotalPerKey();
+        objectDefecit = getMinIdlePerKey() - objectDeque.getIdleObjects().size();
+        if (maxTotalPerKeySave > 0) {
+            int growLimit = Math.max(0,
+                    maxTotalPerKeySave - objectDeque.getIdleObjects().size());
+            objectDefecit = Math.min(objectDefecit, growLimit);
+        }
+
+        // Take the maxTotal limit into account
+        if (maxTotal > 0) {
+            int growLimit = Math.max(0, maxTotal - getNumActive() - getNumIdle());
+            objectDefecit = Math.min(objectDefecit, growLimit);
+        }
+
+        return objectDefecit;
+    }
+
+
+    //--- JMX support ----------------------------------------------------------
+
+    @Override
+    public Map<String,Integer> getNumActivePerKey() {
+        HashMap<String,Integer> result = new HashMap<>();
+
+        Iterator<Entry<K,ObjectDeque<T>>> iter = poolMap.entrySet().iterator();
+        while (iter.hasNext()) {
+            Entry<K,ObjectDeque<T>> entry = iter.next();
+            if (entry != null) {
+                K key = entry.getKey();
+                ObjectDeque<T> objectDequeue = entry.getValue();
+                if (key != null && objectDequeue != null) {
+                    result.put(key.toString(), Integer.valueOf(
+                            objectDequeue.getAllObjects().size() -
+                            objectDequeue.getIdleObjects().size()));
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Return an estimate of the number of threads currently blocked waiting for
+     * an object from the pool. This is intended for monitoring only, not for
+     * synchronization control.
+     *
+     * @return The estimate of the number of threads currently blocked waiting
+     *         for an object from the pool
+     */
+    @Override
+    public int getNumWaiters() {
+        int result = 0;
+
+        if (getBlockWhenExhausted()) {
+            Iterator<ObjectDeque<T>> iter = poolMap.values().iterator();
+
+            while (iter.hasNext()) {
+                // Assume no overflow
+                result += iter.next().getIdleObjects().getTakeQueueLength();
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * Return an estimate of the number of threads currently blocked waiting for
+     * an object from the pool for each key. This is intended for
+     * monitoring only, not for synchronization control.
+     *
+     * @return The estimate of the number of threads currently blocked waiting
+     *         for an object from the pool for each key
+     */
+    @Override
+    public Map<String,Integer> getNumWaitersByKey() {
+        Map<String,Integer> result = new HashMap<>();
+
+        for (K key : poolMap.keySet()) {
+            ObjectDeque<T> queue = poolMap.get(key);
+            if (queue != null) {
+                if (getBlockWhenExhausted()) {
+                    result.put(key.toString(), Integer.valueOf(
+                            queue.getIdleObjects().getTakeQueueLength()));
+                } else {
+                    result.put(key.toString(), Integer.valueOf(0));
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Provides information on all the objects in the pool, both idle (waiting
+     * to be borrowed) and active (currently borrowed).
+     * <p>
+     * Note: This is named listAllObjects so it is presented as an operation via
+     * JMX. That means it won't be invoked unless the explicitly requested
+     * whereas all attributes will be automatically requested when viewing the
+     * attributes for an object in a tool like JConsole.
+     *
+     * @return Information grouped by key on all the objects in the pool
+     */
+    @Override
+    public Map<String,List<DefaultPooledObjectInfo>> listAllObjects() {
+        Map<String,List<DefaultPooledObjectInfo>> result =
+                new HashMap<>();
+
+        for (K key : poolMap.keySet()) {
+            ObjectDeque<T> queue = poolMap.get(key);
+            if (queue != null) {
+                List<DefaultPooledObjectInfo> list =
+                        new ArrayList<>();
+                result.put(key.toString(), list);
+                for (PooledObject<T> p : queue.getAllObjects().values()) {
+                    list.add(new DefaultPooledObjectInfo(p));
+                }
+            }
+        }
+        return result;
+    }
+
+
+    //--- inner classes ----------------------------------------------
+
+    /**
+     * Maintains information on the per key queue for a given key.
+     */
+    private class ObjectDeque<S> {
+
+        private final LinkedBlockingDeque<PooledObject<S>> idleObjects =
+                new LinkedBlockingDeque<>();
+
+        /*
+         * Number of instances created - number destroyed.
+         * Invariant: createCount <= maxTotalPerKey
+         */
+        private final AtomicInteger createCount = new AtomicInteger(0);
+
+        /*
+         * The map is keyed on pooled instances.  Note: pooled instances
+         * <em>must</em> be distinguishable by equals for this structure to
+         * work properly.
+         */
+        private final Map<S, PooledObject<S>> allObjects =
+                new ConcurrentHashMap<>();
+
+        /*
+         * Number of threads with registered interest in this key.
+         * register(K) increments this counter and deRegister(K) decrements it.
+         * Invariant: empty keyed pool will not be dropped unless numInterested
+         *            is 0.
+         */
+        private final AtomicLong numInterested = new AtomicLong(0);
+
+        /**
+         * Obtain the idle objects for the current key.
+         *
+         * @return The idle objects
+         */
+        public LinkedBlockingDeque<PooledObject<S>> getIdleObjects() {
+            return idleObjects;
+        }
+
+        /**
+         * Obtain the count of the number of objects created for the current
+         * key.
+         *
+         * @return The number of objects created for this key
+         */
+        public AtomicInteger getCreateCount() {
+            return createCount;
+        }
+
+        /**
+         * Obtain the number of threads with an interest registered in this key.
+         *
+         * @return The number of threads with a registered interest in this key
+         */
+        public AtomicLong getNumInterested() {
+            return numInterested;
+        }
+
+        /**
+         * Obtain all the objects for the current key.
+         *
+         * @return All the objects
+         */
+        public Map<S, PooledObject<S>> getAllObjects() {
+            return allObjects;
+        }
+    }
+
+    //--- configuration attributes ---------------------------------------------
+    private volatile int maxIdlePerKey =
+            GenericKeyedObjectPoolConfig.DEFAULT_MAX_IDLE_PER_KEY;
+    private volatile int minIdlePerKey =
+        GenericKeyedObjectPoolConfig.DEFAULT_MIN_IDLE_PER_KEY;
+    private volatile int maxTotalPerKey =
+        GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL_PER_KEY;
+    private final KeyedPooledObjectFactory<K,T> factory;
+
+
+    //--- internal attributes --------------------------------------------------
+
+    /*
+     * My hash of sub-pools (ObjectQueue). The list of keys <b>must</b> be kept
+     * in step with {@link #poolKeyList} using {@link #keyLock} to ensure any
+     * changes to the list of current keys is made in a thread-safe manner.
+     */
+    private final Map<K,ObjectDeque<T>> poolMap =
+            new ConcurrentHashMap<>(); // @GuardedBy("keyLock") for write access (and some read access)
+    /*
+     * List of pool keys - used to control eviction order. The list of keys
+     * <b>must</b> be kept in step with {@link #poolMap} using {@link #keyLock}
+     * to ensure any changes to the list of current keys is made in a
+     * thread-safe manner.
+     */
+    private final List<K> poolKeyList = new ArrayList<>(); // @GuardedBy("keyLock")
+    private final ReadWriteLock keyLock = new ReentrantReadWriteLock(true);
+    /*
+     * The combined count of the currently active objects for all keys and those
+     * in the process of being created. Under load, it may exceed
+     * {@link #maxTotal} but there will never be more than {@link #maxTotal}
+     * created at any one time.
+     */
+    private final AtomicInteger numTotal = new AtomicInteger(0);
+    private Iterator<K> evictionKeyIterator = null; // @GuardedBy("evictionLock")
+    private K evictionKey = null; // @GuardedBy("evictionLock")
+
+    // JMX specific attributes
+    private static final String ONAME_BASE =
+        "org.apache.tomcat.dbcp.pool2:type=GenericKeyedObjectPool,name=";
+}

==================================================
GenericKeyedObjectPoolMXBean.java
new file mode 100644
index 0000000000..f6e04d3c7c
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPoolConfig.java
@@ -0,0 +1,184 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+/**
+ * A simple "struct" encapsulating the configuration for a
+ * {@link GenericKeyedObjectPool}.
+ *
+ * <p>
+ * This class is not thread-safe; it is only intended to be used to provide
+ * attributes used when creating a pool.
+ *
+ * @version $Revision: $
+ *
+ * @since 2.0
+ */
+public class GenericKeyedObjectPoolConfig extends BaseObjectPoolConfig {
+
+    /**
+     * The default value for the {@code maxTotalPerKey} configuration attribute.
+     * @see GenericKeyedObjectPool#getMaxTotalPerKey()
+     */
+    public static final int DEFAULT_MAX_TOTAL_PER_KEY = 8;
+
+    /**
+     * The default value for the {@code maxTotal} configuration attribute.
+     * @see GenericKeyedObjectPool#getMaxTotal()
+     */
+    public static final int DEFAULT_MAX_TOTAL = -1;
+
+    /**
+     * The default value for the {@code minIdlePerKey} configuration attribute.
+     * @see GenericKeyedObjectPool#getMinIdlePerKey()
+     */
+    public static final int DEFAULT_MIN_IDLE_PER_KEY = 0;
+
+    /**
+     * The default value for the {@code minIdlePerKey} configuration attribute.
+     * @see GenericKeyedObjectPool#getMaxIdlePerKey()
+     */
+    public static final int DEFAULT_MAX_IDLE_PER_KEY = 8;
+
+
+    private int minIdlePerKey = DEFAULT_MIN_IDLE_PER_KEY;
+
+    private int maxIdlePerKey = DEFAULT_MAX_IDLE_PER_KEY;
+
+    private int maxTotalPerKey = DEFAULT_MAX_TOTAL_PER_KEY;
+
+    private int maxTotal = DEFAULT_MAX_TOTAL;
+
+    /**
+     * Create a new configuration with default settings.
+     */
+    public GenericKeyedObjectPoolConfig() {
+    }
+
+    /**
+     * Get the value for the {@code maxTotal} configuration attribute
+     * for pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code maxTotal} for this
+     *          configuration instance
+     *
+     * @see GenericKeyedObjectPool#getMaxTotal()
+     */
+    public int getMaxTotal() {
+        return maxTotal;
+    }
+
+    /**
+     * Set the value for the {@code maxTotal} configuration attribute for
+     * pools created with this configuration instance.
+     *
+     * @param maxTotal The new setting of {@code maxTotal}
+     *        for this configuration instance
+     *
+     * @see GenericKeyedObjectPool#setMaxTotal(int)
+     */
+    public void setMaxTotal(int maxTotal) {
+        this.maxTotal = maxTotal;
+    }
+
+    /**
+     * Get the value for the {@code maxTotalPerKey} configuration attribute
+     * for pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code maxTotalPerKey} for this
+     *          configuration instance
+     *
+     * @see GenericKeyedObjectPool#getMaxTotalPerKey()
+     */
+    public int getMaxTotalPerKey() {
+        return maxTotalPerKey;
+    }
+
+    /**
+     * Set the value for the {@code maxTotalPerKey} configuration attribute for
+     * pools created with this configuration instance.
+     *
+     * @param maxTotalPerKey The new setting of {@code maxTotalPerKey}
+     *        for this configuration instance
+     *
+     * @see GenericKeyedObjectPool#setMaxTotalPerKey(int)
+     */
+    public void setMaxTotalPerKey(int maxTotalPerKey) {
+        this.maxTotalPerKey = maxTotalPerKey;
+    }
+
+    /**
+     * Get the value for the {@code minIdlePerKey} configuration attribute
+     * for pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code minIdlePerKey} for this
+     *          configuration instance
+     *
+     * @see GenericKeyedObjectPool#getMinIdlePerKey()
+     */
+    public int getMinIdlePerKey() {
+        return minIdlePerKey;
+    }
+
+    /**
+     * Set the value for the {@code minIdlePerKey} configuration attribute for
+     * pools created with this configuration instance.
+     *
+     * @param minIdlePerKey The new setting of {@code minIdlePerKey}
+     *        for this configuration instance
+     *
+     * @see GenericKeyedObjectPool#setMinIdlePerKey(int)
+     */
+    public void setMinIdlePerKey(int minIdlePerKey) {
+        this.minIdlePerKey = minIdlePerKey;
+    }
+
+    /**
+     * Get the value for the {@code maxIdlePerKey} configuration attribute
+     * for pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code maxIdlePerKey} for this
+     *          configuration instance
+     *
+     * @see GenericKeyedObjectPool#getMaxIdlePerKey()
+     */
+    public int getMaxIdlePerKey() {
+        return maxIdlePerKey;
+    }
+
+    /**
+     * Set the value for the {@code maxIdlePerKey} configuration attribute for
+     * pools created with this configuration instance.
+     *
+     * @param maxIdlePerKey The new setting of {@code maxIdlePerKey}
+     *        for this configuration instance
+     *
+     * @see GenericKeyedObjectPool#setMaxIdlePerKey(int)
+     */
+    public void setMaxIdlePerKey(int maxIdlePerKey) {
+        this.maxIdlePerKey = maxIdlePerKey;
+    }
+
+    @Override
+    public GenericKeyedObjectPoolConfig clone() {
+        try {
+            return (GenericKeyedObjectPoolConfig) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new AssertionError(); // Can't happen
+        }
+    }
+}

==================================================
GenericObjectPool.java
new file mode 100644
index 0000000000..eabd56f006
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPoolMXBean.java
@@ -0,0 +1,202 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Defines the methods that will be made available via JMX.
+ *
+ * NOTE: This interface exists only to define those attributes and methods that
+ *       will be made available via JMX. It must not be implemented by clients
+ *       as it is subject to change between major, minor and patch version
+ *       releases of commons pool. Clients that implement this interface may
+ *       not, therefore, be able to upgrade to a new minor or patch release
+ *       without requiring code changes.
+ *
+ * @param <K> The type of keys maintained by the pool.
+ *
+ * @version $Revision: $
+ *
+ * @since 2.0
+ */
+public interface GenericKeyedObjectPoolMXBean<K> {
+    // Expose getters for configuration settings
+    /**
+     * See {@link GenericKeyedObjectPool#getBlockWhenExhausted()}
+     * @return See {@link GenericKeyedObjectPool#getBlockWhenExhausted()}
+     */
+    boolean getBlockWhenExhausted();
+    /**
+     * See {@link GenericKeyedObjectPool#getLifo()}
+     * @return See {@link GenericKeyedObjectPool#getLifo()}
+     */
+    boolean getLifo();
+    /**
+     * See {@link GenericKeyedObjectPool#getMaxIdlePerKey()}
+     * @return See {@link GenericKeyedObjectPool#getMaxIdlePerKey()}
+     */
+    int getMaxIdlePerKey();
+    /**
+     * See {@link GenericKeyedObjectPool#getMaxTotal()}
+     * @return See {@link GenericKeyedObjectPool#getMaxTotal()}
+     */
+    int getMaxTotal();
+    /**
+     * See {@link GenericKeyedObjectPool#getMaxTotalPerKey()}
+     * @return See {@link GenericKeyedObjectPool#getMaxTotalPerKey()}
+     */
+    int getMaxTotalPerKey();
+    /**
+     * See {@link GenericKeyedObjectPool#getMaxWaitMillis()}
+     * @return See {@link GenericKeyedObjectPool#getMaxWaitMillis()}
+     */
+    long getMaxWaitMillis();
+    /**
+     * See {@link GenericKeyedObjectPool#getMinEvictableIdleTimeMillis()}
+     * @return See {@link GenericKeyedObjectPool#getMinEvictableIdleTimeMillis()}
+     */
+    long getMinEvictableIdleTimeMillis();
+    /**
+     * See {@link GenericKeyedObjectPool#getMinIdlePerKey()}
+     * @return See {@link GenericKeyedObjectPool#getMinIdlePerKey()}
+     */
+    int getMinIdlePerKey();
+    /**
+     * See {@link GenericKeyedObjectPool#getNumActive()}
+     * @return See {@link GenericKeyedObjectPool#getNumActive()}
+     */
+    int getNumActive();
+    /**
+     * See {@link GenericKeyedObjectPool#getNumIdle()}
+     * @return See {@link GenericKeyedObjectPool#getNumIdle()}
+     */
+    int getNumIdle();
+    /**
+     * See {@link GenericKeyedObjectPool#getNumTestsPerEvictionRun()}
+     * @return See {@link GenericKeyedObjectPool#getNumTestsPerEvictionRun()}
+     */
+    int getNumTestsPerEvictionRun();
+    /**
+     * See {@link GenericKeyedObjectPool#getTestOnCreate()}
+     * @return See {@link GenericKeyedObjectPool#getTestOnCreate()}
+     * @since 2.2
+     */
+    boolean getTestOnCreate();
+    /**
+     * See {@link GenericKeyedObjectPool#getTestOnBorrow()}
+     * @return See {@link GenericKeyedObjectPool#getTestOnBorrow()}
+     */
+    boolean getTestOnBorrow();
+    /**
+     * See {@link GenericKeyedObjectPool#getTestOnReturn()}
+     * @return See {@link GenericKeyedObjectPool#getTestOnReturn()}
+     */
+    boolean getTestOnReturn();
+    /**
+     * See {@link GenericKeyedObjectPool#getTestWhileIdle()}
+     * @return See {@link GenericKeyedObjectPool#getTestWhileIdle()}
+     */
+    boolean getTestWhileIdle();
+    /**
+     * See {@link GenericKeyedObjectPool#getTimeBetweenEvictionRunsMillis()}
+     * @return See {@link GenericKeyedObjectPool#getTimeBetweenEvictionRunsMillis()}
+     */
+    long getTimeBetweenEvictionRunsMillis();
+    /**
+     * See {@link GenericKeyedObjectPool#isClosed()}
+     * @return See {@link GenericKeyedObjectPool#isClosed()}
+     */
+    boolean isClosed();
+    // Expose getters for monitoring attributes
+    /**
+     * See {@link GenericKeyedObjectPool#getNumActivePerKey()}
+     * @return See {@link GenericKeyedObjectPool#getNumActivePerKey()}
+     */
+    Map<String,Integer> getNumActivePerKey();
+    /**
+     * See {@link GenericKeyedObjectPool#getBorrowedCount()}
+     * @return See {@link GenericKeyedObjectPool#getBorrowedCount()}
+     */
+    long getBorrowedCount();
+    /**
+     * See {@link GenericKeyedObjectPool#getReturnedCount()}
+     * @return See {@link GenericKeyedObjectPool#getReturnedCount()}
+     */
+    long getReturnedCount();
+    /**
+     * See {@link GenericKeyedObjectPool#getCreatedCount()}
+     * @return See {@link GenericKeyedObjectPool#getCreatedCount()}
+     */
+    long getCreatedCount();
+    /**
+     * See {@link GenericKeyedObjectPool#getDestroyedCount()}
+     * @return See {@link GenericKeyedObjectPool#getDestroyedCount()}
+     */
+    long getDestroyedCount();
+    /**
+     * See {@link GenericKeyedObjectPool#getDestroyedByEvictorCount()}
+     * @return See {@link GenericKeyedObjectPool#getDestroyedByEvictorCount()}
+     */
+    long getDestroyedByEvictorCount();
+    /**
+     * See {@link GenericKeyedObjectPool#getDestroyedByBorrowValidationCount()}
+     * @return See {@link GenericKeyedObjectPool#getDestroyedByBorrowValidationCount()}
+     */
+    long getDestroyedByBorrowValidationCount();
+    /**
+     * See {@link GenericKeyedObjectPool#getMeanActiveTimeMillis()}
+     * @return See {@link GenericKeyedObjectPool#getMeanActiveTimeMillis()}
+     */
+    long getMeanActiveTimeMillis();
+    /**
+     * See {@link GenericKeyedObjectPool#getMeanIdleTimeMillis()}
+     * @return See {@link GenericKeyedObjectPool#getMeanIdleTimeMillis()}
+     */
+    long getMeanIdleTimeMillis();
+    /**
+     * See {@link GenericKeyedObjectPool#getMaxBorrowWaitTimeMillis()}
+     * @return See {@link GenericKeyedObjectPool#getMaxBorrowWaitTimeMillis()}
+     */
+    long getMeanBorrowWaitTimeMillis();
+    /**
+     * See {@link GenericKeyedObjectPool#getMaxBorrowWaitTimeMillis()}
+     * @return See {@link GenericKeyedObjectPool#getMaxBorrowWaitTimeMillis()}
+     */
+    long getMaxBorrowWaitTimeMillis();
+    /**
+     * See {@link GenericKeyedObjectPool#getCreationStackTrace()}
+     * @return See {@link GenericKeyedObjectPool#getCreationStackTrace()}
+     */
+    String getCreationStackTrace();
+    /**
+     * See {@link GenericKeyedObjectPool#getNumWaiters()}
+     * @return See {@link GenericKeyedObjectPool#getNumWaiters()}
+     */
+    int getNumWaiters();
+    /**
+     * See {@link GenericKeyedObjectPool#getNumWaitersByKey()}
+     * @return See {@link GenericKeyedObjectPool#getNumWaitersByKey()}
+     */
+    Map<String,Integer> getNumWaitersByKey();
+    /**
+     * See {@link GenericKeyedObjectPool#listAllObjects()}
+     * @return See {@link GenericKeyedObjectPool#listAllObjects()}
+     */
+    Map<String,List<DefaultPooledObjectInfo>> listAllObjects();
+}

==================================================
GenericObjectPoolConfig.java
new file mode 100644
index 0000000000..a090a884ac
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java
@@ -0,0 +1,1111 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.tomcat.dbcp.pool2.ObjectPool;
+import org.apache.tomcat.dbcp.pool2.PoolUtils;
+import org.apache.tomcat.dbcp.pool2.PooledObject;
+import org.apache.tomcat.dbcp.pool2.PooledObjectFactory;
+import org.apache.tomcat.dbcp.pool2.PooledObjectState;
+import org.apache.tomcat.dbcp.pool2.UsageTracking;
+
+/**
+ * A configurable {@link ObjectPool} implementation.
+ * <p>
+ * When coupled with the appropriate {@link PooledObjectFactory},
+ * <code>GenericObjectPool</code> provides robust pooling functionality for
+ * arbitrary objects.</p>
+ * <p>
+ * Optionally, one may configure the pool to examine and possibly evict objects
+ * as they sit idle in the pool and to ensure that a minimum number of idle
+ * objects are available. This is performed by an "idle object eviction" thread,
+ * which runs asynchronously. Caution should be used when configuring this
+ * optional feature. Eviction runs contend with client threads for access to
+ * objects in the pool, so if they run too frequently performance issues may
+ * result.</p>
+ * <p>
+ * The pool can also be configured to detect and remove "abandoned" objects,
+ * i.e. objects that have been checked out of the pool but neither used nor
+ * returned before the configured
+ * {@link AbandonedConfig#getRemoveAbandonedTimeout() removeAbandonedTimeout}.
+ * Abandoned object removal can be configured to happen when
+ * <code>borrowObject</code> is invoked and the pool is close to starvation, or
+ * it can be executed by the idle object evictor, or both. If pooled objects
+ * implement the {@link org.apache.tomcat.dbcp.pool2.TrackedUse} interface,
+ * their last use will be queried
+ * using the <code>getLastUsed</code> method on that interface; otherwise
+ * abandonment is determined by how long an object has been checked out from
+ * the pool.</p>
+ * <p>
+ * Implementation note: To prevent possible deadlocks, care has been taken to
+ * ensure that no call to a factory method will occur within a synchronization
+ * block. See POOL-125 and DBCP-44 for more information.</p>
+ * <p>
+ * This class is intended to be thread-safe.</p>
+ *
+ * @see GenericKeyedObjectPool
+ *
+ * @param <T> Type of element pooled in this pool.
+ *
+ * @version $Revision$
+ *
+ * @since 2.0
+ */
+public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
+        implements ObjectPool<T>, GenericObjectPoolMXBean, UsageTracking<T> {
+
+    /**
+     * Create a new <code>GenericObjectPool</code> using defaults from
+     * {@link GenericObjectPoolConfig}.
+     *
+     * @param factory The object factory to be used to create object instances
+     *                used by this pool
+     */
+    public GenericObjectPool(PooledObjectFactory<T> factory) {
+        this(factory, new GenericObjectPoolConfig());
+    }
+
+    /**
+     * Create a new <code>GenericObjectPool</code> using a specific
+     * configuration.
+     *
+     * @param factory   The object factory to be used to create object instances
+     *                  used by this pool
+     * @param config    The configuration to use for this pool instance. The
+     *                  configuration is used by value. Subsequent changes to
+     *                  the configuration object will not be reflected in the
+     *                  pool.
+     */
+    public GenericObjectPool(PooledObjectFactory<T> factory,
+            GenericObjectPoolConfig config) {
+
+        super(config, ONAME_BASE, config.getJmxNamePrefix());
+
+        if (factory == null) {
+            jmxUnregister(); // tidy up
+            throw new IllegalArgumentException("factory may not be null");
+        }
+        this.factory = factory;
+
+        setConfig(config);
+
+        startEvictor(getTimeBetweenEvictionRunsMillis());
+    }
+
+    /**
+     * Create a new <code>GenericObjectPool</code> that tracks and destroys
+     * objects that are checked out, but never returned to the pool.
+     *
+     * @param factory   The object factory to be used to create object instances
+     *                  used by this pool
+     * @param config    The base pool configuration to use for this pool instance.
+     *                  The configuration is used by value. Subsequent changes to
+     *                  the configuration object will not be reflected in the
+     *                  pool.
+     * @param abandonedConfig  Configuration for abandoned object identification
+     *                         and removal.  The configuration is used by value.
+     */
+    public GenericObjectPool(PooledObjectFactory<T> factory,
+            GenericObjectPoolConfig config, AbandonedConfig abandonedConfig) {
+        this(factory, config);
+        setAbandonedConfig(abandonedConfig);
+    }
+
+    /**
+     * Returns the cap on the number of "idle" instances in the pool. If maxIdle
+     * is set too low on heavily loaded systems it is possible you will see
+     * objects being destroyed and almost immediately new objects being created.
+     * This is a result of the active threads momentarily returning objects
+     * faster than they are requesting them them, causing the number of idle
+     * objects to rise above maxIdle. The best value for maxIdle for heavily
+     * loaded system will vary but the default is a good starting point.
+     *
+     * @return the maximum number of "idle" instances that can be held in the
+     *         pool or a negative value if there is no limit
+     *
+     * @see #setMaxIdle
+     */
+    @Override
+    public int getMaxIdle() {
+        return maxIdle;
+    }
+
+    /**
+     * Returns the cap on the number of "idle" instances in the pool. If maxIdle
+     * is set too low on heavily loaded systems it is possible you will see
+     * objects being destroyed and almost immediately new objects being created.
+     * This is a result of the active threads momentarily returning objects
+     * faster than they are requesting them them, causing the number of idle
+     * objects to rise above maxIdle. The best value for maxIdle for heavily
+     * loaded system will vary but the default is a good starting point.
+     *
+     * @param maxIdle
+     *            The cap on the number of "idle" instances in the pool. Use a
+     *            negative value to indicate an unlimited number of idle
+     *            instances
+     *
+     * @see #getMaxIdle
+     */
+    public void setMaxIdle(int maxIdle) {
+        this.maxIdle = maxIdle;
+    }
+
+    /**
+     * Sets the target for the minimum number of idle objects to maintain in
+     * the pool. This setting only has an effect if it is positive and
+     * {@link #getTimeBetweenEvictionRunsMillis()} is greater than zero. If this
+     * is the case, an attempt is made to ensure that the pool has the required
+     * minimum number of instances during idle object eviction runs.
+     * <p>
+     * If the configured value of minIdle is greater than the configured value
+     * for maxIdle then the value of maxIdle will be used instead.
+     *
+     * @param minIdle
+     *            The minimum number of objects.
+     *
+     * @see #getMinIdle()
+     * @see #getMaxIdle()
+     * @see #getTimeBetweenEvictionRunsMillis()
+     */
+    public void setMinIdle(int minIdle) {
+        this.minIdle = minIdle;
+    }
+
+    /**
+     * Returns the target for the minimum number of idle objects to maintain in
+     * the pool. This setting only has an effect if it is positive and
+     * {@link #getTimeBetweenEvictionRunsMillis()} is greater than zero. If this
+     * is the case, an attempt is made to ensure that the pool has the required
+     * minimum number of instances during idle object eviction runs.
+     * <p>
+     * If the configured value of minIdle is greater than the configured value
+     * for maxIdle then the value of maxIdle will be used instead.
+     *
+     * @return The minimum number of objects.
+     *
+     * @see #setMinIdle(int)
+     * @see #setMaxIdle(int)
+     * @see #setTimeBetweenEvictionRunsMillis(long)
+     */
+    @Override
+    public int getMinIdle() {
+        int maxIdleSave = getMaxIdle();
+        if (this.minIdle > maxIdleSave) {
+            return maxIdleSave;
+        } else {
+            return minIdle;
+        }
+    }
+
+    /**
+     * Whether or not abandoned object removal is configured for this pool.
+     *
+     * @return true if this pool is configured to detect and remove
+     * abandoned objects
+     */
+    @Override
+    public boolean isAbandonedConfig() {
+        return abandonedConfig != null;
+    }
+
+    /**
+     * Will this pool identify and log any abandoned objects?
+     *
+     * @return {@code true} if abandoned object removal is configured for this
+     *         pool and removal events are to be logged otherwise {@code false}
+     *
+     * @see AbandonedConfig#getLogAbandoned()
+     */
+    @Override
+    public boolean getLogAbandoned() {
+        AbandonedConfig ac = this.abandonedConfig;
+        return ac != null && ac.getLogAbandoned();
+    }
+
+    /**
+     * Will a check be made for abandoned objects when an object is borrowed
+     * from this pool?
+     *
+     * @return {@code true} if abandoned object removal is configured to be
+     *         activated by borrowObject otherwise {@code false}
+     *
+     * @see AbandonedConfig#getRemoveAbandonedOnBorrow()
+     */
+    @Override
+    public boolean getRemoveAbandonedOnBorrow() {
+        AbandonedConfig ac = this.abandonedConfig;
+        return ac != null && ac.getRemoveAbandonedOnBorrow();
+    }
+
+    /**
+     * Will a check be made for abandoned objects when the evictor runs?
+     *
+     * @return {@code true} if abandoned object removal is configured to be
+     *         activated when the evictor runs otherwise {@code false}
+     *
+     * @see AbandonedConfig#getRemoveAbandonedOnMaintenance()
+     */
+    @Override
+    public boolean getRemoveAbandonedOnMaintenance() {
+        AbandonedConfig ac = this.abandonedConfig;
+        return ac != null && ac.getRemoveAbandonedOnMaintenance();
+    }
+
+    /**
+     * Obtain the timeout before which an object will be considered to be
+     * abandoned by this pool.
+     *
+     * @return The abandoned object timeout in seconds if abandoned object
+     *         removal is configured for this pool; Integer.MAX_VALUE otherwise.
+     *
+     * @see AbandonedConfig#getRemoveAbandonedTimeout()
+     */
+    @Override
+    public int getRemoveAbandonedTimeout() {
+        AbandonedConfig ac = this.abandonedConfig;
+        return ac != null ? ac.getRemoveAbandonedTimeout() : Integer.MAX_VALUE;
+    }
+
+
+    /**
+     * Sets the base pool configuration.
+     *
+     * @param conf the new configuration to use. This is used by value.
+     *
+     * @see GenericObjectPoolConfig
+     */
+    public void setConfig(GenericObjectPoolConfig conf) {
+        setLifo(conf.getLifo());
+        setMaxIdle(conf.getMaxIdle());
+        setMinIdle(conf.getMinIdle());
+        setMaxTotal(conf.getMaxTotal());
+        setMaxWaitMillis(conf.getMaxWaitMillis());
+        setBlockWhenExhausted(conf.getBlockWhenExhausted());
+        setTestOnCreate(conf.getTestOnCreate());
+        setTestOnBorrow(conf.getTestOnBorrow());
+        setTestOnReturn(conf.getTestOnReturn());
+        setTestWhileIdle(conf.getTestWhileIdle());
+        setNumTestsPerEvictionRun(conf.getNumTestsPerEvictionRun());
+        setMinEvictableIdleTimeMillis(conf.getMinEvictableIdleTimeMillis());
+        setTimeBetweenEvictionRunsMillis(
+                conf.getTimeBetweenEvictionRunsMillis());
+        setSoftMinEvictableIdleTimeMillis(
+                conf.getSoftMinEvictableIdleTimeMillis());
+        setEvictionPolicyClassName(conf.getEvictionPolicyClassName());
+    }
+
+    /**
+     * Sets the abandoned object removal configuration.
+     *
+     * @param abandonedConfig the new configuration to use. This is used by value.
+     *
+     * @see AbandonedConfig
+     */
+    public void setAbandonedConfig(AbandonedConfig abandonedConfig) throws IllegalArgumentException {
+        if (abandonedConfig == null) {
+            this.abandonedConfig = null;
+        } else {
+            this.abandonedConfig = new AbandonedConfig();
+            this.abandonedConfig.setLogAbandoned(abandonedConfig.getLogAbandoned());
+            this.abandonedConfig.setLogWriter(abandonedConfig.getLogWriter());
+            this.abandonedConfig.setRemoveAbandonedOnBorrow(abandonedConfig.getRemoveAbandonedOnBorrow());
+            this.abandonedConfig.setRemoveAbandonedOnMaintenance(abandonedConfig.getRemoveAbandonedOnMaintenance());
+            this.abandonedConfig.setRemoveAbandonedTimeout(abandonedConfig.getRemoveAbandonedTimeout());
+            this.abandonedConfig.setUseUsageTracking(abandonedConfig.getUseUsageTracking());
+        }
+    }
+
+    /**
+     * Obtain a reference to the factory used to create, destroy and validate
+     * the objects used by this pool.
+     *
+     * @return the factory
+     */
+    public PooledObjectFactory<T> getFactory() {
+        return factory;
+    }
+
+    /**
+     * Equivalent to <code>{@link #borrowObject(long)
+     * borrowObject}({@link #getMaxWaitMillis()})</code>.
+     * <p>
+     * {@inheritDoc}
+     */
+    @Override
+    public T borrowObject() throws Exception {
+        return borrowObject(getMaxWaitMillis());
+    }
+
+    /**
+     * Borrow an object from the pool using the specific waiting time which only
+     * applies if {@link #getBlockWhenExhausted()} is true.
+     * <p>
+     * If there is one or more idle instance available in the pool, then an
+     * idle instance will be selected based on the value of {@link #getLifo()},
+     * activated and returned. If activation fails, or {@link #getTestOnBorrow()
+     * testOnBorrow} is set to <code>true</code> and validation fails, the
+     * instance is destroyed and the next available instance is examined. This
+     * continues until either a valid instance is returned or there are no more
+     * idle instances available.
+     * <p>
+     * If there are no idle instances available in the pool, behavior depends on
+     * the {@link #getMaxTotal() maxTotal}, (if applicable)
+     * {@link #getBlockWhenExhausted()} and the value passed in to the
+     * <code>borrowMaxWaitMillis</code> parameter. If the number of instances
+     * checked out from the pool is less than <code>maxTotal,</code> a new
+     * instance is created, activated and (if applicable) validated and returned
+     * to the caller. If validation fails, a <code>NoSuchElementException</code>
+     * is thrown.
+     * <p>
+     * If the pool is exhausted (no available idle instances and no capacity to
+     * create new ones), this method will either block (if
+     * {@link #getBlockWhenExhausted()} is true) or throw a
+     * <code>NoSuchElementException</code> (if
+     * {@link #getBlockWhenExhausted()} is false). The length of time that this
+     * method will block when {@link #getBlockWhenExhausted()} is true is
+     * determined by the value passed in to the <code>borrowMaxWaitMillis</code>
+     * parameter.
+     * <p>
+     * When the pool is exhausted, multiple calling threads may be
+     * simultaneously blocked waiting for instances to become available. A
+     * "fairness" algorithm has been implemented to ensure that threads receive
+     * available instances in request arrival order.
+     *
+     * @param borrowMaxWaitMillis The time to wait in milliseconds for an object
+     *                            to become available
+     *
+     * @return object instance from the pool
+     *
+     * @throws NoSuchElementException if an instance cannot be returned
+     *
+     * @throws Exception if an object instance cannot be returned due to an
+     *                   error
+     */
+    public T borrowObject(long borrowMaxWaitMillis) throws Exception {
+        assertOpen();
+
+        AbandonedConfig ac = this.abandonedConfig;
+        if (ac != null && ac.getRemoveAbandonedOnBorrow() &&
+                (getNumIdle() < 2) &&
+                (getNumActive() > getMaxTotal() - 3) ) {
+            removeAbandoned(ac);
+        }
+
+        PooledObject<T> p = null;
+
+        // Get local copy of current config so it is consistent for entire
+        // method execution
+        boolean blockWhenExhausted = getBlockWhenExhausted();
+
+        boolean create;
+        long waitTime = 0;
+
+        while (p == null) {
+            create = false;
+            if (blockWhenExhausted) {
+                p = idleObjects.pollFirst();
+                if (p == null) {
+                    create = true;
+                    p = create();
+                }
+                if (p == null) {
+                    if (borrowMaxWaitMillis < 0) {
+                        p = idleObjects.takeFirst();
+                    } else {
+                        waitTime = System.currentTimeMillis();
+                        p = idleObjects.pollFirst(borrowMaxWaitMillis,
+                                TimeUnit.MILLISECONDS);
+                        waitTime = System.currentTimeMillis() - waitTime;
+                    }
+                }
+                if (p == null) {
+                    throw new NoSuchElementException(
+                            "Timeout waiting for idle object");
+                }
+                if (!p.allocate()) {
+                    p = null;
+                }
+            } else {
+                p = idleObjects.pollFirst();
+                if (p == null) {
+                    create = true;
+                    p = create();
+                }
+                if (p == null) {
+                    throw new NoSuchElementException("Pool exhausted");
+                }
+                if (!p.allocate()) {
+                    p = null;
+                }
+            }
+
+            if (p != null) {
+                try {
+                    factory.activateObject(p);
+                } catch (Exception e) {
+                    try {
+                        destroy(p);
+                    } catch (Exception e1) {
+                        // Ignore - activation failure is more important
+                    }
+                    p = null;
+                    if (create) {
+                        NoSuchElementException nsee = new NoSuchElementException(
+                                "Unable to activate object");
+                        nsee.initCause(e);
+                        throw nsee;
+                    }
+                }
+                if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {
+                    boolean validate = false;
+                    Throwable validationThrowable = null;
+                    try {
+                        validate = factory.validateObject(p);
+                    } catch (Throwable t) {
+                        PoolUtils.checkRethrow(t);
+                        validationThrowable = t;
+                    }
+                    if (!validate) {
+                        try {
+                            destroy(p);
+                            destroyedByBorrowValidationCount.incrementAndGet();
+                        } catch (Exception e) {
+                            // Ignore - validation failure is more important
+                        }
+                        p = null;
+                        if (create) {
+                            NoSuchElementException nsee = new NoSuchElementException(
+                                    "Unable to validate object");
+                            nsee.initCause(validationThrowable);
+                            throw nsee;
+                        }
+                    }
+                }
+            }
+        }
+
+        updateStatsBorrow(p, waitTime);
+
+        return p.getObject();
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * If {@link #getMaxIdle() maxIdle} is set to a positive value and the
+     * number of idle instances has reached this value, the returning instance
+     * is destroyed.
+     * <p>
+     * If {@link #getTestOnReturn() testOnReturn} == true, the returning
+     * instance is validated before being returned to the idle instance pool. In
+     * this case, if validation fails, the instance is destroyed.
+     * <p>
+     * Exceptions encountered destroying objects for any reason are swallowed
+     * but notified via a
+     * {@link org.apache.tomcat.dbcp.pool2.SwallowedExceptionListener}.
+     */
+    @Override
+    public void returnObject(T obj) {
+        PooledObject<T> p = allObjects.get(obj);
+
+        if (!isAbandonedConfig()) {
+            if (p == null) {
+                throw new IllegalStateException(
+                        "Returned object not currently part of this pool");
+            }
+        } else {
+            if (p == null) {
+                return;  // Object was abandoned and removed
+            } else {
+                // Make sure object is not being reclaimed
+                synchronized(p) {
+                    final PooledObjectState state = p.getState();
+                    if (state != PooledObjectState.ALLOCATED) {
+                        throw new IllegalStateException(
+                                "Object has already been returned to this pool or is invalid");
+                    } else {
+                        p.markReturning(); // Keep from being marked abandoned
+                    }
+                }
+            }
+        }
+
+        long activeTime = p.getActiveTimeMillis();
+
+        if (getTestOnReturn()) {
+            if (!factory.validateObject(p)) {
+                try {
+                    destroy(p);
+                } catch (Exception e) {
+                    swallowException(e);
+                }
+                try {
+                    ensureIdle(1, false);
+                } catch (Exception e) {
+                    swallowException(e);
+                }
+                updateStatsReturn(activeTime);
+                return;
+            }
+        }
+
+        try {
+            factory.passivateObject(p);
+        } catch (Exception e1) {
+            swallowException(e1);
+            try {
+                destroy(p);
+            } catch (Exception e) {
+                swallowException(e);
+            }
+            try {
+                ensureIdle(1, false);
+            } catch (Exception e) {
+                swallowException(e);
+            }
+            updateStatsReturn(activeTime);
+            return;
+        }
+
+        if (!p.deallocate()) {
+            throw new IllegalStateException(
+                    "Object has already been returned to this pool or is invalid");
+        }
+
+        int maxIdleSave = getMaxIdle();
+        if (isClosed() || maxIdleSave > -1 && maxIdleSave <= idleObjects.size()) {
+            try {
+                destroy(p);
+            } catch (Exception e) {
+                swallowException(e);
+            }
+        } else {
+            if (getLifo()) {
+                idleObjects.addFirst(p);
+            } else {
+                idleObjects.addLast(p);
+            }
+        }
+        updateStatsReturn(activeTime);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Activation of this method decrements the active count and attempts to
+     * destroy the instance.
+     *
+     * @throws Exception             if an exception occurs destroying the
+     *                               object
+     * @throws IllegalStateException if obj does not belong to this pool
+     */
+    @Override
+    public void invalidateObject(T obj) throws Exception {
+        PooledObject<T> p = allObjects.get(obj);
+        if (p == null) {
+            if (isAbandonedConfig()) {
+                return;
+            } else {
+                throw new IllegalStateException(
+                        "Invalidated object not currently part of this pool");
+            }
+        }
+        synchronized (p) {
+            if (p.getState() != PooledObjectState.INVALID) {
+                destroy(p);
+            }
+        }
+        ensureIdle(1, false);
+    }
+
+    /**
+     * Clears any objects sitting idle in the pool by removing them from the
+     * idle instance pool and then invoking the configured
+     * {@link PooledObjectFactory#destroyObject(PooledObject)} method on each
+     * idle instance.
+     * <p>
+     * Implementation notes:
+     * <ul>
+     * <li>This method does not destroy or effect in any way instances that are
+     * checked out of the pool when it is invoked.</li>
+     * <li>Invoking this method does not prevent objects being returned to the
+     * idle instance pool, even during its execution. Additional instances may
+     * be returned while removed items are being destroyed.</li>
+     * <li>Exceptions encountered destroying idle instances are swallowed
+     * but notified via a
+     * {@link org.apache.tomcat.dbcp.pool2.SwallowedExceptionListener}.</li>
+     * </ul>
+     */
+    @Override
+    public void clear() {
+        PooledObject<T> p = idleObjects.poll();
+
+        while (p != null) {
+            try {
+                destroy(p);
+            } catch (Exception e) {
+                swallowException(e);
+            }
+            p = idleObjects.poll();
+        }
+    }
+
+    @Override
+    public int getNumActive() {
+        return allObjects.size() - idleObjects.size();
+    }
+
+    @Override
+    public int getNumIdle() {
+        return idleObjects.size();
+    }
+
+    /**
+     * Closes the pool. Once the pool is closed, {@link #borrowObject()} will
+     * fail with IllegalStateException, but {@link #returnObject(Object)} and
+     * {@link #invalidateObject(Object)} will continue to work, with returned
+     * objects destroyed on return.
+     * <p>
+     * Destroys idle instances in the pool by invoking {@link #clear()}.
+     */
+    @Override
+    public void close() {
+        if (isClosed()) {
+            return;
+        }
+
+        synchronized (closeLock) {
+            if (isClosed()) {
+                return;
+            }
+
+            // Stop the evictor before the pool is closed since evict() calls
+            // assertOpen()
+            startEvictor(-1L);
+
+            closed = true;
+            // This clear removes any idle objects
+            clear();
+
+            jmxUnregister();
+
+            // Release any threads that were waiting for an object
+            idleObjects.interuptTakeWaiters();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Successive activations of this method examine objects in sequence,
+     * cycling through objects in oldest-to-youngest order.
+     */
+    @Override
+    public void evict() throws Exception {
+        assertOpen();
+
+        if (idleObjects.size() > 0) {
+
+            PooledObject<T> underTest = null;
+            EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
+
+            synchronized (evictionLock) {
+                EvictionConfig evictionConfig = new EvictionConfig(
+                        getMinEvictableIdleTimeMillis(),
+                        getSoftMinEvictableIdleTimeMillis(),
+                        getMinIdle());
+
+                boolean testWhileIdle = getTestWhileIdle();
+
+                for (int i = 0, m = getNumTests(); i < m; i++) {
+                    if (evictionIterator == null || !evictionIterator.hasNext()) {
+                        if (getLifo()) {
+                            evictionIterator = idleObjects.descendingIterator();
+                        } else {
+                            evictionIterator = idleObjects.iterator();
+                        }
+                    }
+                    if (!evictionIterator.hasNext()) {
+                        // Pool exhausted, nothing to do here
+                        return;
+                    }
+
+                    try {
+                        underTest = evictionIterator.next();
+                    } catch (NoSuchElementException nsee) {
+                        // Object was borrowed in another thread
+                        // Don't count this as an eviction test so reduce i;
+                        i--;
+                        evictionIterator = null;
+                        continue;
+                    }
+
+                    if (!underTest.startEvictionTest()) {
+                        // Object was borrowed in another thread
+                        // Don't count this as an eviction test so reduce i;
+                        i--;
+                        continue;
+                    }
+
+                    if (evictionPolicy.evict(evictionConfig, underTest,
+                            idleObjects.size())) {
+                        destroy(underTest);
+                        destroyedByEvictorCount.incrementAndGet();
+                    } else {
+                        if (testWhileIdle) {
+                            boolean active = false;
+                            try {
+                                factory.activateObject(underTest);
+                                active = true;
+                            } catch (Exception e) {
+                                destroy(underTest);
+                                destroyedByEvictorCount.incrementAndGet();
+                            }
+                            if (active) {
+                                if (!factory.validateObject(underTest)) {
+                                    destroy(underTest);
+                                    destroyedByEvictorCount.incrementAndGet();
+                                } else {
+                                    try {
+                                        factory.passivateObject(underTest);
+                                    } catch (Exception e) {
+                                        destroy(underTest);
+                                        destroyedByEvictorCount.incrementAndGet();
+                                    }
+                                }
+                            }
+                        }
+                        if (!underTest.endEvictionTest(idleObjects)) {
+                            // TODO - May need to add code here once additional
+                            // states are used
+                        }
+                    }
+                }
+            }
+        }
+        AbandonedConfig ac = this.abandonedConfig;
+        if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
+            removeAbandoned(ac);
+        }
+    }
+
+    /**
+     * Attempts to create a new wrapped pooled object.
+     * <p>
+     * If there are {@link #getMaxTotal()} objects already in circulation
+     * or in process of being created, this method returns null.
+     *
+     * @return The new wrapped pooled object
+     *
+     * @throws Exception if the object factory's {@code makeObject} fails
+     */
+    private PooledObject<T> create() throws Exception {
+        int localMaxTotal = getMaxTotal();
+        long newCreateCount = createCount.incrementAndGet();
+        if (localMaxTotal > -1 && newCreateCount > localMaxTotal ||
+                newCreateCount > Integer.MAX_VALUE) {
+            createCount.decrementAndGet();
+            return null;
+        }
+
+        final PooledObject<T> p;
+        try {
+            p = factory.makeObject();
+        } catch (Exception e) {
+            createCount.decrementAndGet();
+            throw e;
+        }
+
+        AbandonedConfig ac = this.abandonedConfig;
+        if (ac != null && ac.getLogAbandoned()) {
+            p.setLogAbandoned(true);
+        }
+
+        createdCount.incrementAndGet();
+        allObjects.put(p.getObject(), p);
+        return p;
+    }
+
+    /**
+     * Destroys a wrapped pooled object.
+     *
+     * @param toDestory The wrapped pooled object to destroy
+     *
+     * @throws Exception If the factory fails to destroy the pooled object
+     *                   cleanly
+     */
+    private void destroy(PooledObject<T> toDestory) throws Exception {
+        toDestory.invalidate();
+        idleObjects.remove(toDestory);
+        allObjects.remove(toDestory.getObject());
+        try {
+            factory.destroyObject(toDestory);
+        } finally {
+            destroyedCount.incrementAndGet();
+            createCount.decrementAndGet();
+        }
+    }
+
+    @Override
+    void ensureMinIdle() throws Exception {
+        ensureIdle(getMinIdle(), true);
+    }
+
+    /**
+     * Tries to ensure that {@code idleCount} idle instances exist in the pool.
+     * <p>
+     * Creates and adds idle instances until either {@link #getNumIdle()} reaches {@code idleCount}
+     * or the total number of objects (idle, checked out, or being created) reaches
+     * {@link #getMaxTotal()}. If {@code always} is false, no instances are created unless
+     * there are threads waiting to check out instances from the pool.
+     *
+     * @param idleCount the number of idle instances desired
+     * @param always true means create instances even if the pool has no threads waiting
+     * @throws Exception if the factory's makeObject throws
+     */
+    private void ensureIdle(int idleCount, boolean always) throws Exception {
+        if (idleCount < 1 || isClosed() || (!always && !idleObjects.hasTakeWaiters())) {
+            return;
+        }
+
+        while (idleObjects.size() < idleCount) {
+            PooledObject<T> p = create();
+            if (p == null) {
+                // Can't create objects, no reason to think another call to
+                // create will work. Give up.
+                break;
+            }
+            if (getLifo()) {
+                idleObjects.addFirst(p);
+            } else {
+                idleObjects.addLast(p);
+            }
+        }
+    }
+
+    /**
+     * Create an object, and place it into the pool. addObject() is useful for
+     * "pre-loading" a pool with idle objects.
+     */
+    @Override
+    public void addObject() throws Exception {
+        assertOpen();
+        if (factory == null) {
+            throw new IllegalStateException(
+                    "Cannot add objects without a factory.");
+        }
+        PooledObject<T> p = create();
+        addIdleObject(p);
+    }
+
+    /**
+     * Add the provided wrapped pooled object to the set of idle objects for
+     * this pool. The object must already be part of the pool.
+     *
+     * @param p The object to make idle
+     *
+     * @throws Exception If the factory fails to passivate the object
+     */
+    private void addIdleObject(PooledObject<T> p) throws Exception {
+        if (p != null) {
+            factory.passivateObject(p);
+            if (getLifo()) {
+                idleObjects.addFirst(p);
+            } else {
+                idleObjects.addLast(p);
+            }
+        }
+    }
+
+    /**
+     * Calculate the number of objects to test in a run of the idle object
+     * evictor.
+     *
+     * @return The number of objects to test for validity
+     */
+    private int getNumTests() {
+        int numTestsPerEvictionRun = getNumTestsPerEvictionRun();
+        if (numTestsPerEvictionRun >= 0) {
+            return Math.min(numTestsPerEvictionRun, idleObjects.size());
+        } else {
+            return (int) (Math.ceil(idleObjects.size() /
+                    Math.abs((double) numTestsPerEvictionRun)));
+        }
+    }
+
+    /**
+     * Recover abandoned objects which have been checked out but
+     * not used since longer than the removeAbandonedTimeout.
+     *
+     * @param ac The configuration to use to identify abandoned objects
+     */
+    private void removeAbandoned(AbandonedConfig ac) {
+        // Generate a list of abandoned objects to remove
+        final long now = System.currentTimeMillis();
+        final long timeout =
+                now - (ac.getRemoveAbandonedTimeout() * 1000L);
+        ArrayList<PooledObject<T>> remove = new ArrayList<>();
+        Iterator<PooledObject<T>> it = allObjects.values().iterator();
+        while (it.hasNext()) {
+            PooledObject<T> pooledObject = it.next();
+            synchronized (pooledObject) {
+                if (pooledObject.getState() == PooledObjectState.ALLOCATED &&
+                        pooledObject.getLastUsedTime() <= timeout) {
+                    pooledObject.markAbandoned();
+                    remove.add(pooledObject);
+                }
+            }
+        }
+
+        // Now remove the abandoned objects
+        Iterator<PooledObject<T>> itr = remove.iterator();
+        while (itr.hasNext()) {
+            PooledObject<T> pooledObject = itr.next();
+            if (ac.getLogAbandoned()) {
+                pooledObject.printStackTrace(ac.getLogWriter());
+            }
+            try {
+                invalidateObject(pooledObject.getObject());
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+
+    //--- Usage tracking support -----------------------------------------------
+
+    @Override
+    public void use(T pooledObject) {
+        AbandonedConfig ac = this.abandonedConfig;
+        if (ac != null && ac.getUseUsageTracking()) {
+            PooledObject<T> wrapper = allObjects.get(pooledObject);
+            wrapper.use();
+        }
+    }
+
+
+    //--- JMX support ----------------------------------------------------------
+
+    private volatile String factoryType = null;
+
+    /**
+     * Return an estimate of the number of threads currently blocked waiting for
+     * an object from the pool. This is intended for monitoring only, not for
+     * synchronization control.
+     *
+     * @return The estimate of the number of threads currently blocked waiting
+     *         for an object from the pool
+     */
+    @Override
+    public int getNumWaiters() {
+        if (getBlockWhenExhausted()) {
+            return idleObjects.getTakeQueueLength();
+        } else {
+            return 0;
+        }
+    }
+
+    /**
+     * Return the type - including the specific type rather than the generic -
+     * of the factory.
+     *
+     * @return A string representation of the factory type
+     */
+    @Override
+    public String getFactoryType() {
+        // Not thread safe. Accept that there may be multiple evaluations.
+        if (factoryType == null) {
+            StringBuilder result = new StringBuilder();
+            result.append(factory.getClass().getName());
+            result.append('<');
+            Class<?> pooledObjectType =
+                    PoolImplUtils.getFactoryType(factory.getClass());
+            result.append(pooledObjectType.getName());
+            result.append('>');
+            factoryType = result.toString();
+        }
+        return factoryType;
+    }
+
+    /**
+     * Provides information on all the objects in the pool, both idle (waiting
+     * to be borrowed) and active (currently borrowed).
+     * <p>
+     * Note: This is named listAllObjects so it is presented as an operation via
+     * JMX. That means it won't be invoked unless the explicitly requested
+     * whereas all attributes will be automatically requested when viewing the
+     * attributes for an object in a tool like JConsole.
+     *
+     * @return Information grouped on all the objects in the pool
+     */
+    @Override
+    public Set<DefaultPooledObjectInfo> listAllObjects() {
+        Set<DefaultPooledObjectInfo> result =
+                new HashSet<>(allObjects.size());
+        for (PooledObject<T> p : allObjects.values()) {
+            result.add(new DefaultPooledObjectInfo(p));
+        }
+        return result;
+    }
+
+    // --- configuration attributes --------------------------------------------
+
+    private volatile int maxIdle = GenericObjectPoolConfig.DEFAULT_MAX_IDLE;
+    private volatile int minIdle = GenericObjectPoolConfig.DEFAULT_MIN_IDLE;
+    private final PooledObjectFactory<T> factory;
+
+
+    // --- internal attributes -------------------------------------------------
+
+    /*
+     * All of the objects currently associated with this pool in any state. It
+     * excludes objects that have been destroyed. The size of
+     * {@link #allObjects} will always be less than or equal to {@link
+     * #_maxActive}. Map keys are pooled objects, values are the PooledObject
+     * wrappers used internally by the pool.
+     */
+    private final Map<T, PooledObject<T>> allObjects =
+        new ConcurrentHashMap<>();
+    /*
+     * The combined count of the currently created objects and those in the
+     * process of being created. Under load, it may exceed {@link #_maxActive}
+     * if multiple threads try and create a new object at the same time but
+     * {@link #create()} will ensure that there are never more than
+     * {@link #_maxActive} objects created at any one time.
+     */
+    private final AtomicLong createCount = new AtomicLong(0);
+    private final LinkedBlockingDeque<PooledObject<T>> idleObjects =
+        new LinkedBlockingDeque<>();
+
+    // JMX specific attributes
+    private static final String ONAME_BASE =
+        "org.apache.tomcat.dbcp.pool2:type=GenericObjectPool,name=";
+
+    // Additional configuration properties for abandoned object tracking
+    private volatile AbandonedConfig abandonedConfig = null;
+}

==================================================
GenericObjectPoolMXBean.java
new file mode 100644
index 0000000000..dd644c362b
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPoolConfig.java
@@ -0,0 +1,146 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+/**
+ * A simple "struct" encapsulating the configuration for a
+ * {@link GenericObjectPool}.
+ *
+ * <p>
+ * This class is not thread-safe; it is only intended to be used to provide
+ * attributes used when creating a pool.
+ *
+ * @version $Revision: $
+ *
+ * @since 2.0
+ */
+public class GenericObjectPoolConfig extends BaseObjectPoolConfig {
+
+    /**
+     * The default value for the {@code maxTotal} configuration attribute.
+     * @see GenericObjectPool#getMaxTotal()
+     */
+    public static final int DEFAULT_MAX_TOTAL = 8;
+
+    /**
+     * The default value for the {@code maxIdle} configuration attribute.
+     * @see GenericObjectPool#getMaxIdle()
+     */
+    public static final int DEFAULT_MAX_IDLE = 8;
+
+    /**
+     * The default value for the {@code minIdle} configuration attribute.
+     * @see GenericObjectPool#getMinIdle()
+     */
+    public static final int DEFAULT_MIN_IDLE = 0;
+
+
+    private int maxTotal = DEFAULT_MAX_TOTAL;
+
+    private int maxIdle = DEFAULT_MAX_IDLE;
+
+    private int minIdle = DEFAULT_MIN_IDLE;
+
+    /**
+     * Get the value for the {@code maxTotal} configuration attribute
+     * for pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code maxTotal} for this
+     *          configuration instance
+     *
+     * @see GenericObjectPool#getMaxTotal()
+     */
+    public int getMaxTotal() {
+        return maxTotal;
+    }
+
+    /**
+     * Set the value for the {@code maxTotal} configuration attribute for
+     * pools created with this configuration instance.
+     *
+     * @param maxTotal The new setting of {@code maxTotal}
+     *        for this configuration instance
+     *
+     * @see GenericObjectPool#setMaxTotal(int)
+     */
+    public void setMaxTotal(int maxTotal) {
+        this.maxTotal = maxTotal;
+    }
+
+
+    /**
+     * Get the value for the {@code maxIdle} configuration attribute
+     * for pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code maxIdle} for this
+     *          configuration instance
+     *
+     * @see GenericObjectPool#getMaxIdle()
+     */
+    public int getMaxIdle() {
+        return maxIdle;
+    }
+
+    /**
+     * Set the value for the {@code maxIdle} configuration attribute for
+     * pools created with this configuration instance.
+     *
+     * @param maxIdle The new setting of {@code maxIdle}
+     *        for this configuration instance
+     *
+     * @see GenericObjectPool#setMaxIdle(int)
+     */
+    public void setMaxIdle(int maxIdle) {
+        this.maxIdle = maxIdle;
+    }
+
+
+    /**
+     * Get the value for the {@code minIdle} configuration attribute
+     * for pools created with this configuration instance.
+     *
+     * @return  The current setting of {@code minIdle} for this
+     *          configuration instance
+     *
+     * @see GenericObjectPool#getMinIdle()
+     */
+    public int getMinIdle() {
+        return minIdle;
+    }
+
+    /**
+     * Set the value for the {@code minIdle} configuration attribute for
+     * pools created with this configuration instance.
+     *
+     * @param minIdle The new setting of {@code minIdle}
+     *        for this configuration instance
+     *
+     * @see GenericObjectPool#setMinIdle(int)
+     */
+    public void setMinIdle(int minIdle) {
+        this.minIdle = minIdle;
+    }
+
+    @Override
+    public GenericObjectPoolConfig clone() {
+        try {
+            return (GenericObjectPoolConfig) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new AssertionError(); // Can't happen
+        }
+    }
+}

==================================================
InterruptibleReentrantLock.java
new file mode 100644
index 0000000000..a05d9b7e5c
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPoolMXBean.java
@@ -0,0 +1,216 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+import java.util.Set;
+
+/**
+ * Defines the methods that will be made available via JMX.
+ *
+ * NOTE: This interface exists only to define those attributes and methods that
+ *       will be made available via JMX. It must not be implemented by clients
+ *       as it is subject to change between major, minor and patch version
+ *       releases of commons pool. Clients that implement this interface may
+ *       not, therefore, be able to upgrade to a new minor or patch release
+ *       without requiring code changes.
+ *
+ * @version $Revision: $
+ *
+ * @since 2.0
+ */
+public interface GenericObjectPoolMXBean {
+    // Getters for basic configuration settings
+    /**
+     * See {@link GenericObjectPool#getBlockWhenExhausted()}
+     * @return See {@link GenericObjectPool#getBlockWhenExhausted()}
+     */
+    boolean getBlockWhenExhausted();
+    /**
+     * See {@link GenericObjectPool#getLifo()}
+     * @return See {@link GenericObjectPool#getLifo()}
+     */
+    boolean getLifo();
+    /**
+     * See {@link GenericObjectPool#getMaxIdle()}
+     * @return See {@link GenericObjectPool#getMaxIdle()}
+     */
+    int getMaxIdle();
+    /**
+     * See {@link GenericObjectPool#getMaxTotal()}
+     * @return See {@link GenericObjectPool#getMaxTotal()}
+     */
+    int getMaxTotal();
+    /**
+     * See {@link GenericObjectPool#getMaxWaitMillis()}
+     * @return See {@link GenericObjectPool#getMaxWaitMillis()}
+     */
+    long getMaxWaitMillis();
+    /**
+     * See {@link GenericObjectPool#getMinEvictableIdleTimeMillis()}
+     * @return See {@link GenericObjectPool#getMinEvictableIdleTimeMillis()}
+     */
+    long getMinEvictableIdleTimeMillis();
+    /**
+     * See {@link GenericObjectPool#getMinIdle()}
+     * @return See {@link GenericObjectPool#getMinIdle()}
+     */
+    int getMinIdle();
+    /**
+     * See {@link GenericObjectPool#getNumActive()}
+     * @return See {@link GenericObjectPool#getNumActive()}
+     */
+    int getNumActive();
+    /**
+     * See {@link GenericObjectPool#getNumIdle()}
+     * @return See {@link GenericObjectPool#getNumIdle()}
+     */
+    int getNumIdle();
+    /**
+     * See {@link GenericObjectPool#getNumTestsPerEvictionRun()}
+     * @return See {@link GenericObjectPool#getNumTestsPerEvictionRun()}
+     */
+    int getNumTestsPerEvictionRun();
+    /**
+     * See {@link GenericObjectPool#getTestOnCreate()}
+     * @return See {@link GenericObjectPool#getTestOnCreate()}
+     * @since 2.2
+     */
+    boolean getTestOnCreate();
+    /**
+     * See {@link GenericObjectPool#getTestOnBorrow()}
+     * @return See {@link GenericObjectPool#getTestOnBorrow()}
+     */
+    boolean getTestOnBorrow();
+    /**
+     * See {@link GenericObjectPool#getTestOnReturn()}
+     * @return See {@link GenericObjectPool#getTestOnReturn()}
+     */
+    boolean getTestOnReturn();
+    /**
+     * See {@link GenericObjectPool#getTestWhileIdle()}
+     * @return See {@link GenericObjectPool#getTestWhileIdle()}
+     */
+    boolean getTestWhileIdle();
+    /**
+     * See {@link GenericObjectPool#getTimeBetweenEvictionRunsMillis()}
+     * @return See {@link GenericObjectPool#getTimeBetweenEvictionRunsMillis()}
+     */
+    long getTimeBetweenEvictionRunsMillis();
+    /**
+     * See {@link GenericObjectPool#isClosed()}
+     * @return See {@link GenericObjectPool#isClosed()}
+     */
+    boolean isClosed();
+    // Getters for monitoring attributes
+    /**
+     * See {@link GenericObjectPool#getBorrowedCount()}
+     * @return See {@link GenericObjectPool#getBorrowedCount()}
+     */
+    long getBorrowedCount();
+    /**
+     * See {@link GenericObjectPool#getReturnedCount()}
+     * @return See {@link GenericObjectPool#getReturnedCount()}
+     */
+    long getReturnedCount();
+    /**
+     * See {@link GenericObjectPool#getCreatedCount()}
+     * @return See {@link GenericObjectPool#getCreatedCount()}
+     */
+    long getCreatedCount();
+    /**
+     * See {@link GenericObjectPool#getDestroyedCount()}
+     * @return See {@link GenericObjectPool#getDestroyedCount()}
+     */
+    long getDestroyedCount();
+    /**
+     * See {@link GenericObjectPool#getDestroyedByEvictorCount()}
+     * @return See {@link GenericObjectPool#getDestroyedByEvictorCount()}
+     */
+    long getDestroyedByEvictorCount();
+    /**
+     * See {@link GenericObjectPool#getDestroyedByBorrowValidationCount()}
+     * @return See {@link GenericObjectPool#getDestroyedByBorrowValidationCount()}
+     */
+    long getDestroyedByBorrowValidationCount();
+    /**
+     * See {@link GenericObjectPool#getMeanActiveTimeMillis()}
+     * @return See {@link GenericObjectPool#getMeanActiveTimeMillis()}
+     */
+    long getMeanActiveTimeMillis();
+    /**
+     * See {@link GenericObjectPool#getMeanIdleTimeMillis()}
+     * @return See {@link GenericObjectPool#getMeanIdleTimeMillis()}
+     */
+    long getMeanIdleTimeMillis();
+    /**
+     * See {@link GenericObjectPool#getMeanBorrowWaitTimeMillis()}
+     * @return See {@link GenericObjectPool#getMeanBorrowWaitTimeMillis()}
+     */
+    long getMeanBorrowWaitTimeMillis();
+    /**
+     * See {@link GenericObjectPool#getMaxBorrowWaitTimeMillis()}
+     * @return See {@link GenericObjectPool#getMaxBorrowWaitTimeMillis()}
+     */
+    long getMaxBorrowWaitTimeMillis();
+    /**
+     * See {@link GenericObjectPool#getCreationStackTrace()}
+     * @return See {@link GenericObjectPool#getCreationStackTrace()}
+     */
+    String getCreationStackTrace();
+    /**
+     * See {@link GenericObjectPool#getNumWaiters()}
+     * @return See {@link GenericObjectPool#getNumWaiters()}
+     */
+    int getNumWaiters();
+
+    // Getters for abandoned object removal configuration
+    /**
+     * See {@link GenericObjectPool#isAbandonedConfig()}
+     * @return See {@link GenericObjectPool#isAbandonedConfig()}
+     */
+    boolean isAbandonedConfig();
+    /**
+     * See {@link GenericObjectPool#getLogAbandoned()}
+     * @return See {@link GenericObjectPool#getLogAbandoned()}
+     */
+    boolean getLogAbandoned();
+    /**
+     * See {@link GenericObjectPool#getRemoveAbandonedOnBorrow()}
+     * @return See {@link GenericObjectPool#getRemoveAbandonedOnBorrow()}
+     */
+    boolean getRemoveAbandonedOnBorrow();
+    /**
+     * See {@link GenericObjectPool#getRemoveAbandonedOnMaintenance()}
+     * @return See {@link GenericObjectPool#getRemoveAbandonedOnMaintenance()}
+     */
+    boolean getRemoveAbandonedOnMaintenance();
+    /**
+     * See {@link GenericObjectPool#getRemoveAbandonedTimeout()}
+     * @return See {@link GenericObjectPool#getRemoveAbandonedTimeout()}
+     */
+    int getRemoveAbandonedTimeout();
+    /**
+     * See {@link GenericObjectPool#getFactoryType()}
+     * @return See {@link GenericObjectPool#getFactoryType()}
+     */
+    public String getFactoryType();
+    /**
+     * See {@link GenericObjectPool#listAllObjects()}
+     * @return See {@link GenericObjectPool#listAllObjects()}
+     */
+    Set<DefaultPooledObjectInfo> listAllObjects();
+}

==================================================
LinkedBlockingDeque.java
new file mode 100644
index 0000000000..a31ce2a644
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/InterruptibleReentrantLock.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+import java.util.Collection;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * This sub-class was created to expose the waiting threads so that they can be
+ * interrupted when the pool using the queue that uses this lock is closed. The
+ * class is intended for internal use only.
+ * <p>
+ * This class is intended to be thread-safe.
+ *
+ * @since 2.0
+ */
+class InterruptibleReentrantLock extends ReentrantLock {
+
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Interrupt the threads that are waiting on a specific condition
+     *
+     * @param condition the condition on which the threads are waiting.
+     */
+    public void interruptWaiters(Condition condition) {
+        Collection<Thread> threads = getWaitingThreads(condition);
+        for (Thread thread : threads) {
+            thread.interrupt();
+        }
+    }
+}

==================================================
PoolImplUtils.java
new file mode 100644
index 0000000000..8c6446da8d
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/LinkedBlockingDeque.java
@@ -0,0 +1,1310 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+import java.io.Serializable;
+import java.util.AbstractQueue;
+import java.util.Collection;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+
+/**
+ * An optionally-bounded {@linkplain java.util.concurrent.BlockingDeque blocking
+ * deque} based on linked nodes.
+ *
+ * <p> The optional capacity bound constructor argument serves as a
+ * way to prevent excessive expansion. The capacity, if unspecified,
+ * is equal to {@link Integer#MAX_VALUE}.  Linked nodes are
+ * dynamically created upon each insertion unless this would bring the
+ * deque above capacity.
+ *
+ * <p>Most operations run in constant time (ignoring time spent
+ * blocking).  Exceptions include {@link #remove(Object) remove},
+ * {@link #removeFirstOccurrence removeFirstOccurrence}, {@link
+ * #removeLastOccurrence removeLastOccurrence}, {@link #contains
+ * contains}, {@link #iterator iterator.remove()}, and the bulk
+ * operations, all of which run in linear time.
+ *
+ * <p>This class and its iterator implement all of the
+ * <em>optional</em> methods of the {@link Collection} and {@link
+ * Iterator} interfaces.
+ *
+ * <p>This class is a member of the
+ * <a href="{@docRoot}/../technotes/guides/collections/index.html">
+ * Java Collections Framework</a>.
+ *
+ * @param <E> the type of elements held in this collection
+ *
+ * Note: This was copied from Apache Harmony and modified to suit the needs of
+ *       Commons Pool.
+ *
+ * @since 2.0
+ */
+class LinkedBlockingDeque<E> extends AbstractQueue<E>
+        implements Deque<E>, Serializable {
+
+    /*
+     * Implemented as a simple doubly-linked list protected by a
+     * single lock and using conditions to manage blocking.
+     *
+     * To implement weakly consistent iterators, it appears we need to
+     * keep all Nodes GC-reachable from a predecessor dequeued Node.
+     * That would cause two problems:
+     * - allow a rogue Iterator to cause unbounded memory retention
+     * - cause cross-generational linking of old Nodes to new Nodes if
+     *   a Node was tenured while live, which generational GCs have a
+     *   hard time dealing with, causing repeated major collections.
+     * However, only non-deleted Nodes need to be reachable from
+     * dequeued Nodes, and reachability does not necessarily have to
+     * be of the kind understood by the GC.  We use the trick of
+     * linking a Node that has just been dequeued to itself.  Such a
+     * self-link implicitly means to jump to "first" (for next links)
+     * or "last" (for prev links).
+     */
+
+    /*
+     * We have "diamond" multiple interface/abstract class inheritance
+     * here, and that introduces ambiguities. Often we want the
+     * BlockingDeque javadoc combined with the AbstractQueue
+     * implementation, so a lot of method specs are duplicated here.
+     */
+
+    private static final long serialVersionUID = -387911632671998426L;
+
+    /** Doubly-linked list node class */
+    private static final class Node<E> {
+        /**
+         * The item, or null if this node has been removed.
+         */
+        E item;
+
+        /**
+         * One of:
+         * - the real predecessor Node
+         * - this Node, meaning the predecessor is tail
+         * - null, meaning there is no predecessor
+         */
+        Node<E> prev;
+
+        /**
+         * One of:
+         * - the real successor Node
+         * - this Node, meaning the successor is head
+         * - null, meaning there is no successor
+         */
+        Node<E> next;
+
+        /**
+         * Create a new list node.
+         *
+         * @param x The list item
+         * @param p Previous item
+         * @param n Next item
+         */
+        Node(E x, Node<E> p, Node<E> n) {
+            item = x;
+            prev = p;
+            next = n;
+        }
+    }
+
+    /**
+     * Pointer to first node.
+     * Invariant: (first == null && last == null) ||
+     *            (first.prev == null && first.item != null)
+     */
+    private transient Node<E> first;
+
+    /**
+     * Pointer to last node.
+     * Invariant: (first == null && last == null) ||
+     *            (last.next == null && last.item != null)
+     */
+    private transient Node<E> last;
+
+    /** Number of items in the deque */
+    private transient int count;
+
+    /** Maximum number of items in the deque */
+    private final int capacity;
+
+    /** Main lock guarding all access */
+    private final InterruptibleReentrantLock lock =
+            new InterruptibleReentrantLock();
+
+    /** Condition for waiting takes */
+    private final Condition notEmpty = lock.newCondition();
+
+    /** Condition for waiting puts */
+    private final Condition notFull = lock.newCondition();
+
+    /**
+     * Creates a {@code LinkedBlockingDeque} with a capacity of
+     * {@link Integer#MAX_VALUE}.
+     */
+    public LinkedBlockingDeque() {
+        this(Integer.MAX_VALUE);
+    }
+
+    /**
+     * Creates a {@code LinkedBlockingDeque} with the given (fixed) capacity.
+     *
+     * @param capacity the capacity of this deque
+     * @throws IllegalArgumentException if {@code capacity} is less than 1
+     */
+    public LinkedBlockingDeque(int capacity) {
+        if (capacity <= 0) throw new IllegalArgumentException();
+        this.capacity = capacity;
+    }
+
+    /**
+     * Creates a {@code LinkedBlockingDeque} with a capacity of
+     * {@link Integer#MAX_VALUE}, initially containing the elements of
+     * the given collection, added in traversal order of the
+     * collection's iterator.
+     *
+     * @param c the collection of elements to initially contain
+     * @throws NullPointerException if the specified collection or any
+     *         of its elements are null
+     */
+    public LinkedBlockingDeque(Collection<? extends E> c) {
+        this(Integer.MAX_VALUE);
+        lock.lock(); // Never contended, but necessary for visibility
+        try {
+            for (E e : c) {
+                if (e == null)
+                    throw new NullPointerException();
+                if (!linkLast(e))
+                    throw new IllegalStateException("Deque full");
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+
+
+    // Basic linking and unlinking operations, called only while holding lock
+
+    /**
+     * Links provided element as first element, or returns false if full.
+     *
+     * @param e The element to link as the first element.
+     *
+     * @return {@code true} if successful, otherwise {@code false}
+     */
+    private boolean linkFirst(E e) {
+        // assert lock.isHeldByCurrentThread();
+        if (count >= capacity)
+            return false;
+        Node<E> f = first;
+        Node<E> x = new Node<>(e, null, f);
+        first = x;
+        if (last == null)
+            last = x;
+        else
+            f.prev = x;
+        ++count;
+        notEmpty.signal();
+        return true;
+    }
+
+    /**
+     * Links provided element as last element, or returns false if full.
+     *
+     * @param e The element to link as the last element.
+     *
+     * @return {@code true} if successful, otherwise {@code false}
+     */
+    private boolean linkLast(E e) {
+        // assert lock.isHeldByCurrentThread();
+        if (count >= capacity)
+            return false;
+        Node<E> l = last;
+        Node<E> x = new Node<>(e, l, null);
+        last = x;
+        if (first == null)
+            first = x;
+        else
+            l.next = x;
+        ++count;
+        notEmpty.signal();
+        return true;
+    }
+
+    /**
+     * Removes and returns the first element, or null if empty.
+     *
+     * @return The first element or {@code null} if empty
+     */
+    private E unlinkFirst() {
+        // assert lock.isHeldByCurrentThread();
+        Node<E> f = first;
+        if (f == null)
+            return null;
+        Node<E> n = f.next;
+        E item = f.item;
+        f.item = null;
+        f.next = f; // help GC
+        first = n;
+        if (n == null)
+            last = null;
+        else
+            n.prev = null;
+        --count;
+        notFull.signal();
+        return item;
+    }
+
+    /**
+     * Removes and returns the last element, or null if empty.
+     *
+     * @return The first element or {@code null} if empty
+     */
+    private E unlinkLast() {
+        // assert lock.isHeldByCurrentThread();
+        Node<E> l = last;
+        if (l == null)
+            return null;
+        Node<E> p = l.prev;
+        E item = l.item;
+        l.item = null;
+        l.prev = l; // help GC
+        last = p;
+        if (p == null)
+            first = null;
+        else
+            p.next = null;
+        --count;
+        notFull.signal();
+        return item;
+    }
+
+    /**
+     * Unlinks the provided node.
+     *
+     * @param x The node to unlink
+     */
+    private void unlink(Node<E> x) {
+        // assert lock.isHeldByCurrentThread();
+        Node<E> p = x.prev;
+        Node<E> n = x.next;
+        if (p == null) {
+            unlinkFirst();
+        } else if (n == null) {
+            unlinkLast();
+        } else {
+            p.next = n;
+            n.prev = p;
+            x.item = null;
+            // Don't mess with x's links.  They may still be in use by
+            // an iterator.
+        --count;
+            notFull.signal();
+        }
+    }
+
+    // BlockingDeque methods
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void addFirst(E e) {
+        if (!offerFirst(e))
+            throw new IllegalStateException("Deque full");
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void addLast(E e) {
+        if (!offerLast(e))
+            throw new IllegalStateException("Deque full");
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean offerFirst(E e) {
+        if (e == null) throw new NullPointerException();
+        lock.lock();
+        try {
+            return linkFirst(e);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean offerLast(E e) {
+        if (e == null) throw new NullPointerException();
+        lock.lock();
+        try {
+            return linkLast(e);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Links the provided element as the first in the queue, waiting until there
+     * is space to do so if the queue is full.
+     *
+     * @param e element to link
+     *
+     * @throws NullPointerException
+     * @throws InterruptedException
+     */
+    public void putFirst(E e) throws InterruptedException {
+        if (e == null) throw new NullPointerException();
+        lock.lock();
+        try {
+            while (!linkFirst(e))
+                notFull.await();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Links the provided element as the last in the queue, waiting until there
+     * is space to do so if the queue is full.
+     *
+     * @param e element to link
+     *
+     * @throws NullPointerException
+     * @throws InterruptedException
+     */
+    public void putLast(E e) throws InterruptedException {
+        if (e == null) throw new NullPointerException();
+        lock.lock();
+        try {
+            while (!linkLast(e))
+                notFull.await();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Links the provided element as the first in the queue, waiting up to the
+     * specified time to do so if the queue is full.
+     *
+     * @param e         element to link
+     * @param timeout   length of time to wait
+     * @param unit      units that timeout is expressed in
+     *
+     * @return {@code true} if successful, otherwise {@code false}
+     *
+     * @throws NullPointerException
+     * @throws InterruptedException
+     */
+    public boolean offerFirst(E e, long timeout, TimeUnit unit)
+        throws InterruptedException {
+        if (e == null) throw new NullPointerException();
+        long nanos = unit.toNanos(timeout);
+        lock.lockInterruptibly();
+        try {
+            while (!linkFirst(e)) {
+                if (nanos <= 0)
+                    return false;
+                nanos = notFull.awaitNanos(nanos);
+            }
+            return true;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Links the provided element as the last in the queue, waiting up to the
+     * specified time to do so if the queue is full.
+     *
+     * @param e         element to link
+     * @param timeout   length of time to wait
+     * @param unit      units that timeout is expressed in
+     *
+     * @return {@code true} if successful, otherwise {@code false}
+     *
+     * @throws NullPointerException
+     * @throws InterruptedException
+     */
+    public boolean offerLast(E e, long timeout, TimeUnit unit)
+        throws InterruptedException {
+        if (e == null) throw new NullPointerException();
+        long nanos = unit.toNanos(timeout);
+        lock.lockInterruptibly();
+        try {
+            while (!linkLast(e)) {
+                if (nanos <= 0)
+                    return false;
+                nanos = notFull.awaitNanos(nanos);
+            }
+            return true;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E removeFirst() {
+        E x = pollFirst();
+        if (x == null) throw new NoSuchElementException();
+        return x;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E removeLast() {
+        E x = pollLast();
+        if (x == null) throw new NoSuchElementException();
+        return x;
+    }
+
+    @Override
+    public E pollFirst() {
+        lock.lock();
+        try {
+            return unlinkFirst();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public E pollLast() {
+        lock.lock();
+        try {
+            return unlinkLast();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Unlinks the first element in the queue, waiting until there is an element
+     * to unlink if the queue is empty.
+     *
+     * @return the unlinked element
+     * @throws InterruptedException if the current thread is interrupted
+     */
+    public E takeFirst() throws InterruptedException {
+        lock.lock();
+        try {
+            E x;
+            while ( (x = unlinkFirst()) == null)
+                notEmpty.await();
+            return x;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Unlinks the last element in the queue, waiting until there is an element
+     * to unlink if the queue is empty.
+     *
+     * @return the unlinked element
+     * @throws InterruptedException if the current thread is interrupted
+     */
+    public E takeLast() throws InterruptedException {
+        lock.lock();
+        try {
+            E x;
+            while ( (x = unlinkLast()) == null)
+                notEmpty.await();
+            return x;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Unlinks the first element in the queue, waiting up to the specified time
+     * to do so if the queue is empty.
+     *
+     * @param timeout   length of time to wait
+     * @param unit      units that timeout is expressed in
+     *
+     * @return the unlinked element
+     * @throws InterruptedException if the current thread is interrupted
+     */
+    public E pollFirst(long timeout, TimeUnit unit)
+        throws InterruptedException {
+        long nanos = unit.toNanos(timeout);
+        lock.lockInterruptibly();
+        try {
+            E x;
+            while ( (x = unlinkFirst()) == null) {
+                if (nanos <= 0)
+                    return null;
+                nanos = notEmpty.awaitNanos(nanos);
+            }
+            return x;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Unlinks the last element in the queue, waiting up to the specified time
+     * to do so if the queue is empty.
+     *
+     * @param timeout   length of time to wait
+     * @param unit      units that timeout is expressed in
+     *
+     * @return the unlinked element
+     * @throws InterruptedException if the current thread is interrupted
+     */
+    public E pollLast(long timeout, TimeUnit unit)
+        throws InterruptedException {
+        long nanos = unit.toNanos(timeout);
+        lock.lockInterruptibly();
+        try {
+            E x;
+            while ( (x = unlinkLast()) == null) {
+                if (nanos <= 0)
+                    return null;
+                nanos = notEmpty.awaitNanos(nanos);
+            }
+            return x;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E getFirst() {
+        E x = peekFirst();
+        if (x == null) throw new NoSuchElementException();
+        return x;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E getLast() {
+        E x = peekLast();
+        if (x == null) throw new NoSuchElementException();
+        return x;
+    }
+
+    @Override
+    public E peekFirst() {
+        lock.lock();
+        try {
+            return (first == null) ? null : first.item;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public E peekLast() {
+        lock.lock();
+        try {
+            return (last == null) ? null : last.item;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public boolean removeFirstOccurrence(Object o) {
+        if (o == null) return false;
+        lock.lock();
+        try {
+            for (Node<E> p = first; p != null; p = p.next) {
+                if (o.equals(p.item)) {
+                    unlink(p);
+                    return true;
+                }
+            }
+            return false;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public boolean removeLastOccurrence(Object o) {
+        if (o == null) return false;
+        lock.lock();
+        try {
+            for (Node<E> p = last; p != null; p = p.prev) {
+                if (o.equals(p.item)) {
+                    unlink(p);
+                    return true;
+                }
+            }
+            return false;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    // BlockingQueue methods
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean add(E e) {
+        addLast(e);
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean offer(E e) {
+        return offerLast(e);
+    }
+
+    /**
+     * Links the provided element as the last in the queue, waiting until there
+     * is space to do so if the queue is full.
+     *
+     * <p>This method is equivalent to {@link #putLast(Object)}.
+     *
+     * @param e element to link
+     *
+     * @throws NullPointerException
+     * @throws InterruptedException
+     */
+    public void put(E e) throws InterruptedException {
+        putLast(e);
+    }
+
+    /**
+     * Links the provided element as the last in the queue, waiting up to the
+     * specified time to do so if the queue is full.
+     * <p>
+     * This method is equivalent to {@link #offerLast(Object, long, TimeUnit)}
+     *
+     * @param e         element to link
+     * @param timeout   length of time to wait
+     * @param unit      units that timeout is expressed in
+     *
+     * @return {@code true} if successful, otherwise {@code false}
+     *
+     * @throws NullPointerException
+     * @throws InterruptedException
+     */
+    public boolean offer(E e, long timeout, TimeUnit unit)
+        throws InterruptedException {
+        return offerLast(e, timeout, unit);
+    }
+
+    /**
+     * Retrieves and removes the head of the queue represented by this deque.
+     * This method differs from {@link #poll poll} only in that it throws an
+     * exception if this deque is empty.
+     *
+     * <p>This method is equivalent to {@link #removeFirst() removeFirst}.
+     *
+     * @return the head of the queue represented by this deque
+     * @throws NoSuchElementException if this deque is empty
+     */
+    @Override
+    public E remove() {
+        return removeFirst();
+    }
+
+    @Override
+    public E poll() {
+        return pollFirst();
+    }
+
+    /**
+     * Unlinks the first element in the queue, waiting until there is an element
+     * to unlink if the queue is empty.
+     *
+     * <p>This method is equivalent to {@link #takeFirst()}.
+     *
+     * @return the unlinked element
+     * @throws InterruptedException if the current thread is interrupted
+     */
+    public E take() throws InterruptedException {
+        return takeFirst();
+    }
+
+    /**
+     * Unlinks the first element in the queue, waiting up to the specified time
+     * to do so if the queue is empty.
+     *
+     * <p>This method is equivalent to {@link #pollFirst(long, TimeUnit)}.
+     *
+     * @param timeout   length of time to wait
+     * @param unit      units that timeout is expressed in
+     *
+     * @return the unlinked element
+     * @throws InterruptedException if the current thread is interrupted
+     */
+    public E poll(long timeout, TimeUnit unit) throws InterruptedException {
+        return pollFirst(timeout, unit);
+    }
+
+    /**
+     * Retrieves, but does not remove, the head of the queue represented by
+     * this deque.  This method differs from {@link #peek peek} only in that
+     * it throws an exception if this deque is empty.
+     *
+     * <p>This method is equivalent to {@link #getFirst() getFirst}.
+     *
+     * @return the head of the queue represented by this deque
+     * @throws NoSuchElementException if this deque is empty
+     */
+    @Override
+    public E element() {
+        return getFirst();
+    }
+
+    @Override
+    public E peek() {
+        return peekFirst();
+    }
+
+    /**
+     * Returns the number of additional elements that this deque can ideally
+     * (in the absence of memory or resource constraints) accept without
+     * blocking. This is always equal to the initial capacity of this deque
+     * less the current {@code size} of this deque.
+     *
+     * <p>Note that you <em>cannot</em> always tell if an attempt to insert
+     * an element will succeed by inspecting {@code remainingCapacity}
+     * because it may be the case that another thread is about to
+     * insert or remove an element.
+     *
+     * @return The number of additional elements the queue is able to accept
+     */
+    public int remainingCapacity() {
+        lock.lock();
+        try {
+            return capacity - count;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Empty the queue to the specified collection.
+     *
+     * @param c The collection to add the elements to
+     *
+     * @return number of elements added to the collection
+     *
+     * @throws UnsupportedOperationException
+     * @throws ClassCastException
+     * @throws NullPointerException
+     * @throws IllegalArgumentException
+     */
+    public int drainTo(Collection<? super E> c) {
+        return drainTo(c, Integer.MAX_VALUE);
+    }
+
+    /**
+     * Empty no more than the specified number of elements from the queue to the
+     * specified collection.
+     *
+     * @param c           collection to add the elements to
+     * @param maxElements maximum number of elements to remove from the queue
+     *
+     * @return number of elements added to the collection
+     * @throws UnsupportedOperationException
+     * @throws ClassCastException
+     * @throws NullPointerException
+     * @throws IllegalArgumentException
+     */
+    public int drainTo(Collection<? super E> c, int maxElements) {
+        if (c == null)
+            throw new NullPointerException();
+        if (c == this)
+            throw new IllegalArgumentException();
+        lock.lock();
+        try {
+            int n = Math.min(maxElements, count);
+            for (int i = 0; i < n; i++) {
+                c.add(first.item);   // In this order, in case add() throws.
+                unlinkFirst();
+            }
+            return n;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    // Stack methods
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void push(E e) {
+        addFirst(e);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E pop() {
+        return removeFirst();
+    }
+
+    // Collection methods
+
+    /**
+     * Removes the first occurrence of the specified element from this deque.
+     * If the deque does not contain the element, it is unchanged.
+     * More formally, removes the first element {@code e} such that
+     * {@code o.equals(e)} (if such an element exists).
+     * Returns {@code true} if this deque contained the specified element
+     * (or equivalently, if this deque changed as a result of the call).
+     *
+     * <p>This method is equivalent to
+     * {@link #removeFirstOccurrence(Object) removeFirstOccurrence}.
+     *
+     * @param o element to be removed from this deque, if present
+     * @return {@code true} if this deque changed as a result of the call
+     */
+    @Override
+    public boolean remove(Object o) {
+        return removeFirstOccurrence(o);
+    }
+
+    /**
+     * Returns the number of elements in this deque.
+     *
+     * @return the number of elements in this deque
+     */
+    @Override
+    public int size() {
+        lock.lock();
+        try {
+            return count;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Returns {@code true} if this deque contains the specified element.
+     * More formally, returns {@code true} if and only if this deque contains
+     * at least one element {@code e} such that {@code o.equals(e)}.
+     *
+     * @param o object to be checked for containment in this deque
+     * @return {@code true} if this deque contains the specified element
+     */
+    @Override
+    public boolean contains(Object o) {
+        if (o == null) return false;
+        lock.lock();
+        try {
+            for (Node<E> p = first; p != null; p = p.next)
+                if (o.equals(p.item))
+                    return true;
+            return false;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /*
+     * TODO: Add support for more efficient bulk operations.
+     *
+     * We don't want to acquire the lock for every iteration, but we
+     * also want other threads a chance to interact with the
+     * collection, especially when count is close to capacity.
+     */
+
+//     /**
+//      * Adds all of the elements in the specified collection to this
+//      * queue.  Attempts to addAll of a queue to itself result in
+//      * {@code IllegalArgumentException}. Further, the behavior of
+//      * this operation is undefined if the specified collection is
+//      * modified while the operation is in progress.
+//      *
+//      * @param c collection containing elements to be added to this queue
+//      * @return {@code true} if this queue changed as a result of the call
+//      * @throws ClassCastException
+//      * @throws NullPointerException
+//      * @throws IllegalArgumentException
+//      * @throws IllegalStateException
+//      * @see #add(Object)
+//      */
+//     public boolean addAll(Collection<? extends E> c) {
+//         if (c == null)
+//             throw new NullPointerException();
+//         if (c == this)
+//             throw new IllegalArgumentException();
+//         final ReentrantLock lock = this.lock;
+//         lock.lock();
+//         try {
+//             boolean modified = false;
+//             for (E e : c)
+//                 if (linkLast(e))
+//                     modified = true;
+//             return modified;
+//         } finally {
+//             lock.unlock();
+//         }
+//     }
+
+    /**
+     * Returns an array containing all of the elements in this deque, in
+     * proper sequence (from first to last element).
+     *
+     * <p>The returned array will be "safe" in that no references to it are
+     * maintained by this deque.  (In other words, this method must allocate
+     * a new array).  The caller is thus free to modify the returned array.
+     *
+     * <p>This method acts as bridge between array-based and collection-based
+     * APIs.
+     *
+     * @return an array containing all of the elements in this deque
+     */
+    @Override
+    public Object[] toArray() {
+        lock.lock();
+        try {
+            Object[] a = new Object[count];
+            int k = 0;
+            for (Node<E> p = first; p != null; p = p.next)
+                a[k++] = p.item;
+            return a;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @SuppressWarnings("unchecked")
+    @Override
+    public <T> T[] toArray(T[] a) {
+        lock.lock();
+        try {
+            if (a.length < count) {
+                a = (T[])java.lang.reflect.Array.newInstance
+                    (a.getClass().getComponentType(), count);
+            }
+            int k = 0;
+            for (Node<E> p = first; p != null; p = p.next)
+                a[k++] = (T)p.item;
+            if (a.length > k) {
+                a[k] = null;
+            }
+            return a;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public String toString() {
+        lock.lock();
+        try {
+            return super.toString();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Atomically removes all of the elements from this deque.
+     * The deque will be empty after this call returns.
+     */
+    @Override
+    public void clear() {
+        lock.lock();
+        try {
+            for (Node<E> f = first; f != null;) {
+                f.item = null;
+                Node<E> n = f.next;
+                f.prev = null;
+                f.next = null;
+                f = n;
+            }
+            first = last = null;
+            count = 0;
+            notFull.signalAll();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Returns an iterator over the elements in this deque in proper sequence.
+     * The elements will be returned in order from first (head) to last (tail).
+     * The returned {@code Iterator} is a "weakly consistent" iterator that
+     * will never throw {@link java.util.ConcurrentModificationException
+     * ConcurrentModificationException},
+     * and guarantees to traverse elements as they existed upon
+     * construction of the iterator, and may (but is not guaranteed to)
+     * reflect any modifications subsequent to construction.
+     *
+     * @return an iterator over the elements in this deque in proper sequence
+     */
+    @Override
+    public Iterator<E> iterator() {
+        return new Itr();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Iterator<E> descendingIterator() {
+        return new DescendingItr();
+    }
+
+    /**
+     * Base class for Iterators for LinkedBlockingDeque
+     */
+    private abstract class AbstractItr implements Iterator<E> {
+        /**
+         * The next node to return in next()
+         */
+         Node<E> next;
+
+        /**
+         * nextItem holds on to item fields because once we claim that
+         * an element exists in hasNext(), we must return item read
+         * under lock (in advance()) even if it was in the process of
+         * being removed when hasNext() was called.
+         */
+        E nextItem;
+
+        /**
+         * Node returned by most recent call to next. Needed by remove.
+         * Reset to null if this element is deleted by a call to remove.
+         */
+        private Node<E> lastRet;
+
+        /**
+         * Obtain the first node to be returned by the iterator.
+         *
+         * @return first node
+         */
+        abstract Node<E> firstNode();
+
+        /**
+         * For a given node, obtain the next node to be returned by the
+         * iterator.
+         *
+         * @param n given node
+         *
+         * @return next node
+         */
+        abstract Node<E> nextNode(Node<E> n);
+
+        /**
+         * Create a new iterator. Sets the initial position.
+         */
+        AbstractItr() {
+            // set to initial position
+            lock.lock();
+            try {
+                next = firstNode();
+                nextItem = (next == null) ? null : next.item;
+            } finally {
+                lock.unlock();
+            }
+        }
+
+        /**
+         * Advances next.
+         */
+        void advance() {
+            lock.lock();
+            try {
+                // assert next != null;
+                Node<E> s = nextNode(next);
+                if (s == next) {
+                    next = firstNode();
+                } else {
+                    // Skip over removed nodes.
+                    // May be necessary if multiple interior Nodes are removed.
+                    while (s != null && s.item == null)
+                        s = nextNode(s);
+                    next = s;
+                }
+                nextItem = (next == null) ? null : next.item;
+            } finally {
+                lock.unlock();
+            }
+        }
+
+        @Override
+        public boolean hasNext() {
+            return next != null;
+        }
+
+        @Override
+        public E next() {
+            if (next == null)
+                throw new NoSuchElementException();
+            lastRet = next;
+            E x = nextItem;
+            advance();
+            return x;
+        }
+
+        @Override
+        public void remove() {
+            Node<E> n = lastRet;
+            if (n == null)
+                throw new IllegalStateException();
+            lastRet = null;
+            lock.lock();
+            try {
+                if (n.item != null)
+                    unlink(n);
+            } finally {
+                lock.unlock();
+            }
+        }
+    }
+
+    /** Forward iterator */
+    private class Itr extends AbstractItr {
+        @Override
+        Node<E> firstNode() { return first; }
+        @Override
+        Node<E> nextNode(Node<E> n) { return n.next; }
+        }
+
+    /** Descending iterator */
+    private class DescendingItr extends AbstractItr {
+        @Override
+        Node<E> firstNode() { return last; }
+        @Override
+        Node<E> nextNode(Node<E> n) { return n.prev; }
+    }
+
+    /**
+     * Save the state of this deque to a stream (that is, serialize it).
+     *
+     * @serialData The capacity (int), followed by elements (each an
+     * {@code Object}) in the proper order, followed by a null
+     * @param s the stream
+     */
+    private void writeObject(java.io.ObjectOutputStream s)
+        throws java.io.IOException {
+        lock.lock();
+        try {
+            // Write out capacity and any hidden stuff
+            s.defaultWriteObject();
+            // Write out all elements in the proper order.
+            for (Node<E> p = first; p != null; p = p.next)
+                s.writeObject(p.item);
+            // Use trailing null as sentinel
+            s.writeObject(null);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Reconstitute this deque from a stream (that is,
+     * deserialize it).
+     * @param s the stream
+     */
+    private void readObject(java.io.ObjectInputStream s)
+        throws java.io.IOException, ClassNotFoundException {
+        s.defaultReadObject();
+        count = 0;
+        first = null;
+        last = null;
+        // Read in all elements and place in queue
+        for (;;) {
+            @SuppressWarnings("unchecked")
+            E item = (E)s.readObject();
+            if (item == null)
+                break;
+            add(item);
+        }
+    }
+
+    // Monitoring methods
+
+    /**
+     * Returns true if there are threads waiting to take instances from this deque.
+     * See disclaimer on accuracy in
+     * {@link java.util.concurrent.locks.ReentrantLock#hasWaiters(Condition)}.
+     *
+     * @return true if there is at least one thread waiting on this deque's notEmpty condition.
+     */
+    public boolean hasTakeWaiters() {
+        lock.lock();
+        try {
+            return lock.hasWaiters(notEmpty);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Returns the length of the queue of threads waiting to take instances from this deque.
+     * See disclaimer on accuracy in
+     * {@link java.util.concurrent.locks.ReentrantLock#getWaitQueueLength(Condition)}.
+     *
+     * @return number of threads waiting on this deque's notEmpty condition.
+     */
+    public int getTakeQueueLength() {
+        lock.lock();
+        try {
+           return lock.getWaitQueueLength(notEmpty);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Interrupts the threads currently waiting to take an object from the pool.
+     * See disclaimer on accuracy in
+     * {@link java.util.concurrent.locks.ReentrantLock#getWaitingThreads(Condition)}.
+     */
+    public void interuptTakeWaiters() {
+        lock.lock();
+        try {
+           lock.interruptWaiters(notEmpty);
+        } finally {
+            lock.unlock();
+        }
+    }
+}

==================================================
PooledSoftReference.java
new file mode 100644
index 0000000000..2b26ac462a
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/PoolImplUtils.java
@@ -0,0 +1,126 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+
+import org.apache.tomcat.dbcp.pool2.PooledObjectFactory;
+
+/**
+ * Implementation specific utilities.
+ *
+ * @since 2.0
+ */
+class PoolImplUtils {
+
+    /**
+     * Identifies the concrete type of object that an object factory creates.
+     *
+     * @param factory The factory to examine
+     *
+     * @return the type of object the factory creates
+     */
+    @SuppressWarnings("rawtypes")
+    static Class<?> getFactoryType(Class<? extends PooledObjectFactory> factory) {
+        return (Class<?>) getGenericType(PooledObjectFactory.class, factory);
+    }
+
+
+    /**
+     * Obtain the concrete type used by an implementation of an interface that
+     * uses a generic type.
+     *
+     * @param type  The interface that defines a generic type
+     * @param clazz The class that implements the interface with a concrete type
+     * @param <T>   The interface type
+     *
+     * @return concrete type used by the implementation
+     */
+    private static <T> Object getGenericType(Class<T> type,
+            Class<? extends T> clazz) {
+
+        // Look to see if this class implements the generic interface
+
+        // Get all the interfaces
+        Type[] interfaces = clazz.getGenericInterfaces();
+        for (Type iface : interfaces) {
+            // Only need to check interfaces that use generics
+            if (iface instanceof ParameterizedType) {
+                ParameterizedType pi = (ParameterizedType) iface;
+                // Look for the generic interface
+                if (pi.getRawType() instanceof Class) {
+                    if (type.isAssignableFrom((Class<?>) pi.getRawType())) {
+                        return getTypeParameter(
+                                clazz, pi.getActualTypeArguments()[0]);
+                    }
+                }
+            }
+        }
+
+        // Interface not found on this class. Look at the superclass.
+        @SuppressWarnings("unchecked")
+        Class<? extends T> superClazz =
+                (Class<? extends T>) clazz.getSuperclass();
+
+        Object result = getGenericType(type, superClazz);
+        if (result instanceof Class<?>) {
+            // Superclass implements interface and defines explicit type for
+            // generic
+            return result;
+        } else if (result instanceof Integer) {
+            // Superclass implements interface and defines unknown type for
+            // generic
+            // Map that unknown type to the generic types defined in this class
+            ParameterizedType superClassType =
+                    (ParameterizedType) clazz.getGenericSuperclass();
+            return getTypeParameter(clazz,
+                    superClassType.getActualTypeArguments()[
+                            ((Integer) result).intValue()]);
+        } else {
+            // Error will be logged further up the call stack
+            return null;
+        }
+    }
+
+
+    /**
+     * For a generic parameter, return either the Class used or if the type
+     * is unknown, the index for the type in definition of the class
+     *
+     * @param clazz defining class
+     * @param argType the type argument of interest
+     *
+     * @return An instance of {@link Class} representing the type used by the
+     *         type parameter or an instance of {@link Integer} representing
+     *         the index for the type in the definition of the defining class
+     */
+    private static Object getTypeParameter(Class<?> clazz, Type argType) {
+        if (argType instanceof Class<?>) {
+            return argType;
+        } else {
+            TypeVariable<?>[] tvs = clazz.getTypeParameters();
+            for (int i = 0; i < tvs.length; i++) {
+                if (tvs[i].equals(argType)) {
+                    return Integer.valueOf(i);
+                }
+            }
+            return null;
+        }
+    }
+}

==================================================
SoftReferenceObjectPool.java
new file mode 100644
index 0000000000..41372a0653
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/PooledSoftReference.java
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.dbcp.pool2.impl;
+
+import java.lang.ref.SoftReference;
+
+/**
+ * Extension of {@link DefaultPooledObject} to wrap pooled soft references.
+ *
+ * <p>This class is intended to be thread-safe.</p>
+ *
+ * @param <T> the type of the underlying object that the wrapped SoftReference
+ * refers to.
+ *
+ * @version $Revision: $
+ *
+ * @since 2.0
+ */
+public class PooledSoftReference<T> extends DefaultPooledObject<T> {
+
+    /** SoftReference wrapped by this object */
+    private volatile SoftReference<T> reference;
+
+    /**
+     * Creates a new PooledSoftReference wrapping the provided reference.
+     *
+     * @param reference SoftReference to be managed by the pool
+     */
+    public PooledSoftReference(SoftReference<T> reference) {
+        super(null);  // Null the hard reference in the parent
+        this.reference = reference;
+    }
+
+    /**
+     * Returns the object that the wrapped SoftReference refers to.
+     * <p>
+     * Note that if the reference has been cleared, this method will return
+     * null.
+     *
+     * @return Object referred to by the SoftReference
+     */
+    @Override
+    public T getObject() {
+        return reference.get();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        StringBuilder result = new StringBuilder();
+        result.append("Referenced Object: ");
+        result.append(getObject().toString());
+        result.append(", State: ");
+        synchronized (this) {
+            result.append(getState().toString());
+        }
+        return result.toString();
+        // TODO add other attributes
+        // TODO encapsulate state and other attribute display in parent
+    }
+
+    /**
+     * Returns the SoftReference wrapped by this object.
+     *
+     * @return underlying SoftReference
+     */
+    public synchronized SoftReference<T> getReference() {
+        return reference;
+    }
+
+    /**
+     * Sets the wrapped reference.
+     *
+     * <p>This method exists to allow a new, non-registered reference to be
+     * held by the pool to track objects that have been checked out of the pool.
+     * The actual parameter <strong>should</strong> be a reference to the same
+     * object that {@link #getObject()} returns before calling this method.</p>
+     *
+     * @param reference new reference
+     */
+    public synchronized void setReference(SoftReference<T> reference) {
+        this.reference = reference;
+    }
+}

==================================================
DefaultTestCase.java
new file mode 100644
index 0000000000..d177957334
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/pool2/package.html
@@ -0,0 +1,63 @@
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<!-- $Id$ -->
+<html>
+   <head>
+      <title>Package Documentation for org.apache.commons.pool2</title>
+   </head>
+   <body>
+      <p>
+         Object pooling API.
+      </p>
+      <p>
+         The <code>org.apache.commons.pool2</code> package defines a simple
+         interface for a pool of object instances, and a handful of base
+         classes that may be useful when creating pool implementations.
+      </p>
+      <p>
+         The <code>pool</code> package itself doesn't define a specific object
+         pooling implementation, but rather a contract that implementations may
+         support in order to be fully interchangeable.
+      </p>
+      <p>
+         The <code>pool</code> package separates the way in which instances are
+         pooled from the way in which they are created, resulting in a pair of
+         interfaces:
+      </p>
+      <dl>
+        <dt>{@link org.apache.commons.pool2.ObjectPool ObjectPool}</dt>
+        <dd>
+          defines a simple object pooling interface, with methods for
+          borrowing instances from and returning them to the pool.
+        </dd>
+        <dt>{@link org.apache.commons.pool2.PooledObjectFactory PooledObjectFactory}</dt>
+        <dd>
+          defines lifecycle methods for object instances contained within a pool.
+          By associating a factory with a pool, the pool can create new object
+          instances as needed.
+        </dd>
+      </dl>
+      <p>
+         The <code>pool</code> package also provides a keyed pool interface,
+         which pools instances of multiple types, accessed according to an
+         arbitrary key. See
+         {@link org.apache.commons.pool2.KeyedObjectPool KeyedObjectPool} and
+         {@link org.apache.commons.pool2.KeyedPooledObjectFactory
+         KeyedPooledObjectFactory}.
+      </p>
+   </body>
+</html>

==================================================
