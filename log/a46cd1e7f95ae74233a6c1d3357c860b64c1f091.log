a46cd1e7f95ae74233a6c1d3357c860b64c1f091
==================================================
- Add session browser capabilities in the manager. Let me know if it creates problems (I checked XSS to some extent to,
==================================================
Remy Maucherat
==================================================
Mon Apr 16 23:30:55 2007 +0000
==================================================
HTMLManagerServlet.java
- Add session browser capabilities in the manager. Let me know if it creates problems (I checked XSS to some extent to,
  but please double check if you can).
- Submitted by CÃ©drik Lime.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@529444 13f79535-47bb-0310-9956-ffa450edef68



==================================================
JspHelper.java
index b267f44b48..1b6cf2716e 100644
--- a/java/org/apache/catalina/manager/HTMLManagerServlet.java
+++ b/java/org/apache/catalina/manager/HTMLManagerServlet.java
@@ -23,6 +23,10 @@ import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.text.MessageFormat;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -30,9 +34,14 @@ import java.util.TreeMap;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
 
 import org.apache.catalina.Container;
 import org.apache.catalina.Context;
+import org.apache.catalina.Session;
+import org.apache.catalina.manager.util.BaseSessionComparator;
+import org.apache.catalina.manager.util.ReverseComparator;
+import org.apache.catalina.manager.util.SessionUtils;
 import org.apache.catalina.util.RequestUtil;
 import org.apache.catalina.util.ServerInfo;
 import org.apache.tomcat.util.http.fileupload.DiskFileUpload;
@@ -50,7 +59,7 @@ import org.apache.tomcat.util.http.fileupload.FileItem;
 * makes it easier to administrate.
 * <p>
 * However if you use a software that parses the output of
-* <code>ManagerServlet</code you won't be able to upgrade
+* <code>ManagerServlet</code> you won't be able to upgrade
 * to this Servlet since the output are not in the
 * same format ar from <code>ManagerServlet</code>
 *
@@ -63,6 +72,11 @@ import org.apache.tomcat.util.http.fileupload.FileItem;
 
 public final class HTMLManagerServlet extends ManagerServlet {
 
+    protected static final String APPLICATION_MESSAGE = "message";
+    protected static final String APPLICATION_ERROR = "error";
+    protected String sessionsListJspPath  = "/sessionsList.jsp";
+    protected String sessionDetailJspPath = "/sessionDetail.jsp";
+
     // --------------------------------------------------------- Public Methods
 
     /**
@@ -100,7 +114,15 @@ public final class HTMLManagerServlet extends ManagerServlet {
         } else if (command.equals("/undeploy")) {
             message = undeploy(path);
         } else if (command.equals("/sessions")) {
-            message = sessions(path);
+            //message = sessions(path);
+            try {
+                doSessions(path, request, response);
+                return;
+            } catch (Exception e) {
+                log("HTMLManagerServlet.sessions[" + path + "]", e);
+                message = sm.getString("managerServlet.exception",
+                        e.toString());
+            }
         } else if (command.equals("/start")) {
             message = start(path);
         } else if (command.equals("/stop")) {
@@ -562,6 +584,309 @@ public final class HTMLManagerServlet extends ManagerServlet {
         return stringWriter.toString();
     }
 
+    /**
+     * @see javax.servlet.Servlet#getServletInfo()
+     */
+    public String getServletInfo() {
+        return "HTMLManagerServlet, Copyright (c) The Apache Software Foundation";
+    }   
+    
+    /**
+     * @see javax.servlet.GenericServlet#init()
+     */
+    public void init() throws ServletException {
+        super.init();
+    }   
+
+    // ------------------------------------------------ Sessions administration
+
+    /**
+     * 
+     * @param req
+     * @param resp
+     * @throws ServletException
+     * @throws IOException 
+     */
+    protected void doSessions(String path, HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
+        req.setAttribute("path", path);
+        String action = req.getParameter("action");
+        if (debug >= 1) {
+            log("sessions: Session action '" + action + "' for web application at '" + path + "'");
+        }
+        if ("sessionDetail".equals(action)) {
+	        String sessionId = req.getParameter("sessionId");
+	        displaySessionDetailPage(req, resp, path, sessionId);
+	        return;
+        } else if ("invalidateSessions".equals(action)) {
+            String[] sessionIds = req.getParameterValues("sessionIds");
+            int i = invalidateSessions(path, sessionIds);
+            req.setAttribute(APPLICATION_MESSAGE, "" + i + " sessions invalidated.");
+        } else if ("removeSessionAttribute".equals(action)) {
+            String sessionId = req.getParameter("sessionId");
+            String name = req.getParameter("attributeName");
+            boolean removed = removeSessionAttribute(path, sessionId, name);
+            String outMessage = removed ? "Session attribute '" + name + "' removed." : "Session did not contain any attribute named '" + name + "'";
+            req.setAttribute(APPLICATION_MESSAGE, outMessage);
+            resp.sendRedirect(resp.encodeRedirectURL(req.getRequestURL().append("?path=").append(path).append("&action=sessionDetail&sessionId=").append(sessionId).toString()));
+            return;
+        } // else
+        displaySessionsListPage(path, req, resp);
+    }
+
+    protected Session[] getSessionsForPath(String path) {
+        if ((path == null) || (!path.startsWith("/") && path.equals(""))) {
+            throw new IllegalArgumentException(sm.getString("managerServlet.invalidPath",
+                                        RequestUtil.filter(path)));
+        }
+        String displayPath = path;
+        if( path.equals("/") )
+            path = "";
+        Context context = (Context) host.findChild(path);
+        if (null == context) {
+            throw new IllegalArgumentException(sm.getString("managerServlet.noContext",
+                                        RequestUtil.filter(displayPath)));
+        }
+        Session[] sessions = context.getManager().findSessions();
+        return sessions;
+    }
+    protected Session getSessionForPathAndId(String path, String id) throws IOException {
+        if ((path == null) || (!path.startsWith("/") && path.equals(""))) {
+            throw new IllegalArgumentException(sm.getString("managerServlet.invalidPath",
+                                        RequestUtil.filter(path)));
+        }
+        String displayPath = path;
+        if( path.equals("/") )
+            path = "";
+        Context context = (Context) host.findChild(path);
+        if (null == context) {
+            throw new IllegalArgumentException(sm.getString("managerServlet.noContext",
+                                        RequestUtil.filter(displayPath)));
+        }
+        Session session = context.getManager().findSession(id);
+        return session;
+    }
+
+    /**
+     * 
+     * @param req
+     * @param resp
+     * @throws ServletException
+     * @throws IOException
+     */
+    protected void displaySessionsListPage(String path, HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
+        List/*<Session>*/ activeSessions = Arrays.asList(getSessionsForPath(path));
+        String sortBy = req.getParameter("sort");
+        String orderBy = null;
+        if (null != sortBy && !"".equals(sortBy.trim())) {
+            Comparator comparator = getComparator(sortBy);
+            if (comparator != null) {
+                orderBy = req.getParameter("order");
+                if ("DESC".equalsIgnoreCase(orderBy)) {
+                    comparator = new ReverseComparator(comparator);
+                    // orderBy = "ASC";
+                } else {
+                    //orderBy = "DESC";
+                }
+                try {
+					Collections.sort(activeSessions, comparator);
+				} catch (IllegalStateException ise) {
+					// at least 1 of the sessions is invalidated
+					req.setAttribute(APPLICATION_ERROR, "Can't sort session list: one session is invalidated");
+				}
+            } else {
+                log("WARNING: unknown sort order: " + sortBy);
+            }
+        }
+        // keep sort order
+        req.setAttribute("sort", sortBy);
+        req.setAttribute("order", orderBy);
+        req.setAttribute("activeSessions", activeSessions);
+        //strong>NOTE</strong> - This header will be overridden
+        // automatically if a <code>RequestDispatcher.forward()</code> call is
+        // ultimately invoked.
+        resp.setHeader("Pragma", "No-cache"); // HTTP 1.0
+        resp.setHeader("Cache-Control", "no-cache,no-store,max-age=0"); // HTTP 1.1
+        resp.setDateHeader("Expires", 0); // 0 means now
+        getServletContext().getRequestDispatcher(sessionsListJspPath).include(req, resp);
+    }
+
+    /**
+     * 
+     * @param req
+     * @param resp
+     * @throws ServletException
+     * @throws IOException
+     */
+    protected void displaySessionDetailPage(HttpServletRequest req, HttpServletResponse resp, String path, String sessionId) throws ServletException, IOException {
+        Session session = getSessionForPathAndId(path, sessionId);
+        //strong>NOTE</strong> - This header will be overridden
+        // automatically if a <code>RequestDispatcher.forward()</code> call is
+        // ultimately invoked.
+        resp.setHeader("Pragma", "No-cache"); // HTTP 1.0
+        resp.setHeader("Cache-Control", "no-cache,no-store,max-age=0"); // HTTP 1.1
+        resp.setDateHeader("Expires", 0); // 0 means now
+        req.setAttribute("currentSession", session);
+        getServletContext().getRequestDispatcher(sessionDetailJspPath).include(req, resp);
+    }
+
+    /**
+     * Invalidate HttpSessions
+     * @param sessionIds
+     * @return number of invalidated sessions
+     * @throws IOException 
+     */
+    public int invalidateSessions(String path, String[] sessionIds) throws IOException {
+        if (null == sessionIds) {
+            return 0;
+        }
+        int nbAffectedSessions = 0;
+        for (int i = 0; i < sessionIds.length; ++i) {
+            String sessionId = sessionIds[i];
+            HttpSession session = getSessionForPathAndId(path, sessionId).getSession();
+            if (null == session) {
+                // Shouldn't happen, but let's play nice...
+            	if (debug >= 1) {
+            		log("WARNING: can't invalidate null session " + sessionId);
+            	}
+                continue;
+            }
+            try {
+				session.invalidate();
+				++nbAffectedSessions;
+	            if (debug >= 1) {
+	                log("Invalidating session id " + sessionId);
+	            }
+			} catch (IllegalStateException ise) {
+				if (debug >= 1) {
+					log("Can't invalidate already invalidated session id " + sessionId);
+				}
+			}
+        }
+        return nbAffectedSessions;
+    }
+
+    /**
+     * Removes an attribute from an HttpSession
+     * @param sessionId
+     * @param attributeName
+     * @return true if there was an attribute removed, false otherwise
+     * @throws IOException 
+     */
+    public boolean removeSessionAttribute(String path, String sessionId, String attributeName) throws IOException {
+        HttpSession session = getSessionForPathAndId(path, sessionId).getSession();
+        if (null == session) {
+            // Shouldn't happen, but let's play nice...
+        	if (debug >= 1) {
+        		log("WARNING: can't remove attribute '" + attributeName + "' for null session " + sessionId);
+        	}
+            return false;
+        }
+        boolean wasPresent = (null != session.getAttribute(attributeName));
+        try {
+            session.removeAttribute(attributeName);
+        } catch (IllegalStateException ise) {
+        	if (debug >= 1) {
+        		log("Can't remote attribute '" + attributeName + "' for invalidated session id " + sessionId);
+        	}
+        }
+        return wasPresent;
+    }
+
+    /**
+     * Sets the maximum inactive interval (session timeout) an HttpSession
+     * @param sessionId
+     * @param maxInactiveInterval in seconds
+     * @return old value for maxInactiveInterval
+     * @throws IOException 
+     */
+    public int setSessionMaxInactiveInterval(String path, String sessionId, int maxInactiveInterval) throws IOException {
+        HttpSession session = getSessionForPathAndId(path, sessionId).getSession();
+        if (null == session) {
+            // Shouldn't happen, but let's play nice...
+        	if (debug >= 1) {
+        		log("WARNING: can't set timout for null session " + sessionId);
+        	}
+            return 0;
+        }
+        try {
+			int oldMaxInactiveInterval = session.getMaxInactiveInterval();
+			session.setMaxInactiveInterval(maxInactiveInterval);
+			return oldMaxInactiveInterval;
+        } catch (IllegalStateException ise) {
+        	if (debug >= 1) {
+        		log("Can't set MaxInactiveInterval '" + maxInactiveInterval + "' for invalidated session id " + sessionId);
+        	}
+        	return 0;
+		}
+    }
+
+    protected Comparator getComparator(String sortBy) {
+        Comparator comparator = null;
+        if ("CreationTime".equalsIgnoreCase(sortBy)) {
+            comparator = new BaseSessionComparator() {
+                public Comparable getComparableObject(Session session) {
+                    return new Date(session.getCreationTime());
+                }
+            };
+        } else if ("id".equalsIgnoreCase(sortBy)) {
+            comparator = new BaseSessionComparator() {
+                public Comparable getComparableObject(Session session) {
+                    return session.getId();
+                }
+            };
+        } else if ("LastAccessedTime".equalsIgnoreCase(sortBy)) {
+            comparator = new BaseSessionComparator() {
+                public Comparable getComparableObject(Session session) {
+                    return new Date(session.getLastAccessedTime());
+                }
+            };
+        } else if ("MaxInactiveInterval".equalsIgnoreCase(sortBy)) {
+            comparator = new BaseSessionComparator() {
+                public Comparable getComparableObject(Session session) {
+                    return new Date(session.getMaxInactiveInterval());
+                }
+            };
+        } else if ("new".equalsIgnoreCase(sortBy)) {
+            comparator = new BaseSessionComparator() {
+                public Comparable getComparableObject(Session session) {
+                    return Boolean.valueOf(session.getSession().isNew());
+                }
+            };
+        } else if ("locale".equalsIgnoreCase(sortBy)) {
+            comparator = new BaseSessionComparator() {
+                public Comparable getComparableObject(Session session) {
+                    return JspHelper.guessDisplayLocaleFromSession(session);
+                }
+            };
+        } else if ("user".equalsIgnoreCase(sortBy)) {
+            comparator = new BaseSessionComparator() {
+                public Comparable getComparableObject(Session session) {
+                    return JspHelper.guessDisplayUserFromSession(session);
+                }
+            };
+        } else if ("UsedTime".equalsIgnoreCase(sortBy)) {
+            comparator = new BaseSessionComparator() {
+                public Comparable getComparableObject(Session session) {
+                    return new Date(SessionUtils.getUsedTimeForSession(session));
+                }
+            };
+        } else if ("InactiveTime".equalsIgnoreCase(sortBy)) {
+            comparator = new BaseSessionComparator() {
+                public Comparable getComparableObject(Session session) {
+                    return new Date(SessionUtils.getInactiveTimeForSession(session));
+                }
+            };
+        } else if ("TTL".equalsIgnoreCase(sortBy)) {
+            comparator = new BaseSessionComparator() {
+                public Comparable getComparableObject(Session session) {
+                    return new Date(SessionUtils.getTTLForSession(session));
+                }
+            };
+        }
+        //TODO: complete this to TTL, etc.
+        return comparator;
+    }
+
     // ------------------------------------------------------ Private Constants
 
     // These HTML sections are broken in relatively small sections, because of
@@ -586,7 +911,7 @@ public final class HTMLManagerServlet extends ManagerServlet {
         " <td class=\"row-left\" bgcolor=\"{5}\"><small><a href=\"{0}\">{0}</a></small></td>\n" +
         " <td class=\"row-left\" bgcolor=\"{5}\"><small>{1}</small></td>\n" +
         " <td class=\"row-center\" bgcolor=\"{5}\"><small>{2}</small></td>\n" +
-        " <td class=\"row-center\" bgcolor=\"{5}\"><small><a href=\"{3}\">{4}</a></small></td>\n";
+        " <td class=\"row-center\" bgcolor=\"{5}\"><small><a href=\"{3}\" target=\"_new\">{4}</a></small></td>\n";
 
     private static final String MANAGER_APP_ROW_BUTTON_SECTION =
         " <td class=\"row-left\" bgcolor=\"{8}\">\n" +

==================================================
BaseSessionComparator.java
new file mode 100644
index 0000000000..39df89ea07
--- /dev/null
+++ b/java/org/apache/catalina/manager/JspHelper.java
@@ -0,0 +1,239 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.manager;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.text.DateFormat;
+import java.text.NumberFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+
+import org.apache.catalina.Session;
+import org.apache.catalina.manager.util.SessionUtils;
+
+
+/**
+ * Helper JavaBean for JSPs, because JSTL 1.1/EL 2.0 is too dumb to
+ * to what I need (call methods with parameters), or I am too dumb to use it correctly. :)
+ * @author C&eacute;drik LIME
+ */
+public class JspHelper {
+
+    private static final String DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
+    private static final String DATE_FORMAT = "yyyy-MM-dd";
+    private static final String TIME_FORMAT = "HH:mm:ss";
+
+    /**
+     * Public constructor, so that this class can be considered a JavaBean
+     */
+    private JspHelper() {
+        super();
+    }
+
+    /**
+     * Try to get user locale from the session, if possible.
+     * IMPLEMENTATION NOTE: this method has explicit support for Tapestry 3 and Struts 1.x
+     * @param in_session
+     * @return String
+     */
+    public static String guessDisplayLocaleFromSession(Session in_session) {
+        return localeToString(SessionUtils.guessLocaleFromSession(in_session));
+    }
+    private static String localeToString(Locale locale) {
+        if (locale != null) {
+            return locale.toString();//locale.getDisplayName();
+        } else {
+            return "";
+        }
+    }
+
+    /**
+     * Try to get user name from the session, if possible.
+     * @param in_session
+     * @return String
+     */
+    public static String guessDisplayUserFromSession(Session in_session) {
+        Object user = SessionUtils.guessUserFromSession(in_session);
+        return escapeXml(user);
+    }
+
+
+    public static String getDisplayCreationTimeForSession(Session in_session) {
+        try {
+			DateFormat formatter = new SimpleDateFormat(DATE_TIME_FORMAT);
+			return formatter.format(new Date(in_session.getCreationTime()));
+        } catch (IllegalStateException ise) {
+        	//ignore: invalidated session
+        	return "";
+		}
+    }
+
+    public static String getDisplayLastAccessedTimeForSession(Session in_session) {
+        try {
+			DateFormat formatter = new SimpleDateFormat(DATE_TIME_FORMAT);
+			return formatter.format(new Date(in_session.getLastAccessedTime()));
+        } catch (IllegalStateException ise) {
+        	//ignore: invalidated session
+        	return "";
+		}
+    }
+
+    public static String getDisplayUsedTimeForSession(Session in_session) {
+        return secondsToTimeString(SessionUtils.getUsedTimeForSession(in_session)/1000);
+    }
+
+    public static String getDisplayTTLForSession(Session in_session) {
+        return secondsToTimeString(SessionUtils.getTTLForSession(in_session)/1000);
+    }
+
+    public static String getDisplayInactiveTimeForSession(Session in_session) {
+        return secondsToTimeString(SessionUtils.getInactiveTimeForSession(in_session)/1000);
+    }
+
+    public static String secondsToTimeString(long in_seconds) {
+        StringBuffer buff = new StringBuffer(9);
+        long rest = in_seconds;
+        long hour = rest / 3600;
+        rest = rest % 3600;
+        long minute = rest / 60;
+        rest = rest % 60;
+        long second = rest;
+        if (hour < 10) {
+            buff.append('0');
+        }
+        buff.append(hour);
+        buff.append(':');
+        if (minute < 10) {
+            buff.append('0');
+        }
+        buff.append(minute);
+        buff.append(':');
+        if (second < 10) {
+            buff.append('0');
+        }
+        buff.append(second);
+        return buff.toString();
+    }
+
+
+    /**
+    * Following copied from org.apache.taglibs.standard.tag.common.core.OutSupport v1.1.2
+    * 
+    *  Optimized to create no extra objects and write directly
+    *  to the JspWriter using blocks of escaped and unescaped characters
+    *
+    */
+   private static void writeEscapedXml(char[] buffer, int length, Writer w) throws IOException {
+       int start = 0;
+
+       for (int i = 0; i < length; i++) {
+           char c = buffer[i];
+           if (c <= HIGHEST_SPECIAL) {
+               char[] escaped = specialCharactersRepresentation[c];
+               if (escaped != null) {
+                   // add unescaped portion
+                   if (start < i) {
+                       w.write(buffer,start,i-start);
+                   }
+                   // add escaped xml
+                   w.write(escaped);
+                   start = i + 1;
+               }
+           }
+       }
+       // add rest of unescaped portion
+       if (start < length) {
+           w.write(buffer,start,length-start);
+       }
+   }
+
+
+    /*
+     * Following copied from org.apache.taglibs.standard.tag.common.core.Util v1.1.2
+     */
+
+    private static final int HIGHEST_SPECIAL = '>';
+    private static char[][] specialCharactersRepresentation = new char[HIGHEST_SPECIAL + 1][];
+    static {
+        specialCharactersRepresentation['&'] = "&amp;".toCharArray();
+        specialCharactersRepresentation['<'] = "&lt;".toCharArray();
+        specialCharactersRepresentation['>'] = "&gt;".toCharArray();
+        specialCharactersRepresentation['"'] = "&#034;".toCharArray();
+        specialCharactersRepresentation['\''] = "&#039;".toCharArray();
+    }
+
+    public static String escapeXml(Object obj) {
+    	return obj == null ? "" : escapeXml(String.valueOf(obj));
+    }
+    /**
+     * Performs the following substring replacements
+     * (to facilitate output to XML/HTML pages):
+     *
+     *    & -> &amp;
+     *    < -> &lt;
+     *    > -> &gt;
+     *    " -> &#034;
+     *    ' -> &#039;
+     *
+     * See also OutSupport.writeEscapedXml().
+     */
+    public static String escapeXml(String buffer) {
+    	if (buffer == null) {
+			return "";
+		}
+        int start = 0;
+        int length = buffer.length();
+        char[] arrayBuffer = buffer.toCharArray();
+        StringBuffer escapedBuffer = null;
+
+        for (int i = 0; i < length; i++) {
+            char c = arrayBuffer[i];
+            if (c <= HIGHEST_SPECIAL) {
+                char[] escaped = specialCharactersRepresentation[c];
+                if (escaped != null) {
+                    // create StringBuffer to hold escaped xml string
+                    if (start == 0) {
+                        escapedBuffer = new StringBuffer(length + 5);
+                    }
+                    // add unescaped portion
+                    if (start < i) {
+                        escapedBuffer.append(arrayBuffer,start,i-start);
+                    }
+                    start = i + 1;
+                    // add escaped xml
+                    escapedBuffer.append(escaped);
+                }
+            }
+        }
+        // no xml escaping was necessary
+        if (start == 0) {
+            return buffer;
+        }
+        // add rest of unescaped portion
+        if (start < length) {
+            escapedBuffer.append(arrayBuffer,start,length-start);
+        }
+        return escapedBuffer.toString();
+    }
+
+    public static String formatNumber(long number) {
+    	return NumberFormat.getNumberInstance().format(number);
+    }
+}

==================================================
ReverseComparator.java
new file mode 100644
index 0000000000..e4c48bcb19
--- /dev/null
+++ b/java/org/apache/catalina/manager/util/BaseSessionComparator.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.manager.util;
+
+import java.util.Comparator;
+
+import org.apache.catalina.Session;
+
+/**
+ * Comparator which permits to compare on a session's content
+ * @author C&eacute;drik LIME
+ */
+public abstract class BaseSessionComparator implements Comparator {
+
+    /**
+     * 
+     */
+    public BaseSessionComparator() {
+        super();
+    }
+
+    public abstract Comparable getComparableObject(Session session);
+
+    /* (non-Javadoc)
+     * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
+     */
+    public final int compare(Object o1, Object o2) {
+        Comparable c1 = getComparableObject((Session)o1);
+        Comparable c2 = getComparableObject((Session)o2);
+        return c1==null ? (c2==null ? 0 : -1) : (c2==null ? 1 : c1.compareTo(c2));
+    }
+}

==================================================
SessionUtils.java
new file mode 100644
index 0000000000..b0a7735bb2
--- /dev/null
+++ b/java/org/apache/catalina/manager/util/ReverseComparator.java
@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.catalina.manager.util;
+
+import java.util.Comparator;
+
+/**
+ * Comparator which reverse the sort order
+ * @author C&eacute;drik LIME
+ */
+public class ReverseComparator implements Comparator {
+    protected Comparator comparator;
+
+    /**
+     * 
+     */
+    public ReverseComparator(Comparator comparator) {
+        super();
+        this.comparator = comparator;
+    }
+
+    /* (non-Javadoc)
+     * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
+     */
+    public int compare(Object o1, Object o2) {
+        int returnValue = comparator.compare(o1, o2);
+        return (- returnValue);
+    }
+}

==================================================
