f89d5ae7aa33bd8c505d3f9f1ead0012b6aef2c1
==================================================
Fixed the socket flush, since NIO SSL uses dual sockets, we need to be considerate of when the data is actually sent on the OS buffer
==================================================
Filip Hanik
==================================================
Mon Aug 7 18:55:41 2006 +0000
==================================================
InternalNioInputBuffer.java
Fixed the socket flush, since NIO SSL uses dual sockets, we need to be considerate of when the data is actually sent on the OS buffer


git-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@429431 13f79535-47bb-0310-9956-ffa450edef68



==================================================
InternalNioOutputBuffer.java
index d11cb5d2c1..b1fb2bc2d0 100644
--- a/java/org/apache/coyote/http11/InternalNioInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalNioInputBuffer.java
@@ -556,23 +556,25 @@ public class InternalNioInputBuffer implements InputBuffer {
             } else if (nRead == -1) {
                 //return false;
                 throw new IOException("end of stream reached.");
-            }
-            timedOut = (readTimeout != -1) && ((System.currentTimeMillis()-start)>this.readTimeout);
-            if ( !timedOut && nRead == 0 ) 
-                try {
-                    final SelectionKey key = socket.getIOChannel().keyFor(poller.getSelector());
-                    final KeyAttachment att = (KeyAttachment)key.attachment();
-                    //to do, add in a check, we might have just timed out on the wait,
-                    //so there is no need to register us again.
-                    boolean addToQueue = false;
-                    try { addToQueue = ((key.interestOps()&SelectionKey.OP_READ) != SelectionKey.OP_READ); } catch ( CancelledKeyException ignore ){}
-                    if ( addToQueue ) {
-                        addToReadQueue(key, att);
-                    }//end if
-                    synchronized (att.getMutex()) {
-                        if ( att.getWakeUp() ) att.getMutex().wait(25);
-                    }
-                }catch ( Exception x ) {}
+            } else {
+                timedOut = (readTimeout != -1) && ((System.currentTimeMillis()-start)>readTimeout);
+                if ( !timedOut && nRead == 0 )  {
+                    try {
+                        final SelectionKey key = socket.getIOChannel().keyFor(poller.getSelector());
+                        final KeyAttachment att = (KeyAttachment)key.attachment();
+                        //to do, add in a check, we might have just timed out on the wait,
+                        //so there is no need to register us again.
+                        boolean addToQueue = false;
+                        try { addToQueue = ((key.interestOps()&SelectionKey.OP_READ) != SelectionKey.OP_READ); } catch ( CancelledKeyException ckx ){ throw new IOException("Socket key cancelled.");}
+                        if ( addToQueue ) {
+                            synchronized (att.getMutex()) {
+                                addToReadQueue(key, att);
+                                att.getMutex().wait(readTimeout);
+                            }
+                        }//end if
+                    }catch ( Exception x ) {}
+                }
+             }
         }while ( nRead == 0 && (!timedOut) );
         //else throw new IOException(sm.getString("iib.failedread"));
         //return false; //timeout

==================================================
NioChannel.java
index 673bffe90a..e6d50f1774 100644
--- a/java/org/apache/coyote/http11/InternalNioOutputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalNioOutputBuffer.java
@@ -395,11 +395,16 @@ public class InternalNioOutputBuffer
     }
 
     private synchronized void writeToSocket(ByteBuffer bytebuffer, boolean flip) throws IOException {
-        int limit = bytebuffer.position();
+        //int limit = bytebuffer.position();
         if ( flip ) bytebuffer.flip();
         while ( bytebuffer.hasRemaining() ) {
             int written = socket.write(bytebuffer);
         }
+        //make sure we are flushed 
+        do {
+            if (socket.flush()) break;
+        }while ( true );
+        
         socket.getBufHandler().getWriteBuffer().clear();
         this.total = 0;
     } 

==================================================
NioEndpoint.java
index 2036c87564..14ab5a60a7 100644
--- a/java/org/apache/tomcat/util/net/NioChannel.java
+++ b/java/org/apache/tomcat/util/net/NioChannel.java
@@ -43,6 +43,15 @@ public class NioChannel implements ByteChannel{
         this.bufHandler = bufHandler;
     }
 
+    /**
+     * returns true if the network buffer has 
+     * been flushed out and is empty
+     * @return boolean
+     */
+    public boolean flush() throws IOException {
+        return true; //no network buffer in the regular channel
+    }
+
 
     /**
      * Closes this channel.

==================================================
SecureNioChannel.java
index f3eaaa5700..404ca3e121 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -978,20 +978,18 @@ public class NioEndpoint {
                 }
     
             };
-            synchronized (events) {
-                events.add(r);
-            }
-            selector.wakeup();
+            addEvent(r);
         }
         
         public void cancelledKey(SelectionKey key) {
             try {
                 KeyAttachment ka = (KeyAttachment) key.attachment();
-                key.cancel();
+                if ( key.isValid() ) key.cancel();
                 if (ka != null && ka.getComet()) processSocket( ka.getChannel(), true);
-                key.channel().close();
-            } catch (IOException e) {
-                if ( log.isDebugEnabled() ) log.debug("",e);
+                if ( key.channel().isOpen() ) key.channel().close();
+                key.attach(null);
+            } catch (Throwable e) {
+                if ( log.isDebugEnabled() ) log.error("",e);
                 // Ignore
             }
         }
@@ -1054,8 +1052,8 @@ public class NioEndpoint {
                                 } else {
                                     boolean close = (!processSocket(channel));
                                     if ( close ) {
-                                        channel.getIOChannel().socket().close();
                                         channel.close();
+                                        channel.getIOChannel().socket().close();
                                     }
                                 }
                             } 
@@ -1064,10 +1062,7 @@ public class NioEndpoint {
                             cancelledKey(sk);
                         }
                     } catch ( CancelledKeyException ckx ) {
-                        if (attachment!=null && attachment.getComet()) processSocket( attachment.getChannel(), true);
-                        try {
-                            sk.channel().close();
-                        }catch ( Exception ignore){}
+                        cancelledKey(sk);
                     } catch (Throwable t) {
                         log.error("",t);
                     }
@@ -1253,6 +1248,8 @@ public class NioEndpoint {
                 }catch ( IOException x ) {
                     handshake = -1;
                     log.error("Error during SSL handshake",x);
+                }catch ( CancelledKeyException ckx ) {
+                    handshake = -1;
                 }
                 if ( handshake == 0 ) {
                     // Process the request from this socket
@@ -1274,7 +1271,7 @@ public class NioEndpoint {
                         }
                     }
                 } else if (handshake == -1 ) {
-                    key.cancel();
+                    if ( key.isValid() ) key.cancel();
                     try {socket.close(true);}catch (IOException ignore){}
                 } else {
                     final SelectionKey fk = key;

==================================================
