626bcccb1f5cfe345471c9d4ac7e3fedcbff227f
==================================================
Fix the root cause of the previous TCK failures (badly re-factored flush()) and restore the changes that were just working around the symptoms (poller stuff).
==================================================
Mark Emlyn
==================================================
Thu Sep 30 17:35:35 2010 +0000
==================================================
AbstractAjpProcessor.java
Fix the root cause of the previous TCK failures (badly re-factored flush()) and restore the changes that were just working around the symptoms (poller stuff).
Servlet 3.0 passes for the AJP/APR connector as of this commit.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1003177 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AjpAprProcessor.java
index c5dd0b3ce2..42831990a1 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
@@ -233,7 +233,7 @@ public abstract class AbstractAjpProcessor implements ActionHook, Processor {
            }
 
            try {
-               flush();
+               flush(false);
            } catch (IOException e) {
                // Set error flag
                error = true;
@@ -253,7 +253,7 @@ public abstract class AbstractAjpProcessor implements ActionHook, Processor {
            }
 
            try {
-               flush();
+               flush(true);
            } catch (IOException e) {
                // Set error flag
                error = true;
@@ -358,7 +358,7 @@ public abstract class AbstractAjpProcessor implements ActionHook, Processor {
    
    // Methods called by action()
    protected abstract void actionInternal(ActionCode actionCode, Object param);
-   protected abstract void flush() throws IOException;
+   protected abstract void flush(boolean tbd) throws IOException;
    protected abstract void finish() throws IOException;
    
    

==================================================
AjpAprProtocol.java
index b50d3e5f41..815121a20e 100644
--- a/java/org/apache/coyote/ajp/AjpAprProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpAprProcessor.java
@@ -319,6 +319,13 @@ public class AjpAprProcessor extends AbstractAjpProcessor {
 
         }
 
+        // Add the socket to the poller
+        if (!error && !endpoint.isPaused()) {
+            if (!isAsync()) {
+                ((AprEndpoint)endpoint).getPoller().add(socketRef);
+            }
+        }
+
         rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
         
         if (error || endpoint.isPaused()) {
@@ -451,10 +458,10 @@ public class AjpAprProcessor extends AbstractAjpProcessor {
 
         // Add the end message
         if (outputBuffer.position() + endMessageArray.length > outputBuffer.capacity()) {
-            flush();
+            flush(false);
         }
         outputBuffer.put(endMessageArray);
-        flush();
+        flush(false);
 
     }
 
@@ -645,7 +652,7 @@ public class AjpAprProcessor extends AbstractAjpProcessor {
      * Callback to write data from the buffer.
      */
     @Override
-    protected void flush() throws IOException {
+    protected void flush(boolean explicit) throws IOException {
         
         long socketRef = socket.getSocket().longValue();
         
@@ -656,11 +663,12 @@ public class AjpAprProcessor extends AbstractAjpProcessor {
             outputBuffer.clear();
         }
         // Send explicit flush message
-        if (Socket.sendb(socketRef, flushMessageBuffer, 0,
-                flushMessageBuffer.position()) < 0) {
-            throw new IOException(sm.getString("ajpprocessor.failedflush"));
+        if (explicit) {
+            if (Socket.sendb(socketRef, flushMessageBuffer, 0,
+                    flushMessageBuffer.position()) < 0) {
+                throw new IOException(sm.getString("ajpprocessor.failedflush"));
+            }
         }
-
     }
 
 
@@ -705,7 +713,7 @@ public class AjpAprProcessor extends AbstractAjpProcessor {
                 len -= thisTime;
                 if (outputBuffer.position() + thisTime +
                     Constants.H_SIZE + 4 > outputBuffer.capacity()) {
-                    flush();
+                    flush(false);
                 }
                 outputBuffer.put((byte) 0x41);
                 outputBuffer.put((byte) 0x42);

==================================================
AjpProcessor.java
index 4b4ea26fe4..a0faf4724e 100644
--- a/java/org/apache/coyote/ajp/AjpAprProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpAprProtocol.java
@@ -481,9 +481,9 @@ public class AjpAprProtocol
                     if (state != SocketState.LONG && state != SocketState.ASYNC_END) {
                         connections.remove(socket);
                         recycledProcessors.offer(result);
-                        //if (state == SocketState.OPEN) {
-                        //    proto.endpoint.getPoller().add(socket.getSocket().longValue());
-                        //}
+                        if (state == SocketState.OPEN) {
+                            proto.endpoint.getPoller().add(socket.getSocket().longValue());
+                        }
                     }
                 }
             }

==================================================
