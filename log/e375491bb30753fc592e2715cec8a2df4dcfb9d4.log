e375491bb30753fc592e2715cec8a2df4dcfb9d4
==================================================
Update Commons Fileupload to r1458500
==================================================
Mark Emlyn
==================================================
Tue Mar 19 23:13:15 2013 +0000
==================================================
FileUploadBase.java
Update Commons Fileupload to r1458500

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1458564 13f79535-47bb-0310-9956-ffa450edef68



==================================================
package-info.java
index 21c81dd452..3db28d2cf7 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java
@@ -299,9 +299,8 @@ public abstract class FileUploadBase {
                 } catch (FileUploadIOException e) {
                     throw (FileUploadException) e.getCause();
                 } catch (IOException e) {
-                    throw new IOFileUploadException(
-                            String.format("Processing of %s request failed. %s",
-                                    MULTIPART_FORM_DATA, e.getMessage()), e);
+                    throw new IOFileUploadException(String.format("Processing of %s request failed. %s",
+                                                           MULTIPART_FORM_DATA, e.getMessage()), e);
                 }
                 final FileItemHeaders fih = item.getHeaders();
                 fileItem.setHeaders(fih);

==================================================
Base64Decoder.java
index bc748187ec..85796e4664 100644
--- a/java/org/apache/tomcat/util/http/fileupload/package-info.java
+++ b/java/org/apache/tomcat/util/http/fileupload/package-info.java
@@ -18,7 +18,7 @@
 
 /**
  * <p><b>NOTE:</b> This code has been copied from commons-fileupload trunk
- * revision 1458080 and commons-io 1.4 and package renamed to avoid clashes with
+ * revision 1458500 and commons-io 1.4 and package renamed to avoid clashes with
  * any web apps that may wish to use these libraries.
  * </p>
  * <p>

==================================================
MimeUtility.java
index 3974bc6150..96cdfd8077 100644
--- a/java/org/apache/tomcat/util/http/fileupload/util/mime/Base64Decoder.java
+++ b/java/org/apache/tomcat/util/http/fileupload/util/mime/Base64Decoder.java
@@ -82,17 +82,19 @@ final class Base64Decoder {
      * whitespace characters will be ignored.
      *
      * @param data the buffer containing the Base64-encoded data
-     * @param off the start offset (zero-based)
-     * @param length the number of bytes to convert
      * @param out the output stream to hold the decoded bytes
      *
      * @return the number of bytes produced.
      */
-    public static int decode(byte[] data, int off, int length, OutputStream out) throws IOException {
+    public static int decode(byte[] data, OutputStream out) throws IOException {
         byte    b1, b2, b3, b4;
         int        outLen = 0;
 
-        int        end = off + length;
+        if (data.length == 0) {
+            return outLen;
+        }
+
+        int        end = data.length;
 
         while (end > 0) {
             if (!ignore((char) data[end - 1])) {
@@ -102,7 +104,7 @@ final class Base64Decoder {
             end--;
         }
 
-        int  i = off;
+        int  i = 0;
         // CHECKSTYLE IGNORE MagicNumber FOR NEXT 1 LINE
         int  finish = end - 4; // last set of 4 bytes might include padding
 
@@ -158,12 +160,13 @@ final class Base64Decoder {
         if (p1 != PADDING) { // Nothing more to do if p1 == PADDING
             // CHECKSTYLE IGNORE MagicNumber FOR NEXT 1 LINE
             out.write((b2 << 4) | (b3 >> 2)); // 4 bits of b2 plus 4 bits of b3
-            outLen++;
-        } else if (p2 != PADDING) { // Nothing more to do if p2 == PADDING
-            b4 = DECODING_TABLE[p2];
-            // CHECKSTYLE IGNORE MagicNumber FOR NEXT 1 LINE
-            out.write((b3 << 6) | b4);        // 2 bits of b3 plus 6 bits of b4
-            outLen++;
+            outLen++; 
+            if (p2 != PADDING) { // Nothing more to do if p2 == PADDING
+                b4 = DECODING_TABLE[p2];
+                // CHECKSTYLE IGNORE MagicNumber FOR NEXT 1 LINE
+                out.write((b3 << 6) | b4);        // 2 bits of b3 plus 6 bits of b4
+                outLen++;
+            }
         }
 
         return outLen;

==================================================
QuotedPrintableDecoder.java
index e1a7b7b1db..537e5a28ac 100644
--- a/java/org/apache/tomcat/util/http/fileupload/util/mime/MimeUtility.java
+++ b/java/org/apache/tomcat/util/http/fileupload/util/mime/MimeUtility.java
@@ -30,11 +30,31 @@ import java.util.Map;
  */
 public final class MimeUtility {
 
+    /**
+     * The {@code US-ASCII} charset identifier constant.
+     */
+    private static final String US_ASCII_CHARSET = "US-ASCII";
+
+    /**
+     * The marker to indicate text is encoded with BASE64 algorithm.
+     */
+    private static final String BASE64_ENCODING_MARKER = "B";
+
+    /**
+     * The marker to indicate text is encoded with QuotedPrintable algorithm.
+     */
+    private static final String QUOTEDPRINTABLE_ENCODING_MARKER = "Q";
+
     /**
      * If the text contains any encoded tokens, those tokens will be marked with "=?".
      */
     private static final String ENCODED_TOKEN_MARKER = "=?";
 
+    /**
+     * If the text contains any encoded tokens, those tokens will terminate with "=?".
+     */
+    private static final String ENCODED_TOKEN_FINISHER = "?=";
+
     /**
      * The linear whitespace chars sequence.
      */
@@ -97,12 +117,12 @@ public final class MimeUtility {
             char ch = text.charAt(offset);
 
             // is this a whitespace character?
-            if (LINEAR_WHITESPACE.indexOf(ch) != -1) {
+            if (LINEAR_WHITESPACE.indexOf(ch) != -1) { // whitespace found
                 startWhiteSpace = offset;
                 while (offset < endOffset) {
                     // step over the white space characters.
                     ch = text.charAt(offset);
-                    if (LINEAR_WHITESPACE.indexOf(ch) != -1) {
+                    if (LINEAR_WHITESPACE.indexOf(ch) != -1) { // whitespace found
                         offset++;
                     } else {
                         // record the location of the first non lwsp and drop down to process the
@@ -116,9 +136,9 @@ public final class MimeUtility {
                 int wordStart = offset;
 
                 while (offset < endOffset) {
-                    // step over the white space characters.
+                    // step over the non white space characters.
                     ch = text.charAt(offset);
-                    if (LINEAR_WHITESPACE.indexOf(ch) == -1) {
+                    if (LINEAR_WHITESPACE.indexOf(ch) == -1) { // not white space
                         offset++;
                     } else {
                         break;
@@ -203,7 +223,7 @@ public final class MimeUtility {
         String encoding = word.substring(charsetPos + 1, encodingPos);
 
         // and finally the encoded text.
-        int encodedTextPos = word.indexOf("?=", encodingPos + 1);
+        int encodedTextPos = word.indexOf(ENCODED_TOKEN_FINISHER, encodingPos + 1);
         if (encodedTextPos == -1) {
             throw new ParseException("Missing encoded text in RFC 2047 encoded-word: " + word);
         }
@@ -219,13 +239,13 @@ public final class MimeUtility {
             // the decoder writes directly to an output stream.
             ByteArrayOutputStream out = new ByteArrayOutputStream(encodedText.length());
 
-            byte[] encodedData = encodedText.getBytes("US-ASCII");
+            byte[] encodedData = encodedText.getBytes(US_ASCII_CHARSET);
 
             // Base64 encoded?
-            if (encoding.equals("B")) {
-                Base64Decoder.decode(encodedData, 0, encodedData.length, out);
-            } else if (encoding.equals("Q")) { // maybe quoted printable.
-                QuotedPrintableDecoder.decode(encodedData, 0, encodedData.length, out);
+            if (encoding.equals(BASE64_ENCODING_MARKER)) {
+                Base64Decoder.decode(encodedData, out);
+            } else if (encoding.equals(QUOTEDPRINTABLE_ENCODING_MARKER)) { // maybe quoted printable.
+                QuotedPrintableDecoder.decode(encodedData, out);
             } else {
                 throw new UnsupportedEncodingException("Unknown RFC 2047 encoding: " + encoding);
             }

==================================================
