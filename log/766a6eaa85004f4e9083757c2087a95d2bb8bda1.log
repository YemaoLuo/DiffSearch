766a6eaa85004f4e9083757c2087a95d2bb8bda1
==================================================
Few change to the ObjectManager ( intended for integration with existing frameworks ).
==================================================
Costin Manolache
==================================================
Thu Nov 26 06:50:10 2009 +0000
==================================================
DynamicObject.java
Few change to the ObjectManager ( intended for integration with existing frameworks ).
The 'sample/if no other framework around' SimpleObject manager no longer depends on IntrospectionUtils, refactored it ( and parts of modeler )
to DynamicObject. 



git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@884419 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ObjectManager.java
new file mode 100644
index 0000000000..7afcb1ffb5
--- /dev/null
+++ b/modules/tomcat-lite/java/org/apache/tomcat/integration/DynamicObject.java
@@ -0,0 +1,393 @@
+/*
+ */
+package org.apache.tomcat.integration;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Refactoring of IntrospectionUtils and modeler dynamic bean.
+ * 
+ * Unlike IntrospectionUtils, the method informations can be cached.
+ * Also I hope this class will be simpler to use. 
+ * There is no static cache.
+ * 
+ * @author Costin Manolache
+ */
+public class DynamicObject {
+    // Based on MbeansDescriptorsIntrospectionSource
+
+    static Logger log = Logger.getLogger(DynamicObject.class.getName());
+
+    static Class<?> NO_PARAMS[] = new Class[0];
+
+
+    private static String strArray[] = new String[0];
+
+    private static Class<?>[] supportedTypes = new Class[] { Boolean.class,
+            Boolean.TYPE, Byte.class, Byte.TYPE, Character.class,
+            Character.TYPE, Short.class, Short.TYPE, Integer.class,
+            Integer.TYPE, Long.class, Long.TYPE, Float.class, Float.TYPE,
+            Double.class, Double.TYPE, String.class, strArray.getClass(),
+            BigDecimal.class, BigInteger.class, AtomicInteger.class,
+            AtomicLong.class, java.io.File.class, };
+
+    
+    private Class realClass;
+
+    private Map<String, Method> getAttMap;
+
+    public DynamicObject(Class beanClass) {
+        this.realClass = beanClass;
+        initCache();
+    }
+
+    public DynamicObject(Class beanClass, boolean noCache) {
+        this.realClass = beanClass;
+    }
+
+    private void initCache() {
+        Method methods[] = null;
+
+        getAttMap = new HashMap<String, Method>();
+
+        methods = realClass.getMethods();
+        for (int j = 0; j < methods.length; ++j) {
+            if (ignorable(methods[j])) {
+                continue;
+            }
+            String name = methods[j].getName();
+
+            Class<?> params[] = methods[j].getParameterTypes();
+
+            if (name.startsWith("get") && params.length == 0) {
+                Class<?> ret = methods[j].getReturnType();
+                if (!supportedType(ret)) {
+                    if (log.isLoggable(Level.FINE))
+                        log.fine("Unsupported type " + methods[j]);
+                    continue;
+                }
+                name = unCapitalize(name.substring(3));
+
+                getAttMap.put(name, methods[j]);
+            } else if (name.startsWith("is") && params.length == 0) {
+                Class<?> ret = methods[j].getReturnType();
+                if (Boolean.TYPE != ret) {
+                    if (log.isLoggable(Level.FINE))
+                        log.fine("Unsupported type " + methods[j] + " " + ret);
+                    continue;
+                }
+                name = unCapitalize(name.substring(2));
+
+                getAttMap.put(name, methods[j]);
+            }
+        }
+    }
+
+    private boolean ignorable(Method method) {
+        if (Modifier.isStatic(method.getModifiers()))
+            return true;
+        if (!Modifier.isPublic(method.getModifiers())) {
+            return true;
+        }
+        if (method.getDeclaringClass() == Object.class)
+            return true;
+        return false;
+    }
+    
+    public List<String> attributeNames() {
+        List<String> attributes = new ArrayList<String>();
+        Method methods[] = realClass.getMethods();
+        for (int j = 0; j < methods.length; ++j) {
+            String name = methods[j].getName();
+            if (ignorable(methods[j])) {
+                continue;
+            }
+            Class<?> params[] = methods[j].getParameterTypes();
+            if (name.startsWith("get") && params.length == 0) {
+                Class<?> ret = methods[j].getReturnType();
+                if (!supportedType(ret)) {
+                    continue;
+                }
+                name = unCapitalize(name.substring(3));
+                attributes.add(name);
+            } else if (name.startsWith("is") && params.length == 0) {
+                Class<?> ret = methods[j].getReturnType();
+                if (Boolean.TYPE != ret) {
+                    continue;
+                }
+                name = unCapitalize(name.substring(2));
+                attributes.add(name);
+            } else if (name.startsWith("set") && params.length == 1) {
+                if (!supportedType(params[0])) {
+                    continue;
+                }
+                name = unCapitalize(name.substring(3));
+                attributes.add(name);
+            }
+        }
+
+        return attributes;
+    }
+
+
+    public Object invoke(Object proxy, String method) throws Exception {
+        Method executeM = null;
+        Class<?> c = proxy.getClass();
+        executeM = c.getMethod(method, NO_PARAMS);
+        if (executeM == null) {
+            throw new RuntimeException("No execute in " + proxy.getClass());
+        }
+        return executeM.invoke(proxy, (Object[]) null);
+    }
+
+    // TODO
+    public Object invoke(String method, Object[] params) {
+        return null;
+    }
+
+    public boolean hasHook(String method) {
+        return false;
+    }
+
+    public Object getAttribute(Object o, String att) {
+        Method m = getAttMap.get(att);
+        if (m == null)
+            return null;
+        try {
+            return m.invoke(o);
+        } catch (Throwable e) {
+            log.log(Level.INFO, "Error getting attribute " + realClass + " "
+                    + att, e);
+            return null;
+        }
+    }
+
+    public boolean setAttribute(Object proxy, String name, Object value) {
+        String methodName = "set" + capitalize(name);
+        Method[] methods = proxy.getClass().getMethods();
+        for (Method m : methods) {
+            Class<?>[] paramT = m.getParameterTypes();
+            if (methodName.equals(m.getName())
+                    && paramT.length == 1
+                    && (value == null || paramT[0].isAssignableFrom(value
+                            .getClass()))) {
+                try {
+                    m.invoke(proxy, value);
+                    return true;
+                } catch (IllegalArgumentException e) {
+                    log.severe("Error setting: " + name + " "
+                            + proxy.getClass().getName() + " " + e);
+                } catch (IllegalAccessException e) {
+                    log.severe("Error setting: " + name + " "
+                            + proxy.getClass().getName() + " " + e);
+                } catch (InvocationTargetException e) {
+                    log.severe("Error setting: " + name + " "
+                            + proxy.getClass().getName() + " " + e);
+                }
+            }
+        }
+        return false;
+    }
+
+    public boolean setProperty(Object proxy, String name, String value) {
+        String setter = "set" + capitalize(name);
+
+        try {
+            Method methods[] = proxy.getClass().getMethods();
+            
+            Method setPropertyMethod = null;
+
+            // First, the ideal case - a setFoo( String ) method
+            for (int i = 0; i < methods.length; i++) {
+                if (ignorable(methods[i])) {
+                    continue;
+                }
+                Class<?> paramT[] = methods[i].getParameterTypes();
+                if (setter.equals(methods[i].getName()) && paramT.length == 1) {
+                    if ("java.lang.String".equals(paramT[0].getName())) {
+                        methods[i].invoke(proxy, new Object[] { value });
+                        return true;
+                    } else {
+                        // match - find the type and invoke it
+                        Class<?> paramType = methods[i].getParameterTypes()[0];
+                        Object params[] = new Object[1];
+                        params[0] = convert(value, paramType);
+                        if (params[0] != null) {
+                            methods[i].invoke(proxy, params);
+                            return true;
+                        }
+                    }
+                }
+                // save "setProperty" for later
+                if ("setProperty".equals(methods[i].getName()) && 
+                        paramT.length == 2 &&
+                        paramT[0] == String.class &&
+                        paramT[1] == String.class) {
+                    setPropertyMethod = methods[i];
+                }
+            }
+
+            try {
+                Field field = proxy.getClass().getField(name);
+                if (field != null) {
+                    Object conv = convert(value, field.getType());
+                    if (conv != null) {
+                        field.set(proxy, conv);
+                        return true;
+                    }
+                }
+            } catch (NoSuchFieldException e) {
+                // ignore
+            }
+
+            // Ok, no setXXX found, try a setProperty("name", "value")
+            if (setPropertyMethod != null) {
+                Object params[] = new Object[2];
+                params[0] = name;
+                params[1] = value;
+                setPropertyMethod.invoke(proxy, params);
+                return true;
+            }
+
+        } catch (Throwable ex2) {
+            log.log(Level.WARNING, "IAE " + proxy + " " + name + " " + value,
+                    ex2);
+        }
+        return false;
+    }
+
+    // ----------- Helpers ------------------
+    
+    static Object convert(String object, Class<?> paramType) {
+        Object result = null;
+        if ("java.lang.String".equals(paramType.getName())) {
+            result = object;
+        } else if ("java.lang.Long".equals(paramType.getName())
+                || "long".equals(paramType.getName())) {
+            try {
+                result = Long.parseLong(object);
+            } catch (NumberFormatException ex) {
+            }
+            // Try a setFoo ( boolean )
+        } else if ("java.lang.Integer".equals(paramType.getName())
+                || "int".equals(paramType.getName())) {
+            try {
+                result = new Integer(object);
+            } catch (NumberFormatException ex) {
+            }
+            // Try a setFoo ( boolean )
+        } else if ("java.lang.Boolean".equals(paramType.getName())
+                || "boolean".equals(paramType.getName())) {
+            result = new Boolean(object);
+        } else {
+            log.info("Unknown type " + paramType.getName());
+        }
+        if (result == null) {
+            throw new IllegalArgumentException("Can't convert argument: "
+                    + object +  " to " + paramType );
+        }
+        return result;
+    }
+
+    /**
+     * Converts the first character of the given String into lower-case.
+     * 
+     * @param name
+     *            The string to convert
+     * @return String
+     */
+    static String unCapitalize(String name) {
+        if (name == null || name.length() == 0) {
+            return name;
+        }
+        char chars[] = name.toCharArray();
+        chars[0] = Character.toLowerCase(chars[0]);
+        return new String(chars);
+    }
+
+    /**
+     * Check if this class is one of the supported types. If the class is
+     * supported, returns true. Otherwise, returns false.
+     * 
+     * @param ret
+     *            The class to check
+     * @return boolean True if class is supported
+     */
+    static boolean supportedType(Class<?> ret) {
+        for (int i = 0; i < supportedTypes.length; i++) {
+            if (ret == supportedTypes[i]) {
+                return true;
+            }
+        }
+        if (isBeanCompatible(ret)) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Check if this class conforms to JavaBeans specifications. If the class is
+     * conformant, returns true.
+     * 
+     * @param javaType
+     *            The class to check
+     * @return boolean True if the class is compatible.
+     */
+    static boolean isBeanCompatible(Class<?> javaType) {
+        // Must be a non-primitive and non array
+        if (javaType.isArray() || javaType.isPrimitive()) {
+            return false;
+        }
+
+        // Anything in the java or javax package that
+        // does not have a defined mapping is excluded.
+        if (javaType.getName().startsWith("java.")
+                || javaType.getName().startsWith("javax.")) {
+            return false;
+        }
+
+        try {
+            javaType.getConstructor(new Class[] {});
+        } catch (java.lang.NoSuchMethodException e) {
+            return false;
+        }
+
+        // Make sure superclass is compatible
+        Class<?> superClass = javaType.getSuperclass();
+        if (superClass != null && superClass != java.lang.Object.class
+                && superClass != java.lang.Exception.class
+                && superClass != java.lang.Throwable.class) {
+            if (!isBeanCompatible(superClass)) {
+                return false;
+            }
+        }
+        return true;
+    }
+    
+    /**
+     * Reverse of Introspector.decapitalize
+     */
+    static String capitalize(String name) {
+        if (name == null || name.length() == 0) {
+            return name;
+        }
+        char chars[] = name.toCharArray();
+        chars[0] = Character.toUpperCase(chars[0]);
+        return new String(chars);
+    }
+
+    
+}

==================================================
AntProperties.java
index 219699c7f3..299e387ddf 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/integration/ObjectManager.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/integration/ObjectManager.java
@@ -78,6 +78,19 @@ public class ObjectManager {
         return null;
     }
 
+    /**
+     * Create or get a new object with the given name.
+     */
+    public String getProperty(String key) {
+        for (ObjectManager p : children) {
+            String o = p.getProperty(key);
+            if (o != null) {
+                return o;
+            }
+        }        
+        return null;
+    }
+
     /**
      * Helper for typed get.
      */
@@ -93,6 +106,6 @@ public class ObjectManager {
         new ArrayList<ObjectManager>(); 
     
     public void register(ObjectManager om) {
-        om.children.add(this);
+        children.add(om);
     }    
 }

==================================================
LocalFilesystem.java
new file mode 100644
index 0000000000..1d840bcd18
--- /dev/null
+++ b/modules/tomcat-lite/java/org/apache/tomcat/integration/simple/AntProperties.java
@@ -0,0 +1,75 @@
+/*
+ */
+package org.apache.tomcat.integration.simple;
+
+import java.util.Hashtable;
+
+/**
+ * Extracted from IntrospectionHelper - a simple utility class to 
+ * do ant style ${property} replacements on a string, using a map
+ * holding properties. Also allows a hook for dynamic, on-demand 
+ * properties.
+ * 
+ * @author Costin Manolache
+ */
+public class AntProperties {
+    public static interface PropertySource {
+        public String getProperty(String key);
+    }
+
+    /**
+     * Replace ${NAME} with the property value
+     */
+    public static String replaceProperties(String value,
+            Hashtable<Object,Object> staticProp, PropertySource dynamicProp[]) {
+        if (value.indexOf("$") < 0) {
+            return value;
+        }
+        StringBuffer sb = new StringBuffer();
+        int prev = 0;
+        // assert value!=nil
+        int pos;
+        while ((pos = value.indexOf("$", prev)) >= 0) {
+            if (pos > 0) {
+                sb.append(value.substring(prev, pos));
+            }
+            if (pos == (value.length() - 1)) {
+                sb.append('$');
+                prev = pos + 1;
+            } else if (value.charAt(pos + 1) != '{') {
+                sb.append('$');
+                prev = pos + 1; // XXX
+            } else {
+                int endName = value.indexOf('}', pos);
+                if (endName < 0) {
+                    sb.append(value.substring(pos));
+                    prev = value.length();
+                    continue;
+                }
+                String n = value.substring(pos + 2, endName);
+                String v = null;
+                if (staticProp != null) {
+                    v = (String) staticProp.get(n);
+                }
+                if (v == null && dynamicProp != null) {
+                    for (int i = 0; i < dynamicProp.length; i++) {
+                        v = dynamicProp[i].getProperty(n);
+                        if (v != null) {
+                            break;
+                        }
+                    }
+                }
+                if (v == null)
+                    v = "${" + n + "}";
+
+                sb.append(v);
+                prev = endName + 1;
+            }
+        }
+        if (prev < value.length())
+            sb.append(value.substring(prev));
+        return sb.toString();
+    }
+
+
+}

==================================================
Main.java
deleted file mode 100644
index 7bdf475627..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/integration/simple/LocalFilesystem.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.integration.simple;
-
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-
-import org.apache.tomcat.addons.Filesystem;
-
-public class LocalFilesystem extends Filesystem {
-
-    public OutputStream getOutputStream(String name) throws IOException {
-        return new FileOutputStream(name);
-    }    
-}

==================================================
SimpleObjectManager.java
index cc2d0031b4..b19e4d4add 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/integration/simple/Main.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/integration/simple/Main.java
@@ -17,7 +17,6 @@
 
 package org.apache.tomcat.integration.simple;
 
-import org.apache.tomcat.integration.ObjectManager;
 
 /**
  * Replacement for tomcat-lite specific Main, using the simple 
@@ -28,17 +27,34 @@ import org.apache.tomcat.integration.ObjectManager;
  * @author Costin Manolache
  */
 public class Main {
+    static boolean running = true;
+    static Object lock = new Object();
+    
+    public static void stop() {
+        running = false;
+        synchronized (lock) {
+            lock.notify();
+        }
+    }
+    
+    public static void waitStop() {
+        while (running) {
+            try {
+                synchronized (lock) {
+                    lock.wait();
+                }
+            } catch (InterruptedException e) {
+            }
+        }
+    }
 
     public static void main(String args[]) 
-    throws Exception {
-        SimpleObjectManager om = new SimpleObjectManager();
-        
-        // Will process CLI. 
-        // 'config' will load a config file.
-        om.bind("Main.args", args);
+            throws Exception {
+        // '--config' will load a config file.
+        SimpleObjectManager om = new SimpleObjectManager(args);
 
-        Runnable main = (Runnable) om.get("Main");
-        if (main == null) {
+        String run = (String) om.getProperty("RUN");
+        if (run == null) {
             // TODO: look for a pre-defined name in local dir, resource,
             // manifest
             System.err.println("Using default tomcat-lite configuration");
@@ -50,16 +66,16 @@ public class Main {
             
             String cfgFile = "org/apache/tomcat/lite/config.properties";
             om.loadResource(cfgFile);
-            main = (Runnable) om.get("Main");
+            run = (String) om.getProperty("RUN");
         }
         
-        // add JMX support
-        ObjectManager jmx = (ObjectManager) om.get("JMX");
-        if (jmx != null) {
-            jmx.register(om);
+        String[] runNames = run.split(",");
+        for (String name: runNames) {
+            Object main = om.get(name);
+            if (main instanceof Runnable) {
+                ((Runnable) main).run();
+            }
         }
-
-        main.run();
-
+        
     }    
 }

==================================================
