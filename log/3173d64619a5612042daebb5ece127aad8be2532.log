3173d64619a5612042daebb5ece127aad8be2532
==================================================
Re-factoring in support of https://issues.apache.org/bugzilla/show_bug.cgi?id=50360
==================================================
Mark Emlyn
==================================================
Thu Dec 9 18:10:38 2010 +0000
==================================================
Connector.java
Re-factoring in support of https://issues.apache.org/bugzilla/show_bug.cgi?id=50360
Move ad-hoc attribute handling from the ProtocolHandler to the Endpoint and expose the Endpoint to ServerSocketFactory objects so they can retrieve additional configuration if required. All default components now use explicit configuration rather than relying on the ad-hoc mechanism.
Ensure the hooks for alternative SSL implementations are in place (were partially removed).
Remove the hooks for alternative ServerSocketFactory implementations (had been hard-coded / half implemented for some time).
Make the sslEnabledProtocols attribute work with BIO as well.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1044058 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractProtocolHandler.java
index 4b8185bc3e..619b28c009 100644
--- a/java/org/apache/catalina/connector/Connector.java
+++ b/java/org/apache/catalina/connector/Connector.java
@@ -249,7 +249,6 @@ public class Connector extends LifecycleMBeanBase  {
          replacements.put("connectionTimeout", "soTimeout");
          replacements.put("randomFile", "randomfile");
          replacements.put("rootFile", "rootfile");
-         replacements.put("sslProtocols", "protocols");
      }
 
 

==================================================
ProtocolHandler.java
index a8040eb966..b7a00c49fd 100644
--- a/java/org/apache/coyote/AbstractProtocolHandler.java
+++ b/java/org/apache/coyote/AbstractProtocolHandler.java
@@ -17,8 +17,6 @@
 package org.apache.coyote;
 
 import java.net.InetAddress;
-import java.util.HashMap;
-import java.util.Iterator;
 import java.util.concurrent.Executor;
 
 import javax.management.MBeanRegistration;
@@ -64,55 +62,6 @@ public abstract class AbstractProtocolHandler implements ProtocolHandler,
     
     // ----------------------------------------------- Generic property handling
 
-    /**
-     * Attributes provide a way for configuration to be passed to sub-components
-     * without the {@link ProtocolHandler} being aware of the properties
-     * available on those sub-components. One example of such a sub-component is
-     * the {@link org.apache.tomcat.util.net.ServerSocketFactory}.
-     */
-    protected HashMap<String, Object> attributes =
-        new HashMap<String, Object>();
-
-
-    /** 
-     * Generic property setter called when a property for which a specific
-     * setter already exists within the {@link ProtocolHandler} needs to be
-     * made available to sub-components. The specific setter will call this
-     * method to populate the attributes.
-     */
-    @Override
-    public void setAttribute(String name, Object value) {
-        if (getLog().isTraceEnabled()) {
-            getLog().trace(sm.getString("abstractProtocolHandler.setAttribute",
-                    name, value));
-        }
-        attributes.put(name, value);
-    }
-
-    
-    /**
-     * Used by sub-components to retrieve configuration information.
-     */
-    @Override
-    public Object getAttribute(String key) {
-        Object value = attributes.get(key);
-        if (getLog().isTraceEnabled()) {
-            getLog().trace(sm.getString("abstractProtocolHandler.getAttribute",
-                    key, value));
-        }
-        return value;
-    }
-
-
-    /**
-     * Used by sub-components to retrieve configuration information.
-     */
-    @Override
-    public Iterator<String> getAttributeNames() {
-        return attributes.keySet().iterator();
-    }
-
-
     /**
      * Generic property setter used by the digester. Other code should not need
      * to use this. The digester will only use this method if it can't find a
@@ -121,7 +70,6 @@ public abstract class AbstractProtocolHandler implements ProtocolHandler,
      * ensures that it is visible to both.
      */
     public boolean setProperty(String name, String value) {
-        setAttribute(name, value);
         return endpoint.setProperty(name, value);
     }
 
@@ -131,9 +79,7 @@ public abstract class AbstractProtocolHandler implements ProtocolHandler,
      * to use this.
      */
     public String getProperty(String name) {
-        // Since all calls to setProperty() will place the property in the
-        // attributes list, just retrieve it from there. 
-        return (String)getAttribute(name);
+        return endpoint.getProperty(name);
     }
 
 
@@ -217,14 +163,12 @@ public abstract class AbstractProtocolHandler implements ProtocolHandler,
     public InetAddress getAddress() { return endpoint.getAddress(); }
     public void setAddress(InetAddress ia) {
         endpoint.setAddress(ia);
-        setAttribute("address", ia.toString());
     }
 
 
     public int getPort() { return endpoint.getPort(); }
     public void setPort(int port) {
         endpoint.setPort(port);
-        setAttribute("port", Integer.toString(port));
     }
 
 
@@ -239,10 +183,6 @@ public abstract class AbstractProtocolHandler implements ProtocolHandler,
     public void setConnectionTimeout(int timeout) {
         // Note that the endpoint uses the alternative name
         endpoint.setSoTimeout(timeout);
-        String str = Integer.toString(timeout);
-        setAttribute("connectionTimeout", str);
-        // Also set the attribute for the alternative name
-        setAttribute("soTimeout", str);
     }
 
     /*

==================================================
AjpProtocol.java
index 8b2f608f0f..b1594c8d67 100644
--- a/java/org/apache/coyote/ProtocolHandler.java
+++ b/java/org/apache/coyote/ProtocolHandler.java
@@ -17,7 +17,6 @@
 
 package org.apache.coyote;
 
-import java.util.Iterator;
 import java.util.concurrent.Executor;
 
 
@@ -36,14 +35,6 @@ import java.util.concurrent.Executor;
  */
 public interface ProtocolHandler {
 
-    /**
-     * Pass config info.
-     */
-    public void setAttribute(String name, Object value);
-    public Object getAttribute(String name);
-    public Iterator<String> getAttributeNames();
-
-    
     /**
      * The adapter, used to call the connector.
      */

==================================================
AbstractHttp11JsseProtocol.java
index 5ec65ca895..3a4ea2c6b9 100644
--- a/java/org/apache/coyote/ajp/AjpProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpProtocol.java
@@ -34,6 +34,7 @@ import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.JIoEndpoint;
 import org.apache.tomcat.util.net.JIoEndpoint.Handler;
+import org.apache.tomcat.util.net.SSLImplementation;
 import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapper;
 
@@ -144,6 +145,12 @@ public class AjpProtocol extends AbstractAjpProtocol {
             return global;
         }
 
+        @Override
+        public SSLImplementation getSslImplementation() {
+            // AJP does not support SSL
+            return null;
+        }
+
         @Override
         public void recycle() {
             recycledProcessors.clear();
@@ -251,7 +258,6 @@ public class AjpProtocol extends AbstractAjpProtocol {
                 }
             }
         }
-
     }
 
 }

==================================================
AbstractHttp11Protocol.java
index 8786fb4340..2f797565be 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11JsseProtocol.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11JsseProtocol.java
@@ -17,7 +17,6 @@
 package org.apache.coyote.http11;
 
 import org.apache.tomcat.util.net.SSLImplementation;
-import org.apache.tomcat.util.net.jsse.JSSEImplementation;
 
 public abstract class AbstractHttp11JsseProtocol
         extends AbstractHttp11Protocol {
@@ -104,12 +103,19 @@ public abstract class AbstractHttp11JsseProtocol
         return endpoint.getAllowUnsafeLegacyRenegotiation();
     }
 
+    private String sslImplemenationName = null;
+    public String getSslImplemenationName() { return sslImplemenationName; }
+    public void setSslImplemenationName(String s) {
+        this.sslImplemenationName = s;
+    }
 
     // ------------------------------------------------------- Lifecycle methods
 
     @Override
     public void init() throws Exception {
+        // SSL implementation needs to be in place before end point is
+        // initialized
+        sslImplementation = SSLImplementation.getInstance(sslImplemenationName);
         super.init();
-        sslImplementation = new JSSEImplementation();
     }
 }

==================================================
Http11NioProtocol.java
index 3b9748de07..648409b86d 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
@@ -166,7 +166,6 @@ public abstract class AbstractHttp11Protocol extends AbstractProtocolHandler {
     public boolean getSecure() { return secure; }
     public void setSecure(boolean b) { 
         secure = b;         
-        setAttribute("secure", "" + b);
     }
     
 
@@ -179,7 +178,6 @@ public abstract class AbstractHttp11Protocol extends AbstractProtocolHandler {
     }
     public void setMaxKeepAliveRequests(int mkar) {
         endpoint.setMaxKeepAliveRequests(mkar);
-        setAttribute("maxKeepAliveRequests", "" + mkar);
     }
 
     

==================================================
Http11Protocol.java
index a0f401735a..8460ae4d15 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -37,6 +37,7 @@ import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.NioChannel;
 import org.apache.tomcat.util.net.NioEndpoint;
 import org.apache.tomcat.util.net.NioEndpoint.Handler;
+import org.apache.tomcat.util.net.SSLImplementation;
 import org.apache.tomcat.util.net.SecureNioChannel;
 import org.apache.tomcat.util.net.SocketStatus;
 
@@ -110,12 +111,10 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
     
     public void setAcceptorThreadPriority(int threadPriority) {
         ((NioEndpoint)endpoint).setAcceptorThreadPriority(threadPriority);
-      setAttribute("acceptorThreadPriority", "" + threadPriority);
     }
 
     public void setPollerThreadPriority(int threadPriority) {
         ((NioEndpoint)endpoint).setPollerThreadPriority(threadPriority);
-      setAttribute("pollerThreadPriority", "" + threadPriority);
     }
 
     public int getAcceptorThreadPriority() {
@@ -142,12 +141,10 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
 
     public void setSocketCloseDelay( int d ) {
         socketCloseDelay=d;
-        setAttribute("socketCloseDelay", "" + d);
     }
 
     public void setOomParachute(int oomParachute) {
         ((NioEndpoint)endpoint).setOomParachute(oomParachute);
-        setAttribute("oomParachute", Integer.valueOf(oomParachute));
     }
 
     // --------------------  SSL related properties --------------------
@@ -217,6 +214,10 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
             recycledProcessors.clear();
         }
         
+        public SSLImplementation getSslImplementation() {
+            return proto.sslImplementation;
+        }
+
         @Override
         public void release(SocketChannel socket) {
             if (log.isDebugEnabled()) 

==================================================
AbstractEndpoint.java
index 00a61cf44a..11b5a913ed 100644
--- a/java/org/apache/coyote/http11/Http11Protocol.java
+++ b/java/org/apache/coyote/http11/Http11Protocol.java
@@ -35,6 +35,7 @@ import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.JIoEndpoint;
 import org.apache.tomcat.util.net.JIoEndpoint.Handler;
+import org.apache.tomcat.util.net.SSLImplementation;
 import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapper;
 
@@ -142,6 +143,10 @@ public class Http11Protocol extends AbstractHttp11JsseProtocol {
             return global;
         }
 
+        public SSLImplementation getSslImplementation() {
+            return proto.sslImplementation;
+        }
+
         @Override
         public void recycle() {
             recycledProcessors.clear();

==================================================
DefaultServerSocketFactory.java
index 070ae7dc15..0744891333 100644
--- a/java/org/apache/tomcat/util/net/AbstractEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AbstractEndpoint.java
@@ -20,6 +20,8 @@ import java.io.File;
 import java.io.OutputStreamWriter;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.StringTokenizer;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
@@ -320,10 +322,44 @@ public abstract class AbstractEndpoint {
 
     protected abstract boolean getDeferAccept();
 
+
+    /**
+     * Attributes provide a way for configuration to be passed to sub-components
+     * without the {@link ProtocolHandler} being aware of the properties
+     * available on those sub-components. One example of such a sub-component is
+     * the {@link org.apache.tomcat.util.net.ServerSocketFactory}.
+     */
+    protected HashMap<String, Object> attributes =
+        new HashMap<String, Object>();
+    /** 
+     * Generic property setter called when a property for which a specific
+     * setter already exists within the {@link ProtocolHandler} needs to be
+     * made available to sub-components. The specific setter will call this
+     * method to populate the attributes.
+     */
+    public void setAttribute(String name, Object value) {
+        if (getLog().isTraceEnabled()) {
+            getLog().trace(sm.getString("abstractProtocolHandler.setAttribute",
+                    name, value));
+        }
+        attributes.put(name, value);
+    }
     /**
-     * Generic properties, introspected
+     * Used by sub-components to retrieve configuration information.
      */
+    public Object getAttribute(String key) {
+        Object value = attributes.get(key);
+        if (getLog().isTraceEnabled()) {
+            getLog().trace(sm.getString("abstractProtocolHandler.getAttribute",
+                    key, value));
+        }
+        return value;
+    }
+
+
+
     public boolean setProperty(String name, String value) {
+        setAttribute(name, value);
         final String socketName = "socket.";
         try {
             if (name.startsWith(socketName)) {
@@ -336,7 +372,10 @@ public abstract class AbstractEndpoint {
             return false;
         }
     }
-
+    public String getProperty(String name) {
+        return (String) getAttribute(name);
+    }
+    
     /**
      * Return the amount of threads that are managed by the pool.
      *
@@ -632,11 +671,24 @@ public abstract class AbstractEndpoint {
 
 
     private String[] sslEnabledProtocolsarr =  new String[0];
-    public String[] getSslEnabledProtocolsArray() { return this.sslEnabledProtocolsarr;}
+    public String[] getSslEnabledProtocolsArray() {
+        return this.sslEnabledProtocolsarr;
+    }
     public void setSslEnabledProtocols(String s) {
-        StringTokenizer t = new StringTokenizer(s,",");
-        sslEnabledProtocolsarr = new String[t.countTokens()];
-        for (int i=0; i<sslEnabledProtocolsarr.length; i++ ) sslEnabledProtocolsarr[i] = t.nextToken();
+        if (s == null) {
+            this.sslEnabledProtocolsarr = new String[0];
+        } else {
+            ArrayList<String> sslEnabledProtocols = new ArrayList<String>();
+            StringTokenizer t = new StringTokenizer(s,",");
+            while (t.hasMoreTokens()) {
+                String p = t.nextToken().trim();
+                if (p.length() > 0) {
+                    sslEnabledProtocols.add(p);
+                }
+            }
+            sslEnabledProtocolsarr = sslEnabledProtocols.toArray(
+                    new String[sslEnabledProtocols.size()]);
+        }
     }
 
 }

==================================================
JIoEndpoint.java
index 1b4c7f04c0..4ee222d73d 100644
--- a/java/org/apache/tomcat/util/net/DefaultServerSocketFactory.java
+++ b/java/org/apache/tomcat/util/net/DefaultServerSocketFactory.java
@@ -29,48 +29,38 @@ import java.net.Socket;
  * @author db@eng.sun.com
  * @author Harish Prabandham
  */
+public class DefaultServerSocketFactory implements ServerSocketFactory {
 
-// Default implementation of server sockets.
+    private AbstractEndpoint endpoint;
 
-//
-// WARNING: Some of the APIs in this class are used by J2EE. 
-// Please talk to harishp@eng.sun.com before making any changes.
-//
-class DefaultServerSocketFactory extends ServerSocketFactory {
-
-    DefaultServerSocketFactory () {
-        /* NOTHING */
+    public DefaultServerSocketFactory(AbstractEndpoint endpoint) {
+        this.endpoint = endpoint;
     }
 
     @Override
-    public ServerSocket createSocket (int port)
-    throws IOException {
+    public ServerSocket createSocket (int port) throws IOException {
         return  new ServerSocket (port);
     }
 
     @Override
     public ServerSocket createSocket (int port, int backlog)
-    throws IOException {
+            throws IOException {
         return new ServerSocket (port, backlog);
     }
 
     @Override
     public ServerSocket createSocket (int port, int backlog,
-        InetAddress ifAddress)
-    throws IOException {
+            InetAddress ifAddress) throws IOException {
         return new ServerSocket (port, backlog, ifAddress);
     }
- 
+
     @Override
-    public Socket acceptSocket(ServerSocket socket)
-            throws IOException {
+    public Socket acceptSocket(ServerSocket socket) throws IOException {
         return socket.accept();
     }
- 
+
     @Override
-    public void handshake(Socket sock)
-        throws IOException {
+    public void handshake(Socket sock) throws IOException {
         // NOOP
     }
-        
 }

==================================================
NioEndpoint.java
index 24c5e181f5..1ca3c923b0 100644
--- a/java/org/apache/tomcat/util/net/JIoEndpoint.java
+++ b/java/org/apache/tomcat/util/net/JIoEndpoint.java
@@ -119,7 +119,9 @@ public class JIoEndpoint extends AbstractEndpoint {
      */
     public interface Handler extends AbstractEndpoint.Handler {
         public SocketState process(SocketWrapper<Socket> socket);
-        public SocketState process(SocketWrapper<Socket> socket, SocketStatus status);
+        public SocketState process(SocketWrapper<Socket> socket,
+                SocketStatus status);
+        public SSLImplementation getSslImplementation(); 
     }
 
 
@@ -333,57 +335,22 @@ public class JIoEndpoint extends AbstractEndpoint {
             acceptorThreadCount = 1;
         }
         if (serverSocketFactory == null) {
-            serverSocketFactory = ServerSocketFactory.getDefault();
-        }
-        if (isSSLEnabled()) {
-            serverSocketFactory.setAttribute(SSL_ATTR_ALGORITHM,
-                    getAlgorithm());
-            serverSocketFactory.setAttribute(SSL_ATTR_CLIENT_AUTH,
-                    getClientAuth());
-            serverSocketFactory.setAttribute(SSL_ATTR_KEYSTORE_FILE,
-                    getKeystoreFile());
-            serverSocketFactory.setAttribute(SSL_ATTR_KEYSTORE_PASS,
-                    getKeystorePass());
-            serverSocketFactory.setAttribute(SSL_ATTR_KEYSTORE_TYPE,
-                    getKeystoreType());
-            serverSocketFactory.setAttribute(SSL_ATTR_KEYSTORE_PROVIDER,
-                    getKeystoreProvider());
-            serverSocketFactory.setAttribute(SSL_ATTR_SSL_PROTOCOL,
-                    getSslProtocol());
-            serverSocketFactory.setAttribute(SSL_ATTR_CIPHERS,
-                    getCiphers());
-            serverSocketFactory.setAttribute(SSL_ATTR_KEY_ALIAS,
-                    getKeyAlias());
-            serverSocketFactory.setAttribute(SSL_ATTR_KEY_PASS,
-                    getKeyPass());
-            serverSocketFactory.setAttribute(SSL_ATTR_TRUSTSTORE_FILE,
-                    getTruststoreFile());
-            serverSocketFactory.setAttribute(SSL_ATTR_TRUSTSTORE_PASS,
-                    getTruststorePass());
-            serverSocketFactory.setAttribute(SSL_ATTR_TRUSTSTORE_TYPE,
-                    getTruststoreType());
-            serverSocketFactory.setAttribute(SSL_ATTR_TRUSTSTORE_PROVIDER,
-                    getTruststoreProvider());
-            serverSocketFactory.setAttribute(SSL_ATTR_TRUSTSTORE_ALGORITHM,
-                    getTruststoreAlgorithm());
-            serverSocketFactory.setAttribute(SSL_ATTR_CRL_FILE,
-                    getCrlFile());
-            serverSocketFactory.setAttribute(SSL_ATTR_TRUST_MAX_CERT_LENGTH,
-                    getTrustMaxCertLength());
-            serverSocketFactory.setAttribute(SSL_ATTR_SESSION_CACHE_SIZE,
-                    getSessionCacheSize());
-            serverSocketFactory.setAttribute(SSL_ATTR_SESSION_TIMEOUT,
-                    getSessionTimeout());
-            serverSocketFactory.setAttribute(SSL_ATTR_ALLOW_UNSAFE_RENEG,
-                    getAllowUnsafeLegacyRenegotiation());
+            if (isSSLEnabled()) {
+                serverSocketFactory =
+                    handler.getSslImplementation().getServerSocketFactory(this);
+            } else {
+                serverSocketFactory = new DefaultServerSocketFactory(this);
+            }
         }
 
         if (serverSocket == null) {
             try {
                 if (getAddress() == null) {
-                    serverSocket = serverSocketFactory.createSocket(getPort(), getBacklog());
+                    serverSocket = serverSocketFactory.createSocket(getPort(),
+                            getBacklog());
                 } else {
-                    serverSocket = serverSocketFactory.createSocket(getPort(), getBacklog(), getAddress());
+                    serverSocket = serverSocketFactory.createSocket(getPort(),
+                            getBacklog(), getAddress());
                 }
             } catch (BindException orig) {
                 String msg;
@@ -397,11 +364,8 @@ public class JIoEndpoint extends AbstractEndpoint {
                 throw be;
             }
         }
-        //if( serverTimeout >= 0 )
-        //    serverSocket.setSoTimeout( serverTimeout );
         
         initialized = true;
-        
     }
     
     @Override
@@ -475,8 +439,6 @@ public class JIoEndpoint extends AbstractEndpoint {
      * Configure the socket.
      */
     protected boolean setSocketOptions(Socket socket) {
-        serverSocketFactory.initSocket(socket);
-        
         try {
             // 1: Set socket options: timeout, linger, etc
             socketProperties.setProperties(socket);

==================================================
SSLImplementation.java
index 2df3759a84..11d557ae87 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -1500,6 +1500,7 @@ public class NioEndpoint extends AbstractEndpoint {
         public SocketState event(NioChannel socket, SocketStatus status);
         public void release(NioChannel socket);
         public void release(SocketChannel socket);
+        public SSLImplementation getSslImplementation();
     }
 
 

==================================================
ServerSocketFactory.java
index f9a6613314..a194af9a76 100644
--- a/java/org/apache/tomcat/util/net/SSLImplementation.java
+++ b/java/org/apache/tomcat/util/net/SSLImplementation.java
@@ -80,7 +80,8 @@ public abstract class SSLImplementation {
 
     public abstract String getImplementationName();
 
-    public abstract ServerSocketFactory getServerSocketFactory();
+    public abstract ServerSocketFactory getServerSocketFactory(
+            AbstractEndpoint endpoint);
 
     public abstract SSLSupport getSSLSupport(Socket sock);
 

==================================================
JSSEFactory.java
index d87223cd3c..5d77925558 100644
--- a/java/org/apache/tomcat/util/net/ServerSocketFactory.java
+++ b/java/org/apache/tomcat/util/net/ServerSocketFactory.java
@@ -14,91 +14,18 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.tomcat.util.net;
 
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
-import java.util.Hashtable;
 
 /**
- * This class creates server sockets. It may be subclassed by other factories,
- * which create particular types of server sockets. This provides a general
- * framework for the addition of public socket-level functionality. It it is the
- * server side analogue of a socket factory, and similarly provides a way to
- * capture a variety of policies related to the sockets being constructed.
- * <P>
- * Like socket factories, Server Socket factory instances have two categories of
- * methods. First are methods used to create sockets. Second are methods which
- * set properties used in the production of sockets, such as networking options.
- * There is also an environment specific default server socket factory;
- * frameworks will often use their own customized factory.
- * <P>
- * <hr>
- * <em> It may be desirable to move this interface into the
- * <b>java.net</b> package, so that is not an extension but the preferred
- * interface.  Should this be serializable, making it a JavaBean which can
- * be saved along with its networking configuration?
- * </em>
- * 
- * @author db@eng.sun.com
- * @author Harish Prabandham
+ * The common interface through which the {@link JIoEndpoint} interacts with
+ * both non-SSL and SSL sockets. 
  */
-public abstract class ServerSocketFactory implements Cloneable {
-
-    //
-    // NOTE: JDK 1.1 bug in class GC, this can get collected
-    // even though it's always accessible via getDefault().
-    //
-
-    private static ServerSocketFactory theFactory;
-    protected Hashtable<String, Object> attributes = new Hashtable<String, Object>();
-
-    /**
-     * Constructor is used only by subclasses.
-     */
-    protected ServerSocketFactory() {
-        /* NOTHING */
-    }
-
-    /**
-     * General mechanism to pass attributes from the ServerConnector to the
-     * socket factory. Note that the "preferred" mechanism is to use bean
-     * setters and explicit methods, but this allows easy configuration via
-     * server.xml or simple Properties
-     */
-    public void setAttribute(String name, Object value) {
-        if (name != null && value != null)
-            attributes.put(name, value);
-    }
-
-    /**
-     * Returns a copy of the environment's default socket factory.
-     */
-    public static synchronized ServerSocketFactory getDefault() {
-        //
-        // optimize typical case: no synch needed
-        //
-
-        if (theFactory == null) {
-            //
-            // Different implementations of this method could
-            // work rather differently. For example, driving
-            // this from a system property, or using a different
-            // implementation than JavaSoft's.
-            //
-
-            theFactory = new DefaultServerSocketFactory();
-        }
-
-        try {
-            return (ServerSocketFactory) theFactory.clone();
-        } catch (CloneNotSupportedException e) {
-            throw new RuntimeException(e.getMessage());
-        }
-    }
+public interface ServerSocketFactory {
 
     /**
      * Returns a server socket which uses all network interfaces on the host,
@@ -112,7 +39,7 @@ public abstract class ServerSocketFactory implements Cloneable {
      * @exception InstantiationException
      *                for construction errors
      */
-    public abstract ServerSocket createSocket(int port) throws IOException,
+    ServerSocket createSocket(int port) throws IOException,
             InstantiationException;
 
     /**
@@ -130,8 +57,8 @@ public abstract class ServerSocketFactory implements Cloneable {
      * @exception InstantiationException
      *                for construction errors
      */
-    public abstract ServerSocket createSocket(int port, int backlog)
-            throws IOException, InstantiationException;
+    ServerSocket createSocket(int port, int backlog) throws IOException,
+            InstantiationException;
 
     /**
      * Returns a server socket which uses only the specified network interface
@@ -150,26 +77,21 @@ public abstract class ServerSocketFactory implements Cloneable {
      * @exception InstantiationException
      *                for construction errors
      */
-    public abstract ServerSocket createSocket(int port, int backlog,
-            InetAddress ifAddress) throws IOException, InstantiationException;
-
-    public void initSocket(Socket s) {
-    }
+    ServerSocket createSocket(int port, int backlog, InetAddress ifAddress)
+            throws IOException, InstantiationException;
 
     /**
      * Wrapper function for accept(). This allows us to trap and translate
-     * exceptions if necessary
+     * exceptions if necessary.
      * 
      * @exception IOException
-     *                ;
      */
-    public abstract Socket acceptSocket(ServerSocket socket) throws IOException;
+    Socket acceptSocket(ServerSocket socket) throws IOException;
 
     /**
-     * Extra function to initiate the handshake. Sometimes necessary for SSL
+     * Triggers the SSL handshake. This will be a no-op for non-SSL sockets.
      * 
      * @exception IOException
-     *                ;
      */
-    public abstract void handshake(Socket sock) throws IOException;
+    void handshake(Socket sock) throws IOException;
 }

==================================================
JSSEImplementation.java
index 7745748467..dcb0354d9a 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSEFactory.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSEFactory.java
@@ -22,6 +22,7 @@ import java.net.Socket;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocket;
 
+import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.ServerSocketFactory;
 
@@ -38,8 +39,8 @@ public class JSSEFactory {
     /**
      * Returns the ServerSocketFactory to use.
      */
-    public ServerSocketFactory getSocketFactory() {
-        return new JSSESocketFactory();
+    public ServerSocketFactory getSocketFactory(AbstractEndpoint endpoint) {
+        return new JSSESocketFactory(endpoint);
     }
 
     /**

==================================================
JSSESocketFactory.java
index 45d3e0df62..671423d2ed 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java
@@ -21,6 +21,7 @@ import java.net.Socket;
 
 import javax.net.ssl.SSLSession;
 
+import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.SSLImplementation;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.ServerSocketFactory;
@@ -47,8 +48,8 @@ public class JSSEImplementation extends SSLImplementation {
     }
       
     @Override
-    public ServerSocketFactory getServerSocketFactory()  {
-        ServerSocketFactory ssf = factory.getSocketFactory();
+    public ServerSocketFactory getServerSocketFactory(AbstractEndpoint endpoint)  {
+        ServerSocketFactory ssf = factory.getSocketFactory(endpoint);
         return ssf;
     } 
 

==================================================
