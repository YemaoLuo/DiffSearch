e424fabd6c3c771c6ece1d712cb86d9de0e1d7a7
==================================================
Remove info and getInfo() from the Valves
==================================================
Mark Emlyn
==================================================
Sat Oct 22 19:25:55 2011 +0000
==================================================
Valve.java
Remove info and getInfo() from the Valves
Also includes automatic clean-up - mainly whitespace

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1187756 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AuthenticatorBase.java
index be4e1e773a..5ee4ffb32f 100644
--- a/java/org/apache/catalina/Valve.java
+++ b/java/org/apache/catalina/Valve.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -49,13 +49,6 @@ public interface Valve {
 
     //-------------------------------------------------------------- Properties
 
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    public String getInfo();
-
-
     /**
      * Return the next Valve in the pipeline containing this Valve, if any.
      */
@@ -131,7 +124,7 @@ public interface Valve {
     public void invoke(Request request, Response response)
         throws IOException, ServletException;
 
-    
+
     /**
      * Process a Comet event.
      *
@@ -146,8 +139,8 @@ public interface Valve {
     public void event(Request request, Response response, CometEvent event)
         throws IOException, ServletException;
 
-    
+
     public boolean isAsyncSupported();
-    
+
 
 }

==================================================
BasicAuthenticator.java
index 0eac4be44a..7e27178aae 100644
--- a/java/org/apache/catalina/authenticator/AuthenticatorBase.java
+++ b/java/org/apache/catalina/authenticator/AuthenticatorBase.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -71,8 +71,6 @@ import org.apache.tomcat.util.res.StringManager;
  * @author Craig R. McClanahan
  * @version $Id$
  */
-
-
 public abstract class AuthenticatorBase extends ValveBase
         implements Authenticator {
 
@@ -105,7 +103,7 @@ public abstract class AuthenticatorBase extends ValveBase
      * for combinations such as BASIC authentication used with the JNDIRealm or
      * DataSourceRealms. However there will also be the performance cost of
      * creating and GC'ing the session. By default, a session will not be
-     * created. 
+     * created.
      */
     protected boolean alwaysUseSession = false;
 
@@ -122,19 +120,13 @@ public abstract class AuthenticatorBase extends ValveBase
      * authentication to prevent a session fixation attack?
      */
     protected boolean changeSessionIdOnAuthentication = true;
-    
+
     /**
      * The Context to which this Valve is attached.
      */
     protected Context context = null;
 
 
-    /**
-     * Descriptive information about this implementation.
-     */
-    protected static final String info =
-        "org.apache.catalina.authenticator.AuthenticatorBase/1.0";
-
     /**
      * Flag to determine if we disable proxy caching, or leave the issue
      * up to the webapp developer.
@@ -146,7 +138,7 @@ public abstract class AuthenticatorBase extends ValveBase
      * with IE.
      */
     protected boolean securePagesWithPragma = false;
-    
+
     /**
      * The Java class name of the secure random number generator class to be
      * used when generating SSO session identifiers. The random number generator
@@ -255,9 +247,10 @@ public abstract class AuthenticatorBase extends ValveBase
     @Override
     public void setContainer(Container container) {
 
-        if (container != null && !(container instanceof Context))
+        if (container != null && !(container instanceof Context)) {
             throw new IllegalArgumentException
                 (sm.getString("authenticator.notContext"));
+        }
 
         super.setContainer(container);
         this.context = (Context) container;
@@ -265,17 +258,6 @@ public abstract class AuthenticatorBase extends ValveBase
     }
 
 
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-
     /**
      * Return the flag that states if we add headers to disable caching by
      * proxies.
@@ -287,13 +269,13 @@ public abstract class AuthenticatorBase extends ValveBase
     /**
      * Set the value of the flag that states if we add headers to disable
      * caching by proxies.
-     * @param nocache <code>true</code> if we add headers to disable proxy 
+     * @param nocache <code>true</code> if we add headers to disable proxy
      *              caching, <code>false</code> if we leave the headers alone.
      */
     public void setDisableProxyCaching(boolean nocache) {
         disableProxyCaching = nocache;
     }
-    
+
     /**
      * Return the flag that states, if proxy caching is disabled, what headers
      * we add to disable the caching.
@@ -305,18 +287,18 @@ public abstract class AuthenticatorBase extends ValveBase
     /**
      * Set the value of the flag that states what headers we add to disable
      * proxy caching.
-     * @param securePagesWithPragma <code>true</code> if we add headers which 
+     * @param securePagesWithPragma <code>true</code> if we add headers which
      * are incompatible with downloading office documents in IE under SSL but
      * which fix a caching problem in Mozilla.
      */
     public void setSecurePagesWithPragma(boolean securePagesWithPragma) {
         this.securePagesWithPragma = securePagesWithPragma;
-    }    
+    }
 
     /**
      * Return the flag that states if we should change the session ID of an
      * existing session upon successful authentication.
-     * 
+     *
      * @return <code>true</code> to change session ID upon successful
      *         authentication, <code>false</code> to do not perform the change.
      */
@@ -327,7 +309,7 @@ public abstract class AuthenticatorBase extends ValveBase
     /**
      * Set the value of the flag that states if we should change the session ID
      * of an existing session upon successful authentication.
-     * 
+     *
      * @param changeSessionIdOnAuthentication
      *            <code>true</code> to change session ID upon successful
      *            authentication, <code>false</code> to do not perform the
@@ -415,9 +397,10 @@ public abstract class AuthenticatorBase extends ValveBase
     public void invoke(Request request, Response response)
         throws IOException, ServletException {
 
-        if (log.isDebugEnabled())
+        if (log.isDebugEnabled()) {
             log.debug("Security checking request " +
                 request.getMethod() + " " + request.getRequestURI());
+        }
         LoginConfig config = this.context.getLoginConfig();
 
         // Have we got a cached authenticated Principal to record?
@@ -428,11 +411,12 @@ public abstract class AuthenticatorBase extends ValveBase
                 if (session != null) {
                     principal = session.getPrincipal();
                     if (principal != null) {
-                        if (log.isDebugEnabled())
+                        if (log.isDebugEnabled()) {
                             log.debug("We have cached auth type " +
                                 session.getAuthType() +
                                 " for principal " +
                                 session.getPrincipal());
+                        }
                         request.setAuthType(session.getAuthType());
                         request.setUserPrincipal(principal);
                     }
@@ -448,8 +432,9 @@ public abstract class AuthenticatorBase extends ValveBase
         if (requestURI.startsWith(contextPath) &&
             requestURI.endsWith(Constants.FORM_ACTION)) {
             if (!authenticate(request, response, config)) {
-                if (log.isDebugEnabled())
+                if (log.isDebugEnabled()) {
                     log.debug(" Failed authenticate() test ??" + requestURI );
+                }
                 return;
             }
         }
@@ -465,17 +450,18 @@ public abstract class AuthenticatorBase extends ValveBase
         // Is this request URI subject to a security constraint?
         SecurityConstraint [] constraints
             = realm.findSecurityConstraints(request, this.context);
-       
+
         if (constraints == null && !context.getPreemptiveAuthentication()) {
-            if (log.isDebugEnabled())
+            if (log.isDebugEnabled()) {
                 log.debug(" Not subject to any constraint");
+            }
             getNext().invoke(request, response);
             return;
         }
 
         // Make sure that constrained resources are not cached by web proxies
         // or browsers as caching can provide a security hole
-        if (constraints != null && disableProxyCaching && 
+        if (constraints != null && disableProxyCaching &&
             !"POST".equalsIgnoreCase(request.getMethod())) {
             if (securePagesWithPragma) {
                 // Note: These can cause problems with downloading files with IE
@@ -537,7 +523,7 @@ public abstract class AuthenticatorBase extends ValveBase
             authRequired = certs != null && certs.length > 0;
         }
 
-        if(authRequired) {  
+        if(authRequired) {
             if (log.isDebugEnabled()) {
                 log.debug(" Calling authenticate()");
             }
@@ -551,10 +537,10 @@ public abstract class AuthenticatorBase extends ValveBase
                  * special
                  */
                 return;
-            } 
-            
+            }
+
         }
-    
+
         if (constraints != null) {
             if (log.isDebugEnabled()) {
                 log.debug(" Calling accessControl()");
@@ -573,7 +559,7 @@ public abstract class AuthenticatorBase extends ValveBase
                 return;
             }
         }
-    
+
         // Any and all specified constraints have been satisfied
         if (log.isDebugEnabled()) {
             log.debug(" Successfully passed all security constraints");
@@ -595,8 +581,9 @@ public abstract class AuthenticatorBase extends ValveBase
      */
     protected void associate(String ssoId, Session session) {
 
-        if (sso == null)
+        if (sso == null) {
             return;
+        }
         sso.associate(ssoId, session);
 
     }
@@ -632,8 +619,9 @@ public abstract class AuthenticatorBase extends ValveBase
      */
     protected boolean reauthenticateFromSSO(String ssoId, Request request) {
 
-        if (sso == null || ssoId == null)
+        if (sso == null || ssoId == null) {
             return false;
+        }
 
         boolean reauthenticated = false;
 
@@ -677,7 +665,7 @@ public abstract class AuthenticatorBase extends ValveBase
                             String username, String password) {
 
         if (log.isDebugEnabled()) {
-            String name = (principal == null) ? "none" : principal.getName(); 
+            String name = (principal == null) ? "none" : principal.getName();
             log.debug("Authenticated '" + name + "' with type '" + authType +
                     "'");
         }
@@ -687,7 +675,7 @@ public abstract class AuthenticatorBase extends ValveBase
         request.setUserPrincipal(principal);
 
         Session session = request.getSessionInternal(false);
-        
+
         if (session != null) {
             if (changeSessionIdOnAuthentication) {
                 Manager manager = request.getContext().getManager();
@@ -703,20 +691,23 @@ public abstract class AuthenticatorBase extends ValveBase
             if (session != null) {
                 session.setAuthType(authType);
                 session.setPrincipal(principal);
-                if (username != null)
+                if (username != null) {
                     session.setNote(Constants.SESS_USERNAME_NOTE, username);
-                else
+                } else {
                     session.removeNote(Constants.SESS_USERNAME_NOTE);
-                if (password != null)
+                }
+                if (password != null) {
                     session.setNote(Constants.SESS_PASSWORD_NOTE, password);
-                else
+                } else {
                     session.removeNote(Constants.SESS_PASSWORD_NOTE);
+                }
             }
         }
 
         // Construct a cookie to be returned to the client
-        if (sso == null)
+        if (sso == null) {
             return;
+        }
 
         // Only create a new SSO entry if the SSO did not already set a note
         // for an existing entry (as it would do with subsequent requests
@@ -728,7 +719,7 @@ public abstract class AuthenticatorBase extends ValveBase
             Cookie cookie = new Cookie(Constants.SINGLE_SIGN_ON_COOKIE, ssoId);
             cookie.setMaxAge(-1);
             cookie.setPath("/");
-            
+
             // Bugzilla 41217
             cookie.setSecure(request.isSecure());
 
@@ -743,7 +734,7 @@ public abstract class AuthenticatorBase extends ValveBase
                     request.getContext().getUseHttpOnly()) {
                 cookie.setHttpOnly(true);
             }
-            
+
             response.addCookie(cookie);
 
             // Register this principal with our SSO valve
@@ -767,8 +758,9 @@ public abstract class AuthenticatorBase extends ValveBase
         // associated sessions are destroyed; if a new SSO entry is created
         // above for this request and the user never revisits the context, the
         // SSO entry will never be cleared if we don't associate the session
-        if (session == null)
+        if (session == null) {
             session = request.getSessionInternal(true);
+        }
         sso.associate(ssoId, session);
 
     }
@@ -785,7 +777,7 @@ public abstract class AuthenticatorBase extends ValveBase
 
     /**
      * Process the login request.
-     * 
+     *
      * @param request   Associated request
      * @param username  The user
      * @param password  The password
@@ -817,7 +809,7 @@ public abstract class AuthenticatorBase extends ValveBase
      */
     @Override
     protected synchronized void startInternal() throws LifecycleException {
-        
+
         // Look up the SingleSignOn implementation in our request processing
         // path, if there is one
         Container parent = context.getParent();
@@ -829,14 +821,16 @@ public abstract class AuthenticatorBase extends ValveBase
                     break;
                 }
             }
-            if (sso == null)
+            if (sso == null) {
                 parent = parent.getParent();
+            }
         }
         if (log.isDebugEnabled()) {
-            if (sso != null)
+            if (sso != null) {
                 log.debug("Found SingleSignOn Valve at " + sso);
-            else
+            } else {
                 log.debug("No SingleSignOn Valve is present");
+            }
         }
 
         sessionIdGenerator = new SessionIdGenerator();

==================================================
DigestAuthenticator.java
index cbbab8a52d..e8927fd745 100644
--- a/java/org/apache/catalina/authenticator/BasicAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/BasicAuthenticator.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -48,33 +48,9 @@ public class BasicAuthenticator
     extends AuthenticatorBase {
     private static final Log log = LogFactory.getLog(BasicAuthenticator.class);
 
-   // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * Descriptive information about this implementation.
-     */
-    protected static final String info =
-        "org.apache.catalina.authenticator.BasicAuthenticator/1.0";
-
-
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
-
 
     // --------------------------------------------------------- Public Methods
 
-
     /**
      * Authenticate the user making this request, based on the specified
      * login configuration.  Return <code>true</code> if any specified
@@ -98,37 +74,41 @@ public class BasicAuthenticator
         Principal principal = request.getUserPrincipal();
         String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);
         if (principal != null) {
-            if (log.isDebugEnabled())
+            if (log.isDebugEnabled()) {
                 log.debug("Already authenticated '" + principal.getName() + "'");
+            }
             // Associate the session with any existing SSO session
-            if (ssoId != null)
+            if (ssoId != null) {
                 associate(ssoId, request.getSessionInternal(true));
+            }
             return (true);
         }
 
         // Is there an SSO session against which we can try to reauthenticate?
         if (ssoId != null) {
-            if (log.isDebugEnabled())
+            if (log.isDebugEnabled()) {
                 log.debug("SSO Id " + ssoId + " set; attempting " +
                           "reauthentication");
+            }
             /* Try to reauthenticate using data cached by SSO.  If this fails,
                either the original SSO logon was of DIGEST or SSL (which
                we can't reauthenticate ourselves because there is no
                cached username and password), or the realm denied
                the user's reauthentication for some reason.
                In either case we have to prompt the user for a logon */
-            if (reauthenticateFromSSO(ssoId, request))
+            if (reauthenticateFromSSO(ssoId, request)) {
                 return true;
+            }
         }
 
         // Validate any credentials already included with this request
         String username = null;
         String password = null;
 
-        MessageBytes authorization = 
+        MessageBytes authorization =
             request.getCoyoteRequest().getMimeHeaders()
             .getValue("authorization");
-        
+
         if (authorization != null) {
             authorization.toBytes();
             ByteChunk authorizationBC = authorization.getByteChunk();
@@ -136,10 +116,10 @@ public class BasicAuthenticator
                 authorizationBC.setOffset(authorizationBC.getOffset() + 6);
                 // FIXME: Add trimming
                 // authorizationBC.trim();
-                
+
                 CharChunk authorizationCC = authorization.getCharChunk();
                 Base64.decode(authorizationBC, authorizationCC);
-                
+
                 // Get username and password
                 int colon = authorizationCC.indexOf(':');
                 if (colon < 0) {
@@ -147,10 +127,10 @@ public class BasicAuthenticator
                 } else {
                     char[] buf = authorizationCC.getBuffer();
                     username = new String(buf, 0, colon);
-                    password = new String(buf, colon + 1, 
+                    password = new String(buf, colon + 1,
                             authorizationCC.getEnd() - colon - 1);
                 }
-                
+
                 authorizationBC.setOffset(authorizationBC.getOffset() - 6);
             }
 
@@ -161,7 +141,7 @@ public class BasicAuthenticator
                 return (true);
             }
         }
-        
+
         StringBuilder value = new StringBuilder(16);
         value.append("Basic realm=\"");
         if (config.getRealmName() == null) {
@@ -169,7 +149,7 @@ public class BasicAuthenticator
         } else {
             value.append(config.getRealmName());
         }
-        value.append('\"');        
+        value.append('\"');
         response.setHeader(AUTH_HEADER_NAME, value.toString());
         response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
         return (false);

==================================================
FormAuthenticator.java
index d287b12dea..7cfcb81136 100644
--- a/java/org/apache/catalina/authenticator/DigestAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/DigestAuthenticator.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -63,13 +63,6 @@ public class DigestAuthenticator extends AuthenticatorBase {
     protected static final MD5Encoder md5Encoder = new MD5Encoder();
 
 
-    /**
-     * Descriptive information about this implementation.
-     */
-    protected static final String info =
-        "org.apache.catalina.authenticator.DigestAuthenticator/1.0";
-
-
     /**
      * Tomcat's DIGEST implementation only supports auth quality of protection.
      */
@@ -81,8 +74,9 @@ public class DigestAuthenticator extends AuthenticatorBase {
     public DigestAuthenticator() {
         super();
         try {
-            if (md5Helper == null)
+            if (md5Helper == null) {
                 md5Helper = MessageDigest.getInstance("MD5");
+            }
         } catch (NoSuchAlgorithmException e) {
             e.printStackTrace();
             throw new IllegalStateException();
@@ -139,17 +133,6 @@ public class DigestAuthenticator extends AuthenticatorBase {
 
     // ------------------------------------------------------------- Properties
 
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-
     public int getCnonceCacheSize() {
         return cnonceCacheSize;
     }
@@ -225,13 +208,15 @@ public class DigestAuthenticator extends AuthenticatorBase {
         Principal principal = request.getUserPrincipal();
         //String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);
         if (principal != null) {
-            if (log.isDebugEnabled())
+            if (log.isDebugEnabled()) {
                 log.debug("Already authenticated '" + principal.getName() + "'");
+            }
             // Associate the session with any existing SSO session in order
             // to get coordinated session invalidation at logout
             String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);
-            if (ssoId != null)
+            if (ssoId != null) {
                 associate(ssoId, request.getSessionInternal(true));
+            }
             return (true);
         }
 
@@ -268,7 +253,7 @@ public class DigestAuthenticator extends AuthenticatorBase {
             if (digestInfo.validate(request, authorization, config)) {
                 principal = digestInfo.authenticate(context.getRealm());
             }
-            
+
             if (principal != null) {
                 String username = parseUsername(authorization);
                 register(request, response, principal,
@@ -311,10 +296,12 @@ public class DigestAuthenticator extends AuthenticatorBase {
     protected String parseUsername(String authorization) {
 
         // Validate the authorization credentials format
-        if (authorization == null)
+        if (authorization == null) {
             return (null);
-        if (!authorization.startsWith("Digest "))
+        }
+        if (!authorization.startsWith("Digest ")) {
             return (null);
+        }
         authorization = authorization.substring(7).trim();
 
         StringTokenizer commaTokenizer =
@@ -323,14 +310,16 @@ public class DigestAuthenticator extends AuthenticatorBase {
         while (commaTokenizer.hasMoreTokens()) {
             String currentToken = commaTokenizer.nextToken();
             int equalSign = currentToken.indexOf('=');
-            if (equalSign < 0)
+            if (equalSign < 0) {
                 return null;
+            }
             String currentTokenName =
                 currentToken.substring(0, equalSign).trim();
             String currentTokenValue =
                 currentToken.substring(equalSign + 1).trim();
-            if ("username".equals(currentTokenName))
+            if ("username".equals(currentTokenName)) {
                 return (removeQuotes(currentTokenValue));
+            }
         }
 
         return (null);
@@ -373,7 +362,7 @@ public class DigestAuthenticator extends AuthenticatorBase {
 
         long currentTime = System.currentTimeMillis();
 
-        
+
         String ipTimeKey =
             request.getRemoteAddr() + ":" + currentTime + ":" + getKey();
 
@@ -422,8 +411,9 @@ public class DigestAuthenticator extends AuthenticatorBase {
 
         // Get the realm name
         String realmName = config.getRealmName();
-        if (realmName == null)
+        if (realmName == null) {
             realmName = REALM_NAME;
+        }
 
         String authenticateHeader;
         if (isNonceStale) {
@@ -442,21 +432,21 @@ public class DigestAuthenticator extends AuthenticatorBase {
 
 
     // ------------------------------------------------------- Lifecycle Methods
-    
+
     @Override
     protected synchronized void startInternal() throws LifecycleException {
         super.startInternal();
-        
+
         // Generate a random secret key
         if (getKey() == null) {
             setKey(sessionIdGenerator.generateSessionId());
         }
-        
+
         // Generate the opaque string the same way
         if (getOpaque() == null) {
             setOpaque(sessionIdGenerator.generateSessionId());
         }
-        
+
         cnonces = new LinkedHashMap<String, DigestAuthenticator.NonceInfo>() {
 
             private static final long serialVersionUID = 1L;
@@ -484,13 +474,13 @@ public class DigestAuthenticator extends AuthenticatorBase {
             }
         };
     }
- 
+
     private static class DigestInfo {
 
-        private String opaque;
-        private long nonceValidity;
-        private String key;
-        private Map<String,NonceInfo> cnonces;
+        private final String opaque;
+        private final long nonceValidity;
+        private final String key;
+        private final Map<String,NonceInfo> cnonces;
         private boolean validateUri = true;
 
         private String userName = null;
@@ -534,8 +524,9 @@ public class DigestAuthenticator extends AuthenticatorBase {
 
             for (int i = 0; i < tokens.length; i++) {
                 String currentToken = tokens[i];
-                if (currentToken.length() == 0)
+                if (currentToken.length() == 0) {
                     continue;
+                }
 
                 int equalSign = currentToken.indexOf('=');
                 if (equalSign < 0) {
@@ -545,24 +536,33 @@ public class DigestAuthenticator extends AuthenticatorBase {
                     currentToken.substring(0, equalSign).trim();
                 String currentTokenValue =
                     currentToken.substring(equalSign + 1).trim();
-                if ("username".equals(currentTokenName))
+                if ("username".equals(currentTokenName)) {
                     userName = removeQuotes(currentTokenValue);
-                if ("realm".equals(currentTokenName))
+                }
+                if ("realm".equals(currentTokenName)) {
                     realmName = removeQuotes(currentTokenValue, true);
-                if ("nonce".equals(currentTokenName))
+                }
+                if ("nonce".equals(currentTokenName)) {
                     nonce = removeQuotes(currentTokenValue);
-                if ("nc".equals(currentTokenName))
+                }
+                if ("nc".equals(currentTokenName)) {
                     nc = removeQuotes(currentTokenValue);
-                if ("cnonce".equals(currentTokenName))
+                }
+                if ("cnonce".equals(currentTokenName)) {
                     cnonce = removeQuotes(currentTokenValue);
-                if ("qop".equals(currentTokenName))
+                }
+                if ("qop".equals(currentTokenName)) {
                     qop = removeQuotes(currentTokenValue);
-                if ("uri".equals(currentTokenName))
+                }
+                if ("uri".equals(currentTokenName)) {
                     uri = removeQuotes(currentTokenValue);
-                if ("response".equals(currentTokenName))
+                }
+                if ("response".equals(currentTokenName)) {
                     response = removeQuotes(currentTokenValue);
-                if ("opaque".equals(currentTokenName))
+                }
+                if ("opaque".equals(currentTokenName)) {
                     opaque = removeQuotes(currentTokenValue);
+                }
             }
 
             if ( (userName == null) || (realmName == null) || (nonce == null)
@@ -592,7 +592,7 @@ public class DigestAuthenticator extends AuthenticatorBase {
             if (!lcRealm.equals(realmName)) {
                 return false;
             }
-            
+
             // Validate the opaque string
             if (!this.opaque.equals(opaque)) {
                 return false;
@@ -695,19 +695,19 @@ public class DigestAuthenticator extends AuthenticatorBase {
     private static class NonceInfo {
         private volatile long count;
         private volatile long timestamp;
-        
+
         public void setCount(long l) {
             count = l;
         }
-        
+
         public long getCount() {
             return count;
         }
-        
+
         public void setTimestamp(long l) {
             timestamp = l;
         }
-        
+
         public long getTimestamp() {
             return timestamp;
         }

==================================================
NonLoginAuthenticator.java
index 8da3fd0458..92d9c37cbe 100644
--- a/java/org/apache/catalina/authenticator/FormAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/FormAuthenticator.java
@@ -58,14 +58,8 @@ public class FormAuthenticator
 
     private static final Log log = LogFactory.getLog(FormAuthenticator.class);
 
-    // ----------------------------------------------------- Instance Variables
-
 
-    /**
-     * Descriptive information about this implementation.
-     */
-    protected static final String info =
-        "org.apache.catalina.authenticator.FormAuthenticator/1.0";
+    // ----------------------------------------------------- Instance Variables
 
     /**
      * Character encoding to use to read the username and password parameters
@@ -81,19 +75,8 @@ public class FormAuthenticator
      */
     protected String landingPage = null;
 
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
 
+    // ------------------------------------------------------------- Properties
 
     /**
      * Return the character encoding to use to read the username and password.

==================================================
SSLAuthenticator.java
index 0c29e88c56..61ea4bc1d8 100644
--- a/java/org/apache/catalina/authenticator/NonLoginAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/NonLoginAuthenticator.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.authenticator;
 
 
@@ -35,33 +33,7 @@ import org.apache.catalina.deploy.LoginConfig;
  * @author Craig R. McClanahan
  * @version $Id$
  */
-
-public final class NonLoginAuthenticator
-    extends AuthenticatorBase {
-
-
-    // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * Descriptive information about this implementation.
-     */
-    private static final String info =
-        "org.apache.catalina.authenticator.NonLoginAuthenticator/1.0";
-
-
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
+public final class NonLoginAuthenticator extends AuthenticatorBase {
 
 
     // --------------------------------------------------------- Public Methods
@@ -94,9 +66,10 @@ public final class NonLoginAuthenticator
         if (ssoId != null)
             associate(ssoId, getSession(request, true));
         */
-        
-        if (containerLog.isDebugEnabled())
+
+        if (containerLog.isDebugEnabled()) {
             containerLog.debug("User authentication is not required");
+        }
         return (true);
 
 

==================================================
SingleSignOn.java
index 988f248362..b4930ad746 100644
--- a/java/org/apache/catalina/authenticator/SSLAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/SSLAuthenticator.java
@@ -5,20 +5,17 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.authenticator;
 
-
 import java.io.IOException;
 import java.security.Principal;
 import java.security.cert.X509Certificate;
@@ -30,8 +27,6 @@ import org.apache.catalina.connector.Request;
 import org.apache.catalina.deploy.LoginConfig;
 import org.apache.coyote.ActionCode;
 
-
-
 /**
  * An <b>Authenticator</b> and <b>Valve</b> implementation of authentication
  * that utilizes SSL certificates to identify client users.
@@ -39,35 +34,10 @@ import org.apache.coyote.ActionCode;
  * @author Craig R. McClanahan
  * @version $Id$
  */
-
-public class SSLAuthenticator
-    extends AuthenticatorBase {
-
-
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * Descriptive information about this implementation.
-     */
-    protected static final String info =
-        "org.apache.catalina.authenticator.SSLAuthenticator/1.0";
-
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
-
+public class SSLAuthenticator extends AuthenticatorBase {
 
     // --------------------------------------------------------- Public Methods
 
-
     /**
      * Authenticate the user by checking for the existence of a certificate
      * chain, validating it against the trust manager for the connector and then
@@ -90,13 +60,15 @@ public class SSLAuthenticator
         Principal principal = request.getUserPrincipal();
         //String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);
         if (principal != null) {
-            if (containerLog.isDebugEnabled())
+            if (containerLog.isDebugEnabled()) {
                 containerLog.debug("Already authenticated '" + principal.getName() + "'");
+            }
             // Associate the session with any existing SSO session in order
             // to get coordinated session invalidation at logout
             String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);
-            if (ssoId != null)
+            if (ssoId != null) {
                 associate(ssoId, request.getSessionInternal(true));
+            }
             return (true);
         }
 
@@ -126,8 +98,9 @@ public class SSLAuthenticator
         */
 
         // Retrieve the certificate chain for this client
-        if (containerLog.isDebugEnabled())
+        if (containerLog.isDebugEnabled()) {
             containerLog.debug(" Looking up certificates");
+        }
 
         X509Certificate certs[] = (X509Certificate[])
             request.getAttribute(Globals.CERTIFICATES_ATTR);
@@ -145,8 +118,9 @@ public class SSLAuthenticator
                 request.getAttribute(Globals.CERTIFICATES_ATTR);
         }
         if ((certs == null) || (certs.length < 1)) {
-            if (containerLog.isDebugEnabled())
+            if (containerLog.isDebugEnabled()) {
                 containerLog.debug("  No certificates included with this request");
+            }
             response.sendError(HttpServletResponse.SC_UNAUTHORIZED,
                                sm.getString("authenticator.certificates"));
             return (false);
@@ -155,8 +129,9 @@ public class SSLAuthenticator
         // Authenticate the specified certificate chain
         principal = context.getRealm().authenticate(certs);
         if (principal == null) {
-            if (containerLog.isDebugEnabled())
+            if (containerLog.isDebugEnabled()) {
                 containerLog.debug("  Realm.authenticate() returned false");
+            }
             response.sendError(HttpServletResponse.SC_UNAUTHORIZED,
                                sm.getString("authenticator.unauthorized"));
             return (false);

==================================================
SpnegoAuthenticator.java
index 22dfed6355..7779876960 100644
--- a/java/org/apache/catalina/authenticator/SingleSignOn.java
+++ b/java/org/apache/catalina/authenticator/SingleSignOn.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -76,13 +76,6 @@ public class SingleSignOn extends ValveBase implements SessionListener {
         new HashMap<String,SingleSignOnEntry>();
 
 
-    /**
-     * Descriptive information about this Valve implementation.
-     */
-    protected static final String info =
-        "org.apache.catalina.authenticator.SingleSignOn";
-
-
     /**
      * Indicates whether this valve should require a downstream Authenticator to
      * reauthenticate each request, or if it itself can bind a UserPrincipal
@@ -215,20 +208,23 @@ public class SingleSignOn extends ValveBase implements SessionListener {
 
         // We only care about session destroyed events
         if (!Session.SESSION_DESTROYED_EVENT.equals(event.getType())
-                && (!Session.SESSION_PASSIVATED_EVENT.equals(event.getType())))
+                && (!Session.SESSION_PASSIVATED_EVENT.equals(event.getType()))) {
             return;
+        }
 
         // Look up the single session id associated with this session (if any)
         Session session = event.getSession();
-        if (containerLog.isDebugEnabled())
+        if (containerLog.isDebugEnabled()) {
             containerLog.debug("Process session destroyed on " + session);
+        }
 
         String ssoId = null;
         synchronized (reverse) {
             ssoId = reverse.get(session);
         }
-        if (ssoId == null)
+        if (ssoId == null) {
             return;
+        }
 
         // Was the session destroyed as the result of a timeout?
         // If so, we'll just remove the expired session from the
@@ -236,12 +232,12 @@ public class SingleSignOn extends ValveBase implements SessionListener {
         // of all session associated with the SSO.
         if (((session.getMaxInactiveInterval() > 0)
             && (System.currentTimeMillis() - session.getThisAccessedTimeInternal() >=
-                session.getMaxInactiveInterval() * 1000)) 
+                session.getMaxInactiveInterval() * 1000))
             || (Session.SESSION_PASSIVATED_EVENT.equals(event.getType()))) {
             removeSession(ssoId, session);
         } else {
             // The session was logged out.
-            // Deregister this single session id, invalidating 
+            // Deregister this single session id, invalidating
             // associated sessions
             deregister(ssoId);
         }
@@ -251,18 +247,6 @@ public class SingleSignOn extends ValveBase implements SessionListener {
 
     // ---------------------------------------------------------- Valve Methods
 
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-
     /**
      * Perform single-sign-on support processing for this request.
      *
@@ -279,23 +263,27 @@ public class SingleSignOn extends ValveBase implements SessionListener {
         request.removeNote(Constants.REQ_SSOID_NOTE);
 
         // Has a valid user already been authenticated?
-        if (containerLog.isDebugEnabled())
+        if (containerLog.isDebugEnabled()) {
             containerLog.debug("Process request for '" + request.getRequestURI() + "'");
+        }
         if (request.getUserPrincipal() != null) {
-            if (containerLog.isDebugEnabled())
+            if (containerLog.isDebugEnabled()) {
                 containerLog.debug(" Principal '" + request.getUserPrincipal().getName() +
                     "' has already been authenticated");
+            }
             getNext().invoke(request, response);
             return;
         }
 
         // Check for the single sign on cookie
-        if (containerLog.isDebugEnabled())
+        if (containerLog.isDebugEnabled()) {
             containerLog.debug(" Checking for SSO cookie");
+        }
         Cookie cookie = null;
         Cookie cookies[] = request.getCookies();
-        if (cookies == null)
+        if (cookies == null) {
             cookies = new Cookie[0];
+        }
         for (int i = 0; i < cookies.length; i++) {
             if (Constants.SINGLE_SIGN_ON_COOKIE.equals(cookies[i].getName())) {
                 cookie = cookies[i];
@@ -303,21 +291,24 @@ public class SingleSignOn extends ValveBase implements SessionListener {
             }
         }
         if (cookie == null) {
-            if (containerLog.isDebugEnabled())
+            if (containerLog.isDebugEnabled()) {
                 containerLog.debug(" SSO cookie is not present");
+            }
             getNext().invoke(request, response);
             return;
         }
 
         // Look up the cached Principal associated with this cookie value
-        if (containerLog.isDebugEnabled())
+        if (containerLog.isDebugEnabled()) {
             containerLog.debug(" Checking for cached principal for " + cookie.getValue());
+        }
         SingleSignOnEntry entry = lookup(cookie.getValue());
         if (entry != null) {
-            if (containerLog.isDebugEnabled())
+            if (containerLog.isDebugEnabled()) {
                 containerLog.debug(" Found cached principal '" +
                     (entry.getPrincipal() != null ? entry.getPrincipal().getName() : "") + "' with auth type '" +
                     entry.getAuthType() + "'");
+            }
             request.setNote(Constants.REQ_SSOID_NOTE, cookie.getValue());
             // Only set security elements if reauthentication is not required
             if (!getRequireReauthentication()) {
@@ -325,8 +316,9 @@ public class SingleSignOn extends ValveBase implements SessionListener {
                 request.setUserPrincipal(entry.getPrincipal());
             }
         } else {
-            if (containerLog.isDebugEnabled())
+            if (containerLog.isDebugEnabled()) {
                 containerLog.debug(" No cached principal found, erasing SSO cookie");
+            }
             cookie.setMaxAge(0);
             response.addCookie(cookie);
         }
@@ -349,12 +341,14 @@ public class SingleSignOn extends ValveBase implements SessionListener {
      */
     protected void associate(String ssoId, Session session) {
 
-        if (containerLog.isDebugEnabled())
+        if (containerLog.isDebugEnabled()) {
             containerLog.debug("Associate sso id " + ssoId + " with session " + session);
+        }
 
         SingleSignOnEntry sso = lookup(ssoId);
-        if (sso != null)
+        if (sso != null) {
             sso.addSession(this, session);
+        }
         synchronized (reverse) {
             reverse.put(session, ssoId);
         }
@@ -375,8 +369,9 @@ public class SingleSignOn extends ValveBase implements SessionListener {
         }
 
         SingleSignOnEntry sso = lookup(ssoId);
-        if (sso == null)
+        if (sso == null) {
             return;
+        }
 
         sso.removeSession(session);
 
@@ -399,8 +394,9 @@ public class SingleSignOn extends ValveBase implements SessionListener {
      */
     protected void deregister(String ssoId) {
 
-        if (containerLog.isDebugEnabled())
+        if (containerLog.isDebugEnabled()) {
             containerLog.debug("Deregistering sso id '" + ssoId + "'");
+        }
 
         // Look up and remove the corresponding SingleSignOnEntry
         SingleSignOnEntry sso = null;
@@ -408,14 +404,16 @@ public class SingleSignOn extends ValveBase implements SessionListener {
             sso = cache.remove(ssoId);
         }
 
-        if (sso == null)
+        if (sso == null) {
             return;
+        }
 
         // Expire any associated sessions
         Session sessions[] = sso.findSessions();
         for (int i = 0; i < sessions.length; i++) {
-            if (containerLog.isTraceEnabled())
+            if (containerLog.isTraceEnabled()) {
                 containerLog.trace(" Invalidating session " + sessions[i]);
+            }
             // Remove from reverse cache first to avoid recursion
             synchronized (reverse) {
                 reverse.remove(sessions[i]);
@@ -438,8 +436,8 @@ public class SingleSignOn extends ValveBase implements SessionListener {
      * <p>
      * If reauthentication is successful, the <code>Principal</code> and
      * authorization type associated with the SSO session will be bound
-     * to the given <code>Request</code> object via calls to 
-     * {@link Request#setAuthType Request.setAuthType()} and 
+     * to the given <code>Request</code> object via calls to
+     * {@link Request#setAuthType Request.setAuthType()} and
      * {@link Request#setUserPrincipal Request.setUserPrincipal()}
      * </p>
      *
@@ -448,27 +446,28 @@ public class SingleSignOn extends ValveBase implements SessionListener {
      * @param realm     Realm implementation against which the caller is to
      *                  be authenticated
      * @param request   the request that needs to be authenticated
-     * 
+     *
      * @return  <code>true</code> if reauthentication was successful,
      *          <code>false</code> otherwise.
      */
     protected boolean reauthenticate(String ssoId, Realm realm,
                                      Request request) {
 
-        if (ssoId == null || realm == null)
+        if (ssoId == null || realm == null) {
             return false;
+        }
 
         boolean reauthenticated = false;
 
         SingleSignOnEntry entry = lookup(ssoId);
         if (entry != null && entry.getCanReauthenticate()) {
-            
+
             String username = entry.getUsername();
             if (username != null) {
                 Principal reauthPrincipal =
-                        realm.authenticate(username, entry.getPassword());                
-                if (reauthPrincipal != null) {                    
-                    reauthenticated = true;                    
+                        realm.authenticate(username, entry.getPassword());
+                if (reauthPrincipal != null) {
+                    reauthenticated = true;
                     // Bind the authorization credentials to the request
                     request.setAuthType(entry.getAuthType());
                     request.setUserPrincipal(reauthPrincipal);
@@ -494,9 +493,10 @@ public class SingleSignOn extends ValveBase implements SessionListener {
     protected void register(String ssoId, Principal principal, String authType,
                   String username, String password) {
 
-        if (containerLog.isDebugEnabled())
+        if (containerLog.isDebugEnabled()) {
             containerLog.debug("Registering sso id '" + ssoId + "' for user '" +
                 (principal != null ? principal.getName() : "") + "' with auth type '" + authType + "'");
+        }
 
         synchronized (cache) {
             cache.put(ssoId, new SingleSignOnEntry(principal, authType,
@@ -536,8 +536,9 @@ public class SingleSignOn extends ValveBase implements SessionListener {
 
         SingleSignOnEntry sso = lookup(ssoId);
         if (sso != null && !sso.getCanReauthenticate()) {
-            if (containerLog.isDebugEnabled())
+            if (containerLog.isDebugEnabled()) {
                 containerLog.debug("Update sso id " + ssoId + " to auth type " + authType);
+            }
 
             synchronized(sso) {
                 sso.updateCredentials(principal, authType, username, password);
@@ -561,7 +562,7 @@ public class SingleSignOn extends ValveBase implements SessionListener {
 
     }
 
-    
+
     /**
      * Remove a single Session from a SingleSignOn.  Called when
      * a session is timed out and no longer active.
@@ -571,14 +572,16 @@ public class SingleSignOn extends ValveBase implements SessionListener {
      */
     protected void removeSession(String ssoId, Session session) {
 
-        if (containerLog.isDebugEnabled())
-            containerLog.debug("Removing session " + session.toString() + " from sso id " + 
+        if (containerLog.isDebugEnabled()) {
+            containerLog.debug("Removing session " + session.toString() + " from sso id " +
                 ssoId );
+        }
 
         // Get a reference to the SingleSignOn
         SingleSignOnEntry entry = lookup(ssoId);
-        if (entry == null)
+        if (entry == null) {
             return;
+        }
 
         // Remove the inactive session from SingleSignOnEntry
         entry.removeSession(session);

==================================================
StandardContextValve.java
index 3c36c6ab3f..58ceb838be 100644
--- a/java/org/apache/catalina/authenticator/SpnegoAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/SpnegoAuthenticator.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -53,7 +53,7 @@ import org.ietf.jgss.Oid;
 public class SpnegoAuthenticator extends AuthenticatorBase {
 
     private static final Log log = LogFactory.getLog(SpnegoAuthenticator.class);
-    
+
     private String loginConfigName = Constants.DEFAULT_LOGIN_MODULE_NAME;
     public String getLoginConfigName() {
         return loginConfigName;
@@ -78,12 +78,6 @@ public class SpnegoAuthenticator extends AuthenticatorBase {
     }
 
 
-    @Override
-    public String getInfo() {
-        return "org.apache.catalina.authenticator.SpnegoAuthenticator/1.0";
-    }
-
-
     @Override
     protected void initInternal() throws LifecycleException {
         super.initInternal();
@@ -107,7 +101,7 @@ public class SpnegoAuthenticator extends AuthenticatorBase {
             System.setProperty(Constants.JAAS_CONF_PROPERTY,
                     jaasConfFile.getAbsolutePath());
         }
-        
+
         // This property must be false for SPNEGO to work
         System.setProperty(Constants.USE_SUBJECT_CREDS_ONLY_PROPERTY, "false");
     }
@@ -121,33 +115,37 @@ public class SpnegoAuthenticator extends AuthenticatorBase {
         Principal principal = request.getUserPrincipal();
         String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);
         if (principal != null) {
-            if (log.isDebugEnabled())
+            if (log.isDebugEnabled()) {
                 log.debug("Already authenticated '" + principal.getName() + "'");
+            }
             // Associate the session with any existing SSO session
-            if (ssoId != null)
+            if (ssoId != null) {
                 associate(ssoId, request.getSessionInternal(true));
+            }
             return true;
         }
 
         // Is there an SSO session against which we can try to reauthenticate?
         if (ssoId != null) {
-            if (log.isDebugEnabled())
+            if (log.isDebugEnabled()) {
                 log.debug("SSO Id " + ssoId + " set; attempting " +
                           "reauthentication");
+            }
             /* Try to reauthenticate using data cached by SSO.  If this fails,
                either the original SSO logon was of DIGEST or SSL (which
                we can't reauthenticate ourselves because there is no
                cached username and password), or the realm denied
                the user's reauthentication for some reason.
                In either case we have to prompt the user for a logon */
-            if (reauthenticateFromSSO(ssoId, request))
+            if (reauthenticateFromSSO(ssoId, request)) {
                 return true;
+            }
         }
 
-        MessageBytes authorization = 
+        MessageBytes authorization =
             request.getCoyoteRequest().getMimeHeaders()
             .getValue("authorization");
-        
+
         if (authorization == null) {
             if (log.isDebugEnabled()) {
                 log.debug(sm.getString("authenticator.noAuthHeader"));
@@ -156,7 +154,7 @@ public class SpnegoAuthenticator extends AuthenticatorBase {
             response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
             return false;
         }
-        
+
         authorization.toBytes();
         ByteChunk authorizationBC = authorization.getByteChunk();
 
@@ -173,7 +171,7 @@ public class SpnegoAuthenticator extends AuthenticatorBase {
         authorizationBC.setOffset(authorizationBC.getOffset() + 10);
         // FIXME: Add trimming
         // authorizationBC.trim();
-                
+
         ByteChunk decoded = new ByteChunk();
         Base64.decode(authorizationBC, decoded);
 

==================================================
StandardEngineValve.java
index 193bc38425..f8ef268fcb 100644
--- a/java/org/apache/catalina/core/StandardContextValve.java
+++ b/java/org/apache/catalina/core/StandardContextValve.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -45,45 +45,23 @@ import org.apache.tomcat.util.buf.MessageBytes;
  */
 
 final class StandardContextValve extends ValveBase {
-    
+
     //------------------------------------------------------ Constructor
     public StandardContextValve() {
         super(true);
     }
 
-    // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * The descriptive information related to this implementation.
-     */
-    private static final String info =
-        "org.apache.catalina.core.StandardContextValve/1.0";
 
+    // ----------------------------------------------------- Instance Variables
 
     private StandardContext context = null;
-    
-
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
 
 
     // --------------------------------------------------------- Public Methods
 
-
     /**
      * Cast to a StandardContext right away, as it will be needed later.
-     * 
+     *
      * @see org.apache.catalina.Contained#setContainer(org.apache.catalina.Container)
      */
     @Override
@@ -92,7 +70,7 @@ final class StandardContextValve extends ValveBase {
         context = (StandardContext) container;
     }
 
-    
+
     /**
      * Select the appropriate child Wrapper to process this request,
      * based on the specified request URI.  If no matching Wrapper can
@@ -162,7 +140,7 @@ final class StandardContextValve extends ValveBase {
             response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
             return;
         }
-        
+
         if (request.isAsyncSupported()) {
             request.setAsyncSupported(wrapper.getPipeline().isAsyncSupported());
         }

==================================================
StandardHostValve.java
index b4cf808f7a..b52eb3cbb2 100644
--- a/java/org/apache/catalina/core/StandardEngineValve.java
+++ b/java/org/apache/catalina/core/StandardEngineValve.java
@@ -5,20 +5,17 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.core;
 
-
 import java.io.IOException;
 
 import javax.servlet.ServletException;
@@ -31,7 +28,6 @@ import org.apache.catalina.connector.Response;
 import org.apache.catalina.valves.ValveBase;
 import org.apache.tomcat.util.res.StringManager;
 
-
 /**
  * Valve that implements the default basic behavior for the
  * <code>StandardEngine</code> container implementation.
@@ -43,8 +39,7 @@ import org.apache.tomcat.util.res.StringManager;
  * @version $Id$
  */
 
-final class StandardEngineValve
-    extends ValveBase {
+final class StandardEngineValve extends ValveBase {
 
     //------------------------------------------------------ Constructor
     public StandardEngineValve() {
@@ -54,14 +49,6 @@ final class StandardEngineValve
 
     // ----------------------------------------------------- Instance Variables
 
-
-    /**
-     * The descriptive information related to this implementation.
-     */
-    private static final String info =
-        "org.apache.catalina.core.StandardEngineValve/1.0";
-
-
     /**
      * The string manager for this package.
      */
@@ -69,23 +56,8 @@ final class StandardEngineValve
         StringManager.getManager(Constants.Package);
 
 
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-
     // --------------------------------------------------------- Public Methods
 
-
     /**
      * Select the appropriate child Host to process this request,
      * based on the requested server name.  If no matching Host can
@@ -106,7 +78,7 @@ final class StandardEngineValve
         if (host == null) {
             response.sendError
                 (HttpServletResponse.SC_BAD_REQUEST,
-                 sm.getString("standardEngine.noHost", 
+                 sm.getString("standardEngine.noHost",
                               request.getServerName()));
             return;
         }

==================================================
ClusterSingleSignOn.java
index 80a8217a4f..769f6b7ea5 100644
--- a/java/org/apache/catalina/core/StandardHostValve.java
+++ b/java/org/apache/catalina/core/StandardHostValve.java
@@ -66,7 +66,7 @@ final class StandardHostValve extends ValveBase {
 
     static {
         STRICT_SERVLET_COMPLIANCE = Globals.STRICT_SERVLET_COMPLIANCE;
-        
+
         String accessSession = System.getProperty(
                 "org.apache.catalina.core.StandardHostValve.ACCESS_SESSION");
         if (accessSession == null) {
@@ -82,15 +82,8 @@ final class StandardHostValve extends ValveBase {
         super(true);
     }
 
-    // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * The descriptive information related to this implementation.
-     */
-    private static final String info =
-        "org.apache.catalina.core.StandardHostValve/1.0";
 
+    // ----------------------------------------------------- Instance Variables
 
     /**
      * The string manager for this package.
@@ -99,23 +92,8 @@ final class StandardHostValve extends ValveBase {
         StringManager.getManager(Constants.Package);
 
 
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-
     // --------------------------------------------------------- Public Methods
 
-
     /**
      * Select the appropriate child Context to process this request,
      * based on the specified request URI.  If no matching Context can
@@ -147,7 +125,7 @@ final class StandardHostValve extends ValveBase {
             if (Globals.IS_SECURITY_ENABLED) {
                 PrivilegedAction<Void> pa = new PrivilegedSetTccl(
                         context.getLoader().getClassLoader());
-                AccessController.doPrivileged(pa);                
+                AccessController.doPrivileged(pa);
             } else {
                 Thread.currentThread().setContextClassLoader
                         (context.getLoader().getClassLoader());
@@ -160,7 +138,7 @@ final class StandardHostValve extends ValveBase {
         // Don't fire listeners during async processing
         // If a request init listener throws an exception, the request is
         // aborted
-        boolean asyncAtStart = request.isAsync(); 
+        boolean asyncAtStart = request.isAsync();
         if (asyncAtStart || context.fireRequestInitEvent(request)) {
 
             // Ask this Context to process this request
@@ -171,7 +149,7 @@ final class StandardHostValve extends ValveBase {
                 request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
                 throwable(request, response, t);
             }
-    
+
             // If the request was async at the start and an error occurred then
             // the async error handling will kick-in and that will fire the
             // request destroyed event *after* the error handling has taken
@@ -183,16 +161,16 @@ final class StandardHostValve extends ValveBase {
                 if (context.getState().isAvailable()) {
                     // Error page processing
                     response.setSuspended(false);
-    
+
                     Throwable t = (Throwable) request.getAttribute(
                             RequestDispatcher.ERROR_EXCEPTION);
-    
+
                     if (t != null) {
                         throwable(request, response, t);
                     } else {
                         status(request, response);
                     }
-    
+
                     context.fireRequestDestroyEvent(request);
                 }
             }
@@ -208,7 +186,7 @@ final class StandardHostValve extends ValveBase {
         if (Globals.IS_SECURITY_ENABLED) {
             PrivilegedAction<Void> pa = new PrivilegedSetTccl(
                     StandardHostValve.class.getClassLoader());
-            AccessController.doPrivileged(pa);                
+            AccessController.doPrivileged(pa);
         } else {
             Thread.currentThread().setContextClassLoader
                     (StandardHostValve.class.getClassLoader());
@@ -244,7 +222,7 @@ final class StandardHostValve extends ValveBase {
         // Ask this Context to process this request
         context.getPipeline().getFirst().event(request, response, event);
 
-        
+
         // Error page processing
         response.setSuspended(false);
 
@@ -287,16 +265,18 @@ final class StandardHostValve extends ValveBase {
 
         // Handle a custom error page for this status code
         Context context = request.getContext();
-        if (context == null)
+        if (context == null) {
             return;
+        }
 
         /* Only look for error pages when isError() is set.
          * isError() is set when response.sendError() is invoked. This
          * allows custom error pages without relying on default from
          * web.xml.
          */
-        if (!response.isError())
+        if (!response.isError()) {
             return;
+        }
 
         ErrorPage errorPage = context.findErrorPage(statusCode);
         if (errorPage != null) {
@@ -305,8 +285,9 @@ final class StandardHostValve extends ValveBase {
                               Integer.valueOf(statusCode));
 
             String message = response.getMessage();
-            if (message == null)
+            if (message == null) {
                 message = "";
+            }
             request.setAttribute(RequestDispatcher.ERROR_MESSAGE, message);
             request.setAttribute
                 (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,
@@ -316,9 +297,10 @@ final class StandardHostValve extends ValveBase {
 
 
             Wrapper wrapper = request.getWrapper();
-            if (wrapper != null)
+            if (wrapper != null) {
                 request.setAttribute(RequestDispatcher.ERROR_SERVLET_NAME,
                                   wrapper.getName());
+            }
             request.setAttribute(RequestDispatcher.ERROR_REQUEST_URI,
                                  request.getRequestURI());
             if (custom(request, response, errorPage)) {
@@ -348,8 +330,9 @@ final class StandardHostValve extends ValveBase {
     private void throwable(Request request, Response response,
                              Throwable throwable) {
         Context context = request.getContext();
-        if (context == null)
+        if (context == null) {
             return;
+        }
 
         Throwable realError = throwable;
 
@@ -389,9 +372,10 @@ final class StandardHostValve extends ValveBase {
             request.setAttribute(RequestDispatcher.ERROR_EXCEPTION,
                               realError);
             Wrapper wrapper = request.getWrapper();
-            if (wrapper != null)
+            if (wrapper != null) {
                 request.setAttribute(RequestDispatcher.ERROR_SERVLET_NAME,
                                   wrapper.getName());
+            }
             request.setAttribute(RequestDispatcher.ERROR_REQUEST_URI,
                                  request.getRequestURI());
             request.setAttribute(RequestDispatcher.ERROR_EXCEPTION_TYPE,
@@ -432,8 +416,9 @@ final class StandardHostValve extends ValveBase {
     private boolean custom(Request request, Response response,
                              ErrorPage errorPage) {
 
-        if (container.getLogger().isDebugEnabled())
+        if (container.getLogger().isDebugEnabled()) {
             container.getLogger().debug("Processing " + errorPage);
+        }
 
         request.setPathInfo(errorPage.getLocation());
 
@@ -446,7 +431,7 @@ final class StandardHostValve extends ValveBase {
 
             if (response.isCommitted()) {
                 // Response is committed - including the error page is the
-                // best we can do 
+                // best we can do
                 rd.include(request.getRequest(), response.getResponse());
             } else {
                 // Reset the response (keeping the real error code and message)
@@ -483,17 +468,20 @@ final class StandardHostValve extends ValveBase {
     private static ErrorPage findErrorPage
         (Context context, Throwable exception) {
 
-        if (exception == null)
+        if (exception == null) {
             return (null);
+        }
         Class<?> clazz = exception.getClass();
         String name = clazz.getName();
         while (!Object.class.equals(clazz)) {
             ErrorPage errorPage = context.findErrorPage(name);
-            if (errorPage != null)
+            if (errorPage != null) {
                 return (errorPage);
+            }
             clazz = clazz.getSuperclass();
-            if (clazz == null)
+            if (clazz == null) {
                 break;
+            }
             name = clazz.getName();
         }
         return (null);
@@ -503,7 +491,7 @@ final class StandardHostValve extends ValveBase {
 
     private static class PrivilegedSetTccl implements PrivilegedAction<Void> {
 
-        private ClassLoader cl;
+        private final ClassLoader cl;
 
         PrivilegedSetTccl(ClassLoader cl) {
             this.cl = cl;

==================================================
JvmRouteBinderValve.java
index 4b51d50aab..ad2158bbb3 100644
--- a/java/org/apache/catalina/ha/authenticator/ClusterSingleSignOn.java
+++ b/java/org/apache/catalina/ha/authenticator/ClusterSingleSignOn.java
@@ -54,20 +54,10 @@ import org.apache.tomcat.util.ExceptionUtils;
  *
  * @author Fabien Carrion
  */
-
-public class ClusterSingleSignOn
-    extends SingleSignOn {
-
+public class ClusterSingleSignOn extends SingleSignOn {
 
     // ----------------------------------------------------- Instance Variables
 
-
-    /**
-     * Descriptive information about this Valve implementation.
-     */
-    protected static final String info =
-        "org.apache.catalina.ha.authenticator.ClusterSingleSignOn";
-
     protected int messageNumber = 0;
 
     private ClusterSingleSignOnListener clusterSSOListener = null;
@@ -76,29 +66,9 @@ public class ClusterSingleSignOn
     // ------------------------------------------------------------- Properties
 
     private CatalinaCluster cluster = null;
-
-
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-    public CatalinaCluster getCluster() {
-
-        return cluster;
-
-    }
-
+    public CatalinaCluster getCluster() { return cluster; }
     public void setCluster(CatalinaCluster cluster) {
-
         this.cluster = cluster;
-
     }
 
 
@@ -114,7 +84,7 @@ public class ClusterSingleSignOn
      */
     @Override
     protected synchronized void startInternal() throws LifecycleException {
-        
+
         clusterSSOListener = new ClusterSingleSignOnListener();
         clusterSSOListener.setClusterSSO(this);
 
@@ -197,16 +167,18 @@ public class ClusterSingleSignOn
                 new SingleSignOnMessage(cluster.getLocalMember(),
                                         ssoId, session.getId());
             Manager mgr = session.getManager();
-            if ((mgr != null) && (mgr instanceof ClusterManager))
+            if ((mgr != null) && (mgr instanceof ClusterManager)) {
                 msg.setContextName(((ClusterManager) mgr).getName());
+            }
 
             msg.setAction(SingleSignOnMessage.ADD_SESSION);
 
             cluster.send(msg);
 
-            if (containerLog.isDebugEnabled())
+            if (containerLog.isDebugEnabled()) {
                 containerLog.debug("SingleSignOnMessage Send with action "
                                    + msg.getAction());
+            }
         }
 
         associateLocal(ssoId, session);
@@ -237,15 +209,17 @@ public class ClusterSingleSignOn
                 new SingleSignOnMessage(cluster.getLocalMember(),
                                         ssoId, session.getId());
             Manager mgr = session.getManager();
-            if ((mgr != null) && (mgr instanceof ClusterManager))
+            if ((mgr != null) && (mgr instanceof ClusterManager)) {
                 msg.setContextName(((ClusterManager) mgr).getName());
+            }
 
             msg.setAction(SingleSignOnMessage.DEREGISTER_SESSION);
 
             cluster.send(msg);
-            if (containerLog.isDebugEnabled())
+            if (containerLog.isDebugEnabled()) {
                 containerLog.debug("SingleSignOnMessage Send with action "
                                    + msg.getAction());
+            }
         }
 
         deregisterLocal(ssoId, session);
@@ -277,9 +251,10 @@ public class ClusterSingleSignOn
             msg.setAction(SingleSignOnMessage.LOGOUT_SESSION);
 
             cluster.send(msg);
-            if (containerLog.isDebugEnabled())
+            if (containerLog.isDebugEnabled()) {
                 containerLog.debug("SingleSignOnMessage Send with action "
                                    + msg.getAction());
+            }
         }
 
         deregisterLocal(ssoId);
@@ -319,9 +294,10 @@ public class ClusterSingleSignOn
             msg.setPassword(password);
 
             cluster.send(msg);
-            if (containerLog.isDebugEnabled())
+            if (containerLog.isDebugEnabled()) {
                 containerLog.debug("SingleSignOnMessage Send with action "
                                    + msg.getAction());
+            }
         }
 
         registerLocal(ssoId, principal, authType, username, password);
@@ -377,9 +353,10 @@ public class ClusterSingleSignOn
             msg.setPassword(password);
 
             cluster.send(msg);
-            if (containerLog.isDebugEnabled())
+            if (containerLog.isDebugEnabled()) {
                 containerLog.debug("SingleSignOnMessage Send with action "
                                    + msg.getAction());
+            }
         }
 
         updateLocal(ssoId, principal, authType, username, password);
@@ -411,15 +388,17 @@ public class ClusterSingleSignOn
                                         ssoId, session.getId());
 
             Manager mgr = session.getManager();
-            if ((mgr != null) && (mgr instanceof ClusterManager))
+            if ((mgr != null) && (mgr instanceof ClusterManager)) {
                 msg.setContextName(((ClusterManager) mgr).getName());
+            }
 
             msg.setAction(SingleSignOnMessage.REMOVE_SESSION);
 
             cluster.send(msg);
-            if (containerLog.isDebugEnabled())
+            if (containerLog.isDebugEnabled()) {
                 containerLog.debug("SingleSignOnMessage Send with action "
                                    + msg.getAction());
+            }
         }
 
         removeSessionLocal(ssoId, session);
@@ -428,7 +407,7 @@ public class ClusterSingleSignOn
     protected void removeSessionLocal(String ssoId, Session session) {
 
         super.removeSession(ssoId, session);
-        
+
     }
 
 }

==================================================
ReplicationValve.java
index 98f6ba2f12..d975e7dfbd 100644
--- a/java/org/apache/catalina/ha/session/JvmRouteBinderValve.java
+++ b/java/org/apache/catalina/ha/session/JvmRouteBinderValve.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -49,7 +49,7 @@ import org.apache.tomcat.util.res.StringManager;
  * nodes. After all that, the session stickiness will work directly to the
  * backup node and the traffic will not go back to the failed node after it is
  * restarted!
- * 
+ *
  * <p>
  * For this valve to function correctly, so that all nodes of the cluster
  * receive the sessionid change notifications that it generates, the following
@@ -58,34 +58,34 @@ import org.apache.tomcat.util.res.StringManager;
  * JvmRouteSessionIDBinderListener} since Tomcat 5.5.10, and both
  * JvmRouteSessionIDBinderListener and JvmRouteSessionIDBinderLifecycleListener
  * for earlier versions of Tomcat.
- * 
+ *
  * <p>
  * Add this Valve to your host definition at conf/server.xml .
- * 
+ *
  * Since 5.5.10 as direct cluster valve:<br/>
- * 
+ *
  * <pre>
  *  &lt;Cluster&gt;
- *  &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot; /&gt;  
+ *  &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot; /&gt;
  *  &lt;/Cluster&gt;
  * </pre>
- * 
+ *
  * <br />
  * Before 5.5.10 as Host element:<br/>
- * 
+ *
  * <pre>
  *  &lt;Host&gt;
- *  &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot; /&gt;  
+ *  &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot; /&gt;
  *  &lt;/Host&gt;
  * </pre>
- * 
+ *
  * <em>A Trick:</em><br/>
  * You can enable this mod_jk turnover mode via JMX before you drop a node to
  * all backup nodes! Set enable true on all JvmRouteBinderValve backups, disable
  * worker at mod_jk and then drop node and restart it! Then enable mod_jk worker
  * and disable JvmRouteBinderValves again. This use case means that only
  * requested sessions are migrated.
- * 
+ *
  * @author Peter Rossbach
  * @version $Id$
  */
@@ -95,11 +95,6 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
     public static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory
             .getLog(JvmRouteBinderValve.class);
 
-    /**
-     * The descriptive information about this implementation.
-     */
-    protected static final String info = "org.apache.catalina.ha.session.JvmRouteBinderValve/1.2";
-
     //------------------------------------------------------ Constructor
     public JvmRouteBinderValve() {
         super(true);
@@ -132,19 +127,9 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
 
     /*--Logic---------------------------------------------------*/
 
-    /**
-     * Return descriptive information about this implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
-
     /**
      * set session id attribute to failed node for request.
-     * 
+     *
      * @return Returns the sessionIdAttribute.
      */
     public String getSessionIdAttribute() {
@@ -153,7 +138,7 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
 
     /**
      * get name of failed request session attribute
-     * 
+     *
      * @param sessionIdAttribute
      *            The sessionIdAttribute to set.
      */
@@ -185,7 +170,7 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
 
     /**
      * Detect possible the JVMRoute change at cluster backup node..
-     * 
+     *
      * @param request
      *            tomcat request being processed
      * @param response
@@ -203,7 +188,7 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
                  request.getContext() != null &&
                  request.getContext().getDistributable() &&
                  !request.isAsyncDispatching()) {
-             // valve cluster can access manager - other cluster handle turnover 
+             // valve cluster can access manager - other cluster handle turnover
              // at host level - hopefully!
              Manager manager = request.getContext().getManager();
 
@@ -212,8 +197,9 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
                        && getCluster() != null
                        && getCluster().getManager(((ClusterManager)manager).getName()) != null)
                      ||
-                     (manager instanceof PersistentManager)))
-                 handlePossibleTurnover(request);
+                     (manager instanceof PersistentManager))) {
+                handlePossibleTurnover(request);
+            }
         }
         // Pass this request on to the next valve in our pipeline
         getNext().invoke(request, response);
@@ -221,7 +207,7 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
 
     /**
      * handle possible session turn over.
-     * 
+     *
      * @see JvmRouteBinderValve#handleJvmRoute(Request, String, String)
      * @param request current request
      */
@@ -231,8 +217,9 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
             long t1 = System.currentTimeMillis();
             String jvmRoute = getLocalJvmRoute(request);
             if (jvmRoute == null) {
-                if (log.isDebugEnabled())
+                if (log.isDebugEnabled()) {
                     log.debug(sm.getString("jvmRoute.missingJvmRouteAttribute"));
+                }
                 return;
             }
             handleJvmRoute( request, sessionID, jvmRoute);
@@ -246,30 +233,32 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
 
     /**
      * get jvmroute from engine
-     * 
+     *
      * @param request current request
      * @return return jvmRoute from ManagerBase or null
      */
     protected String getLocalJvmRoute(Request request) {
         Manager manager = getManager(request);
-        if(manager instanceof ManagerBase)
+        if(manager instanceof ManagerBase) {
             return ((ManagerBase) manager).getJvmRoute();
+        }
         return null ;
     }
 
     /**
      * get Cluster DeltaManager
-     * 
+     *
      * @param request current request
      * @return manager or null
      */
     protected Manager getManager(Request request) {
         Manager manager = request.getContext().getManager();
         if (log.isDebugEnabled()) {
-            if(manager != null)
+            if(manager != null) {
                 log.debug(sm.getString("jvmRoute.foundManager", manager,  request.getContext().getName()));
-            else 
+            } else {
                 log.debug(sm.getString("jvmRoute.notFoundManager", request.getContext().getName()));
+            }
         }
         return manager;
     }
@@ -281,7 +270,7 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
     public CatalinaCluster getCluster() {
         return cluster;
     }
-    
+
     /**
      * @param cluster The cluster to set.
      */
@@ -289,12 +278,12 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
     public void setCluster(CatalinaCluster cluster) {
         this.cluster = cluster;
     }
-    
+
     /**
      * Handle jvmRoute stickiness after tomcat instance failed. After this
      * correction a new Cookie send to client with new jvmRoute and the
      * SessionID change propagate to the other cluster nodes.
-     * 
+     *
      * @param request current request
      * @param sessionId
      *            request SessionID from Cookie
@@ -348,7 +337,7 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
 
     /**
      * change session id and send to all cluster nodes
-     * 
+     *
      * @param request current request
      * @param sessionId
      *            original session id
@@ -363,8 +352,9 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
         catalinaSession.setId(newSessionID, false);
         // FIXME: Why we remove change data from other running request?
         // setId also trigger resetDeltaRequest!!
-        if (catalinaSession instanceof DeltaSession)
+        if (catalinaSession instanceof DeltaSession) {
             ((DeltaSession) catalinaSession).resetDeltaRequest();
+        }
         changeRequestSessionID(request, sessionId, newSessionID);
 
         // now sending the change to all other clusternodes!
@@ -374,7 +364,7 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
         if (log.isDebugEnabled()) {
             log.debug(sm.getString("jvmRoute.changeSession", sessionId,
                     newSessionID));
-        }   
+        }
     }
 
     /**
@@ -397,10 +387,10 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
             request.setAttribute(sessionIdAttribute, sessionId);
         }
     }
-    
+
     /**
      * Send the changed Sessionid to all clusternodes.
-     * 
+     *
      * @see JvmRouteSessionIDBinderListener#messageReceived(
      *            org.apache.catalina.ha.ClusterMessage)
      * @param sessionId
@@ -431,14 +421,15 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
      */
     @Override
     protected synchronized void startInternal() throws LifecycleException {
-        
+
         if (cluster == null) {
             Container hostContainer = getContainer();
             // compatibility with JvmRouteBinderValve version 1.1
             // ( setup at context.xml or context.xml.default )
             if (!(hostContainer instanceof Host)) {
-                if (log.isWarnEnabled())
+                if (log.isWarnEnabled()) {
                     log.warn(sm.getString("jvmRoute.configure.warn"));
+                }
                 hostContainer = hostContainer.getParent();
             }
             if (hostContainer instanceof Host
@@ -452,17 +443,18 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
                 }
             }
         }
-        
+
         if (log.isInfoEnabled()) {
             log.info(sm.getString("jvmRoute.valve.started"));
-            if (cluster == null)
+            if (cluster == null) {
                 log.info(sm.getString("jvmRoute.noCluster"));
+            }
         }
 
         super.startInternal();
     }
 
-    
+
     /**
      * Stop this component and implement the requirements
      * of {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
@@ -477,8 +469,9 @@ public class JvmRouteBinderValve extends ValveBase implements ClusterValve {
 
         cluster = null;
         numberOfSessions = 0;
-        if (log.isInfoEnabled())
+        if (log.isInfoEnabled()) {
             log.info(sm.getString("jvmRoute.valve.stopped"));
+        }
 
     }
 

==================================================
ContextConfig.java
index 71bee61752..6f0a8fcba3 100644
--- a/java/org/apache/catalina/ha/tcp/ReplicationValve.java
+++ b/java/org/apache/catalina/ha/tcp/ReplicationValve.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -63,19 +63,12 @@ import org.apache.tomcat.util.res.StringManager;
 
 public class ReplicationValve
     extends ValveBase implements ClusterValve {
-    
+
     private static final org.apache.juli.logging.Log log =
         org.apache.juli.logging.LogFactory.getLog( ReplicationValve.class );
 
     // ----------------------------------------------------- Instance Variables
 
-    /**
-     * The descriptive information related to this implementation.
-     */
-    private static final String info =
-        "org.apache.catalina.ha.tcp.ReplicationValve/2.0";
-
-
     /**
      * The StringManager for this package.
      */
@@ -85,21 +78,21 @@ public class ReplicationValve
     private CatalinaCluster cluster = null ;
 
     /**
-     * Filter expression 
+     * Filter expression
      */
     protected Pattern filter = null;
-    
+
     /**
-     * crossContext session container 
+     * crossContext session container
      */
     protected ThreadLocal<ArrayList<DeltaSession>> crossContextSessions =
         new ThreadLocal<ArrayList<DeltaSession>>() ;
-    
+
     /**
      * doProcessingStats (default = off)
      */
     protected boolean doProcessingStats = false;
-    
+
     protected long totalRequestTime = 0;
     protected long totalSendTime = 0;
     protected long nrOfRequests = 0;
@@ -107,33 +100,23 @@ public class ReplicationValve
     protected long nrOfFilterRequests = 0;
     protected long nrOfSendRequests = 0;
     protected long nrOfCrossContextSendRequests = 0;
-    
+
     /**
-     * must primary change indicator set 
+     * must primary change indicator set
      */
     protected boolean primaryIndicator = false ;
-    
+
     /**
      * Name of primary change indicator as request attribute
      */
     protected String primaryIndicatorName = "org.apache.catalina.ha.tcp.isPrimarySession";
-   
+
     // ------------------------------------------------------------- Properties
 
     public ReplicationValve() {
         super(true);
     }
-    
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
 
-        return (info);
-
-    }
-    
     /**
      * @return Returns the cluster.
      */
@@ -141,7 +124,7 @@ public class ReplicationValve
     public CatalinaCluster getCluster() {
         return cluster;
     }
-    
+
     /**
      * @param cluster The cluster to set.
      */
@@ -149,7 +132,7 @@ public class ReplicationValve
     public void setCluster(CatalinaCluster cluster) {
         this.cluster = cluster;
     }
- 
+
     /**
      * @return Returns the filter
      */
@@ -167,9 +150,10 @@ public class ReplicationValve
      *            The filter to set.
      */
     public void setFilter(String filter) {
-        if (log.isDebugEnabled())
+        if (log.isDebugEnabled()) {
             log.debug(sm.getString("ReplicationValve.filter.loading", filter));
-        
+        }
+
         if (filter == null || filter.length() == 0) {
             this.filter = null;
         } else {
@@ -195,21 +179,21 @@ public class ReplicationValve
     public void setPrimaryIndicator(boolean primaryIndicator) {
         this.primaryIndicator = primaryIndicator;
     }
-    
+
     /**
      * @return Returns the primaryIndicatorName.
      */
     public String getPrimaryIndicatorName() {
         return primaryIndicatorName;
     }
-    
+
     /**
      * @param primaryIndicatorName The primaryIndicatorName to set.
      */
     public void setPrimaryIndicatorName(String primaryIndicatorName) {
         this.primaryIndicatorName = primaryIndicatorName;
     }
-    
+
     /**
      * Calc processing stats
      */
@@ -231,14 +215,14 @@ public class ReplicationValve
     public long getLastSendTime() {
         return lastSendTime;
     }
-    
+
     /**
      * @return Returns the nrOfRequests.
      */
     public long getNrOfRequests() {
         return nrOfRequests;
     }
-    
+
     /**
      * @return Returns the nrOfFilterRequests.
      */
@@ -266,7 +250,7 @@ public class ReplicationValve
     public long getTotalRequestTime() {
         return totalRequestTime;
     }
-    
+
     /**
      * @return Returns the totalSendTime.
      */
@@ -275,7 +259,7 @@ public class ReplicationValve
     }
 
     // --------------------------------------------------------- Public Methods
-    
+
     /**
      * Register all cross context sessions inside endAccess.
      * Use a list with contains check, that the Portlet API can include a lot of fragments from same or
@@ -287,10 +271,11 @@ public class ReplicationValve
         List<DeltaSession> sessions = crossContextSessions.get();
         if(sessions != null) {
             if(!sessions.contains(session)) {
-                if(log.isDebugEnabled())
+                if(log.isDebugEnabled()) {
                     log.debug(sm.getString("ReplicationValve.crossContext.registerSession",
                         session.getIdInternal(),
                         session.getManager().getContainer().getName()));
+                }
                 sessions.add(session);
             }
         }
@@ -325,39 +310,43 @@ public class ReplicationValve
                 && ((StandardContext) context).getCrossContext();
         try {
             if(isCrossContext) {
-                if(log.isDebugEnabled())
+                if(log.isDebugEnabled()) {
                     log.debug(sm.getString("ReplicationValve.crossContext.add"));
+                }
                 //FIXME add Pool of Arraylists
                 crossContextSessions.set(new ArrayList<DeltaSession>());
             }
             getNext().invoke(request, response);
             if(context != null) {
-                Manager manager = context.getManager();            
+                Manager manager = context.getManager();
                 if (manager != null && manager instanceof ClusterManager) {
                     ClusterManager clusterManager = (ClusterManager) manager;
                     CatalinaCluster containerCluster = (CatalinaCluster) getContainer().getCluster();
                     if (containerCluster == null) {
-                        if (log.isWarnEnabled())
+                        if (log.isWarnEnabled()) {
                             log.warn(sm.getString("ReplicationValve.nocluster"));
+                        }
                         return;
                     }
-                    // valve cluster can access manager - other cluster handle replication 
+                    // valve cluster can access manager - other cluster handle replication
                     // at host level - hopefully!
-                    if(containerCluster.getManager(clusterManager.getName()) == null)
+                    if(containerCluster.getManager(clusterManager.getName()) == null) {
                         return ;
+                    }
                     if(containerCluster.hasMembers()) {
                         sendReplicationMessage(request, totalstart, isCrossContext, clusterManager, containerCluster);
                     } else {
                         resetReplicationRequest(request,isCrossContext);
-                    }        
+                    }
                 }
             }
         } finally {
-            // Array must be remove: Current master request send endAccess at recycle. 
+            // Array must be remove: Current master request send endAccess at recycle.
             // Don't register this request session again!
             if(isCrossContext) {
-                if(log.isDebugEnabled())
+                if(log.isDebugEnabled()) {
                     log.debug(sm.getString("ReplicationValve.crossContext.remove"));
+                }
                 // crossContextSessions.remove() only exist at Java 5
                 // register ArrayList at a pool
                 crossContextSessions.set(null);
@@ -365,9 +354,9 @@ public class ReplicationValve
         }
     }
 
-    
+
     /**
-     * reset the active statistics 
+     * reset the active statistics
      */
     public void resetStatistics() {
         totalRequestTime = 0 ;
@@ -378,7 +367,7 @@ public class ReplicationValve
         nrOfSendRequests = 0;
         nrOfCrossContextSendRequests = 0;
     }
-    
+
 
     // --------------------------------------------------------- Protected Methods
 
@@ -398,12 +387,14 @@ public class ReplicationValve
         try {
             // send invalid sessions
             // DeltaManager returns String[0]
-            if (!(clusterManager instanceof DeltaManager))
+            if (!(clusterManager instanceof DeltaManager)) {
                 sendInvalidSessions(clusterManager, containerCluster);
+            }
             // send replication
             sendSessionReplicationMessage(request, clusterManager, containerCluster);
-            if(isCrossContext)
+            if(isCrossContext) {
                 sendCrossContextSession(containerCluster);
+            }
         } catch (Exception x) {
             // FIXME we have a lot of sends, but the trouble with one node stops the correct replication to other nodes!
             log.error(sm.getString("ReplicationValve.send.failure"), x);
@@ -422,11 +413,12 @@ public class ReplicationValve
     protected void sendCrossContextSession(CatalinaCluster containerCluster) {
         List<DeltaSession> sessions = crossContextSessions.get();
         if(sessions != null && sessions.size() >0) {
-            for(Iterator<DeltaSession> iter = sessions.iterator(); iter.hasNext() ;) {          
+            for(Iterator<DeltaSession> iter = sessions.iterator(); iter.hasNext() ;) {
                 Session session = iter.next();
-                if(log.isDebugEnabled())
-                    log.debug(sm.getString("ReplicationValve.crossContext.sendDelta",  
+                if(log.isDebugEnabled()) {
+                    log.debug(sm.getString("ReplicationValve.crossContext.sendDelta",
                             session.getManager().getContainer().getName() ));
+                }
                 sendMessage(session,(ClusterManager)session.getManager(),containerCluster);
                 if(doStatistics()) {
                     nrOfCrossContextSendRequests++;
@@ -434,7 +426,7 @@ public class ReplicationValve
             }
         }
     }
-  
+
     /**
      * Fix memory leak for long sessions with many changes, when no backup member exists!
      * @param request current request after response is generated
@@ -450,15 +442,16 @@ public class ReplicationValve
             List<DeltaSession> sessions = crossContextSessions.get();
             if(sessions != null && sessions.size() >0) {
                 Iterator<DeltaSession> iter = sessions.iterator();
-                for(; iter.hasNext() ;) {          
+                for(; iter.hasNext() ;) {
                     Session session = iter.next();
                     resetDeltaRequest(session);
-                    if(session instanceof DeltaSession)
+                    if(session instanceof DeltaSession) {
                         ((DeltaSession)contextSession).setPrimarySession(true);
+                    }
 
                 }
             }
-        }                     
+        }
     }
 
     /**
@@ -467,7 +460,7 @@ public class ReplicationValve
      */
     protected void resetDeltaRequest(Session session) {
         if(log.isDebugEnabled()) {
-            log.debug(sm.getString("ReplicationValve.resetDeltaRequest" , 
+            log.debug(sm.getString("ReplicationValve.resetDeltaRequest" ,
                 session.getManager().getContainer().getName() ));
         }
         ((DeltaSession)session).resetDeltaRequest();
@@ -486,18 +479,20 @@ public class ReplicationValve
             String uri = request.getDecodedRequestURI();
             // request without session change
             if (!isRequestWithoutSessionChange(uri)) {
-                if (log.isDebugEnabled())
+                if (log.isDebugEnabled()) {
                     log.debug(sm.getString("ReplicationValve.invoke.uri", uri));
+                }
                 sendMessage(session,manager,cluster);
             } else
-                if(doStatistics())
+                if(doStatistics()) {
                     nrOfFilterRequests++;
+                }
         }
 
     }
 
    /**
-    * Send message delta message from request session 
+    * Send message delta message from request session
     * @param session current session
     * @param manager session manager
     * @param cluster replication cluster
@@ -522,11 +517,12 @@ public class ReplicationValve
         ClusterMessage msg = manager.requestCompleted(sessionId);
         if (msg != null) {
             cluster.send(msg);
-            if(doStatistics())
+            if(doStatistics()) {
                 nrOfSendRequests++;
+            }
         }
     }
-    
+
     /**
      * check for session invalidations
      * @param manager
@@ -544,7 +540,7 @@ public class ReplicationValve
             }
         }
     }
-    
+
     /**
      * is request without possible session change
      * @param uri The request uri
@@ -589,7 +585,7 @@ public class ReplicationValve
     /**
      * Mark Request that processed at primary node with attribute
      * primaryIndicatorName
-     * 
+     *
      * @param request
      * @throws IOException
      */
@@ -600,11 +596,12 @@ public class ReplicationValve
             Session session = manager.findSession(id);
             if (session instanceof ClusterSession) {
                 ClusterSession cses = (ClusterSession) session;
-                if (log.isDebugEnabled())
+                if (log.isDebugEnabled()) {
                     log.debug(sm.getString(
                             "ReplicationValve.session.indicator", request.getContext().getName(),id,
                             primaryIndicatorName,
                             Boolean.valueOf(cses.isPrimarySession())));
+                }
                 request.setAttribute(primaryIndicatorName, cses.isPrimarySession()?Boolean.TRUE:Boolean.FALSE);
             } else {
                 if (log.isDebugEnabled()) {

==================================================
AccessLogValve.java
index 81f95146b5..09785783e2 100644
--- a/java/org/apache/catalina/startup/ContextConfig.java
+++ b/java/org/apache/catalina/startup/ContextConfig.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -112,7 +112,7 @@ public class ContextConfig
     implements LifecycleListener {
 
     private static final Log log = LogFactory.getLog( ContextConfig.class );
-    
+
     private static final String SCI_LOCATION =
         "META-INF/services/javax.servlet.ServletContainerInitializer";
 
@@ -132,7 +132,7 @@ public class ContextConfig
      * context files.
      */
     protected static Digester contextDigester = null;
-    
+
 
     /**
      * The set of Authenticators that we know how to configure.  The key is
@@ -198,14 +198,14 @@ public class ContextConfig
      * The default web application's context file location.
      */
     protected String defaultContextXml = null;
-    
-    
+
+
     /**
      * The default web application's deployment descriptor location.
      */
     protected String defaultWebXml = null;
-    
-    
+
+
     /**
      * Track any fatal errors during startup configuration processing.
      */
@@ -216,14 +216,14 @@ public class ContextConfig
      * Original docBase.
      */
     protected String originalDocBase = null;
-    
+
 
     /**
      * Map of ServletContainerInitializer to classes they expressed interest in.
      */
     protected Map<ServletContainerInitializer, Set<Class<?>>> initializerClassMap =
         new LinkedHashMap<ServletContainerInitializer, Set<Class<?>>>();
-    
+
     /**
      * Map of Types to ServletContainerInitializer that are interested in those
      * types.
@@ -243,7 +243,7 @@ public class ContextConfig
      */
     protected Digester webFragmentDigester = null;
 
-    
+
     // ------------------------------------------------------------- Properties
     /**
      * Return the location of the default deployment descriptor
@@ -361,11 +361,11 @@ public class ContextConfig
      * Process the application classes annotations, if it exists.
      */
     protected void applicationAnnotationsConfig() {
-        
+
         long t1=System.currentTimeMillis();
-        
+
         WebAnnotationSet.loadApplicationAnnotations(context);
-        
+
         long t2=System.currentTimeMillis();
         if (context instanceof StandardContext) {
             ((StandardContext) context).setStartupTime(t2-t1+
@@ -398,9 +398,10 @@ public class ContextConfig
         }
 
         // Has an authenticator been configured already?
-        if (context.getAuthenticator() != null)
+        if (context.getAuthenticator() != null) {
             return;
-        
+        }
+
         if (!(context instanceof ContainerBase)) {
             return;     // Cannot install a Valve even if it would be needed
         }
@@ -490,7 +491,7 @@ public class ContextConfig
      */
     public void createWebXmlDigester(boolean namespaceAware,
             boolean validation) {
-        
+
         if (!namespaceAware && !validation) {
             if (webDigesters[0] == null) {
                 webDigesters[0] = DigesterFactory.newDigester(validation,
@@ -502,7 +503,7 @@ public class ContextConfig
             }
             webDigester = webDigesters[0];
             webFragmentDigester = webFragmentDigesters[0];
-            
+
         } else if (!namespaceAware && validation) {
             if (webDigesters[1] == null) {
                 webDigesters[1] = DigesterFactory.newDigester(validation,
@@ -514,7 +515,7 @@ public class ContextConfig
             }
             webDigester = webDigesters[1];
             webFragmentDigester = webFragmentDigesters[1];
-            
+
         } else if (namespaceAware && !validation) {
             if (webDigesters[2] == null) {
                 webDigesters[2] = DigesterFactory.newDigester(validation,
@@ -526,7 +527,7 @@ public class ContextConfig
             }
             webDigester = webDigesters[2];
             webFragmentDigester = webFragmentDigesters[2];
-            
+
         } else {
             if (webDigesters[3] == null) {
                 webDigesters[3] = DigesterFactory.newDigester(validation,
@@ -541,7 +542,7 @@ public class ContextConfig
         }
     }
 
-    
+
     /**
      * Create (if necessary) and return a Digester configured to process the
      * context configuration descriptor for an application.
@@ -572,18 +573,20 @@ public class ContextConfig
         return System.getProperty(Globals.CATALINA_BASE_PROP);
     }
 
-    
+
     /**
      * Process the default configuration file, if it exists.
      */
     protected void contextConfig() {
-        
+
         // Open the default context.xml file, if it exists
         if( defaultContextXml==null && context instanceof StandardContext ) {
             defaultContextXml = ((StandardContext)context).getDefaultContextXml();
         }
         // set the default if we don't have any overrides
-        if( defaultContextXml==null ) getDefaultContextXml();
+        if( defaultContextXml==null ) {
+            getDefaultContextXml();
+        }
 
         if (!context.getOverride()) {
             File defaultContextFile = new File(defaultContextXml);
@@ -599,7 +602,7 @@ public class ContextConfig
                             "contextConfig.badUrl", defaultContextFile), e);
                 }
             }
-            
+
             File hostContextFile = new File(getConfigBase(),
                     getHostConfigPath(Constants.HostContextXml));
             if (hostContextFile.exists()) {
@@ -612,20 +615,22 @@ public class ContextConfig
                 }
             }
         }
-        if (context.getConfigFile() != null)
+        if (context.getConfigFile() != null) {
             processContextConfig(context.getConfigFile());
-        
+        }
+
     }
 
-    
+
     /**
      * Process a context.xml.
      */
     protected void processContextConfig(URL contextXml) {
-        
-        if (log.isDebugEnabled())
-            log.debug("Processing context [" + context.getName() 
+
+        if (log.isDebugEnabled()) {
+            log.debug("Processing context [" + context.getName()
                     + "] configuration file [" + contextXml + "]");
+        }
 
         InputSource source = null;
         InputStream stream = null;
@@ -633,7 +638,7 @@ public class ContextConfig
         try {
             source = new InputSource(contextXml.toString());
             stream = contextXml.openStream();
-            
+
             // Add as watched resource so that cascade reload occurs if a default
             // config file is modified/added/removed
             if ("file".equals(contextXml.getProtocol())) {
@@ -641,12 +646,13 @@ public class ContextConfig
                         (new File(contextXml.toURI())).getAbsolutePath());
             }
         } catch (Exception e) {
-            log.error(sm.getString("contextConfig.contextMissing",  
+            log.error(sm.getString("contextConfig.contextMissing",
                       contextXml) , e);
         }
-        
-        if (source == null)
+
+        if (source == null) {
             return;
+        }
         synchronized (contextDigester) {
             try {
                 source.setByteStream(stream);
@@ -662,9 +668,10 @@ public class ContextConfig
                     errorHandler.logFindings(log, contextXml.toString());
                     ok = false;
                 }
-                if (log.isDebugEnabled())
-                    log.debug("Successfully processed context [" + context.getName() 
+                if (log.isDebugEnabled()) {
+                    log.debug("Successfully processed context [" + context.getName()
                             + "] configuration file [" + contextXml + "]");
+                }
             } catch (SAXParseException e) {
                 log.error(sm.getString("contextConfig.contextParse",
                         context.getName()), e);
@@ -689,13 +696,13 @@ public class ContextConfig
         }
     }
 
-    
+
     /**
      * Adjust docBase.
      */
     protected void fixDocBase()
         throws IOException {
-        
+
         Host host = (Host) context.getParent();
         File appBase = host.getAppBaseFile();
 
@@ -718,7 +725,7 @@ public class ContextConfig
         }
         file = new File(docBase);
         String origDocBase = docBase;
-        
+
         ContextName cn = new ContextName(context.getPath(),
                 context.getWebappVersion());
         String pathName = cn.getBaseName();
@@ -778,17 +785,18 @@ public class ContextConfig
         context.setDocBase(docBase);
 
     }
-    
-    
+
+
     protected void antiLocking() {
 
-        if ((context instanceof StandardContext) 
+        if ((context instanceof StandardContext)
             && ((StandardContext) context).getAntiResourceLocking()) {
-            
+
             Host host = (Host) context.getParent();
             String docBase = context.getDocBase();
-            if (docBase == null)
+            if (docBase == null) {
                 return;
+            }
             if (originalDocBase == null) {
                 originalDocBase = docBase;
             } else {
@@ -798,7 +806,7 @@ public class ContextConfig
             if (!docBaseFile.isAbsolute()) {
                 docBaseFile = new File(host.getAppBaseFile(), docBase);
             }
-            
+
             String path = context.getPath();
             if (path == null) {
                 return;
@@ -812,24 +820,25 @@ public class ContextConfig
                 file = new File(System.getProperty("java.io.tmpdir"),
                         deploymentCount++ + "-" + docBase + ".war");
             } else {
-                file = new File(System.getProperty("java.io.tmpdir"), 
+                file = new File(System.getProperty("java.io.tmpdir"),
                         deploymentCount++ + "-" + docBase);
             }
-            
-            if (log.isDebugEnabled())
-                log.debug("Anti locking context[" + context.getName() 
+
+            if (log.isDebugEnabled()) {
+                log.debug("Anti locking context[" + context.getName()
                         + "] setting docBase to " + file);
-            
+            }
+
             // Cleanup just in case an old deployment is lying around
             ExpandWar.delete(file);
             if (ExpandWar.copy(docBaseFile, file)) {
                 context.setDocBase(file.getAbsolutePath());
             }
-            
+
         }
-        
+
     }
-    
+
 
     /**
      * Process a "init" event for this Context.
@@ -842,13 +851,14 @@ public class ContextConfig
             contextDigester.getParser();
         }
 
-        if (log.isDebugEnabled())
+        if (log.isDebugEnabled()) {
             log.debug(sm.getString("contextConfig.init"));
+        }
         context.setConfigured(false);
         ok = true;
-        
+
         contextConfig();
-        
+
         createWebXmlDigester(context.getXmlNamespaceAware(),
                 context.getXmlValidation());
 
@@ -858,28 +868,29 @@ public class ContextConfig
             log.error(sm.getString(
                     "contextConfig.fixDocBase", context.getName()), e);
         }
-        
+
     }
-    
-    
+
+
     /**
      * Process a "before start" event for this Context.
      */
     protected synchronized void beforeStart() {
-        
+
         antiLocking();
 
     }
-    
-    
+
+
     /**
      * Process a "contextConfig" event for this Context.
      */
     protected synchronized void configureStart() {
         // Called from StandardContext.start()
 
-        if (log.isDebugEnabled())
+        if (log.isDebugEnabled()) {
             log.debug(sm.getString("contextConfig.start"));
+        }
 
         if (log.isDebugEnabled()) {
             log.debug(sm.getString("contextConfig.xmlSettings",
@@ -887,7 +898,7 @@ public class ContextConfig
                     Boolean.valueOf(context.getXmlValidation()),
                     Boolean.valueOf(context.getXmlNamespaceAware())));
         }
-        
+
         webConfig();
 
         if (!context.getIgnoreAnnotations()) {
@@ -898,28 +909,30 @@ public class ContextConfig
         }
 
         // Configure an authenticator if we need one
-        if (ok)
+        if (ok) {
             authenticatorConfig();
+        }
 
         // Dump the contents of this pipeline if requested
         if ((log.isDebugEnabled()) && (context instanceof ContainerBase)) {
             log.debug("Pipeline Configuration:");
             Pipeline pipeline = ((ContainerBase) context).getPipeline();
             Valve valves[] = null;
-            if (pipeline != null)
+            if (pipeline != null) {
                 valves = pipeline.getValves();
+            }
             if (valves != null) {
                 for (int i = 0; i < valves.length; i++) {
-                    log.debug("  " + valves[i].getInfo());
+                    log.debug("  " + valves[i].getClass().getName());
                 }
             }
             log.debug("======================");
         }
 
         // Make our application available if no problems were encountered
-        if (ok)
+        if (ok) {
             context.setConfigured(true);
-        else {
+        } else {
             log.error(sm.getString("contextConfig.unavailable"));
             context.setConfigured(false);
         }
@@ -932,8 +945,9 @@ public class ContextConfig
      */
     protected synchronized void configureStop() {
 
-        if (log.isDebugEnabled())
+        if (log.isDebugEnabled()) {
             log.debug(sm.getString("contextConfig.stop"));
+        }
 
         int i;
 
@@ -1081,53 +1095,55 @@ public class ContextConfig
             // No need to log failure - it is expected in this case
             ExpandWar.delete(docBaseFile, false);
         }
-        
+
         // Reset ServletContextInitializer scanning
         initializerClassMap.clear();
         typeInitializerMap.clear();
-        
+
         ok = true;
 
     }
-    
-    
+
+
     /**
      * Process a "destroy" event for this Context.
      */
     protected synchronized void destroy() {
         // Called from StandardContext.destroy()
-        if (log.isDebugEnabled())
+        if (log.isDebugEnabled()) {
             log.debug(sm.getString("contextConfig.destroy"));
+        }
 
         // Skip clearing the work directory if Tomcat is being shutdown
         Server s = getServer();
         if (s != null && !s.getState().isAvailable()) {
             return;
         }
-        
+
         // Changed to getWorkPath per Bugzilla 35819.
         String workDir = ((StandardContext) context).getWorkPath();
-        if (workDir != null)
+        if (workDir != null) {
             ExpandWar.delete(new File(workDir));
+        }
     }
-    
-    
+
+
     private Server getServer() {
         Container c = context;
         while (c != null && !(c instanceof Engine)) {
             c = c.getParent();
         }
-        
+
         if (c == null) {
             return null;
         }
-        
+
         Service s = ((Engine)c).getService();
-        
+
         if (s == null) {
             return null;
         }
-        
+
         return s.getServer();
     }
 
@@ -1179,25 +1195,27 @@ public class ContextConfig
      * Get config base.
      */
     protected File getConfigBase() {
-        File configBase = 
+        File configBase =
             new File(System.getProperty(Globals.CATALINA_BASE_PROP), "conf");
         if (!configBase.exists()) {
             return null;
         }
         return configBase;
-    }  
+    }
+
 
-    
     protected String getHostConfigPath(String resourceName) {
         StringBuilder result = new StringBuilder();
         Container container = context;
         Container host = null;
         Container engine = null;
         while (container != null) {
-            if (container instanceof Host)
+            if (container instanceof Host) {
                 host = container;
-            if (container instanceof Engine)
+            }
+            if (container instanceof Engine) {
                 engine = container;
+            }
             container = container.getParent();
         }
         if (engine != null) {
@@ -1225,7 +1243,7 @@ public class ContextConfig
          *   everything else takes priority
          * - Mark Servlets as overridable so SCI configuration can replace
          *   configuration from the defaults
-         */ 
+         */
         Set<WebXml> defaults = new HashSet<WebXml>();
         defaults.add(getDefaultWebXmlFragment());
 
@@ -1234,7 +1252,7 @@ public class ContextConfig
         // Parse context level web.xml
         InputSource contextWebXml = getContextWebXmlSource();
         parseWebXml(contextWebXml, webXml, false);
-        
+
         if (webXml.getMajorVersion() >= 3) {
             // Ordering is important here
 
@@ -1249,12 +1267,12 @@ public class ContextConfig
             if  (!webXml.isMetadataComplete()) {
                 // Step 2. Order the fragments.
                 orderedFragments = WebXml.orderWebFragments(webXml, fragments);
-    
+
                 // Step 3. Look for ServletContainerInitializer implementations
                 if (ok) {
                     processServletContainerInitializers(orderedFragments);
                 }
-    
+
                 // Step 4. Process /WEB-INF/classes for annotations
                 // This will add any matching classes to the typeInitializerMap
                 if (ok) {
@@ -1268,20 +1286,20 @@ public class ContextConfig
                                 "contextConfig.webinfClassesUrl"), e);
                     }
                 }
-    
+
                 // Step 5. Process JARs for annotations - only need to process
                 // those fragments we are going to use
                 // This will add any matching classes to the typeInitializerMap
                 if (ok) {
                     processAnnotations(orderedFragments);
                 }
-    
+
                 // Step 6. Merge web-fragment.xml files into the main web.xml
                 // file.
                 if (ok) {
                     ok = webXml.merge(orderedFragments);
                 }
-    
+
                 // Step 7. Apply global defaults
                 // Have to merge defaults before JSP conversion since defaults
                 // provide JSP servlet definition.
@@ -1291,11 +1309,11 @@ public class ContextConfig
                 if (ok) {
                     convertJsps(webXml);
                 }
-                
+
                 // Step 9. Apply merged web.xml to Context
                 if (ok) {
                     webXml.configureContext(context);
-    
+
                     // Step 9a. Make the merged web.xml available to other
                     // components, specifically Jasper, to save those components
                     // from having to re-generate it.
@@ -1312,7 +1330,7 @@ public class ContextConfig
                 webXml.merge(defaults);
                 webXml.configureContext(context);
             }
-            
+
             // Always need to look for static resources
             // Step 10. Look for static resources packaged in JARs
             if (ok) {
@@ -1333,7 +1351,7 @@ public class ContextConfig
                 // See also StandardContext.resourcesStart() for
                 // WEB-INF/classes/META-INF/resources configuration
             }
-            
+
             // Only look for ServletContainerInitializer if metadata is not
             // complete
             if (!webXml.isMetadataComplete()) {
@@ -1341,7 +1359,7 @@ public class ContextConfig
                 // context
                 if (ok) {
                     for (Map.Entry<ServletContainerInitializer,
-                            Set<Class<?>>> entry : 
+                            Set<Class<?>>> entry :
                                 initializerClassMap.entrySet()) {
                         if (entry.getValue().isEmpty()) {
                             context.addServletContainerInitializer(
@@ -1367,13 +1385,13 @@ public class ContextConfig
         Host host = (Host) context.getParent();
 
         DefaultWebXmlCacheEntry entry = hostWebXmlCache.get(host);
-        
+
         InputSource globalWebXml = getGlobalWebXmlSource();
         InputSource hostWebXml = getHostWebXmlSource();
-        
+
         long globalTimeStamp = 0;
         long hostTimeStamp = 0;
-        
+
         if (globalWebXml != null) {
             try {
                 File f = new File(new URI(globalWebXml.getSystemId()));
@@ -1382,7 +1400,7 @@ public class ContextConfig
                 globalTimeStamp = -1;
             }
         }
-        
+
         if (hostWebXml != null) {
             try {
                 File f = new File(new URI(hostWebXml.getSystemId()));
@@ -1391,12 +1409,12 @@ public class ContextConfig
                 hostTimeStamp = -1;
             }
         }
-        
+
         if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp &&
                 entry.getHostTimeStamp() == hostTimeStamp) {
             return entry.getWebXml();
         }
-        
+
         // Parsing global web.xml is relatively expensive. Use a sync block to
         // make sure it only happens once
         synchronized (host) {
@@ -1423,13 +1441,13 @@ public class ContextConfig
             } else {
                 parseWebXml(globalWebXml, webXmlDefaultFragment, false);
             }
-            
+
             // Parse host level web.xml if present
             // Additive apart from welcome pages
             webXmlDefaultFragment.setReplaceWelcomeFiles(true);
-            
+
             parseWebXml(hostWebXml, webXmlDefaultFragment, false);
-            
+
             // Don't update the cache if an error occurs
             if (globalTimeStamp != -1 && hostTimeStamp != -1) {
                 entry = new DefaultWebXmlCacheEntry(webXmlDefaultFragment,
@@ -1470,9 +1488,10 @@ public class ContextConfig
         String jspFile = servletDef.getJspFile();
         if ((jspFile != null) && !jspFile.startsWith("/")) {
             if (context.isServlet22()) {
-                if(log.isDebugEnabled())
+                if(log.isDebugEnabled()) {
                     log.debug(sm.getString("contextConfig.jspFile.warning",
                                        jspFile));
+                }
                 jspFile = "/" + jspFile;
             } else {
                 throw new IllegalArgumentException
@@ -1496,7 +1515,7 @@ public class ContextConfig
      */
     protected void processServletContainerInitializers(
             Set<WebXml> fragments) {
-        
+
         for (WebXml fragment : fragments) {
             URL url = fragment.getURL();
             Jar jar = null;
@@ -1534,13 +1553,13 @@ public class ContextConfig
                     jar.close();
                 }
             }
-            
+
             if (sci == null) {
                 continue;
             }
 
             initializerClassMap.put(sci, new HashSet<Class<?>>());
-            
+
             HandlesTypes ht =
                 sci.getClass().getAnnotation(HandlesTypes.class);
             if (ht != null) {
@@ -1560,12 +1579,12 @@ public class ContextConfig
 
         }
     }
-    
-    
+
+
     /**
      * Extract the name of the ServletContainerInitializer.
-     * 
-     * @param is    The resource where the name is defined 
+     *
+     * @param is    The resource where the name is defined
      * @return      The class name
      * @throws IOException
      */
@@ -1573,7 +1592,7 @@ public class ContextConfig
             InputStream is) throws IOException {
 
         String className = null;
-        
+
         if (is != null) {
             String line = null;
             try {
@@ -1588,7 +1607,7 @@ public class ContextConfig
                 // If it does - ignore & return null
             }
         }
-        
+
         ServletContainerInitializer sci = null;
         try {
             Class<?> clazz = Class.forName(className,true,
@@ -1604,11 +1623,11 @@ public class ContextConfig
             log.error(sm.getString("contextConfig.invalidSci", className), e);
             throw new IOException(e);
         }
-        
+
         return sci;
     }
 
-    
+
     /**
      * Scan JARs that contain web-fragment.xml files that will be used to
      * configure this application to see if they also contain static resources.
@@ -1637,8 +1656,8 @@ public class ContextConfig
             }
         }
     }
-    
-    
+
+
     /**
      * Identify the default web.xml to be used and obtain an input source for
      * it.
@@ -1649,7 +1668,9 @@ public class ContextConfig
             defaultWebXml = ((StandardContext) context).getDefaultWebXml();
         }
         // Set the default if we don't have any overrides
-        if (defaultWebXml == null) getDefaultWebXml();
+        if (defaultWebXml == null) {
+            getDefaultWebXml();
+        }
 
         // Is it explicitly suppressed, e.g. in embedded environment?
         if (Constants.NoDefaultWebXml.equals(defaultWebXml)) {
@@ -1657,20 +1678,21 @@ public class ContextConfig
         }
         return getWebXmlSource(defaultWebXml, getBaseDir());
     }
-    
-    
+
+
     /**
      * Identify the host web.xml to be used and obtain an input source for
      * it.
      */
     protected InputSource getHostWebXmlSource() {
         String resourceName = getHostConfigPath(Constants.HostWebXml);
-        
+
         // In an embedded environment, configBase might not be set
         File configBase = getConfigBase();
-        if (configBase == null)
+        if (configBase == null) {
             return null;
-        
+        }
+
         String basePath = null;
         try {
             basePath = configBase.getCanonicalPath();
@@ -1681,7 +1703,7 @@ public class ContextConfig
 
         return getWebXmlSource(resourceName, basePath);
     }
-    
+
     /**
      * Identify the application web.xml to be used and obtain an input source
      * for it.
@@ -1690,7 +1712,7 @@ public class ContextConfig
         InputStream stream = null;
         InputSource source = null;
         URL url = null;
-        
+
         String altDDName = null;
 
         // Open the application web.xml file, if it exists
@@ -1728,15 +1750,15 @@ public class ContextConfig
             source = new InputSource(url.toExternalForm());
             source.setByteStream(stream);
         }
-        
+
         return source;
     }
-    
+
     /**
-     * 
+     *
      * @param filename  Name of the file (possibly with one or more leading path
      *                  segments) to read
-     * @param path      Location that filename is relative to 
+     * @param path      Location that filename is relative to
      */
     protected InputSource getWebXmlSource(String filename, String path) {
         File file = new File(filename);
@@ -1756,7 +1778,7 @@ public class ContextConfig
                     source =
                         new InputSource(getClass().getClassLoader().getResource(
                                 filename).toURI().toString());
-                } 
+                }
             } else {
                 source = new InputSource(file.getAbsoluteFile().toURI().toString());
                 stream = new FileInputStream(file);
@@ -1777,8 +1799,10 @@ public class ContextConfig
 
     protected void parseWebXml(InputSource source, WebXml dest,
             boolean fragment) {
-        
-        if (source == null) return;
+
+        if (source == null) {
+            return;
+        }
 
         XmlErrorHandler handler = new XmlErrorHandler();
 
@@ -1794,14 +1818,14 @@ public class ContextConfig
             digester = webDigester;
             ruleSet = webRuleSet;
         }
-        
+
         // Sync on the ruleSet since the same ruleSet is shared across all four
         // digesters
         synchronized(ruleSet) {
-            
+
             digester.push(dest);
             digester.setErrorHandler(handler);
-            
+
             if(log.isDebugEnabled()) {
                 log.debug(sm.getString("contextConfig.applicationStart",
                         source.getSystemId()));
@@ -1840,17 +1864,17 @@ public class ContextConfig
      * will be parsed before being added to the map. Every JAR will be added and
      * <code>null</code> will be used if no web-fragment.xml was found. Any JARs
      * known not contain fragments will be skipped.
-     * 
+     *
      * @return A map of JAR name to processed web fragment (if any)
      */
     protected Map<String,WebXml> processJarsForWebFragments() {
-        
+
         JarScanner jarScanner = context.getJarScanner();
         FragmentJarScannerCallback callback = new FragmentJarScannerCallback();
-        
+
         jarScanner.scan(context.getServletContext(),
                 context.getLoader().getClassLoader(), callback, null);
-        
+
         return callback.getFragments();
     }
 
@@ -1888,7 +1912,7 @@ public class ContextConfig
             log.error(sm.getString("contextConfig.unknownUrlProtocol",
                     url.getProtocol(), url));
         }
-        
+
     }
 
 
@@ -1896,10 +1920,10 @@ public class ContextConfig
 
         Jar jar = null;
         InputStream is;
-        
+
         try {
             jar = JarFactory.newInstance(url);
-            
+
             jar.nextEntry();
             String entryName = jar.getEntryName();
             while (entryName != null) {
@@ -1933,7 +1957,7 @@ public class ContextConfig
         }
     }
 
-    
+
     protected void processAnnotationsJndi(URL url, WebXml fragment) {
         try {
             URLConnection urlConn = url.openConnection();
@@ -1943,10 +1967,10 @@ public class ContextConfig
                 sm.getString("contextConfig.jndiUrlNotDirContextConn", url);
                 return;
             }
-            
+
             dcUrlConn = (DirContextURLConnection) urlConn;
             dcUrlConn.setUseCaches(false);
-            
+
             String type = dcUrlConn.getHeaderField(ResourceAttributes.TYPE);
             if (ResourceAttributes.COLLECTION_TYPE.equals(type)) {
                 // Collection
@@ -1956,7 +1980,7 @@ public class ContextConfig
                     URL dirUrl = new URL(url.toString() + '/' + dir);
                     processAnnotationsJndi(dirUrl, fragment);
                 }
-                
+
             } else {
                 // Single file
                 if (url.getPath().endsWith(".class")) {
@@ -1982,10 +2006,10 @@ public class ContextConfig
             log.error(sm.getString("contextConfig.jndiUrl", url), e);
         }
     }
-    
-    
+
+
     protected void processAnnotationsFile(File file, WebXml fragment) {
-        
+
         if (file.isDirectory()) {
             String[] dirs = file.list();
             for (String dir : dirs) {
@@ -2014,14 +2038,14 @@ public class ContextConfig
 
     protected void processAnnotationsStream(InputStream is, WebXml fragment)
             throws ClassFormatException, IOException {
-        
+
         ClassParser parser = new ClassParser(is, null);
         JavaClass clazz = parser.parse();
-        
+
         checkHandlesTypes(clazz);
-        
+
         String className = clazz.getClassName();
-        
+
         AnnotationEntry[] annotationsEntries = clazz.getAnnotationEntries();
 
         for (AnnotationEntry ae : annotationsEntries) {
@@ -2045,14 +2069,15 @@ public class ContextConfig
      * @param javaClass
      */
     protected void checkHandlesTypes(JavaClass javaClass) {
-        
+
         // Skip this if we can
-        if (typeInitializerMap.size() == 0)
+        if (typeInitializerMap.size() == 0) {
             return;
-        
+        }
+
         // No choice but to load the class
         String className = javaClass.getClassName();
-        
+
         Class<?> clazz = null;
         try {
             clazz = context.getLoader().getClassLoader().loadClass(className);
@@ -2079,9 +2104,9 @@ public class ContextConfig
             // Skip
             return;
         }
-        
+
         boolean match = false;
-        
+
         for (Map.Entry<Class<?>, Set<ServletContainerInitializer>> entry :
                 typeInitializerMap.entrySet()) {
             if (entry.getKey().isAnnotation()) {
@@ -2109,7 +2134,7 @@ public class ContextConfig
         if (!internalForm.startsWith("L")) {
             return internalForm;
         }
-        
+
         // Assume starts with L, ends with ; and uses / rather than .
         return internalForm.substring(1,
                 internalForm.length() - 1).replace('/', '.');
@@ -2132,7 +2157,7 @@ public class ContextConfig
             servletName = className;
         }
         ServletDef servletDef = fragment.getServlets().get(servletName);
-        
+
         boolean isWebXMLservletDef;
         if (servletDef == null) {
             servletDef = new ServletDef();
@@ -2374,7 +2399,7 @@ public class ContextConfig
         String[] result = new String[values.size()];
         return values.toArray(result);
     }
-    
+
     protected Map<String,String> processAnnotationWebInitParams(
             ElementValue ev) {
         Map<String, String> result = new HashMap<String,String>();
@@ -2402,16 +2427,16 @@ public class ContextConfig
         }
         return result;
     }
-    
+
     private class FragmentJarScannerCallback implements JarScannerCallback {
 
         private static final String FRAGMENT_LOCATION =
             "META-INF/web-fragment.xml";
-        private Map<String,WebXml> fragments = new HashMap<String,WebXml>();
-        
+        private final Map<String,WebXml> fragments = new HashMap<String,WebXml>();
+
         @Override
         public void scan(JarURLConnection jarConn) throws IOException {
-            
+
             URL url = jarConn.getURL();
             URL resourceURL = jarConn.getJarFileURL();
             Jar jar = null;
@@ -2456,7 +2481,7 @@ public class ContextConfig
 
             InputStream stream = null;
             WebXml fragment = new WebXml();
-            
+
             try {
                 File fragmentFile = new File(file, FRAGMENT_LOCATION);
                 if (fragmentFile.isFile()) {
@@ -2481,7 +2506,7 @@ public class ContextConfig
                 fragments.put(fragment.getName(), fragment);
             }
         }
-        
+
         public Map<String,WebXml> getFragments() {
             return fragments;
         }

==================================================
CometConnectionManagerValve.java
index 3cc31dc892..484085942f 100644
--- a/java/org/apache/catalina/valves/AccessLogValve.java
+++ b/java/org/apache/catalina/valves/AccessLogValve.java
@@ -182,13 +182,6 @@ public class AccessLogValve extends ValveBase implements AccessLog {
     private String directory = "logs";
 
 
-    /**
-     * The descriptive information about this implementation.
-     */
-    protected static final String info =
-        "org.apache.catalina.valves.AccessLogValve/2.2";
-
-
     /**
      * enabled this component
      */
@@ -627,15 +620,6 @@ public class AccessLogValve extends ValveBase implements AccessLog {
     }
 
 
-    /**
-     * Return descriptive information about this implementation.
-     */
-    @Override
-    public String getInfo() {
-        return (info);
-    }
-
-
     /**
      * Return the format pattern.
      */

==================================================
ErrorReportValve.java
index 97954109b1..62072d1924 100644
--- a/java/org/apache/catalina/valves/CometConnectionManagerValve.java
+++ b/java/org/apache/catalina/valves/CometConnectionManagerValve.java
@@ -62,14 +62,6 @@ public class CometConnectionManagerValve extends ValveBase
 
     // ----------------------------------------------------- Instance Variables
 
-
-    /**
-     * The descriptive information related to this implementation.
-     */
-    protected static final String info =
-        "org.apache.catalina.valves.CometConnectionManagerValve/1.0";
-
-
     /**
      * List of current Comet connections.
      */
@@ -154,16 +146,6 @@ public class CometConnectionManagerValve extends ValveBase
 
     // --------------------------------------------------------- Public Methods
 
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-        return (info);
-    }
-
-
     /**
      * Register requests for tracking, whenever needed.
      *

==================================================
ExtendedAccessLogValve.java
index 7fcad1d602..17a68d1748 100644
--- a/java/org/apache/catalina/valves/ErrorReportValve.java
+++ b/java/org/apache/catalina/valves/ErrorReportValve.java
@@ -53,33 +53,9 @@ public class ErrorReportValve extends ValveBase {
         super(true);
     }
 
-    // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * The descriptive information related to this implementation.
-     */
-    private static final String info =
-        "org.apache.catalina.valves.ErrorReportValve/1.0";
-
-
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
-
 
     // --------------------------------------------------------- Public Methods
 
-
     /**
      * Invoke the next Valve in the sequence. When the invoke returns, check
      * the response state, and output an error report is necessary.

==================================================
PersistentValve.java
index c7980fbe72..9661cb87ed 100644
--- a/java/org/apache/catalina/valves/ExtendedAccessLogValve.java
+++ b/java/org/apache/catalina/valves/ExtendedAccessLogValve.java
@@ -144,21 +144,6 @@ public class ExtendedAccessLogValve extends AccessLogValve {
         "org.apache.catalina.valves.ExtendedAccessLogValve/2.1";
 
 
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * Return descriptive information about this implementation.
-     */
-    @Override
-    public String getInfo() {
-        return (extendedAccessLogInfo);
-    }
-
-
-    // --------------------------------------------------------- Public Methods
-
-
     // -------------------------------------------------------- Private Methods
 
     /**

==================================================
RemoteAddrValve.java
index fd1cab8304..367e8d0ca4 100644
--- a/java/org/apache/catalina/valves/PersistentValve.java
+++ b/java/org/apache/catalina/valves/PersistentValve.java
@@ -51,33 +51,9 @@ public class PersistentValve extends ValveBase {
         super(true);
     }
 
-    // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * The descriptive information related to this implementation.
-     */
-    private static final String info =
-        "org.apache.catalina.valves.PersistentValve/1.0";
-
-
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
-
 
     // --------------------------------------------------------- Public Methods
 
-
     /**
      * Select the appropriate child Context to process this request,
      * based on the specified request URI.  If no matching Context can

==================================================
RemoteHostValve.java
index ae7b256a35..cea4f25917 100644
--- a/java/org/apache/catalina/valves/RemoteAddrValve.java
+++ b/java/org/apache/catalina/valves/RemoteAddrValve.java
@@ -32,38 +32,10 @@ import org.apache.catalina.connector.Response;
  * @author Craig R. McClanahan
  * @version $Id$
  */
-
-public final class RemoteAddrValve
-    extends RequestFilterValve {
-
-
-    // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * The descriptive information related to this implementation.
-     */
-    private static final String info =
-        "org.apache.catalina.valves.RemoteAddrValve/1.0";
-
-
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
-
+public final class RemoteAddrValve extends RequestFilterValve {
 
     // --------------------------------------------------------- Public Methods
 
-
     /**
      * Extract the desired request property, and pass it (along with the
      * specified request and response objects) to the protected
@@ -83,6 +55,4 @@ public final class RemoteAddrValve
         process(request.getRequest().getRemoteAddr(), request, response);
 
     }
-
-
 }

==================================================
RemoteIpValve.java
index 19938ecbb1..2e62b74214 100644
--- a/java/org/apache/catalina/valves/RemoteHostValve.java
+++ b/java/org/apache/catalina/valves/RemoteHostValve.java
@@ -32,38 +32,10 @@ import org.apache.catalina.connector.Response;
  * @author Craig R. McClanahan
  * @version $Id$
  */
-
-public final class RemoteHostValve
-    extends RequestFilterValve {
-
-
-    // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * The descriptive information related to this implementation.
-     */
-    private static final String info =
-        "org.apache.catalina.valves.RemoteHostValve/1.0";
-
-
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
-
+public final class RemoteHostValve extends RequestFilterValve {
 
     // --------------------------------------------------------- Public Methods
 
-
     /**
      * Extract the desired request property, and pass it (along with the
      * specified request and response objects) to the protected
@@ -83,6 +55,4 @@ public final class RemoteHostValve
         process(request.getRequest().getRemoteHost(), request, response);
 
     }
-
-
 }

==================================================
RequestFilterValve.java
index 58eeeb6589..a37d6151c2 100644
--- a/java/org/apache/catalina/valves/RemoteIpValve.java
+++ b/java/org/apache/catalina/valves/RemoteIpValve.java
@@ -352,11 +352,6 @@ public class RemoteIpValve extends ValveBase {
      */
     private static final Pattern commaSeparatedValuesPattern = Pattern.compile("\\s*,\\s*");
 
-    /**
-     * The descriptive information related to this implementation.
-     */
-    private static final String info = "org.apache.catalina.valves.RemoteIpValve/1.0";
-
     /**
      * Logger
      */
@@ -494,14 +489,6 @@ public class RemoteIpValve extends ValveBase {
         this.portHeader = portHeader;
     }
 
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-        return info;
-    }
-
     /**
      * @see #setInternalProxies(String)
      * @return Regular expression that defines the internal proxies

==================================================
SemaphoreValve.java
index b98f322157..03384093b4 100644
--- a/java/org/apache/catalina/valves/RequestFilterValve.java
+++ b/java/org/apache/catalina/valves/RequestFilterValve.java
@@ -64,19 +64,9 @@ public abstract class RequestFilterValve extends ValveBase {
         super(true);
     }
 
-    // ----------------------------------------------------- Class Variables
-
-
-    /**
-     * The descriptive information related to this implementation.
-     */
-    private static final String info =
-        "org.apache.catalina.valves.RequestFilterValve/1.0";
-
 
     // ----------------------------------------------------- Instance Variables
 
-
     /**
      * The regular expression used to test for allowed requests.
      */
@@ -150,20 +140,8 @@ public abstract class RequestFilterValve extends ValveBase {
     }
 
 
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-
     // --------------------------------------------------------- Public Methods
 
-
     /**
      * Extract the desired request property, and pass it (along with the
      * specified request and response objects) to the protected

==================================================
StuckThreadDetectionValve.java
index aed952e907..3ff60806c3 100644
--- a/java/org/apache/catalina/valves/SemaphoreValve.java
+++ b/java/org/apache/catalina/valves/SemaphoreValve.java
@@ -46,15 +46,8 @@ public class SemaphoreValve extends ValveBase {
         super(true);
     }
 
-    // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * The descriptive information related to this implementation.
-     */
-    private static final String info =
-        "org.apache.catalina.valves.SemaphoreValve/1.0";
 
+    // ----------------------------------------------------- Instance Variables
 
     /**
      * Semaphore.
@@ -131,16 +124,6 @@ public class SemaphoreValve extends ValveBase {
 
     // --------------------------------------------------------- Public Methods
 
-
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-        return (info);
-    }
-
-
     /**
      * Do concurrency control on the request using the semaphore.
      *

==================================================
ValveBase.java
index 8d6af6a412..773a8f623a 100644
--- a/java/org/apache/catalina/valves/StuckThreadDetectionValve.java
+++ b/java/org/apache/catalina/valves/StuckThreadDetectionValve.java
@@ -44,11 +44,6 @@ import org.apache.tomcat.util.res.StringManager;
  */
 public class StuckThreadDetectionValve extends ValveBase {
 
-    /**
-     * The descriptive information related to this implementation.
-     */
-    private static final String info =
-            "org.apache.catalina.valves.StuckThreadDetectionValve/1.0";
     /**
      * Logger
      */
@@ -123,14 +118,6 @@ public class StuckThreadDetectionValve extends ValveBase {
         }
     }
 
-    /**
-     * Return descriptive information about this Valve implementation.
-     */
-    @Override
-    public String getInfo() {
-        return info;
-    }
-
     private void notifyStuckThreadDetected(MonitoredThread monitoredThread,
         long activeTime, int numStuckThreads) {
         if (log.isWarnEnabled()) {

==================================================
