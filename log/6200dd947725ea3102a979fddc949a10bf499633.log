6200dd947725ea3102a979fddc949a10bf499633
==================================================
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=51557
==================================================
Mark Emlyn
==================================================
Wed Jul 27 09:10:11 2011 +0000
==================================================
AbstractInputBuffer.java
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=51557
Ignore HTTP headers that do not comply with RFC 2616 and use header names that are not tokens.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1151394 13f79535-47bb-0310-9956-ffa450edef68



==================================================
InternalAprInputBuffer.java
index aab5a4db48..7788b87d78 100644
--- a/java/org/apache/coyote/http11/AbstractInputBuffer.java
+++ b/java/org/apache/coyote/http11/AbstractInputBuffer.java
@@ -27,20 +27,7 @@ import org.apache.tomcat.util.res.StringManager;
 
 public abstract class AbstractInputBuffer implements InputBuffer{
 
-    public abstract boolean parseRequestLine(boolean useAvailableDataOnly) throws IOException;
-    
-    public abstract boolean parseHeaders() throws IOException;
-    
-    protected abstract boolean fill(boolean block) throws IOException; 
-
-    // -------------------------------------------------------------- Constants
-
-
-    // ----------------------------------------------------------- Constructors
-
-
-    // -------------------------------------------------------------- Variables
-
+    protected static final boolean[] HTTP_TOKEN_CHAR = new boolean[128];
 
     /**
      * The string manager for this package.
@@ -49,7 +36,55 @@ public abstract class AbstractInputBuffer implements InputBuffer{
         StringManager.getManager(Constants.Package);
 
 
-    // ----------------------------------------------------- Instance Variables
+    static {
+        for (int i = 0; i < 128; i++) {
+            if (i < 32) {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == 127) {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == '(') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == ')') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == '<') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == '>') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == '@') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == ',') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == ';') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == ':') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == '\\') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == '\"') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == '/') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == '[') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == ']') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == '?') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == '=') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == '{') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == '}') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == ' ') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else if (i == '\t') {
+                HTTP_TOKEN_CHAR[i] = false;
+            } else {
+                HTTP_TOKEN_CHAR[i] = true;
+            }
+        }
+    }
 
 
     /**
@@ -217,6 +252,13 @@ public abstract class AbstractInputBuffer implements InputBuffer{
     }
 
 
+    public abstract boolean parseRequestLine(boolean useAvailableDataOnly) throws IOException;
+    
+    public abstract boolean parseHeaders() throws IOException;
+    
+    protected abstract boolean fill(boolean block) throws IOException; 
+
+
     // --------------------------------------------------------- Public Methods
 
 
@@ -308,6 +350,4 @@ public abstract class AbstractInputBuffer implements InputBuffer{
             return activeFilters[lastActiveFilter].doRead(chunk,req);
 
     }
-
-    
 }

==================================================
InternalInputBuffer.java
index 8c302456ab..12dbb12fe8 100644
--- a/java/org/apache/coyote/http11/InternalAprInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalAprInputBuffer.java
@@ -14,17 +14,18 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
-
 package org.apache.coyote.http11;
 
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.SocketTimeoutException;
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 
 import org.apache.coyote.InputBuffer;
 import org.apache.coyote.Request;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.jni.Socket;
 import org.apache.tomcat.jni.Status;
 import org.apache.tomcat.util.buf.ByteChunk;
@@ -38,9 +39,8 @@ import org.apache.tomcat.util.buf.MessageBytes;
  */
 public class InternalAprInputBuffer extends AbstractInputBuffer {
 
-
-    // -------------------------------------------------------------- Constants
-
+    private static final Log log =
+        LogFactory.getLog(InternalAprInputBuffer.class);
 
     // ----------------------------------------------------------- Constructors
 
@@ -394,6 +394,11 @@ public class InternalAprInputBuffer extends AbstractInputBuffer {
             if (buf[pos] == Constants.COLON) {
                 colon = true;
                 headerValue = headers.addValue(buf, start, pos - start);
+            } else if (!HTTP_TOKEN_CHAR[buf[pos]]) {
+                // If a non-token header is detected, skip the line and
+                // ignore the header
+                skipLine(start);
+                return true;
             }
             chr = buf[pos];
             if ((chr >= Constants.A) && (chr <= Constants.Z)) {
@@ -496,6 +501,38 @@ public class InternalAprInputBuffer extends AbstractInputBuffer {
     }
 
     
+    private void skipLine(int start) throws IOException {
+        boolean eol = false;
+        int lastRealByte = start;
+        if (pos - 1 > start) {
+            lastRealByte = pos - 1;
+        }
+        
+        while (!eol) {
+
+            // Read new bytes if needed
+            if (pos >= lastValid) {
+                if (!fill())
+                    throw new EOFException(sm.getString("iib.eof.error"));
+            }
+
+            if (buf[pos] == Constants.CR) {
+                // Skip
+            } else if (buf[pos] == Constants.LF) {
+                eol = true;
+            } else {
+                lastRealByte = pos;
+            }
+            pos++;
+        }
+
+        if (log.isDebugEnabled()) {
+            log.debug(sm.getString("iib.invalidheader", new String(buf, start,
+                    lastRealByte - start + 1, Charset.forName("ISO-8859-1"))));
+        }
+    }
+    
+    
     /**
      * Available bytes (note that due to encoding, this may not correspond )
      */

==================================================
InternalNioInputBuffer.java
index 101a96cc42..081fa757a4 100644
--- a/java/org/apache/coyote/http11/InternalInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalInputBuffer.java
@@ -14,15 +14,16 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
-
 package org.apache.coyote.http11;
 
 import java.io.EOFException;
 import java.io.IOException;
+import java.nio.charset.Charset;
 
 import org.apache.coyote.InputBuffer;
 import org.apache.coyote.Request;
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.buf.MessageBytes;
 
@@ -34,6 +35,9 @@ import org.apache.tomcat.util.buf.MessageBytes;
  */
 public class InternalInputBuffer extends AbstractInputBuffer {
 
+    private static final Log log = LogFactory.getLog(InternalInputBuffer.class);
+
+
     /**
      * Default constructor.
      */
@@ -316,7 +320,13 @@ public class InternalInputBuffer extends AbstractInputBuffer {
             if (buf[pos] == Constants.COLON) {
                 colon = true;
                 headerValue = headers.addValue(buf, start, pos - start);
+            } else if (!HTTP_TOKEN_CHAR[buf[pos]]) {
+                // If a non-token header is detected, skip the line and
+                // ignore the header
+                skipLine(start);
+                return true;
             }
+
             chr = buf[pos];
             if ((chr >= Constants.A) && (chr <= Constants.Z)) {
                 buf[pos] = (byte) (chr - Constants.LC_OFFSET);
@@ -421,6 +431,37 @@ public class InternalInputBuffer extends AbstractInputBuffer {
     // ------------------------------------------------------ Protected Methods
 
 
+    private void skipLine(int start) throws IOException {
+        boolean eol = false;
+        int lastRealByte = start;
+        if (pos - 1 > start) {
+            lastRealByte = pos - 1;
+        }
+        
+        while (!eol) {
+
+            // Read new bytes if needed
+            if (pos >= lastValid) {
+                if (!fill())
+                    throw new EOFException(sm.getString("iib.eof.error"));
+            }
+
+            if (buf[pos] == Constants.CR) {
+                // Skip
+            } else if (buf[pos] == Constants.LF) {
+                eol = true;
+            } else {
+                lastRealByte = pos;
+            }
+            pos++;
+        }
+
+        if (log.isDebugEnabled()) {
+            log.debug(sm.getString("iib.invalidheader", new String(buf, start,
+                    lastRealByte - start + 1, Charset.forName("ISO-8859-1"))));
+        }
+    }
+
     /**
      * Fill the internal buffer using data from the underlying input stream.
      * 

==================================================
TestInternalInputBuffer.java
index 00916296d4..e4074f3ab5 100644
--- a/java/org/apache/coyote/http11/LocalStrings.properties
+++ b/java/org/apache/coyote/http11/LocalStrings.properties
@@ -38,5 +38,6 @@ http11processor.comet.notsupported=The Comet protocol is not supported by this c
 http11processor.sendfile.error=Error sending data using sendfile. May be caused by invalid request attributes for start/end points
 
 iib.eof.error=Unexpected EOF read on the socket
-iib.requestheadertoolarge.error=Request header is too large
+iib.invalidheader=The HTTP header line [{0}] does not conform to RFC 2616 and has been ignored.
 iib.invalidmethod=Invalid character (CR or LF) found in method name
+iib.requestheadertoolarge.error=Request header is too large

==================================================
