dbeb843a79cf3976351b5c62d2ff0004f5b765ed
==================================================
Fix line ends in the files.
==================================================
Konstantin Kolinko
==================================================
Thu Feb 9 22:50:52 2012 +0000
==================================================
Constants.java
Fix line ends in the files.

This is technical commit to recover from eoln brokeness from commits via svn-git intergration. See thread on dev@. This commit should not change anything besides the line ends.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1242584 13f79535-47bb-0310-9956-ffa450edef68



==================================================
UpgradeAprProcessor.java
index 66c754be36..d3764a766a 100644
--- a/java/org/apache/coyote/http11/upgrade/Constants.java
+++ b/java/org/apache/coyote/http11/upgrade/Constants.java
@@ -1,22 +1,22 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-public class Constants {
-
-    public static final String Package = "org.apache.coyote.http11.upgrade";
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+public class Constants {
+
+    public static final String Package = "org.apache.coyote.http11.upgrade";
+}

==================================================
UpgradeBioProcessor.java
index e484a9b77d..fd3391850d 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeAprProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeAprProcessor.java
@@ -1,73 +1,73 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-
-import org.apache.tomcat.jni.Socket;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-/**
- * Implementation note: The need to extend Http11Processor could probably be
- * removed if the Processor interface was expanded to cover all of the methods
- * required by the AbstractProtocol. That would simplify the code and further
- * reduce the size of instances of this class.
- */
-public class UpgradeAprProcessor extends UpgradeProcessor<Long> {
-
-    long socket;
-
-
-    public UpgradeAprProcessor(SocketWrapper<Long> wrapper,
-            UpgradeInbound upgradeInbound) {
-        super(upgradeInbound);
-
-        this.socket = wrapper.getSocket().longValue();
-    }
-
-
-    /*
-     * Output methods
-     */
-    @Override
-    public void flush() throws IOException {
-        // NOOP
-    }
-
-
-    @Override
-    public void write(int b) throws IOException {
-        Socket.send(socket, new byte[] {(byte) b}, 0, 1);
-    }
-
-
-    /*
-     * Input methods
-     */
-    @Override
-    public int read() throws IOException {
-        byte[] bytes = new byte[1];
-        Socket.recv(socket, bytes, 0, 1);
-        return bytes[0];
-    }
-
-
-    @Override
-    public int read(byte[] bytes) throws IOException {
-        return Socket.recv(socket, bytes, 0, bytes.length);
-    }
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.IOException;
+
+import org.apache.tomcat.jni.Socket;
+import org.apache.tomcat.util.net.SocketWrapper;
+
+/**
+ * Implementation note: The need to extend Http11Processor could probably be
+ * removed if the Processor interface was expanded to cover all of the methods
+ * required by the AbstractProtocol. That would simplify the code and further
+ * reduce the size of instances of this class.
+ */
+public class UpgradeAprProcessor extends UpgradeProcessor<Long> {
+
+    long socket;
+
+
+    public UpgradeAprProcessor(SocketWrapper<Long> wrapper,
+            UpgradeInbound upgradeInbound) {
+        super(upgradeInbound);
+
+        this.socket = wrapper.getSocket().longValue();
+    }
+
+
+    /*
+     * Output methods
+     */
+    @Override
+    public void flush() throws IOException {
+        // NOOP
+    }
+
+
+    @Override
+    public void write(int b) throws IOException {
+        Socket.send(socket, new byte[] {(byte) b}, 0, 1);
+    }
+
+
+    /*
+     * Input methods
+     */
+    @Override
+    public int read() throws IOException {
+        byte[] bytes = new byte[1];
+        Socket.recv(socket, bytes, 0, 1);
+        return bytes[0];
+    }
+
+
+    @Override
+    public int read(byte[] bytes) throws IOException {
+        return Socket.recv(socket, bytes, 0, bytes.length);
+    }
+}

==================================================
UpgradeNioProcessor.java
index e07b4f3b69..4910646b1e 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeBioProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeBioProcessor.java
@@ -1,74 +1,74 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Socket;
-
-import org.apache.tomcat.util.net.SocketWrapper;
-
-/**
- * Implementation note: The need to extend Http11Processor could probably be
- * removed if the Processor interface was expanded to cover all of the methods
- * required by the AbstractProtocol. That would simplify the code and further
- * reduce the size of instances of this class.
- */
-public class UpgradeBioProcessor extends UpgradeProcessor<Socket> {
-
-    private InputStream inputStream;
-    private OutputStream outputStream;
-
-    public UpgradeBioProcessor(SocketWrapper<Socket> wrapper,
-            UpgradeInbound upgradeInbound) throws IOException {
-        super(upgradeInbound);
-
-        this.inputStream = wrapper.getSocket().getInputStream();
-        this.outputStream = wrapper.getSocket().getOutputStream();
-    }
-
-
-    /*
-     * Output methods
-     */
-    @Override
-    public void flush() throws IOException {
-        outputStream.flush();
-    }
-
-
-    @Override
-    public void write(int b) throws IOException {
-        outputStream.write(b);
-    }
-
-
-    /*
-     * Input methods
-     */
-    @Override
-    public int read() throws IOException {
-        return inputStream.read();
-    }
-
-
-    @Override
-    public int read(byte[] bytes) throws IOException {
-        return inputStream.read(bytes);
-    }
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.Socket;
+
+import org.apache.tomcat.util.net.SocketWrapper;
+
+/**
+ * Implementation note: The need to extend Http11Processor could probably be
+ * removed if the Processor interface was expanded to cover all of the methods
+ * required by the AbstractProtocol. That would simplify the code and further
+ * reduce the size of instances of this class.
+ */
+public class UpgradeBioProcessor extends UpgradeProcessor<Socket> {
+
+    private InputStream inputStream;
+    private OutputStream outputStream;
+
+    public UpgradeBioProcessor(SocketWrapper<Socket> wrapper,
+            UpgradeInbound upgradeInbound) throws IOException {
+        super(upgradeInbound);
+
+        this.inputStream = wrapper.getSocket().getInputStream();
+        this.outputStream = wrapper.getSocket().getOutputStream();
+    }
+
+
+    /*
+     * Output methods
+     */
+    @Override
+    public void flush() throws IOException {
+        outputStream.flush();
+    }
+
+
+    @Override
+    public void write(int b) throws IOException {
+        outputStream.write(b);
+    }
+
+
+    /*
+     * Input methods
+     */
+    @Override
+    public int read() throws IOException {
+        return inputStream.read();
+    }
+
+
+    @Override
+    public int read(byte[] bytes) throws IOException {
+        return inputStream.read(bytes);
+    }
+}

==================================================
UpgradeProcessor.java
index 487235274b..3871d5d8d8 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeNioProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeNioProcessor.java
@@ -1,179 +1,179 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.nio.channels.Selector;
-
-import org.apache.tomcat.util.net.NioChannel;
-import org.apache.tomcat.util.net.NioEndpoint;
-import org.apache.tomcat.util.net.NioSelectorPool;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-/**
- * Implementation note: The need to extend Http11Processor could probably be
- * removed if the Processor interface was expanded to cover all of the methods
- * required by the AbstractProtocol. That would simplify the code and further
- * reduce the size of instances of this class.
- */
-public class UpgradeNioProcessor extends UpgradeProcessor<NioChannel> {
-
-    private NioChannel nioChannel;
-    private NioSelectorPool pool;
-
-    public UpgradeNioProcessor(SocketWrapper<NioChannel> wrapper,
-            UpgradeInbound upgradeInbound, NioSelectorPool pool) {
-        super(upgradeInbound);
-
-        this.nioChannel = wrapper.getSocket();
-        this.pool = pool;
-    }
-
-
-    /*
-     * Output methods
-     */
-    @Override
-    public void flush() throws IOException {
-        NioEndpoint.KeyAttachment att =
-                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
-        if (att == null) {
-            throw new IOException("Key must be cancelled");
-        }
-        long writeTimeout = att.getTimeout();
-        Selector selector = null;
-        try {
-            selector = pool.get();
-        } catch ( IOException x ) {
-            //ignore
-        }
-        try {
-            do {
-                if (nioChannel.flush(true, selector, writeTimeout)) {
-                    break;
-                }
-            } while (true);
-        } finally {
-            if (selector != null) {
-                pool.put(selector);
-            }
-        }
-    }
-
-    @Override
-    public void write(int b) throws IOException {
-        writeToSocket(new byte[] {(byte) b});
-    }
-
-    /*
-     * Input methods
-     */
-    @Override
-    public int read() throws IOException {
-        byte[] bytes = new byte[1];
-        readSocket(true, bytes, 0, 1);
-        return bytes[0];
-    }
-
-    @Override
-    public int read(byte[] bytes) throws IOException {
-        return readSocket(true, bytes, 0, bytes.length);
-    }
-
-
-    /*
-     * Adapted from the NioInputBuffer.
-     */
-    private int readSocket(boolean block, byte[] bytes, int offset, int len)
-            throws IOException {
-
-        int nRead = 0;
-        nioChannel.getBufHandler().getReadBuffer().clear();
-        nioChannel.getBufHandler().getReadBuffer().limit(len);
-        if (block) {
-            Selector selector = null;
-            try {
-                selector = pool.get();
-            } catch ( IOException x ) {
-                // Ignore
-            }
-            try {
-                NioEndpoint.KeyAttachment att =
-                        (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
-                if (att == null) {
-                    throw new IOException("Key must be cancelled.");
-                }
-                nRead = pool.read(nioChannel.getBufHandler().getReadBuffer(),
-                        nioChannel, selector, att.getTimeout());
-            } catch (EOFException eof) {
-                nRead = -1;
-            } finally {
-                if (selector != null) {
-                    pool.put(selector);
-                }
-            }
-        } else {
-            nRead = nioChannel.read(nioChannel.getBufHandler().getReadBuffer());
-        }
-        if (nRead > 0) {
-            nioChannel.getBufHandler().getReadBuffer().flip();
-            nioChannel.getBufHandler().getReadBuffer().limit(nRead);
-            nioChannel.getBufHandler().getReadBuffer().get(bytes, offset, nRead);
-            return nRead;
-        } else if (nRead == -1) {
-            //return false;
-            throw new EOFException(sm.getString("nio.eof.error"));
-        } else {
-            return 0;
-        }
-    }
-
-
-    /*
-     * Adapted from the NioOutputBuffer
-     */
-    private synchronized int writeToSocket(byte[] bytes) throws IOException {
-
-        nioChannel.getBufHandler().getWriteBuffer().clear();
-        nioChannel.getBufHandler().getWriteBuffer().put(bytes);
-        nioChannel.getBufHandler().getWriteBuffer().flip();
-
-        int written = 0;
-        NioEndpoint.KeyAttachment att =
-                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
-        if (att == null) {
-            throw new IOException("Key must be cancelled");
-        }
-        long writeTimeout = att.getTimeout();
-        Selector selector = null;
-        try {
-            selector = pool.get();
-        } catch ( IOException x ) {
-            //ignore
-        }
-        try {
-            written = pool.write(nioChannel.getBufHandler().getWriteBuffer(),
-                    nioChannel, selector, writeTimeout, true);
-        } finally {
-            if (selector != null) {
-                pool.put(selector);
-            }
-        }
-        return written;
-    }
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.channels.Selector;
+
+import org.apache.tomcat.util.net.NioChannel;
+import org.apache.tomcat.util.net.NioEndpoint;
+import org.apache.tomcat.util.net.NioSelectorPool;
+import org.apache.tomcat.util.net.SocketWrapper;
+
+/**
+ * Implementation note: The need to extend Http11Processor could probably be
+ * removed if the Processor interface was expanded to cover all of the methods
+ * required by the AbstractProtocol. That would simplify the code and further
+ * reduce the size of instances of this class.
+ */
+public class UpgradeNioProcessor extends UpgradeProcessor<NioChannel> {
+
+    private NioChannel nioChannel;
+    private NioSelectorPool pool;
+
+    public UpgradeNioProcessor(SocketWrapper<NioChannel> wrapper,
+            UpgradeInbound upgradeInbound, NioSelectorPool pool) {
+        super(upgradeInbound);
+
+        this.nioChannel = wrapper.getSocket();
+        this.pool = pool;
+    }
+
+
+    /*
+     * Output methods
+     */
+    @Override
+    public void flush() throws IOException {
+        NioEndpoint.KeyAttachment att =
+                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
+        if (att == null) {
+            throw new IOException("Key must be cancelled");
+        }
+        long writeTimeout = att.getTimeout();
+        Selector selector = null;
+        try {
+            selector = pool.get();
+        } catch ( IOException x ) {
+            //ignore
+        }
+        try {
+            do {
+                if (nioChannel.flush(true, selector, writeTimeout)) {
+                    break;
+                }
+            } while (true);
+        } finally {
+            if (selector != null) {
+                pool.put(selector);
+            }
+        }
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+        writeToSocket(new byte[] {(byte) b});
+    }
+
+    /*
+     * Input methods
+     */
+    @Override
+    public int read() throws IOException {
+        byte[] bytes = new byte[1];
+        readSocket(true, bytes, 0, 1);
+        return bytes[0];
+    }
+
+    @Override
+    public int read(byte[] bytes) throws IOException {
+        return readSocket(true, bytes, 0, bytes.length);
+    }
+
+
+    /*
+     * Adapted from the NioInputBuffer.
+     */
+    private int readSocket(boolean block, byte[] bytes, int offset, int len)
+            throws IOException {
+
+        int nRead = 0;
+        nioChannel.getBufHandler().getReadBuffer().clear();
+        nioChannel.getBufHandler().getReadBuffer().limit(len);
+        if (block) {
+            Selector selector = null;
+            try {
+                selector = pool.get();
+            } catch ( IOException x ) {
+                // Ignore
+            }
+            try {
+                NioEndpoint.KeyAttachment att =
+                        (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
+                if (att == null) {
+                    throw new IOException("Key must be cancelled.");
+                }
+                nRead = pool.read(nioChannel.getBufHandler().getReadBuffer(),
+                        nioChannel, selector, att.getTimeout());
+            } catch (EOFException eof) {
+                nRead = -1;
+            } finally {
+                if (selector != null) {
+                    pool.put(selector);
+                }
+            }
+        } else {
+            nRead = nioChannel.read(nioChannel.getBufHandler().getReadBuffer());
+        }
+        if (nRead > 0) {
+            nioChannel.getBufHandler().getReadBuffer().flip();
+            nioChannel.getBufHandler().getReadBuffer().limit(nRead);
+            nioChannel.getBufHandler().getReadBuffer().get(bytes, offset, nRead);
+            return nRead;
+        } else if (nRead == -1) {
+            //return false;
+            throw new EOFException(sm.getString("nio.eof.error"));
+        } else {
+            return 0;
+        }
+    }
+
+
+    /*
+     * Adapted from the NioOutputBuffer
+     */
+    private synchronized int writeToSocket(byte[] bytes) throws IOException {
+
+        nioChannel.getBufHandler().getWriteBuffer().clear();
+        nioChannel.getBufHandler().getWriteBuffer().put(bytes);
+        nioChannel.getBufHandler().getWriteBuffer().flip();
+
+        int written = 0;
+        NioEndpoint.KeyAttachment att =
+                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
+        if (att == null) {
+            throw new IOException("Key must be cancelled");
+        }
+        long writeTimeout = att.getTimeout();
+        Selector selector = null;
+        try {
+            selector = pool.get();
+        } catch ( IOException x ) {
+            //ignore
+        }
+        try {
+            written = pool.write(nioChannel.getBufHandler().getWriteBuffer(),
+                    nioChannel, selector, writeTimeout, true);
+        } finally {
+            if (selector != null) {
+                pool.put(selector);
+            }
+        }
+        return written;
+    }
+}

==================================================
