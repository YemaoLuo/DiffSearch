ea4581ddf46002a489d3e4667e50cba056dd6eeb
==================================================
Tab police and trailing whitespace deletion
==================================================
Rainer Jung
==================================================
Thu Sep 18 16:48:10 2008 +0000
==================================================
MethodExpressionLiteral.java
Tab police and trailing whitespace deletion
for package a.o.el (except for generated java files).


git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@696702 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ValueExpressionLiteral.java
index 652a3e823d..b0de8cb344 100644
--- a/java/org/apache/el/MethodExpressionLiteral.java
+++ b/java/org/apache/el/MethodExpressionLiteral.java
@@ -36,13 +36,13 @@ public class MethodExpressionLiteral extends MethodExpression implements Externa
     private Class expectedType;
 
     private String expr;
-    
+
     private Class[] paramTypes;
-    
+
     public MethodExpressionLiteral() {
         // do nothing
     }
-    
+
     public MethodExpressionLiteral(String expr, Class expectedType, Class[] paramTypes) {
         this.expr = expr;
         this.expectedType = expectedType;

==================================================
ELArithmetic.java
index 2221b88669..1477b4ce1f 100644
--- a/java/org/apache/el/ValueExpressionLiteral.java
+++ b/java/org/apache/el/ValueExpressionLiteral.java
@@ -44,7 +44,7 @@ public final class ValueExpressionLiteral extends ValueExpression implements
     public ValueExpressionLiteral() {
         super();
     }
-    
+
     public ValueExpressionLiteral(Object value, Class expectedType) {
         this.value = value;
         this.expectedType = expectedType;

==================================================
ELSupport.java
index 404a6c5d25..66a208d026 100644
--- a/java/org/apache/el/lang/ELArithmetic.java
+++ b/java/org/apache/el/lang/ELArithmetic.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -110,12 +110,12 @@ public abstract class ELArithmetic {
     public final static class DoubleDelegate extends ELArithmetic {
 
         protected Number add(Number num0, Number num1) {
-        	// could only be one of these
-        	if (num0 instanceof BigDecimal) {
-        		return ((BigDecimal) num0).add(new BigDecimal(num1.doubleValue()));
-        	} else if (num1 instanceof BigDecimal) {
-        		return ((new BigDecimal(num0.doubleValue()).add((BigDecimal) num1)));
-        	}
+            // could only be one of these
+            if (num0 instanceof BigDecimal) {
+                return ((BigDecimal) num0).add(new BigDecimal(num1.doubleValue()));
+            } else if (num1 instanceof BigDecimal) {
+                return ((new BigDecimal(num0.doubleValue()).add((BigDecimal) num1)));
+            }
             return new Double(num0.doubleValue() + num1.doubleValue());
         }
 
@@ -123,7 +123,7 @@ public abstract class ELArithmetic {
             if (num instanceof Double)
                 return num;
             if (num instanceof BigInteger)
-            	return new BigDecimal((BigInteger) num);
+                return new BigDecimal((BigInteger) num);
             return new Double(num.doubleValue());
         }
 
@@ -140,22 +140,22 @@ public abstract class ELArithmetic {
         }
 
         protected Number subtract(Number num0, Number num1) {
-        	// could only be one of these
-        	if (num0 instanceof BigDecimal) {
-        		return ((BigDecimal) num0).subtract(new BigDecimal(num1.doubleValue()));
-        	} else if (num1 instanceof BigDecimal) {
-        		return ((new BigDecimal(num0.doubleValue()).subtract((BigDecimal) num1)));
-        	}
+            // could only be one of these
+            if (num0 instanceof BigDecimal) {
+                return ((BigDecimal) num0).subtract(new BigDecimal(num1.doubleValue()));
+            } else if (num1 instanceof BigDecimal) {
+                return ((new BigDecimal(num0.doubleValue()).subtract((BigDecimal) num1)));
+            }
             return new Double(num0.doubleValue() - num1.doubleValue());
         }
 
         protected Number multiply(Number num0, Number num1) {
-        	// could only be one of these
-        	if (num0 instanceof BigDecimal) {
-        		return ((BigDecimal) num0).multiply(new BigDecimal(num1.doubleValue()));
-        	} else if (num1 instanceof BigDecimal) {
-        		return ((new BigDecimal(num0.doubleValue()).multiply((BigDecimal) num1)));
-        	}
+            // could only be one of these
+            if (num0 instanceof BigDecimal) {
+                return ((BigDecimal) num0).multiply(new BigDecimal(num1.doubleValue()));
+            } else if (num1 instanceof BigDecimal) {
+                return ((new BigDecimal(num0.doubleValue()).multiply((BigDecimal) num1)));
+            }
             return new Double(num0.doubleValue() * num1.doubleValue());
         }
 
@@ -270,7 +270,7 @@ public abstract class ELArithmetic {
         else if (DOUBLE.matches(obj0, obj1))
             delegate = DOUBLE;
         else if (BIGINTEGER.matches(obj0, obj1))
-            delegate = BIGINTEGER;   
+            delegate = BIGINTEGER;
         else
             delegate = LONG;
 
@@ -332,7 +332,7 @@ public abstract class ELArithmetic {
     }
 
     /**
-     * 
+     *
      */
     protected ELArithmetic() {
         super();
@@ -349,7 +349,7 @@ public abstract class ELArithmetic {
     protected abstract Number coerce(final Number num);
 
     protected final Number coerce(final Object obj) {
-        
+
         if (isNumber(obj)) {
             return coerce((Number) obj);
         }

==================================================
EvaluationContext.java
index 5bddf4fc91..51e3649902 100644
--- a/java/org/apache/el/lang/ELSupport.java
+++ b/java/org/apache/el/lang/ELSupport.java
@@ -137,7 +137,7 @@ public class ELSupport {
             return obj0.equals(obj1);
         }
     }
-    
+
     /**
      * @param obj
      * @param type

==================================================
ExpressionBuilder.java
index 68d77a9028..94b698045c 100644
--- a/java/org/apache/el/lang/EvaluationContext.java
+++ b/java/org/apache/el/lang/EvaluationContext.java
@@ -70,12 +70,12 @@ public final class EvaluationContext extends ELContext {
     public void setPropertyResolved(boolean resolved) {
         this.elContext.setPropertyResolved(resolved);
     }
-    
-    public Locale getLocale() { 
+
+    public Locale getLocale() {
         return this.elContext.getLocale();
         }
 
-    public void setLocale(Locale locale) { 
+    public void setLocale(Locale locale) {
         this.elContext.setLocale(locale);
     }
 }

==================================================
FunctionMapperFactory.java
index 24eb75ad47..f6546aa584 100644
--- a/java/org/apache/el/lang/ExpressionBuilder.java
+++ b/java/org/apache/el/lang/ExpressionBuilder.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -50,160 +50,160 @@ import org.apache.el.util.MessageFactory;
  */
 public final class ExpressionBuilder implements NodeVisitor {
 
-	private static final ConcurrentCache cache = new ConcurrentCache(5000);
-
-	private FunctionMapper fnMapper;
-
-	private VariableMapper varMapper;
-
-	private String expression;
-
-	/**
-	 * 
-	 */
-	public ExpressionBuilder(String expression, ELContext ctx)
-			throws ELException {
-		this.expression = expression;
-
-		FunctionMapper ctxFn = ctx.getFunctionMapper();
-		VariableMapper ctxVar = ctx.getVariableMapper();
-
-		if (ctxFn != null) {
-			this.fnMapper = new FunctionMapperFactory(ctxFn);
-		}
-		if (ctxVar != null) {
-			this.varMapper = new VariableMapperFactory(ctxVar);
-		}
-	}
-
-	public final static Node createNode(String expr) throws ELException {
-		Node n = createNodeInternal(expr);
-		return n;
-	}
-
-	private final static Node createNodeInternal(String expr)
-			throws ELException {
-		if (expr == null) {
-			throw new ELException(MessageFactory.get("error.null"));
-		}
-
-		Node n = (Node) cache.get(expr);
-		if (n == null) {
-			try {
-				n = (new ELParser(new StringReader(expr)))
-						.CompositeExpression();
-
-				// validate composite expression
-				if (n instanceof AstCompositeExpression) {
-					int numChildren = n.jjtGetNumChildren();
-					if (numChildren == 1) {
-						n = n.jjtGetChild(0);
-					} else {
-						Class type = null;
-						Node child = null;
-						for (int i = 0; i < numChildren; i++) {
-							child = n.jjtGetChild(i);
-							if (child instanceof AstLiteralExpression)
-								continue;
-							if (type == null)
-								type = child.getClass();
-							else {
-								if (!type.equals(child.getClass())) {
-									throw new ELException(MessageFactory.get(
-											"error.mixed", expr));
-								}
-							}
-						}
-					}
-				}
-				if (n instanceof AstDeferredExpression
-						|| n instanceof AstDynamicExpression) {
-					n = n.jjtGetChild(0);
-				}
-				cache.put(expr, n);
-			} catch (ParseException pe) {
-				throw new ELException("Error Parsing: " + expr, pe);
-			}
-		}
-		return n;
-	}
-
-	private void prepare(Node node) throws ELException {
+    private static final ConcurrentCache cache = new ConcurrentCache(5000);
+
+    private FunctionMapper fnMapper;
+
+    private VariableMapper varMapper;
+
+    private String expression;
+
+    /**
+     *
+     */
+    public ExpressionBuilder(String expression, ELContext ctx)
+            throws ELException {
+        this.expression = expression;
+
+        FunctionMapper ctxFn = ctx.getFunctionMapper();
+        VariableMapper ctxVar = ctx.getVariableMapper();
+
+        if (ctxFn != null) {
+            this.fnMapper = new FunctionMapperFactory(ctxFn);
+        }
+        if (ctxVar != null) {
+            this.varMapper = new VariableMapperFactory(ctxVar);
+        }
+    }
+
+    public final static Node createNode(String expr) throws ELException {
+        Node n = createNodeInternal(expr);
+        return n;
+    }
+
+    private final static Node createNodeInternal(String expr)
+            throws ELException {
+        if (expr == null) {
+            throw new ELException(MessageFactory.get("error.null"));
+        }
+
+        Node n = (Node) cache.get(expr);
+        if (n == null) {
+            try {
+                n = (new ELParser(new StringReader(expr)))
+                        .CompositeExpression();
+
+                // validate composite expression
+                if (n instanceof AstCompositeExpression) {
+                    int numChildren = n.jjtGetNumChildren();
+                    if (numChildren == 1) {
+                        n = n.jjtGetChild(0);
+                    } else {
+                        Class type = null;
+                        Node child = null;
+                        for (int i = 0; i < numChildren; i++) {
+                            child = n.jjtGetChild(i);
+                            if (child instanceof AstLiteralExpression)
+                                continue;
+                            if (type == null)
+                                type = child.getClass();
+                            else {
+                                if (!type.equals(child.getClass())) {
+                                    throw new ELException(MessageFactory.get(
+                                            "error.mixed", expr));
+                                }
+                            }
+                        }
+                    }
+                }
+                if (n instanceof AstDeferredExpression
+                        || n instanceof AstDynamicExpression) {
+                    n = n.jjtGetChild(0);
+                }
+                cache.put(expr, n);
+            } catch (ParseException pe) {
+                throw new ELException("Error Parsing: " + expr, pe);
+            }
+        }
+        return n;
+    }
+
+    private void prepare(Node node) throws ELException {
         try {
             node.accept(this);
         } catch (Exception e) {
             throw (ELException) e;
         }
-		if (this.fnMapper instanceof FunctionMapperFactory) {
-			this.fnMapper = ((FunctionMapperFactory) this.fnMapper).create();
-		}
-		if (this.varMapper instanceof VariableMapperFactory) {
-			this.varMapper = ((VariableMapperFactory) this.varMapper).create();
-		}
-	}
-
-	private Node build() throws ELException {
-		Node n = createNodeInternal(this.expression);
-		this.prepare(n);
-		if (n instanceof AstDeferredExpression
-				|| n instanceof AstDynamicExpression) {
-			n = n.jjtGetChild(0);
-		}
-		return n;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see com.sun.el.parser.NodeVisitor#visit(com.sun.el.parser.Node)
-	 */
-	public void visit(Node node) throws ELException {
-		if (node instanceof AstFunction) {
-
-			AstFunction funcNode = (AstFunction) node;
-
-			if (this.fnMapper == null) {
-				throw new ELException(MessageFactory.get("error.fnMapper.null"));
-			}
-			Method m = fnMapper.resolveFunction(funcNode.getPrefix(), funcNode
-					.getLocalName());
-			if (m == null) {
-				throw new ELException(MessageFactory.get(
-						"error.fnMapper.method", funcNode.getOutputName()));
-			}
-			int pcnt = m.getParameterTypes().length;
-			if (node.jjtGetNumChildren() != pcnt) {
-				throw new ELException(MessageFactory.get(
-						"error.fnMapper.paramcount", funcNode.getOutputName(),
-						"" + pcnt, "" + node.jjtGetNumChildren()));
-			}
-		} else if (node instanceof AstIdentifier && this.varMapper != null) {
-			String variable = ((AstIdentifier) node).getImage();
-
-			// simply capture it
-			this.varMapper.resolveVariable(variable);
-		}
-	}
-
-	public ValueExpression createValueExpression(Class expectedType)
-			throws ELException {
-		Node n = this.build();
-		return new ValueExpressionImpl(this.expression, n, this.fnMapper,
-				this.varMapper, expectedType);
-	}
-
-	public MethodExpression createMethodExpression(Class expectedReturnType,
-			Class[] expectedParamTypes) throws ELException {
-		Node n = this.build();
-		if (n instanceof AstValue || n instanceof AstIdentifier) {
-			return new MethodExpressionImpl(expression, n, this.fnMapper,
-					this.varMapper, expectedReturnType, expectedParamTypes);
-		} else if (n instanceof AstLiteralExpression) {
-			return new MethodExpressionLiteral(expression, expectedReturnType,
-					expectedParamTypes);
-		} else {
-			throw new ELException("Not a Valid Method Expression: "
-					+ expression);
-		}
-	}
+        if (this.fnMapper instanceof FunctionMapperFactory) {
+            this.fnMapper = ((FunctionMapperFactory) this.fnMapper).create();
+        }
+        if (this.varMapper instanceof VariableMapperFactory) {
+            this.varMapper = ((VariableMapperFactory) this.varMapper).create();
+        }
+    }
+
+    private Node build() throws ELException {
+        Node n = createNodeInternal(this.expression);
+        this.prepare(n);
+        if (n instanceof AstDeferredExpression
+                || n instanceof AstDynamicExpression) {
+            n = n.jjtGetChild(0);
+        }
+        return n;
+    }
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see com.sun.el.parser.NodeVisitor#visit(com.sun.el.parser.Node)
+     */
+    public void visit(Node node) throws ELException {
+        if (node instanceof AstFunction) {
+
+            AstFunction funcNode = (AstFunction) node;
+
+            if (this.fnMapper == null) {
+                throw new ELException(MessageFactory.get("error.fnMapper.null"));
+            }
+            Method m = fnMapper.resolveFunction(funcNode.getPrefix(), funcNode
+                    .getLocalName());
+            if (m == null) {
+                throw new ELException(MessageFactory.get(
+                        "error.fnMapper.method", funcNode.getOutputName()));
+            }
+            int pcnt = m.getParameterTypes().length;
+            if (node.jjtGetNumChildren() != pcnt) {
+                throw new ELException(MessageFactory.get(
+                        "error.fnMapper.paramcount", funcNode.getOutputName(),
+                        "" + pcnt, "" + node.jjtGetNumChildren()));
+            }
+        } else if (node instanceof AstIdentifier && this.varMapper != null) {
+            String variable = ((AstIdentifier) node).getImage();
+
+            // simply capture it
+            this.varMapper.resolveVariable(variable);
+        }
+    }
+
+    public ValueExpression createValueExpression(Class expectedType)
+            throws ELException {
+        Node n = this.build();
+        return new ValueExpressionImpl(this.expression, n, this.fnMapper,
+                this.varMapper, expectedType);
+    }
+
+    public MethodExpression createMethodExpression(Class expectedReturnType,
+            Class[] expectedParamTypes) throws ELException {
+        Node n = this.build();
+        if (n instanceof AstValue || n instanceof AstIdentifier) {
+            return new MethodExpressionImpl(expression, n, this.fnMapper,
+                    this.varMapper, expectedReturnType, expectedParamTypes);
+        } else if (n instanceof AstLiteralExpression) {
+            return new MethodExpressionLiteral(expression, expectedReturnType,
+                    expectedParamTypes);
+        } else {
+            throw new ELException("Not a Valid Method Expression: "
+                    + expression);
+        }
+    }
 }

==================================================
FunctionMapperImpl.java
index 63d2a6e58f..532ec8dbdc 100644
--- a/java/org/apache/el/lang/FunctionMapperFactory.java
+++ b/java/org/apache/el/lang/FunctionMapperFactory.java
@@ -29,15 +29,15 @@ public class FunctionMapperFactory extends FunctionMapper {
 
     protected FunctionMapperImpl memento = null;
     protected FunctionMapper target;
-    
+
     public FunctionMapperFactory(FunctionMapper mapper) {
         if (mapper == null) {
             throw new NullPointerException("FunctionMapper target cannot be null");
         }
         this.target = mapper;
     }
-   
-    
+
+
     /* (non-Javadoc)
      * @see javax.el.FunctionMapper#resolveFunction(java.lang.String, java.lang.String)
      */
@@ -51,7 +51,7 @@ public class FunctionMapperFactory extends FunctionMapper {
         }
         return m;
     }
-    
+
     public FunctionMapper create() {
         return this.memento;
     }

==================================================
VariableMapperFactory.java
index de60ddb015..4ca06cb7ea 100644
--- a/java/org/apache/el/lang/FunctionMapperImpl.java
+++ b/java/org/apache/el/lang/FunctionMapperImpl.java
@@ -38,7 +38,7 @@ public class FunctionMapperImpl extends FunctionMapper implements
         Externalizable {
 
     private static final long serialVersionUID = 1L;
-    
+
     protected Map functions = null;
 
     /*
@@ -83,16 +83,16 @@ public class FunctionMapperImpl extends FunctionMapper implements
             ClassNotFoundException {
         this.functions = (Map) in.readObject();
     }
-    
+
     public static class Function implements Externalizable {
-    
+
         protected transient Method m;
         protected String owner;
         protected String name;
         protected String[] types;
         protected String prefix;
         protected String localName;
-    
+
         /**
          * 
          */
@@ -107,11 +107,11 @@ public class FunctionMapperImpl extends FunctionMapper implements
             this.localName = localName;
             this.m = m;
         }
-        
+
         public Function() {
             // for serialization
         }
-    
+
         /*
          * (non-Javadoc)
          * 
@@ -122,18 +122,18 @@ public class FunctionMapperImpl extends FunctionMapper implements
             out.writeUTF(this.localName);
             // make sure m isn't null
             getMethod();
-            out.writeUTF((this.owner != null) ? 
-                     this.owner : 
+            out.writeUTF((this.owner != null) ?
+                     this.owner :
                      this.m.getDeclaringClass().getName());
-            out.writeUTF((this.name != null) ? 
-                     this.name : 
+            out.writeUTF((this.name != null) ?
+                     this.name :
                      this.m.getName());
-            out.writeObject((this.types != null) ? 
-                     this.types : 
+            out.writeObject((this.types != null) ?
+                     this.types :
                      ReflectionUtil.toTypeNameArray(this.m.getParameterTypes()));
 
         }
-    
+
         /*
          * (non-Javadoc)
          * 
@@ -141,7 +141,7 @@ public class FunctionMapperImpl extends FunctionMapper implements
          */
         public void readExternal(ObjectInput in) throws IOException,
                 ClassNotFoundException {
-            
+
             this.prefix = in.readUTF();
             if ("".equals(this.prefix)) this.prefix = null;
             this.localName = in.readUTF();
@@ -149,7 +149,7 @@ public class FunctionMapperImpl extends FunctionMapper implements
             this.name = in.readUTF();
             this.types = (String[]) in.readObject();
         }
-    
+
         public Method getMethod() {
             if (this.m == null) {
                 try {
@@ -162,7 +162,7 @@ public class FunctionMapperImpl extends FunctionMapper implements
             }
             return this.m;
         }
-        
+
         public boolean matches(String prefix, String localName) {
             if (this.prefix != null) {
                 if (prefix == null) return false;
@@ -170,7 +170,7 @@ public class FunctionMapperImpl extends FunctionMapper implements
             }
             return this.localName.equals(localName);
         }
-    
+
         /* (non-Javadoc)
          * @see java.lang.Object#equals(java.lang.Object)
          */
@@ -180,7 +180,7 @@ public class FunctionMapperImpl extends FunctionMapper implements
             }
             return false;
         }
-        
+
         /* (non-Javadoc)
          * @see java.lang.Object#hashCode()
          */

==================================================
VariableMapperImpl.java
index 30c386e904..d511ac5480 100644
--- a/java/org/apache/el/lang/VariableMapperFactory.java
+++ b/java/org/apache/el/lang/VariableMapperFactory.java
@@ -24,14 +24,14 @@ public class VariableMapperFactory extends VariableMapper {
 
     private final VariableMapper target;
     private VariableMapper momento;
-    
+
     public VariableMapperFactory(VariableMapper target) {
         if (target == null) {
             throw new NullPointerException("Target VariableMapper cannot be null");
         }
         this.target = target;
     }
-    
+
     public VariableMapper create() {
         return this.momento;
     }

==================================================
ConcurrentCache.java
index db207ab904..ae3b7d7184 100644
--- a/java/org/apache/el/parser/ELParser.jjt
+++ b/java/org/apache/el/parser/ELParser.jjt
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,22 +16,22 @@
  */
 
 /*
-	Author:	Jacob Hookom
-	Email:	jacob at hookom.net
+    Author:    Jacob Hookom
+    Email:    jacob at hookom.net
 */
 
 /* == Option Declaration == */
 options
 {
-	STATIC=false;
-	NODE_PREFIX="Ast";
-	VISITOR_EXCEPTION="javax.el.ELException";
-	VISITOR=false;
-	MULTI=true;
-	NODE_DEFAULT_VOID=true;
-	JAVA_UNICODE_ESCAPE=false;
-  	UNICODE_INPUT=true;
-	BUILD_NODE_FILES=true;
+    STATIC=false;
+    NODE_PREFIX="Ast";
+    VISITOR_EXCEPTION="javax.el.ELException";
+    VISITOR=false;
+    MULTI=true;
+    NODE_DEFAULT_VOID=true;
+    JAVA_UNICODE_ESCAPE=false;
+    UNICODE_INPUT=true;
+    BUILD_NODE_FILES=true;
 }
 
 /* == Parser Declaration == */
@@ -44,9 +44,9 @@ public class ELParser
     public static Node parse(String ref) throws ELException
     {
         try {
-        	return (new ELParser(new StringReader(ref))).CompositeExpression();
+            return (new ELParser(new StringReader(ref))).CompositeExpression();
         } catch (ParseException pe) {
-           	throw new ELException(pe.getMessage());
+            throw new ELException(pe.getMessage());
         }
     }
 }
@@ -59,7 +59,7 @@ PARSER_END( ELParser )
  */
 AstCompositeExpression CompositeExpression() #CompositeExpression : {}
 {
-	(DeferredExpression() | DynamicExpression() | LiteralExpression())* <EOF> { return jjtThis; }
+    (DeferredExpression() | DynamicExpression() | LiteralExpression())* <EOF> { return jjtThis; }
 }
 
 /*
@@ -68,7 +68,7 @@ AstCompositeExpression CompositeExpression() #CompositeExpression : {}
  */
 void LiteralExpression() #LiteralExpression : { Token t = null; }
 {
-	t=<LITERAL_EXPRESSION> { jjtThis.setImage(t.image); }
+    t=<LITERAL_EXPRESSION> { jjtThis.setImage(t.image); }
 }
 
 /*
@@ -77,7 +77,7 @@ void LiteralExpression() #LiteralExpression : { Token t = null; }
  */
 void DeferredExpression() #DeferredExpression : {}
 {
-	<START_DEFERRED_EXPRESSION> Expression() <END_EXPRESSION> 
+    <START_DEFERRED_EXPRESSION> Expression() <END_EXPRESSION>
 }
 
 /*
@@ -86,7 +86,7 @@ void DeferredExpression() #DeferredExpression : {}
  */
 void DynamicExpression() #DynamicExpression : {}
 {
-	<START_DYNAMIC_EXPRESSION> Expression() <END_EXPRESSION> 
+    <START_DYNAMIC_EXPRESSION> Expression() <END_EXPRESSION>
 }
 
 /*
@@ -95,7 +95,7 @@ void DynamicExpression() #DynamicExpression : {}
  */
 void Expression() : {}
 {
-	Choice()
+    Choice()
 }
 
 /*
@@ -104,7 +104,7 @@ void Expression() : {}
  */
 void Choice() : {}
 {
-	Or() (<QUESTIONMARK> Choice() <COLON> Choice() #Choice(3))*
+    Or() (<QUESTIONMARK> Choice() <COLON> Choice() #Choice(3))*
 }
 
 /*
@@ -113,7 +113,7 @@ void Choice() : {}
  */
 void Or() : {}
 {
-	And() ((<OR0>|<OR1>) And() #Or(2))*
+    And() ((<OR0>|<OR1>) And() #Or(2))*
 }
 
 /*
@@ -122,7 +122,7 @@ void Or() : {}
  */
 void And() : {}
 {
-	Equality() ((<AND0>|<AND1>) Equality() #And(2))*
+    Equality() ((<AND0>|<AND1>) Equality() #And(2))*
 }
 
 /*
@@ -131,12 +131,12 @@ void And() : {}
  */
 void Equality() : {}
 {
-	Compare()
-	(
-		((<EQ0>|<EQ1>) Compare() #Equal(2))
-	|
-		((<NE0>|<NE1>) Compare() #NotEqual(2))
-	)*
+    Compare()
+    (
+        ((<EQ0>|<EQ1>) Compare() #Equal(2))
+    |
+        ((<NE0>|<NE1>) Compare() #NotEqual(2))
+    )*
 }
 
 /*
@@ -145,16 +145,16 @@ void Equality() : {}
  */
 void Compare() : {}
 {
-	Math()
-	(
-		((<LT0>|<LT1>) Math() #LessThan(2))
-	|
-		((<GT0>|<GT1>) Math() #GreaterThan(2))
-	|
-		((<LE0>|<LE1>) Math() #LessThanEqual(2))
-	|
-		((<GE0>|<GE1>) Math() #GreaterThanEqual(2))
-	)*
+    Math()
+    (
+        ((<LT0>|<LT1>) Math() #LessThan(2))
+    |
+        ((<GT0>|<GT1>) Math() #GreaterThan(2))
+    |
+        ((<LE0>|<LE1>) Math() #LessThanEqual(2))
+    |
+        ((<GE0>|<GE1>) Math() #GreaterThanEqual(2))
+    )*
 }
 
 /*
@@ -163,12 +163,12 @@ void Compare() : {}
  */
 void Math() : {}
 {
-	Multiplication()
-	(
-		(<PLUS> Multiplication() #Plus(2))
-	|
-		(<MINUS> Multiplication() #Minus(2))
-	)*
+    Multiplication()
+    (
+        (<PLUS> Multiplication() #Plus(2))
+    |
+        (<MINUS> Multiplication() #Minus(2))
+    )*
 }
 
 /*
@@ -177,14 +177,14 @@ void Math() : {}
  */
 void Multiplication() : {}
 {
-	Unary()
-	(
-		(<MULT> Unary() #Mult(2))
-	|
-		((<DIV0>|<DIV1>) Unary() #Div(2))
-	|
-		((<MOD0>|<MOD1>) Unary() #Mod(2))	
-	)*	
+    Unary()
+    (
+        (<MULT> Unary() #Mult(2))
+    |
+        ((<DIV0>|<DIV1>) Unary() #Div(2))
+    |
+        ((<MOD0>|<MOD1>) Unary() #Mod(2))
+    )*
 }
 
 /*
@@ -193,13 +193,13 @@ void Multiplication() : {}
  */
 void Unary() : {}
 {
-		<MINUS> Unary() #Negative 
-	|
-		(<NOT0>|<NOT1>) Unary() #Not 
-	|
-		<EMPTY> Unary() #Empty
-	|	
-		Value()
+        <MINUS> Unary() #Negative
+    |
+        (<NOT0>|<NOT1>) Unary() #Not
+    |
+        <EMPTY> Unary() #Empty
+    |
+        Value()
 }
 
 /*
@@ -208,7 +208,7 @@ void Unary() : {}
  */
 void Value() : {}
 {
-	(ValuePrefix() (ValueSuffix())*) #Value(>1)
+    (ValuePrefix() (ValueSuffix())*) #Value(>1)
 }
 
 /*
@@ -217,8 +217,8 @@ void Value() : {}
  */
 void ValuePrefix() : {}
 {
-	Literal()
-	| NonLiteral()
+    Literal()
+    | NonLiteral()
 }
 
 /*
@@ -227,7 +227,7 @@ void ValuePrefix() : {}
  */
 void ValueSuffix() : {}
 {
-	DotSuffix() | BracketSuffix()
+    DotSuffix() | BracketSuffix()
 }
 
 /*
@@ -236,7 +236,7 @@ void ValueSuffix() : {}
  */
 void DotSuffix() #DotSuffix : { Token t = null; }
 {
-	<DOT> t=<IDENTIFIER> { jjtThis.setImage(t.image); }
+    <DOT> t=<IDENTIFIER> { jjtThis.setImage(t.image); }
 }
 
 /*
@@ -245,7 +245,7 @@ void DotSuffix() #DotSuffix : { Token t = null; }
  */
 void BracketSuffix() #BracketSuffix : {}
 {
-	<LBRACK> Expression() <RBRACK>
+    <LBRACK> Expression() <RBRACK>
 }
 
 /*
@@ -254,9 +254,9 @@ void BracketSuffix() #BracketSuffix : {}
  */
 void NonLiteral() : {}
 {
- 	<LPAREN> Expression() <RPAREN>
- 	| LOOKAHEAD((<IDENTIFIER> <COLON>)? <IDENTIFIER> <LPAREN>) Function()
-	| Identifier()
+    <LPAREN> Expression() <RPAREN>
+    | LOOKAHEAD((<IDENTIFIER> <COLON>)? <IDENTIFIER> <LPAREN>) Function()
+    | Identifier()
 }
 
 /*
@@ -265,7 +265,7 @@ void NonLiteral() : {}
  */
 void Identifier() #Identifier : { Token t = null; }
 {
-	t=<IDENTIFIER> { jjtThis.setImage(t.image); }
+    t=<IDENTIFIER> { jjtThis.setImage(t.image); }
 }
 
 /*
@@ -274,20 +274,20 @@ void Identifier() #Identifier : { Token t = null; }
  */
 void Function() #Function :
 {
-	Token t0 = null;
-	Token t1 = null;
+    Token t0 = null;
+    Token t1 = null;
 }
 {
-	(t0=<IDENTIFIER> <COLON>)? t1=<IDENTIFIER>
-	{
-		if (t0 != null) {
-			jjtThis.setPrefix(t0.image);
-			jjtThis.setLocalName(t1.image);
-		} else {
-			jjtThis.setLocalName(t1.image);
-		}
-	}
-	<LPAREN> (Expression() (<COMMA> Expression())*)? <RPAREN>
+    (t0=<IDENTIFIER> <COLON>)? t1=<IDENTIFIER>
+    {
+        if (t0 != null) {
+            jjtThis.setPrefix(t0.image);
+            jjtThis.setLocalName(t1.image);
+        } else {
+            jjtThis.setLocalName(t1.image);
+        }
+    }
+    <LPAREN> (Expression() (<COMMA> Expression())*)? <RPAREN>
 }
 
 /*
@@ -296,11 +296,11 @@ void Function() #Function :
  */
 void Literal() : {}
 {
-	Boolean()
-	| FloatingPoint()
-	| Integer()
-	| String()
-	| Null()
+    Boolean()
+    | FloatingPoint()
+    | Integer()
+    | String()
+    | Null()
 }
 
 /*
@@ -309,8 +309,8 @@ void Literal() : {}
  */
 void Boolean() : {}
 {
-	<TRUE> #True
-	| <FALSE> #False
+    <TRUE> #True
+    | <FALSE> #False
 }
 
 /*
@@ -319,7 +319,7 @@ void Boolean() : {}
  */
 void FloatingPoint() #FloatingPoint : { Token t = null; }
 {
-	t=<FLOATING_POINT_LITERAL> { jjtThis.setImage(t.image); }
+    t=<FLOATING_POINT_LITERAL> { jjtThis.setImage(t.image); }
 }
 
 /*
@@ -328,7 +328,7 @@ void FloatingPoint() #FloatingPoint : { Token t = null; }
  */
 void Integer() #Integer : { Token t = null; }
 {
-	t=<INTEGER_LITERAL> { jjtThis.setImage(t.image); }
+    t=<INTEGER_LITERAL> { jjtThis.setImage(t.image); }
 }
 
 /*
@@ -337,7 +337,7 @@ void Integer() #Integer : { Token t = null; }
  */
 void String() #String : { Token t = null; }
 {
-	t=<STRING_LITERAL> { jjtThis.setImage(t.image); }
+    t=<STRING_LITERAL> { jjtThis.setImage(t.image); }
 }
 
 /*
@@ -346,7 +346,7 @@ void String() #String : { Token t = null; }
  */
 void Null() #Null : {}
 {
-	<NULL>
+    <NULL>
 }
 
 
@@ -374,97 +374,97 @@ void Null() #Null : {}
 
 <IN_EXPRESSION> TOKEN :
 {
-	< INTEGER_LITERAL: ["0"-"9"] (["0"-"9"])* >
-|	< FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? 
-		| "." (["0"-"9"])+ (<EXPONENT>)?
-		| (["0"-"9"])+ <EXPONENT>
-	>
-|	< #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
-|	< STRING_LITERAL: ("\"" ((~["\"","\\"])
-		| ("\\" ( ["\\","\""] )))* "\"")
-		| ("\'" ((~["\'","\\"])
-		| ("\\" ( ["\\","\'"] )))* "\'")
-	>
-|	< BADLY_ESCAPED_STRING_LITERAL: ("\"" (~["\"","\\"])* ("\\" ( ~["\\","\""] )))
-		| ("\'" (~["\'","\\"])* ("\\" ( ~["\\","\'"] )))
-	>
-|	< TRUE : "true" >
-|	< FALSE : "false" >
-|	< NULL : "null" >
-|	< END_EXPRESSION : "}" > : DEFAULT
-|	< DOT : "." >
-|	< LPAREN : "(" >
-|	< RPAREN : ")" >
-|	< LBRACK : "[" >
-|	< RBRACK : "]" >
-|	< COLON : ":" >
-|	< COMMA : "," >
-|	< GT0 : ">" >
-|	< GT1 : "gt" >
-|	< LT0 : "<" >
-|	< LT1 : "lt" >
-|	< GE0 : ">=" >
-|	< GE1 : "ge" >
-|	< LE0 : "<=" >
-|	< LE1 : "le" >
-|	< EQ0 : "==" >
-|	< EQ1 : "eq" >
-|	< NE0 : "!=" >
-|	< NE1 : "ne" >
-|	< NOT0 : "!" >
-|	< NOT1 : "not" >
-|	< AND0 : "&&" >
-|	< AND1 : "and" >
-|	< OR0 : "||" >
-|	< OR1 : "or" >
-|	< EMPTY : "empty" >
-|	< INSTANCEOF : "instanceof" >
-|	< MULT : "*" >
-|	< PLUS : "+" >
-|	< MINUS : "-" >
-|	< QUESTIONMARK : "?" >
-|	< DIV0 : "/" >
-|	< DIV1 : "div" >
-|	< MOD0 : "%" >
-|	< MOD1 : "mod" >
-|	< IDENTIFIER : (<LETTER>|<IMPL_OBJ_START>) (<LETTER>|<DIGIT>)* >
-|	< FUNCTIONSUFFIX : (<IDENTIFIER>) >
-|	< #IMPL_OBJ_START: "#" >
-|	< #LETTER:
-		[
-		"\u0024",
-		"\u0041"-"\u005a",
-		"\u005f",
-		"\u0061"-"\u007a",
-		"\u00c0"-"\u00d6",
-		"\u00d8"-"\u00f6",
-		"\u00f8"-"\u00ff",
-		"\u0100"-"\u1fff",
-		"\u3040"-"\u318f",
-		"\u3300"-"\u337f",
-		"\u3400"-"\u3d2d",
-		"\u4e00"-"\u9fff",
-		"\uf900"-"\ufaff"
-		]
-	>
-|	< #DIGIT:
-		[
-		"\u0030"-"\u0039",
-		"\u0660"-"\u0669",
-		"\u06f0"-"\u06f9",
-		"\u0966"-"\u096f",
-		"\u09e6"-"\u09ef",
-		"\u0a66"-"\u0a6f",
-		"\u0ae6"-"\u0aef",
-		"\u0b66"-"\u0b6f",
-		"\u0be7"-"\u0bef",
-		"\u0c66"-"\u0c6f",
-		"\u0ce6"-"\u0cef",
-		"\u0d66"-"\u0d6f",
-		"\u0e50"-"\u0e59",
-		"\u0ed0"-"\u0ed9",
-		"\u1040"-"\u1049"
-		]
-	>
-|	< ILLEGAL_CHARACTER: (~[]) >
+    < INTEGER_LITERAL: ["0"-"9"] (["0"-"9"])* >
+|    < FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
+        | "." (["0"-"9"])+ (<EXPONENT>)?
+        | (["0"-"9"])+ <EXPONENT>
+    >
+|    < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
+|    < STRING_LITERAL: ("\"" ((~["\"","\\"])
+        | ("\\" ( ["\\","\""] )))* "\"")
+        | ("\'" ((~["\'","\\"])
+        | ("\\" ( ["\\","\'"] )))* "\'")
+    >
+|    < BADLY_ESCAPED_STRING_LITERAL: ("\"" (~["\"","\\"])* ("\\" ( ~["\\","\""] )))
+        | ("\'" (~["\'","\\"])* ("\\" ( ~["\\","\'"] )))
+    >
+|    < TRUE : "true" >
+|    < FALSE : "false" >
+|    < NULL : "null" >
+|    < END_EXPRESSION : "}" > : DEFAULT
+|    < DOT : "." >
+|    < LPAREN : "(" >
+|    < RPAREN : ")" >
+|    < LBRACK : "[" >
+|    < RBRACK : "]" >
+|    < COLON : ":" >
+|    < COMMA : "," >
+|    < GT0 : ">" >
+|    < GT1 : "gt" >
+|    < LT0 : "<" >
+|    < LT1 : "lt" >
+|    < GE0 : ">=" >
+|    < GE1 : "ge" >
+|    < LE0 : "<=" >
+|    < LE1 : "le" >
+|    < EQ0 : "==" >
+|    < EQ1 : "eq" >
+|    < NE0 : "!=" >
+|    < NE1 : "ne" >
+|    < NOT0 : "!" >
+|    < NOT1 : "not" >
+|    < AND0 : "&&" >
+|    < AND1 : "and" >
+|    < OR0 : "||" >
+|    < OR1 : "or" >
+|    < EMPTY : "empty" >
+|    < INSTANCEOF : "instanceof" >
+|    < MULT : "*" >
+|    < PLUS : "+" >
+|    < MINUS : "-" >
+|    < QUESTIONMARK : "?" >
+|    < DIV0 : "/" >
+|    < DIV1 : "div" >
+|    < MOD0 : "%" >
+|    < MOD1 : "mod" >
+|    < IDENTIFIER : (<LETTER>|<IMPL_OBJ_START>) (<LETTER>|<DIGIT>)* >
+|    < FUNCTIONSUFFIX : (<IDENTIFIER>) >
+|    < #IMPL_OBJ_START: "#" >
+|    < #LETTER:
+        [
+        "\u0024",
+        "\u0041"-"\u005a",
+        "\u005f",
+        "\u0061"-"\u007a",
+        "\u00c0"-"\u00d6",
+        "\u00d8"-"\u00f6",
+        "\u00f8"-"\u00ff",
+        "\u0100"-"\u1fff",
+        "\u3040"-"\u318f",
+        "\u3300"-"\u337f",
+        "\u3400"-"\u3d2d",
+        "\u4e00"-"\u9fff",
+        "\uf900"-"\ufaff"
+        ]
+    >
+|    < #DIGIT:
+        [
+        "\u0030"-"\u0039",
+        "\u0660"-"\u0669",
+        "\u06f0"-"\u06f9",
+        "\u0966"-"\u096f",
+        "\u09e6"-"\u09ef",
+        "\u0a66"-"\u0a6f",
+        "\u0ae6"-"\u0aef",
+        "\u0b66"-"\u0b6f",
+        "\u0be7"-"\u0bef",
+        "\u0c66"-"\u0c6f",
+        "\u0ce6"-"\u0cef",
+        "\u0d66"-"\u0d6f",
+        "\u0e50"-"\u0e59",
+        "\u0ed0"-"\u0ed9",
+        "\u1040"-"\u1049"
+        ]
+    >
+|    < ILLEGAL_CHARACTER: (~[]) >
 }

==================================================
MessageFactory.java
index 4740dc2d9f..5515b0e707 100644
--- a/java/org/apache/el/util/ConcurrentCache.java
+++ b/java/org/apache/el/util/ConcurrentCache.java
@@ -22,34 +22,34 @@ import java.util.concurrent.ConcurrentHashMap;
 
 public final class ConcurrentCache<K,V> {
 
-	private final int size;
-	
-	private final Map<K,V> eden;
-	
-	private final Map<K,V> longterm;
-	
-	public ConcurrentCache(int size) {
-		this.size = size;
-		this.eden = new ConcurrentHashMap<K,V>(size);
-		this.longterm = new WeakHashMap<K,V>(size);
-	}
-	
-	public V get(K k) {
-		V v = this.eden.get(k);
-		if (v == null) {
-			v = this.longterm.get(k);
-			if (v != null) {
-				this.eden.put(k, v);
-			}
-		}
-		return v;
-	}
-	
-	public void put(K k, V v) {
-		if (this.eden.size() >= size) {
-			this.longterm.putAll(this.eden);
-			this.eden.clear();
-		}
-		this.eden.put(k, v);
-	}
+    private final int size;
+
+    private final Map<K,V> eden;
+
+    private final Map<K,V> longterm;
+
+    public ConcurrentCache(int size) {
+        this.size = size;
+        this.eden = new ConcurrentHashMap<K,V>(size);
+        this.longterm = new WeakHashMap<K,V>(size);
+    }
+
+    public V get(K k) {
+        V v = this.eden.get(k);
+        if (v == null) {
+            v = this.longterm.get(k);
+            if (v != null) {
+                this.eden.put(k, v);
+            }
+        }
+        return v;
+    }
+
+    public void put(K k, V v) {
+        if (this.eden.size() >= size) {
+            this.longterm.putAll(this.eden);
+            this.eden.clear();
+        }
+        this.eden.put(k, v);
+    }
 }

==================================================
