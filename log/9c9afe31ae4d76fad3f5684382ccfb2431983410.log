9c9afe31ae4d76fad3f5684382ccfb2431983410
==================================================
Push down read methods to AprSocketWrapper
==================================================
Mark Emlyn
==================================================
Mon Nov 10 16:46:09 2014 +0000
==================================================
AprProcessor.java
Push down read methods to AprSocketWrapper

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1637925 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AprServletInputStream.java
index a5fbeeea32..835d3f44a6 100644
--- a/java/org/apache/coyote/http11/upgrade/AprProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/AprProcessor.java
@@ -24,6 +24,7 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.jni.Socket;
 import org.apache.tomcat.util.net.AprEndpoint;
+import org.apache.tomcat.util.net.AprEndpoint.AprSocketWrapper;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 
 public class AprProcessor extends AbstractProcessor<Long> {
@@ -34,13 +35,13 @@ public class AprProcessor extends AbstractProcessor<Long> {
 
     private static final int INFINITE_TIMEOUT = -1;
 
-    public AprProcessor(SocketWrapperBase<Long> wrapper, ByteBuffer leftoverInput,
+    public AprProcessor(SocketWrapperBase<Long> wrapper, ByteBuffer leftOverInput,
             HttpUpgradeHandler httpUpgradeProcessor, AprEndpoint endpoint,
             int asyncWriteBufferSize) {
         super(httpUpgradeProcessor,
-                new AprServletInputStream(wrapper, leftoverInput),
+                new AprServletInputStream(wrapper),
                 new AprServletOutputStream(wrapper, asyncWriteBufferSize, endpoint));
-
+        ((AprSocketWrapper) wrapper).setLeftOverInput(leftOverInput);
         Socket.timeoutSet(wrapper.getSocket().longValue(), INFINITE_TIMEOUT);
     }
 }

==================================================
AprEndpoint.java
index 9680340516..b0c7db355b 100644
--- a/java/org/apache/coyote/http11/upgrade/AprServletInputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/AprServletInputStream.java
@@ -16,136 +16,31 @@
  */
 package org.apache.coyote.http11.upgrade;
 
-import java.io.EOFException;
 import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
 
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.jni.OS;
-import org.apache.tomcat.jni.Socket;
-import org.apache.tomcat.jni.Status;
+import org.apache.tomcat.util.net.AprEndpoint.AprSocketWrapper;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 
 public class AprServletInputStream extends AbstractServletInputStream {
 
-    private static final Log log = LogFactory.getLog(AprServletInputStream.class);
-
     private final SocketWrapperBase<Long> wrapper;
-    private final long socket;
-    private ByteBuffer leftoverInput;
-    private volatile boolean eagain = false;
-    private volatile boolean closed = false;
-
 
-    public AprServletInputStream(SocketWrapperBase<Long> wrapper, ByteBuffer leftoverInput) {
+    public AprServletInputStream(SocketWrapperBase<Long> wrapper) {
         this.wrapper = wrapper;
-        this.socket = wrapper.getSocket().longValue();
-        if (leftoverInput != null) {
-            this.leftoverInput = ByteBuffer.allocate(leftoverInput.remaining());
-            this.leftoverInput.put(leftoverInput);
-        }
     }
 
-
     @Override
-    protected int doRead(boolean block, byte[] b, int off, int len)
-            throws IOException {
-
-        if (closed) {
-            throw new IOException(sm.getString("apr.closed", Long.valueOf(socket)));
-        }
-
-        if (leftoverInput != null) {
-            if (leftoverInput.remaining() < len) {
-                len = leftoverInput.remaining();
-            }
-            leftoverInput.get(b, off, len);
-            if (leftoverInput.remaining() == 0) {
-                leftoverInput = null;
-            }
-            return len;
-        }
-
-        Lock readLock = wrapper.getBlockingStatusReadLock();
-        WriteLock writeLock = wrapper.getBlockingStatusWriteLock();
-
-        boolean readDone = false;
-        int result = 0;
-        readLock.lock();
-        try {
-            if (wrapper.getBlockingStatus() == block) {
-                result = Socket.recv(socket, b, off, len);
-                readDone = true;
-            }
-        } finally {
-            readLock.unlock();
-        }
-
-        if (!readDone) {
-            writeLock.lock();
-            try {
-                wrapper.setBlockingStatus(block);
-                // Set the current settings for this socket
-                Socket.optSet(socket, Socket.APR_SO_NONBLOCK, (block ? 0 : 1));
-                // Downgrade the lock
-                readLock.lock();
-                try {
-                    writeLock.unlock();
-                    result = Socket.recv(socket, b, off, len);
-                } finally {
-                    readLock.unlock();
-                }
-            } finally {
-                // Should have been released above but may not have been on some
-                // exception paths
-                if (writeLock.isHeldByCurrentThread()) {
-                    writeLock.unlock();
-                }
-            }
-        }
-
-        if (result > 0) {
-            eagain = false;
-            return result;
-        } else if (-result == Status.EAGAIN) {
-            eagain = true;
-            return 0;
-        } else if (-result == Status.APR_EGENERAL && wrapper.isSecure()) {
-            // Not entirely sure why this is necessary. Testing to date has not
-            // identified any issues with this but log it so it can be tracked
-            // if it is suspected of causing issues in the future.
-            if (log.isDebugEnabled()) {
-                log.debug(sm.getString("apr.read.sslGeneralError",
-                        Long.valueOf(socket), wrapper));
-            }
-            eagain = true;
-            return 0;
-        } else if (-result == Status.APR_EOF) {
-            throw new EOFException(sm.getString("apr.clientAbort"));
-        } else if ((OS.IS_WIN32 || OS.IS_WIN64) &&
-                (-result == Status.APR_OS_START_SYSERR + 10053)) {
-            // 10053 on Windows is connection aborted
-            throw new EOFException(sm.getString("apr.clientAbort"));
-        } else {
-            throw new IOException(sm.getString("apr.read.error",
-                    Integer.valueOf(-result), Long.valueOf(socket), wrapper));
-        }
+    protected boolean doIsReady() throws IOException {
+        return ((AprSocketWrapper) wrapper).doIsReady();
     }
 
-
     @Override
-    protected boolean doIsReady() {
-        return !eagain;
+    protected int doRead(boolean block, byte[] b, int off, int len) throws IOException {
+        return ((AprSocketWrapper) wrapper).doRead(block, b, off, len);
     }
 
-
     @Override
     protected void doClose() throws IOException {
-        closed = true;
-        // AbstractProcessor needs to trigger the close as multiple closes for
-        // APR/native sockets will cause problems.
+        ((AprSocketWrapper) wrapper).doClose();
     }
 }

==================================================
