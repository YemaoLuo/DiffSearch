07ec75ff59c86144426f25e810ef6bcdbca191dd
==================================================
Refactor to reduce duplication prior to adding trailer header support.
==================================================
Mark Thomas
==================================================
Thu May 4 09:22:45 2017 +0000
==================================================
Http2AsyncUpgradeHandler.java
Refactor to reduce duplication prior to adding trailer header support.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1793758 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http2UpgradeHandler.java
index 85b4c9e855..941a426a3d 100644
--- a/java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java
+++ b/java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java
@@ -25,8 +25,8 @@ import java.util.concurrent.TimeUnit;
 import org.apache.coyote.Adapter;
 import org.apache.coyote.ProtocolException;
 import org.apache.coyote.Request;
-import org.apache.coyote.Response;
 import org.apache.coyote.http2.HpackEncoder.State;
+import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.net.SocketWrapperBase.BlockingMode;
 
@@ -133,88 +133,49 @@ public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
 
 
     @Override
-    void writeHeaders(Stream stream, Response coyoteResponse, boolean endOfStream, int payloadSize)
-            throws IOException {
+    void writeHeaders(Stream stream, int pushedStreamId, MimeHeaders mimeHeaders,
+            boolean endOfStream, int payloadSize) throws IOException {
+
         if (log.isDebugEnabled()) {
             log.debug(sm.getString("upgradeHandler.writeHeaders", connectionId,
-                    stream.getIdentifier()));
+                    stream.getIdentifier(), Integer.valueOf(pushedStreamId),
+                    Boolean.valueOf(endOfStream)));
         }
 
         if (!stream.canWrite()) {
             return;
         }
 
-        boolean first = true;
-        State state = null;
-        ArrayList<ByteBuffer> bufs = new ArrayList<>();
-        // This ensures the Stream processing thread has control of the socket.
-        while (state != State.COMPLETE) {
-            byte[] header = new byte[9];
-            ByteBuffer target = ByteBuffer.allocate(payloadSize);
-            state = getHpackEncoder().encode(coyoteResponse.getMimeHeaders(), target);
-            target.flip();
-            if (state == State.COMPLETE || target.limit() > 0) {
-                ByteUtil.setThreeBytes(header, 0, target.limit());
-                if (first) {
-                    first = false;
-                    header[3] = FrameType.HEADERS.getIdByte();
-                    if (endOfStream) {
-                        header[4] = FLAG_END_OF_STREAM;
-                    }
-                } else {
-                    header[3] = FrameType.CONTINUATION.getIdByte();
-                }
-                if (state == State.COMPLETE) {
-                    header[4] += FLAG_END_OF_HEADERS;
-                }
-                if (log.isDebugEnabled()) {
-                    log.debug(target.limit() + " bytes");
-                }
-                ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue());
-                bufs.add(ByteBuffer.wrap(header));
-                bufs.add(target);
-            } else if (state == State.UNDERFLOW) {
-                payloadSize = payloadSize * 2;
-            }
-        }
-        socketWrapper.write(BlockingMode.SEMI_BLOCK, getWriteTimeout(), TimeUnit.MILLISECONDS,
-                null, SocketWrapperBase.COMPLETE_WRITE, applicationErrorCompletion,
-                bufs.toArray(BYTEBUFFER_ARRAY));
-        handleAsyncException();
-    }
-
-
-    @Override
-    protected void writePushHeaders(Stream stream, int pushedStreamId, Request coyoteRequest, int payloadSize)
-            throws IOException {
-        if (log.isDebugEnabled()) {
-            log.debug(sm.getString("upgradeHandler.writePushHeaders", connectionId,
-                    stream.getIdentifier(), Integer.toString(pushedStreamId)));
-        }
-
-        if (!stream.canWrite()) {
-            return;
+        byte[] pushedStreamIdBytes = null;
+        if (pushedStreamId > 0) {
+            pushedStreamIdBytes = new byte[4];
+            ByteUtil.set31Bits(pushedStreamIdBytes, 0, pushedStreamId);
         }
 
         boolean first = true;
         State state = null;
         ArrayList<ByteBuffer> bufs = new ArrayList<>();
-        byte[] pushedStreamIdBytes = new byte[4];
-        ByteUtil.set31Bits(pushedStreamIdBytes, 0, pushedStreamId);
-        // This ensures the Stream processing thread has control of the socket.
+
         while (state != State.COMPLETE) {
             byte[] header = new byte[9];
-            ByteBuffer target = ByteBuffer.allocate(payloadSize);
-            if (first) {
-                target.put(pushedStreamIdBytes);
+            ByteBuffer payload = ByteBuffer.allocate(payloadSize);
+            if (first && pushedStreamIdBytes != null) {
+                payload.put(pushedStreamIdBytes);
             }
-            state = getHpackEncoder().encode(coyoteRequest.getMimeHeaders(), target);
-            target.flip();
-            if (state == State.COMPLETE || target.limit() > 0) {
-                ByteUtil.setThreeBytes(header, 0, target.limit());
+            state = getHpackEncoder().encode(mimeHeaders, payload);
+            payload.flip();
+            if (state == State.COMPLETE || payload.limit() > 0) {
+                ByteUtil.setThreeBytes(header, 0, payload.limit());
                 if (first) {
                     first = false;
-                    header[3] = FrameType.PUSH_PROMISE.getIdByte();
+                    if (pushedStreamIdBytes == null) {
+                        header[3] = FrameType.HEADERS.getIdByte();
+                    } else {
+                        header[3] = FrameType.PUSH_PROMISE.getIdByte();
+                    }
+                    if (endOfStream) {
+                        header[4] = FLAG_END_OF_STREAM;
+                    }
                 } else {
                     header[3] = FrameType.CONTINUATION.getIdByte();
                 }
@@ -222,11 +183,11 @@ public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
                     header[4] += FLAG_END_OF_HEADERS;
                 }
                 if (log.isDebugEnabled()) {
-                    log.debug(target.limit() + " bytes");
+                    log.debug(payload.limit() + " bytes");
                 }
                 ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue());
                 bufs.add(ByteBuffer.wrap(header));
-                bufs.add(target);
+                bufs.add(payload);
             } else if (state == State.UNDERFLOW) {
                 payloadSize = payloadSize * 2;
             }

==================================================
Stream.java
index e88ad8a6f9..ee63581cb1 100644
--- a/java/org/apache/coyote/http2/Http2UpgradeHandler.java
+++ b/java/org/apache/coyote/http2/Http2UpgradeHandler.java
@@ -40,7 +40,6 @@ import org.apache.coyote.Adapter;
 import org.apache.coyote.CloseNowException;
 import org.apache.coyote.ProtocolException;
 import org.apache.coyote.Request;
-import org.apache.coyote.Response;
 import org.apache.coyote.http11.upgrade.InternalHttpUpgradeHandler;
 import org.apache.coyote.http2.HpackDecoder.HeaderEmitter;
 import org.apache.coyote.http2.HpackEncoder.State;
@@ -49,6 +48,7 @@ import org.apache.coyote.http2.Http2Parser.Output;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.codec.binary.Base64;
+import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.SocketEvent;
@@ -522,11 +522,13 @@ class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeH
         }
     }
 
-    void writeHeaders(Stream stream, Response coyoteResponse, boolean endOfStream, int payloadSize)
-            throws IOException {
+    void writeHeaders(Stream stream, int pushedStreamId, MimeHeaders mimeHeaders,
+            boolean endOfStream, int payloadSize) throws IOException {
+
         if (log.isDebugEnabled()) {
             log.debug(sm.getString("upgradeHandler.writeHeaders", connectionId,
-                    stream.getIdentifier()));
+                    stream.getIdentifier(), Integer.valueOf(pushedStreamId),
+                    Boolean.valueOf(endOfStream)));
         }
 
         if (!stream.canWrite()) {
@@ -534,78 +536,37 @@ class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeH
         }
 
         byte[] header = new byte[9];
-        ByteBuffer target = ByteBuffer.allocate(payloadSize);
-        boolean first = true;
-        State state = null;
-        // This ensures the Stream processing thread has control of the socket.
-        synchronized (socketWrapper) {
-            while (state != State.COMPLETE) {
-                state = getHpackEncoder().encode(coyoteResponse.getMimeHeaders(), target);
-                target.flip();
-                if (state == State.COMPLETE || target.limit() > 0) {
-                    ByteUtil.setThreeBytes(header, 0, target.limit());
-                    if (first) {
-                        first = false;
-                        header[3] = FrameType.HEADERS.getIdByte();
-                        if (endOfStream) {
-                            header[4] = FLAG_END_OF_STREAM;
-                        }
-                    } else {
-                        header[3] = FrameType.CONTINUATION.getIdByte();
-                    }
-                    if (state == State.COMPLETE) {
-                        header[4] += FLAG_END_OF_HEADERS;
-                    }
-                    if (log.isDebugEnabled()) {
-                        log.debug(target.limit() + " bytes");
-                    }
-                    ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue());
-                    try {
-                        socketWrapper.write(true, header, 0, header.length);
-                        socketWrapper.write(true, target);
-                        socketWrapper.flush(true);
-                    } catch (IOException ioe) {
-                        handleAppInitiatedIOException(ioe);
-                    }
-                }
-                if (state == State.UNDERFLOW && target.limit() == 0) {
-                    target = ByteBuffer.allocate(target.capacity() * 2);
-                } else {
-                    target.clear();
-                }
-            }
-        }
-    }
-
+        ByteBuffer payload = ByteBuffer.allocate(payloadSize);
 
-    protected void writePushHeaders(Stream stream, int pushedStreamId, Request coyoteRequest, int payloadSize)
-            throws IOException {
-        if (log.isDebugEnabled()) {
-            log.debug(sm.getString("upgradeHandler.writePushHeaders", connectionId,
-                    stream.getIdentifier(), Integer.toString(pushedStreamId)));
+        byte[] pushedStreamIdBytes = null;
+        if (pushedStreamId > 0) {
+            pushedStreamIdBytes = new byte[4];
+            ByteUtil.set31Bits(pushedStreamIdBytes, 0, pushedStreamId);
         }
 
-        if (!stream.canWrite()) {
-            return;
-        }
-
-        byte[] header = new byte[9];
-        ByteBuffer target = ByteBuffer.allocate(payloadSize);
         boolean first = true;
         State state = null;
-        byte[] pushedStreamIdBytes = new byte[4];
-        ByteUtil.set31Bits(pushedStreamIdBytes, 0, pushedStreamId);
+
         // This ensures the Stream processing thread has control of the socket.
         synchronized (socketWrapper) {
-            target.put(pushedStreamIdBytes);
             while (state != State.COMPLETE) {
-                state = getHpackEncoder().encode(coyoteRequest.getMimeHeaders(), target);
-                target.flip();
-                if (state == State.COMPLETE || target.limit() > 0) {
-                    ByteUtil.setThreeBytes(header, 0, target.limit());
+                if (first && pushedStreamIdBytes != null) {
+                    payload.put(pushedStreamIdBytes);
+                }
+                state = getHpackEncoder().encode(mimeHeaders, payload);
+                payload.flip();
+                if (state == State.COMPLETE || payload.limit() > 0) {
+                    ByteUtil.setThreeBytes(header, 0, payload.limit());
                     if (first) {
                         first = false;
-                        header[3] = FrameType.PUSH_PROMISE.getIdByte();
+                        if (pushedStreamIdBytes == null) {
+                            header[3] = FrameType.HEADERS.getIdByte();
+                        } else {
+                            header[3] = FrameType.PUSH_PROMISE.getIdByte();
+                        }
+                        if (endOfStream) {
+                            header[4] = FLAG_END_OF_STREAM;
+                        }
                     } else {
                         header[3] = FrameType.CONTINUATION.getIdByte();
                     }
@@ -613,21 +574,19 @@ class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeH
                         header[4] += FLAG_END_OF_HEADERS;
                     }
                     if (log.isDebugEnabled()) {
-                        log.debug(target.limit() + " bytes");
+                        log.debug(payload.limit() + " bytes");
                     }
                     ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue());
                     try {
                         socketWrapper.write(true, header, 0, header.length);
-                        socketWrapper.write(true, target);
+                        socketWrapper.write(true, payload);
                         socketWrapper.flush(true);
                     } catch (IOException ioe) {
                         handleAppInitiatedIOException(ioe);
                     }
-                }
-                if (state == State.UNDERFLOW && target.limit() == 0) {
-                    target = ByteBuffer.allocate(target.capacity() * 2);
-                } else {
-                    target.clear();
+                    payload.clear();
+                } else if (state == State.UNDERFLOW) {
+                    payload = ByteBuffer.allocate(payload.capacity() * 2);
                 }
             }
         }
@@ -1133,7 +1092,8 @@ class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeH
         Stream pushStream  = createLocalStream(request);
 
         // TODO: Is 1k the optimal value?
-        writePushHeaders(associatedStream, pushStream.getIdentifier().intValue(), request, 1024);
+        writeHeaders(associatedStream, pushStream.getIdentifier().intValue(),
+                request.getMimeHeaders(), false, 1024);
 
         pushStream.sentPushPromise();
 

==================================================
