b6ae4792cc57c0760a7aa9f6eeb6a4721e00fb6a
==================================================
Remove generics from Processor.
==================================================
Mark Thomas
==================================================
Fri Jan 30 10:24:10 2015 +0000
==================================================
AbstractProcessor.java
Remove generics from Processor.
This removes I/O implementation specific code from several places in the Protocol implementations and will allow those methods to be pulled up.
This commit includes a couple of temporary methods in SocketWrapperBase that I hope to be able to remove at a later stage of refactoring.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1655976 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractProtocol.java
index cc49af97f0..8e0bbf6748 100644
--- a/java/org/apache/coyote/AbstractProcessor.java
+++ b/java/org/apache/coyote/AbstractProcessor.java
@@ -32,16 +32,16 @@ import org.apache.tomcat.util.res.StringManager;
  * Provides functionality and attributes common to all supported protocols
  * (currently HTTP and AJP).
  */
-public abstract class AbstractProcessor<S> implements ActionHook, Processor<S> {
+public abstract class AbstractProcessor implements ActionHook, Processor {
 
     protected static final StringManager sm = StringManager.getManager(Constants.Package);
 
     protected Adapter adapter;
     protected final AsyncStateMachine asyncStateMachine;
-    protected final AbstractEndpoint<S> endpoint;
+    protected final AbstractEndpoint<?> endpoint;
     protected final Request request;
     protected final Response response;
-    protected SocketWrapperBase<S> socketWrapper = null;
+    protected SocketWrapperBase<?> socketWrapper = null;
     private String clientCertProvider = null;
 
     /**
@@ -61,7 +61,7 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor<S> {
         response = null;
     }
 
-    public AbstractProcessor(AbstractEndpoint<S> endpoint) {
+    public AbstractProcessor(AbstractEndpoint<?> endpoint) {
         this.endpoint = endpoint;
         asyncStateMachine = new AsyncStateMachine(this);
         request = new Request();
@@ -87,7 +87,7 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor<S> {
                 response.setStatus(500);
             }
             getLog().info(sm.getString("abstractProcessor.nonContainerThreadError"), t);
-            getEndpoint().processSocket(socketWrapper, SocketStatus.CLOSE_NOW, true);
+            socketWrapper.processSocket(SocketStatus.CLOSE_NOW, true);
         }
     }
 
@@ -104,7 +104,7 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor<S> {
     /**
      * The endpoint receiving connections that are handled by this processor.
      */
-    protected AbstractEndpoint<S> getEndpoint() {
+    protected AbstractEndpoint<?> getEndpoint() {
         return endpoint;
     }
 
@@ -152,7 +152,7 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor<S> {
     /**
      * Set the socket wrapper being used.
      */
-    protected final void setSocketWrapper(SocketWrapperBase<S> socketWrapper) {
+    protected final void setSocketWrapper(SocketWrapperBase<?> socketWrapper) {
         this.socketWrapper = socketWrapper;
     }
 
@@ -160,7 +160,7 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor<S> {
     /**
      * Get the socket wrapper being used.
      */
-    protected final SocketWrapperBase<S> getSocketWrapper() {
+    protected final SocketWrapperBase<?> getSocketWrapper() {
         return socketWrapper;
     }
 
@@ -198,7 +198,7 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor<S> {
      * with although they may change type during processing.
      */
     @Override
-    public abstract SocketState process(SocketWrapperBase<S> socket) throws IOException;
+    public abstract SocketState process(SocketWrapperBase<?> socket) throws IOException;
 
     /**
      * Process in-progress Servlet 3.0 Async requests. These will start as HTTP

==================================================
AsyncStateMachine.java
index f7df3f922b..9285f80aea 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -567,7 +567,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
 
     // ------------------------------------------- Connection handler base class
 
-    protected abstract static class AbstractConnectionHandler<S,P extends Processor<S>>
+    protected abstract static class AbstractConnectionHandler<S,P extends Processor>
             implements AbstractEndpoint.Handler<S> {
 
         protected abstract Log getLog();
@@ -575,7 +575,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
         protected final RequestGroupInfo global = new RequestGroupInfo();
         protected final AtomicLong registerCount = new AtomicLong(0);
 
-        protected final ConcurrentHashMap<S,Processor<S>> connections =
+        protected final ConcurrentHashMap<S,Processor> connections =
                 new ConcurrentHashMap<>();
 
         protected final RecycledProcessors<P,S> recycledProcessors =
@@ -610,7 +610,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
                 return SocketState.CLOSED;
             }
 
-            Processor<S> processor = connections.get(socket);
+            Processor processor = connections.get(socket);
             if (status == SocketStatus.DISCONNECT && processor == null) {
                 // Nothing to do. Endpoint requested a close and there is no
                 // longer a processor associated with this socket.
@@ -775,9 +775,9 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
 
         protected abstract P createProcessor();
         protected abstract void initSsl(SocketWrapperBase<S> socket,
-                Processor<S> processor);
+                Processor processor);
         protected abstract void longPoll(SocketWrapperBase<S> socket,
-                Processor<S> processor);
+                Processor processor);
 
         /**
          * Expected to be used by the handler once the processor is no longer
@@ -791,12 +791,12 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
          *                    reading
          */
         protected abstract void release(SocketWrapperBase<S> socket,
-                Processor<S> processor, boolean addToPoller);
-        protected abstract Processor<S> createUpgradeProcessor(
-                SocketWrapperBase<S> socket, ByteBuffer leftoverInput,
+                Processor processor, boolean addToPoller);
+        protected abstract Processor createUpgradeProcessor(
+                SocketWrapperBase<?> socket, ByteBuffer leftoverInput,
                 HttpUpgradeHandler httpUpgradeHandler) throws IOException;
 
-        protected void register(AbstractProcessor<S> processor) {
+        protected void register(AbstractProcessor processor) {
             if (getProtocol().getDomain() != null) {
                 synchronized (this) {
                     try {
@@ -823,7 +823,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
             }
         }
 
-        protected void unregister(Processor<S> processor) {
+        protected void unregister(Processor processor) {
             if (getProtocol().getDomain() != null) {
                 synchronized (this) {
                     try {
@@ -849,8 +849,8 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
         }
     }
 
-    protected static class RecycledProcessors<P extends Processor<S>, S>
-            extends SynchronizedStack<Processor<S>> {
+    protected static class RecycledProcessors<P extends Processor, S>
+            extends SynchronizedStack<Processor> {
 
         private final transient AbstractConnectionHandler<S,P> handler;
         protected final AtomicInteger size = new AtomicInteger(0);
@@ -861,7 +861,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
 
         @SuppressWarnings("sync-override") // Size may exceed cache size a bit
         @Override
-        public boolean push(Processor<S> processor) {
+        public boolean push(Processor processor) {
             int cacheSize = handler.getProtocol().getProcessorCache();
             boolean offer = cacheSize == -1 ? true : size.get() < cacheSize;
             //avoid over growing our cache or add after we have stopped
@@ -878,8 +878,8 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
 
         @SuppressWarnings("sync-override") // OK if size is too big briefly
         @Override
-        public Processor<S> pop() {
-            Processor<S> result = super.pop();
+        public Processor pop() {
+            Processor result = super.pop();
             if (result != null) {
                 size.decrementAndGet();
             }
@@ -888,7 +888,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
 
         @Override
         public synchronized void clear() {
-            Processor<S> next = pop();
+            Processor next = pop();
             while (next != null) {
                 handler.unregister(next);
                 next = pop();

==================================================
Processor.java
index 3d3e6853bd..8be962cf01 100644
--- a/java/org/apache/coyote/AsyncStateMachine.java
+++ b/java/org/apache/coyote/AsyncStateMachine.java
@@ -157,10 +157,10 @@ public class AsyncStateMachine {
     private volatile AsyncState state = AsyncState.DISPATCHED;
     // Need this to fire listener on complete
     private AsyncContextCallback asyncCtxt = null;
-    private final Processor<?> processor;
+    private final Processor processor;
 
 
-    public AsyncStateMachine(Processor<?> processor) {
+    public AsyncStateMachine(Processor processor) {
         this.processor = processor;
     }
 

==================================================
AbstractAjpProtocol.java
index 4c875e9e57..c05e2ca38e 100644
--- a/java/org/apache/coyote/Processor.java
+++ b/java/org/apache/coyote/Processor.java
@@ -31,10 +31,10 @@ import org.apache.tomcat.util.net.SocketWrapperBase;
 /**
  * Common interface for processors of all protocols.
  */
-public interface Processor<S> {
+public interface Processor {
     Executor getExecutor();
 
-    SocketState process(SocketWrapperBase<S> socketWrapper) throws IOException;
+    SocketState process(SocketWrapperBase<?> socketWrapper) throws IOException;
 
     SocketState asyncDispatch(SocketStatus status);
     SocketState asyncPostProcess();

==================================================
AjpAprProtocol.java
index 09c7345920..f550d12b3f 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProtocol.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProtocol.java
@@ -103,7 +103,7 @@ public abstract class AbstractAjpProtocol<S> extends AbstractProtocol<S> {
         }
     }
 
-    protected void configureProcessor(AjpProcessor<S> processor) {
+    protected void configureProcessor(AjpProcessor processor) {
         processor.setAdapter(getAdapter());
         processor.setTomcatAuthentication(getTomcatAuthentication());
         processor.setRequiredSecret(requiredSecret);
@@ -112,7 +112,7 @@ public abstract class AbstractAjpProtocol<S> extends AbstractProtocol<S> {
     }
 
     protected abstract static class AbstractAjpConnectionHandler<S>
-            extends AbstractConnectionHandler<S,AjpProcessor<S>> {
+            extends AbstractConnectionHandler<S,AjpProcessor> {
 
         private final AbstractAjpProtocol<S> proto;
 
@@ -127,28 +127,26 @@ public abstract class AbstractAjpProtocol<S> extends AbstractProtocol<S> {
 
 
         @Override
-        protected AjpProcessor<S> createProcessor() {
-            AjpProcessor<S> processor =
-                    new AjpProcessor<>(proto.getPacketSize(), proto.getEndpoint());
+        protected AjpProcessor createProcessor() {
+            AjpProcessor processor = new AjpProcessor(proto.getPacketSize(), proto.getEndpoint());
             proto.configureProcessor(processor);
             register(processor);
             return processor;
         }
 
         @Override
-        protected void initSsl(SocketWrapperBase<S> socket, Processor<S> processor) {
+        protected void initSsl(SocketWrapperBase<S> socket, Processor processor) {
             // NOOP for AJP
         }
 
         @Override
-        protected void longPoll(SocketWrapperBase<S> socket,
-                Processor<S> processor) {
+        protected void longPoll(SocketWrapperBase<S> socket, Processor processor) {
             // Same requirements for all AJP connectors
             socket.setAsync(true);
         }
 
         @Override
-        protected AjpProcessor<S> createUpgradeProcessor(SocketWrapperBase<S> socket,
+        protected AjpProcessor createUpgradeProcessor(SocketWrapperBase<?> socket,
                 ByteBuffer leftoverInput, HttpUpgradeHandler httpUpgradeHandler) {
             // TODO should fail - throw IOE
             return null;

==================================================
AjpNio2Protocol.java
index d27cd58c47..1dee0b93d3 100644
--- a/java/org/apache/coyote/ajp/AjpAprProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpAprProtocol.java
@@ -86,7 +86,7 @@ public class AjpAprProtocol extends AbstractAjpProtocol<Long> {
 
         @Override
         public void release(SocketWrapperBase<Long> socket,
-                Processor<Long> processor, boolean addToPoller) {
+                Processor processor, boolean addToPoller) {
             processor.recycle();
             recycledProcessors.push(processor);
             if (addToPoller) {

==================================================
AjpNioProtocol.java
index 9a24db7e4f..2a2309e05d 100644
--- a/java/org/apache/coyote/ajp/AjpNio2Protocol.java
+++ b/java/org/apache/coyote/ajp/AjpNio2Protocol.java
@@ -84,8 +84,7 @@ public class AjpNio2Protocol extends AbstractAjpProtocol<Nio2Channel> {
          */
         @Override
         public void release(SocketWrapperBase<Nio2Channel> socket) {
-            Processor<Nio2Channel> processor =
-                    connections.remove(socket.getSocket());
+            Processor processor = connections.remove(socket.getSocket());
             if (processor != null) {
                 processor.recycle();
                 recycledProcessors.push(processor);
@@ -94,7 +93,7 @@ public class AjpNio2Protocol extends AbstractAjpProtocol<Nio2Channel> {
 
         @Override
         public void release(SocketWrapperBase<Nio2Channel> socket,
-                Processor<Nio2Channel> processor, boolean addToPoller) {
+                Processor processor, boolean addToPoller) {
             if (getLog().isDebugEnabled()) {
                 log.debug("Socket: [" + socket + "], Processor: [" + processor +
                         "], addToPoller: [" + addToPoller + "]");

==================================================
AjpProcessor.java
index 74f91e2767..21e4cd6445 100644
--- a/java/org/apache/coyote/ajp/AjpNioProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpNioProtocol.java
@@ -89,12 +89,12 @@ public class AjpNioProtocol extends AbstractAjpProtocol<NioChannel> {
             if (log.isDebugEnabled())
                 log.debug(sm.getString("ajpnioprotocol.releaseStart", socket));
             boolean released = false;
-            Iterator<java.util.Map.Entry<NioChannel, Processor<NioChannel>>> it = connections.entrySet().iterator();
+            Iterator<java.util.Map.Entry<NioChannel, Processor>> it = connections.entrySet().iterator();
             while (it.hasNext()) {
-                java.util.Map.Entry<NioChannel, Processor<NioChannel>> entry = it.next();
+                java.util.Map.Entry<NioChannel, Processor> entry = it.next();
                 if (entry.getKey().getIOChannel()==socket) {
                     it.remove();
-                    Processor<NioChannel> result = entry.getValue();
+                    Processor result = entry.getValue();
                     result.recycle();
                     unregister(result);
                     released = true;
@@ -113,8 +113,7 @@ public class AjpNioProtocol extends AbstractAjpProtocol<NioChannel> {
          */
         @Override
         public void release(SocketWrapperBase<NioChannel> socket) {
-            Processor<NioChannel> processor =
-                    connections.remove(socket.getSocket());
+            Processor processor = connections.remove(socket.getSocket());
             if (processor != null) {
                 processor.recycle();
                 recycledProcessors.push(processor);
@@ -124,7 +123,7 @@ public class AjpNioProtocol extends AbstractAjpProtocol<NioChannel> {
 
         @Override
         public void release(SocketWrapperBase<NioChannel> socket,
-               Processor<NioChannel> processor,  boolean addToPoller) {
+               Processor processor,  boolean addToPoller) {
             processor.recycle();
             recycledProcessors.push(processor);
             if (addToPoller) {

==================================================
AbstractHttp11Protocol.java
index ffdb49cc2b..2ceab6fe00 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -56,11 +56,8 @@ import org.apache.tomcat.util.res.StringManager;
 
 /**
  * AJP Processor implementation.
- *
- * @param <S> The socket type of the IO implementation used by this processor
- *            instance.
  */
-public class AjpProcessor<S> extends AbstractProcessor<S> {
+public class AjpProcessor extends AbstractProcessor {
 
     private static final Log log = LogFactory.getLog(AjpProcessor.class);
     /**
@@ -250,7 +247,7 @@ public class AjpProcessor<S> extends AbstractProcessor<S> {
 
     // ------------------------------------------------------------ Constructor
 
-    public AjpProcessor(int packetSize, AbstractEndpoint<S> endpoint) {
+    public AjpProcessor(int packetSize, AbstractEndpoint<?> endpoint) {
 
         super(endpoint);
 
@@ -498,13 +495,13 @@ public class AjpProcessor<S> extends AbstractProcessor<S> {
         case ASYNC_COMPLETE: {
             socketWrapper.clearDispatches();
             if (asyncStateMachine.asyncComplete()) {
-                endpoint.processSocket(socketWrapper, SocketStatus.OPEN_READ, true);
+                socketWrapper.processSocket(SocketStatus.OPEN_READ, true);
             }
             break;
         }
         case ASYNC_DISPATCH: {
             if (asyncStateMachine.asyncDispatch()) {
-                endpoint.processSocket(socketWrapper, SocketStatus.OPEN_READ, true);
+                socketWrapper.processSocket(SocketStatus.OPEN_READ, true);
             }
             break;
         }
@@ -594,7 +591,7 @@ public class AjpProcessor<S> extends AbstractProcessor<S> {
             break;
         }
         case DISPATCH_EXECUTE: {
-            getEndpoint().executeNonBlockingDispatches(socketWrapper);
+            socketWrapper.executeNonBlockingDispatches();
             break;
         }
         case CLOSE_NOW: {
@@ -690,7 +687,7 @@ public class AjpProcessor<S> extends AbstractProcessor<S> {
      * @throws IOException error during an I/O operation
      */
     @Override
-    public SocketState process(SocketWrapperBase<S> socket) throws IOException {
+    public SocketState process(SocketWrapperBase<?> socket) throws IOException {
 
         RequestInfo rp = request.getRequestProcessor();
         rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);

==================================================
Http11AprProtocol.java
index fb29337c5c..c06ae4d094 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
@@ -214,7 +214,7 @@ public abstract class AbstractHttp11Protocol<S> extends AbstractProtocol<S> {
     // ------------------------------------------------------------- Common code
 
     // Common configuration required for all new HTTP11 processors
-    protected void configureProcessor(Http11Processor<S> processor) {
+    protected void configureProcessor(Http11Processor processor) {
         processor.setAdapter(getAdapter());
         processor.setMaxKeepAliveRequests(getMaxKeepAliveRequests());
         processor.setConnectionUploadTimeout(getConnectionUploadTimeout());

==================================================
Http11Nio2Protocol.java
index 7d7fd546c0..8bb3512cd6 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -212,7 +212,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
     // --------------------  Connection handler --------------------
 
     protected static class Http11ConnectionHandler
-            extends AbstractConnectionHandler<Long,Http11Processor<Long>> {
+            extends AbstractConnectionHandler<Long,Http11Processor> {
 
         protected Http11AprProtocol proto;
 
@@ -232,7 +232,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
 
         @Override
         public void release(SocketWrapperBase<Long> socket,
-                Processor<Long> processor, boolean addToPoller) {
+                Processor processor, boolean addToPoller) {
             processor.recycle();
             recycledProcessors.push(processor);
             if (addToPoller && proto.getEndpoint().isRunning()) {
@@ -246,7 +246,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
         public SocketState process(SocketWrapperBase<Long> socket,
                 SocketStatus status) {
             if (proto.npnHandler != null) {
-                Processor<Long> processor = null;
+                Processor processor = null;
                 if (status == SocketStatus.OPEN_READ) {
                     processor = connections.get(socket.getSocket());
 
@@ -265,7 +265,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
         }
 
         @Override
-        protected void initSsl(SocketWrapperBase<Long> socket, Processor<Long> processor) {
+        protected void initSsl(SocketWrapperBase<Long> socket, Processor processor) {
             if (proto.isSSLEnabled()) {
                 AprSSLSupport sslSupport =
                         new AprSSLSupport(socket, processor.getClientCertProvider());
@@ -276,8 +276,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
         }
 
         @Override
-        protected void longPoll(SocketWrapperBase<Long> socket,
-                Processor<Long> processor) {
+        protected void longPoll(SocketWrapperBase<Long> socket, Processor processor) {
 
             if (processor.isAsync()) {
                 // Async
@@ -295,8 +294,8 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
         }
 
         @Override
-        protected Http11Processor<Long> createProcessor() {
-            Http11Processor<Long> processor = new Http11Processor<>(
+        protected Http11Processor createProcessor() {
+            Http11Processor processor = new Http11Processor(
                     proto.getMaxHttpHeaderSize(), proto.getEndpoint(),
                     proto.getMaxTrailerSize(), proto.getMaxExtensionSize(),
                     proto.getMaxSwallowSize());
@@ -308,11 +307,11 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
         }
 
         @Override
-        protected Processor<Long> createUpgradeProcessor(
-                SocketWrapperBase<Long> socket, ByteBuffer leftoverInput,
+        protected Processor createUpgradeProcessor(
+                SocketWrapperBase<?> socket, ByteBuffer leftoverInput,
                 HttpUpgradeHandler httpUpgradeHandler)
                 throws IOException {
-            return new UpgradeProcessor<>(socket, leftoverInput, httpUpgradeHandler);
+            return new UpgradeProcessor(socket, leftoverInput, httpUpgradeHandler);
         }
     }
 }

==================================================
Http11NioProtocol.java
index b0a3eae311..8bb9136740 100644
--- a/java/org/apache/coyote/http11/Http11Nio2Protocol.java
+++ b/java/org/apache/coyote/http11/Http11Nio2Protocol.java
@@ -100,7 +100,7 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
     // --------------------  Connection handler --------------------
 
     protected static class Http11ConnectionHandler
-            extends AbstractConnectionHandler<Nio2Channel,Http11Processor<Nio2Channel>>
+            extends AbstractConnectionHandler<Nio2Channel,Http11Processor>
             implements Handler {
 
         protected Http11Nio2Protocol proto;
@@ -131,8 +131,7 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
          */
         @Override
         public void release(SocketWrapperBase<Nio2Channel> socket) {
-            Processor<Nio2Channel> processor =
-                connections.remove(socket.getSocket());
+            Processor processor = connections.remove(socket.getSocket());
             if (processor != null) {
                 processor.recycle();
                 recycledProcessors.push(processor);
@@ -154,7 +153,7 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
 
         @Override
         public void release(SocketWrapperBase<Nio2Channel> socket,
-                Processor<Nio2Channel> processor, boolean addToPoller) {
+                Processor processor, boolean addToPoller) {
             processor.recycle();
             recycledProcessors.push(processor);
             if (socket.isAsync()) {
@@ -167,8 +166,7 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
 
 
         @Override
-        protected void initSsl(SocketWrapperBase<Nio2Channel> socket,
-                Processor<Nio2Channel> processor) {
+        protected void initSsl(SocketWrapperBase<Nio2Channel> socket, Processor processor) {
             if (proto.isSSLEnabled() &&
                     (proto.sslImplementation != null)
                     && (socket.getSocket() instanceof SecureNio2Channel)) {
@@ -183,8 +181,7 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
         }
 
         @Override
-        protected void longPoll(SocketWrapperBase<Nio2Channel> socket,
-                Processor<Nio2Channel> processor) {
+        protected void longPoll(SocketWrapperBase<Nio2Channel> socket, Processor processor) {
             if (processor.isAsync()) {
                 socket.setAsync(true);
                 ((Nio2Endpoint) proto.getEndpoint()).addTimeout(socket);
@@ -209,8 +206,8 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
         }
 
         @Override
-        public Http11Processor<Nio2Channel> createProcessor() {
-            Http11Processor<Nio2Channel> processor = new Http11Processor<>(
+        public Http11Processor createProcessor() {
+            Http11Processor processor = new Http11Processor(
                     proto.getMaxHttpHeaderSize(), proto.getEndpoint(),
                     proto.getMaxTrailerSize(), proto.getMaxExtensionSize(),
                     proto.getMaxSwallowSize());
@@ -220,11 +217,11 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
         }
 
         @Override
-        protected Processor<Nio2Channel> createUpgradeProcessor(
-                SocketWrapperBase<Nio2Channel> socket, ByteBuffer leftoverInput,
+        protected Processor createUpgradeProcessor(
+                SocketWrapperBase<?> socket, ByteBuffer leftoverInput,
                 HttpUpgradeHandler httpUpgradeHandler)
                 throws IOException {
-            return new UpgradeProcessor<>(socket, leftoverInput, httpUpgradeHandler);
+            return new UpgradeProcessor(socket, leftoverInput, httpUpgradeHandler);
         }
 
         @Override

==================================================
Http11Processor.java
index 7811da7e9d..70323907d0 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -127,7 +127,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
     // --------------------  Connection handler --------------------
 
     protected static class Http11ConnectionHandler
-            extends AbstractConnectionHandler<NioChannel,Http11Processor<NioChannel>>
+            extends AbstractConnectionHandler<NioChannel,Http11Processor>
             implements Handler {
 
         protected Http11NioProtocol proto;
@@ -161,12 +161,12 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
             if (log.isDebugEnabled())
                 log.debug("Iterating through our connections to release a socket channel:"+socket);
             boolean released = false;
-            Iterator<java.util.Map.Entry<NioChannel, Processor<NioChannel>>> it = connections.entrySet().iterator();
+            Iterator<java.util.Map.Entry<NioChannel, Processor>> it = connections.entrySet().iterator();
             while (it.hasNext()) {
-                java.util.Map.Entry<NioChannel, Processor<NioChannel>> entry = it.next();
+                java.util.Map.Entry<NioChannel, Processor> entry = it.next();
                 if (entry.getKey().getIOChannel()==socket) {
                     it.remove();
-                    Processor<NioChannel> result = entry.getValue();
+                    Processor result = entry.getValue();
                     result.recycle();
                     unregister(result);
                     released = true;
@@ -183,8 +183,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
          */
         @Override
         public void release(SocketWrapperBase<NioChannel> socket) {
-            Processor<NioChannel> processor =
-                connections.remove(socket.getSocket());
+            Processor processor = connections.remove(socket.getSocket());
             if (processor != null) {
                 processor.recycle();
                 recycledProcessors.push(processor);
@@ -206,7 +205,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
 
         @Override
         public void release(SocketWrapperBase<NioChannel> socket,
-                Processor<NioChannel> processor, boolean addToPoller) {
+                Processor processor, boolean addToPoller) {
             processor.recycle();
             recycledProcessors.push(processor);
             if (addToPoller) {
@@ -216,8 +215,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
 
 
         @Override
-        protected void initSsl(SocketWrapperBase<NioChannel> socket,
-                Processor<NioChannel> processor) {
+        protected void initSsl(SocketWrapperBase<NioChannel> socket, Processor processor) {
             if (proto.isSSLEnabled() &&
                     (proto.sslImplementation != null)
                     && (socket.getSocket() instanceof SecureNioChannel)) {
@@ -232,8 +230,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
         }
 
         @Override
-        protected void longPoll(SocketWrapperBase<NioChannel> socket,
-                Processor<NioChannel> processor) {
+        protected void longPoll(SocketWrapperBase<NioChannel> socket, Processor processor) {
 
             if (processor.isAsync()) {
                 socket.setAsync(true);
@@ -247,8 +244,8 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
         }
 
         @Override
-        public Http11Processor<NioChannel> createProcessor() {
-            Http11Processor<NioChannel> processor = new Http11Processor<>(
+        public Http11Processor createProcessor() {
+            Http11Processor processor = new Http11Processor(
                     proto.getMaxHttpHeaderSize(), proto.getEndpoint(),
                     proto.getMaxTrailerSize(), proto.getMaxExtensionSize(),
                     proto.getMaxSwallowSize());
@@ -258,11 +255,11 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
         }
 
         @Override
-        protected Processor<NioChannel> createUpgradeProcessor(
-                SocketWrapperBase<NioChannel> socket, ByteBuffer leftoverInput,
+        protected Processor createUpgradeProcessor(
+                SocketWrapperBase<?> socket, ByteBuffer leftoverInput,
                 HttpUpgradeHandler httpUpgradeHandler)
                 throws IOException {
-            return new UpgradeProcessor<>(socket, leftoverInput, httpUpgradeHandler);
+            return new UpgradeProcessor(socket, leftoverInput, httpUpgradeHandler);
         }
 
         @Override

==================================================
UpgradeProcessor.java
index 4016a2ef31..9f7ff4d821 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -61,9 +61,9 @@ import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
-public class Http11Processor<S> extends AbstractProcessor<S> {
+public class Http11Processor extends AbstractProcessor {
 
-    private static final Log log = LogFactory.getLog(Http11AprProtocol.class);
+    private static final Log log = LogFactory.getLog(Http11Processor.class);
 
     /**
      * The string manager for this package.
@@ -238,7 +238,7 @@ public class Http11Processor<S> extends AbstractProcessor<S> {
     protected SSLSupport sslSupport;
 
 
-    public Http11Processor(int maxHttpHeaderSize, AbstractEndpoint<S> endpoint,
+    public Http11Processor(int maxHttpHeaderSize, AbstractEndpoint<?> endpoint,
             int maxTrailerSize, int maxExtensionSize, int maxSwallowSize) {
 
         super(endpoint);
@@ -841,7 +841,7 @@ public class Http11Processor<S> extends AbstractProcessor<S> {
         case ASYNC_COMPLETE: {
             socketWrapper.clearDispatches();
             if (asyncStateMachine.asyncComplete()) {
-                endpoint.processSocket(this.socketWrapper, SocketStatus.OPEN_READ, true);
+                socketWrapper.processSocket(SocketStatus.OPEN_READ, true);
             }
             break;
         }
@@ -855,7 +855,7 @@ public class Http11Processor<S> extends AbstractProcessor<S> {
         }
         case ASYNC_DISPATCH: {
             if (asyncStateMachine.asyncDispatch()) {
-                endpoint.processSocket(this.socketWrapper, SocketStatus.OPEN_READ, true);
+                socketWrapper.processSocket(SocketStatus.OPEN_READ, true);
             }
             break;
         }
@@ -892,9 +892,9 @@ public class Http11Processor<S> extends AbstractProcessor<S> {
             break;
         }
         case DISPATCH_EXECUTE: {
-            SocketWrapperBase<S> wrapper = socketWrapper;
+            SocketWrapperBase<?> wrapper = socketWrapper;
             if (wrapper != null) {
-                getEndpoint().executeNonBlockingDispatches(wrapper);
+                wrapper.executeNonBlockingDispatches();
             }
             break;
         }
@@ -1017,7 +1017,7 @@ public class Http11Processor<S> extends AbstractProcessor<S> {
      * @throws IOException error during an I/O operation
      */
     @Override
-    public SocketState process(SocketWrapperBase<S> socketWrapper)
+    public SocketState process(SocketWrapperBase<?> socketWrapper)
         throws IOException {
         RequestInfo rp = request.getRequestProcessor();
         rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
@@ -1869,7 +1869,7 @@ public class Http11Processor<S> extends AbstractProcessor<S> {
      *
      * @return true if the keep-alive loop should be broken
      */
-    private boolean breakKeepAliveLoop(SocketWrapperBase<S> socketWrapper) {
+    private boolean breakKeepAliveLoop(SocketWrapperBase<?> socketWrapper) {
         openSocket = keepAlive;
         // Do sendfile as needed: add socket to sendfile and end
         if (sendfileData != null && !getErrorState().isError()) {

==================================================
SpdyAprNpnHandler.java
index 4ec63a31bd..83b9508f34 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeProcessor.java
@@ -35,7 +35,7 @@ import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
-public class UpgradeProcessor<S> implements Processor<S>, WebConnection {
+public class UpgradeProcessor implements Processor, WebConnection {
 
     private static final int INFINITE_TIMEOUT = -1;
 
@@ -140,7 +140,7 @@ public class UpgradeProcessor<S> implements Processor<S>, WebConnection {
 
 
     @Override
-    public final SocketState process(SocketWrapperBase<S> socketWrapper) throws IOException {
+    public final SocketState process(SocketWrapperBase<?> socketWrapper) throws IOException {
         return null;
     }
 

==================================================
SpdyProcessor.java
index e1d5f83901..8a63d38509 100644
--- a/java/org/apache/coyote/spdy/SpdyAprNpnHandler.java
+++ b/java/org/apache/coyote/spdy/SpdyAprNpnHandler.java
@@ -82,7 +82,7 @@ public class SpdyAprNpnHandler implements NpnHandler<Long> {
             @Override
             public void onStream(SpdyConnection con, SpdyStream ch)
                     throws IOException {
-                SpdyProcessor<Long> sp = new SpdyProcessor<>(con, ep);
+                SpdyProcessor sp = new SpdyProcessor(con, ep);
                 sp.setAdapter(adapter);
                 sp.onSynStream(ch);
             }

==================================================
SpdyProxyProtocol.java
index 39a62835b3..b88c67db11 100644
--- a/java/org/apache/coyote/spdy/SpdyProcessor.java
+++ b/java/org/apache/coyote/spdy/SpdyProcessor.java
@@ -57,7 +57,7 @@ import org.apache.tomcat.util.net.SocketWrapperBase;
  *
  * Based on the AJP processor.
  */
-public class SpdyProcessor<S> extends AbstractProcessor<S> implements Runnable {
+public class SpdyProcessor extends AbstractProcessor implements Runnable {
 
     private static final Log log = LogFactory.getLog(SpdyProcessor.class);
 
@@ -82,7 +82,7 @@ public class SpdyProcessor<S> extends AbstractProcessor<S> implements Runnable {
 
     private boolean outCommit = false;
 
-    public SpdyProcessor(SpdyConnection spdy, AbstractEndpoint<S> endpoint) {
+    public SpdyProcessor(SpdyConnection spdy, AbstractEndpoint<?> endpoint) {
         super(endpoint);
 
         this.spdy = spdy;
@@ -505,7 +505,7 @@ public class SpdyProcessor<S> extends AbstractProcessor<S> implements Runnable {
     }
 
     @Override
-    public SocketState process(SocketWrapperBase<S> socket)
+    public SocketState process(SocketWrapperBase<?> socket)
             throws IOException {
         throw new IOException("Unimplemented");
     }

==================================================
SocketWrapperBase.java
index ab72e3e0bf..5f19a4d797 100644
--- a/java/org/apache/coyote/spdy/SpdyProxyProtocol.java
+++ b/java/org/apache/coyote/spdy/SpdyProxyProtocol.java
@@ -93,7 +93,7 @@ public class SpdyProxyProtocol extends AbstractProtocol<NioChannel> {
         spdyContext.setHandler(new SpdyHandler() {
             @Override
             public void onStream(SpdyConnection con, SpdyStream ch) throws IOException {
-                SpdyProcessor<NioChannel> sp = new SpdyProcessor<>(con, getEndpoint());
+                SpdyProcessor sp = new SpdyProcessor(con, getEndpoint());
                 sp.setAdapter(getAdapter());
                 sp.onSynStream(ch);
             }

==================================================
