a0fcc73f0a8d7f17fdd5383fb3b48401c68e0d3b
==================================================
Whitespace removal from remaining /java/org/apache/juli
==================================================
Mark Emlyn
==================================================
Sat Oct 22 21:21:17 2011 +0000
==================================================
AsyncFileHandler.java
Whitespace removal from remaining /java/org/apache/juli

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1187804 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ClassLoaderLogManager.java
index c58050e43d..4e1e02a58e 100644
--- a/java/org/apache/juli/AsyncFileHandler.java
+++ b/java/org/apache/juli/AsyncFileHandler.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -26,7 +26,7 @@ import java.util.logging.LogRecord;
  * class. This class does not add its own configuration properties for the
  * logging configuration, but relies on the following system properties
  * instead:</p>
- * 
+ *
  * <ul>
  *   <li><code>org.apache.juli.AsyncOverflowDropType</code>
  *    Default value: <code>1</code></li>
@@ -35,9 +35,9 @@ import java.util.logging.LogRecord;
  *   <li><code>org.apache.juli.AsyncLoggerPollInterval</code>
  *    Default value: <code>1000</code></li>
  * </ul>
- * 
+ *
  * <p>See the System Properties page in the configuration reference of Tomcat.</p>
- * 
+ *
  * @author Filip Hanik
  *
  */
@@ -47,21 +47,21 @@ public class AsyncFileHandler extends FileHandler {
     public static final int OVERFLOW_DROP_FIRST = 2;
     public static final int OVERFLOW_DROP_FLUSH = 3;
     public static final int OVERFLOW_DROP_CURRENT = 4;
-    
+
     public static final int OVERFLOW_DROP_TYPE = Integer.parseInt(System.getProperty("org.apache.juli.AsyncOverflowDropType","1"));
     public static final int DEFAULT_MAX_RECORDS = Integer.parseInt(System.getProperty("org.apache.juli.AsyncMaxRecordCount","10000"));
     public static final int LOGGER_SLEEP_TIME = Integer.parseInt(System.getProperty("org.apache.juli.AsyncLoggerPollInterval","1000"));
-   
+
     protected static LinkedBlockingDeque<LogEntry> queue = new LinkedBlockingDeque<LogEntry>(DEFAULT_MAX_RECORDS);
-    
+
     protected static LoggerThread logger = new LoggerThread();
-    
+
     static {
         logger.start();
     }
-    
+
     protected volatile boolean closed = false;
-    
+
     public AsyncFileHandler() {
         this(null,null,null);
     }
@@ -78,7 +78,7 @@ public class AsyncFileHandler extends FileHandler {
         // TODO Auto-generated method stub
         super.close();
     }
-    
+
     @Override
     protected void open() {
         if(!closed) return;
@@ -86,7 +86,7 @@ public class AsyncFileHandler extends FileHandler {
         // TODO Auto-generated method stub
         super.open();
     }
-    
+
 
     @Override
     public void publish(LogRecord record) {
@@ -100,7 +100,7 @@ public class AsyncFileHandler extends FileHandler {
                 switch (OVERFLOW_DROP_TYPE) {
                     case OVERFLOW_DROP_LAST: {
                         //remove the last added element
-                        queue.pollLast(); 
+                        queue.pollLast();
                         break;
                     }
                     case OVERFLOW_DROP_FIRST: {
@@ -123,9 +123,9 @@ public class AsyncFileHandler extends FileHandler {
             //after this we clear the flag
             Thread.interrupted();
         }
-        
+
     }
-    
+
     protected void publishInternal(LogRecord record) {
         super.publish(record);
     }
@@ -136,7 +136,7 @@ public class AsyncFileHandler extends FileHandler {
             this.setDaemon(true);
             this.setName("AsyncFileHandlerWriter-"+System.identityHashCode(this));
         }
-        
+
         @Override
         public void run() {
             while (run) {
@@ -151,7 +151,7 @@ public class AsyncFileHandler extends FileHandler {
             }//while
         }
     }
-    
+
     protected static class LogEntry {
         private LogRecord record;
         private AsyncFileHandler handler;
@@ -160,7 +160,7 @@ public class AsyncFileHandler extends FileHandler {
             this.record = record;
             this.handler = handler;
         }
-        
+
         public boolean flush() {
             if (handler.closed) {
                 return false;
@@ -169,8 +169,8 @@ public class AsyncFileHandler extends FileHandler {
                 return true;
             }
         }
-        
+
     }
-    
-    
+
+
 }

==================================================
FileHandler.java
index 3367460d29..c86136ea5a 100644
--- a/java/org/apache/juli/ClassLoaderLogManager.java
+++ b/java/org/apache/juli/ClassLoaderLogManager.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -47,7 +47,7 @@ import java.util.logging.Logger;
 public class ClassLoaderLogManager extends LogManager {
 
     private final class Cleaner extends Thread {
-        
+
         @Override
         public void run() {
             if (useShutdownHook) {
@@ -57,12 +57,12 @@ public class ClassLoaderLogManager extends LogManager {
 
     }
 
-    
+
     // ------------------------------------------------------------Constructors
 
     public ClassLoaderLogManager() {
         super();
-        try { 
+        try {
             Runtime.getRuntime().addShutdownHook(new Cleaner());
         } catch (IllegalStateException ise) {
             // We are probably already being shutdown. Ignore this error.
@@ -75,13 +75,13 @@ public class ClassLoaderLogManager extends LogManager {
 
     /**
      * Map containing the classloader information, keyed per classloader. A
-     * weak hashmap is used to ensure no classloader reference is leaked from 
+     * weak hashmap is used to ensure no classloader reference is leaked from
      * application redeployment.
      */
-    protected final Map<ClassLoader, ClassLoaderLogInfo> classLoaderLoggers = 
+    protected final Map<ClassLoader, ClassLoaderLogInfo> classLoaderLoggers =
         new WeakHashMap<ClassLoader, ClassLoaderLogInfo>();
 
-    
+
     /**
      * This prefix is used to allow using prefixes for the properties names
      * of handlers and their subcomponents.
@@ -97,7 +97,7 @@ public class ClassLoaderLogManager extends LogManager {
      */
     protected volatile boolean useShutdownHook = true;
 
-    
+
     // ------------------------------------------------------------- Properties
 
 
@@ -116,7 +116,7 @@ public class ClassLoaderLogManager extends LogManager {
 
     /**
      * Add the specified logger to the classloader local configuration.
-     * 
+     *
      * @param logger The logger to be added
      */
     @Override
@@ -124,7 +124,7 @@ public class ClassLoaderLogManager extends LogManager {
 
         final String loggerName = logger.getName();
 
-        ClassLoader classLoader = 
+        ClassLoader classLoader =
             Thread.currentThread().getContextClassLoader();
         ClassLoaderLogInfo info = getClassLoaderInfo(classLoader);
         if (info.loggers.containsKey(loggerName)) {
@@ -148,7 +148,7 @@ public class ClassLoaderLogManager extends LogManager {
             }
         }
 
-        // Always instantiate parent loggers so that 
+        // Always instantiate parent loggers so that
         // we can control log categories even during runtime
         int dotIndex = loggerName.lastIndexOf('.');
         if (dotIndex >= 0) {
@@ -202,18 +202,18 @@ public class ClassLoaderLogManager extends LogManager {
         if (Boolean.valueOf(useParentHandlersString).booleanValue()) {
             logger.setUseParentHandlers(true);
         }
-        
+
         return true;
     }
 
-    
+
     /**
-     * Get the logger associated with the specified name inside 
+     * Get the logger associated with the specified name inside
      * the classloader local configuration. If this returns null,
      * and the call originated for Logger.getLogger, a new
      * logger with the specified name will be instantiated and
      * added using addLogger.
-     * 
+     *
      * @param name The name of the logger to retrieve
      */
     @Override
@@ -222,10 +222,10 @@ public class ClassLoaderLogManager extends LogManager {
                 .getContextClassLoader();
         return getClassLoaderInfo(classLoader).loggers.get(name);
     }
-    
-    
+
+
     /**
-     * Get an enumeration of the logger names currently defined in the 
+     * Get an enumeration of the logger names currently defined in the
      * classloader local configuration.
      */
     @Override
@@ -235,13 +235,13 @@ public class ClassLoaderLogManager extends LogManager {
         return Collections.enumeration(getClassLoaderInfo(classLoader).loggers.keySet());
     }
 
-    
+
     /**
      * Get the value of the specified property in the classloader local
      * configuration.
-     * 
+     *
      * @param name The property name
-     */    
+     */
     @Override
     public String getProperty(String name) {
         ClassLoader classLoader = Thread.currentThread()
@@ -252,7 +252,7 @@ public class ClassLoaderLogManager extends LogManager {
         }
         ClassLoaderLogInfo info = getClassLoaderInfo(classLoader);
         String result = info.props.getProperty(name);
-        // If the property was not found, and the current classloader had no 
+        // If the property was not found, and the current classloader had no
         // configuration (property list is empty), look for the parent classloader
         // properties.
         if ((result == null) && (info.props.isEmpty())) {
@@ -277,27 +277,27 @@ public class ClassLoaderLogManager extends LogManager {
         }
         return result;
     }
-    
-    
+
+
     @Override
     public void readConfiguration()
         throws IOException, SecurityException {
-        
+
         checkAccess();
-        
+
         readConfiguration(Thread.currentThread().getContextClassLoader());
-        
+
     }
-        
+
     @Override
     public void readConfiguration(InputStream is)
         throws IOException, SecurityException {
-        
+
         checkAccess();
         reset();
 
         readConfiguration(is, Thread.currentThread().getContextClassLoader());
-    
+
     }
 
     @Override
@@ -358,12 +358,12 @@ public class ClassLoaderLogManager extends LogManager {
     /**
      * Retrieve the configuration associated with the specified classloader. If
      * it does not exist, it will be created.
-     * 
-     * @param classLoader The classloader for which we will retrieve or build the 
+     *
+     * @param classLoader The classloader for which we will retrieve or build the
      *                    configuration
      */
     protected ClassLoaderLogInfo getClassLoaderInfo(ClassLoader classLoader) {
-        
+
         if (classLoader == null) {
             classLoader = ClassLoader.getSystemClassLoader();
         }
@@ -386,21 +386,21 @@ public class ClassLoaderLogManager extends LogManager {
         return info;
     }
 
-    
+
     /**
      * Read configuration for the specified classloader.
-     * 
-     * @param classLoader 
+     *
+     * @param classLoader
      * @throws IOException Error
      */
     protected void readConfiguration(ClassLoader classLoader)
         throws IOException {
-        
+
         InputStream is = null;
-        // Special case for URL classloaders which are used in containers: 
+        // Special case for URL classloaders which are used in containers:
         // only look in the local repositories to avoid redefining loggers 20 times
         try {
-            if ((classLoader instanceof URLClassLoader) 
+            if ((classLoader instanceof URLClassLoader)
                     && (((URLClassLoader) classLoader).findResource("logging.properties") != null)) {
                 is = classLoader.getResourceAsStream("logging.properties");
             }
@@ -433,7 +433,7 @@ public class ClassLoaderLogManager extends LogManager {
             }
             // Try the default JVM configuration
             if (is == null) {
-                File defaultFile = new File(new File(System.getProperty("java.home"), "lib"), 
+                File defaultFile = new File(new File(System.getProperty("java.home"), "lib"),
                     "logging.properties");
                 try {
                     is = new FileInputStream(defaultFile);
@@ -442,7 +442,7 @@ public class ClassLoaderLogManager extends LogManager {
                 }
             }
         }
-        
+
         Logger localRootLogger = new RootLogger();
         if (is == null) {
             // Retrieve the root logger of the parent classloader instead
@@ -456,30 +456,30 @@ public class ClassLoaderLogManager extends LogManager {
                 localRootLogger.setParent(info.rootNode.logger);
             }
         }
-        ClassLoaderLogInfo info = 
+        ClassLoaderLogInfo info =
             new ClassLoaderLogInfo(new LogNode(null, localRootLogger));
         classLoaderLoggers.put(classLoader, info);
-        
+
         if (is != null) {
             readConfiguration(is, classLoader);
         }
         addLogger(localRootLogger);
-        
+
     }
-    
-    
+
+
     /**
      * Load specified configuration.
-     * 
+     *
      * @param is InputStream to the properties file
      * @param classLoader for which the configuration will be loaded
      * @throws IOException If something wrong happens during loading
      */
     protected void readConfiguration(InputStream is, ClassLoader classLoader)
         throws IOException {
-        
+
         ClassLoaderLogInfo info = classLoaderLoggers.get(classLoader);
-        
+
         try {
             info.props.load(is);
         } catch (IOException e) {
@@ -493,7 +493,7 @@ public class ClassLoaderLogManager extends LogManager {
                 // Ignore
             }
         }
-        
+
         // Create handlers for the root logger of this classloader
         String rootHandlers = info.props.getProperty(".handlers");
         String handlers = info.props.getProperty("handlers");
@@ -507,7 +507,7 @@ public class ClassLoaderLogManager extends LogManager {
                 if (handlerClassName.length() <= 0) {
                     continue;
                 }
-                // Parse and remove a prefix (prefix start with a digit, such as 
+                // Parse and remove a prefix (prefix start with a digit, such as
                 // "10WebappFooHanlder.")
                 if (Character.isDigit(handlerClassName.charAt(0))) {
                     int pos = handlerClassName.indexOf('.');
@@ -518,9 +518,9 @@ public class ClassLoaderLogManager extends LogManager {
                 }
                 try {
                     this.prefix.set(prefix);
-                    Handler handler = 
+                    Handler handler =
                         (Handler) classLoader.loadClass(handlerClassName).newInstance();
-                    // The specification strongly implies all configuration should be done 
+                    // The specification strongly implies all configuration should be done
                     // during the creation of the handler object.
                     // This includes setting level, filter, formatter and encoding.
                     this.prefix.set(null);
@@ -534,15 +534,15 @@ public class ClassLoaderLogManager extends LogManager {
                     e.printStackTrace();
                 }
             }
-            
+
         }
-        
+
     }
-    
-    
+
+
     /**
      * Set parent child relationship between the two specified loggers.
-     * 
+     *
      * @param logger
      * @param parent
      */
@@ -557,10 +557,10 @@ public class ClassLoaderLogManager extends LogManager {
         });
     }
 
-    
+
     /**
      * System property replacement in the given string.
-     * 
+     *
      * @param str The original string
      * @return the modified string
      */
@@ -599,7 +599,7 @@ public class ClassLoaderLogManager extends LogManager {
     protected static final class LogNode {
         Logger logger;
 
-        protected final Map<String, LogNode> children = 
+        protected final Map<String, LogNode> children =
             new HashMap<String, LogNode>();
 
         protected final LogNode parent;
@@ -683,7 +683,7 @@ public class ClassLoaderLogManager extends LogManager {
 
 
     /**
-     * This class is needed to instantiate the root of each per classloader 
+     * This class is needed to instantiate the root of each per classloader
      * hierarchy.
      */
     protected static class RootLogger extends Logger {

==================================================
JdkLoggerFormatter.java
index 60742d5b32..067974cf31 100644
--- a/java/org/apache/juli/FileHandler.java
+++ b/java/org/apache/juli/FileHandler.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -42,13 +42,13 @@ import java.util.logging.SimpleFormatter;
  * named {prefix}{date}{suffix} in a configured directory.
  *
  * <p>The following configuration properties are available:</p>
- * 
+ *
  * <ul>
  *   <li><code>directory</code> - The directory where to create the log file.
  *    If the path is not absolute, it is relative to the current working
  *    directory of the application. The Apache Tomcat configuration files usually
  *    specify an absolute path for this property,
- *    <code>${catalina.base}/logs</code> 
+ *    <code>${catalina.base}/logs</code>
  *    Default value: <code>logs</code></li>
  *   <li><code>rotatable</code> - If <code>true</code>, the log file will be
  *    rotated on the first write past midnight and the filename will be
@@ -85,12 +85,12 @@ public class FileHandler
 
     // ------------------------------------------------------------ Constructor
 
-    
+
     public FileHandler() {
         this(null, null, null);
     }
-    
-    
+
+
     public FileHandler(String directory, String prefix, String suffix) {
         this.directory = directory;
         this.prefix = prefix;
@@ -98,7 +98,7 @@ public class FileHandler
         configure();
         openWriter();
     }
-    
+
 
     // ----------------------------------------------------- Instance Variables
 
@@ -180,7 +180,7 @@ public class FileHandler
                     // Update to writeLock before we switch
                     writerLock.readLock().unlock();
                     writerLock.writeLock().lock();
-    
+
                     // Make sure another thread hasn't already done this
                     if (!date.equals(tsDate)) {
                         closeWriter();
@@ -220,8 +220,8 @@ public class FileHandler
             writerLock.readLock().unlock();
         }
     }
-    
-    
+
+
     // -------------------------------------------------------- Private Methods
 
 
@@ -234,7 +234,7 @@ public class FileHandler
     }
 
     protected void closeWriter() {
-        
+
         writerLock.writeLock().lock();
         try {
             if (writer == null)
@@ -268,10 +268,10 @@ public class FileHandler
         } finally {
             writerLock.readLock().unlock();
         }
-        
+
     }
-    
-    
+
+
     /**
      * Configure from <code>LogManager</code> properties.
      */
@@ -282,9 +282,9 @@ public class FileHandler
         date = tsString.substring(0, 10);
 
         String className = this.getClass().getName(); //allow classes to override
-        
+
         ClassLoader cl = Thread.currentThread().getContextClassLoader();
-        
+
         // Retrieve configuration of logging file name
         rotatable = Boolean.parseBoolean(getProperty(className + ".rotatable", "true"));
         if (directory == null)
@@ -334,13 +334,13 @@ public class FileHandler
         } else {
             setFormatter(new SimpleFormatter());
         }
-        
+
         // Set error manager
         setErrorManager(new ErrorManager());
-        
+
     }
 
-    
+
     private String getProperty(String name, String defaultValue) {
         String value = LogManager.getLogManager().getProperty(name);
         if (value == null) {
@@ -350,15 +350,15 @@ public class FileHandler
         }
         return value;
     }
-    
-    
+
+
     /**
      * Open the new log file for the date specified by <code>date</code>.
      */
     protected void open() {
         openWriter();
     }
-    
+
     protected void openWriter() {
 
         // Create the directory if necessary

==================================================
OneLineFormatter.java
index 75af095987..cf8463a7d8 100644
--- a/java/org/apache/juli/JdkLoggerFormatter.java
+++ b/java/org/apache/juli/JdkLoggerFormatter.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -23,11 +23,11 @@ import java.util.logging.LogRecord;
 
 
 /**
- * A more compact formatter. 
- * 
+ * A more compact formatter.
+ *
  * Equivalent log4j config:
  *   <pre>
- *  log4j.rootCategory=WARN, A1   
+ *  log4j.rootCategory=WARN, A1
  *  log4j.appender.A1=org.apache.log4j.ConsoleAppender
  *  log4j.appender.A1.layout=org.apache.log4j.PatternLayout
  *  log4j.appender.A1.Target=System.err
@@ -36,8 +36,8 @@ import java.util.logging.LogRecord;
  *
  * Example:
  *  1130122891846 Http11BaseProtocol I Initializing Coyote HTTP/1.1 on http-8800
- *  
- * 
+ *
+ *
  * @author Costin Manolache
  */
 public class JdkLoggerFormatter extends Formatter {
@@ -57,19 +57,19 @@ public class JdkLoggerFormatter extends Formatter {
         long time=record.getMillis();
         String message=formatMessage(record);
 
-        
-        if( name.indexOf(".") >= 0 ) 
+
+        if( name.indexOf(".") >= 0 )
             name = name.substring(name.lastIndexOf(".") + 1);
 
         // Use a string buffer for better performance
         StringBuilder buf = new StringBuilder();
-        
+
         buf.append(time);
         buf.append(" ");
-        
-        // pad to 8 to make it more readable 
+
+        // pad to 8 to make it more readable
         for( int i=0; i<8-buf.length(); i++ ) { buf.append(" "); }
-        
+
         //      Append a readable representation of the log level.
         switch(level) {
          case LOG_LEVEL_TRACE: buf.append(" T "); break;
@@ -80,31 +80,31 @@ public class JdkLoggerFormatter extends Formatter {
          //case : buf.append(" F "); break;
          default: buf.append("   ");
          }
-         
+
 
         // Append the name of the log instance if so configured
         buf.append(name);
-        
-        // pad to 20 chars 
+
+        // pad to 20 chars
         for( int i=0; i<8-buf.length(); i++ ) { buf.append(" "); }
-                
+
         // Append the message
         buf.append(message);
-        
+
         // Append stack trace if not null
         if(t != null) {
             buf.append(" \n");
-            
+
             java.io.StringWriter sw= new java.io.StringWriter(1024);
             java.io.PrintWriter pw= new java.io.PrintWriter(sw);
             t.printStackTrace(pw);
             pw.close();
             buf.append(sw.toString());
         }
-        
+
         buf.append("\n");
         // Print to the appropriate destination
         return buf.toString();
     }
-    
-} 
+
+}

==================================================
VerbatimFormatter.java
index 1ee65574a4..c5b35ad3be 100644
--- a/java/org/apache/juli/OneLineFormatter.java
+++ b/java/org/apache/juli/OneLineFormatter.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
DirectJDKLog.java
index aff4f45535..9096d99e45 100644
--- a/java/org/apache/juli/VerbatimFormatter.java
+++ b/java/org/apache/juli/VerbatimFormatter.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -35,7 +35,7 @@ public class VerbatimFormatter extends Formatter {
     public String format(LogRecord record) {
         // Timestamp
         StringBuilder sb = new StringBuilder(record.getMessage());
-        
+
         // New line for next record
         sb.append(LINE_SEP);
 

==================================================
Log.java
index 33d8ce0364..770d278004 100644
--- a/java/org/apache/juli/logging/DirectJDKLog.java
+++ b/java/org/apache/juli/logging/DirectJDKLog.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -23,17 +23,17 @@ import java.util.logging.Handler;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-/** 
+/**
  * Hardcoded java.util.logging commons-logging implementation.
- * 
- * In addition, it curr 
- * 
+ *
+ * In addition, it curr
+ *
  */
 class DirectJDKLog implements Log {
     // no reason to hide this - but good reasons to not hide
     public Logger logger;
-    
-    /** Alternate config reader and console format 
+
+    /** Alternate config reader and console format
      */
     private static final String SIMPLE_FMT="java.util.logging.SimpleFormatter";
     private static final String SIMPLE_CFG="org.apache.juli.JdkLoggerConfig"; //doesn't exist
@@ -42,15 +42,15 @@ class DirectJDKLog implements Log {
     static {
         if( System.getProperty("java.util.logging.config.class") ==null  &&
                 System.getProperty("java.util.logging.config.file") ==null ) {
-            // default configuration - it sucks. Let's override at least the 
+            // default configuration - it sucks. Let's override at least the
             // formatter for the console
             try {
-                Class.forName(SIMPLE_CFG).newInstance();                
-            } catch( Throwable t ) {                
+                Class.forName(SIMPLE_CFG).newInstance();
+            } catch( Throwable t ) {
             }
             try {
-                Formatter fmt=(Formatter)Class.forName(System.getProperty(FORMATTER, SIMPLE_FMT)).newInstance(); 
-                // it is also possible that the user modified jre/lib/logging.properties - 
+                Formatter fmt=(Formatter)Class.forName(System.getProperty(FORMATTER, SIMPLE_FMT)).newInstance();
+                // it is also possible that the user modified jre/lib/logging.properties -
                 // but that's really stupid in most cases
                 Logger root=Logger.getLogger("");
                 Handler handlers[]=root.getHandlers();
@@ -63,109 +63,109 @@ class DirectJDKLog implements Log {
             } catch( Throwable t ) {
                 // maybe it wasn't included - the ugly default will be used.
             }
-            
+
         }
     }
-    
+
     public DirectJDKLog(String name ) {
-        logger=Logger.getLogger(name);        
+        logger=Logger.getLogger(name);
     }
-    
+
     @Override
     public final boolean isErrorEnabled() {
         return logger.isLoggable(Level.SEVERE);
     }
-    
+
     @Override
     public final boolean isWarnEnabled() {
-        return logger.isLoggable(Level.WARNING); 
+        return logger.isLoggable(Level.WARNING);
     }
-    
+
     @Override
     public final boolean isInfoEnabled() {
         return logger.isLoggable(Level.INFO);
     }
-    
+
     @Override
     public final boolean isDebugEnabled() {
         return logger.isLoggable(Level.FINE);
     }
-    
+
     @Override
     public final boolean isFatalEnabled() {
         return logger.isLoggable(Level.SEVERE);
     }
-    
+
     @Override
     public final boolean isTraceEnabled() {
         return logger.isLoggable(Level.FINER);
     }
-    
+
     @Override
     public final void debug(Object message) {
         log(Level.FINE, String.valueOf(message), null);
     }
-    
+
     @Override
     public final void debug(Object message, Throwable t) {
         log(Level.FINE, String.valueOf(message), t);
     }
-    
+
     @Override
     public final void trace(Object message) {
         log(Level.FINER, String.valueOf(message), null);
     }
-    
+
     @Override
     public final void trace(Object message, Throwable t) {
         log(Level.FINER, String.valueOf(message), t);
     }
-    
+
     @Override
     public final void info(Object message) {
         log(Level.INFO, String.valueOf(message), null);
     }
-    
+
     @Override
-    public final void info(Object message, Throwable t) {        
+    public final void info(Object message, Throwable t) {
         log(Level.INFO, String.valueOf(message), t);
     }
-    
+
     @Override
     public final void warn(Object message) {
         log(Level.WARNING, String.valueOf(message), null);
     }
-    
+
     @Override
     public final void warn(Object message, Throwable t) {
         log(Level.WARNING, String.valueOf(message), t);
     }
-    
+
     @Override
     public final void error(Object message) {
         log(Level.SEVERE, String.valueOf(message), null);
     }
-    
+
     @Override
     public final void error(Object message, Throwable t) {
         log(Level.SEVERE, String.valueOf(message), t);
     }
-    
+
     @Override
     public final void fatal(Object message) {
         log(Level.SEVERE, String.valueOf(message), null);
     }
-    
+
     @Override
     public final void fatal(Object message, Throwable t) {
         log(Level.SEVERE, String.valueOf(message), t);
-    }    
+    }
 
     // from commons logging. This would be my number one reason why java.util.logging
-    // is bad - design by committee can be really bad ! The impact on performance of 
+    // is bad - design by committee can be really bad ! The impact on performance of
     // using java.util.logging - and the ugliness if you need to wrap it - is far
-    // worse than the unfriendly and uncommon default format for logs. 
-    
+    // worse than the unfriendly and uncommon default format for logs.
+
     private void log( Level level, String msg, Throwable ex ) {
         if (logger.isLoggable(level)) {
             // Hack (?) to get the stack trace.
@@ -185,13 +185,13 @@ class DirectJDKLog implements Log {
                 logger.logp( level, cname, method, msg, ex );
             }
         }
-    }        
+    }
 
     // for LogFactory
     static void release() {
-        
+
     }
-    
+
     static Log getInstance(String name) {
         return new DirectJDKLog( name );
     }

==================================================
LogConfigurationException.java
index 47c79af1f9..faa9e4551c 100644
--- a/java/org/apache/juli/logging/Log.java
+++ b/java/org/apache/juli/logging/Log.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 
 package org.apache.juli.logging;

==================================================
LogFactory.java
index 6a73116c69..c652e3246a 100644
--- a/java/org/apache/juli/logging/LogConfigurationException.java
+++ b/java/org/apache/juli/logging/LogConfigurationException.java
@@ -5,15 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 package org.apache.juli.logging;
 

==================================================
