9a45ea57d5cf39992ac87087e53a5f0c00bf284c
==================================================
Delete unused code
==================================================
Mark Emlyn
==================================================
Tue Mar 24 13:29:21 2009 +0000
==================================================
Apr.java
Delete unused code

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@757792 13f79535-47bb-0310-9956-ffa450edef68



==================================================
EmptyEnumeration.java
deleted file mode 100644
index 4ac8c44928..0000000000
--- a/java/org/apache/tomcat/apr.properties
+++ /dev/null
@@ -1,16 +0,0 @@
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-tcn.info=Tomcat Native/@VERSION@

==================================================
LRUCache.java
deleted file mode 100644
index 79c104d443..0000000000
--- a/java/org/apache/tomcat/util/collections/EmptyEnumeration.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.collections;
-
-import java.util.Enumeration;
-import java.util.NoSuchElementException;
-
-/**
- * @deprecated
- */
-public class EmptyEnumeration implements Enumeration {
-
-    static EmptyEnumeration staticInstance=new EmptyEnumeration();
-
-    public EmptyEnumeration() {
-    }
-
-    public static Enumeration getEmptyEnumeration() {
-	return staticInstance;
-    }
-    
-    public Object nextElement( ) {
-	throw new NoSuchElementException( "EmptyEnumeration");
-    }
-
-    public boolean hasMoreElements() {
-	return false;
-    }
-    
-}

==================================================
Queue.java
deleted file mode 100644
index 76f8699ad2..0000000000
--- a/java/org/apache/tomcat/util/collections/LRUCache.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.collections;
-
-import java.util.Hashtable;
-
-/**
- * This class implements a Generic LRU Cache
- *
- *
- * @author Ignacio J. Ortega
- *
- * @deprecated
- */
-
-public class LRUCache
-{
-    class CacheNode
-    {
-
-        CacheNode prev;
-        CacheNode next;
-        Object value;
-        Object key;
-
-        CacheNode()
-        {
-        }
-    }
-
-
-    public LRUCache(int i)
-    {
-        currentSize = 0;
-        cacheSize = i;
-        nodes = new Hashtable(i);
-    }
-
-    public Object get(Object key)
-    {
-        CacheNode node = (CacheNode)nodes.get(key);
-        if(node != null)
-        {
-            moveToHead(node);
-            return node.value;
-        }
-        else
-        {
-            return null;
-        }
-    }
-
-    public void put(Object key, Object value)
-    {
-        CacheNode node = (CacheNode)nodes.get(key);
-        if(node == null)
-        {
-            if(currentSize >= cacheSize)
-            {
-                if(last != null)
-                    nodes.remove(last.key);
-                removeLast();
-            }
-            else
-            {
-                currentSize++;
-            }
-            node = new CacheNode();
-        }
-        node.value = value;
-        node.key = key;
-        moveToHead(node);
-        nodes.put(key, node);
-    }
-
-    public Object remove(Object key) {
-        CacheNode node = (CacheNode)nodes.get(key);
-        if (node != null) {
-            if (node.prev != null) {
-                node.prev.next = node.next;
-            }
-            if (node.next != null) {
-                node.next.prev = node.prev;
-            }
-            if (last == node)
-                last = node.prev;
-            if (first == node)
-                first = node.next;
-        }
-        return node;
-    }
-
-    public void clear()
-    {
-        first = null;
-        last = null;
-    }
-
-    private void removeLast()
-    {
-        if(last != null)
-        {
-            if(last.prev != null)
-                last.prev.next = null;
-            else
-                first = null;
-            last = last.prev;
-        }
-    }
-
-    private void moveToHead(CacheNode node)
-    {
-        if(node == first)
-            return;
-        if(node.prev != null)
-            node.prev.next = node.next;
-        if(node.next != null)
-            node.next.prev = node.prev;
-        if(last == node)
-            last = node.prev;
-        if(first != null)
-        {
-            node.next = first;
-            first.prev = node;
-        }
-        first = node;
-        node.prev = null;
-        if(last == null)
-            last = first;
-    }
-
-    private int cacheSize;
-    private Hashtable nodes;
-    private int currentSize;
-    private CacheNode first;
-    private CacheNode last;
-}

==================================================
SimpleHashtable.java
deleted file mode 100644
index 9617bb24c6..0000000000
--- a/java/org/apache/tomcat/util/collections/Queue.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.collections;
-
-import java.util.Vector;
-
-/**
- * A simple FIFO queue class which causes the calling thread to wait
- * if the queue is empty and notifies threads that are waiting when it
- * is not empty.
- *
- * @author Anil V (akv@eng.sun.com)
- * 
- * @deprecated
- */
-public class Queue {
-    private Vector<Object> vector = new Vector<Object>();
-    private boolean stopWaiting=false;
-    private boolean waiting=false;
-    
-    /** 
-     * Put the object into the queue.
-     * 
-     * @param	object		the object to be appended to the
-     * 				queue. 
-     */
-    public synchronized void put(Object object) {
-	vector.addElement(object);
-	notify();
-    }
-
-    /** Break the pull(), allowing the calling thread to exit
-     */
-    public synchronized void stop() {
-	stopWaiting=true;
-	// just a hack to stop waiting 
-	if( waiting ) notify();
-    }
-    
-    /**
-     * Pull the first object out of the queue. Wait if the queue is
-     * empty.
-     */
-    public synchronized Object pull() {
-	while (isEmpty()) {
-	    try {
-		waiting=true;
-		wait();
-	    } catch (InterruptedException ex) {
-	    }
-	    waiting=false;
-	    if( stopWaiting ) return null;
-	}
-	return get();
-    }
-
-    /**
-     * Get the first object out of the queue. Return null if the queue
-     * is empty. 
-     */
-    public synchronized Object get() {
-	Object object = peek();
-	if (object != null)
-	    vector.removeElementAt(0);
-	return object;
-    }
-
-    /**
-     * Peek to see if something is available.
-     */
-    public Object peek() {
-	if (isEmpty())
-	    return null;
-	return vector.elementAt(0);
-    }
-    
-    /**
-     * Is the queue empty?
-     */
-    public boolean isEmpty() {
-	return vector.isEmpty();
-    }
-
-    /**
-     * How many elements are there in this queue?
-     */
-    public int size() {
-	return vector.size();
-    }
-}

==================================================
SimplePool.java
deleted file mode 100644
index 31580f482e..0000000000
--- a/java/org/apache/tomcat/util/collections/SimpleHashtable.java
+++ /dev/null
@@ -1,325 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.collections;
-
-import java.util.Enumeration;
-
-/* **************************************** Stolen from Crimson ******************** */
-/* From Crimson/Parser - in a perfect world we'll just have a common set of
-   utilities, and all apache project will just use those.
-
-*/
-
-// can't be replaced using a Java 2 "Collections" API
-// since this package must also run on JDK 1.1
-
-
-/**
- * This class implements a special purpose hashtable.  It works like a
- * normal <code>java.util.Hashtable</code> except that: <OL>
- *
- *	<LI> Keys to "get" are strings which are known to be interned,
- *	so that "==" is used instead of "String.equals".  (Interning
- *	could be document-relative instead of global.)
- *
- *	<LI> It's not synchronized, since it's to be used only by
- *	one thread at a time.
- *
- *	<LI> The keys () enumerator allocates no memory, with live
- *	updates to the data disallowed.
- *
- *	<LI> It's got fewer bells and whistles:  fixed threshold and
- *	load factor, no JDK 1.2 collection support, only keys can be
- *	enumerated, things can't be removed, simpler inheritance; more.
- *
- *	</OL>
- *
- * <P> The overall result is that it's less expensive to use these in
- * performance-critical locations, in terms both of CPU and memory,
- * than <code>java.util.Hashtable</code> instances.  In this package
- * it makes a significant difference when normalizing attributes,
- * which is done for each start-element construct.
- *
- *@deprecated
- */
-public final class SimpleHashtable implements Enumeration
-{
-    
-    private static org.apache.juli.logging.Log log=
-        org.apache.juli.logging.LogFactory.getLog( SimpleHashtable.class );
-    
-    // entries ...
-    private Entry		table[];
-
-    // currently enumerated key
-    private Entry		current = null;
-    private int			currentBucket = 0;
-
-    // number of elements in hashtable
-    private int			count;
-    private int			threshold;
-
-    private static final float	loadFactor = 0.75f;
-
-
-    /**
-     * Constructs a new, empty hashtable with the specified initial 
-     * capacity.
-     *
-     * @param      initialCapacity   the initial capacity of the hashtable.
-     */
-    public SimpleHashtable(int initialCapacity) {
-	if (initialCapacity < 0)
-	    throw new IllegalArgumentException("Illegal Capacity: "+
-                                               initialCapacity);
-        if (initialCapacity==0)
-            initialCapacity = 1;
-	table = new Entry[initialCapacity];
-	threshold = (int)(initialCapacity * loadFactor);
-    }
-
-    /**
-     * Constructs a new, empty hashtable with a default capacity.
-     */
-    public SimpleHashtable() {
-	this(11);
-    }
-
-    /**
-     */
-    public void clear ()
-    {
-	count = 0;
-	currentBucket = 0;
-	current = null;
-	for (int i = 0; i < table.length; i++)
-	    table [i] = null;
-    }
-
-    /**
-     * Returns the number of keys in this hashtable.
-     *
-     * @return  the number of keys in this hashtable.
-     */
-    public int size() {
-	return count;
-    }
-
-    /**
-     * Returns an enumeration of the keys in this hashtable.
-     *
-     * @return  an enumeration of the keys in this hashtable.
-     * @see     Enumeration
-     */
-    public Enumeration keys() {
-	currentBucket = 0;
-	current = null;
-	hasMoreElements();
-	return this;
-    }
-
-    /**
-     * Used to view this as an enumeration; returns true if there
-     * are more keys to be enumerated.
-     */
-    public boolean hasMoreElements ()
-    {
-	if (current != null)
-	    return true;
-	while (currentBucket < table.length) {
-	    current = table [currentBucket++];
-	    if (current != null)
-		return true;
-	}
-	return false;
-    }
-
-    /**
-     * Used to view this as an enumeration; returns the next key
-     * in the enumeration.
-     */
-    public Object nextElement ()
-    {
-	Object retval;
-
-	if (current == null)
-	    throw new IllegalStateException ();
-	retval = current.key;
-	current = current.next;
-	// Advance to the next position ( we may call next after next,
-	// without hasMore )
-	hasMoreElements();
-	return retval;
-    }
-
-
-    /**
-     * Returns the value to which the specified key is mapped in this hashtable.
-     */
-    public Object getInterned (String key) {
-	Entry tab[] = table;
-	int hash = key.hashCode();
-	int index = (hash & 0x7FFFFFFF) % tab.length;
-	for (Entry e = tab[index] ; e != null ; e = e.next) {
-	    if ((e.hash == hash) && (e.key == key))
-		return e.value;
-	}
-	return null;
-    }
-
-    /**
-     * Returns the value to which the specified key is mapped in this
-     * hashtable ... the key isn't necessarily interned, though.
-     */
-    public Object get(String key) {
-	Entry tab[] = table;
-	int hash = key.hashCode();
-	int index = (hash & 0x7FFFFFFF) % tab.length;
-	for (Entry e = tab[index] ; e != null ; e = e.next) {
-	    if ((e.hash == hash) && e.key.equals(key))
-		return e.value;
-	}
-	return null;
-    }
-
-    /**
-     * Increases the capacity of and internally reorganizes this 
-     * hashtable, in order to accommodate and access its entries more 
-     * efficiently.  This method is called automatically when the 
-     * number of keys in the hashtable exceeds this hashtable's capacity 
-     * and load factor. 
-     */
-    private void rehash() {
-	int oldCapacity = table.length;
-	Entry oldMap[] = table;
-
-	int newCapacity = oldCapacity * 2 + 1;
-	Entry newMap[] = new Entry[newCapacity];
-
-	threshold = (int)(newCapacity * loadFactor);
-	table = newMap;
-
-	/*
-	System.out.pr intln("rehash old=" + oldCapacity
-		+ ", new=" + newCapacity
-		+ ", thresh=" + threshold
-		+ ", count=" + count);
-	*/
-
-	for (int i = oldCapacity ; i-- > 0 ;) {
-	    for (Entry old = oldMap[i] ; old != null ; ) {
-		Entry e = old;
-		old = old.next;
-
-		int index = (e.hash & 0x7FFFFFFF) % newCapacity;
-		e.next = newMap[index];
-		newMap[index] = e;
-	    }
-	}
-    }
-
-    /**
-     * Maps the specified <code>key</code> to the specified 
-     * <code>value</code> in this hashtable. Neither the key nor the 
-     * value can be <code>null</code>. 
-     *
-     * <P>The value can be retrieved by calling the <code>get</code> method 
-     * with a key that is equal to the original key. 
-     */
-    public Object put(Object key, Object value) {
-	// Make sure the value is not null
-	if (value == null) {
-	    throw new NullPointerException();
-	}
-
-	// Makes sure the key is not already in the hashtable.
-	Entry tab[] = table;
-	int hash = key.hashCode();
-	int index = (hash & 0x7FFFFFFF) % tab.length;
-	for (Entry e = tab[index] ; e != null ; e = e.next) {
-	    // if ((e.hash == hash) && e.key.equals(key)) {
-	    if ((e.hash == hash) && (e.key == key)) {
-		Object old = e.value;
-		e.value = value;
-		return old;
-	    }
-	}
-
-	if (count >= threshold) {
-	    // Rehash the table if the threshold is exceeded
-	    rehash();
-
-            tab = table;
-            index = (hash & 0x7FFFFFFF) % tab.length;
-	} 
-
-	// Creates the new entry.
-	Entry e = new Entry(hash, key, value, tab[index]);
-	tab[index] = e;
-	count++;
-	return null;
-    }
-
-    public Object remove(Object key) {
-	Entry tab[] = table;
-	Entry prev=null;
-	int hash = key.hashCode();
-	int index = (hash & 0x7FFFFFFF) % tab.length;
-	if( dL > 0 ) d("Idx " + index +  " " + tab[index] );
-	for (Entry e = tab[index] ; e != null ; prev=e, e = e.next) {
-	    if( dL > 0 ) d("> " + prev + " " + e.next + " " + e + " " + e.key);
-	    if ((e.hash == hash) && e.key.equals(key)) {
-		if( prev!=null ) {
-		    prev.next=e.next;
-		} else {
-		    tab[index]=e.next;
-		}
-		if( dL > 0 ) d("Removing from list " + tab[index] + " " + prev +
-			       " " + e.value);
-		count--;
-		Object res=e.value;
-		e.value=null;
-		return res;
-	    }
-	}
-	return null;
-    }
-
-    /**
-     * Hashtable collision list.
-     */
-    private static class Entry {
-	int	hash;
-	Object	key;
-	Object	value;
-	Entry	next;
-
-	protected Entry(int hash, Object key, Object value, Entry next) {
-	    this.hash = hash;
-	    this.key = key;
-	    this.value = value;
-	    this.next = next;
-	}
-    }
-
-    private static final int dL=0;
-    private void d(String s ) {
-	if (log.isDebugEnabled())
-            log.debug( "SimpleHashtable: " + s );
-    }
-}

==================================================
