5ae507be0568ad0eeefd250d3027466b42ae0e63
==================================================
Clean-up
==================================================
Mark Emlyn
==================================================
Fri Oct 14 20:40:17 2011 +0000
==================================================
CoyoteAdapter.java
Clean-up
- remove trailing whitespace
- add final where appropriate
- add {...} where appropriate

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1183492 13f79535-47bb-0310-9956-ffa450edef68



==================================================
TestCometProcessor.java
index 2d4643f0b6..379935adea 100644
--- a/java/org/apache/catalina/connector/CoyoteAdapter.java
+++ b/java/org/apache/catalina/connector/CoyoteAdapter.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -60,7 +60,7 @@ import org.apache.tomcat.util.res.StringManager;
  * @version $Id$
  */
 public class CoyoteAdapter implements Adapter {
-    
+
     private static final Log log = LogFactory.getLog(CoyoteAdapter.class);
 
     // -------------------------------------------------------------- Constants
@@ -76,7 +76,7 @@ public class CoyoteAdapter implements Adapter {
     public static final int ADAPTER_NOTES = 1;
 
 
-    protected static final boolean ALLOW_BACKSLASH = 
+    protected static final boolean ALLOW_BACKSLASH =
         Boolean.valueOf(System.getProperty("org.apache.catalina.connector.CoyoteAdapter.ALLOW_BACKSLASH", "false")).booleanValue();
 
 
@@ -136,14 +136,14 @@ public class CoyoteAdapter implements Adapter {
 
     // -------------------------------------------------------- Adapter Methods
 
-    
+
     /**
      * Event method.
-     * 
+     *
      * @return false to indicate an error, expected or not
      */
     @Override
-    public boolean event(org.apache.coyote.Request req, 
+    public boolean event(org.apache.coyote.Request req,
             org.apache.coyote.Response res, SocketStatus status) {
 
         Request request = (Request) req.getNote(ADAPTER_NOTES);
@@ -152,7 +152,7 @@ public class CoyoteAdapter implements Adapter {
         if (request.getWrapper() == null) {
             return false;
         }
-            
+
         boolean error = false;
         boolean read = false;
         try {
@@ -206,7 +206,7 @@ public class CoyoteAdapter implements Adapter {
             }
 
             req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());
-            
+
             // Calling the container
             connector.getService().getContainer().getPipeline().getFirst().event(request, response, request.getEvent());
 
@@ -255,7 +255,7 @@ public class CoyoteAdapter implements Adapter {
             }
         }
     }
-    
+
     @Override
     public boolean asyncDispatch(org.apache.coyote.Request req,
             org.apache.coyote.Response res, SocketStatus status) throws Exception {
@@ -275,7 +275,7 @@ public class CoyoteAdapter implements Adapter {
                 // Error or timeout - need to tell listeners the request is over
                 // Have to test this first since state may change while in this
                 // method and this is only required if entering this method in
-                // this state 
+                // this state
                 Context ctxt = (Context) request.getMappingData().context;
                 if (ctxt != null) {
                     ctxt.fireRequestDestroyEvent(request);
@@ -343,7 +343,7 @@ public class CoyoteAdapter implements Adapter {
                 request.recycle();
                 response.recycle();
             } else {
-                // Clear converters so that the minimum amount of memory 
+                // Clear converters so that the minimum amount of memory
                 // is used by this processor
                 request.clearEncoders();
                 response.clearEncoders();
@@ -351,12 +351,12 @@ public class CoyoteAdapter implements Adapter {
         }
         return success;
     }
-    
+
     /**
      * Service method.
      */
     @Override
-    public void service(org.apache.coyote.Request req, 
+    public void service(org.apache.coyote.Request req,
                         org.apache.coyote.Response res)
         throws Exception {
 
@@ -391,10 +391,10 @@ public class CoyoteAdapter implements Adapter {
 
         boolean comet = false;
         boolean async = false;
-        
+
         try {
 
-            // Parse and set Catalina and configuration specific 
+            // Parse and set Catalina and configuration specific
             // request parameters
             req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());
             boolean postParseSuccess = postParseRequest(req, request, res, response);
@@ -450,7 +450,7 @@ public class CoyoteAdapter implements Adapter {
                 request.recycle();
                 response.recycle();
             } else {
-                // Clear converters so that the minimum amount of memory 
+                // Clear converters so that the minimum amount of memory
                 // is used by this processor
                 request.clearEncoders();
                 response.clearEncoders();
@@ -466,7 +466,7 @@ public class CoyoteAdapter implements Adapter {
 
         Request request = (Request) req.getNote(ADAPTER_NOTES);
         Response response = (Response) res.getNote(ADAPTER_NOTES);
-        
+
         if (request == null) {
             // Create objects
             request = connector.createRequest();
@@ -486,7 +486,7 @@ public class CoyoteAdapter implements Adapter {
             req.getParameters().setQueryStringEncoding
                 (connector.getURIEncoding());
         }
-        
+
         try {
             // Log at the lowest level available. logAccess() will be
             // automatically called on parent containers.
@@ -514,8 +514,8 @@ public class CoyoteAdapter implements Adapter {
             response.recycle();
         }
     }
-    
-    
+
+
     @Override
     public String getDomain() {
         return connector.getDomain();
@@ -528,13 +528,13 @@ public class CoyoteAdapter implements Adapter {
     /**
      * Parse additional request parameters.
      */
-    protected boolean postParseRequest(org.apache.coyote.Request req, 
+    protected boolean postParseRequest(org.apache.coyote.Request req,
                                        Request request,
-                                       org.apache.coyote.Response res, 
+                                       org.apache.coyote.Response res,
                                        Response response)
             throws Exception {
 
-        // XXX the processor may have set a correct scheme and port prior to this point, 
+        // XXX the processor may have set a correct scheme and port prior to this point,
         // in ajp13 protocols dont make sense to get the port from the connector...
         // otherwise, use connector configuration
         if (! req.scheme().isNull()) {
@@ -547,11 +547,11 @@ public class CoyoteAdapter implements Adapter {
             request.setSecure(connector.getSecure());
         }
 
-        // FIXME: the code below doesnt belongs to here, 
-        // this is only have sense 
+        // FIXME: the code below doesnt belongs to here,
+        // this is only have sense
         // in Http11, not in ajp13..
         // At this point the Host header has been processed.
-        // Override if the proxyPort/proxyHost are set 
+        // Override if the proxyPort/proxyHost are set
         String proxyName = connector.getProxyName();
         int proxyPort = connector.getProxyPort();
         if (proxyPort != 0) {
@@ -564,12 +564,12 @@ public class CoyoteAdapter implements Adapter {
         // Copy the raw URI to the decodedURI
         MessageBytes decodedURI = req.decodedURI();
         decodedURI.duplicate(req.requestURI());
-        
+
         // Parse the path parameters. This will:
         //   - strip out the path parameters
         //   - convert the decodedURI to bytes
         parsePathParameters(req, request);
-        
+
         // URI decoding
         // %xx decoding of the URL
         try {
@@ -628,10 +628,10 @@ public class CoyoteAdapter implements Adapter {
             //reset mapping data, should prolly be done elsewhere
             request.getMappingData().recycle();
         }
-        
+
         boolean mapRequired = true;
         String version = null;
-        
+
         while (mapRequired) {
             if (version != null) {
                 // Once we have a version - that is it
@@ -661,14 +661,14 @@ public class CoyoteAdapter implements Adapter {
                 }
                 return false;
             }
-        
+
             // Now we have the context, we can parse the session ID from the URL
             // (if any). Need to do this before we redirect in case we need to
             // include the session id in the redirect
             String sessionID = null;
             if (request.getServletContext().getEffectiveSessionTrackingModes()
                     .contains(SessionTrackingMode.URL)) {
-                
+
                 // Get the session ID if there was one
                 sessionID = request.getPathParameter(
                         ApplicationSessionCookieConfig.getSessionUriParamName(
@@ -682,9 +682,9 @@ public class CoyoteAdapter implements Adapter {
             // Look for session ID in cookies and SSL session
             parseSessionCookiesId(req, request);
             parseSessionSslId(request);
-            
+
             sessionID = request.getRequestedSessionId();
-            
+
             if (mapRequired) {
                 if (sessionID == null) {
                     // No session means no possibility of needing to remap
@@ -702,7 +702,7 @@ public class CoyoteAdapter implements Adapter {
                                 // Set version so second time through mapping the
                                 // correct context is found
                                 version = ctxt.getWebappVersion();
-                                // Reset mapping 
+                                // Reset mapping
                                 request.getMappingData().recycle();
                                 break;
                             }
@@ -712,7 +712,7 @@ public class CoyoteAdapter implements Adapter {
                         // No matching context found. No need to re-map
                         mapRequired = false;
                     }
-                }                
+                }
             }
 
         }
@@ -741,7 +741,7 @@ public class CoyoteAdapter implements Adapter {
         }
 
         // Filter trace method
-        if (!connector.getAllowTrace() 
+        if (!connector.getAllowTrace()
                 && req.method().equalsIgnoreCase("TRACE")) {
             Wrapper wrapper = request.getWrapper();
             String header = null;
@@ -759,7 +759,7 @@ public class CoyoteAdapter implements Adapter {
                         }
                     }
                 }
-            }                               
+            }
             res.setStatus(405);
             res.addHeader("Allow", header);
             res.setMessage("TRACE method is not allowed");
@@ -776,7 +776,7 @@ public class CoyoteAdapter implements Adapter {
      * of the form /path;name=value;name2=value2/ etc. Currently only really
      * interested in the session ID that will be in this form. Other parameters
      * can safely be ignored.
-     * 
+     *
      * @param req
      * @param request
      */
@@ -831,14 +831,14 @@ public class CoyoteAdapter implements Adapter {
                 // Extract path param from decoded request URI
                 byte[] buf = uriBC.getBuffer();
                 for (int i = 0; i < end - start - pathParamEnd; i++) {
-                    buf[start + semicolon + i] 
+                    buf[start + semicolon + i]
                         = buf[start + i + pathParamEnd];
                 }
                 uriBC.setBytes(buf, start,
                         end - start - pathParamEnd + semicolon);
             } else {
                 if (charset != null) {
-                    pv = new String(uriBC.getBuffer(), start + pathParamStart, 
+                    pv = new String(uriBC.getBuffer(), start + pathParamStart,
                                 (end - start) - pathParamStart, charset);
                 }
                 uriBC.setEnd(start + semicolon);
@@ -856,7 +856,7 @@ public class CoyoteAdapter implements Adapter {
                 int equals = pv.indexOf('=');
                 if (equals > -1) {
                     String name = pv.substring(0, equals);
-                    String value = pv.substring(equals + 1); 
+                    String value = pv.substring(equals + 1);
                     request.addPathParameter(name, value);
                     if (log.isDebugEnabled()) {
                         log.debug(sm.getString("coyoteAdapter.debug", "equals",
@@ -872,8 +872,8 @@ public class CoyoteAdapter implements Adapter {
             semicolon = uriBC.indexOf(';', semicolon);
         }
     }
-    
-    
+
+
     /**
      * Look for SSL session ID if required. Only look for SSL Session ID if it
      * is the only tracking method enabled.
@@ -891,8 +891,8 @@ public class CoyoteAdapter implements Adapter {
             request.setRequestedSessionSSL(true);
         }
     }
-    
-    
+
+
     /**
      * Parse session id in URL.
      */
@@ -905,14 +905,16 @@ public class CoyoteAdapter implements Adapter {
         Context context = (Context) request.getMappingData().context;
         if (context != null && !context.getServletContext()
                 .getEffectiveSessionTrackingModes().contains(
-                        SessionTrackingMode.COOKIE))
+                        SessionTrackingMode.COOKIE)) {
             return;
-        
+        }
+
         // Parse session id from cookies
         Cookies serverCookies = req.getCookies();
         int count = serverCookies.getCookieCount();
-        if (count <= 0)
+        if (count <= 0) {
             return;
+        }
 
         String sessionCookieName =
             ApplicationSessionCookieConfig.getSessionCookieName(context);
@@ -928,9 +930,10 @@ public class CoyoteAdapter implements Adapter {
                         (scookie.getValue().toString());
                     request.setRequestedSessionCookie(true);
                     request.setRequestedSessionURL(false);
-                    if (log.isDebugEnabled())
+                    if (log.isDebugEnabled()) {
                         log.debug(" Requested cookie session id is " +
                             request.getRequestedSessionId());
+                    }
                 } else {
                     if (!request.isRequestedSessionIdValid()) {
                         // Replace the session id until one is valid
@@ -948,7 +951,7 @@ public class CoyoteAdapter implements Adapter {
     /**
      * Character conversion of the URI.
      */
-    protected void convertURI(MessageBytes uri, Request request) 
+    protected void convertURI(MessageBytes uri, Request request)
         throws Exception {
 
         ByteChunk bc = uri.getByteChunk();
@@ -972,7 +975,7 @@ public class CoyoteAdapter implements Adapter {
             if (conv != null) {
                 try {
                     conv.convert(bc, cc, cc.getBuffer().length - cc.getEnd());
-                    uri.setChars(cc.getBuffer(), cc.getStart(), 
+                    uri.setChars(cc.getBuffer(), cc.getStart(),
                                  cc.getLength());
                     return;
                 } catch (IOException e) {
@@ -1000,9 +1003,10 @@ public class CoyoteAdapter implements Adapter {
     protected void convertMB(MessageBytes mb) {
 
         // This is of course only meaningful for bytes
-        if (mb.getType() != MessageBytes.T_BYTES)
+        if (mb.getType() != MessageBytes.T_BYTES) {
             return;
-        
+        }
+
         ByteChunk bc = mb.getByteChunk();
         CharChunk cc = mb.getCharChunk();
         int length = bc.getLength();
@@ -1026,7 +1030,7 @@ public class CoyoteAdapter implements Adapter {
      * This method normalizes "\", "//", "/./" and "/../". This method will
      * return false when trying to go above the root, or if the URI contains
      * a null byte.
-     * 
+     *
      * @param uriMB URI to be normalized
      */
     public static boolean normalize(MessageBytes uriMB) {
@@ -1037,12 +1041,14 @@ public class CoyoteAdapter implements Adapter {
         int end = uriBC.getEnd();
 
         // An empty URL is not acceptable
-        if (start == end)
+        if (start == end) {
             return false;
+        }
 
         // URL * is acceptable
-        if ((end - start == 1) && b[start] == (byte) '*')
-          return true;
+        if ((end - start == 1) && b[start] == (byte) '*') {
+            return true;
+        }
 
         int pos = 0;
         int index = 0;
@@ -1081,8 +1087,8 @@ public class CoyoteAdapter implements Adapter {
         // Note: It is possible to extend the URI by 1 without any side effect
         // as the next character is a non-significant WS.
         if (((end - start) >= 2) && (b[end - 1] == (byte) '.')) {
-            if ((b[end - 2] == (byte) '/') 
-                || ((b[end - 2] == (byte) '.') 
+            if ((b[end - 2] == (byte) '/')
+                || ((b[end - 2] == (byte) '.')
                     && (b[end - 3] == (byte) '/'))) {
                 b[end] = (byte) '/';
                 end++;
@@ -1096,9 +1102,10 @@ public class CoyoteAdapter implements Adapter {
         // Resolve occurrences of "/./" in the normalized path
         while (true) {
             index = uriBC.indexOf("/./", 0, 3, index);
-            if (index < 0)
+            if (index < 0) {
                 break;
-            copyBytes(b, start + index, start + index + 2, 
+            }
+            copyBytes(b, start + index, start + index + 2,
                       end - start - index - 2);
             end = end - 2;
             uriBC.setEnd(end);
@@ -1109,11 +1116,13 @@ public class CoyoteAdapter implements Adapter {
         // Resolve occurrences of "/../" in the normalized path
         while (true) {
             index = uriBC.indexOf("/../", 0, 4, index);
-            if (index < 0)
+            if (index < 0) {
                 break;
+            }
             // Prevent from going outside our context
-            if (index == 0)
+            if (index == 0) {
                 return false;
+            }
             int index2 = -1;
             for (pos = start + index - 1; (pos >= 0) && (index2 < 0); pos --) {
                 if (b[pos] == (byte) '/') {
@@ -1136,9 +1145,9 @@ public class CoyoteAdapter implements Adapter {
      * Check that the URI is normalized following character decoding.
      * <p>
      * This method checks for "\", 0, "//", "/./" and "/../". This method will
-     * return false if sequences that are supposed to be normalized are still 
+     * return false if sequences that are supposed to be normalized are still
      * present in the URI.
-     * 
+     *
      * @param uriMB URI to be checked (should be chars)
      */
     public static boolean checkNormalize(MessageBytes uriMB) {
@@ -1171,8 +1180,8 @@ public class CoyoteAdapter implements Adapter {
 
         // Check for ending with "/." or "/.."
         if (((end - start) >= 2) && (c[end - 1] == '.')) {
-            if ((c[end - 2] == '/') 
-                    || ((c[end - 2] == '.') 
+            if ((c[end - 2] == '/')
+                    || ((c[end - 2] == '.')
                     && (c[end - 3] == '/'))) {
                 return false;
             }
@@ -1197,7 +1206,7 @@ public class CoyoteAdapter implements Adapter {
 
 
     /**
-     * Copy an array of bytes to a different position. Used during 
+     * Copy an array of bytes to a different position. Used during
      * normalization.
      */
     protected static void copyBytes(byte[] b, int dest, int src, int len) {

==================================================
TestAsyncContextImpl.java
index baa4fd0ce0..67cb3439d4 100644
--- a/test/org/apache/catalina/comet/TestCometProcessor.java
+++ b/test/org/apache/catalina/comet/TestCometProcessor.java
@@ -48,7 +48,7 @@ public class TestCometProcessor extends TomcatBaseTest {
 
     @Test
     public void testAsyncClose() throws Exception {
-        
+
         if (!isCometSupported()) {
             return;
         }
@@ -63,12 +63,12 @@ public class TestCometProcessor extends TomcatBaseTest {
         root.getPipeline().addValve(new AsyncCometCloseValve());
         tomcat.getConnector().setProperty("connectionTimeout", "5000");
         tomcat.start();
-        
+
         // Create connection to Comet servlet
         final Socket socket =
             SocketFactory.getDefault().createSocket("localhost", getPort());
         socket.setSoTimeout(5000);
-        
+
         final OutputStream os = socket.getOutputStream();
         String requestLine = "POST http://localhost:" + getPort() +
                 "/comet HTTP/1.1\r\n";
@@ -79,24 +79,24 @@ public class TestCometProcessor extends TomcatBaseTest {
         InputStream is = socket.getInputStream();
         ResponseReaderThread readThread = new ResponseReaderThread(is);
         readThread.start();
-        
+
         // Wait for the comet request/response to finish
         int count = 0;
         while (count < 10 && !readThread.getResponse().endsWith("0\r\n\r\n")) {
             Thread.sleep(500);
             count++;
         }
-        
+
         if (count == 10) {
             fail("Comet request did not complete");
         }
-        
+
         // Send a standard HTTP request on the same connection
         requestLine = "GET http://localhost:" + getPort() +
                 "/hello HTTP/1.1\r\n";
         os.write(requestLine.getBytes());
         os.write("\r\n".getBytes());
-        
+
         // Check for the expected response
         count = 0;
         while (count < 10 && !readThread.getResponse().contains(
@@ -116,7 +116,7 @@ public class TestCometProcessor extends TomcatBaseTest {
 
     @Test
     public void testSimpleCometClient() throws Exception {
-        
+
         if (!isCometSupported()) {
             return;
         }
@@ -132,17 +132,17 @@ public class TestCometProcessor extends TomcatBaseTest {
         final Socket socket =
             SocketFactory.getDefault().createSocket("localhost", getPort());
         socket.setSoTimeout(60000);
-        
+
         final OutputStream os = socket.getOutputStream();
         String requestLine = "POST http://localhost:" + getPort() +
                 "/ HTTP/1.1\r\n";
         os.write(requestLine.getBytes());
         os.write("transfer-encoding: chunked\r\n".getBytes());
         os.write("\r\n".getBytes());
-        
+
         PingWriterThread writeThread = new PingWriterThread(4, os);
         writeThread.start();
-        
+
         socket.setSoTimeout(25000);
         InputStream is = socket.getInputStream();
         ResponseReaderThread readThread = new ResponseReaderThread(is);
@@ -150,7 +150,7 @@ public class TestCometProcessor extends TomcatBaseTest {
         readThread.join();
         os.close();
         is.close();
-        
+
         // Validate response
         String[] response = readThread.getResponse().split("\r\n");
         assertEquals("HTTP/1.1 200 OK", response[0]);
@@ -182,14 +182,14 @@ public class TestCometProcessor extends TomcatBaseTest {
         // Expect 26 lines
         assertEquals(26, response.length);
     }
-    
+
     /**
      * Tests if the Comet connection is closed if the Tomcat connector is
      * stopped.
      */
     @Test
     public void testCometConnectorStop() throws Exception {
-        
+
         if (!isCometSupported()) {
             return;
         }
@@ -205,24 +205,24 @@ public class TestCometProcessor extends TomcatBaseTest {
         final Socket socket =
             SocketFactory.getDefault().createSocket("localhost", getPort());
         socket.setSoTimeout(10000);
-        
+
         final OutputStream os = socket.getOutputStream();
         String requestLine = "POST http://localhost:" + getPort() +
                 "/ HTTP/1.1\r\n";
         os.write(requestLine.getBytes());
         os.write("transfer-encoding: chunked\r\n".getBytes());
         os.write("\r\n".getBytes());
-        
+
         PingWriterThread writeThread = new PingWriterThread(100, os);
         writeThread.start();
 
         InputStream is = socket.getInputStream();
         ResponseReaderThread readThread = new ResponseReaderThread(is);
         readThread.start();
-        
+
         // Allow the first couple of PING messages to be written
         Thread.sleep(3000);
-        
+
         tomcat.getConnector().stop();
         // Allow the executor a chance to send the end event
         Thread.sleep(100);
@@ -302,9 +302,9 @@ public class TestCometProcessor extends TomcatBaseTest {
     }
 
     private static class PingWriterThread extends Thread {
-        
-        private int pingCount;
-        private OutputStream os;
+
+        private final int pingCount;
+        private final OutputStream os;
         private volatile Exception e = null;
 
         public PingWriterThread(int pingCount, OutputStream os) {
@@ -335,8 +335,8 @@ public class TestCometProcessor extends TomcatBaseTest {
 
     private static class ResponseReaderThread extends Thread {
 
-        private InputStream is;
-        private StringBuilder response = new StringBuilder();
+        private final InputStream is;
+        private final StringBuilder response = new StringBuilder();
 
         public ResponseReaderThread(InputStream is) {
             this.is = is;
@@ -365,26 +365,26 @@ public class TestCometProcessor extends TomcatBaseTest {
         @Override
         public void invoke(Request request, Response response)
                 throws IOException, ServletException {
-            
+
             CometEventImpl event = new CometEventImpl(request, response);
-            
+
             getNext().invoke(request, response);
-            
+
             if (request.isComet()) {
                 Thread t = new AsyncCometCloseThread(event);
                 t.start();
             }
         }
     }
-    
+
     private static class AsyncCometCloseThread extends Thread {
 
-        private CometEvent event;
-        
+        private final CometEvent event;
+
         public AsyncCometCloseThread(CometEvent event) {
             this.event = event;
         }
-        
+
         @Override
         public void run() {
             try {

==================================================
TesterAccessLogValve.java
index 3d9b9416c2..eda4ae9741 100644
--- a/test/org/apache/catalina/core/TestAsyncContextImpl.java
+++ b/test/org/apache/catalina/core/TestAsyncContextImpl.java
@@ -65,22 +65,22 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     public void testBug49528() throws Exception {
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
-        
+
         // Must have a real docBase - just use temp
-        Context ctx = 
+        Context ctx =
             tomcat.addContext("", System.getProperty("java.io.tmpdir"));
 
         Bug49528Servlet servlet = new Bug49528Servlet();
-        
+
         Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet);
         wrapper.setAsyncSupported(true);
         ctx.addServletMapping("/", "servlet");
-        
+
         TesterAccessLogValve alv = new TesterAccessLogValve();
         ctx.getPipeline().addValve(alv);
-        
+
         tomcat.start();
-        
+
         // Call the servlet once
         ByteChunk bc = getUrl("http://localhost:" + getPort() + "/");
         assertEquals("OK", bc.toString());
@@ -103,22 +103,22 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     public void testBug49567() throws Exception {
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
-        
+
         // Must have a real docBase - just use temp
-        Context ctx = 
+        Context ctx =
             tomcat.addContext("", System.getProperty("java.io.tmpdir"));
 
         Bug49567Servlet servlet = new Bug49567Servlet();
-        
+
         Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet);
         wrapper.setAsyncSupported(true);
         ctx.addServletMapping("/", "servlet");
-        
+
         TesterAccessLogValve alv = new TesterAccessLogValve();
         ctx.getPipeline().addValve(alv);
-        
+
         tomcat.start();
-        
+
         // Call the servlet once
         ByteChunk bc = getUrl("http://localhost:" + getPort() + "/");
         assertEquals("OK", bc.toString());
@@ -141,27 +141,27 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     public void testAsyncStartNoComplete() throws Exception {
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
-        
+
         // Minimise pauses during test
         tomcat.getConnector().setAttribute(
                 "connectionTimeout", Integer.valueOf(3000));
-        
+
         // Must have a real docBase - just use temp
-        Context ctx = 
+        Context ctx =
             tomcat.addContext("", System.getProperty("java.io.tmpdir"));
 
         AsyncStartNoCompleteServlet servlet =
             new AsyncStartNoCompleteServlet();
-        
+
         Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet);
         wrapper.setAsyncSupported(true);
         ctx.addServletMapping("/", "servlet");
-        
+
         TesterAccessLogValve alv = new TesterAccessLogValve();
         ctx.getPipeline().addValve(alv);
-        
+
         tomcat.start();
-        
+
         // Call the servlet the first time
         ByteChunk bc1 = getUrl("http://localhost:" + getPort() +
                 "/?echo=run1");
@@ -171,7 +171,7 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
         ByteChunk bc2 = getUrl("http://localhost:" + getPort() +
                 "/?echo=run2");
         assertEquals("OK-run2", bc2.toString());
-        
+
         // Check the access log
         validateAccessLog(alv, 2, 200,
                 AsyncStartNoCompleteServlet.ASYNC_TIMEOUT,
@@ -183,23 +183,23 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     public void testAsyncStartWithComplete() throws Exception {
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
-        
+
         // Must have a real docBase - just use temp
-        Context ctx = 
+        Context ctx =
             tomcat.addContext("", System.getProperty("java.io.tmpdir"));
 
         AsyncStartWithCompleteServlet servlet =
             new AsyncStartWithCompleteServlet();
-        
+
         Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet);
         wrapper.setAsyncSupported(true);
         ctx.addServletMapping("/", "servlet");
-        
+
         TesterAccessLogValve alv = new TesterAccessLogValve();
         ctx.getPipeline().addValve(alv);
-        
+
         tomcat.start();
-        
+
         // Call the servlet once
         ByteChunk bc = getUrl("http://localhost:" + getPort() + "/");
         assertEquals("OK", bc.toString());
@@ -207,18 +207,18 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
         // Check the access log
         validateAccessLog(alv, 1, 200, 0, REQUEST_TIME);
     }
-    
+
     /*
      * NOTE: This servlet is only intended to be used in single-threaded tests.
      */
     private static class Bug49528Servlet extends HttpServlet {
 
         private static final long serialVersionUID = 1L;
-        
+
         private volatile boolean done = false;
-        
+
         private StringBuilder result;
-        
+
         public static final long THREAD_SLEEP_TIME = 1000;
 
         public String getResult() {
@@ -233,14 +233,14 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
         protected void doGet(final HttpServletRequest req,
                 final HttpServletResponse resp)
                 throws ServletException, IOException {
-            
+
             result  = new StringBuilder();
             result.append('1');
             result.append(req.isAsyncStarted());
             req.startAsync().setTimeout(10000);
             result.append('2');
             result.append(req.isAsyncStarted());
-            
+
             req.getAsyncContext().start(new Runnable() {
                 @Override
                 public void run() {
@@ -275,11 +275,11 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     private static class Bug49567Servlet extends HttpServlet {
 
         private static final long serialVersionUID = 1L;
-        
+
         private volatile boolean done = false;
-        
+
         private StringBuilder result;
-        
+
         public static final long THREAD_SLEEP_TIME = 1000;
 
         public String getResult() {
@@ -294,14 +294,14 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
         protected void doGet(final HttpServletRequest req,
                 final HttpServletResponse resp)
                 throws ServletException, IOException {
-            
+
             result = new StringBuilder();
             result.append('1');
             result.append(req.isAsyncStarted());
             req.startAsync();
             result.append('2');
             result.append(req.isAsyncStarted());
-            
+
             req.getAsyncContext().start(new Runnable() {
                 @Override
                 public void run() {
@@ -335,18 +335,18 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
             req.getMethod();
         }
     }
-    
+
     private static class AsyncStartNoCompleteServlet extends HttpServlet {
 
         public static final long ASYNC_TIMEOUT = 1000;
-        
+
         private static final long serialVersionUID = 1L;
-        
+
         @Override
         protected void doGet(final HttpServletRequest req,
                 final HttpServletResponse resp)
                 throws ServletException, IOException {
-            
+
             String echo = req.getParameter("echo");
             AsyncContext actxt = req.startAsync();
             resp.setContentType("text/plain");
@@ -362,12 +362,12 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     private static class AsyncStartWithCompleteServlet extends HttpServlet {
 
         private static final long serialVersionUID = 1L;
-        
+
         @Override
         protected void doGet(final HttpServletRequest req,
                 final HttpServletResponse resp)
                 throws ServletException, IOException {
-            
+
             AsyncContext actxt = req.startAsync();
             actxt.setTimeout(3000);
             resp.setContentType("text/plain");
@@ -405,17 +405,17 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     throws Exception {
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
-        
+
         // Must have a real docBase - just use temp
         File docBase = new File(System.getProperty("java.io.tmpdir"));
-        
+
         // Create the folder that will trigger the redirect
         File foo = new File(docBase, "async");
         addDeleteOnTearDown(foo);
         if (!foo.mkdirs() && !foo.isDirectory()) {
             fail("Unable to create async directory in docBase");
         }
-        
+
         Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
 
         TimeoutServlet timeout =
@@ -435,7 +435,7 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
 
         TesterAccessLogValve alv = new TesterAccessLogValve();
         ctx.getPipeline().addValve(alv);
-        
+
         tomcat.start();
         ByteChunk res = new ByteChunk();
         try {
@@ -478,12 +478,12 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
                     REQUEST_TIME);
         }
     }
-    
+
     private static class TimeoutServlet extends HttpServlet {
         private static final long serialVersionUID = 1L;
 
-        private boolean completeOnTimeout;
-        private String dispatchUrl;
+        private final boolean completeOnTimeout;
+        private final String dispatchUrl;
 
         public static final long ASYNC_TIMEOUT = 3000;
 
@@ -491,19 +491,20 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
             this.completeOnTimeout = completeOnTimeout;
             this.dispatchUrl = dispatchUrl;
         }
-        
+
         @Override
-        protected void doGet(HttpServletRequest req, HttpServletResponse resp) 
+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                 throws ServletException, IOException {
             if (req.isAsyncSupported()) {
                 resp.getWriter().print("TimeoutServletGet-");
                 final AsyncContext ac = req.startAsync();
                 ac.setTimeout(ASYNC_TIMEOUT);
-                
+
                 ac.addListener(new TrackingListener(
                         false, completeOnTimeout, dispatchUrl));
-            } else
+            } else {
                 resp.getWriter().print("FAIL: Async unsupported");
+            }
         }
     }
 
@@ -536,14 +537,14 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     public void testDispatchWithThreadMultiple() throws Exception {
         doTestDispatch(5, true);
     }
-    
+
     private void doTestDispatch(int iter, boolean useThread) throws Exception {
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
-        
+
         // Must have a real docBase - just use temp
         File docBase = new File(System.getProperty("java.io.tmpdir"));
-        
+
         Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
 
         DispatchingServlet dispatch = new DispatchingServlet(false, false);
@@ -560,9 +561,9 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
 
         TesterAccessLogValve alv = new TesterAccessLogValve();
         ctx.getPipeline().addValve(alv);
-        
+
         tomcat.start();
-        
+
         StringBuilder url = new StringBuilder(48);
         url.append("http://localhost:");
         url.append(getPort());
@@ -572,7 +573,7 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
             url.append("&useThread=y");
         }
         ByteChunk res = getUrl(url.toString());
-        
+
         StringBuilder expected = new StringBuilder("requestInitialized-");
         int loop = iter;
         while (loop > 0) {
@@ -582,24 +583,24 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
         expected.append("NonAsyncServletGet-");
         expected.append("requestDestroyed");
         assertEquals(expected.toString(), res.toString());
-        
+
         // Check the access log
         validateAccessLog(alv, 1, 200, 0, REQUEST_TIME);
     }
-    
+
     private static class DispatchingServlet extends HttpServlet {
 
         private static final long serialVersionUID = 1L;
         private static final String ITER_PARAM = "iter";
         private boolean addTrackingListener = false;
         private boolean completeOnError = false;
-        
+
         public DispatchingServlet(boolean addTrackingListener,
                 boolean completeOnError) {
             this.addTrackingListener = addTrackingListener;
             this.completeOnError = completeOnError;
         }
-        
+
         @Override
         protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                 throws ServletException, IOException {
@@ -610,7 +611,7 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
             final AsyncContext ctxt = req.startAsync();
             if (addTrackingListener) {
                 TrackingListener listener =
-                    new TrackingListener(completeOnError, true, null); 
+                    new TrackingListener(completeOnError, true, null);
                 ctxt.addListener(listener);
             }
             Runnable run = new Runnable() {
@@ -647,10 +648,10 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     public void testListeners() throws Exception {
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
-        
+
         // Must have a real docBase - just use temp
         File docBase = new File(System.getProperty("java.io.tmpdir"));
-        
+
         Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
 
         TrackingServlet tracking = new TrackingServlet();
@@ -665,16 +666,16 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
 
         TesterAccessLogValve alv = new TesterAccessLogValve();
         ctx.getPipeline().addValve(alv);
-        
+
         tomcat.start();
-        
+
         StringBuilder url = new StringBuilder(48);
         url.append("http://localhost:");
         url.append(getPort());
         url.append("/stage1");
 
         ByteChunk res = getUrl(url.toString());
-        
+
         assertEquals(
                 "DispatchingServletGet-DispatchingServletGet-onStartAsync-" +
                 "TimeoutServletGet-onStartAsync-onTimeout-onComplete-",
@@ -688,9 +689,9 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     private static class TrackingServlet extends HttpServlet {
 
         private static final long serialVersionUID = 1L;
-        
+
         private static volatile boolean first = true;
-        
+
         @Override
         protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                 throws ServletException, IOException {
@@ -701,7 +702,7 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
             TrackingServlet.first = false;
 
             final AsyncContext ctxt = req.startAsync();
-            TrackingListener listener = new TrackingListener(false, true, null); 
+            TrackingListener listener = new TrackingListener(false, true, null);
             ctxt.addListener(listener);
             ctxt.setTimeout(3000);
 
@@ -724,11 +725,11 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     }
 
     private static class TrackingListener implements AsyncListener {
-        
-        private boolean completeOnError;
-        private boolean completeOnTimeout;
-        private String dispatchUrl;
-        
+
+        private final boolean completeOnError;
+        private final boolean completeOnTimeout;
+        private final String dispatchUrl;
+
         public TrackingListener(boolean completeOnError,
                 boolean completeOnTimeout, String dispatchUrl) {
             this.completeOnError = completeOnError;
@@ -738,14 +739,14 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
 
         @Override
         public void onComplete(AsyncEvent event) throws IOException {
-            ServletResponse resp = event.getAsyncContext().getResponse(); 
+            ServletResponse resp = event.getAsyncContext().getResponse();
             resp.getWriter().write("onComplete-");
             resp.flushBuffer();
         }
 
         @Override
         public void onTimeout(AsyncEvent event) throws IOException {
-            ServletResponse resp = event.getAsyncContext().getResponse(); 
+            ServletResponse resp = event.getAsyncContext().getResponse();
             resp.getWriter().write("onTimeout-");
             resp.flushBuffer();
             if (completeOnTimeout){
@@ -758,7 +759,7 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
 
         @Override
         public void onError(AsyncEvent event) throws IOException {
-            ServletResponse resp = event.getAsyncContext().getResponse(); 
+            ServletResponse resp = event.getAsyncContext().getResponse();
             resp.getWriter().write("onError-");
             resp.flushBuffer();
             if (completeOnError) {
@@ -768,12 +769,12 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
 
         @Override
         public void onStartAsync(AsyncEvent event) throws IOException {
-            ServletResponse resp = event.getAsyncContext().getResponse(); 
+            ServletResponse resp = event.getAsyncContext().getResponse();
             resp.getWriter().write("onStartAsync-");
             resp.flushBuffer();
         }
     }
-    
+
     public static class TrackingRequestListener
             implements ServletRequestListener {
 
@@ -864,16 +865,16 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
             throws Exception {
         doTestDispatchError(5, true, true);
     }
-    
+
     private void doTestDispatchError(int iter, boolean useThread,
             boolean completeOnError)
             throws Exception {
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
-        
+
         // Must have a real docBase - just use temp
         File docBase = new File(System.getProperty("java.io.tmpdir"));
-        
+
         Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
 
         DispatchingServlet dispatch =
@@ -890,9 +891,9 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
 
         TesterAccessLogValve alv = new TesterAccessLogValve();
         ctx.getPipeline().addValve(alv);
-        
+
         tomcat.start();
-        
+
         StringBuilder url = new StringBuilder(48);
         url.append("http://localhost:");
         url.append(getPort());
@@ -902,7 +903,7 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
             url.append("&useThread=y");
         }
         ByteChunk res = getUrl(url.toString());
-        
+
         StringBuilder expected = new StringBuilder("requestInitialized-");
         int loop = iter;
         while (loop > 0) {
@@ -914,11 +915,11 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
         }
         expected.append("ErrorServletGet-onError-onComplete-requestDestroyed");
         assertEquals(expected.toString(), res.toString());
-        
+
         // Check the access log
         validateAccessLog(alv, 1, 200, 0, REQUEST_TIME);
     }
-    
+
     private static class ErrorServlet extends HttpServlet {
 
         private static final long serialVersionUID = 1L;
@@ -928,7 +929,7 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
         public ErrorServlet(boolean flush) {
             this.flush = flush;
         }
-        
+
         @Override
         protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                 throws ServletException, IOException {
@@ -944,10 +945,10 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     public void testBug50352() throws Exception {
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
-        
+
         // Must have a real docBase - just use temp
         File docBase = new File(System.getProperty("java.io.tmpdir"));
-        
+
         Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
 
         AsyncStartRunnable servlet = new AsyncStartRunnable();
@@ -957,20 +958,20 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
 
         TesterAccessLogValve alv = new TesterAccessLogValve();
         ctx.getPipeline().addValve(alv);
-        
+
         tomcat.start();
-        
+
         ByteChunk res = getUrl("http://localhost:" + getPort() + "/");
-        
+
         assertEquals("Runnable-onComplete-", res.toString());
 
         // Check the access log
         validateAccessLog(alv, 1, 200, AsyncStartRunnable.THREAD_SLEEP_TIME,
                 AsyncStartRunnable.THREAD_SLEEP_TIME + REQUEST_TIME);
     }
-    
+
     private static final class AsyncStartRunnable extends HttpServlet {
-        
+
         private static final long serialVersionUID = 1L;
 
         public static final long THREAD_SLEEP_TIME = 3000;
@@ -979,7 +980,7 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
         protected void doGet(HttpServletRequest request,
                 HttpServletResponse response)
                 throws ServletException, IOException {
-            
+
             final AsyncContext asyncContext =
                 request.startAsync(request, response);
 
@@ -1006,22 +1007,22 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     public void testBug50753() throws Exception {
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
-        
+
         // Must have a real docBase - just use temp
-        Context ctx = 
+        Context ctx =
             tomcat.addContext("", System.getProperty("java.io.tmpdir"));
 
         Bug50753Servlet servlet = new Bug50753Servlet();
-        
+
         Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servlet);
         wrapper.setAsyncSupported(true);
         ctx.addServletMapping("/", "servlet");
-        
+
         TesterAccessLogValve alv = new TesterAccessLogValve();
         ctx.getPipeline().addValve(alv);
-        
+
         tomcat.start();
-        
+
         // Call the servlet once
         Map<String,List<String>> headers =
             new LinkedHashMap<String,List<String>>();
@@ -1033,7 +1034,7 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
         assertNotNull(testHeader);
         assertEquals(1, testHeader.size());
         assertEquals("xyz",testHeader.get(0));
-        
+
         // Check the access log
         validateAccessLog(alv, 1, 200, Bug50753Servlet.THREAD_SLEEP_TIME,
                 Bug50753Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);
@@ -1049,22 +1050,22 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
         protected void doGet(HttpServletRequest req,
                 final HttpServletResponse resp)
                 throws ServletException, IOException {
-            final AsyncContext ctx = req.startAsync(); 
-            ctx.start(new Runnable() { 
+            final AsyncContext ctx = req.startAsync();
+            ctx.start(new Runnable() {
                 @Override
-                public void run() { 
-                    try { 
-                        Thread.sleep(THREAD_SLEEP_TIME); 
-                        resp.setHeader("A", "xyz"); 
-                        resp.setContentType("text/plain"); 
-                        resp.setContentLength("OK".getBytes().length); 
-                        resp.getWriter().print("OK"); 
-                        ctx.complete(); 
-                    } catch (Exception e) { 
+                public void run() {
+                    try {
+                        Thread.sleep(THREAD_SLEEP_TIME);
+                        resp.setHeader("A", "xyz");
+                        resp.setContentType("text/plain");
+                        resp.setContentLength("OK".getBytes().length);
+                        resp.getWriter().print("OK");
+                        ctx.complete();
+                    } catch (Exception e) {
                         e.printStackTrace();
-                    } 
-                } 
-            }); 
+                    }
+                }
+            });
         }
     }
 
@@ -1072,10 +1073,10 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     public void testErrorHandling() throws Exception {
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
-        
+
         // Must have a real docBase - just use temp
         File docBase = new File(System.getProperty("java.io.tmpdir"));
-        
+
         Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
 
         ErrorServlet error = new ErrorServlet(false);
@@ -1084,22 +1085,22 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
 
         TesterAccessLogValve alv = new TesterAccessLogValve();
         ctx.getPipeline().addValve(alv);
-        
+
         tomcat.start();
-        
+
         StringBuilder url = new StringBuilder(48);
         url.append("http://localhost:");
         url.append(getPort());
         url.append("/error");
-        
+
         int rc = getUrl(url.toString(), new ByteChunk(), null);
-        
+
         assertEquals(500, rc);
-        
+
         // Without this test may complete before access log has a chance to log
         // the request
         Thread.sleep(REQUEST_TIME);
-        
+
         // Check the access log
         validateAccessLog(alv, 1, 500, 0, REQUEST_TIME);
     }
@@ -1107,13 +1108,13 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     private void validateAccessLog(TesterAccessLogValve alv, int count,
             int status, long minTime, long maxTime) throws Exception {
         List<Entry> entries = alv.getEntries();
-        
+
         // Wait (but not too long) until all expected entries appear (access log
         // entry will be made after response has been returned to user)
         for (int i = 0; i < 10 && entries.size() < count; i++) {
             Thread.sleep(100);
         }
-        
+
         assertEquals(count, entries.size());
         for (int j = 0; j < count; j++) {
             Entry entry = entries.get(j);
@@ -1129,10 +1130,10 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     public void testCommitOnComplete() throws Exception {
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
-        
+
         // Must have a real docBase - just use temp
         File docBase = new File(System.getProperty("java.io.tmpdir"));
-        
+
         Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
 
         AsyncStatusServlet asyncStatusServlet =
@@ -1144,22 +1145,22 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
 
         TesterAccessLogValve alv = new TesterAccessLogValve();
         ctx.getPipeline().addValve(alv);
-        
+
         tomcat.start();
-        
+
         StringBuilder url = new StringBuilder(48);
         url.append("http://localhost:");
         url.append(getPort());
         url.append("/asyncStatusServlet");
-        
+
         int rc = getUrl(url.toString(), new ByteChunk(), null);
-        
+
         assertEquals(HttpServletResponse.SC_BAD_REQUEST, rc);
-        
+
         // Without this test may complete before access log has a chance to log
         // the request
         Thread.sleep(REQUEST_TIME);
-        
+
         // Check the access log
         validateAccessLog(alv, 1, HttpServletResponse.SC_BAD_REQUEST, 0,
                 REQUEST_TIME);
@@ -1175,11 +1176,11 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
         public AsyncStatusServlet(int status) {
             this.status = status;
         }
-        
+
         @Override
         protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                 throws ServletException, IOException {
-            
+
             AsyncContext actxt = req.startAsync();
             resp.setStatus(status);
             actxt.complete();
@@ -1190,10 +1191,10 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
     public void testBug51197() throws Exception {
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
-        
+
         // Must have a real docBase - just use temp
         File docBase = new File(System.getProperty("java.io.tmpdir"));
-        
+
         Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
 
         AsyncErrorServlet asyncErrorServlet =
@@ -1205,22 +1206,22 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
 
         TesterAccessLogValve alv = new TesterAccessLogValve();
         ctx.getPipeline().addValve(alv);
-        
+
         tomcat.start();
-        
+
         StringBuilder url = new StringBuilder(48);
         url.append("http://localhost:");
         url.append(getPort());
         url.append("/asyncErrorServlet");
-        
+
         int rc = getUrl(url.toString(), new ByteChunk(), null);
-        
+
         assertEquals(HttpServletResponse.SC_BAD_REQUEST, rc);
-        
+
         // Without this test may complete before access log has a chance to log
         // the request
         Thread.sleep(REQUEST_TIME);
-        
+
         // Check the access log
         validateAccessLog(alv, 1, HttpServletResponse.SC_BAD_REQUEST, TIMEOUT,
                 TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME);
@@ -1236,11 +1237,11 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
         public AsyncErrorServlet(int status) {
             this.status = status;
         }
-        
+
         @Override
         protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                 throws ServletException, IOException {
-            
+
             final AsyncContext actxt = req.startAsync();
             actxt.setTimeout(TIMEOUT);
             actxt.start(new Runnable() {

==================================================
