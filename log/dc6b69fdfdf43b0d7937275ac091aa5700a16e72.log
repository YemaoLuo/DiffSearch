dc6b69fdfdf43b0d7937275ac091aa5700a16e72
==================================================
Extract the Runnable implementation from the StreamProcessor
==================================================
Mark Thomas
==================================================
Mon Dec 5 08:54:49 2016 +0000
==================================================
Http2UpgradeHandler.java
Extract the Runnable implementation from the StreamProcessor

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1772603 13f79535-47bb-0310-9956-ffa450edef68



==================================================
StreamProcessor.java
index 4bfebcf845..65d0ea21d0 100644
--- a/java/org/apache/coyote/http2/Http2UpgradeHandler.java
+++ b/java/org/apache/coyote/http2/Http2UpgradeHandler.java
@@ -144,7 +144,7 @@ class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeH
     // Stream concurrency control
     private int maxConcurrentStreamExecution = Http2Protocol.DEFAULT_MAX_CONCURRENT_STREAM_EXECUTION;
     private AtomicInteger streamConcurrency = null;
-    private Queue<StreamProcessor> queuedProcessors = null;
+    private Queue<StreamRunnable> queuedRunnable = null;
 
     // Limits
     private Set<String> allowedTrailerHeaders = Collections.emptySet();
@@ -191,7 +191,7 @@ class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeH
         // Init concurrency control if needed
         if (maxConcurrentStreamExecution < localSettings.getMaxConcurrentStreams()) {
             streamConcurrency = new AtomicInteger(0);
-            queuedProcessors = new ConcurrentLinkedQueue<>();
+            queuedRunnable = new ConcurrentLinkedQueue<>();
         }
 
         parser = new Http2Parser(connectionId, this, this);
@@ -268,15 +268,16 @@ class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeH
 
     private void processStreamOnContainerThread(Stream stream) {
         StreamProcessor streamProcessor = new StreamProcessor(this, stream, adapter, socketWrapper);
+        StreamRunnable streamRunnable = new StreamRunnable(streamProcessor, SocketEvent.OPEN_READ);
         streamProcessor.setSslSupport(sslSupport);
         if (streamConcurrency == null) {
-            socketWrapper.getEndpoint().getExecutor().execute(streamProcessor);
+            socketWrapper.getEndpoint().getExecutor().execute(streamRunnable);
         } else {
             if (getStreamConcurrency() < maxConcurrentStreamExecution) {
                 increaseStreamConcurrency();
-                socketWrapper.getEndpoint().getExecutor().execute(streamProcessor);
+                socketWrapper.getEndpoint().getExecutor().execute(streamRunnable);
             } else {
-                queuedProcessors.offer(streamProcessor);
+                queuedRunnable.offer(streamRunnable);
             }
         }
     }
@@ -440,10 +441,10 @@ class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeH
         }
         decreaseStreamConcurrency();
         if (getStreamConcurrency() < maxConcurrentStreamExecution) {
-            StreamProcessor streamProcessor = queuedProcessors.poll();
-            if (streamProcessor != null) {
+            StreamRunnable streamRunnable = queuedRunnable.poll();
+            if (streamRunnable != null) {
                 increaseStreamConcurrency();
-                socketWrapper.getEndpoint().getExecutor().execute(streamProcessor);
+                socketWrapper.getEndpoint().getExecutor().execute(streamRunnable);
             }
         }
     }

==================================================
StreamRunnable.java
index c07e09d3a6..823468754c 100644
--- a/java/org/apache/coyote/http2/StreamProcessor.java
+++ b/java/org/apache/coyote/http2/StreamProcessor.java
@@ -32,7 +32,7 @@ import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
-class StreamProcessor extends AbstractProcessor implements Runnable {
+class StreamProcessor extends AbstractProcessor {
 
     private static final Log log = LogFactory.getLog(StreamProcessor.class);
     private static final StringManager sm = StringManager.getManager(StreamProcessor.class);
@@ -50,8 +50,7 @@ class StreamProcessor extends AbstractProcessor implements Runnable {
     }
 
 
-    @Override
-    public final void run() {
+    final void process(SocketEvent event) {
         try {
             // FIXME: the regular processor syncs on socketWrapper, but here this deadlocks
             synchronized (this) {
@@ -60,7 +59,7 @@ class StreamProcessor extends AbstractProcessor implements Runnable {
                 ContainerThreadMarker.set();
                 SocketState state = SocketState.CLOSED;
                 try {
-                    state = process(socketWrapper, SocketEvent.OPEN_READ);
+                    state = process(socketWrapper, event);
 
                     if (state == SocketState.CLOSED) {
                         if (!getErrorState().isConnectionIoAllowed()) {
@@ -170,7 +169,8 @@ class StreamProcessor extends AbstractProcessor implements Runnable {
 
     @Override
     protected final void executeDispatches(SocketWrapperBase<?> wrapper) {
-        wrapper.getEndpoint().getExecutor().execute(this);
+        StreamRunnable streamRunnable = new StreamRunnable(this, SocketEvent.OPEN_READ);
+        wrapper.getEndpoint().getExecutor().execute(streamRunnable);
     }
 
 

==================================================
