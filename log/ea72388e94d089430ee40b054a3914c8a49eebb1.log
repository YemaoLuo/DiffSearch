ea72388e94d089430ee40b054a3914c8a49eebb1
==================================================
Move server side specific code to separate package. Further refactoring is likely to be required as client side code is developed.
==================================================
Mark Emlyn
==================================================
Sun Jan 20 17:54:03 2013 +0000
==================================================
WebSocketContainer.java
Move server side specific code to separate package. Further refactoring is likely to be required as client side code is developed.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1435904 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Constants.java
index bafbb044bb..7dd54e9b1b 100644
--- a/java/javax/websocket/WebSocketContainer.java
+++ b/java/javax/websocket/WebSocketContainer.java
@@ -28,6 +28,21 @@ public interface WebSocketContainer {
     Session connectToServer(Class<?> annotatedEndpointClass, URI path)
             throws DeploymentException;
 
+    /**
+     * Creates a new connection to the WebSocket.
+     *
+     * @param endpoint
+     *            An instance of this class will be created to handle responses
+     *            from the server
+     * @param clientEndpointConfiguration
+     *            Used to configure the new connection
+     * @param path
+     *            The full URL of the WebSocket endpoint to connect to
+     *
+     * @return The WebSocket session for the connection
+     *
+     * @throws DeploymentException  If the connection can not be established
+     */
     Session connectToServer(Class<? extends Endpoint> endpoint,
             ClientEndpointConfiguration clientEndpointConfiguration, URI path)
             throws DeploymentException;

==================================================
Util.java
index 8ee8e9efda..063bc8b8f3 100644
--- a/java/org/apache/tomcat/websocket/Constants.java
+++ b/java/org/apache/tomcat/websocket/Constants.java
@@ -23,7 +23,6 @@ public class Constants {
 
     protected static final String PACKAGE_NAME =
             Constants.class.getPackage().getName();
-    protected static final String SERVLET_NAME = WsServlet.class.getName();
     // OP Codes
     public static final byte OPCODE_CONTINUATION = 0x00;
     public static final byte OPCODE_TEXT = 0x01;

==================================================
WsFrame.java
index 99b08568ad..0d37d35041 100644
--- a/java/org/apache/tomcat/websocket/Util.java
+++ b/java/org/apache/tomcat/websocket/Util.java
@@ -30,32 +30,6 @@ class Util {
     }
 
 
-    /**
-     * Converts a path defined for a WebSocket endpoint into a path that can be
-     * used as a servlet mapping.
-     *
-     * @param wsPath The WebSocket endpoint path to convert
-     * @return The servlet mapping
-     */
-    static String getServletPath(String wsPath) {
-        int templateStart = wsPath.indexOf('{');
-        if (templateStart == -1) {
-            if (wsPath.charAt(wsPath.length() - 1) == '/') {
-                return wsPath + '*';
-            } else {
-                return wsPath + "/*";
-            }
-        } else {
-            String temp = wsPath.substring(0, templateStart);
-            if (temp.charAt(temp.length() - 1) == '/') {
-                return temp + '*';
-            } else {
-                return temp.substring(0, temp.lastIndexOf('/') + 1) + '*';
-            }
-        }
-    }
-
-
     static CloseCode getCloseCode(int code) {
         if (code > 2999 && code < 5000) {
             return CloseCodes.NORMAL_CLOSURE;

==================================================
WsRemoteEndpointBase.java
index 533d22d0de..d34b5dce77 100644
--- a/java/org/apache/tomcat/websocket/WsFrame.java
+++ b/java/org/apache/tomcat/websocket/WsFrame.java
@@ -83,8 +83,13 @@ public class WsFrame {
         this.sis = sis;
         this.wsSession = wsSession;
 
+        // TODO This needs to work for client and server side code
+        /*
         int readBufferSize =
                 ServerContainerImpl.getServerContainer().getReadBufferSize();
+        */
+        // Temp hack until the above is resolved
+        int readBufferSize = 8192;
 
         inputBuffer = new byte[readBufferSize];
         messageBufferBinary = ByteBuffer.allocate(readBufferSize);

==================================================
WsSession.java
similarity index 76%
rename from java/org/apache/tomcat/websocket/WsRemoteEndpoint.java
rename to java/org/apache/tomcat/websocket/WsRemoteEndpointBase.java
index 5ef624ba06..11c8c11bac 100644
--- a/java/org/apache/tomcat/websocket/WsRemoteEndpoint.java
+++ b/java/org/apache/tomcat/websocket/WsRemoteEndpointBase.java
@@ -24,35 +24,21 @@ import java.nio.CharBuffer;
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
 import java.nio.charset.CoderResult;
-import java.util.concurrent.BrokenBarrierException;
-import java.util.concurrent.CyclicBarrier;
 import java.util.concurrent.Future;
 
-import javax.servlet.ServletOutputStream;
 import javax.websocket.EncodeException;
 import javax.websocket.RemoteEndpoint;
 import javax.websocket.SendHandler;
 import javax.websocket.SendResult;
 
-public class WsRemoteEndpoint implements RemoteEndpoint {
+public abstract class WsRemoteEndpointBase implements RemoteEndpoint {
 
-    private final Object messageWriteLock = new Object();
-
-    private final ServletOutputStream sos;
-    private final WsSession wsSession;
     // Max length for outgoing WebSocket frame header is 10 bytes
     private final ByteBuffer header = ByteBuffer.allocate(10);
 
     private final ByteBuffer textToByte = ByteBuffer.allocate(8192);
     private final CharsetEncoder encoder = Charset.forName("UTF8").newEncoder();
     private volatile Boolean isText = null;
-    private volatile CyclicBarrier writeBarrier = new CyclicBarrier(2);
-
-
-    public WsRemoteEndpoint(WsSession wsSession, ServletOutputStream sos) {
-        this.wsSession = wsSession;
-        this.sos = sos;
-    }
 
 
     @Override
@@ -200,14 +186,7 @@ public class WsRemoteEndpoint implements RemoteEndpoint {
     }
 
 
-    public void onWritePossible() {
-        try {
-            writeBarrier.await();
-        } catch (InterruptedException | BrokenBarrierException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        }
-    }
+    public abstract void onWritePossible();
 
 
     protected void sendMessage(byte opCode, ByteBuffer message,
@@ -250,50 +229,13 @@ public class WsRemoteEndpoint implements RemoteEndpoint {
         }
         header.flip();
 
-        // Could sync on sos but don't as other (user or container) code may
-        // sync on this creating the potential for deadlocks.
-        synchronized (messageWriteLock) {
-            doBlockingWrite(header);
-            doBlockingWrite(message);
-            try {
-                sos.flush();
-            } catch (IOException e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            }
-
-            if (Constants.OPCODE_CLOSE == opCode) {
-                try {
-                    sos.close();
-                } catch (IOException e) {
-                    // TODO Auto-generated catch block
-                    e.printStackTrace();
-                }
-            }
-        }
-        if (opCode == Constants.OPCODE_CLOSE) {
-            // Connection is closing - ensure no threads are stuck waiting on
-            // the write barrier
-            writeBarrier.reset();
-        }
-    }
-
 
-    private void doBlockingWrite(ByteBuffer data) {
-        if (!sos.canWrite()) {
-            try {
-                writeBarrier.await();
-            } catch (InterruptedException | BrokenBarrierException e) {
-                wsSession.getLocalEndpoint().onError(wsSession, e);
-            }
-        }
-        try {
-            sos.write(data.array(), data.arrayOffset(), data.limit());
-        } catch (IOException e) {
-            wsSession.getLocalEndpoint().onError(wsSession, e);
-        }
+        writeMessage(opCode, header, message);
     }
 
+    protected abstract void writeMessage(int opCode, ByteBuffer header,
+            ByteBuffer message);
+
 
     @Override
     public void setBatchingAllowed(boolean batchingAllowed) {

==================================================
Constants.java
index 433dbb5d89..54d9c40dbd 100644
--- a/java/org/apache/tomcat/websocket/WsSession.java
+++ b/java/org/apache/tomcat/websocket/WsSession.java
@@ -43,12 +43,12 @@ public class WsSession implements Session {
     private static final Charset UTF8 = Charset.forName("UTF8");
 
     private final Endpoint localEndpoint;
-    private WsRemoteEndpoint wsRemoteEndpoint;
+    private WsRemoteEndpointBase wsRemoteEndpoint;
     private MessageHandler textMessageHandler = null;
     private MessageHandler binaryMessageHandler = null;
     private MessageHandler.Basic<PongMessage> pongMessageHandler = null;
 
-    protected WsSession(Endpoint localEndpoint) {
+    public WsSession(Endpoint localEndpoint) {
         this.localEndpoint = localEndpoint;
     }
 
@@ -250,7 +250,7 @@ public class WsSession implements Session {
     }
 
 
-    protected void setRemote(WsRemoteEndpoint wsRemoteEndpoint) {
+    public void setRemote(WsRemoteEndpointBase wsRemoteEndpoint) {
         this.wsRemoteEndpoint = wsRemoteEndpoint;
     }
 
@@ -269,12 +269,12 @@ public class WsSession implements Session {
         return pongMessageHandler;
     }
 
-    protected void onClose(CloseReason closeReason) {
+    public void onClose(CloseReason closeReason) {
         localEndpoint.onClose(this, closeReason);
     }
 
 
-    protected Endpoint getLocalEndpoint() {
+    public Endpoint getLocalEndpoint() {
         return localEndpoint;
     }
 

==================================================
ServerContainerImpl.java
new file mode 100644
index 0000000000..9cbee17dbe
--- /dev/null
+++ b/java/org/apache/tomcat/websocket/server/LocalStrings.properties
@@ -0,0 +1,37 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+sci.newInstance.fail=Failed to create an Endpoint instance of type [{0}]
+serverContainer.endpointDeploy=Endpoint class [{0}] deploying to path [{1}] in ServletContext [{2}]
+serverContainer.missingEndpoint=An Endpoint instance has been request for path [{0}] but no matching Endpoint class was found
+serverContainer.pojoDeploy=POJO class [{0}] deploying to path [{1}] in ServletContext [{2}]
+serverContainer.servletContextMismatch=Attempted to register a POJO annotated for WebSocket at path [{0}] in the ServletContext with context path [{1}] when the WebSocket ServerContainer is allocated to the ServletContext with context path [{2}]
+serverContainer.servletContextMissing=No ServletContext was specified
+uriTemplate.noMatch=The input template [{0}] generated the pattern [{1}] which did not match the supplied pathInfo [{2}]
+# Note the wsFrame.* messages are used as close reasons in WebSocket control
+# frames and therefore must be 123 bytes (not characters) or less in length.
+# Messages are encoded using UTF-8 where a single character may be encoded in
+# as many as 4 bytes.
+wsFrame.byteToLongFail=Too many bytes ([{0}]) were provided to be converted into a long
+wsFrame.controlFragmented=A fragmented control frame was received but control frames may not be fragmented
+wsFrame.controlPayloadTooBig=A control frame was sent with a payload of size [{0}] which is larger than the maximum permitted of 125 bytes
+wsFrame.controlNoFin=A control frame was sent that did not have the fin bit set. Control frames are not permitted to use continuation frames.
+wsFrame.invalidOpCode= A WebSocket frame was sent with an unrecognised opCode of [{0}]
+wsFrame.invalidUtf8=A WebSocket text frame was received that could not be decoded to UTF-8 because it contained invalid byte sequences
+wsFrame.invalidUtf8Close=A WebSocket close frame was received with a close reason that contained invalid UTF-8 byte sequences
+wsFrame.noContinuation=A new message was started when a continuation frame was expected
+wsFrame.notMasked=The client frame was not masked but all client frames must be masked
+wsFrame.oneByteCloseCode=The client sent a close frame with a single byte payload which is not valid
+wsFrame.textMessageTooBig=The decoded text message was too big for the output buffer and the endpoint does not support partial messages
+wsFrame.wrongRsv=The client frame set the reserved bits to [{0}] which was not supported by this endpoint
\ No newline at end of file

==================================================
WsProtocolHandler.java
similarity index 88%
rename from java/org/apache/tomcat/websocket/ServerContainerImpl.java
rename to java/org/apache/tomcat/websocket/server/ServerContainerImpl.java
index 3a4f1ac207..3d7d4ca3ee 100644
--- a/java/org/apache/tomcat/websocket/ServerContainerImpl.java
+++ b/java/org/apache/tomcat/websocket/server/ServerContainerImpl.java
@@ -14,7 +14,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.apache.tomcat.websocket;
+package org.apache.tomcat.websocket.server;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
@@ -31,6 +31,7 @@ import javax.websocket.server.ServerEndpointConfiguration;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.res.StringManager;
+import org.apache.tomcat.websocket.WsWebSocketContainer;
 import org.apache.tomcat.websocket.pojo.PojoEndpointConfiguration;
 import org.apache.tomcat.websocket.pojo.PojoMethodMapping;
 
@@ -111,7 +112,7 @@ public class ServerContainerImpl extends WsWebSocketContainer {
             throw new DeploymentException(sm.getString("sci.newInstance.fail",
                     endpointClass.getName()), e);
         }
-        String servletPath = Util.getServletPath(path);
+        String servletPath = getServletPath(path);
         if (log.isDebugEnabled()) {
             log.debug(sm.getString("serverContainer.endpointDeploy",
                     endpointClass.getName(), path,
@@ -150,7 +151,7 @@ public class ServerContainerImpl extends WsWebSocketContainer {
             log.debug(sm.getString("serverContainer.pojoDeploy",
                     pojo.getName(), wsPath, servletContext.getContextPath()));
         }
-        String servletPath = Util.getServletPath(wsPath);
+        String servletPath = getServletPath(wsPath);
         // Remove the trailing /* before adding it to the map
         pojoMap.put(servletPath.substring(0, servletPath.length() - 2), pojo);
         pojoMethodMap.put(pojo,
@@ -201,4 +202,30 @@ public class ServerContainerImpl extends WsWebSocketContainer {
     public void setReadBufferSize(int readBufferSize) {
         this.readBufferSize = readBufferSize;
     }
+
+
+    /**
+     * Converts a path defined for a WebSocket endpoint into a path that can be
+     * used as a servlet mapping.
+     *
+     * @param wsPath The WebSocket endpoint path to convert
+     * @return The servlet mapping
+     */
+    static String getServletPath(String wsPath) {
+        int templateStart = wsPath.indexOf('{');
+        if (templateStart == -1) {
+            if (wsPath.charAt(wsPath.length() - 1) == '/') {
+                return wsPath + '*';
+            } else {
+                return wsPath + "/*";
+            }
+        } else {
+            String temp = wsPath.substring(0, templateStart);
+            if (temp.charAt(temp.length() - 1) == '/') {
+                return temp + '*';
+            } else {
+                return temp.substring(0, temp.lastIndexOf('/') + 1) + '*';
+            }
+        }
+    }
 }

==================================================
WsRemoteEndpointServer.java
similarity index 88%
rename from java/org/apache/tomcat/websocket/WsProtocolHandler.java
rename to java/org/apache/tomcat/websocket/server/WsProtocolHandler.java
index 386e42b7fc..ae6626fa92 100644
--- a/java/org/apache/tomcat/websocket/WsProtocolHandler.java
+++ b/java/org/apache/tomcat/websocket/server/WsProtocolHandler.java
@@ -14,7 +14,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.apache.tomcat.websocket;
+package org.apache.tomcat.websocket.server;
 
 import java.io.EOFException;
 import java.io.IOException;
@@ -30,6 +30,10 @@ import javax.websocket.CloseReason.CloseCodes;
 import javax.websocket.Endpoint;
 import javax.websocket.EndpointConfiguration;
 
+import org.apache.tomcat.websocket.WsFrame;
+import org.apache.tomcat.websocket.WsIOException;
+import org.apache.tomcat.websocket.WsSession;
+
 /**
  * Servlet 3.1 HTTP upgrade handler for WebSocket connections.
  */
@@ -69,10 +73,11 @@ public class WsProtocolHandler implements ProtocolHandler {
         try {
             WsFrame wsFrame = new WsFrame(sis, wsSession);
             sis.setReadListener(new WsReadListener(this, wsFrame, wsSession));
-            WsRemoteEndpoint wsRemoteEndpoint =
-                    new WsRemoteEndpoint(wsSession, sos);
-            wsSession.setRemote(wsRemoteEndpoint);
-            sos.setWriteListener(new WsWriteListener(this, wsRemoteEndpoint));
+            WsRemoteEndpointServer wsRemoteEndpointServer =
+                    new WsRemoteEndpointServer(wsSession, sos);
+            wsSession.setRemote(wsRemoteEndpointServer);
+            sos.setWriteListener(
+                    new WsWriteListener(this, wsRemoteEndpointServer));
             ep.onOpen(wsSession, endpointConfig);
         } finally {
             t.setContextClassLoader(cl);
@@ -150,18 +155,18 @@ public class WsProtocolHandler implements ProtocolHandler {
     private static class WsWriteListener implements WriteListener {
 
         private final WsProtocolHandler wsProtocolHandler;
-        private final WsRemoteEndpoint wsRemoteEndpoint;
+        private final WsRemoteEndpointServer wsRemoteEndpointServer;
 
         private WsWriteListener(WsProtocolHandler wsProtocolHandler,
-                WsRemoteEndpoint wsRemoteEndpoint) {
+                WsRemoteEndpointServer wsRemoteEndpointServer) {
             this.wsProtocolHandler = wsProtocolHandler;
-            this.wsRemoteEndpoint = wsRemoteEndpoint;
+            this.wsRemoteEndpointServer = wsRemoteEndpointServer;
         }
 
 
         @Override
         public void onWritePossible() {
-            wsRemoteEndpoint.onWritePossible();
+            wsRemoteEndpointServer.onWritePossible();
         }
 
 

==================================================
WsSci.java
new file mode 100644
index 0000000000..8ff01e934d
--- /dev/null
+++ b/java/org/apache/tomcat/websocket/server/WsRemoteEndpointServer.java
@@ -0,0 +1,108 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.websocket.server;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.concurrent.BrokenBarrierException;
+import java.util.concurrent.CyclicBarrier;
+
+import javax.servlet.ServletOutputStream;
+
+import org.apache.tomcat.websocket.Constants;
+import org.apache.tomcat.websocket.WsRemoteEndpointBase;
+import org.apache.tomcat.websocket.WsSession;
+
+/**
+ * This is the server side {@link RemoteEndpoint} implementation - i.e. what the
+ * server uses to send data to the client. Communication is over a
+ * {@link ServletOutputStream}.
+ */
+public class WsRemoteEndpointServer extends WsRemoteEndpointBase {
+
+    private final WsSession wsSession;
+    private final ServletOutputStream sos;
+    private final Object messageWriteLock = new Object();
+
+    private volatile CyclicBarrier writeBarrier = new CyclicBarrier(2);
+
+
+    public WsRemoteEndpointServer(WsSession wsSession,
+            ServletOutputStream sos) {
+        this.wsSession = wsSession;
+        this.sos = sos;
+    }
+
+
+    @Override
+    public void onWritePossible() {
+        try {
+            writeBarrier.await();
+        } catch (InterruptedException | BrokenBarrierException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+    }
+
+
+    @Override
+    protected void writeMessage(int opCode, ByteBuffer header,
+            ByteBuffer message) {
+        // Could sync on sos but don't as other (user or container) code may
+        // sync on this creating the potential for deadlocks.
+        synchronized (messageWriteLock) {
+            doBlockingWrite(header);
+            doBlockingWrite(message);
+            try {
+                sos.flush();
+            } catch (IOException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+            }
+
+            if (Constants.OPCODE_CLOSE == opCode) {
+                try {
+                    sos.close();
+                } catch (IOException e) {
+                    // TODO Auto-generated catch block
+                    e.printStackTrace();
+                }
+            }
+        }
+        if (opCode == Constants.OPCODE_CLOSE) {
+            // Connection is closing - ensure no threads are stuck waiting on
+            // the write barrier
+            writeBarrier.reset();
+        }
+    }
+
+
+    private void doBlockingWrite(ByteBuffer data) {
+        if (!sos.canWrite()) {
+            try {
+                writeBarrier.await();
+            } catch (InterruptedException | BrokenBarrierException e) {
+                wsSession.getLocalEndpoint().onError(wsSession, e);
+            }
+        }
+        try {
+            sos.write(data.array(), data.arrayOffset(), data.limit());
+        } catch (IOException e) {
+            wsSession.getLocalEndpoint().onError(wsSession, e);
+        }
+    }
+}

==================================================
WsServlet.java
similarity index 97%
rename from java/org/apache/tomcat/websocket/WsSci.java
rename to java/org/apache/tomcat/websocket/server/WsSci.java
index 29b6a70dc7..df2298dded 100644
--- a/java/org/apache/tomcat/websocket/WsSci.java
+++ b/java/org/apache/tomcat/websocket/server/WsSci.java
@@ -14,7 +14,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.apache.tomcat.websocket;
+package org.apache.tomcat.websocket.server;
 
 import java.util.Set;
 
@@ -24,6 +24,7 @@ import javax.servlet.ServletException;
 import javax.servlet.annotation.HandlesTypes;
 import javax.websocket.server.WebSocketEndpoint;
 
+
 /**
  * Registers an interest in any class that is annotated with
  * {@link WebSocketEndpoint} so that Endpoint can be published via the WebSocket

==================================================
package-info.java
similarity index 99%
rename from java/org/apache/tomcat/websocket/WsServlet.java
rename to java/org/apache/tomcat/websocket/server/WsServlet.java
index fb738779d7..08076e5b0f 100644
--- a/java/org/apache/tomcat/websocket/WsServlet.java
+++ b/java/org/apache/tomcat/websocket/server/WsServlet.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.tomcat.websocket;
+package org.apache.tomcat.websocket.server;
 
 import java.io.IOException;
 import java.nio.charset.Charset;
@@ -38,6 +38,7 @@ import javax.websocket.Extension;
 import javax.websocket.server.ServerEndpointConfiguration;
 import javax.xml.bind.DatatypeConverter;
 
+
 /**
  * Handles the initial HTTP connection for WebSocket connections.
  */

==================================================
TestWsWebSocketContainer.java
index 6c63a6812a..2028f5bbaf 100644
--- a/res/checkstyle/org-import-control.xml
+++ b/res/checkstyle/org-import-control.xml
@@ -138,12 +138,16 @@
       </subpackage>
     </subpackage>
     <subpackage name="websocket">
-      <allow pkg="javax.servlet"/>
       <allow pkg="javax.websocket"/>
       <allow pkg="org.apache.juli"/>
       <allow pkg="org.apache.tomcat.util"/>
       <!-- Ideally want to remove this -->
       <allow pkg="org.apache.tomcat.websocket.pojo"/>
+      <disallow pkg="javax.servlet"/>
+      <subpackage name="server">
+        <allow pkg="javax.servlet"/>
+        <allow pkg="org.apache.tomcat.websocket"/>
+      </subpackage>
     </subpackage>
   </subpackage>
 </import-control>
\ No newline at end of file

==================================================
TestServerContainerImpl.java
new file mode 100644
index 0000000000..f2de6c9d8f
--- /dev/null
+++ b/test/org/apache/tomcat/websocket/TestWsWebSocketContainer.java
@@ -0,0 +1,109 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.websocket;
+
+import java.io.File;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import javax.websocket.ContainerProvider;
+import javax.websocket.DefaultClientConfiguration;
+import javax.websocket.Endpoint;
+import javax.websocket.EndpointConfiguration;
+import javax.websocket.MessageHandler;
+import javax.websocket.Session;
+import javax.websocket.WebSocketContainer;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import org.apache.catalina.startup.Tomcat;
+import org.apache.catalina.startup.TomcatBaseTest;
+
+public class TestWsWebSocketContainer extends TomcatBaseTest {
+
+    private static final String MESSAGE_STRING_1 = "qwerty";
+
+    @Test
+    public void testConnectToServerEndpoint() throws Exception {
+        // Examples app includes WebSocket Echo endpoint
+        Tomcat tomcat = getTomcatInstance();
+        File appDir = new File(getBuildDirectory(), "webapps/examples");
+        tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath());
+
+        tomcat.start();
+
+        WebSocketContainer wsContainer = ContainerProvider.getClientContainer();
+        Session wsSession = wsContainer.connectToServer(TesterEndpoint.class,
+                new DefaultClientConfiguration(), new URI("http://localhost:" +
+                        getPort() + "/examples/echoAnnotation"));
+        TesterMessageHandlerString handler = new TesterMessageHandlerString(1);
+        wsSession.addMessageHandler(handler);
+        wsSession.getRemote().sendString(MESSAGE_STRING_1);
+
+        boolean latchResult = handler.getLatch().await(10, TimeUnit.SECONDS);
+
+        Assert.assertTrue(latchResult);
+
+        List<String> messages = handler.getMessages();
+        Assert.assertEquals(1, messages.size());
+        Assert.assertEquals(MESSAGE_STRING_1, messages.get(0));
+    }
+
+    private static class TesterMessageHandlerString
+            implements MessageHandler.Basic<String> {
+
+        private final CountDownLatch latch;
+
+        private List<String> messages = new ArrayList<>();
+
+        public TesterMessageHandlerString(int latchCount) {
+            if (latchCount > 0) {
+                latch = new CountDownLatch(latchCount);
+            } else {
+                latch = null;
+            }
+        }
+
+        public List<String> getMessages() {
+            return messages;
+        }
+
+        public CountDownLatch getLatch() {
+            return latch;
+        }
+
+        @Override
+        public void onMessage(String message) {
+            if (latch != null) {
+                latch.countDown();
+            }
+            messages.add(message);
+        }
+    }
+
+    private static class TesterEndpoint extends Endpoint {
+
+        @Override
+        public void onOpen(Session session, EndpointConfiguration config) {
+            // TODO Auto-generated method stub
+        }
+    }
+}

==================================================
WsConfigListener.java
similarity index 67%
rename from test/org/apache/tomcat/websocket/TestUtil.java
rename to test/org/apache/tomcat/websocket/server/TestServerContainerImpl.java
index 152716fd83..96f174272d 100644
--- a/test/org/apache/tomcat/websocket/TestUtil.java
+++ b/test/org/apache/tomcat/websocket/server/TestServerContainerImpl.java
@@ -14,30 +14,30 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.apache.tomcat.websocket;
+package org.apache.tomcat.websocket.server;
 
 import org.junit.Assert;
 import org.junit.Test;
 
-public class TestUtil {
+public class TestServerContainerImpl {
 
     @Test
     public void testGetServletMappingPath() throws Exception {
         Assert.assertEquals("/foo/*",
-                Util.getServletPath("/foo"));
+                ServerContainerImpl.getServletPath("/foo"));
         Assert.assertEquals("/foo/*",
-                Util.getServletPath("/foo/"));
+                ServerContainerImpl.getServletPath("/foo/"));
         Assert.assertEquals("/foo/bar/*",
-                Util.getServletPath("/foo/bar"));
+                ServerContainerImpl.getServletPath("/foo/bar"));
         Assert.assertEquals("/foo/bar/*",
-                Util.getServletPath("/foo/bar/"));
+                ServerContainerImpl.getServletPath("/foo/bar/"));
         Assert.assertEquals("/foo/*",
-                Util.getServletPath("/foo/{bar}"));
+                ServerContainerImpl.getServletPath("/foo/{bar}"));
         Assert.assertEquals("/foo/*",
-                Util.getServletPath("/foo/{bar}/"));
+                ServerContainerImpl.getServletPath("/foo/{bar}/"));
         Assert.assertEquals("/foo/*",
-                Util.getServletPath("/foo/x{bar}"));
+                ServerContainerImpl.getServletPath("/foo/x{bar}"));
         Assert.assertEquals("/foo/*",
-                Util.getServletPath("/foo/x{bar}/"));
+                ServerContainerImpl.getServletPath("/foo/x{bar}/"));
     }
 }

==================================================
