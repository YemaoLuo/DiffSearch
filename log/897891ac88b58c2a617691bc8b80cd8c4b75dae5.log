897891ac88b58c2a617691bc8b80cd8c4b75dae5
==================================================
Refactor - simplification
==================================================
Mark Thomas
==================================================
Wed Jan 16 15:55:46 2019 +0000
==================================================
AbstractStream.java
Refactor - simplification

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1851461 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http2AsyncUpgradeHandler.java
index 25883395b6..fac522d3b9 100644
--- a/java/org/apache/coyote/http2/AbstractStream.java
+++ b/java/org/apache/coyote/http2/AbstractStream.java
@@ -38,13 +38,19 @@ abstract class AbstractStream {
     private final Set<Stream> childStreams = Collections.newSetFromMap(new ConcurrentHashMap<>());
     private long windowSize = ConnectionSettingsBase.DEFAULT_INITIAL_WINDOW_SIZE;
 
+
+    AbstractStream(Integer identifier) {
+        this.identifier = identifier;
+    }
+
+
     final Integer getIdentifier() {
         return identifier;
     }
 
 
-    AbstractStream(Integer identifier) {
-        this.identifier = identifier;
+    final int getIdAsInt() {
+        return identifier.intValue();
     }
 
 

==================================================
Http2UpgradeHandler.java
index 2ab57910a7..15098f066b 100644
--- a/java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java
+++ b/java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java
@@ -195,7 +195,7 @@ public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
             }
         }
         if (writeable) {
-            ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue());
+            ByteUtil.set31Bits(header, 5, stream.getIdAsInt());
             int orgLimit = data.limit();
             data.limit(data.position() + len);
             socketWrapper.write(BlockingMode.BLOCK, protocol.getWriteTimeout(),
@@ -223,7 +223,7 @@ public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
         ByteUtil.setThreeBytes(frame2, 0,  4);
         frame2[3] = FrameType.WINDOW_UPDATE.getIdByte();
         ByteUtil.set31Bits(frame2, 9, increment);
-        ByteUtil.set31Bits(frame2, 5, stream.getIdentifier().intValue());
+        ByteUtil.set31Bits(frame2, 5, stream.getIdAsInt());
         socketWrapper.write(BlockingMode.SEMI_BLOCK, protocol.getWriteTimeout(),
                 TimeUnit.MILLISECONDS, null, SocketWrapperBase.COMPLETE_WRITE, errorCompletion,
                 ByteBuffer.wrap(frame), ByteBuffer.wrap(frame2));
@@ -301,7 +301,7 @@ public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
                 }
             }
             if (writeable) {
-                ByteUtil.set31Bits(header, 5, sendfile.stream.getIdentifier().intValue());
+                ByteUtil.set31Bits(header, 5, sendfile.stream.getIdAsInt());
                 sendfile.mappedBuffer.limit(sendfile.mappedBuffer.position() + frameSize);
                 socketWrapper.write(BlockingMode.SEMI_BLOCK, protocol.getWriteTimeout(),
                         TimeUnit.MILLISECONDS, sendfile, SocketWrapperBase.COMPLETE_WRITE_WITH_COMPLETION,
@@ -362,7 +362,7 @@ public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
                 }
             }
             if (writeable) {
-                ByteUtil.set31Bits(header, 5, sendfile.stream.getIdentifier().intValue());
+                ByteUtil.set31Bits(header, 5, sendfile.stream.getIdAsInt());
                 sendfile.mappedBuffer.limit(sendfile.mappedBuffer.position() + frameSize);
                 socketWrapper.write(BlockingMode.SEMI_BLOCK, protocol.getWriteTimeout(),
                         TimeUnit.MILLISECONDS, sendfile, SocketWrapperBase.COMPLETE_WRITE_WITH_COMPLETION,

==================================================
Stream.java
index 0041fbc1c7..67695a66a1 100644
--- a/java/org/apache/coyote/http2/Http2UpgradeHandler.java
+++ b/java/org/apache/coyote/http2/Http2UpgradeHandler.java
@@ -601,7 +601,7 @@ class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeH
                 if (log.isDebugEnabled()) {
                     log.debug(headerFrameBuffers.getPayload().limit() + " bytes");
                 }
-                ByteUtil.set31Bits(headerFrameBuffers.getHeader(), 5, stream.getIdentifier().intValue());
+                ByteUtil.set31Bits(headerFrameBuffers.getHeader(), 5, stream.getIdAsInt());
                 headerFrameBuffers.endFrame();
             } else if (state == State.UNDERFLOW) {
                 headerFrameBuffers.expandPayload();
@@ -644,7 +644,7 @@ class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeH
             }
         }
         if (writeable) {
-            ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue());
+            ByteUtil.set31Bits(header, 5, stream.getIdAsInt());
             synchronized (socketWrapper) {
                 try {
                     socketWrapper.write(true, header, 0, header.length);
@@ -694,7 +694,7 @@ class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeH
             ByteUtil.set31Bits(frame, 9, increment);
             socketWrapper.write(true, frame, 0, frame.length);
             // Change stream Id and re-use
-            ByteUtil.set31Bits(frame, 5, stream.getIdentifier().intValue());
+            ByteUtil.set31Bits(frame, 5, stream.getIdAsInt());
             try {
                 socketWrapper.write(true, frame, 0, frame.length);
                 socketWrapper.flush(true);
@@ -1164,8 +1164,8 @@ class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeH
         // is sent before the next stream is created for a PUSH_PROMISE.
         synchronized (socketWrapper) {
             pushStream = createLocalStream(request);
-            writeHeaders(associatedStream, pushStream.getIdentifier().intValue(),
-                    request.getMimeHeaders(), false, Constants.DEFAULT_HEADERS_FRAME_SIZE);
+            writeHeaders(associatedStream, pushStream.getIdAsInt(), request.getMimeHeaders(),
+                    false, Constants.DEFAULT_HEADERS_FRAME_SIZE);
         }
 
         pushStream.sentPushPromise();
@@ -1390,7 +1390,7 @@ class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeH
                     stream.close(new StreamException(sm.getString(
                             "upgradeHandler.windowSizeTooBig", connectionId,
                             stream.getIdentifier()),
-                            h2e.getError(), stream.getIdentifier().intValue()));
+                            h2e.getError(), stream.getIdAsInt()));
                }
             }
         } else {

==================================================
StreamStateMachine.java
index 6c9a8c4523..4607ab4b2c 100644
--- a/java/org/apache/coyote/http2/Stream.java
+++ b/java/org/apache/coyote/http2/Stream.java
@@ -281,7 +281,7 @@ class Stream extends AbstractStream implements HeaderEmitter {
         if (pseudoHeader && headerState != HEADER_STATE_PSEUDO) {
             headerException = new StreamException(sm.getString(
                     "stream.header.unexpectedPseudoHeader", getConnectionId(), getIdentifier(),
-                    name), Http2Error.PROTOCOL_ERROR, getIdentifier().intValue());
+                    name), Http2Error.PROTOCOL_ERROR, getIdAsInt());
             // No need for further processing. The stream will be reset.
             return;
         }
@@ -379,7 +379,7 @@ class Stream extends AbstractStream implements HeaderEmitter {
             if (pseudoHeader) {
                 headerException = new StreamException(sm.getString(
                         "stream.header.unknownPseudoHeader", getConnectionId(), getIdentifier(),
-                        name), Http2Error.PROTOCOL_ERROR, getIdentifier().intValue());
+                        name), Http2Error.PROTOCOL_ERROR, getIdAsInt());
             }
 
             if (headerState == HEADER_STATE_TRAILER) {
@@ -634,7 +634,7 @@ class Stream extends AbstractStream implements HeaderEmitter {
 
     final void push(Request request) throws IOException {
         // Can only push when supported and from a peer initiated stream
-        if (!isPushSupported() || getIdentifier().intValue() % 2 == 0) {
+        if (!isPushSupported() || getIdAsInt() % 2 == 0) {
             return;
         }
         // Set the special HTTP/2 headers

==================================================
