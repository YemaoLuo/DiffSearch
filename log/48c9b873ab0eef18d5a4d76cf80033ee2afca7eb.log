48c9b873ab0eef18d5a4d76cf80033ee2afca7eb
==================================================
Remove ugly reflection using a generic id
==================================================
remm remm@apache.org
==================================================
Mon Feb 1 15:04:32 2021 +0100
==================================================
Connector.java
Remove ugly reflection using a generic id

The id if available then replaces address-port to name threads and
mbeans.


==================================================
AbstractProtocol.java
index 4f4be1c38f..8eb235da5e 100644
--- a/java/org/apache/catalina/connector/Connector.java
+++ b/java/org/apache/catalina/connector/Connector.java
@@ -950,11 +950,11 @@ public class Connector extends LifecycleMBeanBase  {
 
         StringBuilder sb = new StringBuilder("type=");
         sb.append(type);
-        Object path = getProperty("unixDomainSocketPath");
-        if (path != null) {
+        String id = protocolHandler.getId();
+        if (id != null) {
             // Maintain MBean name compatibility, even if not accurate
             sb.append(",port=0,address=");
-            sb.append(ObjectName.quote(path.toString()));
+            sb.append(ObjectName.quote(id));
         } else {
             sb.append(",port=");
             int port = getPortWithOffset();
@@ -1066,7 +1066,7 @@ public class Connector extends LifecycleMBeanBase  {
     protected void startInternal() throws LifecycleException {
 
         // Validate settings before starting
-        if (getProperty("unixDomainSocketPath") == null && getPortWithOffset() < 0) {
+        if (protocolHandler.getId() == null && getPortWithOffset() < 0) {
             throw new LifecycleException(sm.getString(
                     "coyoteConnector.invalidPort", Integer.valueOf(getPortWithOffset())));
         }
@@ -1132,9 +1132,9 @@ public class Connector extends LifecycleMBeanBase  {
         StringBuilder sb = new StringBuilder("Connector[");
         sb.append(getProtocol());
         sb.append('-');
-        Object path = getProperty("unixDomainSocketPath");
-        if (path != null) {
-            sb.append(path.toString());
+        Object id = protocolHandler.getId();
+        if (id != null) {
+            sb.append(id.toString());
         } else {
             int port = getPortWithOffset();
             if (port > 0) {

==================================================
ProtocolHandler.java
index 09b60dd4eb..7b8756d28b 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -207,6 +207,12 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
     }
 
 
+    @Override
+    public String getId() {
+        return endpoint.getId();
+    }
+
+
     // ---------------------- Properties that are passed through to the EndPoint
 
     @Override
@@ -347,9 +353,9 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
     private String getNameInternal() {
         StringBuilder name = new StringBuilder(getNamePrefix());
         name.append('-');
-        String path = getProperty("unixDomainSocketPath");
-        if (path != null) {
-            name.append(path);
+        String id = getId();
+        if (id != null) {
+            name.append(id);
         } else {
             if (getAddress() != null) {
                 name.append(getAddress().getHostAddress());

==================================================
AbstractEndpoint.java
index dfa5a25c36..cf25010a83 100644
--- a/java/org/apache/coyote/ProtocolHandler.java
+++ b/java/org/apache/coyote/ProtocolHandler.java
@@ -206,6 +206,17 @@ public interface ProtocolHandler {
     }
 
 
+    /**
+     * The default behavior is to identify connectors uniquely with address
+     * and port. However, certain connectors are not using that and need
+     * some other identifier, which then can be used as a replacement.
+     * @return the id
+     */
+    public default String getId() {
+        return null;
+    }
+
+
     /**
      * Create a new ProtocolHandler for the given protocol.
      * @param protocol the protocol

==================================================
AprEndpoint.java
index 62f80455e2..ae5c798f57 100644
--- a/java/org/apache/tomcat/util/net/AbstractEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AbstractEndpoint.java
@@ -807,6 +807,17 @@ public abstract class AbstractEndpoint<S,U> {
     }
 
 
+    /**
+     * The default behavior is to identify connectors uniquely with address
+     * and port. However, certain connectors are not using that and need
+     * some other identifier, which then can be used as a replacement.
+     * @return the id
+     */
+    public String getId() {
+        return null;
+    }
+
+
     protected final List<String> negotiableProtocols = new ArrayList<>();
     public void addNegotiatedProtocol(String negotiableProtocol) {
         negotiableProtocols.add(negotiableProtocol);

==================================================
NioEndpoint.java
index 9d212a1d5f..cf62eabe1f 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -304,6 +304,16 @@ public class AprEndpoint extends AbstractEndpoint<Long,Long> implements SNICallB
     }
 
 
+    @Override
+    public String getId() {
+        if (getUnixDomainSocketPath() != null) {
+            return getUnixDomainSocketPath();
+        } else {
+            return null;
+        }
+    }
+
+
     // ----------------------------------------------- Public Lifecycle Methods
 
 

==================================================
