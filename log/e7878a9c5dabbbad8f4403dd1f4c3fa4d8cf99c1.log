e7878a9c5dabbbad8f4403dd1f4c3fa4d8cf99c1
==================================================
Fix trailing whitespace and import order
==================================================
Mark Emlyn
==================================================
Wed Feb 22 19:22:51 2012 +0000
==================================================
Http11AprProtocol.java
Fix trailing whitespace and import order

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1292459 13f79535-47bb-0310-9956-ffa450edef68



==================================================
SpdyProcessor.java
index 8db314fa41..32ae242177 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -26,10 +26,10 @@ import org.apache.coyote.http11.upgrade.UpgradeInbound;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.net.AbstractEndpoint;
-import org.apache.tomcat.util.net.AprEndpoint;
-import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
+import org.apache.tomcat.util.net.AprEndpoint;
 import org.apache.tomcat.util.net.AprEndpoint.Handler;
+import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapper;
 
 
@@ -45,8 +45,8 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
 
     private static final Log log = LogFactory.getLog(Http11AprProtocol.class);
 
-    /** 
-     * Interface specific for protocols that negotiate at NPN level, like 
+    /**
+     * Interface specific for protocols that negotiate at NPN level, like
      * SPDY. This is only available for APR, will replace the HTTP framing.
      */
     public static interface NpnHandler {
@@ -193,7 +193,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
             getLog().warn("Failed to init light protocol " + impl, ex);
         }
     }
-    
+
     // ----------------------------------------------------- JMX related methods
 
     @Override
@@ -201,7 +201,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
         return ("http-apr");
     }
 
-    
+
     @Override
     public void start() throws Exception {
         super.start();
@@ -210,7 +210,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
             npnHandler.init(endpoint, sslCtx, adapter);
         }
     }
-    
+
     // --------------------  Connection handler --------------------
 
     protected static class Http11ConnectionHandler
@@ -257,7 +257,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
                         socket.getSocket().longValue(), true);
             }
         }
-        
+
         @Override
         public SocketState process(SocketWrapper<Long> socket,
                 SocketStatus status) {
@@ -265,7 +265,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
                 Processor<Long> processor = null;
                 if (status == SocketStatus.OPEN) {
                     processor = connections.get(socket.getSocket());
-                   
+
                 }
                 if (processor == null) {
                     // if not null - this is a former comet request, handled by http11

==================================================
SpdyProxyProtocol.java
index 5a0a198622..ecaefcc629 100644
--- a/java/org/apache/coyote/spdy/SpdyProcessor.java
+++ b/java/org/apache/coyote/spdy/SpdyProcessor.java
@@ -31,8 +31,8 @@ import org.apache.coyote.Request;
 import org.apache.coyote.RequestInfo;
 import org.apache.coyote.Response;
 import org.apache.coyote.http11.upgrade.UpgradeInbound;
-import org.apache.tomcat.spdy.SpdyFrame;
 import org.apache.tomcat.spdy.SpdyConnection;
+import org.apache.tomcat.spdy.SpdyFrame;
 import org.apache.tomcat.spdy.SpdyStream;
 import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.buf.Ascii;
@@ -49,9 +49,9 @@ import org.apache.tomcat.util.net.SocketWrapper;
 /**
  * A spdy stream ( multiplexed over a spdy tcp connection ) processed by a
  * tomcat servlet.
- * 
+ *
  * Based on the AJP processor.
- * 
+ *
  */
 public class SpdyProcessor extends AbstractProcessor<Object> implements
         Runnable {

==================================================
SpdyConnection.java
index 9a59a41004..4c0231626d 100644
--- a/java/org/apache/coyote/spdy/SpdyProxyProtocol.java
+++ b/java/org/apache/coyote/spdy/SpdyProxyProtocol.java
@@ -33,26 +33,26 @@ import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapper;
 
 /**
- * SPDY in 'proxy' mode - no SSL and no header compression. 
- * This doesn't require JNI libraries, SSL/compression are off-loaded to 
- * a reverse proxy ( apache, etc ). 
- * 
+ * SPDY in 'proxy' mode - no SSL and no header compression.
+ * This doesn't require JNI libraries, SSL/compression are off-loaded to
+ * a reverse proxy ( apache, etc ).
+ *
  * To configure:
- * <Connector port="8011" protocol="org.apache.coyote.spdy.SpdyProxyProtocol"/> 
- * 
- * To test, use 
+ * <Connector port="8011" protocol="org.apache.coyote.spdy.SpdyProxyProtocol"/>
+ *
+ * To test, use
  *   chrome  --use-spdy=no-compress,no-ssl [--enable-websocket-over-spdy]
- * 
+ *
  * TODO: Remote information (client ip, certs, etc ) will be sent in X- headers.
  * TODO: if spdy->spdy proxy, info about original spdy stream for pushes.
- * 
+ *
  */
 public class SpdyProxyProtocol extends AbstractProtocol {
     private static final Log log = LogFactory.getLog(SpdyProxyProtocol.class);
-    
+
     JIoEndpoint.Handler cHandler = new TomcatJioHandler();
     SpdyContextProxy spdyContext;
-    
+
     public SpdyProxyProtocol() {
         endpoint = new JIoEndpoint();
         ((JIoEndpoint) endpoint).setHandler(cHandler);
@@ -60,7 +60,7 @@ public class SpdyProxyProtocol extends AbstractProtocol {
         setSoTimeout(Constants.DEFAULT_CONNECTION_TIMEOUT);
         setTcpNoDelay(Constants.DEFAULT_TCP_NO_DELAY);
     }
-    
+
     @Override
     protected Log getLog() {
         return log;
@@ -80,7 +80,7 @@ public class SpdyProxyProtocol extends AbstractProtocol {
     protected Handler getHandler() {
         return cHandler;
     }
-    
+
     public void start() throws Exception {
         super.start();
         spdyContext = new SpdyContextProxy() {
@@ -93,7 +93,7 @@ public class SpdyProxyProtocol extends AbstractProtocol {
         };
         spdyContext.setExecutor(endpoint.getExecutor());
     }
-    
+
     public class TomcatJioHandler implements JIoEndpoint.Handler {
 
         @Override
@@ -108,7 +108,7 @@ public class SpdyProxyProtocol extends AbstractProtocol {
         @Override
         public SocketState process(SocketWrapper<Socket> socket,
                 SocketStatus status) {
-            SpdyConnection ch = spdyContext.getConnection(socket.getSocket()); 
+            SpdyConnection ch = spdyContext.getConnection(socket.getSocket());
             ch.onBlockingSocket();
             return SocketState.CLOSED;
         }

==================================================
SpdyContext.java
index 337c5ad1a9..c75ec31372 100644
--- a/java/org/apache/tomcat/spdy/SpdyConnection.java
+++ b/java/org/apache/tomcat/spdy/SpdyConnection.java
@@ -30,12 +30,12 @@ import java.util.logging.Logger;
  * Main class implementing SPDY protocol. Works with both blocking and
  * non-blocking sockets. To simplify integration in various endpoints there is
  * no 'socket' layer/abstraction, but read/write abstract methods.
- * 
+ *
  * Because SPDY is multiplexing, a blocking socket needs a second thread to
  * handle writes ( the read thread may be blocked while a servlet is writing ).
  * The intended use of SPDY with blocking sockets is for frontend(load-balancer)
  * to tomcat, where each tomcat will have a few spdy connections.
- * 
+ *
  */
 public abstract class SpdyConnection { // implements Runnable {
 
@@ -159,11 +159,11 @@ public abstract class SpdyConnection { // implements Runnable {
     /*
      * Output requirements: - common case: sendFrame called from a thread ( like
      * servlets ), wants to be blocked anyways
-     * 
+     *
      * - but also need to support 'non-blocking' mode ( ping )
-     * 
+     *
      * - we need to queue frames when write would block, so we can prioritize.
-     * 
+     *
      * - for fully non-blocking write: there will be a drain callback.
      */
 
@@ -259,7 +259,7 @@ public abstract class SpdyConnection { // implements Runnable {
 
     /**
      * Blocking call for sendFrame: must be called from a thread pool.
-     * 
+     *
      * Will wait until the actual frame is sent.
      */
     public void sendFrameBlocking(SpdyFrame oframe, SpdyStream proc)
@@ -284,7 +284,7 @@ public abstract class SpdyConnection { // implements Runnable {
 
     /**
      * Send as much as possible without blocking.
-     * 
+     *
      * With a nb transport it should call drain directly.
      */
     public void nonBlockingDrain() {
@@ -509,7 +509,7 @@ public abstract class SpdyConnection { // implements Runnable {
 
     /**
      * Process a SPDY connection. Called in a separate thread.
-     * 
+     *
      * @return
      * @throws IOException
      */
@@ -617,7 +617,7 @@ public abstract class SpdyConnection { // implements Runnable {
     public void setSpdyContext(SpdyContext spdyContext) {
         this.spdyContext = spdyContext;
     }
-    
+
     public SpdyStream get(String host, String url) throws IOException {
         SpdyStream sch = new SpdyStream(this);
         sch.addHeader("host", host);

==================================================
SpdyContextProxy.java
index 582686294f..7e2748a4d5 100644
--- a/java/org/apache/tomcat/spdy/SpdyContext.java
+++ b/java/org/apache/tomcat/spdy/SpdyContext.java
@@ -23,12 +23,12 @@ import java.util.concurrent.Executors;
 /**
  * Will implement polling/reuse of heavy objects, allow additional
  * configuration.
- * 
+ *
  * The abstract methods allow integration with different libraries (
  * compression, request handling )
- * 
+ *
  * In 'external' mode it must be used with APR library and compression.
- * 
+ *
  * In 'intranet' mode - it is supposed to be used behind a load balancer that
  * handles SSL and compression. Test with: --user-data-dir=/tmp/test
  * --use-spdy=no-compress,no-ssl
@@ -61,7 +61,7 @@ public class SpdyContext {
     public void releaseFrame(SpdyFrame done) {
     }
 
-    /** 
+    /**
      * Override for server side to return a custom stream.
      */
     public SpdyStream getStream(SpdyConnection framer) {
@@ -72,11 +72,11 @@ public class SpdyContext {
     public void setExecutor(Executor executor) {
         this.executor = executor;
     }
-    
+
     /**
      * SPDY is a multiplexed protocol - the SpdyProcessors will be executed on
      * this executor.
-     * 
+     *
      * If the context returns null - we'll assume the SpdyProcessors are fully
      * non blocking, and will execute them in the spdy thread.
      */
@@ -87,16 +87,16 @@ public class SpdyContext {
         return executor;
     }
 
-    /** 
+    /**
      * Override for servers.
-     * @throws IOException 
+     * @throws IOException
      */
     protected void onSynStream(SpdyConnection spdyCon, SpdyStream ch) throws IOException {
     }
 
     /**
-     * Client mode: return a connection for host/port. 
-     * @throws IOException 
+     * Client mode: return a connection for host/port.
+     * @throws IOException
      */
     public SpdyConnection getConnection(String host, int port) throws IOException {
         return null;

==================================================
SpdyStream.java
index a73975bb5a..6c5ce7cea3 100644
--- a/java/org/apache/tomcat/spdy/SpdyContextProxy.java
+++ b/java/org/apache/tomcat/spdy/SpdyContextProxy.java
@@ -8,8 +8,8 @@ import java.net.SocketTimeoutException;
 
 /**
  * Spdy context for 'proxy' or test mode spdy - no NPN, no SSL, no compression.
- * 
- * This can be supported without JNI dependencies. 
+ *
+ * This can be supported without JNI dependencies.
  * It can be modified to support SSL and compression - but so far the only way
  * to use NPN is via JNI.
  */
@@ -32,10 +32,10 @@ public class SpdyContextProxy extends SpdyContext {
         }
 
     }
-    
+
     public SpdyConnection getConnection(Socket socket) {
         return new SpdyConnectionSocket(this, socket);
-    }    
+    }
 
     public static class SpdyConnectionSocket extends SpdyConnection {
         Socket socket;
@@ -57,12 +57,12 @@ public class SpdyContextProxy extends SpdyContext {
         public SpdyConnectionSocket(SpdyContext spdyContext) {
             super(spdyContext);
         }
-        
+
         public SpdyConnectionSocket(SpdyContext spdyContext, Socket socket) {
             super(spdyContext);
             this.socket = socket;
         }
-        
+
         @Override
         public synchronized int write(byte[] data, int off, int len) throws IOException {
             socket.getOutputStream().write(data, off, len);

==================================================
AprEndpoint.java
index 7c2a06a44f..11b297efff 100644
--- a/java/org/apache/tomcat/spdy/SpdyStream.java
+++ b/java/org/apache/tomcat/spdy/SpdyStream.java
@@ -25,14 +25,14 @@ import java.util.concurrent.TimeUnit;
 
 /**
  * One SPDY stream.
- * 
+ *
  * Created by SpdyContext.getProcessor(framer).
- * 
+ *
  * The methods are called in a IO thread when the framer received a frame for
  * this stream.
- * 
+ *
  * They should not block.
- * 
+ *
  * The frame must be either consumed or popInFrame must be called, after the
  * call is done the frame will be reused.
  */
@@ -56,10 +56,10 @@ public class SpdyStream {
     public SpdyStream(SpdyConnection spdy) {
         this.spdy = spdy;
     }
-    
+
     /**
      * Non-blocking, called when a data frame is received.
-     * 
+     *
      * The processor must consume the data, or set frame.data to null or a fresh
      * buffer ( to avoid a copy ).
      */
@@ -74,9 +74,9 @@ public class SpdyStream {
     /**
      * Non-blocking - handles a syn stream package. The processor must consume
      * frame.data or set it to null.
-     * 
+     *
      * The base method is for client implementation - servers need to override
-     * and process the frame as a request. 
+     * and process the frame as a request.
      */
     public void onCtlFrame(SpdyFrame frame) throws IOException {
         // TODO: handle RST
@@ -92,7 +92,7 @@ public class SpdyStream {
 
     /**
      * True if the channel both received and sent FIN frames.
-     * 
+     *
      * This is tracked by the processor, to avoid extra storage in framer.
      */
     public boolean isFinished() {
@@ -115,7 +115,7 @@ public class SpdyStream {
             throw new IOException(e);
         }
     }
-    
+
     public void getHeaders(Map<String, String> resHeaders) {
         SpdyFrame f = resFrame;
         int nvCount = f.nvCount;
@@ -129,7 +129,7 @@ public class SpdyStream {
             resHeaders.put(n, v);
         }
     }
-    
+
     public SpdyFrame getRequest() {
         if (reqFrame == null) {
             reqFrame = spdy.getFrame(SpdyConnection.TYPE_SYN_STREAM);
@@ -143,8 +143,8 @@ public class SpdyStream {
         nameB = value.getBytes();
         reqFrame.headerValue(nameB, 0, nameB.length);
     }
-    
-    
+
+
     public synchronized void sendDataFrame(byte[] data, int start,
             int length, boolean close) throws IOException {
 
@@ -177,7 +177,7 @@ public class SpdyStream {
 
         send(scheme, method);
     }
-    
+
     public void send(String scheme, String method) throws IOException {
         getRequest();
         if ("GET".equalsIgnoreCase(method)) {
@@ -192,5 +192,5 @@ public class SpdyStream {
         }
         spdy.sendFrameBlocking(reqFrame, this);
     }
-    
+
 }
\ No newline at end of file

==================================================
