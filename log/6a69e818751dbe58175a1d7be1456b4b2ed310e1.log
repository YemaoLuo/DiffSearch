6a69e818751dbe58175a1d7be1456b4b2ed310e1
==================================================
Fixed bug #49711: HttpServletRequest#getParts() does not work in a Filter
==================================================
Christopher Schultz
==================================================
Fri Jan 21 17:46:03 2011 +0000
==================================================
AbstractCatalinaTask.java
Fixed bug #49711: HttpServletRequest#getParts() does not work in a Filter
- Added <Connector> attribute allowCasualMultipartParsing (default false)
- Requests that contain multipart/form-data will be parsed in the absence of @MultipartConfig when the above attribute is set to "true"



git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1061929 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Connector.java
index c248d42e65..b89ee6ed53 100644
--- a/java/org/apache/catalina/ant/AbstractCatalinaTask.java
+++ b/java/org/apache/catalina/ant/AbstractCatalinaTask.java
@@ -170,6 +170,7 @@ public abstract class AbstractCatalinaTask extends BaseRedirectorHelperTask {
         URLConnection conn = null;
         InputStreamReader reader = null;
         try {
+            openRedirector();
 
             // Create a connection for this command
             conn = (new URL(url + command)).openConnection();

==================================================
Request.java
index f5fb1e5e6c..6f54c66d66 100644
--- a/java/org/apache/catalina/connector/Connector.java
+++ b/java/org/apache/catalina/connector/Connector.java
@@ -246,6 +246,13 @@ public class Connector extends LifecycleMBeanBase  {
       */
      protected boolean useBodyEncodingForURI = false;
 
+
+    /**
+     * Allow multipart/form-data requests to be parsed even when the
+     * target servlet doesn't specify @MultipartConfig or have a
+     * &lt;multipart-config&gt; element.
+     */
+    protected boolean allowCasualMultipartParsing = false;
      
      protected static HashMap<String,String> replacements =
          new HashMap<String,String>();
@@ -767,6 +774,32 @@ public class Connector extends LifecycleMBeanBase  {
 
      }
 
+    /**
+     * Set to <code>true</code> to allow requests mapped to servlets that
+     * do not explicitly declare @MultipartConfig or have
+     * &lt;multipart-config&gt; specified in web.xml to parse
+     * multipart/form-data requests.
+     *
+     * @param allowCasualMultipartParsing <code>true</code> to allow such
+     *        casual parsing, <code>false</code> otherwise.
+     */
+    public void setAllowCasualMultipartParsing(boolean allowCasualMultipartParsing)
+    {
+        this.allowCasualMultipartParsing = allowCasualMultipartParsing;
+    }
+
+    /**
+     * Returns <code>true</code> if requests mapped to servlets without
+     * "multipart config" to parse multipart/form-data requests anyway.
+     *
+     * @return <code>true</code> if requests mapped to servlets without
+     *    "multipart config" to parse multipart/form-data requests,
+     *    <code>false</code> otherwise.
+     */
+    protected boolean getAllowCasualMultipartParsing()
+    {
+        return this.allowCasualMultipartParsing;
+    }
 
     /**
      * Indicates whether the generation of an X-Powered-By response header for

==================================================
AprEndpoint.java
index a3302b7e2d..f656078789 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -2537,7 +2537,7 @@ public class Request
         
         return parts;
     }
-    
+
     private void parseParts() {
 
         // Return immediately if the parts have already been parsed
@@ -2545,13 +2545,22 @@ public class Request
             return;
 
         MultipartConfigElement mce = getWrapper().getMultipartConfigElement();
+
         if (mce == null) {
-            parts = Collections.emptyList();
-            return;
+            Connector connector = getConnector();
+            if(connector.getAllowCasualMultipartParsing()) {
+                mce = new MultipartConfigElement(null,
+                                                 connector.getMaxPostSize(),
+                                                 connector.getMaxPostSize(),
+                                                 connector.getMaxPostSize());
+            } else {
+                parts = Collections.emptyList();
+                return;
+            }
         }
         
         Parameters parameters = coyoteRequest.getParameters();
-        
+
         File location;
         String locationStr = mce.getLocation();
         if (locationStr == null || locationStr.length() == 0) {
@@ -2582,7 +2591,7 @@ public class Request
         upload.setFileItemFactory(factory);
         upload.setFileSizeMax(mce.getMaxFileSize());
         upload.setSizeMax(mce.getMaxRequestSize());
-        
+
         parts = new ArrayList<Part>();
         try {
             List<FileItem> items = upload.parseRequest(this);
@@ -2604,11 +2613,12 @@ public class Request
                                             Parameters.DEFAULT_ENCODING)});
                         } catch (UnsupportedEncodingException e) {
                             // Should not be possible
+                            e.printStackTrace();
                         }
                     }
                 }
             }
-            
+
         } catch (InvalidContentTypeException e) {
             partsParseException = new ServletException(e);
         } catch (FileUploadBase.SizeException e) {

==================================================
TestRequest.java
index dcb912eec5..c89d7512ae 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -242,6 +242,9 @@ public class AprEndpoint extends AbstractEndpoint {
     public String getSSLCipherSuite() { return SSLCipherSuite; }
     public void setSSLCipherSuite(String SSLCipherSuite) { this.SSLCipherSuite = SSLCipherSuite; }
 
+    protected boolean SSLFIPSMode = false;
+    public boolean getSSLFIPSMode() { return SSLFIPSMode; }
+    public void setSSLFIPSMode(boolean SSLFIPSMode) { this.SSLFIPSMode = SSLFIPSMode; }
 
     /**
      * SSL certificate file.

==================================================
