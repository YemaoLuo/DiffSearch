ed82d448c7208fcaf599010d409159ef7ff7f5be
==================================================
First revision of an example non blocking read operation.
==================================================
Filip Hanik
==================================================
Wed Jul 4 01:56:46 2012 +0000
==================================================
ServletInputStream.java
First revision of an example non blocking read operation.
The servlet specification, and discussions on the expert group are quite contradictory.
According to the specification request response object can only live during service() or 
when an AsyncContext is present. but the NIO api is written with examples of bypassing both.

So for this iteration, we are working with the assumption that 
NIO is only allowed during async operations, otherwise there is no point to NIO.
This is because 'polling' was not allowed, so there is no point to have NIO when the thread is present



git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1357039 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ServletOutputStream.java
index cead0f6da7..f2752f5c0d 100644
--- a/java/javax/servlet/ServletInputStream.java
+++ b/java/javax/servlet/ServletInputStream.java
@@ -94,8 +94,11 @@ public abstract class ServletInputStream extends InputStream {
      * @return
      */
     public abstract boolean isFinished();
+
     /**
      * TODO SERVLET 3.1
+     * If this returns false, the container will invoke
+     * {@link ReadListener#onDataAvailable()} when data is available.
      * @return
      */
     public abstract boolean isReady();

==================================================
CoyoteAdapter.java
index f80234ab91..9488e9c955 100644
--- a/java/javax/servlet/ServletOutputStream.java
+++ b/java/javax/servlet/ServletOutputStream.java
@@ -273,6 +273,8 @@ public abstract class ServletOutputStream extends OutputStream {
     }
 
     /**
+     * If this returns false, it will cause a callback to
+     * {@link WriteListener#onWritePossible()} when the buffer has emptied
      * TODO SERVLET 3.1
      * @return
      */

==================================================
CoyoteInputStream.java
index b01f74c8e2..9c17032c8d 100644
--- a/java/org/apache/catalina/connector/CoyoteAdapter.java
+++ b/java/org/apache/catalina/connector/CoyoteAdapter.java
@@ -20,6 +20,7 @@ import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.nio.charset.Charset;
 import java.util.EnumSet;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import javax.servlet.RequestDispatcher;
 import javax.servlet.SessionTrackingMode;
@@ -293,6 +294,22 @@ public class CoyoteAdapter implements Adapter {
                     asyncConImpl.setErrorState(null);
                 }
             }
+
+
+            if (!request.isAsyncDispatching() && request.isAsync()) {
+                AtomicBoolean result = new AtomicBoolean(true);
+                req.action(ActionCode.ASYNC_DISPATCH_FOR_OPERATION, this);
+                if (result.get()) {
+                    if (status==SocketStatus.OPEN_WRITE) {
+                        //TODO Notify write listener
+                    } else if (status==SocketStatus.OPEN) {
+                        //TODO Notify read listener
+                        asyncConImpl.canRead();
+                    }
+                    success = true;
+                }
+            }
+
             if (request.isAsyncDispatching()) {
                 success = true;
                 connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);

==================================================
InputBuffer.java
index 6bd7d3b90c..e874d873bb 100644
--- a/java/org/apache/catalina/connector/CoyoteInputStream.java
+++ b/java/org/apache/catalina/connector/CoyoteInputStream.java
@@ -242,25 +242,20 @@ public class CoyoteInputStream
         }
     }
 
-    /**
-     * TODO SERVLET 3.1
-     */
     @Override
     public boolean isFinished() {
-        // TODO Auto-generated method stub
-        return false;
+        return ib.isFinished();
     }
 
     @Override
     public int dataAvailable() {
-        // TODO Auto-generated method stub
-        return 0;
+        return ib.dataAvailable();
     }
 
 
     @Override
     public boolean isReady() {
-        return dataAvailable()>0;
+        return ib.isReady();
     }
 
 
@@ -269,10 +264,8 @@ public class CoyoteInputStream
      */
     @Override
     public void setReadListener(ReadListener listener) {
-        // TODO Auto-generated method stub
-
+        ib.setReadListener(listener);
     }
 
 
-
 }

==================================================
AsyncContextImpl.java
index a1e511204e..99c6be2396 100644
--- a/java/org/apache/catalina/connector/InputBuffer.java
+++ b/java/org/apache/catalina/connector/InputBuffer.java
@@ -23,6 +23,8 @@ import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
 import java.util.HashMap;
 
+import javax.servlet.ReadListener;
+
 import org.apache.catalina.security.SecurityUtil;
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.Request;
@@ -247,6 +249,51 @@ public class InputBuffer extends Reader
         return available;
     }
 
+    private volatile ReadListener listener;
+    public void setReadListener(ReadListener listener) {
+        this.listener = listener;
+        coyoteRequest.action(ActionCode.SET_READ_LISTENER, listener);
+    }
+
+    public ReadListener getReadListener() {
+        return listener;
+    }
+
+    public boolean isFinished() {
+        return dataAvailable()==0;
+    }
+
+    public int dataAvailable() {
+        if (getReadListener()==null) throw new IllegalStateException("not in non blocking mode.");
+        int result = 0;
+        //first check if we have buffered something already
+        result = available();
+
+        if(result <= 0) {
+            //here we can issue a non blocking read
+            //if supported
+            //TODO SERVLET 3.1
+        }
+
+        return result;
+
+    }
+
+
+    public boolean isReady() {
+        if (getReadListener()==null) throw new IllegalStateException("not in non blocking mode.");
+        int available = dataAvailable();
+        boolean result = available>0;
+        if (!result) {
+            coyoteRequest.action(ActionCode.NB_READ_INTEREST, null);
+        }
+        return result;
+    }
+
+
+
+
+
 
     // ------------------------------------------------- Bytes Handling Methods
 
@@ -441,7 +488,9 @@ public class InputBuffer extends Reader
         if (closed) {
             throw new IOException(sm.getString("inputBuffer.streamClosed"));
         }
-
+        if (state == INITIAL_STATE) {
+            state = CHAR_STATE;
+        }
         return (available() > 0);
     }
 

==================================================
ActionCode.java
index 4e0eb9c508..bce96546b7 100644
--- a/java/org/apache/catalina/core/AsyncContextImpl.java
+++ b/java/org/apache/catalina/core/AsyncContextImpl.java
@@ -105,6 +105,25 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
         }
     }
 
+    public boolean canRead() throws IOException {
+        ClassLoader oldCL = Thread.currentThread().getContextClassLoader();
+        ClassLoader newCL = request.getContext().getLoader().getClassLoader();
+        try {
+            Thread.currentThread().setContextClassLoader(newCL);
+            request.getCoyoteRequest().getReadListener().onDataAvailable();
+            if (request.getInputStream().dataAvailable()==0) {
+                request.getCoyoteRequest().getReadListener().onAllDataRead();
+            }
+        }finally {
+            Thread.currentThread().setContextClassLoader(oldCL);
+        }
+        return true;
+    }
+
+    public boolean canWrite() throws IOException {
+        return false;
+    }
+
     public boolean timeout() throws IOException {
         AtomicBoolean result = new AtomicBoolean();
         request.getCoyoteRequest().action(ActionCode.ASYNC_TIMEOUT, result);

==================================================
AsyncStateMachine.java
index 550ec16ee4..ad784c4fcf 100644
--- a/java/org/apache/coyote/ActionCode.java
+++ b/java/org/apache/coyote/ActionCode.java
@@ -136,6 +136,13 @@ public enum ActionCode {
      */
     ASYNC_DISPATCH,
 
+    /**
+     * Callback when an async call is
+     * {@link javax.servlet.ReadListener#onDataAvailable()} or
+     * {@link javax.servlet.WriteListener#onWritePossible()}
+     */
+    ASYNC_DISPATCH_FOR_OPERATION,
+
     /**
      * Callback to indicate the the actual dispatch has started and that the
      * async state needs change.
@@ -193,5 +200,27 @@ public enum ActionCode {
     /**
      * Callback to trigger the HTTP upgrade process.
      */
-    UPGRADE
+    UPGRADE,
+
+    /**
+     * Callback to trigger setting the ReadListener
+     */
+    SET_READ_LISTENER,
+
+    /**
+     * Callback to trigger setting the WriteListener
+     */
+    SET_WRITE_LISTENER,
+
+    /**
+     * Indicator that Servlet is interested in being
+     * notified when data is available to be read
+     */
+    NB_READ_INTEREST,
+
+    /**
+     *Indicator that the Servlet is interested
+     *in being notified when it can write data
+     */
+    NB_WRITE_INTEREST
 }

==================================================
Request.java
index 520326c340..916865df30 100644
--- a/java/org/apache/coyote/AsyncStateMachine.java
+++ b/java/org/apache/coyote/AsyncStateMachine.java
@@ -69,18 +69,18 @@ import org.apache.tomcat.util.res.StringManager;
  * |       |          |               |                       |               |
  * |       |          |              \|/                     \|/   complete() |
  * |       |          |         MUST_DISPATCH              STARTED---->-------|
- * |       |          |           |                         |   |
- * |       |          |           |postProcess()            |   |
- * ^       ^          |           |              dispatch() |   |auto
- * |       |          |           |    |--------------------|   |
- * |       |          | auto     \|/  \|/                      \|/
- * |       |          |---<----DISPATCHING<-----------------TIMING_OUT
- * |       |                                  dispatch()      |   |
- * |       |                                                  |   |
- * |       |-------<-------------------------------------<----|   |
- * |                              complete()                      |
- * |                                                              |
- * |----<------------------------<-----------------------------<--|
+ * |       |          |           |                         |   |  \ \
+ * |       |          |           |postProcess()            |   |   \ \
+ * ^       ^          |           |              dispatch() |   |auto\ \
+ * |       |          |           |    |--------------------|   |     \ \----<------
+ * |       |          | auto     \|/  \|/                      \|/     \            \
+ * |       |          |---<----DISPATCHING<-----------------TIMING_OUT  \            \
+ * |       |                                  dispatch()      |   |      |            \
+ * |       |                                                  |   |     \|/            |
+ * |       |-------<-------------------------------------<----|   |   READ_WRITE_OP ->-
+ * |                              complete()              \-------|------|
+ * |                                                              |      |
+ * |----<------------------------<-----------------------------<--|------|
  *                                 error()
  * </pre>
  */
@@ -101,6 +101,7 @@ public class AsyncStateMachine<S> {
         TIMING_OUT(true, false, false),
         MUST_DISPATCH(true, false, true),
         DISPATCHING(true, false, true),
+        READ_WRITE_OP(true,true,false),
         ERROR(true,false,false);
 
         private boolean isAsync;
@@ -167,6 +168,16 @@ public class AsyncStateMachine<S> {
         }
     }
 
+    public synchronized void asyncOperation() {
+        if (state==AsyncState.STARTED) {
+            state = AsyncState.READ_WRITE_OP;
+        } else {
+            throw new IllegalStateException(
+                    sm.getString("asyncStateMachine.invalidAsyncState",
+                            "asyncOperation()", state));
+        }
+    }
+
     /*
      * Async has been processed. Whether or not to enter a long poll depends on
      * current state. For example, as per SRV.2.3.3.3 can now process calls to
@@ -174,7 +185,7 @@ public class AsyncStateMachine<S> {
      */
     public synchronized SocketState asyncPostProcess() {
 
-        if (state == AsyncState.STARTING) {
+        if (state == AsyncState.STARTING || state == AsyncState.READ_WRITE_OP) {
             state = AsyncState.STARTED;
             return SocketState.LONG;
         } else if (state == AsyncState.MUST_COMPLETE) {
@@ -217,6 +228,8 @@ public class AsyncStateMachine<S> {
         } else if (state == AsyncState.TIMING_OUT ||
                 state == AsyncState.ERROR) {
             state = AsyncState.MUST_COMPLETE;
+        } else if (state == AsyncState.READ_WRITE_OP) {
+            state = AsyncState.MUST_COMPLETE;
         } else {
             throw new IllegalStateException(
                     sm.getString("asyncStateMachine.invalidAsyncState",

==================================================
AbstractInputBuffer.java
index b2b2a6bbc9..35d4516875 100644
--- a/java/org/apache/coyote/Request.java
+++ b/java/org/apache/coyote/Request.java
@@ -20,6 +20,9 @@ package org.apache.coyote;
 import java.io.IOException;
 import java.util.HashMap;
 
+import javax.servlet.ReadListener;
+
+import org.apache.coyote.http11.AbstractInputBuffer;
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.buf.UDecoder;
@@ -136,6 +139,34 @@ public final class Request {
     private int available = 0;
 
     private final RequestInfo reqProcessorMX=new RequestInfo(this);
+
+
+    // ------------------------------------------------------------- TODO SERVLET 3.1 IN PROGRESS
+
+    protected volatile ReadListener listener;
+
+    public ReadListener getReadListener() {
+        return listener;
+    }
+
+    public void setReadListener(ReadListener listener) {
+        //TODO SERVLET 3.1 is it allowed to switch from non block to blocking?
+        setBlocking(listener==null);
+        this.listener = listener;
+    }
+
+    protected volatile boolean blocking = true;
+
+    public boolean isBlocking() {
+        return blocking;
+    }
+
+    public void setBlocking(boolean blocking) throws IllegalStateException {
+        @SuppressWarnings("rawtypes")
+        AbstractInputBuffer buf = (AbstractInputBuffer)inputBuffer;
+        if (!blocking && !buf.supportsNonBlocking()) throw new IllegalStateException();
+        this.blocking = blocking;
+    }
     // ------------------------------------------------------------- Properties
 
 
@@ -505,6 +536,9 @@ public final class Request {
         remoteUser.recycle();
         authType.recycle();
         attributes.clear();
+
+        blocking = true;
+        listener = null;
     }
 
     // -------------------- Info  --------------------

==================================================
Http11NioProcessor.java
index 0b83aab94a..aa0b13d829 100644
--- a/java/org/apache/coyote/http11/AbstractInputBuffer.java
+++ b/java/org/apache/coyote/http11/AbstractInputBuffer.java
@@ -162,6 +162,9 @@ public abstract class AbstractInputBuffer<S> implements InputBuffer{
     protected int lastActiveFilter;
 
 
+    // ------------------------------------------------------------- TODO SERVLET 3.1 IN PROGRESS
+    public abstract boolean supportsNonBlocking();
+
     // ------------------------------------------------------------- Properties
 
 

==================================================
InternalAprInputBuffer.java
index 2f83180be6..71e2533b1f 100644
--- a/java/org/apache/coyote/http11/Http11NioProcessor.java
+++ b/java/org/apache/coyote/http11/Http11NioProcessor.java
@@ -22,6 +22,7 @@ import java.net.InetAddress;
 import java.nio.channels.SelectionKey;
 
 import javax.net.ssl.SSLEngine;
+import javax.servlet.ReadListener;
 
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.RequestInfo;
@@ -101,6 +102,19 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
      */
     protected SocketWrapper<NioChannel> socket = null;
 
+    /**
+     * TODO SERVLET 3.1
+     */
+    protected ReadListener readListener;
+
+    public ReadListener getReadListener() {
+        return readListener;
+    }
+
+    public void setReadListener(ReadListener listener) {
+        readListener = listener;
+    }
+
 
     // --------------------------------------------------------- Public Methods
 
@@ -497,6 +511,21 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
                 ((NioEndpoint)endpoint).processSocket(this.socket.getSocket(),
                         SocketStatus.OPEN, true);
             }
+        } else if (actionCode == ActionCode.ASYNC_DISPATCH_FOR_OPERATION) {
+            asyncStateMachine.asyncOperation();
+        } else if (actionCode == ActionCode.SET_READ_LISTENER) {
+            ReadListener listener = (ReadListener)param;
+            request.setReadListener(listener);
+        } else if (actionCode == ActionCode.NB_READ_INTEREST) {
+            if (socket==null || socket.getSocket().getAttachment(false)==null) {
+                return;
+            }
+            RequestInfo rp = request.getRequestProcessor();
+            if (rp.getStage() == org.apache.coyote.Constants.STAGE_SERVICE) {
+                NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socket.getSocket().getAttachment(false);
+                attach.interestOps(attach.interestOps() | SelectionKey.OP_READ);
+            }
+
         }
     }
 

==================================================
InternalInputBuffer.java
index 5406057358..1bc8e01955 100644
--- a/java/org/apache/coyote/http11/InternalAprInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalAprInputBuffer.java
@@ -91,6 +91,8 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
 
     // --------------------------------------------------------- Public Methods
 
+
+
     /**
      * Recycle the input buffer. This should be called when closing the
      * connection.
@@ -102,6 +104,13 @@ public class InternalAprInputBuffer extends AbstractInputBuffer<Long> {
     }
 
 
+    @Override
+    public boolean supportsNonBlocking() {
+        //TODO SERVLET 3.1
+        return false;
+    }
+
+
     /**
      * Read the request line. This function is meant to be used during the
      * HTTP request header parsing. Do NOT attempt to read the request body

==================================================
InternalNioInputBuffer.java
index d8152b7432..aa47182a64 100644
--- a/java/org/apache/coyote/http11/InternalInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalInputBuffer.java
@@ -442,6 +442,12 @@ public class InternalInputBuffer extends AbstractInputBuffer<Socket> {
 
     }
 
+    @Override
+    public boolean supportsNonBlocking() {
+        //TODO SERVLET 3.1
+        return false;
+    }
+
 
     @Override
     public void recycle() {

==================================================
NioEndpoint.java
index 7b7d5af2b4..640e177f18 100644
--- a/java/org/apache/coyote/http11/InternalNioInputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalNioInputBuffer.java
@@ -169,6 +169,49 @@ public class InternalNioInputBuffer extends AbstractInputBuffer<NioChannel> {
 
     // --------------------------------------------------------- Public Methods
 
+
+    @Override
+    public boolean supportsNonBlocking() {
+        return true;
+    }
+
+
+    @Override
+    public int available() {
+
+        int available = super.available();
+        if (available>0) {
+            return available;
+        }
+
+        available = Math.max(lastValid - pos, 0);
+        if (available>0) {
+            return available;
+        }
+        try {
+            available = nbRead();
+        }catch (IOException x) {
+            //TODO SERVLET 3.1 -
+            //we should not swallow this exception
+
+            if (log.isDebugEnabled()) {
+                log.debug("Unable to issue non blocking read.", x);
+            }
+        }
+        return available;
+    }
+
+    /**
+     * Issues a non blocking read
+     * @return int - nr of bytes read
+     * @throws IOException
+     */
+    public int nbRead() throws IOException {
+        return readSocket(true,false);
+    }
+
+
+
     /**
      * Recycle the input buffer. This should be called when closing the
      * connection.

==================================================
SocketStatus.java
index 78ed95a8d8..fd5fb29f6d 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -1244,7 +1244,7 @@ public class NioEndpoint extends AbstractEndpoint {
                                         processSocket(channel, SocketStatus.DISCONNECT, true);
                                 } else {
                                     //future placement of a WRITE notif
-                                    if (!processSocket(channel, SocketStatus.OPEN, true))
+                                    if (!processSocket(channel, SocketStatus.OPEN_WRITE, true))
                                         processSocket(channel, SocketStatus.DISCONNECT, true);
                                 }
                             } else {
@@ -1253,8 +1253,23 @@ public class NioEndpoint extends AbstractEndpoint {
                         } else {
                             //later on, improve latch behavior
                             if ( isWorkerAvailable() ) {
-                                unreg(sk, attachment,sk.readyOps());
-                                boolean close = (!processSocket(channel, null, true));
+
+                                boolean readAndWrite = sk.isReadable() && sk.isWritable();
+                                reg(sk, attachment, 0);
+                                if (readAndWrite) {
+                                    //remember the that we want to know about write too
+                                    attachment.interestOps(SelectionKey.OP_WRITE);
+                                }
+                                //read goes before write
+                                if (sk.isReadable()) {
+                                    //read notification
+                                    if (!processSocket(channel, SocketStatus.OPEN, true))
+                                        close = true;
+                                } else {
+                                    //future placement of a WRITE notif
+                                    if (!processSocket(channel, SocketStatus.OPEN_WRITE, true))
+                                        close = true;
+                                }
                                 if (close) {
                                     cancelledKey(sk,SocketStatus.DISCONNECT);
                                 }
@@ -1652,11 +1667,10 @@ public class NioEndpoint extends AbstractEndpoint {
                                     (KeyAttachment) key.attachment(),
                                     status);
                         }
-
+                        KeyAttachment ka = (KeyAttachment)key.attachment();
                         if (state == SocketState.CLOSED) {
                             // Close socket and pool
                             try {
-                                KeyAttachment ka = (KeyAttachment) key.attachment();
                                 if (ka!=null) ka.setComet(false);
                                 socket.getPoller().cancelledKey(key, SocketStatus.ERROR);
                                 nioChannels.offer(socket);
@@ -1666,6 +1680,9 @@ public class NioEndpoint extends AbstractEndpoint {
                             }catch ( Exception x ) {
                                 log.error("",x);
                             }
+                        } else if (state == SocketState.LONG && ka != null && ka.isAsync() && ka.interestOps() > 0) {
+                            //we are async, and we are interested in operations
+                            ka.getPoller().add(socket, ka.interestOps());
                         }
                     } else if (handshake == -1 ) {
                         KeyAttachment ka = null;

==================================================
TestNonBlockingAPI.java
index bf53c2bd08..cec3adf2b2 100644
--- a/java/org/apache/tomcat/util/net/SocketStatus.java
+++ b/java/org/apache/tomcat/util/net/SocketStatus.java
@@ -23,5 +23,5 @@ package org.apache.tomcat.util.net;
  * @author remm
  */
 public enum SocketStatus {
-    OPEN, STOP, TIMEOUT, DISCONNECT, ERROR
+    OPEN, OPEN_WRITE, STOP, TIMEOUT, DISCONNECT, ERROR
 }

==================================================
