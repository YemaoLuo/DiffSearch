1b87e8ce916b20e7ffd3e16a55166893b2fc39f4
==================================================
Not used any more ( were part of the mini-servlet on top of coyote )
==================================================
Costin Manolache
==================================================
Tue Jan 5 21:28:53 2010 +0000
==================================================
UriNormalizer.java
Not used any more ( were part of the mini-servlet on top of coyote )



git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@896228 13f79535-47bb-0310-9956-ffa450edef68



==================================================
HttpRequest.java
deleted file mode 100644
index 7e83978861..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/util/buf/UriNormalizer.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/*  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.util.buf;
-
-import java.io.IOException;
-
-/**
- * 
- */
-public class UriNormalizer {
-
-    
-    public static void decodeRequest(MessageBytes decodedURI, 
-                                     MessageBytes requestURI,
-                                     UDecoder urlDecoder) throws IOException {
-      decodedURI.duplicate(requestURI);
-
-      if (decodedURI.getType() == MessageBytes.T_BYTES) {
-          // %xx decoding of the URL
-          urlDecoder.convert(decodedURI, false);
-          // Normalization
-          if (!normalize(decodedURI)) {
-              throw new IOException("Error normalizing");
-          }
-          // Character decoding
-          //convertURI(decodedURI, request);
-      } else {
-          // The URL is chars or String, and has been sent using an in-memory
-          // protocol handler, we have to assume the URL has been properly
-          // decoded already
-          decodedURI.toChars();
-      }
-    }
-
-    /**
-     * Normalize URI.
-     * <p>
-     * This method normalizes "\", "//", "/./" and "/../". This method will
-     * return false when trying to go above the root, or if the URI contains
-     * a null byte.
-     * 
-     * @param uriMB URI to be normalized
-     */
-    public static boolean normalize(MessageBytes uriMB) {
-
-        ByteChunk uriBC = uriMB.getByteChunk();
-        byte[] b = uriBC.getBytes();
-        int start = uriBC.getStart();
-        int end = uriBC.getEnd();
-
-        // URL * is acceptable
-        if ((end - start == 1) && b[start] == (byte) '*')
-          return true;
-
-        int pos = 0;
-        int index = 0;
-
-        // Replace '\' with '/'
-        // Check for null byte
-        for (pos = start; pos < end; pos++) {
-            if (b[pos] == (byte) '\\')
-                b[pos] = (byte) '/';
-            if (b[pos] == (byte) 0)
-                return false;
-        }
-
-        // The URL must start with '/'
-        if (b[start] != (byte) '/') {
-            return false;
-        }
-
-        // Replace "//" with "/"
-        for (pos = start; pos < (end - 1); pos++) {
-            if (b[pos] == (byte) '/') {
-                while ((pos + 1 < end) && (b[pos + 1] == (byte) '/')) {
-                    copyBytes(b, pos, pos + 1, end - pos - 1);
-                    end--;
-                }
-            }
-        }
-
-        // If the URI ends with "/." or "/..", then we append an extra "/"
-        // Note: It is possible to extend the URI by 1 without any side effect
-        // as the next character is a non-significant WS.
-        if (((end - start) >= 2) && (b[end - 1] == (byte) '.')) {
-            if ((b[end - 2] == (byte) '/') 
-                || ((b[end - 2] == (byte) '.') 
-                    && (b[end - 3] == (byte) '/'))) {
-                b[end] = (byte) '/';
-                end++;
-            }
-        }
-
-        uriBC.setEnd(end);
-
-        index = 0;
-
-        // Resolve occurrences of "/./" in the normalized path
-        while (true) {
-            index = uriBC.indexOf("/./", 0, 3, index);
-            if (index < 0)
-                break;
-            copyBytes(b, start + index, start + index + 2, 
-                      end - start - index - 2);
-            end = end - 2;
-            uriBC.setEnd(end);
-        }
-
-        index = 0;
-
-        // Resolve occurrences of "/../" in the normalized path
-        while (true) {
-            index = uriBC.indexOf("/../", 0, 4, index);
-            if (index < 0)
-                break;
-            // Prevent from going outside our context
-            if (index == 0)
-                return false;
-            int index2 = -1;
-            for (pos = start + index - 1; (pos >= 0) && (index2 < 0); pos --) {
-                if (b[pos] == (byte) '/') {
-                    index2 = pos;
-                }
-            }
-            copyBytes(b, start + index2, start + index + 3,
-                      end - start - index - 3);
-            end = end + index2 - index - 3;
-            uriBC.setEnd(end);
-            index = index2;
-        }
-
-        //uriBC.setBytes(b, start, end);
-        uriBC.setEnd(end);
-        return true;
-
-    }
-    
-    /**
-     * Copy an array of bytes to a different position. Used during 
-     * normalization.
-     */
-    public static void copyBytes(byte[] b, int dest, int src, int len) {
-        for (int pos = 0; pos < len; pos++) {
-            b[pos + dest] = b[pos + src];
-        }
-    }
-
-}
\ No newline at end of file

==================================================
HttpResponse.java
deleted file mode 100644
index 3e1c81ce60..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/util/http/HttpRequest.java
+++ /dev/null
@@ -1,306 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.http;
-
-import org.apache.tomcat.util.buf.MessageBytes;
-import org.apache.tomcat.util.buf.UDecoder;
-
-/**
- * Simple request representation, public fields - no I/O or actions,
- * just a struct.
- * 
- * Based on Coyote request.
- * 
- * @author Costin Manolache
- */
-public class HttpRequest {
-    
-    // Same fields as in coyote - this is the primary info from request
-    
-    protected MessageBytes schemeMB;
-    
-    protected MessageBytes methodMB;
-    protected MessageBytes unparsedURIMB;
-    protected MessageBytes protoMB;
-    protected MimeHeaders headers;
-    
-    // Reference to 'real' request object
-    public Object nativeRequest;
-    public Object wrapperRequest;
-
-    protected MessageBytes remoteAddrMB;
-    protected MessageBytes remoteHostMB;
-    protected int remotePort;
-
-    protected MessageBytes localNameMB;
-    protected MessageBytes localAddrMB;
-    protected int localPort;
-
-    protected MessageBytes serverNameMB;
-    protected int serverPort = -1;
-    
-    public HttpRequest() {
-        schemeMB = 
-            MessageBytes.newInstance();
-        methodMB = MessageBytes.newInstance();
-        unparsedURIMB = MessageBytes.newInstance();
-        decodedUriMB = MessageBytes.newInstance();
-        requestURI = MessageBytes.newInstance();
-        protoMB = MessageBytes.newInstance();
-        headers = new MimeHeaders();
-        queryMB = MessageBytes.newInstance();
-        serverNameMB = MessageBytes.newInstance();
-        
-        parameters = new Parameters();
-        parameters.setQuery(queryMB);
-        parameters.setURLDecoder(urlDecoder);
-        //parameters.setHeaders(headers);
-        cookies = new Cookies(headers);
-        
-        initRemote();
-    }
-    
-    private void initRemote() {
-        remoteAddrMB = MessageBytes.newInstance();
-        localNameMB = MessageBytes.newInstance();
-        remoteHostMB = MessageBytes.newInstance();
-        localAddrMB = MessageBytes.newInstance();
-    }
-    
-    
-    public HttpRequest(MessageBytes scheme, MessageBytes method,
-            MessageBytes unparsedURI, MessageBytes protocol,
-            MimeHeaders mimeHeaders,
-            MessageBytes requestURI, 
-            MessageBytes decodedURI, 
-            MessageBytes query, Parameters params, 
-            MessageBytes serverName,
-            Cookies cookies) {
-        this.schemeMB = scheme;
-        this.methodMB = method;
-        this.unparsedURIMB = unparsedURI;
-        this.protoMB = protocol;
-        this.headers = mimeHeaders;
-        
-        this.requestURI = requestURI;
-        this.decodedUriMB = decodedURI;
-        this.queryMB = query;
-        this.parameters = params;
-        this.serverNameMB = serverName;
-        this.cookies = cookies;
-        initRemote();        
-    }
-
-
-    
-    // ==== Derived fields, computed after request is received ===
-    
-    protected MessageBytes requestURI;
-    protected MessageBytes queryMB;
-    protected MessageBytes decodedUriMB;
-    
-    // -----------------
-    protected Parameters parameters;
-    
-    protected MessageBytes contentTypeMB;
-
-    protected String charEncoding;
-    protected long contentLength = -1;
-
-    protected Cookies cookies;
-
-    // Avoid object creation:
-    protected UDecoder urlDecoder = new UDecoder();
-
-    
-    public void recycle() {
-        schemeMB.recycle();
-        methodMB.setString("GET");
-        unparsedURIMB.recycle();
-        protoMB.setString("HTTP/1.1");
-        headers.recycle();
-        
-        requestURI.recycle();
-        queryMB.recycle();
-        decodedUriMB.recycle();
-        
-        parameters.recycle();
-        contentTypeMB = null;
-        charEncoding = null;
-        contentLength = -1;
-        remoteAddrMB.recycle();
-        remoteHostMB.recycle();
-        cookies.recycle();
-    }
-    
-    public Parameters getParameters() {
-        return parameters;
-    }
-    
-    // For compatibility with coyote
-    public MessageBytes decodedURI() {
-        return decodedUriMB;
-    }
-
-    public MessageBytes requestURI() {
-        return requestURI;
-    }
-
-    public MessageBytes method() {
-        return methodMB;
-    }
-    
-    public String getHeader(String name) {
-        return headers.getHeader(name);
-    }
-
-    public MimeHeaders getMimeHeaders() {
-        return headers;
-    }
-    
-    /**
-     * Get the character encoding used for this request.
-     */
-    public String getCharacterEncoding() {
-
-        if (charEncoding != null)
-            return charEncoding;
-
-        charEncoding = ContentType.getCharsetFromContentType(getContentType());
-        return charEncoding;
-
-    }
-
-
-    public void setCharacterEncoding(String enc) {
-        this.charEncoding = enc;
-    }
-
-
-    public void setContentLength(int len) {
-        this.contentLength = len;
-    }
-
-
-    public int getContentLength() {
-        long length = getContentLengthLong();
-
-        if (length < Integer.MAX_VALUE) {
-            return (int) length;
-        }
-        return -1;
-    }
-
-    public long getContentLengthLong() {
-        if( contentLength > -1 ) return contentLength;
-
-        MessageBytes clB = headers.getUniqueValue("content-length");
-        contentLength = (clB == null || clB.isNull()) ? -1 : clB.getLong();
-
-        return contentLength;
-    }
-
-    public String getContentType() {
-        contentType();
-        if ((contentTypeMB == null) || contentTypeMB.isNull()) 
-            return null;
-        return contentTypeMB.toString();
-    }
-
-
-    public void setContentType(String type) {
-        contentTypeMB.setString(type);
-    }
-
-
-    public MessageBytes contentType() {
-        if (contentTypeMB == null || contentTypeMB.isNull())
-            contentTypeMB = headers.getValue("content-type");
-        return contentTypeMB;
-    }
-
-    public int getServerPort() {
-        return serverPort;
-    }
-    
-    public void setServerPort(int serverPort ) {
-        this.serverPort=serverPort;
-    }
-
-    public MessageBytes remoteAddr() {
-        return remoteAddrMB;
-    }
-
-    public MessageBytes remoteHost() {
-        return remoteHostMB;
-    }
-
-    public MessageBytes localName() {
-        return localNameMB;
-    }    
-
-    public MessageBytes localAddr() {
-        return localAddrMB;
-    }
-    
-    public int getRemotePort(){
-        return remotePort;
-    }
-        
-    public void setRemotePort(int port){
-        this.remotePort = port;
-    }
-    
-    public int getLocalPort(){
-        return localPort;
-    }
-        
-    public void setLocalPort(int port){
-        this.localPort = port;
-    }
-    
-    public MessageBytes queryString() {
-        return queryMB;
-    }
-    
-    public MessageBytes protocol() {
-        return protoMB;
-    }
-    
-    public MessageBytes scheme() {
-        return schemeMB;
-    }
-    
-    public MessageBytes serverName() {
-        return serverNameMB;
-    }
-
-    public MessageBytes unparsedURI() {
-        return unparsedURIMB;
-    }
-
-    public Cookies getCookies() {
-        return cookies;
-    }
-    
-    public UDecoder getURLDecoder() {
-        return urlDecoder;
-    }
-
-}
-

==================================================
MimeMap.java
deleted file mode 100644
index 56932552e9..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/util/http/HttpResponse.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.http;
-
-import org.apache.tomcat.util.buf.MessageBytes;
-
-/**
- * The data fields in a HTTP response and few helper and accessors.
- * No actions - just a struct.
- * 
- * Subset of coyte response.
- * 
- * @author Costin Manolache
- */
-public class HttpResponse {
-    // Primary fields 
-    // in coyote message is String, status is int
-    protected MessageBytes message = MessageBytes.newInstance();
-    protected MessageBytes proto = MessageBytes.newInstance();
-    protected MessageBytes statusBuffer = MessageBytes.newInstance();
-    protected MimeHeaders headers = new MimeHeaders();
-    public Object nativeResponse;
-       
-    boolean commited;
-    
-    public void recycle() {
-        getMimeHeaders().recycle();
-        message.recycle();
-        statusBuffer.setInt(200);
-        commited = false;
-    }
-    
-    public boolean isCommitted() {
-        return commited;
-    }
-
-    public void setCommitted(boolean b) {
-        commited = b;
-    }
-    
-    // Methods named for compat with coyote
-    
-    public void setStatus(int i) {
-        statusBuffer.setInt(i);
-    }
-    
-    public void setMessage(String s) {
-        message.setString(s);
-    }
-    
-    public String getMessage() {
-        return message.toString();
-    }
-    
-    public MessageBytes getMessageBuffer() {
-        return message;
-    }
-    
-    public MessageBytes protocol() {
-        return proto;
-    }
-    
-    public int getStatus() {
-        return statusBuffer.getInt();
-    }
-
-    public MessageBytes getStatusBuffer() {
-        return statusBuffer;
-    }
-    
-
-    public void addHeader(String name, String value) {
-        getMimeHeaders().addValue(name).setString(value);
-    }
-
-    public void setHeader(String name, String value) {
-        getMimeHeaders().setValue(name).setString(value);
-    }
-
-    public void setMimeHeaders(MimeHeaders resHeaders) {
-        this.headers = resHeaders;
-    }
-
-    public MimeHeaders getMimeHeaders() {
-        return headers;
-    }
-    
-    /**
-     * Warning: This method always returns <code>false<code> for Content-Type
-     * and Content-Length.
-     */
-    public boolean containsHeader(String name) {
-        return headers.getHeader(name) != null;
-    }
-
-    public void setContentLength(long length) {
-        MessageBytes clB = getMimeHeaders().getUniqueValue("content-length");
-        if (clB == null) {
-            clB = getMimeHeaders().addValue("content-length");
-        }        
-        clB.setLong(length);
-    }
-    
-    public long getContentLength() {
-        MessageBytes clB = getMimeHeaders().getUniqueValue("content-length");
-        return (clB == null || clB.isNull()) ? -1 : clB.getLong();
-    }
-    
-    public void setContentType(String contentType) {
-        MessageBytes clB = getMimeHeaders().getUniqueValue("content-type");
-        if (clB == null) {
-            setHeader("content-type", contentType);
-        } else {
-            clB.setString(contentType);
-        }
-    }
-    
-}
\ No newline at end of file

==================================================
BaseMapper.java
deleted file mode 100644
index 50a1d6291b..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/util/http/MimeMap.java
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.http;
-
-import java.net.*;
-import java.util.*;
-
-
-/**
- * A mime type map that implements the java.net.FileNameMap interface.
- *
- * @author James Duncan Davidson [duncan@eng.sun.com]
- * @author Jason Hunter [jch@eng.sun.com]
- */
-public class MimeMap implements FileNameMap {
-
-    // Defaults - all of them are "well-known" types,
-    // you can add using normal web.xml.
-    
-    public static final Hashtable<String,String> defaultMap =
-        new Hashtable<String,String>(101);
-    static {
-        defaultMap.put("txt", "text/plain");
-        defaultMap.put("css", "text/css");
-        defaultMap.put("html","text/html");
-        defaultMap.put("htm", "text/html");
-        defaultMap.put("gif", "image/gif");
-        defaultMap.put("jpg", "image/jpeg");
-        defaultMap.put("jpe", "image/jpeg");
-        defaultMap.put("jpeg", "image/jpeg");
-        defaultMap.put("png", "image/png");
-                defaultMap.put("java", "text/plain");
-        defaultMap.put("body", "text/html");
-        defaultMap.put("rtx", "text/richtext");
-        defaultMap.put("tsv", "text/tab-separated-values");
-        defaultMap.put("etx", "text/x-setext");
-        defaultMap.put("ps", "application/x-postscript");
-        defaultMap.put("class", "application/java");
-        defaultMap.put("csh", "application/x-csh");
-        defaultMap.put("sh", "application/x-sh");
-        defaultMap.put("tcl", "application/x-tcl");
-        defaultMap.put("tex", "application/x-tex");
-        defaultMap.put("texinfo", "application/x-texinfo");
-        defaultMap.put("texi", "application/x-texinfo");
-        defaultMap.put("t", "application/x-troff");
-        defaultMap.put("tr", "application/x-troff");
-        defaultMap.put("roff", "application/x-troff");
-        defaultMap.put("man", "application/x-troff-man");
-        defaultMap.put("me", "application/x-troff-me");
-        defaultMap.put("ms", "application/x-wais-source");
-        defaultMap.put("src", "application/x-wais-source");
-        defaultMap.put("zip", "application/zip");
-        defaultMap.put("bcpio", "application/x-bcpio");
-        defaultMap.put("cpio", "application/x-cpio");
-        defaultMap.put("gtar", "application/x-gtar");
-        defaultMap.put("shar", "application/x-shar");
-        defaultMap.put("sv4cpio", "application/x-sv4cpio");
-        defaultMap.put("sv4crc", "application/x-sv4crc");
-        defaultMap.put("tar", "application/x-tar");
-        defaultMap.put("ustar", "application/x-ustar");
-        defaultMap.put("dvi", "application/x-dvi");
-        defaultMap.put("hdf", "application/x-hdf");
-        defaultMap.put("latex", "application/x-latex");
-        defaultMap.put("bin", "application/octet-stream");
-        defaultMap.put("oda", "application/oda");
-        defaultMap.put("pdf", "application/pdf");
-        defaultMap.put("ps", "application/postscript");
-        defaultMap.put("eps", "application/postscript");
-        defaultMap.put("ai", "application/postscript");
-        defaultMap.put("rtf", "application/rtf");
-        defaultMap.put("nc", "application/x-netcdf");
-        defaultMap.put("cdf", "application/x-netcdf");
-        defaultMap.put("cer", "application/x-x509-ca-cert");
-        defaultMap.put("exe", "application/octet-stream");
-        defaultMap.put("gz", "application/x-gzip");
-        defaultMap.put("Z", "application/x-compress");
-        defaultMap.put("z", "application/x-compress");
-        defaultMap.put("hqx", "application/mac-binhex40");
-        defaultMap.put("mif", "application/x-mif");
-        defaultMap.put("ief", "image/ief");
-        defaultMap.put("tiff", "image/tiff");
-        defaultMap.put("tif", "image/tiff");
-        defaultMap.put("ras", "image/x-cmu-raster");
-        defaultMap.put("pnm", "image/x-portable-anymap");
-        defaultMap.put("pbm", "image/x-portable-bitmap");
-        defaultMap.put("pgm", "image/x-portable-graymap");
-        defaultMap.put("ppm", "image/x-portable-pixmap");
-        defaultMap.put("rgb", "image/x-rgb");
-        defaultMap.put("xbm", "image/x-xbitmap");
-        defaultMap.put("xpm", "image/x-xpixmap");
-        defaultMap.put("xwd", "image/x-xwindowdump");
-        defaultMap.put("au", "audio/basic");
-        defaultMap.put("snd", "audio/basic");
-        defaultMap.put("aif", "audio/x-aiff");
-        defaultMap.put("aiff", "audio/x-aiff");
-        defaultMap.put("aifc", "audio/x-aiff");
-        defaultMap.put("wav", "audio/x-wav");
-        defaultMap.put("mpeg", "video/mpeg");
-        defaultMap.put("mpg", "video/mpeg");
-        defaultMap.put("mpe", "video/mpeg");
-        defaultMap.put("qt", "video/quicktime");
-        defaultMap.put("mov", "video/quicktime");
-        defaultMap.put("avi", "video/x-msvideo");
-        defaultMap.put("movie", "video/x-sgi-movie");
-        defaultMap.put("avx", "video/x-rad-screenplay");
-        defaultMap.put("wrl", "x-world/x-vrml");
-        defaultMap.put("mpv2", "video/mpeg2");
-        
-        /* Add XML related MIMEs */
-        
-        defaultMap.put("xml", "text/xml");
-        defaultMap.put("xsl", "text/xml");        
-        defaultMap.put("svg", "image/svg+xml");
-        defaultMap.put("svgz", "image/svg+xml");
-        defaultMap.put("wbmp", "image/vnd.wap.wbmp");
-        defaultMap.put("wml", "text/vnd.wap.wml");
-        defaultMap.put("wmlc", "application/vnd.wap.wmlc");
-        defaultMap.put("wmls", "text/vnd.wap.wmlscript");
-        defaultMap.put("wmlscriptc", "application/vnd.wap.wmlscriptc");
-    }
-    
-
-    private Hashtable<String,String> map = new Hashtable<String,String>();
-
-    public void addContentType(String extn, String type) {
-        map.put(extn, type.toLowerCase());
-    }
-
-    public Enumeration getExtensions() {
-        return map.keys();
-    }
-
-    public String getMimeType(String ext) {
-        return getContentTypeFor(ext);
-    }
-    
-    public String getContentType(String extn) {
-        String type = (String)map.get(extn.toLowerCase());
-        if( type == null ) type=(String)defaultMap.get( extn );
-        return type;
-    }
-
-    public void removeContentType(String extn) {
-        map.remove(extn.toLowerCase());
-    }
-
-    /** Get extension of file, without fragment id
-     */
-    public static String getExtension( String fileName ) {
-        // play it safe and get rid of any fragment id
-        // that might be there
-        int length=fileName.length();
-        
-        int newEnd = fileName.lastIndexOf('#');
-        if( newEnd== -1 ) newEnd=length;
-        // Instead of creating a new string.
-        //         if (i != -1) {
-        //             fileName = fileName.substring(0, i);
-        //         }
-        int i = fileName.lastIndexOf('.', newEnd );
-        if (i != -1) {
-             return  fileName.substring(i + 1, newEnd );
-        } else {
-            // no extension, no content type
-            return null;
-        }
-    }
-    
-    public String getContentTypeFor(String fileName) {
-        String extn=getExtension( fileName );
-        if (extn!=null) {
-            return getContentType(extn);
-        } else {
-            // no extension, no content type
-            return null;
-        }
-    }
-
-}

==================================================
