e92b5caa819e5f7ade4b64049f1598c95b41e4b2
==================================================
Update to Commons IO 2.4 and run UCDetector over the copied classes
==================================================
Mark Emlyn
==================================================
Fri Mar 15 14:21:24 2013 +0000
==================================================
ByteArrayOutputStream.java
Update to Commons IO 2.4 and run UCDetector over the copied classes

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1456963 13f79535-47bb-0310-9956-ffa450edef68



==================================================
DeferredFileOutputStream.java
index 58ff86429e..391c070f33 100644
--- a/java/org/apache/tomcat/util/http/fileupload/ByteArrayOutputStream.java
+++ b/java/org/apache/tomcat/util/http/fileupload/ByteArrayOutputStream.java
@@ -19,7 +19,6 @@ package org.apache.tomcat.util.http.fileupload;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -35,7 +34,7 @@ import java.util.List;
  * this class can be called after the stream has been closed without
  * generating an <tt>IOException</tt>.
  * <p>
- * This is an alternative implementation of the java.io.ByteArrayOutputStream
+ * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}
  * class. The original implementation only allocates 32 bytes at the beginning.
  * As this class is designed for heavy duty it starts at 1024 bytes. In contrast
  * to the original it doesn't reallocate the whole memory block but allocates
@@ -44,8 +43,6 @@ import java.util.List;
  * designed to behave exactly like the original. The only exception is the
  * deprecated toString(int) method that has been ignored.
  *
- * @author <a href="mailto:jeremias@apache.org">Jeremias Maerki</a>
- * @author Holger Hoffstatte
  * @version $Id$
  */
 public class ByteArrayOutputStream extends OutputStream {
@@ -54,7 +51,7 @@ public class ByteArrayOutputStream extends OutputStream {
     private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
 
     /** The list of buffers, which grows and never reduces. */
-    private List<byte[]> buffers = new ArrayList<>();
+    private final List<byte[]> buffers = new ArrayList<>();
     /** The index of the current buffer. */
     private int currentBufferIndex;
     /** The total count of bytes in all the filled buffers. */
@@ -84,18 +81,9 @@ public class ByteArrayOutputStream extends OutputStream {
             throw new IllegalArgumentException(
                 "Negative initial size: " + size);
         }
-        needNewBuffer(size);
-    }
-
-    /**
-     * Return the appropriate <code>byte[]</code> buffer
-     * specified by index.
-     *
-     * @param index  the index of the buffer required
-     * @return the buffer
-     */
-    private byte[] getBuffer(int index) {
-        return buffers.get(index);
+        synchronized (this) {
+            needNewBuffer(size);
+        }
     }
 
     /**
@@ -110,7 +98,7 @@ public class ByteArrayOutputStream extends OutputStream {
             filledBufferSum += currentBuffer.length;
 
             currentBufferIndex++;
-            currentBuffer = getBuffer(currentBufferIndex);
+            currentBuffer = buffers.get(currentBufferIndex);
         } else {
             //Creating new buffer
             int newBufferSize;
@@ -188,7 +176,7 @@ public class ByteArrayOutputStream extends OutputStream {
      * @return total number of bytes read from the input stream
      *         (and written to this stream)
      * @throws IOException if an I/O error occurs while reading the input stream
-     * @since Commons IO 1.4
+     * @since 1.4
      */
     public synchronized int write(InputStream in) throws IOException {
         int readCount = 0;
@@ -207,14 +195,6 @@ public class ByteArrayOutputStream extends OutputStream {
         return readCount;
     }
 
-    /**
-     * Return the current size of the byte array.
-     * @return the current size of the byte array
-     */
-    public synchronized int size() {
-        return count;
-    }
-
     /**
      * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in
      * this class can be called after the stream has been closed without
@@ -228,16 +208,6 @@ public class ByteArrayOutputStream extends OutputStream {
         //nop
     }
 
-    /**
-     * @see java.io.ByteArrayOutputStream#reset()
-     */
-    public synchronized void reset() {
-        count = 0;
-        filledBufferSum = 0;
-        currentBufferIndex = 0;
-        currentBuffer = getBuffer(currentBufferIndex);
-    }
-
     /**
      * Writes the entire contents of this byte stream to the
      * specified output stream.
@@ -248,8 +218,7 @@ public class ByteArrayOutputStream extends OutputStream {
      */
     public synchronized void writeTo(OutputStream out) throws IOException {
         int remaining = count;
-        for (int i = 0; i < buffers.size(); i++) {
-            byte[] buf = getBuffer(i);
+        for (byte[] buf : buffers) {
             int c = Math.min(buf.length, remaining);
             out.write(buf, 0, c);
             remaining -= c;
@@ -273,8 +242,7 @@ public class ByteArrayOutputStream extends OutputStream {
         }
         byte newbuf[] = new byte[remaining];
         int pos = 0;
-        for (int i = 0; i < buffers.size(); i++) {
-            byte[] buf = getBuffer(i);
+        for (byte[] buf : buffers) {
             int c = Math.min(buf.length, remaining);
             System.arraycopy(buf, 0, newbuf, pos, c);
             pos += c;
@@ -295,18 +263,4 @@ public class ByteArrayOutputStream extends OutputStream {
     public String toString() {
         return new String(toByteArray());
     }
-
-    /**
-     * Gets the curent contents of this byte stream as a string
-     * using the specified encoding.
-     *
-     * @param enc  the name of the character encoding
-     * @return the string converted from the byte array
-     * @throws UnsupportedEncodingException if the encoding is not supported
-     * @see java.io.ByteArrayOutputStream#toString(String)
-     */
-    public String toString(String enc) throws UnsupportedEncodingException {
-        return new String(toByteArray(), enc);
-    }
-
 }

==================================================
FileCleaningTracker.java
index 752d5b11a4..3b7e2d2646 100644
--- a/java/org/apache/tomcat/util/http/fileupload/DeferredFileOutputStream.java
+++ b/java/org/apache/tomcat/util/http/fileupload/DeferredFileOutputStream.java
@@ -17,7 +17,6 @@
 package org.apache.tomcat.util.http.fileupload;
 
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
@@ -34,9 +33,6 @@ import java.io.OutputStream;
  * you want to store it in memory (for speed), but if the file is large you want
  * to store it to file (to avoid memory issues).
  *
- * @author <a href="mailto:martinc@apache.org">Martin Cooper</a>
- * @author gaxzerow
- *
  * @version $Id$
  */
 public class DeferredFileOutputStream
@@ -69,23 +65,17 @@ public class DeferredFileOutputStream
     /**
      * The temporary file prefix.
      */
-    private String prefix;
+    private final String prefix;
 
     /**
      * The temporary file suffix.
      */
-    private String suffix;
+    private final String suffix;
 
     /**
      * The directory to use for temporary files.
      */
-    private File directory;
-
-
-    /**
-     * True when close() has been called successfully.
-     */
-    private boolean closed = false;
+    private final File directory;
 
     // ----------------------------------------------------------- Constructors
 
@@ -99,31 +89,26 @@ public class DeferredFileOutputStream
      */
     public DeferredFileOutputStream(int threshold, File outputFile)
     {
-        super(threshold);
-        this.outputFile = outputFile;
-
-        memoryOutputStream = new ByteArrayOutputStream();
-        currentOutputStream = memoryOutputStream;
+        this(threshold,  outputFile, null, null, null);
     }
 
 
     /**
      * Constructs an instance of this class which will trigger an event at the
-     * specified threshold, and save data to a temporary file beyond that point.
+     * specified threshold, and save data either to a file beyond that point.
      *
      * @param threshold  The number of bytes at which to trigger an event.
+     * @param outputFile The file to which data is saved beyond the threshold.
      * @param prefix Prefix to use for the temporary file.
      * @param suffix Suffix to use for the temporary file.
      * @param directory Temporary file directory.
-     *
-     * @since Commons IO 1.4
      */
-    public DeferredFileOutputStream(int threshold, String prefix, String suffix, File directory)
-    {
-        this(threshold, (File)null);
-        if (prefix == null) {
-            throw new IllegalArgumentException("Temporary file prefix is missing");
-        }
+    private DeferredFileOutputStream(int threshold, File outputFile, String prefix, String suffix, File directory) {
+        super(threshold);
+        this.outputFile = outputFile;
+
+        memoryOutputStream = new ByteArrayOutputStream();
+        currentOutputStream = memoryOutputStream;
         this.prefix = prefix;
         this.suffix = suffix;
         this.directory = directory;
@@ -176,21 +161,21 @@ public class DeferredFileOutputStream
      * Determines whether or not the data for this output stream has been
      * retained in memory.
      *
-     * @return <code>true</code> if the data is available in memory;
-     *         <code>false</code> otherwise.
+     * @return {@code true} if the data is available in memory;
+     *         {@code false} otherwise.
      */
     public boolean isInMemory()
     {
-        return (!isThresholdExceeded());
+        return !isThresholdExceeded();
     }
 
 
     /**
      * Returns the data for this output stream as an array of bytes, assuming
      * that the data has been retained in memory. If the data was written to
-     * disk, this method returns <code>null</code>.
+     * disk, this method returns {@code null}.
      *
-     * @return The data for this output stream, or <code>null</code> if no such
+     * @return The data for this output stream, or {@code null} if no such
      *         data is available.
      */
     public byte[] getData()
@@ -208,13 +193,13 @@ public class DeferredFileOutputStream
      * the temporary file created or null.
      * <p>
      * If the constructor specifying the file is used then it returns that
-     * same output file, even when threashold has not been reached.
+     * same output file, even when threshold has not been reached.
      * <p>
      * If constructor specifying a temporary file prefix/suffix is used
-     * then the temporary file created once the threashold is reached is returned
-     * If the threshold was not reached then <code>null</code> is returned.
+     * then the temporary file created once the threshold is reached is returned
+     * If the threshold was not reached then {@code null} is returned.
      *
-     * @return The file for this output stream, or <code>null</code> if no such
+     * @return The file for this output stream, or {@code null} if no such
      *         file exists.
      */
     public File getFile()
@@ -232,39 +217,5 @@ public class DeferredFileOutputStream
     public void close() throws IOException
     {
         super.close();
-        closed = true;
-    }
-
-
-    /**
-     * Writes the data from this output stream to the specified output stream,
-     * after it has been closed.
-     *
-     * @param out output stream to write to.
-     * @exception IOException if this stream is not yet closed or an error occurs.
-     */
-    public void writeTo(OutputStream out) throws IOException
-    {
-        // we may only need to check if this is closed if we are working with a file
-        // but we should force the habit of closing wether we are working with
-        // a file or memory.
-        if (!closed)
-        {
-            throw new IOException("Stream not closed");
-        }
-
-        if(isInMemory())
-        {
-            memoryOutputStream.writeTo(out);
-        }
-        else
-        {
-            FileInputStream fis = new FileInputStream(outputFile);
-            try {
-                IOUtils.copy(fis, out);
-            } finally {
-                IOUtils.closeQuietly(fis);
-            }
-        }
     }
 }

==================================================
FileDeleteStrategy.java
index 0494b7af53..a1545bfd2b 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileCleaningTracker.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileCleaningTracker.java
@@ -45,23 +45,23 @@ public class FileCleaningTracker {
     /**
      * Queue of <code>Tracker</code> instances being watched.
      */
-    ReferenceQueue<Object> q = new ReferenceQueue<>();
+    private final ReferenceQueue<Object> q = new ReferenceQueue<>();
     /**
      * Collection of <code>Tracker</code> instances in existence.
      */
-    final Collection<Tracker> trackers = Collections.synchronizedSet(new HashSet<Tracker>()); // synchronized
+    private final Collection<Tracker> trackers = Collections.synchronizedSet(new HashSet<Tracker>()); // synchronized
     /**
      * Collection of File paths that failed to delete.
      */
-    final List<String> deleteFailures = Collections.synchronizedList(new ArrayList<String>());
+    private final List<String> deleteFailures = Collections.synchronizedList(new ArrayList<String>());
     /**
      * Whether to terminate the thread when the tracking is complete.
      */
-    volatile boolean exitWhenFinished = false;
+    private volatile boolean exitWhenFinished = false;
     /**
      * The thread that will clean up registered files.
      */
-    Thread reaper;
+    private Thread reaper;
 
     //-----------------------------------------------------------------------
     /**
@@ -94,36 +94,6 @@ public class FileCleaningTracker {
         addTracker(file.getPath(), marker, deleteStrategy);
     }
 
-    /**
-     * Track the specified file, using the provided marker, deleting the file
-     * when the marker instance is garbage collected.
-     * The {@link FileDeleteStrategy#NORMAL normal} deletion strategy will be used.
-     *
-     * @param path  the full path to the file to be tracked, not null
-     * @param marker  the marker object used to track the file, not null
-     * @throws NullPointerException if the path is null
-     */
-    public void track(String path, Object marker) {
-        track(path, marker, (FileDeleteStrategy) null);
-    }
-
-    /**
-     * Track the specified file, using the provided marker, deleting the file
-     * when the marker instance is garbage collected.
-     * The speified deletion strategy is used.
-     *
-     * @param path  the full path to the file to be tracked, not null
-     * @param marker  the marker object used to track the file, not null
-     * @param deleteStrategy  the strategy to delete the file, null means normal
-     * @throws NullPointerException if the path is null
-     */
-    public void track(String path, Object marker, FileDeleteStrategy deleteStrategy) {
-        if (path == null) {
-            throw new NullPointerException("The path must not be null");
-        }
-        addTracker(path, marker, deleteStrategy);
-    }
-
     /**
      * Adds a tracker to the list of trackers.
      *
@@ -143,57 +113,6 @@ public class FileCleaningTracker {
         trackers.add(new Tracker(path, deleteStrategy, marker, q));
     }
 
-    //-----------------------------------------------------------------------
-    /**
-     * Retrieve the number of files currently being tracked, and therefore
-     * awaiting deletion.
-     *
-     * @return the number of files being tracked
-     */
-    public int getTrackCount() {
-        return trackers.size();
-    }
-
-    /**
-     * Return the file paths that failed to delete.
-     *
-     * @return the file paths that failed to delete
-     */
-    public List<String> getDeleteFailures() {
-        return deleteFailures;
-    }
-
-    /**
-     * Call this method to cause the file cleaner thread to terminate when
-     * there are no more objects being tracked for deletion.
-     * <p>
-     * In a simple environment, you don't need this method as the file cleaner
-     * thread will simply exit when the JVM exits. In a more complex environment,
-     * with multiple class loaders (such as an application server), you should be
-     * aware that the file cleaner thread will continue running even if the class
-     * loader it was started from terminates. This can consitute a memory leak.
-     * <p>
-     * For example, suppose that you have developed a web application, which
-     * contains the commons-io jar file in your WEB-INF/lib directory. In other
-     * words, the FileCleaner class is loaded through the class loader of your
-     * web application. If the web application is terminated, but the servlet
-     * container is still running, then the file cleaner thread will still exist,
-     * posing a memory leak.
-     * <p>
-     * This method allows the thread to be terminated. Simply call this method
-     * in the resource cleanup code, such as {@link javax.servlet.ServletContextListener#contextDestroyed}.
-     * Once called, no new objects can be tracked by the file cleaner.
-     */
-    public synchronized void exitWhenFinished() {
-        // synchronized block protects reaper
-        exitWhenFinished = true;
-        if (reaper != null) {
-            synchronized (reaper) {
-                reaper.interrupt();
-            }
-        }
-    }
-
     //-----------------------------------------------------------------------
     /**
      * The reaper thread.

==================================================
FileUtils.java
index dcc71966ae..cbcb6f6b25 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileDeleteStrategy.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileDeleteStrategy.java
@@ -28,9 +28,8 @@ import java.io.IOException;
  * <p>
  * This class captures the strategy to use and is designed for user subclassing.
  *
- * @author Stephen Colebourne
  * @version $Id$
- * @since Commons IO 1.3
+ * @since 1.3
  */
 public class FileDeleteStrategy {
 
@@ -39,11 +38,6 @@ public class FileDeleteStrategy {
      * the deletion of directories that are not empty.
      */
     public static final FileDeleteStrategy NORMAL = new FileDeleteStrategy("Normal");
-    /**
-     * The singleton instance for forced file deletion, which always deletes,
-     * even if the file represents a non-empty directory.
-     */
-    public static final FileDeleteStrategy FORCE = new ForceFileDeleteStrategy();
 
     /** The name of the strategy. */
     private final String name;
@@ -80,22 +74,6 @@ public class FileDeleteStrategy {
         }
     }
 
-    /**
-     * Deletes the file object, which may be a file or a directory.
-     * If the file does not exist, the method just returns.
-     * <p>
-     * Subclass writers should override {@link #doDelete(File)}, not this method.
-     *
-     * @param fileToDelete  the file to delete, not null
-     * @throws NullPointerException if the file is null
-     * @throws IOException if an error occurs during file deletion
-     */
-    public void delete(File fileToDelete) throws IOException {
-        if (fileToDelete.exists() && doDelete(fileToDelete) == false) {
-            throw new IOException("Deletion failed: " + fileToDelete);
-        }
-    }
-
     /**
      * Actually deletes the file object, which may be a file or a directory.
      * <p>
@@ -144,7 +122,7 @@ public class FileDeleteStrategy {
          * if the file exists.
          *
          * @param fileToDelete  the file to delete, not null
-         * @return Always returns <code>true</code>
+         * @return Always returns {@code true}
          * @throws NullPointerException if the file is null
          * @throws IOException if an error occurs during file deletion
          */

==================================================
IOUtils.java
index 0071b88061..76d808f5b4 100644
--- a/java/org/apache/tomcat/util/http/fileupload/FileUtils.java
+++ b/java/org/apache/tomcat/util/http/fileupload/FileUtils.java
@@ -40,20 +40,6 @@ import java.io.IOException;
  * <p>
  * Origin of code: Excalibur, Alexandria, Commons-Utils
  *
- * @author <a href="mailto:burton@relativity.yi.org">Kevin A. Burton</A>
- * @author <a href="mailto:sanders@apache.org">Scott Sanders</a>
- * @author <a href="mailto:dlr@finemaltcoding.com">Daniel Rall</a>
- * @author <a href="mailto:Christoph.Reck@dlr.de">Christoph.Reck</a>
- * @author <a href="mailto:peter@apache.org">Peter Donald</a>
- * @author <a href="mailto:jefft@apache.org">Jeff Turner</a>
- * @author Matthew Hawthorne
- * @author <a href="mailto:jeremias@apache.org">Jeremias Maerki</a>
- * @author Stephen Colebourne
- * @author Ian Springer
- * @author Chris Eldredge
- * @author Jim Harrington
- * @author Niall Pemberton
- * @author Sandy McArthur
  * @version $Id$
  */
 public class FileUtils {
@@ -77,7 +63,10 @@ public class FileUtils {
             return;
         }
 
-        cleanDirectory(directory);
+        if (!isSymlink(directory)) {
+            cleanDirectory(directory);
+        }
+
         if (!directory.delete()) {
             String message =
                 "Unable to delete directory " + directory + ".";
@@ -85,7 +74,6 @@ public class FileUtils {
         }
     }
 
-
     /**
      * Cleans a directory without deleting it.
      *
@@ -109,8 +97,7 @@ public class FileUtils {
         }
 
         IOException exception = null;
-        for (int i = 0; i < files.length; i++) {
-            File file = files[i];
+        for (File file : files) {
             try {
                 forceDelete(file);
             } catch (IOException ioe) {
@@ -123,7 +110,6 @@ public class FileUtils {
         }
     }
 
-
     //-----------------------------------------------------------------------
     /**
      * Deletes a file. If file is a directory, delete it and all sub-directories.
@@ -135,8 +121,8 @@ public class FileUtils {
      *      (java.io.File methods returns a boolean)</li>
      * </ul>
      *
-     * @param file  file or directory to delete, must not be <code>null</code>
-     * @throws NullPointerException if the directory is <code>null</code>
+     * @param file  file or directory to delete, must not be {@code null}
+     * @throws NullPointerException if the directory is {@code null}
      * @throws FileNotFoundException if the file was not found
      * @throws IOException in case deletion is unsuccessful
      */
@@ -160,8 +146,8 @@ public class FileUtils {
      * Schedules a file to be deleted when JVM exits.
      * If file is directory delete it and all sub-directories.
      *
-     * @param file  file or directory to delete, must not be <code>null</code>
-     * @throws NullPointerException if the file is <code>null</code>
+     * @param file  file or directory to delete, must not be {@code null}
+     * @throws NullPointerException if the file is {@code null}
      * @throws IOException in case deletion is unsuccessful
      */
     public static void forceDeleteOnExit(File file) throws IOException {
@@ -175,8 +161,8 @@ public class FileUtils {
     /**
      * Schedules a directory recursively for deletion on JVM exit.
      *
-     * @param directory  directory to delete, must not be <code>null</code>
-     * @throws NullPointerException if the directory is <code>null</code>
+     * @param directory  directory to delete, must not be {@code null}
+     * @throws NullPointerException if the directory is {@code null}
      * @throws IOException in case deletion is unsuccessful
      */
     private static void deleteDirectoryOnExit(File directory) throws IOException {
@@ -184,15 +170,17 @@ public class FileUtils {
             return;
         }
 
-        cleanDirectoryOnExit(directory);
         directory.deleteOnExit();
+        if (!isSymlink(directory)) {
+            cleanDirectoryOnExit(directory);
+        }
     }
 
     /**
      * Cleans a directory without deleting it.
      *
-     * @param directory  directory to clean, must not be <code>null</code>
-     * @throws NullPointerException if the directory is <code>null</code>
+     * @param directory  directory to clean, must not be {@code null}
+     * @throws NullPointerException if the directory is {@code null}
      * @throws IOException in case cleaning is unsuccessful
      */
     private static void cleanDirectoryOnExit(File directory) throws IOException {
@@ -212,8 +200,7 @@ public class FileUtils {
         }
 
         IOException exception = null;
-        for (int i = 0; i < files.length; i++) {
-            File file = files[i];
+        for (File file : files) {
             try {
                 forceDeleteOnExit(file);
             } catch (IOException ioe) {
@@ -225,4 +212,43 @@ public class FileUtils {
             throw exception;
         }
     }
+
+
+    /**
+     * Determines whether the specified file is a Symbolic Link rather than an actual file.
+     * <p>
+     * Will not return true if there is a Symbolic Link anywhere in the path,
+     * only if the specific file is.
+     * <p>
+     * <b>Note:</b> the current implementation always returns {@code false} if
+     * the system is detected as Windows using
+     * {@link File#separatorChar} == '\\'
+     *
+     * @param file the file to check
+     * @return true if the file is a Symbolic Link
+     * @throws IOException if an IO error occurs while checking the file
+     * @since 2.0
+     */
+    public static boolean isSymlink(File file) throws IOException {
+        if (file == null) {
+            throw new NullPointerException("File must not be null");
+        }
+        //FilenameUtils.isSystemWindows()
+        if (File.separatorChar == '\\') {
+            return false;
+        }
+        File fileInCanonicalDir = null;
+        if (file.getParent() == null) {
+            fileInCanonicalDir = file;
+        } else {
+            File canonicalDir = file.getParentFile().getCanonicalFile();
+            fileInCanonicalDir = new File(canonicalDir, file.getName());
+        }
+
+        if (fileInCanonicalDir.getCanonicalFile().equals(fileInCanonicalDir.getAbsoluteFile())) {
+            return false;
+        } else {
+            return true;
+        }
+    }
 }

==================================================
ThresholdingOutputStream.java
index d8eace505d..99530b464e 100644
--- a/java/org/apache/tomcat/util/http/fileupload/IOUtils.java
+++ b/java/org/apache/tomcat/util/http/fileupload/IOUtils.java
@@ -20,7 +20,6 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 
-
 /**
  * General IO stream manipulation utilities.
  * <p>
@@ -52,14 +51,6 @@ import java.io.OutputStream;
  * <p>
  * Origin of code: Excalibur.
  *
- * @author Peter Donald
- * @author Jeff Turner
- * @author Matthew Hawthorne
- * @author Stephen Colebourne
- * @author Gareth Davis
- * @author Ian Springer
- * @author Niall Pemberton
- * @author Sandy McArthur
  * @version $Id$
  */
 public class IOUtils {
@@ -67,8 +58,13 @@ public class IOUtils {
     // Writer. Each method should take at least one of these as a parameter,
     // or return one of them.
 
+    private static final int EOF = -1;
+
     /**
-     * The default buffer size to use.
+     * The default buffer size ({@value}) to use for
+     * {@link #copyLarge(InputStream, OutputStream)}
+     * and
+     * {@link #copyLarge(Reader, Writer)}
      */
     private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;
 
@@ -79,25 +75,6 @@ public class IOUtils {
         super();
     }
 
-
-    /**
-     * Unconditionally close an <code>InputStream</code>.
-     * <p>
-     * Equivalent to {@link InputStream#close()}, except any exceptions will be ignored.
-     * This is typically used in finally blocks.
-     *
-     * @param input  the InputStream to close, may be null or already closed
-     */
-    public static void closeQuietly(InputStream input) {
-        try {
-            if (input != null) {
-                input.close();
-            }
-        } catch (IOException ioe) {
-            // ignore
-        }
-    }
-
     // copy from InputStream
     //-----------------------------------------------------------------------
     /**
@@ -114,11 +91,10 @@ public class IOUtils {
      *
      * @param input  the <code>InputStream</code> to read from
      * @param output  the <code>OutputStream</code> to write to
-     * @return the number of bytes copied
+     * @return the number of bytes copied, or -1 if &gt; Integer.MAX_VALUE
      * @throws NullPointerException if the input or output is null
      * @throws IOException if an I/O error occurs
-     * @throws ArithmeticException if the byte count is too large
-     * @since Commons IO 1.1
+     * @since 1.1
      */
     public static int copy(InputStream input, OutputStream output) throws IOException {
         long count = copyLarge(input, output);
@@ -134,25 +110,26 @@ public class IOUtils {
      * <p>
      * This method buffers the input internally, so there is no need to use a
      * <code>BufferedInputStream</code>.
+     * <p>
+     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.
      *
      * @param input  the <code>InputStream</code> to read from
      * @param output  the <code>OutputStream</code> to write to
      * @return the number of bytes copied
      * @throws NullPointerException if the input or output is null
      * @throws IOException if an I/O error occurs
-     * @since Commons IO 1.3
+     * @since 1.3
      */
     public static long copyLarge(InputStream input, OutputStream output)
             throws IOException {
+
         byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
         long count = 0;
         int n = 0;
-        while (-1 != (n = input.read(buffer))) {
+        while (EOF != (n = input.read(buffer))) {
             output.write(buffer, 0, n);
             count += n;
         }
         return count;
     }
-
-
 }

==================================================
