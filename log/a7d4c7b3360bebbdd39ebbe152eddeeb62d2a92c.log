a7d4c7b3360bebbdd39ebbe152eddeeb62d2a92c
==================================================
Code clean-up. Formatting. No functional change.
==================================================
Mark Thomas
==================================================
Wed Mar 8 18:27:07 2023 +0000
==================================================
Constants.java
Code clean-up. Formatting. No functional change.


==================================================
DefaultServerEndpointConfigurator.java
index d30c880af0..5aa99bbb5e 100644
--- a/java/org/apache/tomcat/websocket/server/Constants.java
+++ b/java/org/apache/tomcat/websocket/server/Constants.java
@@ -21,13 +21,10 @@ package org.apache.tomcat.websocket.server;
  */
 public class Constants {
 
-    public static final String BINARY_BUFFER_SIZE_SERVLET_CONTEXT_INIT_PARAM =
-            "org.apache.tomcat.websocket.binaryBufferSize";
-    public static final String TEXT_BUFFER_SIZE_SERVLET_CONTEXT_INIT_PARAM =
-            "org.apache.tomcat.websocket.textBufferSize";
+    public static final String BINARY_BUFFER_SIZE_SERVLET_CONTEXT_INIT_PARAM = "org.apache.tomcat.websocket.binaryBufferSize";
+    public static final String TEXT_BUFFER_SIZE_SERVLET_CONTEXT_INIT_PARAM = "org.apache.tomcat.websocket.textBufferSize";
 
-    public static final String SERVER_CONTAINER_SERVLET_CONTEXT_ATTRIBUTE =
-            "jakarta.websocket.server.ServerContainer";
+    public static final String SERVER_CONTAINER_SERVLET_CONTEXT_ATTRIBUTE = "jakarta.websocket.server.ServerContainer";
 
 
     private Constants() {

==================================================
UpgradeUtil.java
index 50252f61c1..24ed9e5c0f 100644
--- a/java/org/apache/tomcat/websocket/server/DefaultServerEndpointConfigurator.java
+++ b/java/org/apache/tomcat/websocket/server/DefaultServerEndpointConfigurator.java
@@ -26,13 +26,11 @@ import jakarta.websocket.HandshakeResponse;
 import jakarta.websocket.server.HandshakeRequest;
 import jakarta.websocket.server.ServerEndpointConfig;
 
-@aQute.bnd.annotation.spi.ServiceProvider(value=ServerEndpointConfig.Configurator.class)
-public class DefaultServerEndpointConfigurator
-        extends ServerEndpointConfig.Configurator {
+@aQute.bnd.annotation.spi.ServiceProvider(value = ServerEndpointConfig.Configurator.class)
+public class DefaultServerEndpointConfigurator extends ServerEndpointConfig.Configurator {
 
     @Override
-    public <T> T getEndpointInstance(Class<T> clazz)
-            throws InstantiationException {
+    public <T> T getEndpointInstance(Class<T> clazz) throws InstantiationException {
         try {
             return clazz.getConstructor().newInstance();
         } catch (InstantiationException e) {
@@ -46,8 +44,7 @@ public class DefaultServerEndpointConfigurator
 
 
     @Override
-    public String getNegotiatedSubprotocol(List<String> supported,
-            List<String> requested) {
+    public String getNegotiatedSubprotocol(List<String> supported, List<String> requested) {
 
         for (String request : requested) {
             if (supported.contains(request)) {
@@ -59,8 +56,7 @@ public class DefaultServerEndpointConfigurator
 
 
     @Override
-    public List<Extension> getNegotiatedExtensions(List<Extension> installed,
-            List<Extension> requested) {
+    public List<Extension> getNegotiatedExtensions(List<Extension> installed, List<Extension> requested) {
         Set<String> installedNames = new HashSet<>();
         for (Extension e : installed) {
             installedNames.add(e.getName());
@@ -81,8 +77,7 @@ public class DefaultServerEndpointConfigurator
     }
 
     @Override
-    public void modifyHandshake(ServerEndpointConfig sec,
-            HandshakeRequest request, HandshakeResponse response) {
+    public void modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response) {
         // NO-OP
     }
 

==================================================
UriTemplate.java
index 09fa90021e..ac4021fd00 100644
--- a/java/org/apache/tomcat/websocket/server/UpgradeUtil.java
+++ b/java/org/apache/tomcat/websocket/server/UpgradeUtil.java
@@ -49,60 +49,49 @@ import org.apache.tomcat.websocket.pojo.PojoMethodMapping;
 
 public class UpgradeUtil {
 
-    private static final StringManager sm =
-            StringManager.getManager(UpgradeUtil.class.getPackage().getName());
-    private static final byte[] WS_ACCEPT =
-            "258EAFA5-E914-47DA-95CA-C5AB0DC85B11".getBytes(
-                    StandardCharsets.ISO_8859_1);
+    private static final StringManager sm = StringManager.getManager(UpgradeUtil.class.getPackage().getName());
+    private static final byte[] WS_ACCEPT = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
+            .getBytes(StandardCharsets.ISO_8859_1);
 
     private UpgradeUtil() {
         // Utility class. Hide default constructor.
     }
 
     /**
-     * Checks to see if this is an HTTP request that includes a valid upgrade
-     * request to web socket.
+     * Checks to see if this is an HTTP request that includes a valid upgrade request to web socket.
      * <p>
-     * Note: RFC 2616 does not limit HTTP upgrade to GET requests but the Java
-     *       WebSocket spec 1.0, section 8.2 implies such a limitation and RFC
-     *       6455 section 4.1 requires that a WebSocket Upgrade uses GET.
-     * @param request  The request to check if it is an HTTP upgrade request for
-     *                 a WebSocket connection
+     * Note: RFC 2616 does not limit HTTP upgrade to GET requests but the Java WebSocket spec 1.0, section 8.2 implies
+     * such a limitation and RFC 6455 section 4.1 requires that a WebSocket Upgrade uses GET.
+     *
+     * @param request  The request to check if it is an HTTP upgrade request for a WebSocket connection
      * @param response The response associated with the request
-     * @return <code>true</code> if the request includes an HTTP Upgrade request
-     *         for the WebSocket protocol, otherwise <code>false</code>
+     *
+     * @return <code>true</code> if the request includes an HTTP Upgrade request for the WebSocket protocol, otherwise
+     *             <code>false</code>
      */
-    public static boolean isWebSocketUpgradeRequest(ServletRequest request,
-            ServletResponse response) {
+    public static boolean isWebSocketUpgradeRequest(ServletRequest request, ServletResponse response) {
 
         return ((request instanceof HttpServletRequest) &&
-                (response instanceof HttpServletResponse) &&
-                headerContainsToken((HttpServletRequest) request,
-                        Constants.UPGRADE_HEADER_NAME,
-                        Constants.UPGRADE_HEADER_VALUE) &&
+                (response instanceof HttpServletResponse) && headerContainsToken((HttpServletRequest) request,
+                        Constants.UPGRADE_HEADER_NAME, Constants.UPGRADE_HEADER_VALUE) &&
                 "GET".equals(((HttpServletRequest) request).getMethod()));
     }
 
 
-    public static void doUpgrade(WsServerContainer sc, HttpServletRequest req,
-            HttpServletResponse resp, ServerEndpointConfig sec,
-            Map<String,String> pathParams)
-            throws ServletException, IOException {
+    public static void doUpgrade(WsServerContainer sc, HttpServletRequest req, HttpServletResponse resp,
+            ServerEndpointConfig sec, Map<String, String> pathParams) throws ServletException, IOException {
 
         // Validate the rest of the headers and reject the request if that
         // validation fails
         String key;
         String subProtocol = null;
-        if (!headerContainsToken(req, Constants.CONNECTION_HEADER_NAME,
-                Constants.CONNECTION_HEADER_VALUE)) {
+        if (!headerContainsToken(req, Constants.CONNECTION_HEADER_NAME, Constants.CONNECTION_HEADER_VALUE)) {
             resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
             return;
         }
-        if (!headerContainsToken(req, Constants.WS_VERSION_HEADER_NAME,
-                Constants.WS_VERSION_HEADER_VALUE)) {
+        if (!headerContainsToken(req, Constants.WS_VERSION_HEADER_NAME, Constants.WS_VERSION_HEADER_VALUE)) {
             resp.setStatus(HttpServletResponse.SC_UPGRADE_REQUIRED);
-            resp.setHeader(Constants.WS_VERSION_HEADER_NAME,
-                    Constants.WS_VERSION_HEADER_VALUE);
+            resp.setHeader(Constants.WS_VERSION_HEADER_NAME, Constants.WS_VERSION_HEADER_VALUE);
             return;
         }
         key = req.getHeader(Constants.WS_KEY_HEADER_NAME);
@@ -119,10 +108,8 @@ public class UpgradeUtil {
             return;
         }
         // Sub-protocols
-        List<String> subProtocols = getTokensFromHeader(req,
-                Constants.WS_PROTOCOL_HEADER_NAME);
-        subProtocol = sec.getConfigurator().getNegotiatedSubprotocol(
-                sec.getSubprotocols(), subProtocols);
+        List<String> subProtocols = getTokensFromHeader(req, Constants.WS_PROTOCOL_HEADER_NAME);
+        subProtocol = sec.getConfigurator().getNegotiatedSubprotocol(sec.getSubprotocols(), subProtocols);
 
         // Extensions
         // Should normally only be one header but handle the case of multiple
@@ -143,8 +130,8 @@ public class UpgradeUtil {
             installedExtensions.addAll(sec.getExtensions());
             installedExtensions.addAll(Constants.INSTALLED_EXTENSIONS);
         }
-        List<Extension> negotiatedExtensionsPhase1 = sec.getConfigurator().getNegotiatedExtensions(
-                installedExtensions, extensionsRequested);
+        List<Extension> negotiatedExtensionsPhase1 = sec.getConfigurator().getNegotiatedExtensions(installedExtensions,
+                extensionsRequested);
 
         // Negotiation phase 2. Create the Transformations that will be applied
         // to this connection. Note than an extension may be dropped at this
@@ -186,12 +173,9 @@ public class UpgradeUtil {
         }
 
         // If we got this far, all is good. Accept the connection.
-        resp.setHeader(Constants.UPGRADE_HEADER_NAME,
-                Constants.UPGRADE_HEADER_VALUE);
-        resp.setHeader(Constants.CONNECTION_HEADER_NAME,
-                Constants.CONNECTION_HEADER_VALUE);
-        resp.setHeader(HandshakeResponse.SEC_WEBSOCKET_ACCEPT,
-                getWebSocketAccept(key));
+        resp.setHeader(Constants.UPGRADE_HEADER_NAME, Constants.UPGRADE_HEADER_VALUE);
+        resp.setHeader(Constants.CONNECTION_HEADER_NAME, Constants.CONNECTION_HEADER_VALUE);
+        resp.setHeader(HandshakeResponse.SEC_WEBSOCKET_ACCEPT, getWebSocketAccept(key));
         if (subProtocol != null && subProtocol.length() > 0) {
             // RFC6455 4.2.2 explicitly states "" is not valid here
             resp.setHeader(Constants.WS_PROTOCOL_HEADER_NAME, subProtocol);
@@ -201,26 +185,25 @@ public class UpgradeUtil {
         }
 
         // Add method mapping to user properties
-        if (!Endpoint.class.isAssignableFrom(sec.getEndpointClass()) &&
-                sec.getUserProperties().get(org.apache.tomcat.websocket.pojo.Constants.POJO_METHOD_MAPPING_KEY) == null) {
+        if (!Endpoint.class.isAssignableFrom(sec.getEndpointClass()) && sec.getUserProperties()
+                .get(org.apache.tomcat.websocket.pojo.Constants.POJO_METHOD_MAPPING_KEY) == null) {
             // This is a POJO endpoint and the application has called upgrade
             // directly. Need to add the method mapping.
             try {
-                PojoMethodMapping methodMapping = new PojoMethodMapping(sec.getEndpointClass(),
-                        sec.getDecoders(), sec.getPath(), sc.getInstanceManager(Thread.currentThread().getContextClassLoader()));
-                if (methodMapping.getOnClose() != null || methodMapping.getOnOpen() != null
-                        || methodMapping.getOnError() != null || methodMapping.hasMessageHandlers()) {
-                    sec.getUserProperties().put(
-                            org.apache.tomcat.websocket.pojo.Constants.POJO_METHOD_MAPPING_KEY, methodMapping);
+                PojoMethodMapping methodMapping = new PojoMethodMapping(sec.getEndpointClass(), sec.getDecoders(),
+                        sec.getPath(), sc.getInstanceManager(Thread.currentThread().getContextClassLoader()));
+                if (methodMapping.getOnClose() != null || methodMapping.getOnOpen() != null ||
+                        methodMapping.getOnError() != null || methodMapping.hasMessageHandlers()) {
+                    sec.getUserProperties().put(org.apache.tomcat.websocket.pojo.Constants.POJO_METHOD_MAPPING_KEY,
+                            methodMapping);
                 }
             } catch (DeploymentException e) {
-                throw new ServletException(
-                        sm.getString("upgradeUtil.pojoMapFail", sec.getEndpointClass().getName()),  e);
+                throw new ServletException(sm.getString("upgradeUtil.pojoMapFail", sec.getEndpointClass().getName()),
+                        e);
             }
         }
 
-        WsPerSessionServerEndpointConfig perSessionServerEndpointConfig =
-                new WsPerSessionServerEndpointConfig(sec);
+        WsPerSessionServerEndpointConfig perSessionServerEndpointConfig = new WsPerSessionServerEndpointConfig(sec);
 
         WsHandshakeRequest wsRequest = new WsHandshakeRequest(req, pathParams);
         WsHandshakeResponse wsResponse = new WsHandshakeResponse();
@@ -228,40 +211,34 @@ public class UpgradeUtil {
         wsRequest.finished();
 
         // Add any additional headers
-        for (Entry<String,List<String>> entry :
-                wsResponse.getHeaders().entrySet()) {
-            for (String headerValue: entry.getValue()) {
+        for (Entry<String, List<String>> entry : wsResponse.getHeaders().entrySet()) {
+            for (String headerValue : entry.getValue()) {
                 resp.addHeader(entry.getKey(), headerValue);
             }
         }
 
-        WsHttpUpgradeHandler wsHandler =
-                req.upgrade(WsHttpUpgradeHandler.class);
-        wsHandler.preInit(perSessionServerEndpointConfig, sc, wsRequest,
-                negotiatedExtensionsPhase2, subProtocol, transformation, pathParams,
-                req.isSecure());
+        WsHttpUpgradeHandler wsHandler = req.upgrade(WsHttpUpgradeHandler.class);
+        wsHandler.preInit(perSessionServerEndpointConfig, sc, wsRequest, negotiatedExtensionsPhase2, subProtocol,
+                transformation, pathParams, req.isSecure());
 
     }
 
 
-    private static List<Transformation> createTransformations(
-            List<Extension> negotiatedExtensions) {
+    private static List<Transformation> createTransformations(List<Extension> negotiatedExtensions) {
 
         TransformationFactory factory = TransformationFactory.getInstance();
 
-        LinkedHashMap<String,List<List<Extension.Parameter>>> extensionPreferences =
-                new LinkedHashMap<>();
+        LinkedHashMap<String, List<List<Extension.Parameter>>> extensionPreferences = new LinkedHashMap<>();
 
         // Result will likely be smaller than this
         List<Transformation> result = new ArrayList<>(negotiatedExtensions.size());
 
         for (Extension extension : negotiatedExtensions) {
             extensionPreferences.computeIfAbsent(extension.getName(), k -> new ArrayList<>())
-                .add(extension.getParameters());
+                    .add(extension.getParameters());
         }
 
-        for (Map.Entry<String,List<List<Extension.Parameter>>> entry :
-            extensionPreferences.entrySet()) {
+        for (Map.Entry<String, List<List<Extension.Parameter>>> entry : extensionPreferences.entrySet()) {
             Transformation transformation = factory.create(entry.getKey(), entry.getValue(), true);
             if (transformation != null) {
                 result.add(transformation);
@@ -290,11 +267,9 @@ public class UpgradeUtil {
 
 
     /*
-     * This only works for tokens. Quoted strings need more sophisticated
-     * parsing.
+     * This only works for tokens. Quoted strings need more sophisticated parsing.
      */
-    private static boolean headerContainsToken(HttpServletRequest req,
-            String headerName, String target) {
+    private static boolean headerContainsToken(HttpServletRequest req, String headerName, String target) {
         Enumeration<String> headers = req.getHeaders(headerName);
         while (headers.hasMoreElements()) {
             String header = headers.nextElement();
@@ -310,11 +285,9 @@ public class UpgradeUtil {
 
 
     /*
-     * This only works for tokens. Quoted strings need more sophisticated
-     * parsing.
+     * This only works for tokens. Quoted strings need more sophisticated parsing.
      */
-    private static List<String> getTokensFromHeader(HttpServletRequest req,
-            String headerName) {
+    private static List<String> getTokensFromHeader(HttpServletRequest req, String headerName) {
         List<String> result = new ArrayList<>();
         Enumeration<String> headers = req.getHeaders(headerName);
         while (headers.hasMoreElements()) {
@@ -329,8 +302,7 @@ public class UpgradeUtil {
 
 
     private static String getWebSocketAccept(String key) {
-        byte[] digest = ConcurrentMessageDigest.digestSHA1(
-                key.getBytes(StandardCharsets.ISO_8859_1), WS_ACCEPT);
+        byte[] digest = ConcurrentMessageDigest.digestSHA1(key.getBytes(StandardCharsets.ISO_8859_1), WS_ACCEPT);
         return Base64.encodeBase64String(digest);
     }
 }

==================================================
WsContextListener.java
index f8a8ec46a8..4681862e25 100644
--- a/java/org/apache/tomcat/websocket/server/UriTemplate.java
+++ b/java/org/apache/tomcat/websocket/server/UriTemplate.java
@@ -29,8 +29,8 @@ import jakarta.websocket.DeploymentException;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * Extracts path parameters from URIs used to create web socket connections
- * using the URI template defined for the associated Endpoint.
+ * Extracts path parameters from URIs used to create web socket connections using the URI template defined for the
+ * associated Endpoint.
  */
 public class UriTemplate {
 
@@ -45,8 +45,7 @@ public class UriTemplate {
 
         if (path == null || path.length() == 0 || !path.startsWith("/") || path.contains("/../") ||
                 path.contains("/./") || path.contains("//")) {
-            throw new DeploymentException(
-                    sm.getString("uriTemplate.invalidPath", path));
+            throw new DeploymentException(sm.getString("uriTemplate.invalidPath", path));
         }
 
         StringBuilder normalized = new StringBuilder(path.length());
@@ -69,8 +68,7 @@ public class UriTemplate {
                 } else {
                     // As per EG discussion, all other empty segments are
                     // invalid
-                    throw new DeploymentException(sm.getString(
-                            "uriTemplate.emptySegment", path));
+                    throw new DeploymentException(sm.getString("uriTemplate.emptySegment", path));
                 }
             }
             normalized.append('/');
@@ -82,13 +80,11 @@ public class UriTemplate {
                 normalized.append(paramCount++);
                 normalized.append('}');
                 if (!paramNames.add(segment)) {
-                    throw new DeploymentException(sm.getString(
-                            "uriTemplate.duplicateParameter", segment));
+                    throw new DeploymentException(sm.getString("uriTemplate.duplicateParameter", segment));
                 }
             } else {
                 if (segment.contains("{") || segment.contains("}")) {
-                    throw new DeploymentException(sm.getString(
-                            "uriTemplate.invalidSegment", segment, path));
+                    throw new DeploymentException(sm.getString("uriTemplate.invalidSegment", segment, path));
                 }
                 normalized.append(segment);
             }
@@ -101,9 +97,9 @@ public class UriTemplate {
     }
 
 
-    public Map<String,String> match(UriTemplate candidate) {
+    public Map<String, String> match(UriTemplate candidate) {
 
-        Map<String,String> result = new HashMap<>();
+        Map<String, String> result = new HashMap<>();
 
         // Should not happen but for safety
         if (candidate.getSegmentCount() != getSegmentCount()) {
@@ -117,15 +113,13 @@ public class UriTemplate {
 
             if (targetSegment.getParameterIndex() == -1) {
                 // Not a parameter - values must match
-                if (!targetSegment.getValue().equals(
-                        candidateSegment.getValue())) {
+                if (!targetSegment.getValue().equals(candidateSegment.getValue())) {
                     // Not a match. Stop here
                     return null;
                 }
             } else {
                 // Parameter
-                result.put(targetSegment.getValue(),
-                        candidateSegment.getValue());
+                result.put(targetSegment.getValue(), candidateSegment.getValue());
             }
         }
 

==================================================
WsFilter.java
index a356f85a7e..6c698dc4e1 100644
--- a/java/org/apache/tomcat/websocket/server/WsContextListener.java
+++ b/java/org/apache/tomcat/websocket/server/WsContextListener.java
@@ -21,12 +21,10 @@ import jakarta.servlet.ServletContextEvent;
 import jakarta.servlet.ServletContextListener;
 
 /**
- * In normal usage, this {@link ServletContextListener} does not need to be
- * explicitly configured as the {@link WsSci} performs all the necessary
- * bootstrap and installs this listener in the {@link ServletContext}. If the
- * {@link WsSci} is disabled, this listener must be added manually to every
- * {@link ServletContext} that uses WebSocket to bootstrap the
- * {@link WsServerContainer} correctly.
+ * In normal usage, this {@link ServletContextListener} does not need to be explicitly configured as the {@link WsSci}
+ * performs all the necessary bootstrap and installs this listener in the {@link ServletContext}. If the {@link WsSci}
+ * is disabled, this listener must be added manually to every {@link ServletContext} that uses WebSocket to bootstrap
+ * the {@link WsServerContainer} correctly.
  */
 public class WsContextListener implements ServletContextListener {
 

==================================================
WsFrameServer.java
index 7f484b9ca3..224542207b 100644
--- a/java/org/apache/tomcat/websocket/server/WsFilter.java
+++ b/java/org/apache/tomcat/websocket/server/WsFilter.java
@@ -38,18 +38,16 @@ public class WsFilter extends GenericFilter {
 
     @Override
     public void init() throws ServletException {
-        sc = (WsServerContainer) getServletContext().getAttribute(
-                Constants.SERVER_CONTAINER_SERVLET_CONTEXT_ATTRIBUTE);
+        sc = (WsServerContainer) getServletContext().getAttribute(Constants.SERVER_CONTAINER_SERVLET_CONTEXT_ATTRIBUTE);
     }
 
 
     @Override
-    public void doFilter(ServletRequest request, ServletResponse response,
-            FilterChain chain) throws IOException, ServletException {
+    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
+            throws IOException, ServletException {
 
         // This filter only needs to handle WebSocket upgrade requests
-        if (!sc.areEndpointsRegistered() ||
-                !UpgradeUtil.isWebSocketUpgradeRequest(request, response)) {
+        if (!sc.areEndpointsRegistered() || !UpgradeUtil.isWebSocketUpgradeRequest(request, response)) {
             chain.doFilter(request, response);
             return;
         }
@@ -75,7 +73,6 @@ public class WsFilter extends GenericFilter {
             return;
         }
 
-        UpgradeUtil.doUpgrade(sc, req, resp, mappingResult.getConfig(),
-                mappingResult.getPathParams());
+        UpgradeUtil.doUpgrade(sc, req, resp, mappingResult.getConfig(), mappingResult.getPathParams());
     }
 }

==================================================
WsHandshakeRequest.java
index c40ae31095..fd4da3d44a 100644
--- a/java/org/apache/tomcat/websocket/server/WsFrameServer.java
+++ b/java/org/apache/tomcat/websocket/server/WsFrameServer.java
@@ -54,8 +54,7 @@ public class WsFrameServer extends WsFrameBase {
     /**
      * Called when there is data in the ServletInputStream to process.
      *
-     * @throws IOException if an I/O error occurs while processing the available
-     *                     data
+     * @throws IOException if an I/O error occurs while processing the available data
      */
     private void onDataAvailable() throws IOException {
         if (log.isDebugEnabled()) {
@@ -156,24 +155,23 @@ public class WsFrameServer extends WsFrameBase {
     SocketState notifyDataAvailable() throws IOException {
         while (isOpen()) {
             switch (getReadState()) {
-            case WAITING:
-                if (!changeReadState(ReadState.WAITING, ReadState.PROCESSING)) {
-                    continue;
-                }
-                try {
-                    return doOnDataAvailable();
-                } catch (IOException e) {
-                    changeReadState(ReadState.CLOSING);
-                    throw e;
-                }
-            case SUSPENDING_WAIT:
-                if (!changeReadState(ReadState.SUSPENDING_WAIT, ReadState.SUSPENDED)) {
-                    continue;
-                }
-                return SocketState.SUSPENDED;
-            default:
-                throw new IllegalStateException(
-                        sm.getString("wsFrameServer.illegalReadState", getReadState()));
+                case WAITING:
+                    if (!changeReadState(ReadState.WAITING, ReadState.PROCESSING)) {
+                        continue;
+                    }
+                    try {
+                        return doOnDataAvailable();
+                    } catch (IOException e) {
+                        changeReadState(ReadState.CLOSING);
+                        throw e;
+                    }
+                case SUSPENDING_WAIT:
+                    if (!changeReadState(ReadState.SUSPENDING_WAIT, ReadState.SUSPENDED)) {
+                        continue;
+                    }
+                    return SocketState.SUSPENDED;
+                default:
+                    throw new IllegalStateException(sm.getString("wsFrameServer.illegalReadState", getReadState()));
             }
         }
 
@@ -185,19 +183,18 @@ public class WsFrameServer extends WsFrameBase {
         onDataAvailable();
         while (isOpen()) {
             switch (getReadState()) {
-            case PROCESSING:
-                if (!changeReadState(ReadState.PROCESSING, ReadState.WAITING)) {
-                    continue;
-                }
-                return SocketState.UPGRADED;
-            case SUSPENDING_PROCESS:
-                if (!changeReadState(ReadState.SUSPENDING_PROCESS, ReadState.SUSPENDED)) {
-                    continue;
-                }
-                return SocketState.SUSPENDED;
-            default:
-                throw new IllegalStateException(
-                        sm.getString("wsFrameServer.illegalReadState", getReadState()));
+                case PROCESSING:
+                    if (!changeReadState(ReadState.PROCESSING, ReadState.WAITING)) {
+                        continue;
+                    }
+                    return SocketState.UPGRADED;
+                case SUSPENDING_PROCESS:
+                    if (!changeReadState(ReadState.SUSPENDING_PROCESS, ReadState.SUSPENDED)) {
+                        continue;
+                    }
+                    return SocketState.SUSPENDED;
+                default:
+                    throw new IllegalStateException(sm.getString("wsFrameServer.illegalReadState", getReadState()));
             }
         }
 

==================================================
WsHttpUpgradeHandler.java
index 3fb0b11440..fb5bce9000 100644
--- a/java/org/apache/tomcat/websocket/server/WsHandshakeRequest.java
+++ b/java/org/apache/tomcat/websocket/server/WsHandshakeRequest.java
@@ -41,16 +41,16 @@ public class WsHandshakeRequest implements HandshakeRequest {
     private static final StringManager sm = StringManager.getManager(WsHandshakeRequest.class);
 
     private final URI requestUri;
-    private final Map<String,List<String>> parameterMap;
+    private final Map<String, List<String>> parameterMap;
     private final String queryString;
     private final Principal userPrincipal;
-    private final Map<String,List<String>> headers;
+    private final Map<String, List<String>> headers;
     private final Object httpSession;
 
     private volatile HttpServletRequest request;
 
 
-    public WsHandshakeRequest(HttpServletRequest request, Map<String,String> pathParams) {
+    public WsHandshakeRequest(HttpServletRequest request, Map<String, String> pathParams) {
 
         this.request = request;
 
@@ -60,28 +60,24 @@ public class WsHandshakeRequest implements HandshakeRequest {
         requestUri = buildRequestUri(request);
 
         // ParameterMap
-        Map<String,String[]> originalParameters = request.getParameterMap();
-        Map<String,List<String>> newParameters =
-                new HashMap<>(originalParameters.size());
-        for (Entry<String,String[]> entry : originalParameters.entrySet()) {
-            newParameters.put(entry.getKey(),
-                    Collections.unmodifiableList(
-                            Arrays.asList(entry.getValue())));
+        Map<String, String[]> originalParameters = request.getParameterMap();
+        Map<String, List<String>> newParameters = new HashMap<>(originalParameters.size());
+        for (Entry<String, String[]> entry : originalParameters.entrySet()) {
+            newParameters.put(entry.getKey(), Collections.unmodifiableList(Arrays.asList(entry.getValue())));
         }
-        for (Entry<String,String> entry : pathParams.entrySet()) {
+        for (Entry<String, String> entry : pathParams.entrySet()) {
             newParameters.put(entry.getKey(), Collections.singletonList(entry.getValue()));
         }
         parameterMap = Collections.unmodifiableMap(newParameters);
 
         // Headers
-        Map<String,List<String>> newHeaders = new CaseInsensitiveKeyMap<>();
+        Map<String, List<String>> newHeaders = new CaseInsensitiveKeyMap<>();
 
         Enumeration<String> headerNames = request.getHeaderNames();
         while (headerNames.hasMoreElements()) {
             String headerName = headerNames.nextElement();
 
-            newHeaders.put(headerName, Collections.unmodifiableList(
-                    Collections.list(request.getHeaders(headerName))));
+            newHeaders.put(headerName, Collections.unmodifiableList(Collections.list(request.getHeaders(headerName))));
         }
 
         headers = Collections.unmodifiableMap(newHeaders);
@@ -93,7 +89,7 @@ public class WsHandshakeRequest implements HandshakeRequest {
     }
 
     @Override
-    public Map<String,List<String>> getParameterMap() {
+    public Map<String, List<String>> getParameterMap() {
         return parameterMap;
     }
 
@@ -108,7 +104,7 @@ public class WsHandshakeRequest implements HandshakeRequest {
     }
 
     @Override
-    public Map<String,List<String>> getHeaders() {
+    public Map<String, List<String>> getHeaders() {
         return headers;
     }
 
@@ -127,12 +123,9 @@ public class WsHandshakeRequest implements HandshakeRequest {
     }
 
     /**
-     * Called when the HandshakeRequest is no longer required. Since an instance
-     * of this class retains a reference to the current HttpServletRequest that
-     * reference needs to be cleared as the HttpServletRequest may be reused.
-     *
-     * There is no reason for instances of this class to be accessed once the
-     * handshake has been completed.
+     * Called when the HandshakeRequest is no longer required. Since an instance of this class retains a reference to
+     * the current HttpServletRequest that reference needs to be cleared as the HttpServletRequest may be reused. There
+     * is no reason for instances of this class to be accessed once the handshake has been completed.
      */
     void finished() {
         request = null;
@@ -160,17 +153,14 @@ public class WsHandshakeRequest implements HandshakeRequest {
             uri.append(scheme);
         } else {
             // Should never happen
-            throw new IllegalArgumentException(
-                    sm.getString("wsHandshakeRequest.unknownScheme", scheme));
+            throw new IllegalArgumentException(sm.getString("wsHandshakeRequest.unknownScheme", scheme));
         }
 
         uri.append("://");
         uri.append(req.getServerName());
 
-        if ((scheme.equals("http") && (port != 80))
-            || (scheme.equals("ws") && (port != 80))
-            || (scheme.equals("wss") && (port != 443))
-            || (scheme.equals("https") && (port != 443))) {
+        if ((scheme.equals("http") && (port != 80)) || (scheme.equals("ws") && (port != 80)) ||
+                (scheme.equals("wss") && (port != 443)) || (scheme.equals("https") && (port != 443))) {
             uri.append(':');
             uri.append(port);
         }
@@ -186,8 +176,7 @@ public class WsHandshakeRequest implements HandshakeRequest {
             return new URI(uri.toString());
         } catch (URISyntaxException e) {
             // Should never happen
-            throw new IllegalArgumentException(
-                    sm.getString("wsHandshakeRequest.invalidUri", uri.toString()), e);
+            throw new IllegalArgumentException(sm.getString("wsHandshakeRequest.invalidUri", uri.toString()), e);
         }
     }
 }

==================================================
WsMappingResult.java
index 22e9c93ff3..f3891e1a68 100644
--- a/java/org/apache/tomcat/websocket/server/WsHttpUpgradeHandler.java
+++ b/java/org/apache/tomcat/websocket/server/WsHttpUpgradeHandler.java
@@ -63,7 +63,7 @@ public class WsHttpUpgradeHandler implements InternalHttpUpgradeHandler {
     private List<Extension> negotiatedExtensions;
     private String subProtocol;
     private Transformation transformation;
-    private Map<String,String> pathParameters;
+    private Map<String, String> pathParameters;
     private boolean secure;
     private WebConnection connection;
 
@@ -83,11 +83,9 @@ public class WsHttpUpgradeHandler implements InternalHttpUpgradeHandler {
     }
 
 
-    public void preInit(ServerEndpointConfig serverEndpointConfig,
-            WsServerContainer wsc, WsHandshakeRequest handshakeRequest,
-            List<Extension> negotiatedExtensionsPhase2, String subProtocol,
-            Transformation transformation, Map<String,String> pathParameters,
-            boolean secure) {
+    public void preInit(ServerEndpointConfig serverEndpointConfig, WsServerContainer wsc,
+            WsHandshakeRequest handshakeRequest, List<Extension> negotiatedExtensionsPhase2, String subProtocol,
+            Transformation transformation, Map<String, String> pathParameters, boolean secure) {
         this.serverEndpointConfig = serverEndpointConfig;
         this.webSocketContainer = wsc;
         this.handshakeRequest = handshakeRequest;
@@ -103,13 +101,12 @@ public class WsHttpUpgradeHandler implements InternalHttpUpgradeHandler {
     public void init(WebConnection connection) {
         this.connection = connection;
         if (serverEndpointConfig == null) {
-            throw new IllegalStateException(
-                    sm.getString("wsHttpUpgradeHandler.noPreInit"));
+            throw new IllegalStateException(sm.getString("wsHttpUpgradeHandler.noPreInit"));
         }
 
         String httpSessionId = null;
         Object session = handshakeRequest.getHttpSession();
-        if (session != null ) {
+        if (session != null) {
             httpSessionId = ((HttpSession) session).getId();
         }
 
@@ -121,16 +118,12 @@ public class WsHttpUpgradeHandler implements InternalHttpUpgradeHandler {
         t.setContextClassLoader(applicationClassLoader);
         try {
             wsRemoteEndpointServer = new WsRemoteEndpointImplServer(socketWrapper, upgradeInfo, webSocketContainer);
-            wsSession = new WsSession(wsRemoteEndpointServer,
-                    webSocketContainer, handshakeRequest.getRequestURI(),
-                    handshakeRequest.getParameterMap(),
-                    handshakeRequest.getQueryString(),
-                    handshakeRequest.getUserPrincipal(), httpSessionId,
-                    negotiatedExtensions, subProtocol, pathParameters, secure,
-                    serverEndpointConfig);
+            wsSession = new WsSession(wsRemoteEndpointServer, webSocketContainer, handshakeRequest.getRequestURI(),
+                    handshakeRequest.getParameterMap(), handshakeRequest.getQueryString(),
+                    handshakeRequest.getUserPrincipal(), httpSessionId, negotiatedExtensions, subProtocol,
+                    pathParameters, secure, serverEndpointConfig);
             ep = wsSession.getLocal();
-            wsFrame = new WsFrameServer(socketWrapper, upgradeInfo, wsSession, transformation,
-                    applicationClassLoader);
+            wsFrame = new WsFrameServer(socketWrapper, upgradeInfo, wsSession, transformation, applicationClassLoader);
             // WsFrame adds the necessary final transformations. Copy the
             // completed transformation chain to the remote end point.
             wsRemoteEndpointServer.setTransformation(wsFrame.getTransformation());
@@ -160,8 +153,7 @@ public class WsHttpUpgradeHandler implements InternalHttpUpgradeHandler {
                     close(ws.getCloseReason());
                 } catch (IOException ioe) {
                     onError(ioe);
-                    CloseReason cr = new CloseReason(
-                            CloseCodes.CLOSED_ABNORMALLY, ioe.getMessage());
+                    CloseReason cr = new CloseReason(CloseCodes.CLOSED_ABNORMALLY, ioe.getMessage());
                     close(cr);
                 }
                 return SocketState.CLOSED;
@@ -175,8 +167,7 @@ public class WsHttpUpgradeHandler implements InternalHttpUpgradeHandler {
                     wsSession.close(cr);
                 } catch (IOException ioe) {
                     onError(ioe);
-                    cr = new CloseReason(
-                            CloseCodes.CLOSED_ABNORMALLY, ioe.getMessage());
+                    cr = new CloseReason(CloseCodes.CLOSED_ABNORMALLY, ioe.getMessage());
                     close(cr);
                     return SocketState.CLOSED;
                 }
@@ -241,23 +232,18 @@ public class WsHttpUpgradeHandler implements InternalHttpUpgradeHandler {
 
     private void close(CloseReason cr) {
         /*
-         * Any call to this method is a result of a problem reading from the
-         * client. At this point that state of the connection is unknown. First
-         * attempt to clear the handler for any in-flight message write (that
-         * probably failed). If using NIO2 is is possible that the original
-         * error occurred on a write but this method was called during a read.
-         * The in-progress write will block the sending of the close frame
-         * unless the handler is cleared (effectively signalling the write
-         * failed).
+         * Any call to this method is a result of a problem reading from the client. At this point that state of the
+         * connection is unknown. First attempt to clear the handler for any in-flight message write (that probably
+         * failed). If using NIO2 is is possible that the original error occurred on a write but this method was called
+         * during a read. The in-progress write will block the sending of the close frame unless the handler is cleared
+         * (effectively signalling the write failed).
          */
         wsRemoteEndpointServer.clearHandler(new EOFException(), true);
 
-        /* Then:
-         *  - send a close frame to the client
-         * - close the socket immediately.
-         * There is no point in waiting for a close frame from the client
-         * because there is no guarantee that we can recover from whatever
-         * messed up state the client put the connection into.
+        /*
+         * Then: - send a close frame to the client - close the socket immediately. There is no point in waiting for a
+         * close frame from the client because there is no guarantee that we can recover from whatever messed up state
+         * the client put the connection into.
          */
         wsSession.onClose(cr);
     }

==================================================
WsPerSessionServerEndpointConfig.java
index 51252318ca..3729315947 100644
--- a/java/org/apache/tomcat/websocket/server/WsMappingResult.java
+++ b/java/org/apache/tomcat/websocket/server/WsMappingResult.java
@@ -23,11 +23,10 @@ import jakarta.websocket.server.ServerEndpointConfig;
 class WsMappingResult {
 
     private final ServerEndpointConfig config;
-    private final Map<String,String> pathParams;
+    private final Map<String, String> pathParams;
 
 
-    WsMappingResult(ServerEndpointConfig config,
-            Map<String,String> pathParams) {
+    WsMappingResult(ServerEndpointConfig config, Map<String, String> pathParams) {
         this.config = config;
         this.pathParams = pathParams;
     }
@@ -38,7 +37,7 @@ class WsMappingResult {
     }
 
 
-    Map<String,String> getPathParams() {
+    Map<String, String> getPathParams() {
         return pathParams;
     }
 }

==================================================
WsRemoteEndpointImplServer.java
index 07452e9054..451efe412f 100644
--- a/java/org/apache/tomcat/websocket/server/WsPerSessionServerEndpointConfig.java
+++ b/java/org/apache/tomcat/websocket/server/WsPerSessionServerEndpointConfig.java
@@ -26,16 +26,14 @@ import jakarta.websocket.Extension;
 import jakarta.websocket.server.ServerEndpointConfig;
 
 /**
- * Wraps the provided {@link ServerEndpointConfig} and provides a per session
- * view - the difference being that the map returned by {@link
- * #getUserProperties()} is unique to this instance rather than shared with the
- * wrapped {@link ServerEndpointConfig}.
+ * Wraps the provided {@link ServerEndpointConfig} and provides a per session view - the difference being that the map
+ * returned by {@link #getUserProperties()} is unique to this instance rather than shared with the wrapped
+ * {@link ServerEndpointConfig}.
  */
 class WsPerSessionServerEndpointConfig implements ServerEndpointConfig {
 
     private final ServerEndpointConfig perEndpointConfig;
-    private final Map<String,Object> perSessionUserProperties =
-            new ConcurrentHashMap<>();
+    private final Map<String, Object> perSessionUserProperties = new ConcurrentHashMap<>();
 
     WsPerSessionServerEndpointConfig(ServerEndpointConfig perEndpointConfig) {
         this.perEndpointConfig = perEndpointConfig;
@@ -53,7 +51,7 @@ class WsPerSessionServerEndpointConfig implements ServerEndpointConfig {
     }
 
     @Override
-    public Map<String,Object> getUserProperties() {
+    public Map<String, Object> getUserProperties() {
         return perSessionUserProperties;
     }
 

==================================================
WsSci.java
index 524f8e972d..8dd5974328 100644
--- a/java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java
+++ b/java/org/apache/tomcat/websocket/server/WsRemoteEndpointImplServer.java
@@ -37,13 +37,12 @@ import org.apache.tomcat.websocket.Transformation;
 import org.apache.tomcat.websocket.WsRemoteEndpointImplBase;
 
 /**
- * This is the server side {@link jakarta.websocket.RemoteEndpoint} implementation
- * - i.e. what the server uses to send data to the client.
+ * This is the server side {@link jakarta.websocket.RemoteEndpoint} implementation - i.e. what the server uses to send
+ * data to the client.
  */
 public class WsRemoteEndpointImplServer extends WsRemoteEndpointImplBase {
 
-    private static final StringManager sm =
-            StringManager.getManager(WsRemoteEndpointImplServer.class);
+    private static final StringManager sm = StringManager.getManager(WsRemoteEndpointImplServer.class);
     private final Log log = LogFactory.getLog(WsRemoteEndpointImplServer.class); // must not be static
 
     private final SocketWrapperBase<?> socketWrapper;
@@ -69,8 +68,7 @@ public class WsRemoteEndpointImplServer extends WsRemoteEndpointImplBase {
 
 
     @Override
-    protected void doWrite(SendHandler handler, long blockingWriteTimeoutExpiry,
-            ByteBuffer... buffers) {
+    protected void doWrite(SendHandler handler, long blockingWriteTimeoutExpiry, ByteBuffer... buffers) {
         if (socketWrapper.hasAsyncIO()) {
             final boolean block = (blockingWriteTimeoutExpiry != -1);
             long timeout = -1;
@@ -90,9 +88,8 @@ public class WsRemoteEndpointImplServer extends WsRemoteEndpointImplBase {
                     wsWriteTimeout.register(this);
                 }
             }
-            socketWrapper.write(block ? BlockingMode.BLOCK : BlockingMode.SEMI_BLOCK, timeout,
-                    TimeUnit.MILLISECONDS, null, SocketWrapperBase.COMPLETE_WRITE_WITH_COMPLETION,
-                    new CompletionHandler<Long, Void>() {
+            socketWrapper.write(block ? BlockingMode.BLOCK : BlockingMode.SEMI_BLOCK, timeout, TimeUnit.MILLISECONDS,
+                    null, SocketWrapperBase.COMPLETE_WRITE_WITH_COMPLETION, new CompletionHandler<Long, Void>() {
                         @Override
                         public void completed(Long result, Void attachment) {
                             if (block) {
@@ -107,6 +104,7 @@ public class WsRemoteEndpointImplServer extends WsRemoteEndpointImplBase {
                                 clearHandler(null, true);
                             }
                         }
+
                         @Override
                         public void failed(Throwable exc, Void attachment) {
                             if (block) {
@@ -239,11 +237,9 @@ public class WsRemoteEndpointImplServer extends WsRemoteEndpointImplBase {
 
 
     /*
-     * Currently this is only called from the background thread so we could just
-     * call clearHandler() with useDispatch == false but the method parameter
-     * was added in case other callers started to use this method to make sure
-     * that those callers think through what the correct value of useDispatch is
-     * for them.
+     * Currently this is only called from the background thread so we could just call clearHandler() with useDispatch ==
+     * false but the method parameter was added in case other callers started to use this method to make sure that those
+     * callers think through what the correct value of useDispatch is for them.
      */
     protected void onTimeout(boolean useDispatch) {
         if (handler != null) {
@@ -261,12 +257,9 @@ public class WsRemoteEndpointImplServer extends WsRemoteEndpointImplBase {
 
 
     /**
-     * @param t             The throwable associated with any error that
-     *                      occurred
-     * @param useDispatch   Should {@link SendHandler#onResult(SendResult)} be
-     *                      called from a new thread, keeping in mind the
-     *                      requirements of
-     *                      {@link jakarta.websocket.RemoteEndpoint.Async}
+     * @param t           The throwable associated with any error that occurred
+     * @param useDispatch Should {@link SendHandler#onResult(SendResult)} be called from a new thread, keeping in mind
+     *                        the requirements of {@link jakarta.websocket.RemoteEndpoint.Async}
      */
     void clearHandler(Throwable t, boolean useDispatch) {
         // Setting the result marks this (partial) message as

==================================================
WsServerContainer.java
index b27808607d..434602ad6c 100644
--- a/java/org/apache/tomcat/websocket/server/WsSci.java
+++ b/java/org/apache/tomcat/websocket/server/WsSci.java
@@ -32,17 +32,14 @@ import jakarta.websocket.server.ServerEndpoint;
 import jakarta.websocket.server.ServerEndpointConfig;
 
 /**
- * Registers an interest in any class that is annotated with
- * {@link ServerEndpoint} so that Endpoint can be published via the WebSocket
- * server.
+ * Registers an interest in any class that is annotated with {@link ServerEndpoint} so that Endpoint can be published
+ * via the WebSocket server.
  */
-@HandlesTypes({ServerEndpoint.class, ServerApplicationConfig.class,
-        Endpoint.class})
+@HandlesTypes({ ServerEndpoint.class, ServerApplicationConfig.class, Endpoint.class })
 public class WsSci implements ServletContainerInitializer {
 
     @Override
-    public void onStartup(Set<Class<?>> clazzes, ServletContext ctx)
-            throws ServletException {
+    public void onStartup(Set<Class<?>> clazzes, ServletContext ctx) throws ServletException {
 
         WsServerContainer sc = init(ctx, true);
 
@@ -61,10 +58,8 @@ public class WsSci implements ServletContainerInitializer {
             wsPackage = wsPackage.substring(0, wsPackage.lastIndexOf('.') + 1);
             for (Class<?> clazz : clazzes) {
                 int modifiers = clazz.getModifiers();
-                if (!Modifier.isPublic(modifiers) ||
-                        Modifier.isAbstract(modifiers) ||
-                        Modifier.isInterface(modifiers) ||
-                        !isExported(clazz)) {
+                if (!Modifier.isPublic(modifiers) || Modifier.isAbstract(modifiers) ||
+                        Modifier.isInterface(modifiers) || !isExported(clazz)) {
                     // Non-public, abstract, interface or not in an exported
                     // package - skip it.
                     continue;
@@ -74,13 +69,11 @@ public class WsSci implements ServletContainerInitializer {
                     continue;
                 }
                 if (ServerApplicationConfig.class.isAssignableFrom(clazz)) {
-                    serverApplicationConfigs.add(
-                            (ServerApplicationConfig) clazz.getConstructor().newInstance());
+                    serverApplicationConfigs.add((ServerApplicationConfig) clazz.getConstructor().newInstance());
                 }
                 if (Endpoint.class.isAssignableFrom(clazz)) {
                     @SuppressWarnings("unchecked")
-                    Class<? extends Endpoint> endpoint =
-                            (Class<? extends Endpoint>) clazz;
+                    Class<? extends Endpoint> endpoint = (Class<? extends Endpoint>) clazz;
                     scannedEndpointClazzes.add(endpoint);
                 }
                 if (clazz.isAnnotationPresent(ServerEndpoint.class)) {
@@ -99,14 +92,11 @@ public class WsSci implements ServletContainerInitializer {
             filteredPojoEndpoints.addAll(scannedPojoEndpoints);
         } else {
             for (ServerApplicationConfig config : serverApplicationConfigs) {
-                Set<ServerEndpointConfig> configFilteredEndpoints =
-                        config.getEndpointConfigs(scannedEndpointClazzes);
+                Set<ServerEndpointConfig> configFilteredEndpoints = config.getEndpointConfigs(scannedEndpointClazzes);
                 if (configFilteredEndpoints != null) {
                     filteredEndpointConfigs.addAll(configFilteredEndpoints);
                 }
-                Set<Class<?>> configFilteredPojos =
-                        config.getAnnotatedEndpointClasses(
-                                scannedPojoEndpoints);
+                Set<Class<?>> configFilteredPojos = config.getAnnotatedEndpointClasses(scannedPojoEndpoints);
                 if (configFilteredPojos != null) {
                     filteredPojoEndpoints.addAll(configFilteredPojos);
                 }
@@ -135,13 +125,11 @@ public class WsSci implements ServletContainerInitializer {
     }
 
 
-    static WsServerContainer init(ServletContext servletContext,
-            boolean initBySciMechanism) {
+    static WsServerContainer init(ServletContext servletContext, boolean initBySciMechanism) {
 
         WsServerContainer sc = new WsServerContainer(servletContext);
 
-        servletContext.setAttribute(
-                Constants.SERVER_CONTAINER_SERVLET_CONTEXT_ATTRIBUTE, sc);
+        servletContext.setAttribute(Constants.SERVER_CONTAINER_SERVLET_CONTEXT_ATTRIBUTE, sc);
 
         servletContext.addListener(new WsSessionListener(sc));
         // Can't register the ContextListener again if the ContextListener is

==================================================
WsSessionListener.java
index 27533e97f9..b33fa50bda 100644
--- a/java/org/apache/tomcat/websocket/server/WsServerContainer.java
+++ b/java/org/apache/tomcat/websocket/server/WsServerContainer.java
@@ -49,32 +49,26 @@ import org.apache.tomcat.websocket.WsWebSocketContainer;
 import org.apache.tomcat.websocket.pojo.PojoMethodMapping;
 
 /**
- * Provides a per class loader (i.e. per web application) instance of a
- * ServerContainer. Web application wide defaults may be configured by setting
- * the following servlet context initialisation parameters to the desired
- * values.
+ * Provides a per class loader (i.e. per web application) instance of a ServerContainer. Web application wide defaults
+ * may be configured by setting the following servlet context initialisation parameters to the desired values.
  * <ul>
  * <li>{@link Constants#BINARY_BUFFER_SIZE_SERVLET_CONTEXT_INIT_PARAM}</li>
  * <li>{@link Constants#TEXT_BUFFER_SIZE_SERVLET_CONTEXT_INIT_PARAM}</li>
  * </ul>
  */
-public class WsServerContainer extends WsWebSocketContainer
-        implements ServerContainer {
+public class WsServerContainer extends WsWebSocketContainer implements ServerContainer {
 
     private static final StringManager sm = StringManager.getManager(WsServerContainer.class);
 
-    private static final CloseReason AUTHENTICATED_HTTP_SESSION_CLOSED =
-            new CloseReason(CloseCodes.VIOLATED_POLICY,
-                    "This connection was established under an authenticated " +
-                    "HTTP session that has ended.");
+    private static final CloseReason AUTHENTICATED_HTTP_SESSION_CLOSED = new CloseReason(CloseCodes.VIOLATED_POLICY,
+            "This connection was established under an authenticated " + "HTTP session that has ended.");
 
     private final WsWriteTimeout wsWriteTimeout = new WsWriteTimeout();
 
     private final ServletContext servletContext;
-    private final Map<String,ExactPathMatch> configExactMatchMap = new ConcurrentHashMap<>();
-    private final Map<Integer,ConcurrentSkipListMap<String,TemplatePathMatch>> configTemplateMatchMap =
-            new ConcurrentHashMap<>();
-    private final Map<String,Set<WsSession>> authenticatedSessions = new ConcurrentHashMap<>();
+    private final Map<String, ExactPathMatch> configExactMatchMap = new ConcurrentHashMap<>();
+    private final Map<Integer, ConcurrentSkipListMap<String, TemplatePathMatch>> configTemplateMatchMap = new ConcurrentHashMap<>();
+    private final Map<String, Set<WsSession>> authenticatedSessions = new ConcurrentHashMap<>();
     private volatile boolean endpointsRegistered = false;
     private volatile boolean deploymentFailed = false;
 
@@ -84,37 +78,32 @@ public class WsServerContainer extends WsWebSocketContainer
         setInstanceManager((InstanceManager) servletContext.getAttribute(InstanceManager.class.getName()));
 
         // Configure servlet context wide defaults
-        String value = servletContext.getInitParameter(
-                Constants.BINARY_BUFFER_SIZE_SERVLET_CONTEXT_INIT_PARAM);
+        String value = servletContext.getInitParameter(Constants.BINARY_BUFFER_SIZE_SERVLET_CONTEXT_INIT_PARAM);
         if (value != null) {
             setDefaultMaxBinaryMessageBufferSize(Integer.parseInt(value));
         }
 
-        value = servletContext.getInitParameter(
-                Constants.TEXT_BUFFER_SIZE_SERVLET_CONTEXT_INIT_PARAM);
+        value = servletContext.getInitParameter(Constants.TEXT_BUFFER_SIZE_SERVLET_CONTEXT_INIT_PARAM);
         if (value != null) {
             setDefaultMaxTextMessageBufferSize(Integer.parseInt(value));
         }
 
-        FilterRegistration.Dynamic fr = servletContext.addFilter(
-                "Tomcat WebSocket (JSR356) Filter", new WsFilter());
+        FilterRegistration.Dynamic fr = servletContext.addFilter("Tomcat WebSocket (JSR356) Filter", new WsFilter());
         fr.setAsyncSupported(true);
 
-        EnumSet<DispatcherType> types = EnumSet.of(DispatcherType.REQUEST,
-                DispatcherType.FORWARD);
+        EnumSet<DispatcherType> types = EnumSet.of(DispatcherType.REQUEST, DispatcherType.FORWARD);
 
         fr.addMappingForUrlPatterns(types, true, "/*");
     }
 
 
     /**
-     * Published the provided endpoint implementation at the specified path with
-     * the specified configuration. {@link #WsServerContainer(ServletContext)}
-     * must be called before calling this method.
+     * Published the provided endpoint implementation at the specified path with the specified configuration.
+     * {@link #WsServerContainer(ServletContext)} must be called before calling this method.
      *
-     * @param sec   The configuration to use when creating endpoint instances
-     * @throws DeploymentException if the endpoint cannot be published as
-     *         requested
+     * @param sec The configuration to use when creating endpoint instances
+     *
+     * @throws DeploymentException if the endpoint cannot be published as requested
      */
     @Override
     public void addEndpoint(ServerEndpointConfig sec) throws DeploymentException {
@@ -125,8 +114,7 @@ public class WsServerContainer extends WsWebSocketContainer
     void addEndpoint(ServerEndpointConfig sec, boolean fromAnnotatedPojo) throws DeploymentException {
 
         if (servletContext == null) {
-            throw new DeploymentException(
-                    sm.getString("serverContainer.servletContextMissing"));
+            throw new DeploymentException(sm.getString("serverContainer.servletContextMissing"));
         }
 
         if (deploymentFailed) {
@@ -138,10 +126,10 @@ public class WsServerContainer extends WsWebSocketContainer
             String path = sec.getPath();
 
             // Add method mapping to user properties
-            PojoMethodMapping methodMapping = new PojoMethodMapping(sec.getEndpointClass(),
-                    sec.getDecoders(), path, getInstanceManager(Thread.currentThread().getContextClassLoader()));
-            if (methodMapping.getOnClose() != null || methodMapping.getOnOpen() != null
-                    || methodMapping.getOnError() != null || methodMapping.hasMessageHandlers()) {
+            PojoMethodMapping methodMapping = new PojoMethodMapping(sec.getEndpointClass(), sec.getDecoders(), path,
+                    getInstanceManager(Thread.currentThread().getContextClassLoader()));
+            if (methodMapping.getOnClose() != null || methodMapping.getOnOpen() != null ||
+                    methodMapping.getOnError() != null || methodMapping.hasMessageHandlers()) {
                 sec.getUserProperties().put(org.apache.tomcat.websocket.pojo.Constants.POJO_METHOD_MAPPING_KEY,
                         methodMapping);
             }
@@ -149,8 +137,7 @@ public class WsServerContainer extends WsWebSocketContainer
             UriTemplate uriTemplate = new UriTemplate(path);
             if (uriTemplate.hasParameters()) {
                 Integer key = Integer.valueOf(uriTemplate.getSegmentCount());
-                ConcurrentSkipListMap<String,TemplatePathMatch> templateMatches =
-                        configTemplateMatchMap.get(key);
+                ConcurrentSkipListMap<String, TemplatePathMatch> templateMatches = configTemplateMatchMap.get(key);
                 if (templateMatches == null) {
                     // Ensure that if concurrent threads execute this block they
                     // all end up using the same ConcurrentSkipListMap instance
@@ -162,17 +149,15 @@ public class WsServerContainer extends WsWebSocketContainer
                 TemplatePathMatch oldMatch = templateMatches.putIfAbsent(uriTemplate.getNormalizedPath(), newMatch);
                 if (oldMatch != null) {
                     // Note: This depends on Endpoint instances being added
-                    //       before POJOs in WsSci#onStartup()
+                    // before POJOs in WsSci#onStartup()
                     if (oldMatch.isFromAnnotatedPojo() && !newMatch.isFromAnnotatedPojo() &&
                             oldMatch.getConfig().getEndpointClass() == newMatch.getConfig().getEndpointClass()) {
                         // The WebSocket spec says to ignore the new match in this case
                         templateMatches.put(path, oldMatch);
                     } else {
                         // Duplicate uriTemplate;
-                        throw new DeploymentException(
-                                sm.getString("serverContainer.duplicatePaths", path,
-                                             sec.getEndpointClass(),
-                                             sec.getEndpointClass()));
+                        throw new DeploymentException(sm.getString("serverContainer.duplicatePaths", path,
+                                sec.getEndpointClass(), sec.getEndpointClass()));
                     }
                 }
             } else {
@@ -181,17 +166,15 @@ public class WsServerContainer extends WsWebSocketContainer
                 ExactPathMatch oldMatch = configExactMatchMap.put(path, newMatch);
                 if (oldMatch != null) {
                     // Note: This depends on Endpoint instances being added
-                    //       before POJOs in WsSci#onStartup()
+                    // before POJOs in WsSci#onStartup()
                     if (oldMatch.isFromAnnotatedPojo() && !newMatch.isFromAnnotatedPojo() &&
                             oldMatch.getConfig().getEndpointClass() == newMatch.getConfig().getEndpointClass()) {
                         // The WebSocket spec says to ignore the new match in this case
                         configExactMatchMap.put(path, oldMatch);
                     } else {
                         // Duplicate path mappings
-                        throw new DeploymentException(
-                                sm.getString("serverContainer.duplicatePaths", path,
-                                             oldMatch.getConfig().getEndpointClass(),
-                                             sec.getEndpointClass()));
+                        throw new DeploymentException(sm.getString("serverContainer.duplicatePaths", path,
+                                oldMatch.getConfig().getEndpointClass(), sec.getEndpointClass()));
                     }
                 }
             }
@@ -205,11 +188,10 @@ public class WsServerContainer extends WsWebSocketContainer
 
 
     /**
-     * Provides the equivalent of {@link #addEndpoint(ServerEndpointConfig)}
-     * for publishing plain old java objects (POJOs) that have been annotated as
-     * WebSocket endpoints.
+     * Provides the equivalent of {@link #addEndpoint(ServerEndpointConfig)} for publishing plain old java objects
+     * (POJOs) that have been annotated as WebSocket endpoints.
      *
-     * @param pojo   The annotated POJO
+     * @param pojo The annotated POJO
      */
     @Override
     public void addEndpoint(Class<?> pojo) throws DeploymentException {
@@ -229,9 +211,7 @@ public class WsServerContainer extends WsWebSocketContainer
         try {
             ServerEndpoint annotation = pojo.getAnnotation(ServerEndpoint.class);
             if (annotation == null) {
-                throw new DeploymentException(
-                        sm.getString("serverContainer.missingAnnotation",
-                                pojo.getName()));
+                throw new DeploymentException(sm.getString("serverContainer.missingAnnotation", pojo.getName()));
             }
             String path = annotation.value();
 
@@ -239,25 +219,19 @@ public class WsServerContainer extends WsWebSocketContainer
             validateEncoders(annotation.encoders(), getInstanceManager(Thread.currentThread().getContextClassLoader()));
 
             // ServerEndpointConfig
-            Class<? extends Configurator> configuratorClazz =
-                    annotation.configurator();
+            Class<? extends Configurator> configuratorClazz = annotation.configurator();
             Configurator configurator = null;
             if (!configuratorClazz.equals(Configurator.class)) {
                 try {
                     configurator = annotation.configurator().getConstructor().newInstance();
                 } catch (ReflectiveOperationException e) {
-                    throw new DeploymentException(sm.getString(
-                            "serverContainer.configuratorFail",
-                            annotation.configurator().getName(),
-                            pojo.getClass().getName()), e);
+                    throw new DeploymentException(sm.getString("serverContainer.configuratorFail",
+                            annotation.configurator().getName(), pojo.getClass().getName()), e);
                 }
             }
-            sec = ServerEndpointConfig.Builder.create(pojo, path).
-                    decoders(Arrays.asList(annotation.decoders())).
-                    encoders(Arrays.asList(annotation.encoders())).
-                    subprotocols(Arrays.asList(annotation.subprotocols())).
-                    configurator(configurator).
-                    build();
+            sec = ServerEndpointConfig.Builder.create(pojo, path).decoders(Arrays.asList(annotation.decoders()))
+                    .encoders(Arrays.asList(annotation.encoders()))
+                    .subprotocols(Arrays.asList(annotation.subprotocols())).configurator(configurator).build();
         } catch (DeploymentException de) {
             failDeployment();
             throw de;
@@ -283,12 +257,11 @@ public class WsServerContainer extends WsWebSocketContainer
 
 
     @Override
-    public void upgradeHttpToWebSocket(Object httpServletRequest, Object httpServletResponse,
-            ServerEndpointConfig sec, Map<String, String> pathParameters)
-            throws IOException, DeploymentException {
+    public void upgradeHttpToWebSocket(Object httpServletRequest, Object httpServletResponse, ServerEndpointConfig sec,
+            Map<String, String> pathParameters) throws IOException, DeploymentException {
         try {
-            UpgradeUtil.doUpgrade(this, (HttpServletRequest) httpServletRequest, (HttpServletResponse) httpServletResponse,
-                    sec, pathParameters);
+            UpgradeUtil.doUpgrade(this, (HttpServletRequest) httpServletRequest,
+                    (HttpServletResponse) httpServletResponse, sec, pathParameters);
         } catch (ServletException e) {
             throw new DeploymentException(e.getMessage(), e);
         }
@@ -314,7 +287,7 @@ public class WsServerContainer extends WsWebSocketContainer
 
         // Number of segments has to match
         Integer key = Integer.valueOf(pathUriTemplate.getSegmentCount());
-        ConcurrentSkipListMap<String,TemplatePathMatch> templateMatches = configTemplateMatchMap.get(key);
+        ConcurrentSkipListMap<String, TemplatePathMatch> templateMatches = configTemplateMatchMap.get(key);
 
         if (templateMatches == null) {
             // No templates with an equal number of segments so there will be
@@ -325,7 +298,7 @@ public class WsServerContainer extends WsWebSocketContainer
         // List is in alphabetical order of normalised templates.
         // Correct match is the first one that matches.
         ServerEndpointConfig sec = null;
-        Map<String,String> pathParams = null;
+        Map<String, String> pathParams = null;
         for (TemplatePathMatch templateMatch : templateMatches.values()) {
             pathParams = templateMatch.getUriTemplate().match(pathUriTemplate);
             if (pathParams != null) {
@@ -349,9 +322,7 @@ public class WsServerContainer extends WsWebSocketContainer
 
 
     /**
-     * {@inheritDoc}
-     *
-     * Overridden to make it visible to other classes in this package.
+     * {@inheritDoc} Overridden to make it visible to other classes in this package.
      */
     @Override
     protected InstanceManager getInstanceManager(ClassLoader classLoader) {
@@ -360,40 +331,30 @@ public class WsServerContainer extends WsWebSocketContainer
 
 
     /**
-     * {@inheritDoc}
-     *
-     * Overridden to make it visible to other classes in this package.
+     * {@inheritDoc} Overridden to make it visible to other classes in this package.
      */
     @Override
     protected void registerSession(Object key, WsSession wsSession) {
         super.registerSession(key, wsSession);
-        if (wsSession.isOpen() &&
-                wsSession.getUserPrincipal() != null &&
-                wsSession.getHttpSessionId() != null) {
-            registerAuthenticatedSession(wsSession,
-                    wsSession.getHttpSessionId());
+        if (wsSession.isOpen() && wsSession.getUserPrincipal() != null && wsSession.getHttpSessionId() != null) {
+            registerAuthenticatedSession(wsSession, wsSession.getHttpSessionId());
         }
     }
 
 
     /**
-     * {@inheritDoc}
-     *
-     * Overridden to make it visible to other classes in this package.
+     * {@inheritDoc} Overridden to make it visible to other classes in this package.
      */
     @Override
     protected void unregisterSession(Object key, WsSession wsSession) {
-        if (wsSession.getUserPrincipal() != null &&
-                wsSession.getHttpSessionId() != null) {
-            unregisterAuthenticatedSession(wsSession,
-                    wsSession.getHttpSessionId());
+        if (wsSession.getUserPrincipal() != null && wsSession.getHttpSessionId() != null) {
+            unregisterAuthenticatedSession(wsSession, wsSession.getHttpSessionId());
         }
         super.unregisterSession(key, wsSession);
     }
 
 
-    private void registerAuthenticatedSession(WsSession wsSession,
-            String httpSessionId) {
+    private void registerAuthenticatedSession(WsSession wsSession, String httpSessionId) {
         Set<WsSession> wsSessions = authenticatedSessions.get(httpSessionId);
         if (wsSessions == null) {
             wsSessions = ConcurrentHashMap.newKeySet();
@@ -404,8 +365,7 @@ public class WsServerContainer extends WsWebSocketContainer
     }
 
 
-    private void unregisterAuthenticatedSession(WsSession wsSession,
-            String httpSessionId) {
+    private void unregisterAuthenticatedSession(WsSession wsSession, String httpSessionId) {
         Set<WsSession> wsSessions = authenticatedSessions.get(httpSessionId);
         // wsSessions will be null if the HTTP session has ended
         if (wsSessions != null) {
@@ -445,9 +405,8 @@ public class WsServerContainer extends WsWebSocketContainer
                     instance = (Encoder) instanceManager.newInstance(encoder);
                     instanceManager.destroyInstance(instance);
                 }
-            } catch(ReflectiveOperationException | NamingException e) {
-                throw new DeploymentException(sm.getString(
-                        "serverContainer.encoderFail", encoder.getName()), e);
+            } catch (ReflectiveOperationException | NamingException e) {
+                throw new DeploymentException(sm.getString("serverContainer.encoderFail", encoder.getName()), e);
             }
         }
     }
@@ -458,8 +417,7 @@ public class WsServerContainer extends WsWebSocketContainer
         private final UriTemplate uriTemplate;
         private final boolean fromAnnotatedPojo;
 
-        TemplatePathMatch(ServerEndpointConfig config, UriTemplate uriTemplate,
-                boolean fromAnnotatedPojo) {
+        TemplatePathMatch(ServerEndpointConfig config, UriTemplate uriTemplate, boolean fromAnnotatedPojo) {
             this.config = config;
             this.uriTemplate = uriTemplate;
             this.fromAnnotatedPojo = fromAnnotatedPojo;

==================================================
WsWriteTimeout.java
index 63016249b8..c3cd48febf 100644
--- a/java/org/apache/tomcat/websocket/server/WsSessionListener.java
+++ b/java/org/apache/tomcat/websocket/server/WsSessionListener.java
@@ -19,7 +19,7 @@ package org.apache.tomcat.websocket.server;
 import jakarta.servlet.http.HttpSessionEvent;
 import jakarta.servlet.http.HttpSessionListener;
 
-public class WsSessionListener implements HttpSessionListener{
+public class WsSessionListener implements HttpSessionListener {
 
     private final WsServerContainer wsServerContainer;
 

==================================================
package-info.java
index eddaceac82..be5f23b6f8 100644
--- a/java/org/apache/tomcat/websocket/server/WsWriteTimeout.java
+++ b/java/org/apache/tomcat/websocket/server/WsWriteTimeout.java
@@ -25,18 +25,17 @@ import org.apache.tomcat.websocket.BackgroundProcess;
 import org.apache.tomcat.websocket.BackgroundProcessManager;
 
 /**
- * Provides timeouts for asynchronous web socket writes. On the server side we
- * only have access to {@link jakarta.servlet.ServletOutputStream} and
- * {@link jakarta.servlet.ServletInputStream} so there is no way to set a timeout
- * for writes to the client.
+ * Provides timeouts for asynchronous web socket writes. On the server side we only have access to
+ * {@link jakarta.servlet.ServletOutputStream} and {@link jakarta.servlet.ServletInputStream} so there is no way to set
+ * a timeout for writes to the client.
  */
 public class WsWriteTimeout implements BackgroundProcess {
 
     /**
      * Note: The comparator imposes orderings that are inconsistent with equals
      */
-    private final Set<WsRemoteEndpointImplServer> endpoints =
-            new ConcurrentSkipListSet<>(Comparator.comparingLong(WsRemoteEndpointImplServer::getTimeoutExpiry));
+    private final Set<WsRemoteEndpointImplServer> endpoints = new ConcurrentSkipListSet<>(
+            Comparator.comparingLong(WsRemoteEndpointImplServer::getTimeoutExpiry));
     private final AtomicInteger count = new AtomicInteger(0);
     private int backgroundProcessCount = 0;
     private volatile int processPeriod = 1;
@@ -44,7 +43,7 @@ public class WsWriteTimeout implements BackgroundProcess {
     @Override
     public void backgroundProcess() {
         // This method gets called once a second.
-        backgroundProcessCount ++;
+        backgroundProcessCount++;
 
         if (backgroundProcessCount >= processPeriod) {
             backgroundProcessCount = 0;
@@ -73,10 +72,7 @@ public class WsWriteTimeout implements BackgroundProcess {
 
 
     /**
-     * {@inheritDoc}
-     *
-     * The default value is 1 which means asynchronous write timeouts are
-     * processed every 1 second.
+     * {@inheritDoc} The default value is 1 which means asynchronous write timeouts are processed every 1 second.
      */
     @Override
     public int getProcessPeriod() {

==================================================
