7cd65e6f8cca0c9899874c843b814aa876fb87a0
==================================================
First pass at removing the BIO code. Some unused/unnecessary code remains and will be removed next.
==================================================
Mark Emlyn
==================================================
Tue Nov 4 15:53:34 2014 +0000
==================================================
InputBuffer.java
index bc216438b7..59697437a0 100644
--- a/build.xml
+++ b/build.xml
@@ -1337,17 +1337,11 @@
   <property name="junit.formatter.extension" value=".txt" />
 
   <target name="test" description="Runs the JUnit test cases"
-          depends="test-bio,test-nio,test-nio2,test-apr,cobertura-report" >
+          depends="test-nio,test-nio2,test-apr,cobertura-report" >
     <fail if="test.result.error" message='Some tests completed with an Error. See ${tomcat.build}/logs for details, search for "FAILED".' />
     <fail if="test.result.failure" message='Some tests completed with a Failure. See ${tomcat.build}/logs for details, search for "FAILED".' />
   </target>
 
-  <target name="test-bio" description="Runs the JUnit test cases for BIO. Does not stop on errors."
-          depends="test-compile,deploy,cobertura-instrument,test-openssl-exists" if="${execute.test.bio}">
-    <runtests protocol="org.apache.coyote.http11.Http11Protocol"
-              extension=".BIO" />
-  </target>
-
   <target name="test-nio" description="Runs the JUnit test cases for NIO. Does not stop on errors."
           depends="test-compile,deploy,cobertura-instrument,test-openssl-exists" if="${execute.test.nio}">
     <runtests protocol="org.apache.coyote.http11.Http11NioProtocol"
@@ -1498,7 +1492,7 @@
   </target>
 
   <target name="cobertura-report" if="${test.cobertura}"
-          depends="test-bio,test-nio,test-nio2,test-apr"
+          depends="test-nio,test-nio2,test-apr"
           description="Creates report from gathered Cobertura results">
 
     <cobertura-report srcdir="${basedir}/java" destdir="${cobertura.out}"

==================================================
AbstractProtocol.java
index a8f579787c..22b89f35ab 100644
--- a/java/org/apache/catalina/connector/InputBuffer.java
+++ b/java/org/apache/catalina/connector/InputBuffer.java
@@ -284,8 +284,6 @@ public class InputBuffer extends Reader
         if (coyoteRequest.getReadListener() == null) {
             throw new IllegalStateException("not in non blocking mode.");
         }
-        // Need to check is finished before we check available() as BIO always
-        // returns 1 for isAvailable()
         if (isFinished()) {
             // If this is a non-container thread, need to trigger a read
             // which will eventually lead to a call to onAllDataRead() via a

==================================================
AjpProcessor.java
index e4fee7f005..bfed8cc39e 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -84,7 +84,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
 
     /**
      * Endpoint that provides low-level network I/O - must be matched to the
-     * ProtocolHandler implementation (ProtocolHandler using BIO, requires BIO
+     * ProtocolHandler implementation (ProtocolHandler using NIO, requires NIO
      * Endpoint etc.).
      */
     protected AbstractEndpoint<S> endpoint = null;

==================================================
AjpProtocol.java
deleted file mode 100644
index adc090b3ae..0000000000
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.ajp;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Socket;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.net.JIoEndpoint;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-/**
- * Processes AJP requests.
- *
- * @author Remy Maucherat
- * @author Henri Gomez
- * @author Dan Milstein
- * @author Keith Wannamaker
- * @author Kevin Seguin
- * @author Costin Manolache
- */
-public class AjpProcessor extends AbstractAjpProcessor<Socket> {
-
-    private static final Log log = LogFactory.getLog(AjpProcessor.class);
-    @Override
-    protected Log getLog() {
-        return log;
-    }
-
-
-    public AjpProcessor(int packetSize, JIoEndpoint endpoint) {
-
-        super(packetSize, endpoint);
-
-        response.setOutputBuffer(new SocketOutputBuffer());
-    }
-
-
-    protected InputStream input;
-
-    protected OutputStream output;
-
-
-    @Override
-    public void recycle(boolean socketClosing) {
-        super.recycle(socketClosing);
-        if (socketClosing) {
-            input = null;
-            output = null;
-        }
-    }
-
-
-    @Override
-    protected void registerForEvent(boolean read, boolean write) {
-        // NO-OP for BIO
-    }
-
-    @Override
-    protected void resetTimeouts() {
-        // NO-OP. The AJP BIO connector only uses the timeout value on the
-        //        SocketWrapper for async timeouts.
-    }
-
-
-    @Override
-    protected void setupSocket(SocketWrapper<Socket> socketWrapper)
-            throws IOException {
-        input = socketWrapper.getSocket().getInputStream();
-        output = socketWrapper.getSocket().getOutputStream();
-    }
-
-
-    @Override
-    protected void setTimeout(SocketWrapper<Socket> socketWrapper,
-            int timeout) throws IOException {
-        socketWrapper.getSocket().setSoTimeout(timeout);
-    }
-
-
-    @Override
-    protected int output(byte[] src, int offset, int length, boolean block)
-            throws IOException {
-        output.write(src, offset, length);
-        return length;
-    }
-
-
-    @Override
-    protected boolean read(byte[] buf, int pos, int n, boolean blockFirstRead)
-        throws IOException {
-
-        int read = 0;
-        int res = 0;
-        while (read < n) {
-            res = input.read(buf, read + pos, n - read);
-            if (res > 0) {
-                read += res;
-            } else {
-                throw new IOException(sm.getString("ajpprocessor.failedread"));
-            }
-        }
-
-        return true;
-    }
-}

==================================================
Http11Processor.java
deleted file mode 100644
index 8cf946ba89..0000000000
--- a/java/org/apache/coyote/ajp/AjpProtocol.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.ajp;
-
-import java.net.Socket;
-
-import org.apache.coyote.AbstractProtocol;
-import org.apache.coyote.Processor;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.net.AbstractEndpoint;
-import org.apache.tomcat.util.net.JIoEndpoint;
-import org.apache.tomcat.util.net.JIoEndpoint.Handler;
-import org.apache.tomcat.util.net.SSLImplementation;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-
-/**
- * Abstract the protocol implementation, including threading, etc.
- * Processor is single threaded and specific to stream-based protocols,
- * will not fit Jk protocols like JNI.
- *
- * @author Remy Maucherat
- * @author Costin Manolache
- */
-public class AjpProtocol extends AbstractAjpProtocol<Socket> {
-
-
-    private static final Log log = LogFactory.getLog(AjpProtocol.class);
-
-    @Override
-    protected Log getLog() { return log; }
-
-
-    @Override
-    protected AbstractEndpoint.Handler getHandler() {
-        return cHandler;
-    }
-
-
-    // ------------------------------------------------------------ Constructor
-
-
-    public AjpProtocol() {
-        endpoint = new JIoEndpoint();
-        cHandler = new AjpConnectionHandler(this);
-        ((JIoEndpoint) endpoint).setHandler(cHandler);
-        setSoLinger(Constants.DEFAULT_CONNECTION_LINGER);
-        setSoTimeout(Constants.DEFAULT_CONNECTION_TIMEOUT);
-        setTcpNoDelay(Constants.DEFAULT_TCP_NO_DELAY);
-    }
-
-
-    // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * Connection handler for AJP.
-     */
-    private final AjpConnectionHandler cHandler;
-
-
-    // ----------------------------------------------------- JMX related methods
-
-    @Override
-    protected String getNamePrefix() {
-        return ("ajp-bio");
-    }
-
-
-    // --------------------------------------  AjpConnectionHandler Inner Class
-
-
-    protected static class AjpConnectionHandler
-            extends AbstractAjpConnectionHandler<Socket,AjpProcessor>
-            implements Handler {
-
-        protected final AjpProtocol proto;
-
-        public AjpConnectionHandler(AjpProtocol proto) {
-            this.proto = proto;
-        }
-
-        @Override
-        protected AbstractProtocol<Socket> getProtocol() {
-            return proto;
-        }
-
-        @Override
-        protected Log getLog() {
-            return log;
-        }
-
-        @Override
-        public SSLImplementation getSslImplementation() {
-            // AJP does not support SSL
-            return null;
-        }
-
-        /**
-         * Expected to be used by the handler once the processor is no longer
-         * required.
-         *
-         * @param socket            Ignored for BIO
-         * @param processor
-         * @param isSocketClosing
-         * @param addToPoller       Ignored for BIO
-         */
-        @Override
-        public void release(SocketWrapper<Socket> socket,
-                Processor<Socket> processor, boolean isSocketClosing,
-                boolean addToPoller) {
-            processor.recycle(isSocketClosing);
-            recycledProcessors.push(processor);
-        }
-
-
-        @Override
-        protected AjpProcessor createProcessor() {
-            AjpProcessor processor = new AjpProcessor(proto.packetSize, (JIoEndpoint)proto.endpoint);
-            proto.configureProcessor(processor);
-            register(processor);
-            return processor;
-        }
-
-        @Override
-        public void beforeHandshake(SocketWrapper<Socket> socket) {
-        }
-    }
-}

==================================================
Http11Protocol.java
deleted file mode 100644
index 6d56db138d..0000000000
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ /dev/null
@@ -1,396 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.Socket;
-
-import org.apache.coyote.ActionCode;
-import org.apache.coyote.http11.filters.BufferedInputFilter;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.net.JIoEndpoint;
-import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-
-/**
- * Processes HTTP requests.
- *
- * @author Remy Maucherat
- */
-public class Http11Processor extends AbstractHttp11Processor<Socket> {
-
-    private static final Log log = LogFactory.getLog(Http11Processor.class);
-    @Override
-    protected Log getLog() {
-        return log;
-    }
-
-   // ------------------------------------------------------------ Constructor
-
-
-    public Http11Processor(int headerBufferSize, JIoEndpoint endpoint,
-            int maxTrailerSize, int maxExtensionSize, int maxSwallowSize) {
-
-        super(endpoint);
-
-        inputBuffer = new InternalInputBuffer(request, headerBufferSize);
-        request.setInputBuffer(inputBuffer);
-
-        outputBuffer = new InternalOutputBuffer(response, headerBufferSize);
-        response.setOutputBuffer(outputBuffer);
-
-        initializeFilters(maxTrailerSize, maxExtensionSize, maxSwallowSize);
-    }
-
-
-    // ----------------------------------------------------- Instance Variables
-
-    /**
-     * SSL information.
-     */
-    protected SSLSupport sslSupport;
-
-
-    /**
-     * The percentage of threads that have to be in use before keep-alive is
-     * disabled to aid scalability.
-     */
-    private int disableKeepAlivePercentage = 75;
-
-    // --------------------------------------------------------- Public Methods
-
-
-    /**
-     * Set the SSL information for this HTTP connection.
-     */
-    @Override
-    public void setSslSupport(SSLSupport sslSupport) {
-        this.sslSupport = sslSupport;
-    }
-
-
-    public int getDisableKeepAlivePercentage() {
-        return disableKeepAlivePercentage;
-    }
-
-
-    public void setDisableKeepAlivePercentage(int disableKeepAlivePercentage) {
-        this.disableKeepAlivePercentage = disableKeepAlivePercentage;
-    }
-
-
-    @Override
-    protected boolean disableKeepAlive() {
-        int threadRatio = -1;
-        // These may return zero or negative values
-        // Only calculate a thread ratio when both are >0 to ensure we get a
-        // sensible result
-        int maxThreads, threadsBusy;
-        if ((maxThreads = endpoint.getMaxThreads()) > 0
-                && (threadsBusy = endpoint.getCurrentThreadsBusy()) > 0) {
-            threadRatio = (threadsBusy * 100) / maxThreads;
-        }
-        // Disable keep-alive if we are running low on threads
-        if (threadRatio > getDisableKeepAlivePercentage()) {
-            return true;
-        }
-
-        return false;
-    }
-
-
-    @Override
-    protected void setRequestLineReadTimeout() throws IOException {
-
-        /*
-         * When there is no data in the buffer and this is not the first
-         * request on this connection and timeouts are being used the
-         * first read for this request may need a different timeout to
-         * take account of time spent waiting for a processing thread.
-         *
-         * This is a little hacky but better than exposing the socket
-         * and the timeout info to the InputBuffer
-         */
-        if (inputBuffer.lastValid == 0 && socketWrapper.getLastAccess() > -1) {
-            int firstReadTimeout;
-            if (keepAliveTimeout == -1) {
-                firstReadTimeout = 0;
-            } else {
-                long queueTime =
-                    System.currentTimeMillis() - socketWrapper.getLastAccess();
-
-                if (queueTime >= keepAliveTimeout) {
-                    // Queued for longer than timeout but there might be
-                    // data so use shortest possible timeout
-                    firstReadTimeout = 1;
-                } else {
-                    // Cast is safe since queueTime must be less than
-                    // keepAliveTimeout which is an int
-                    firstReadTimeout = keepAliveTimeout - (int) queueTime;
-                }
-            }
-            socketWrapper.getSocket().setSoTimeout(firstReadTimeout);
-            // Blocking IO so fill() always blocks
-            if (!inputBuffer.fill(true)) {
-                throw new EOFException(sm.getString("iib.eof.error"));
-            }
-            // Once the first byte has been read, the standard timeout should be
-            // used so restore it here.
-            if (endpoint.getSoTimeout()> 0) {
-                setSocketTimeout(endpoint.getSoTimeout());
-            } else {
-                setSocketTimeout(0);
-            }
-        }
-    }
-
-
-    @Override
-    protected boolean handleIncompleteRequestLineRead() {
-        // Not used with BIO since it uses blocking reads
-        return false;
-    }
-
-
-    @Override
-    protected void setSocketTimeout(int timeout) throws IOException {
-        socketWrapper.getSocket().setSoTimeout(timeout);
-    }
-
-
-    @Override
-    protected boolean breakKeepAliveLoop(SocketWrapper<Socket> socketWrapper) {
-        openSocket = keepAlive;
-        // If we don't have a pipe-lined request allow this thread to be
-        // used by another connection
-        if (inputBuffer.lastValid == 0) {
-            return true;
-        }
-        return false;
-    }
-
-
-    @Override
-    protected void registerForEvent(boolean read, boolean write) {
-        // NO-OP for BIO
-    }
-
-    @Override
-    protected void resetTimeouts() {
-        // NO-OP for BIO
-    }
-
-
-    @Override
-    protected void recycleInternal() {
-        // Recycle
-        this.socketWrapper = null;
-        // Recycle ssl info
-        sslSupport = null;
-    }
-
-
-    // ----------------------------------------------------- ActionHook Methods
-
-    /**
-     * Send an action to the connector.
-     *
-     * @param actionCode Type of the action
-     * @param param Action parameter
-     */
-    @SuppressWarnings("incomplete-switch") // Other cases are handled by action()
-    @Override
-    public void actionInternal(ActionCode actionCode, Object param) {
-
-        switch (actionCode) {
-        case REQ_SSL_ATTRIBUTE: {
-            try {
-                if (sslSupport != null) {
-                    Object sslO = sslSupport.getCipherSuite();
-                    if (sslO != null)
-                        request.setAttribute
-                            (SSLSupport.CIPHER_SUITE_KEY, sslO);
-                    sslO = sslSupport.getPeerCertificateChain(false);
-                    if (sslO != null)
-                        request.setAttribute
-                            (SSLSupport.CERTIFICATE_KEY, sslO);
-                    sslO = sslSupport.getKeySize();
-                    if (sslO != null)
-                        request.setAttribute
-                            (SSLSupport.KEY_SIZE_KEY, sslO);
-                    sslO = sslSupport.getSessionId();
-                    if (sslO != null)
-                        request.setAttribute
-                            (SSLSupport.SESSION_ID_KEY, sslO);
-                    request.setAttribute(SSLSupport.SESSION_MGR, sslSupport);
-                }
-            } catch (Exception e) {
-                log.warn(sm.getString("http11processor.socket.ssl"), e);
-            }
-            break;
-        }
-        case REQ_HOST_ADDR_ATTRIBUTE: {
-            if (socketWrapper == null) {
-                request.remoteAddr().recycle();
-            } else {
-                if (socketWrapper.getRemoteAddr() == null) {
-                    InetAddress inetAddr = socketWrapper.getSocket().getInetAddress();
-                    if (inetAddr != null) {
-                        socketWrapper.setRemoteAddr(inetAddr.getHostAddress());
-                    }
-                }
-                request.remoteAddr().setString(socketWrapper.getRemoteAddr());
-            }
-            break;
-        }
-        case REQ_LOCAL_NAME_ATTRIBUTE: {
-            if (socketWrapper == null) {
-                request.localName().recycle();
-            } else {
-                if (socketWrapper.getLocalName() == null) {
-                    InetAddress inetAddr = socketWrapper.getSocket().getLocalAddress();
-                    if (inetAddr != null) {
-                        socketWrapper.setLocalName(inetAddr.getHostName());
-                    }
-                }
-                request.localName().setString(socketWrapper.getLocalName());
-            }
-            break;
-        }
-        case REQ_HOST_ATTRIBUTE: {
-            if (socketWrapper == null) {
-                request.remoteHost().recycle();
-            } else {
-                if (socketWrapper.getRemoteHost() == null) {
-                    InetAddress inetAddr = socketWrapper.getSocket().getInetAddress();
-                    if (inetAddr != null) {
-                        socketWrapper.setRemoteHost(inetAddr.getHostName());
-                    }
-                    if (socketWrapper.getRemoteHost() == null) {
-                        if (socketWrapper.getRemoteAddr() == null &&
-                                inetAddr != null) {
-                            socketWrapper.setRemoteAddr(inetAddr.getHostAddress());
-                        }
-                        if (socketWrapper.getRemoteAddr() != null) {
-                            socketWrapper.setRemoteHost(socketWrapper.getRemoteAddr());
-                        }
-                    }
-                }
-                request.remoteHost().setString(socketWrapper.getRemoteHost());
-            }
-            break;
-        }
-        case REQ_LOCAL_ADDR_ATTRIBUTE: {
-            if (socketWrapper == null) {
-                request.localAddr().recycle();
-            } else {
-                if (socketWrapper.getLocalAddr() == null) {
-                    socketWrapper.setLocalAddr(
-                            socketWrapper.getSocket().getLocalAddress().getHostAddress());
-                }
-                request.localAddr().setString(socketWrapper.getLocalAddr());
-            }
-            break;
-        }
-        case REQ_REMOTEPORT_ATTRIBUTE: {
-            if (socketWrapper == null) {
-                request.setRemotePort(0);
-            } else {
-                if (socketWrapper.getRemotePort() == -1) {
-                    socketWrapper.setRemotePort(socketWrapper.getSocket().getPort());
-                }
-                request.setRemotePort(socketWrapper.getRemotePort());
-            }
-            break;
-        }
-        case REQ_LOCALPORT_ATTRIBUTE: {
-            if (socketWrapper == null) {
-                request.setLocalPort(0);
-            } else {
-                if (socketWrapper.getLocalPort() == -1) {
-                    socketWrapper.setLocalPort(socketWrapper.getSocket().getLocalPort());
-                }
-                request.setLocalPort(socketWrapper.getLocalPort());
-            }
-            break;
-        }
-        case REQ_SSL_CERTIFICATE: {
-            if (sslSupport != null) {
-                /*
-                 * Consume and buffer the request body, so that it does not
-                 * interfere with the client's handshake messages
-                 */
-                InputFilter[] inputFilters = inputBuffer.getFilters();
-                ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])
-                    .setLimit(maxSavePostSize);
-                inputBuffer.addActiveFilter
-                    (inputFilters[Constants.BUFFERED_FILTER]);
-                try {
-                    Object sslO = sslSupport.getPeerCertificateChain(true);
-                    if( sslO != null) {
-                        request.setAttribute
-                            (SSLSupport.CERTIFICATE_KEY, sslO);
-                    }
-                } catch (Exception e) {
-                    log.warn(sm.getString("http11processor.socket.ssl"), e);
-                }
-            }
-            break;
-        }
-        }
-    }
-
-
-    // ------------------------------------------------------ Protected Methods
-
-
-    @Override
-    protected void prepareRequestInternal() {
-        // NOOP for BIO
-    }
-
-    @Override
-    protected boolean prepareSendfile(OutputFilter[] outputFilters) {
-        // Should never, ever call this code
-        Exception e = new Exception();
-        log.error(sm.getString("http11processor.neverused"), e);
-        return false;
-    }
-
-    @Override
-    protected AbstractInputBuffer<Socket> getInputBuffer() {
-        return inputBuffer;
-    }
-
-    @Override
-    protected AbstractOutputBuffer<Socket> getOutputBuffer() {
-        return outputBuffer;
-    }
-
-    /**
-     * Set the socket buffer flag.
-     */
-    @Override
-    public void setSocketBuffer(int socketBuffer) {
-        super.setSocketBuffer(socketBuffer);
-        outputBuffer.setSocketBuffer(socketBuffer);
-    }
-}

==================================================
InternalInputBuffer.java
deleted file mode 100644
index b1dbe47c6e..0000000000
--- a/java/org/apache/coyote/http11/Http11Protocol.java
+++ /dev/null
@@ -1,212 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11;
-
-import java.io.IOException;
-import java.net.Socket;
-import java.nio.ByteBuffer;
-
-import javax.servlet.http.HttpUpgradeHandler;
-
-import org.apache.coyote.AbstractProtocol;
-import org.apache.coyote.Processor;
-import org.apache.coyote.http11.upgrade.BioProcessor;
-import org.apache.juli.logging.Log;
-import org.apache.tomcat.util.net.AbstractEndpoint;
-import org.apache.tomcat.util.net.JIoEndpoint;
-import org.apache.tomcat.util.net.JIoEndpoint.Handler;
-import org.apache.tomcat.util.net.SSLImplementation;
-import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-
-/**
- * Abstract the protocol implementation, including threading, etc.
- * Processor is single threaded and specific to stream-based protocols,
- * will not fit Jk protocols like JNI.
- *
- * @author Remy Maucherat
- * @author Costin Manolache
- */
-public class Http11Protocol extends AbstractHttp11JsseProtocol<Socket> {
-
-
-    private static final org.apache.juli.logging.Log log
-        = org.apache.juli.logging.LogFactory.getLog(Http11Protocol.class);
-
-    @Override
-    protected Log getLog() { return log; }
-
-
-    @Override
-    protected AbstractEndpoint.Handler getHandler() {
-        return cHandler;
-    }
-
-
-    // ------------------------------------------------------------ Constructor
-
-
-    public Http11Protocol() {
-        endpoint = new JIoEndpoint();
-        cHandler = new Http11ConnectionHandler(this);
-        ((JIoEndpoint) endpoint).setHandler(cHandler);
-        setSoLinger(Constants.DEFAULT_CONNECTION_LINGER);
-        setSoTimeout(Constants.DEFAULT_CONNECTION_TIMEOUT);
-        setTcpNoDelay(Constants.DEFAULT_TCP_NO_DELAY);
-    }
-
-
-    // ----------------------------------------------------------------- Fields
-
-    private final Http11ConnectionHandler cHandler;
-
-
-    // ------------------------------------------------ HTTP specific properties
-    // ------------------------------------------ managed in the ProtocolHandler
-
-    private int disableKeepAlivePercentage = 75;
-    public int getDisableKeepAlivePercentage() {
-        return disableKeepAlivePercentage;
-    }
-    public void setDisableKeepAlivePercentage(int disableKeepAlivePercentage) {
-        if (disableKeepAlivePercentage < 0) {
-            this.disableKeepAlivePercentage = 0;
-        } else if (disableKeepAlivePercentage > 100) {
-            this.disableKeepAlivePercentage = 100;
-        } else {
-            this.disableKeepAlivePercentage = disableKeepAlivePercentage;
-        }
-    }
-
-    @Override
-    public void start() throws Exception {
-        super.start();
-        if (npnHandler != null) {
-            npnHandler.init(endpoint, 0, getAdapter());
-        }
-    }
-
-    // ----------------------------------------------------- JMX related methods
-
-    @Override
-    protected String getNamePrefix() {
-        return ("http-bio");
-    }
-
-
-    // -----------------------------------  Http11ConnectionHandler Inner Class
-
-    protected static class Http11ConnectionHandler
-            extends AbstractConnectionHandler<Socket, Http11Processor> implements Handler {
-
-        protected Http11Protocol proto;
-
-        Http11ConnectionHandler(Http11Protocol proto) {
-            this.proto = proto;
-        }
-
-        @Override
-        protected AbstractProtocol<Socket> getProtocol() {
-            return proto;
-        }
-
-        @Override
-        protected Log getLog() {
-            return log;
-        }
-
-        @Override
-        public SSLImplementation getSslImplementation() {
-            return proto.sslImplementation;
-        }
-
-        @Override
-        public SocketState process(SocketWrapper<Socket> socket,
-                SocketStatus status) {
-            if (proto.npnHandler != null) {
-                SocketState ss = proto.npnHandler.process(socket, status);
-                if (ss != SocketState.OPEN) {
-                    return ss;
-                }
-            }
-            return super.process(socket, status);
-        }
-
-        /**
-         * Expected to be used by the handler once the processor is no longer
-         * required.
-         *
-         * @param socket            Not used in BIO
-         * @param processor
-         * @param isSocketClosing   Not used in HTTP
-         * @param addToPoller       Not used in BIO
-         */
-        @Override
-        public void release(SocketWrapper<Socket> socket,
-                Processor<Socket> processor, boolean isSocketClosing,
-                boolean addToPoller) {
-            processor.recycle(isSocketClosing);
-            recycledProcessors.push(processor);
-        }
-
-        @Override
-        protected void initSsl(SocketWrapper<Socket> socket,
-                Processor<Socket> processor) {
-            if (proto.isSSLEnabled() && (proto.sslImplementation != null)) {
-                processor.setSslSupport(
-                        proto.sslImplementation.getSSLSupport(
-                                socket.getSocket()));
-            } else {
-                processor.setSslSupport(null);
-            }
-
-        }
-
-        @Override
-        protected void longPoll(SocketWrapper<Socket> socket,
-                Processor<Socket> processor) {
-            // NO-OP
-        }
-
-        @Override
-        protected Http11Processor createProcessor() {
-            Http11Processor processor = new Http11Processor(
-                    proto.getMaxHttpHeaderSize(), (JIoEndpoint)proto.endpoint,
-                    proto.getMaxTrailerSize(),proto.getMaxExtensionSize(),
-                    proto.getMaxSwallowSize());
-            proto.configureProcessor(processor);
-            // BIO specific configuration
-            processor.setDisableKeepAlivePercentage(proto.getDisableKeepAlivePercentage());
-            register(processor);
-            return processor;
-        }
-
-        @Override
-        protected Processor<Socket> createUpgradeProcessor(
-                SocketWrapper<Socket> socket, ByteBuffer leftoverInput,
-                HttpUpgradeHandler httpUpgradeProcessor)
-                throws IOException {
-            return new BioProcessor(socket, leftoverInput, httpUpgradeProcessor,
-                    proto.getUpgradeAsyncWriteBufferSize());
-        }
-
-        @Override
-        public void beforeHandshake(SocketWrapper<Socket> socket) {
-        }
-    }
-}

==================================================
InternalOutputBuffer.java
deleted file mode 100644
index cca628f4f8..0000000000
--- a/java/org/apache/coyote/http11/InternalInputBuffer.java
+++ /dev/null
@@ -1,592 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.Socket;
-import java.nio.charset.StandardCharsets;
-
-import org.apache.coyote.InputBuffer;
-import org.apache.coyote.Request;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.buf.ByteChunk;
-import org.apache.tomcat.util.buf.MessageBytes;
-import org.apache.tomcat.util.net.AbstractEndpoint;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-/**
- * Implementation of InputBuffer which provides HTTP request header parsing as
- * well as transfer decoding.
- *
- * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
- */
-public class InternalInputBuffer extends AbstractInputBuffer<Socket> {
-
-    private static final Log log = LogFactory.getLog(InternalInputBuffer.class);
-
-
-    /**
-     * Underlying input stream.
-     */
-    private InputStream inputStream;
-
-
-    /**
-     * Default constructor.
-     */
-    public InternalInputBuffer(Request request, int headerBufferSize) {
-
-        this.request = request;
-        headers = request.getMimeHeaders();
-
-        buf = new byte[headerBufferSize];
-
-        inputStreamInputBuffer = new InputStreamInputBuffer();
-
-        filterLibrary = new InputFilter[0];
-        activeFilters = new InputFilter[0];
-        lastActiveFilter = -1;
-
-        parsingHeader = true;
-        swallowInput = true;
-
-    }
-
-
-    /**
-     * Data is always available for blocking IO (if you wait long enough) so
-     * return a value of 1. Note that the actual value is never used it is only
-     * tested for == 0 or &gt; 0.
-     */
-    @Override
-    public int available() {
-        return 1;
-    }
-
-
-    /**
-     * Read the request line. This function is meant to be used during the
-     * HTTP request header parsing. Do NOT attempt to read the request body
-     * using it.
-     *
-     * @throws IOException If an exception occurs during the underlying socket
-     * read operations, or if the given buffer is not big enough to accommodate
-     * the whole line.
-     */
-    @Override
-    public boolean parseRequestLine(boolean useAvailableDataOnly)
-
-        throws IOException {
-
-        int start = 0;
-
-        //
-        // Skipping blank lines
-        //
-
-        byte chr = 0;
-        do {
-
-            // Read new bytes if needed
-            if (pos >= lastValid) {
-                if (!fill())
-                    throw new EOFException(sm.getString("iib.eof.error"));
-            }
-            // Set the start time once we start reading data (even if it is
-            // just skipping blank lines)
-            if (request.getStartTime() < 0) {
-                request.setStartTime(System.currentTimeMillis());
-            }
-            chr = buf[pos++];
-        } while ((chr == Constants.CR) || (chr == Constants.LF));
-
-        pos--;
-
-        // Mark the current buffer position
-        start = pos;
-
-        //
-        // Reading the method name
-        // Method name is always US-ASCII
-        //
-
-        boolean space = false;
-
-        while (!space) {
-
-            // Read new bytes if needed
-            if (pos >= lastValid) {
-                if (!fill())
-                    throw new EOFException(sm.getString("iib.eof.error"));
-            }
-
-            // Spec says no CR or LF in method name
-            if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) {
-                throw new IllegalArgumentException(
-                        sm.getString("iib.invalidmethod"));
-            }
-            // Spec says single SP but it also says be tolerant of HT
-            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
-                space = true;
-                request.method().setBytes(buf, start, pos - start);
-            }
-
-            pos++;
-
-        }
-
-
-        // Spec says single SP but also says be tolerant of multiple and/or HT
-        while (space) {
-            // Read new bytes if needed
-            if (pos >= lastValid) {
-                if (!fill())
-                    throw new EOFException(sm.getString("iib.eof.error"));
-            }
-            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
-                pos++;
-            } else {
-                space = false;
-            }
-        }
-
-        // Mark the current buffer position
-        start = pos;
-        int end = 0;
-        int questionPos = -1;
-
-        //
-        // Reading the URI
-        //
-
-        boolean eol = false;
-
-        while (!space) {
-
-            // Read new bytes if needed
-            if (pos >= lastValid) {
-                if (!fill())
-                    throw new EOFException(sm.getString("iib.eof.error"));
-            }
-
-            // Spec says single SP but it also says be tolerant of HT
-            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
-                space = true;
-                end = pos;
-            } else if ((buf[pos] == Constants.CR)
-                       || (buf[pos] == Constants.LF)) {
-                // HTTP/0.9 style request
-                eol = true;
-                space = true;
-                end = pos;
-            } else if ((buf[pos] == Constants.QUESTION)
-                       && (questionPos == -1)) {
-                questionPos = pos;
-            }
-
-            pos++;
-
-        }
-
-        if (questionPos >= 0) {
-            request.queryString().setBytes(buf, questionPos + 1,
-                                           end - questionPos - 1);
-            request.requestURI().setBytes(buf, start, questionPos - start);
-        } else {
-            request.requestURI().setBytes(buf, start, end - start);
-        }
-
-        // Spec says single SP but also says be tolerant of multiple and/or HT
-        while (space) {
-            // Read new bytes if needed
-            if (pos >= lastValid) {
-                if (!fill())
-                    throw new EOFException(sm.getString("iib.eof.error"));
-            }
-            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
-                pos++;
-            } else {
-                space = false;
-            }
-        }
-
-        // Mark the current buffer position
-        start = pos;
-        end = 0;
-
-        //
-        // Reading the protocol
-        // Protocol is always US-ASCII
-        //
-
-        while (!eol) {
-
-            // Read new bytes if needed
-            if (pos >= lastValid) {
-                if (!fill())
-                    throw new EOFException(sm.getString("iib.eof.error"));
-            }
-
-            if (buf[pos] == Constants.CR) {
-                end = pos;
-            } else if (buf[pos] == Constants.LF) {
-                if (end == 0)
-                    end = pos;
-                eol = true;
-            }
-
-            pos++;
-
-        }
-
-        if ((end - start) > 0) {
-            request.protocol().setBytes(buf, start, end - start);
-        } else {
-            request.protocol().setString("");
-        }
-
-        return true;
-
-    }
-
-
-    /**
-     * Parse the HTTP headers.
-     */
-    @Override
-    public boolean parseHeaders()
-        throws IOException {
-        if (!parsingHeader) {
-            throw new IllegalStateException(
-                    sm.getString("iib.parseheaders.ise.error"));
-        }
-
-        while (parseHeader()) {
-            // Loop until we run out of headers
-        }
-
-        parsingHeader = false;
-        end = pos;
-        return true;
-    }
-
-
-    /**
-     * Parse an HTTP header.
-     *
-     * @return false after reading a blank line (which indicates that the
-     * HTTP header parsing is done
-     */
-    @SuppressWarnings("null") // headerValue cannot be null
-    private boolean parseHeader()
-        throws IOException {
-
-        //
-        // Check for blank line
-        //
-
-        byte chr = 0;
-        while (true) {
-
-            // Read new bytes if needed
-            if (pos >= lastValid) {
-                if (!fill())
-                    throw new EOFException(sm.getString("iib.eof.error"));
-            }
-
-            chr = buf[pos];
-
-            if (chr == Constants.CR) {
-                // Skip
-            } else if (chr == Constants.LF) {
-                pos++;
-                return false;
-            } else {
-                break;
-            }
-
-            pos++;
-
-        }
-
-        // Mark the current buffer position
-        int start = pos;
-
-        //
-        // Reading the header name
-        // Header name is always US-ASCII
-        //
-
-        boolean colon = false;
-        MessageBytes headerValue = null;
-
-        while (!colon) {
-
-            // Read new bytes if needed
-            if (pos >= lastValid) {
-                if (!fill())
-                    throw new EOFException(sm.getString("iib.eof.error"));
-            }
-
-            if (buf[pos] == Constants.COLON) {
-                colon = true;
-                headerValue = headers.addValue(buf, start, pos - start);
-            } else if (!HTTP_TOKEN_CHAR[buf[pos]]) {
-                // If a non-token header is detected, skip the line and
-                // ignore the header
-                skipLine(start);
-                return true;
-            }
-
-            chr = buf[pos];
-            if ((chr >= Constants.A) && (chr <= Constants.Z)) {
-                buf[pos] = (byte) (chr - Constants.LC_OFFSET);
-            }
-
-            pos++;
-
-        }
-
-        // Mark the current buffer position
-        start = pos;
-        int realPos = pos;
-
-        //
-        // Reading the header value (which can be spanned over multiple lines)
-        //
-
-        boolean eol = false;
-        boolean validLine = true;
-
-        while (validLine) {
-
-            boolean space = true;
-
-            // Skipping spaces
-            while (space) {
-
-                // Read new bytes if needed
-                if (pos >= lastValid) {
-                    if (!fill())
-                        throw new EOFException(sm.getString("iib.eof.error"));
-                }
-
-                if ((buf[pos] == Constants.SP) || (buf[pos] == Constants.HT)) {
-                    pos++;
-                } else {
-                    space = false;
-                }
-
-            }
-
-            int lastSignificantChar = realPos;
-
-            // Reading bytes until the end of the line
-            while (!eol) {
-
-                // Read new bytes if needed
-                if (pos >= lastValid) {
-                    if (!fill())
-                        throw new EOFException(sm.getString("iib.eof.error"));
-                }
-
-                if (buf[pos] == Constants.CR) {
-                    // Skip
-                } else if (buf[pos] == Constants.LF) {
-                    eol = true;
-                } else if (buf[pos] == Constants.SP) {
-                    buf[realPos] = buf[pos];
-                    realPos++;
-                } else {
-                    buf[realPos] = buf[pos];
-                    realPos++;
-                    lastSignificantChar = realPos;
-                }
-
-                pos++;
-
-            }
-
-            realPos = lastSignificantChar;
-
-            // Checking the first character of the new line. If the character
-            // is a LWS, then it's a multiline header
-
-            // Read new bytes if needed
-            if (pos >= lastValid) {
-                if (!fill())
-                    throw new EOFException(sm.getString("iib.eof.error"));
-            }
-
-            chr = buf[pos];
-            if ((chr != Constants.SP) && (chr != Constants.HT)) {
-                validLine = false;
-            } else {
-                eol = false;
-                // Copying one extra space in the buffer (since there must
-                // be at least one space inserted between the lines)
-                buf[realPos] = chr;
-                realPos++;
-            }
-
-        }
-
-        // Set the header value
-        headerValue.setBytes(buf, start, realPos - start);
-
-        return true;
-
-    }
-
-
-    @Override
-    public void recycle() {
-        super.recycle();
-        inputStream = null;
-    }
-
-
-    // ------------------------------------------------------ Protected Methods
-
-
-    @Override
-    protected void init(SocketWrapper<Socket> socketWrapper,
-            AbstractEndpoint<Socket> endpoint) throws IOException {
-        inputStream = socketWrapper.getSocket().getInputStream();
-    }
-
-
-
-    private void skipLine(int start) throws IOException {
-        boolean eol = false;
-        int lastRealByte = start;
-        if (pos - 1 > start) {
-            lastRealByte = pos - 1;
-        }
-
-        while (!eol) {
-
-            // Read new bytes if needed
-            if (pos >= lastValid) {
-                if (!fill())
-                    throw new EOFException(sm.getString("iib.eof.error"));
-            }
-
-            if (buf[pos] == Constants.CR) {
-                // Skip
-            } else if (buf[pos] == Constants.LF) {
-                eol = true;
-            } else {
-                lastRealByte = pos;
-            }
-            pos++;
-        }
-
-        if (log.isDebugEnabled()) {
-            log.debug(sm.getString("iib.invalidheader", new String(buf, start,
-                    lastRealByte - start + 1, StandardCharsets.ISO_8859_1)));
-        }
-    }
-
-    /**
-     * Fill the internal buffer using data from the underlying input stream.
-     *
-     * @return false if at end of stream
-     */
-    protected boolean fill() throws IOException {
-        return fill(true);
-    }
-
-    @Override
-    protected boolean fill(boolean block) throws IOException {
-
-        int nRead = 0;
-
-        if (parsingHeader) {
-
-            if (lastValid == buf.length) {
-                throw new IllegalArgumentException
-                    (sm.getString("iib.requestheadertoolarge.error"));
-            }
-
-            nRead = inputStream.read(buf, pos, buf.length - lastValid);
-            if (nRead > 0) {
-                lastValid = pos + nRead;
-            }
-
-        } else {
-
-            if (buf.length - end < 4500) {
-                // In this case, the request header was really large, so we allocate a
-                // brand new one; the old one will get GCed when subsequent requests
-                // clear all references
-                buf = new byte[buf.length];
-                end = 0;
-            }
-            pos = end;
-            lastValid = pos;
-            nRead = inputStream.read(buf, pos, buf.length - lastValid);
-            if (nRead > 0) {
-                lastValid = pos + nRead;
-            }
-
-        }
-
-        return (nRead > 0);
-
-    }
-
-
-    @Override
-    protected final Log getLog() {
-        return log;
-    }
-
-
-    // ------------------------------------- InputStreamInputBuffer Inner Class
-
-    /**
-     * This class is an input buffer which will read its data from an input
-     * stream.
-     */
-    protected class InputStreamInputBuffer
-        implements InputBuffer {
-
-
-        /**
-         * Read bytes into the specified chunk.
-         */
-        @Override
-        public int doRead(ByteChunk chunk, Request req )
-            throws IOException {
-
-            if (pos >= lastValid) {
-                if (!fill())
-                    return -1;
-            }
-
-            int length = lastValid - pos;
-            chunk.setBytes(buf, pos, length);
-            pos = lastValid;
-
-            return (length);
-        }
-    }
-}

==================================================
BioProcessor.java
deleted file mode 100644
index 429326dddc..0000000000
--- a/java/org/apache/coyote/http11/InternalOutputBuffer.java
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.coyote.http11;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.Socket;
-
-import org.apache.coyote.OutputBuffer;
-import org.apache.coyote.Response;
-import org.apache.tomcat.util.buf.ByteChunk;
-import org.apache.tomcat.util.net.AbstractEndpoint;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-/**
- * Output buffer.
- *
- * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
- */
-public class InternalOutputBuffer extends AbstractOutputBuffer<Socket>
-    implements ByteChunk.ByteOutputChannel {
-
-    // ----------------------------------------------------------- Constructors
-
-    /**
-     * Default constructor.
-     */
-    public InternalOutputBuffer(Response response, int headerBufferSize) {
-
-        super(response, headerBufferSize);
-
-        outputStreamOutputBuffer = new OutputStreamOutputBuffer();
-
-        socketBuffer = new ByteChunk();
-        socketBuffer.setByteOutputChannel(this);
-    }
-
-    /**
-     * Underlying output stream. Note: protected to assist with unit testing
-     */
-    protected OutputStream outputStream;
-
-
-    /**
-     * Socket buffer.
-     */
-    private final ByteChunk socketBuffer;
-
-
-    /**
-     * Socket buffer (extra buffering to reduce number of packets sent).
-     */
-    private boolean useSocketBuffer = false;
-
-
-    /**
-     * Set the socket buffer size.
-     */
-    @Override
-    public void setSocketBuffer(int socketBufferSize) {
-
-        if (socketBufferSize > 500) {
-            useSocketBuffer = true;
-            socketBuffer.allocate(socketBufferSize, socketBufferSize);
-        } else {
-            useSocketBuffer = false;
-        }
-    }
-
-
-    // --------------------------------------------------------- Public Methods
-
-    @Override
-    public void init(SocketWrapper<Socket> socketWrapper,
-            AbstractEndpoint<Socket> endpoint) throws IOException {
-
-        outputStream = socketWrapper.getSocket().getOutputStream();
-    }
-
-
-    /**
-     * Recycle the output buffer. This should be called when closing the
-     * connection.
-     */
-    @Override
-    public void recycle() {
-        super.recycle();
-        outputStream = null;
-    }
-
-
-    /**
-     * End processing of current HTTP request.
-     * Note: All bytes of the current request should have been already
-     * consumed. This method only resets all the pointers so that we are ready
-     * to parse the next HTTP request.
-     */
-    @Override
-    public void nextRequest() {
-        super.nextRequest();
-        socketBuffer.recycle();
-    }
-
-
-    // ------------------------------------------------ HTTP/1.1 Output Methods
-
-    /**
-     * Send an acknowledgment.
-     */
-    @Override
-    public void sendAck()
-        throws IOException {
-
-        if (!committed)
-            outputStream.write(Constants.ACK_BYTES);
-
-    }
-
-
-    // ------------------------------------------------------ Protected Methods
-
-
-    /**
-     * Commit the response.
-     *
-     * @throws IOException an underlying I/O error occurred
-     */
-    @Override
-    protected void commit()
-        throws IOException {
-
-        // The response is now committed
-        committed = true;
-        response.setCommitted(true);
-
-        if (pos > 0) {
-            // Sending the response header buffer
-            if (useSocketBuffer) {
-                socketBuffer.append(headerBuffer, 0, pos);
-            } else {
-                outputStream.write(headerBuffer, 0, pos);
-            }
-        }
-
-    }
-
-
-    /**
-     * Callback to write data from the buffer.
-     */
-    @Override
-    public void realWriteBytes(byte cbuf[], int off, int len)
-        throws IOException {
-        if (len > 0) {
-            outputStream.write(cbuf, off, len);
-        }
-    }
-
-
-    //-------------------------------------------------- Non-blocking IO methods
-
-    @Override
-    protected boolean hasMoreDataToFlush() {
-        // The blocking connector always blocks until the previous write is
-        // complete so there is never data remaining to flush. This effectively
-        // allows non-blocking code to work with the blocking connector but -
-        // obviously - every write will always block.
-        return false;
-    }
-
-
-    @Override
-    protected void registerWriteInterest() {
-        // NO-OP for non-blocking connector
-    }
-
-
-    @Override
-    protected boolean flushBuffer(boolean block) throws IOException {
-        // Blocking connector so ignore block parameter as this will always use
-        // blocking IO.
-        if (useSocketBuffer) {
-            socketBuffer.flushBuffer();
-        }
-        // Always blocks so never any data left over.
-        return false;
-    }
-
-
-    // ----------------------------------- OutputStreamOutputBuffer Inner Class
-
-    /**
-     * This class is an output buffer which will write data to an output
-     * stream.
-     */
-    protected class OutputStreamOutputBuffer
-        implements OutputBuffer {
-
-
-        /**
-         * Write chunk.
-         */
-        @Override
-        public int doWrite(ByteChunk chunk, Response res)
-            throws IOException {
-
-            int length = chunk.getLength();
-            if (useSocketBuffer) {
-                socketBuffer.append(chunk.getBuffer(), chunk.getStart(),
-                                    length);
-            } else {
-                outputStream.write(chunk.getBuffer(), chunk.getStart(),
-                                   length);
-            }
-            byteCount += chunk.getLength();
-            return chunk.getLength();
-        }
-
-        @Override
-        public long getBytesWritten() {
-            return byteCount;
-        }
-    }
-}

==================================================
BioServletInputStream.java
deleted file mode 100644
index fa11929f5d..0000000000
--- a/java/org/apache/coyote/http11/upgrade/BioProcessor.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-import java.net.Socket;
-import java.nio.ByteBuffer;
-
-import javax.servlet.http.HttpUpgradeHandler;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-public class BioProcessor extends AbstractProcessor<Socket> {
-
-    private static final Log log = LogFactory.getLog(BioProcessor.class);
-    @Override
-    protected Log getLog() {return log;}
-
-    private static final int INFINITE_TIMEOUT = 0;
-
-    public BioProcessor(SocketWrapper<Socket> wrapper, ByteBuffer leftoverInput,
-            HttpUpgradeHandler httpUpgradeProcessor,
-            int asyncWriteBufferSize) throws IOException {
-        super(httpUpgradeProcessor, new BioServletInputStream(wrapper, leftoverInput),
-                new BioServletOutputStream(wrapper, asyncWriteBufferSize));
-
-        wrapper.getSocket().setSoTimeout(INFINITE_TIMEOUT);
-    }
-}

==================================================
BioServletOutputStream.java
deleted file mode 100644
index 0d2ec83a2f..0000000000
--- a/java/org/apache/coyote/http11/upgrade/BioServletInputStream.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.Socket;
-import java.nio.ByteBuffer;
-
-import org.apache.tomcat.util.net.SocketWrapper;
-
-public class BioServletInputStream extends AbstractServletInputStream {
-
-    private final InputStream inputStream;
-    private ByteBuffer leftoverInput;
-
-    public BioServletInputStream(SocketWrapper<Socket> wrapper, ByteBuffer leftoverInput)
-            throws IOException {
-        inputStream = wrapper.getSocket().getInputStream();
-        if (leftoverInput != null) {
-            this.leftoverInput = ByteBuffer.allocate(leftoverInput.remaining());
-            this.leftoverInput.put(leftoverInput);
-        }
-    }
-
-    @Override
-    protected int doRead(boolean block, byte[] b, int off, int len)
-            throws IOException {
-        if (leftoverInput != null) {
-            if (leftoverInput.remaining() < len) {
-                len = leftoverInput.remaining();
-            }
-            leftoverInput.get(b, off, len);
-            if (leftoverInput.remaining() == 0) {
-                leftoverInput = null;
-            }
-            return len;
-        } else {
-            return inputStream.read(b, off, len);
-        }
-    }
-
-    @Override
-    protected boolean doIsReady() {
-        // Always returns true for BIO
-        return true;
-    }
-
-    @Override
-    protected void doClose() throws IOException {
-        inputStream.close();
-    }
-}

==================================================
AbstractEndpoint.java
deleted file mode 100644
index 233f6364a6..0000000000
--- a/java/org/apache/coyote/http11/upgrade/BioServletOutputStream.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.Socket;
-
-import org.apache.tomcat.util.net.SocketWrapper;
-
-public class BioServletOutputStream extends AbstractServletOutputStream<Socket> {
-
-    private final OutputStream os;
-
-    public BioServletOutputStream(SocketWrapper<Socket> socketWrapper,
-            int asyncWriteBufferSize) throws IOException {
-        super(socketWrapper, asyncWriteBufferSize);
-        os = socketWrapper.getSocket().getOutputStream();
-    }
-
-    @Override
-    protected int doWrite(boolean block, byte[] b, int off, int len)
-            throws IOException {
-        os.write(b, off, len);
-        return len;
-    }
-
-    @Override
-    protected void doFlush() throws IOException {
-        os.flush();
-    }
-
-    @Override
-    protected void doClose() throws IOException {
-        os.close();
-    }
-}

==================================================
JIoEndpoint.java
index 063bbb02f9..2ac8f9c281 100644
--- a/java/org/apache/tomcat/util/net/AbstractEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AbstractEndpoint.java
@@ -690,7 +690,7 @@ public abstract class AbstractEndpoint<S> {
          * onWritePossible() and/or onDataAvailable() as appropriate are made by
          * the container.
          *
-         * Processing the dispatches requires (for BIO and APR/native at least)
+         * Processing the dispatches requires (for APR/native at least)
          * that the socket has been added to the waitingRequests queue. This may
          * not have occurred by the time that the non-container thread completes
          * triggering the call to this method. Therefore, the coded syncs on the

==================================================
TestRegistration.java
deleted file mode 100644
index 0b2526e069..0000000000
--- a/java/org/apache/tomcat/util/net/JIoEndpoint.java
+++ /dev/null
@@ -1,541 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.util.net;
-
-import java.io.IOException;
-import java.net.BindException;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.RejectedExecutionException;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.ExceptionUtils;
-import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
-import org.apache.tomcat.util.net.jsse.JSSESocketFactory;
-
-
-/**
- * Handle incoming TCP connections.
- *
- * This class implement a simple server model: one listener thread accepts on a socket and
- * creates a new worker thread for each incoming connection.
- *
- * More advanced Endpoints will reuse the threads, use queues, etc.
- *
- * @author James Duncan Davidson
- * @author Jason Hunter
- * @author James Todd
- * @author Costin Manolache
- * @author Gal Shachor
- * @author Yoav Shapira
- * @author Remy Maucherat
- */
-public class JIoEndpoint extends AbstractEndpoint<Socket> {
-
-
-    // -------------------------------------------------------------- Constants
-
-    private static final Log log = LogFactory.getLog(JIoEndpoint.class);
-
-    // ----------------------------------------------------------------- Fields
-
-    /**
-     * Associated server socket.
-     */
-    protected ServerSocket serverSocket = null;
-
-
-    // ------------------------------------------------------------ Constructor
-
-    public JIoEndpoint() {
-        // Set maxConnections to zero so we can tell if the user has specified
-        // their own value on the connector when we reach bind()
-        setMaxConnections(0);
-        // Reduce the executor timeout for BIO as threads in keep-alive will not
-        // terminate when the executor interrupts them.
-        setExecutorTerminationTimeoutMillis(0);
-    }
-
-    // ------------------------------------------------------------- Properties
-
-    /**
-     * Handling of accepted sockets.
-     */
-    protected Handler handler = null;
-    public void setHandler(Handler handler ) { this.handler = handler; }
-    public Handler getHandler() { return handler; }
-
-    /**
-     * Server socket factory.
-     */
-    protected ServerSocketFactory serverSocketFactory = null;
-    public void setServerSocketFactory(ServerSocketFactory factory) { this.serverSocketFactory = factory; }
-    public ServerSocketFactory getServerSocketFactory() { return serverSocketFactory; }
-
-    /**
-     * Port in use.
-     */
-    @Override
-    public int getLocalPort() {
-        ServerSocket s = serverSocket;
-        if (s == null) {
-            return -1;
-        } else {
-            return s.getLocalPort();
-        }
-    }
-
-
-    @Override
-    public String[] getCiphersUsed() {
-        if (serverSocketFactory instanceof JSSESocketFactory) {
-            return ((JSSESocketFactory) serverSocketFactory).getEnabledCiphers();
-        }
-        return new String[0];
-    }
-
-
-    /*
-     * Optional feature support.
-     */
-    @Override
-    public boolean getUseSendfile() { return false; } // Not supported
-    @Override
-    public boolean getDeferAccept() { return false; } // Not supported
-    @Override
-    public boolean getUsePolling() { return false; } // Not supported
-
-
-    // ------------------------------------------------ Handler Inner Interface
-
-    /**
-     * Bare bones interface used for socket processing. Per thread data is to be
-     * stored in the ThreadWithAttributes extra folders, or alternately in
-     * thread local fields.
-     */
-    public interface Handler extends AbstractEndpoint.Handler {
-        public SocketState process(SocketWrapper<Socket> socket,
-                SocketStatus status);
-        public SSLImplementation getSslImplementation();
-        public void beforeHandshake(SocketWrapper<Socket> socket);
-    }
-
-
-    // --------------------------------------------------- Acceptor Inner Class
-    /**
-     * The background thread that listens for incoming TCP/IP connections and
-     * hands them off to an appropriate processor.
-     */
-    protected class Acceptor extends AbstractEndpoint.Acceptor {
-
-        @Override
-        public void run() {
-
-            int errorDelay = 0;
-
-            // Loop until we receive a shutdown command
-            while (running) {
-
-                // Loop if endpoint is paused
-                while (paused && running) {
-                    state = AcceptorState.PAUSED;
-                    try {
-                        Thread.sleep(50);
-                    } catch (InterruptedException e) {
-                        // Ignore
-                    }
-                }
-
-                if (!running) {
-                    break;
-                }
-                state = AcceptorState.RUNNING;
-
-                try {
-                    //if we have reached max connections, wait
-                    countUpOrAwaitConnection();
-
-                    Socket socket = null;
-                    try {
-                        // Accept the next incoming connection from the server
-                        // socket
-                        socket = serverSocketFactory.acceptSocket(serverSocket);
-                    } catch (IOException ioe) {
-                        countDownConnection();
-                        // Introduce delay if necessary
-                        errorDelay = handleExceptionWithDelay(errorDelay);
-                        // re-throw
-                        throw ioe;
-                    }
-                    // Successful accept, reset the error delay
-                    errorDelay = 0;
-
-                    // Configure the socket
-                    if (running && !paused && setSocketOptions(socket)) {
-                        // Hand this socket off to an appropriate processor
-                        if (!processSocket(socket)) {
-                            countDownConnection();
-                            // Close socket right away
-                            closeSocket(socket);
-                        }
-                    } else {
-                        countDownConnection();
-                        // Close socket right away
-                        closeSocket(socket);
-                    }
-                } catch (IOException x) {
-                    if (running) {
-                        log.error(sm.getString("endpoint.accept.fail"), x);
-                    }
-                } catch (NullPointerException npe) {
-                    if (running) {
-                        log.error(sm.getString("endpoint.accept.fail"), npe);
-                    }
-                } catch (Throwable t) {
-                    ExceptionUtils.handleThrowable(t);
-                    log.error(sm.getString("endpoint.accept.fail"), t);
-                }
-            }
-            state = AcceptorState.ENDED;
-        }
-    }
-
-
-    private void closeSocket(Socket socket) {
-        try {
-            socket.close();
-        } catch (IOException e) {
-            // Ignore
-        }
-    }
-
-
-    // ------------------------------------------- SocketProcessor Inner Class
-
-
-    /**
-     * This class is the equivalent of the Worker, but will simply use in an
-     * external Executor thread pool.
-     */
-    protected class SocketProcessor implements Runnable {
-
-        protected SocketWrapper<Socket> socket = null;
-        protected SocketStatus status = null;
-
-        public SocketProcessor(SocketWrapper<Socket> socket) {
-            if (socket==null) throw new NullPointerException();
-            this.socket = socket;
-        }
-
-        public SocketProcessor(SocketWrapper<Socket> socket, SocketStatus status) {
-            this(socket);
-            this.status = status;
-        }
-
-        @Override
-        public void run() {
-            boolean launch = false;
-            synchronized (socket) {
-                try {
-                    SocketState state = SocketState.OPEN;
-                    handler.beforeHandshake(socket);
-                    try {
-                        // SSL handshake
-                        serverSocketFactory.handshake(socket.getSocket());
-                    } catch (Throwable t) {
-                        ExceptionUtils.handleThrowable(t);
-                        if (log.isDebugEnabled()) {
-                            log.debug(sm.getString("endpoint.err.handshake"), t);
-                        }
-                        // Tell to close the socket
-                        state = SocketState.CLOSED;
-                    }
-
-                    if ((state != SocketState.CLOSED)) {
-                        if (status == null) {
-                            state = handler.process(socket, SocketStatus.OPEN_READ);
-                        } else {
-                            state = handler.process(socket,status);
-                        }
-                    }
-                    if (state == SocketState.CLOSED) {
-                        // Close socket
-                        if (log.isTraceEnabled()) {
-                            log.trace("Closing socket:"+socket);
-                        }
-                        countDownConnection();
-                        try {
-                            socket.getSocket().close();
-                        } catch (IOException e) {
-                            // Ignore
-                        }
-                    } else if (state == SocketState.OPEN ||
-                            state == SocketState.UPGRADING  ||
-                            state == SocketState.UPGRADED){
-                        socket.setKeptAlive(true);
-                        socket.access();
-                        launch = true;
-                    } else if (state == SocketState.LONG) {
-                        socket.access();
-                        waitingRequests.add(socket);
-                    }
-                } finally {
-                    if (launch) {
-                        try {
-                            getExecutor().execute(new SocketProcessor(socket, SocketStatus.OPEN_READ));
-                        } catch (RejectedExecutionException x) {
-                            log.warn("Socket reprocessing request was rejected for:"+socket,x);
-                            try {
-                                //unable to handle connection at this time
-                                handler.process(socket, SocketStatus.DISCONNECT);
-                            } finally {
-                                countDownConnection();
-                            }
-
-
-                        } catch (NullPointerException npe) {
-                            if (running) {
-                                log.error(sm.getString("endpoint.launch.fail"),
-                                        npe);
-                            }
-                        }
-                    }
-                }
-            }
-            socket = null;
-            // Finish up this request
-        }
-
-    }
-
-
-    // -------------------- Public methods --------------------
-
-    @Override
-    public void bind() throws Exception {
-
-        // Initialize thread count defaults for acceptor
-        if (acceptorThreadCount == 0) {
-            acceptorThreadCount = 1;
-        }
-        // Initialize maxConnections
-        if (getMaxConnections() == 0) {
-            // User hasn't set a value - use the default
-            setMaxConnections(getMaxThreadsExecutor(true));
-        }
-
-        if (serverSocketFactory == null) {
-            if (isSSLEnabled()) {
-                serverSocketFactory =
-                    handler.getSslImplementation().getServerSocketFactory(this);
-            } else {
-                serverSocketFactory = new DefaultServerSocketFactory(this);
-            }
-        }
-
-        if (serverSocket == null) {
-            try {
-                if (getAddress() == null) {
-                    serverSocket = serverSocketFactory.createSocket(getPort(),
-                            getBacklog());
-                } else {
-                    serverSocket = serverSocketFactory.createSocket(getPort(),
-                            getBacklog(), getAddress());
-                }
-            } catch (BindException orig) {
-                String msg;
-                if (getAddress() == null)
-                    msg = orig.getMessage() + " <null>:" + getPort();
-                else
-                    msg = orig.getMessage() + " " +
-                            getAddress().toString() + ":" + getPort();
-                BindException be = new BindException(msg);
-                be.initCause(orig);
-                throw be;
-            }
-        }
-
-    }
-
-    @Override
-    public void startInternal() throws Exception {
-
-        if (!running) {
-            running = true;
-            paused = false;
-
-            // Create worker collection
-            if (getExecutor() == null) {
-                createExecutor();
-            }
-
-            initializeConnectionLatch();
-
-            startAcceptorThreads();
-
-            // Start async timeout thread
-            setAsyncTimeout(new AsyncTimeout());
-            Thread timeoutThread = new Thread(getAsyncTimeout(), getName() + "-AsyncTimeout");
-            timeoutThread.setPriority(threadPriority);
-            timeoutThread.setDaemon(true);
-            timeoutThread.start();
-        }
-    }
-
-    @Override
-    public void stopInternal() {
-        releaseConnectionLatch();
-        if (!paused) {
-            pause();
-        }
-        if (running) {
-            running = false;
-            getAsyncTimeout().stop();
-            unlockAccept();
-        }
-        shutdownExecutor();
-    }
-
-    /**
-     * Deallocate APR memory pools, and close server socket.
-     */
-    @Override
-    public void unbind() throws Exception {
-        if (running) {
-            stop();
-        }
-        if (serverSocket != null) {
-            try {
-                if (serverSocket != null)
-                    serverSocket.close();
-            } catch (Exception e) {
-                log.error(sm.getString("endpoint.err.close"), e);
-            }
-            serverSocket = null;
-        }
-        handler.recycle();
-    }
-
-
-    @Override
-    protected AbstractEndpoint.Acceptor createAcceptor() {
-        return new Acceptor();
-    }
-
-
-    /**
-     * Configure the socket.
-     */
-    protected boolean setSocketOptions(Socket socket) {
-        try {
-            // 1: Set socket options: timeout, linger, etc
-            socketProperties.setProperties(socket);
-        } catch (SocketException s) {
-            //error here is common if the client has reset the connection
-            if (log.isDebugEnabled()) {
-                log.debug(sm.getString("endpoint.err.unexpected"), s);
-            }
-            // Close the socket
-            return false;
-        } catch (Throwable t) {
-            ExceptionUtils.handleThrowable(t);
-            log.error(sm.getString("endpoint.err.unexpected"), t);
-            // Close the socket
-            return false;
-        }
-        return true;
-    }
-
-
-    /**
-     * Process a new connection from a new client. Wraps the socket so
-     * keep-alive and other attributes can be tracked and then passes the socket
-     * to the executor for processing.
-     *
-     * @param socket    The socket associated with the client.
-     *
-     * @return          <code>true</code> if the socket is passed to the
-     *                  executor, <code>false</code> if something went wrong or
-     *                  if the endpoint is shutting down. Returning
-     *                  <code>false</code> is an indication to close the socket
-     *                  immediately.
-     */
-    protected boolean processSocket(Socket socket) {
-        // Process the request from this socket
-        try {
-            SocketWrapper<Socket> wrapper = new SocketWrapper<>(socket);
-            wrapper.setKeepAliveLeft(getMaxKeepAliveRequests());
-            wrapper.setSecure(isSSLEnabled());
-            // During shutdown, executor may be null - avoid NPE
-            if (!running) {
-                return false;
-            }
-            getExecutor().execute(new SocketProcessor(wrapper));
-        } catch (RejectedExecutionException x) {
-            log.warn("Socket processing request was rejected for:"+socket,x);
-            return false;
-        } catch (Throwable t) {
-            ExceptionUtils.handleThrowable(t);
-            // This means we got an OOM or similar creating a thread, or that
-            // the pool and its queue are full
-            log.error(sm.getString("endpoint.process.fail"), t);
-            return false;
-        }
-        return true;
-    }
-
-
-    @Override
-    public void processSocket(SocketWrapper<Socket> socket,
-            SocketStatus status, boolean dispatch) {
-        try {
-            // Synchronisation is required here as this code may be called as a
-            // result of calling AsyncContext.dispatch() from a non-container
-            // thread
-            synchronized (socket) {
-                if (waitingRequests.remove(socket)) {
-                    SocketProcessor proc = new SocketProcessor(socket,status);
-                    Executor executor = getExecutor();
-                    if (dispatch && executor != null) {
-                        // During shutdown, executor may be null - avoid NPE
-                        if (!running) {
-                            return;
-                        }
-                        getExecutor().execute(proc);
-                    } else {
-                        proc.run();
-                    }
-                }
-            }
-        } catch (RejectedExecutionException ree) {
-            log.warn(sm.getString("endpoint.executor.fail", socket) , ree);
-        } catch (Throwable t) {
-            ExceptionUtils.handleThrowable(t);
-            // This means we got an OOM or similar creating a thread, or that
-            // the pool and its queue are full
-            log.error(sm.getString("endpoint.process.fail"), t);
-        }
-    }
-
-    @Override
-    protected Log getLog() {
-        return log;
-    }
-}

==================================================
TestNonBlockingAPI.java
index d4c76b6642..0fb404d3f1 100644
--- a/test/org/apache/catalina/mbeans/TestRegistration.java
+++ b/test/org/apache/catalina/mbeans/TestRegistration.java
@@ -170,11 +170,6 @@ public class TestRegistration extends TomcatBaseTest {
         combinedRealm.addRealm(nullRealm);
         ctx.setRealm(combinedRealm);
 
-        // Disable keep-alive otherwise request processing threads in keep-alive
-        // won't shut down fast enough with BIO to de-register the processor
-        // triggering a test failure
-        tomcat.getConnector().setAttribute("maxKeepAliveRequests", Integer.valueOf(1));
-
         tomcat.start();
 
         getUrl("http://localhost:" + getPort());
@@ -195,12 +190,10 @@ public class TestRegistration extends TomcatBaseTest {
         String protocol = tomcat.getConnector().getProtocolHandlerClassName();
         if (protocol.indexOf("Nio2") > 0) {
             protocol = "nio2";
-        } else if (protocol.indexOf("Nio") > 0) {
-            protocol = "nio";
         } else if (protocol.indexOf("Apr") > 0) {
             protocol = "apr";
         } else {
-            protocol = "bio";
+            protocol = "nio";
         }
         String index = tomcat.getConnector().getProperty("nameIndex").toString();
         ArrayList<String> expected = new ArrayList<>(Arrays.asList(basicMBeanNames()));

==================================================
TestAbstractAjpProcessor.java
index 3f47769044..532049c21d 100644
--- a/test/org/apache/catalina/nonblocking/TestNonBlockingAPI.java
+++ b/test/org/apache/catalina/nonblocking/TestNonBlockingAPI.java
@@ -41,7 +41,6 @@ import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
 import org.junit.Assert;
-import org.junit.Assume;
 import org.junit.Test;
 
 import org.apache.catalina.Context;
@@ -91,12 +90,6 @@ public class TestNonBlockingAPI extends TomcatBaseTest {
 
     @Test(expected=IOException.class)
     public void testNonBlockingReadIgnoreIsReady() throws Exception {
-        // TODO Investigate options to get this test to pass with the HTTP BIO
-        //      connector.
-        Assume.assumeFalse(
-                "Skipping as this test requires true non-blocking IO",
-                getTomcatInstance().getConnector().getProtocol()
-                        .equals("org.apache.coyote.http11.Http11Protocol"));
         doTestNonBlockingRead(true);
     }
 

==================================================
TestWebSocketFrameClientSSL.java
index 4d0a50d2ba..357739aebc 100644
--- a/test/org/apache/coyote/ajp/TestAbstractAjpProcessor.java
+++ b/test/org/apache/coyote/ajp/TestAbstractAjpProcessor.java
@@ -46,17 +46,15 @@ public class TestAbstractAjpProcessor extends TomcatBaseTest {
         // Has a protocol been specified
         String protocol = System.getProperty("tomcat.test.protocol");
 
-        // Use BIO by default
+        // Use NIO by default
         if (protocol == null) {
-            protocol = "org.apache.coyote.ajp.AjpProtocol";
+            protocol = "org.apache.coyote.ajp.AjpNioProtocol";
         } else if (protocol.contains("Nio2")) {
             protocol = "org.apache.coyote.ajp.AjpNio2Protocol";
-        } else if (protocol.contains("Nio")) {
-            protocol = "org.apache.coyote.ajp.AjpNioProtocol";
         } else if (protocol.contains("Apr")) {
             protocol = "org.apache.coyote.ajp.AjpAprProtocol";
         } else {
-            protocol = "org.apache.coyote.ajp.AjpProtocol";
+            protocol = "org.apache.coyote.ajp.AjpNioProtocol";
         }
 
         return protocol;

==================================================
TestWsWebSocketContainer.java
index e2b0890c60..141b18ef34 100644
--- a/test/org/apache/tomcat/websocket/TestWebSocketFrameClientSSL.java
+++ b/test/org/apache/tomcat/websocket/TestWebSocketFrameClientSSL.java
@@ -28,7 +28,6 @@ import javax.websocket.Session;
 import javax.websocket.WebSocketContainer;
 
 import org.junit.Assert;
-import org.junit.Assume;
 import org.junit.Test;
 
 import org.apache.catalina.Context;
@@ -92,13 +91,6 @@ public class TestWebSocketFrameClientSSL extends TomcatBaseTest {
 
     @Test
     public void testBug56032() throws Exception {
-        // TODO Investigate options to get this test to pass with the HTTP BIO
-        //      connector.
-        Assume.assumeFalse(
-                "Skip this test on BIO. TODO: investigate options to make it pass with HTTP BIO connector",
-                getTomcatInstance().getConnector().getProtocol()
-                        .equals("org.apache.coyote.http11.Http11Protocol"));
-
         Tomcat tomcat = getTomcatInstance();
         // No file system docBase required
         Context ctx = tomcat.addContext("", null);

==================================================
