affad98167e78a3bf25602f31d6652e077b413a9
==================================================
SocketWrapperBase.socket is final and is always created non-null.
==================================================
Mark Thomas
==================================================
Tue May 31 21:03:17 2016 +0000
==================================================
AbstractProtocol.java
SocketWrapperBase.socket is final and is always created non-null.
Remove unnecessary null checks

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1746344 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http11Processor.java
index e0f34ef072..0f6b1da735 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -716,10 +716,6 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
             }
 
             S socket = wrapper.getSocket();
-            if (socket == null) {
-                // Nothing to do. Socket has been closed.
-                return SocketState.CLOSED;
-            }
 
             Processor processor = connections.get(socket);
             if (status == SocketEvent.DISCONNECT && processor == null) {
@@ -975,11 +971,9 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
         @Override
         public void release(SocketWrapperBase<S> socketWrapper) {
             S socket = socketWrapper.getSocket();
-            if (socket != null) {
-                Processor processor = connections.remove(socket);
-                //getProtocol().removeWaitingProcessor(processor);
-                release(processor);
-            }
+            Processor processor = connections.remove(socket);
+            //getProtocol().removeWaitingProcessor(processor);
+            release(processor);
         }
 
 

==================================================
AprEndpoint.java
index 6284891153..2fb324b926 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -825,7 +825,7 @@ public class Http11Processor extends AbstractProcessor {
             break;
         }
         case REQ_SSL_CERTIFICATE: {
-            if (sslSupport != null && socketWrapper.getSocket() != null) {
+            if (sslSupport != null) {
                 // Consume and buffer the request body, so that it does not
                 // interfere with the client's handshake messages
                 InputFilter[] inputFilters = inputBuffer.getFilters();

==================================================
Nio2Endpoint.java
index 86519b8d1c..d82e2e79cd 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -2255,10 +2255,6 @@ public class AprEndpoint extends AbstractEndpoint<Long> implements SNICallBack {
         public void run() {
             synchronized (socketWrapper) {
                 // Process the request from this socket
-                if (socketWrapper.getSocket() == null) {
-                    // Closed in another thread
-                    return;
-                }
                 SocketState state = getHandler().process(socketWrapper, event);
                 if (state == Handler.SocketState.CLOSED) {
                     // Close socket and pool

==================================================
NioBlockingSelector.java
index 42a3c3c9c0..a29e1daf12 100644
--- a/java/org/apache/tomcat/util/net/Nio2Endpoint.java
+++ b/java/org/apache/tomcat/util/net/Nio2Endpoint.java
@@ -424,12 +424,10 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
             if (log.isDebugEnabled()) log.error("",e);
         }
         try {
-            if (socket.getSocket() != null) {
-                synchronized (socket.getSocket()) {
-                    if (socket.getSocket() != null && socket.getSocket().isOpen()) {
-                        countDownConnection();
-                        socket.getSocket().close(true);
-                    }
+            synchronized (socket.getSocket()) {
+                if (socket.getSocket().isOpen()) {
+                    countDownConnection();
+                    socket.getSocket().close(true);
                 }
             }
         } catch (Throwable e) {
@@ -942,10 +940,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
 
         @Override
         public void close() throws IOException {
-            Nio2Channel socket = getSocket();
-            if (socket != null) {
-                socket.close();
-            }
+            getSocket().close();
         }
 
         @Override
@@ -1395,9 +1390,6 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
 
 
         public void awaitBytes() {
-            if (getSocket() == null) {
-                return;
-            }
             // NO-OP is there is already a read in progress.
             if (readPending.tryAcquire()) {
                 getSocket().getBufHandler().configureReadBufferForWrite();
@@ -1643,26 +1635,24 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                     int handshake = -1;
 
                     try {
-                        if (socketWrapper.getSocket() != null) {
-                            // For STOP there is no point trying to handshake as the
-                            // Poller has been stopped.
-                            if (!socketWrapper.getSocket().isHandshakeComplete() && event == SocketEvent.ERROR) {
-                                handshake = -1;
-                            } else if (socketWrapper.getSocket().isHandshakeComplete() ||
-                                    event == SocketEvent.STOP ||
-                                    event == SocketEvent.ERROR) {
-                                handshake = 0;
-                            } else {
-                                handshake = socketWrapper.getSocket().handshake();
-                                // The handshake process reads/writes from/to the
-                                // socket. status may therefore be OPEN_WRITE once
-                                // the handshake completes. However, the handshake
-                                // happens when the socket is opened so the status
-                                // must always be OPEN_READ after it completes. It
-                                // is OK to always set this as it is only used if
-                                // the handshake completes.
-                                event = SocketEvent.OPEN_READ;
-                            }
+                        // For STOP there is no point trying to handshake as the
+                        // Poller has been stopped.
+                        if (!socketWrapper.getSocket().isHandshakeComplete() && event == SocketEvent.ERROR) {
+                            handshake = -1;
+                        } else if (socketWrapper.getSocket().isHandshakeComplete() ||
+                                event == SocketEvent.STOP ||
+                                event == SocketEvent.ERROR) {
+                            handshake = 0;
+                        } else {
+                            handshake = socketWrapper.getSocket().handshake();
+                            // The handshake process reads/writes from/to the
+                            // socket. status may therefore be OPEN_WRITE once
+                            // the handshake completes. However, the handshake
+                            // happens when the socket is opened so the status
+                            // must always be OPEN_READ after it completes. It
+                            // is OK to always set this as it is only used if
+                            // the handshake completes.
+                            event = SocketEvent.OPEN_READ;
                         }
                     } catch (IOException x) {
                         handshake = -1;

==================================================
NioEndpoint.java
index 418fd0a5fa..068f1fc068 100644
--- a/java/org/apache/tomcat/util/net/NioBlockingSelector.java
+++ b/java/org/apache/tomcat/util/net/NioBlockingSelector.java
@@ -245,7 +245,6 @@ public class NioBlockingSelector {
         public void add(final NioSocketWrapper key, final int ops, final KeyReference ref) {
             if ( key == null ) return;
             NioChannel nch = key.getSocket();
-            if ( nch == null ) return;
             final SocketChannel ch = nch.getIOChannel();
             if ( ch == null ) return;
 
@@ -276,7 +275,6 @@ public class NioBlockingSelector {
         public void remove(final NioSocketWrapper key, final int ops) {
             if ( key == null ) return;
             NioChannel nch = key.getSocket();
-            if ( nch == null ) return;
             final SocketChannel ch = nch.getIOChannel();
             if ( ch == null ) return;
 

==================================================
SocketWrapperBase.java
index 600235120f..ce19a2dd75 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -1230,10 +1230,7 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel> {
 
         @Override
         public void close() throws IOException {
-            NioChannel socket = getSocket();
-            if (socket != null) {
-                socket.close();
-            }
+            getSocket().close();
         }
 
 
@@ -1432,9 +1429,6 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel> {
         @Override
         public void run() {
             NioChannel socket = socketWrapper.getSocket();
-            if (socket == null) {
-                return;
-            }
             SelectionKey key = socket.getIOChannel().keyFor(
                     socket.getPoller().getSelector());
 

==================================================
