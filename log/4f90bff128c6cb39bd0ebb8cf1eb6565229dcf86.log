4f90bff128c6cb39bd0ebb8cf1eb6565229dcf86
==================================================
First part of fix for BZ 65262. Make WebSocket more IoC friendly
==================================================
Mark Thomas
==================================================
Tue May 4 17:02:38 2021 +0100
==================================================
ClientEndpointHolder.java
First part of fix for BZ 65262. Make WebSocket more IoC friendly

This first part tackles the Endpoints. Endpoint instance creation has
been refactored and will now run through the InstanceManger for object
creation where possible. Where that isn't possible, the objects will
continue to be registered with the InstanceManager.

https://bz.apache.org/bugzilla/show_bug.cgi?id=65262


==================================================
EndpointClassHolder.java
new file mode 100644
index 0000000000..d3334d1413
--- /dev/null
+++ b/java/org/apache/tomcat/websocket/ClientEndpointHolder.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.websocket;
+
+import jakarta.websocket.DeploymentException;
+import jakarta.websocket.Endpoint;
+
+import org.apache.tomcat.InstanceManager;
+
+public interface ClientEndpointHolder {
+    String getClassName();
+    Endpoint getInstance(InstanceManager instanceManager) throws DeploymentException;
+}

==================================================
EndpointHolder.java
new file mode 100644
index 0000000000..7a2cf218f6
--- /dev/null
+++ b/java/org/apache/tomcat/websocket/EndpointClassHolder.java
@@ -0,0 +1,57 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.websocket;
+
+import javax.naming.NamingException;
+
+import jakarta.websocket.DeploymentException;
+import jakarta.websocket.Endpoint;
+
+import org.apache.tomcat.InstanceManager;
+import org.apache.tomcat.util.res.StringManager;
+
+public class EndpointClassHolder implements ClientEndpointHolder {
+
+    private static final StringManager sm = StringManager.getManager(EndpointClassHolder.class);
+
+    private final Class<? extends Endpoint> clazz;
+
+
+    public EndpointClassHolder(Class<? extends Endpoint> clazz) {
+        this.clazz = clazz;
+    }
+
+
+    @Override
+    public String getClassName() {
+        return clazz.getName();
+    }
+
+
+    @Override
+    public Endpoint getInstance(InstanceManager instanceManager) throws DeploymentException {
+        try {
+            if (instanceManager == null) {
+                return clazz.getConstructor().newInstance();
+            } else {
+                return (Endpoint) instanceManager.newInstance(clazz);
+            }
+        } catch (ReflectiveOperationException | NamingException e) {
+            throw new DeploymentException(sm.getString("clientEndpointHolder.instanceCreationFailed"), e);
+        }
+    }
+}

==================================================
PojoClassHolder.java
index 71b16d6fde..9a064891d9 100644
--- a/java/org/apache/tomcat/websocket/LocalStrings_zh_CN.properties
+++ b/java/org/apache/tomcat/websocket/LocalStrings_zh_CN.properties
@@ -115,7 +115,6 @@ wsSession.unknownHandlerType=无法添加消息处理程序[{0}]，因为它被
 wsWebSocketContainer.asynchronousSocketChannelFail=无法打开与服务器的连接
 wsWebSocketContainer.connect.entry=连接[{0}]类型的终端实例至[{1}]
 wsWebSocketContainer.defaultConfiguratorFail=无法创建默认配置程序。
-wsWebSocketContainer.endpointCreateFail=未能创建类型为[{0}]的本地终结点
 wsWebSocketContainer.failedAuthentication=无法处理http响应代码[{0}]。服务器不接受身份验证头。
 wsWebSocketContainer.httpRequestFailed=启动WebSocket连接的HTTP请求失败
 wsWebSocketContainer.invalidExtensionParameters=服务器用客户端无法支持的扩展参数响应

==================================================
PojoHolder.java
new file mode 100644
index 0000000000..e2c1da82f8
--- /dev/null
+++ b/java/org/apache/tomcat/websocket/PojoClassHolder.java
@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.websocket;
+
+import javax.naming.NamingException;
+
+import jakarta.websocket.ClientEndpointConfig;
+import jakarta.websocket.DeploymentException;
+import jakarta.websocket.Endpoint;
+
+import org.apache.tomcat.InstanceManager;
+import org.apache.tomcat.util.res.StringManager;
+import org.apache.tomcat.websocket.pojo.PojoEndpointClient;
+
+public class PojoClassHolder implements ClientEndpointHolder {
+
+    private static final StringManager sm = StringManager.getManager(PojoClassHolder.class);
+
+    private final Class<?> pojoClazz;
+    private final ClientEndpointConfig clientEndpointConfig;
+
+
+    public PojoClassHolder(Class<?> pojoClazz, ClientEndpointConfig clientEndpointConfig) {
+        this.pojoClazz = pojoClazz;
+        this.clientEndpointConfig = clientEndpointConfig;
+    }
+
+
+    @Override
+    public String getClassName() {
+        return pojoClazz.getName();
+    }
+
+    @Override
+    public Endpoint getInstance(InstanceManager instanceManager) throws DeploymentException {
+        try {
+            Object pojo;
+            if (instanceManager == null) {
+                pojo = pojoClazz.getConstructor().newInstance();
+            } else {
+                pojo = instanceManager.newInstance(pojoClazz);
+            }
+            return new PojoEndpointClient(pojo, clientEndpointConfig.getDecoders());
+        } catch (ReflectiveOperationException | SecurityException | NamingException e) {
+            throw new DeploymentException(sm.getString("clientEndpointHolder.instanceCreationFailed"), e);
+        }
+    }
+
+}

==================================================
WsSession.java
new file mode 100644
index 0000000000..7195944df3
--- /dev/null
+++ b/java/org/apache/tomcat/websocket/PojoHolder.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.websocket;
+
+import javax.naming.NamingException;
+
+import jakarta.websocket.ClientEndpointConfig;
+import jakarta.websocket.DeploymentException;
+import jakarta.websocket.Endpoint;
+
+import org.apache.tomcat.InstanceManager;
+import org.apache.tomcat.util.res.StringManager;
+import org.apache.tomcat.websocket.pojo.PojoEndpointClient;
+
+public class PojoHolder implements ClientEndpointHolder {
+
+    private static final StringManager sm = StringManager.getManager(PojoHolder.class);
+
+    private final Object pojo;
+    private final ClientEndpointConfig clientEndpointConfig;
+
+
+    public PojoHolder(Object pojo, ClientEndpointConfig clientEndpointConfig) {
+        this.pojo = pojo;
+        this.clientEndpointConfig = clientEndpointConfig;
+    }
+
+
+    @Override
+    public String getClassName() {
+        return pojo.getClass().getName();
+    }
+
+
+    @Override
+    public Endpoint getInstance(InstanceManager instanceManager) throws DeploymentException {
+        if (instanceManager != null) {
+            try {
+                instanceManager.newInstance(pojo);
+            } catch (ReflectiveOperationException | NamingException e) {
+                throw new DeploymentException(sm.getString("clientEndpointHolder.instanceRegistrationFailed"), e);
+            }
+        }
+        return new PojoEndpointClient(pojo, clientEndpointConfig.getDecoders());
+    }
+}

==================================================
WsWebSocketContainer.java
index 2085cb3ae8..4c71d84302 100644
--- a/java/org/apache/tomcat/websocket/WsSession.java
+++ b/java/org/apache/tomcat/websocket/WsSession.java
@@ -30,6 +30,8 @@ import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicLong;
 
+import javax.naming.NamingException;
+
 import jakarta.websocket.ClientEndpointConfig;
 import jakarta.websocket.CloseReason;
 import jakarta.websocket.CloseReason.CloseCode;
@@ -47,6 +49,7 @@ import jakarta.websocket.SendResult;
 import jakarta.websocket.Session;
 import jakarta.websocket.WebSocketContainer;
 import jakarta.websocket.server.ServerEndpointConfig;
+import jakarta.websocket.server.ServerEndpointConfig.Configurator;
 
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
@@ -55,19 +58,29 @@ import org.apache.tomcat.InstanceManagerBindings;
 import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.res.StringManager;
 import org.apache.tomcat.websocket.pojo.PojoEndpointServer;
+import org.apache.tomcat.websocket.server.DefaultServerEndpointConfigurator;
 
 public class WsSession implements Session {
 
+    private final Log log = LogFactory.getLog(WsSession.class); // must not be static
+    private static final StringManager sm = StringManager.getManager(WsSession.class);
+
     // An ellipsis is a single character that looks like three periods in a row
     // and is used to indicate a continuation.
     private static final byte[] ELLIPSIS_BYTES = "\u2026".getBytes(StandardCharsets.UTF_8);
     // An ellipsis is three bytes in UTF-8
     private static final int ELLIPSIS_BYTES_LEN = ELLIPSIS_BYTES.length;
 
-    private static final StringManager sm = StringManager.getManager(WsSession.class);
+    private static final boolean SEC_CONFIGURATOR_USES_IMPL_DEFAULT;
+
     private static AtomicLong ids = new AtomicLong(0);
 
-    private final Log log = LogFactory.getLog(WsSession.class); // must not be static
+    static {
+        ServerEndpointConfig.Builder builder = ServerEndpointConfig.Builder.create(null, null);
+        ServerEndpointConfig sec = builder.build();
+        SEC_CONFIGURATOR_USES_IMPL_DEFAULT =
+                sec.getConfigurator().getClass().equals(DefaultServerEndpointConfigurator.class);
+    }
 
     private final Endpoint localEndpoint;
     private final WsRemoteEndpointImplBase wsRemoteEndpoint;
@@ -111,7 +124,7 @@ public class WsSession implements Session {
      * called will be used when calling
      * {@link Endpoint#onClose(Session, CloseReason)}.
      *
-     * @param localEndpoint        The end point managed by this code
+     * @param clientEndpointHolder The end point managed by this code
      * @param wsRemoteEndpoint     The other / remote end point
      * @param wsWebSocketContainer The container that created this session
      * @param negotiatedExtensions The agreed extensions to use for this session
@@ -126,12 +139,11 @@ public class WsSession implements Session {
      *                             end point
      * @throws DeploymentException if an invalid encode is specified
      */
-    public WsSession(Endpoint localEndpoint,
+    public WsSession(ClientEndpointHolder clientEndpointHolder,
             WsRemoteEndpointImplBase wsRemoteEndpoint,
             WsWebSocketContainer wsWebSocketContainer,
             List<Extension> negotiatedExtensions, String subProtocol, Map<String, String> pathParameters,
             boolean secure, ClientEndpointConfig clientEndpointConfig) throws DeploymentException {
-        this.localEndpoint = localEndpoint;
         this.wsRemoteEndpoint = wsRemoteEndpoint;
         this.wsRemoteEndpoint.setSession(this);
         this.remoteEndpointAsync = new WsRemoteEndpointAsync(wsRemoteEndpoint);
@@ -165,13 +177,8 @@ public class WsSession implements Session {
         if (instanceManager == null) {
             instanceManager = InstanceManagerBindings.get(applicationClassLoader);
         }
-        if (instanceManager != null) {
-            try {
-                instanceManager.newInstance(localEndpoint);
-            } catch (Exception e) {
-                throw new DeploymentException(sm.getString("wsSession.instanceNew"), e);
-            }
-        }
+
+        this.localEndpoint = clientEndpointHolder.getInstance(instanceManager);
 
         if (log.isDebugEnabled()) {
             log.debug(sm.getString("wsSession.created", id));
@@ -221,17 +228,6 @@ public class WsSession implements Session {
             List<Extension> negotiatedExtensions, String subProtocol, Map<String, String> pathParameters,
             boolean secure, ServerEndpointConfig serverEndpointConfig) throws DeploymentException {
 
-        try {
-            Class<?> clazz = serverEndpointConfig.getEndpointClass();
-            if (Endpoint.class.isAssignableFrom(clazz)) {
-                this.localEndpoint = (Endpoint) serverEndpointConfig.getConfigurator().getEndpointInstance(clazz);
-            } else {
-                this.localEndpoint = new PojoEndpointServer(pathParameters);
-            }
-        } catch (InstantiationException e) {
-            throw new DeploymentException(sm.getString("wsSession.instanceNew"), e);
-        }
-
         this.wsRemoteEndpoint = wsRemoteEndpoint;
         this.wsRemoteEndpoint.setSession(this);
         this.remoteEndpointAsync = new WsRemoteEndpointAsync(wsRemoteEndpoint);
@@ -269,12 +265,32 @@ public class WsSession implements Session {
         if (instanceManager == null) {
             instanceManager = InstanceManagerBindings.get(applicationClassLoader);
         }
-        if (instanceManager != null) {
-            try {
-                instanceManager.newInstance(localEndpoint);
-            } catch (Exception e) {
-                throw new DeploymentException(sm.getString("wsSession.instanceNew"), e);
+
+        Configurator configurator = serverEndpointConfig.getConfigurator();
+        Class<?> clazz = serverEndpointConfig.getEndpointClass();
+
+        Object endpointInstance;
+        try {
+            if (instanceManager == null || !isDefaultConfigurator(configurator)) {
+                endpointInstance = configurator.getEndpointInstance(clazz);
+                if (instanceManager != null) {
+                    try {
+                        instanceManager.newInstance(endpointInstance);
+                    } catch (ReflectiveOperationException | NamingException e) {
+                        throw new DeploymentException(sm.getString("wsSession.instanceNew"), e);
+                    }
+                }
+            } else {
+                endpointInstance = instanceManager.newInstance(clazz);
             }
+        } catch (ReflectiveOperationException | NamingException e) {
+            throw new DeploymentException(sm.getString("wsSession.instanceCreateFailed"), e);
+        }
+
+        if (endpointInstance instanceof Endpoint) {
+            this.localEndpoint = (Endpoint) endpointInstance;
+        } else {
+            this.localEndpoint = new PojoEndpointServer(pathParameters, endpointInstance);
         }
 
         if (log.isDebugEnabled()) {
@@ -283,6 +299,18 @@ public class WsSession implements Session {
     }
 
 
+    private boolean isDefaultConfigurator(Configurator configurator) {
+        if (configurator.getClass().equals(DefaultServerEndpointConfigurator.class)) {
+            return true;
+        }
+        if (SEC_CONFIGURATOR_USES_IMPL_DEFAULT &&
+                configurator.getClass().equals(ServerEndpointConfig.Configurator.class)) {
+            return true;
+        }
+        return false;
+    }
+
+
     /**
      * Creates a new WebSocket session for communication between the two
      * provided end points. The result of {@link Thread#getContextClassLoader()}

==================================================
PojoEndpointServer.java
index 3147f4abed..ae9909b9a5 100644
--- a/java/org/apache/tomcat/websocket/pojo/LocalStrings_zh_CN.properties
+++ b/java/org/apache/tomcat/websocket/pojo/LocalStrings_zh_CN.properties
@@ -19,8 +19,6 @@ pojoEndpointBase.onError=在错误发生后，没有为[{0}]配置错误处理
 pojoEndpointBase.onErrorFail=无法为类型为[{0}]的POJO调用POJO端点的onError方法
 pojoEndpointBase.onOpenFail=无法为类型为[{0}]的POJO调用POJO端点的onOpen方法
 
-pojoEndpointServer.getPojoInstanceFail=创建类型为 [{0}] 的 POJO 实例失败
-
 pojoMessageHandlerWhole.decodeIoFail=解码消息时出现IO错误
 pojoMessageHandlerWhole.maxBufferSize=此实现支持的最大消息大小为Integer.MAX_VALUE
 

==================================================
