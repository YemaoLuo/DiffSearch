100a058a2be3b172e42ba191b96f3ac1554e6f29
==================================================
Avoid overflow with OpenSSL engine
==================================================
remm remm@apache.org
==================================================
Sat Mar 9 21:37:11 2019 +0100
==================================================
SecureNio2Channel.java
Avoid overflow with OpenSSL engine

Avoid many overflow situations with OpenSSL engine, overflow will now
only occur if the destination buffers are all full when unwrap is
called. Since it has an internal buffer (the bio in the native code), it
doesn't have to write all the decrypted data available and can hold them
until the next unwrap call. Also improve the overflow handling in the
NIO2 code to give the right bytes produced and avoid some useless
processing.


==================================================
OpenSSLEngine.java
index 8c709919e1..6eae95d30e 100644
--- a/java/org/apache/tomcat/util/net/SecureNio2Channel.java
+++ b/java/org/apache/tomcat/util/net/SecureNio2Channel.java
@@ -1012,6 +1012,10 @@ public class SecureNio2Channel extends Nio2Channel  {
                         int length2 = length;
                         boolean processOverflow = false;
                         do {
+                            boolean useOverflow = false;
+                            if (processOverflow) {
+                                useOverflow = true;
+                            }
                             processOverflow = false;
                             //prepare the buffer
                             netInBuffer.flip();
@@ -1022,6 +1026,10 @@ public class SecureNio2Channel extends Nio2Channel  {
                             if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {
                                 //we did receive some data, add it to our total
                                 read += unwrap.bytesProduced();
+                                if (useOverflow) {
+                                    // Remove the data read into the overflow buffer
+                                    read -= dsts2[dsts.length].position();
+                                }
                                 //perform any tasks if needed
                                 if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)
                                     tasks();
@@ -1038,7 +1046,7 @@ public class SecureNio2Channel extends Nio2Channel  {
                                 //buffer overflow can happen, if we have read data, then
                                 //empty out the dst buffer before we do another read
                                 break;
-                            } else {
+                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {
                                 //here we should trap BUFFER_OVERFLOW and call expand on the buffer
                                 //for now, throw an exception, as we initialized the buffers
                                 //in the constructor
@@ -1062,6 +1070,10 @@ public class SecureNio2Channel extends Nio2Channel  {
                                     getBufHandler().configureReadBufferForWrite();
                                     processOverflow = true;
                                 }
+                            } else if (unwrap.getStatus() == Status.CLOSED) {
+                                break;
+                            } else {
+                                throw new IOException(sm.getString("channel.nio.ssl.unwrapFail", unwrap.getStatus()));
                             }
                         } while ((netInBuffer.position() != 0) || processOverflow); //continue to unwrapping as long as the input buffer has stuff
                         int capacity = 0;

==================================================
