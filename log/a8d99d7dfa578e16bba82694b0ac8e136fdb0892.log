a8d99d7dfa578e16bba82694b0ac8e136fdb0892
==================================================
eol
==================================================
Mark Emlyn
==================================================
Tue Feb 7 10:19:51 2012 +0000
==================================================
UpgradeAprProcessor.java
eol

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1241411 13f79535-47bb-0310-9956-ffa450edef68



==================================================
UpgradeBioProcessor.java
index 4d41706618..efb19c56d7 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeAprProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeAprProcessor.java
@@ -1,123 +1,123 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-
-import org.apache.coyote.http11.Http11AprProcessor;
-import org.apache.tomcat.jni.Socket;
-import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
-import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-/**
- * Implementation note: The need to extend Http11Processor could probably be
- * removed if the Processor interface was expanded to cover all of the methods
- * required by the AbstractProtocol. That would simplify the code and further
- * reduce the size of instances of this class.
- */
-public class UpgradeAprProcessor extends Http11AprProcessor
-        implements UpgradeProcessor {
-
-    long socket;
-
-    public UpgradeAprProcessor(SocketWrapper<Long> wrapper,
-            UpgradeInbound inbound) {
-        this.socket = wrapper.getSocket().longValue();
-
-        this.upgradeInbound = inbound;
-        upgradeInbound.setUpgradeProcessor(this);
-        upgradeInbound.setUpgradeOutbound(new UpgradeOutbound(this));
-        // Remove the default - no need for it here
-        this.compressableMimeTypes = null;
-    }
-
-
-    @Override
-    public SocketState upgradeDispatch() throws IOException {
-        return upgradeInbound.onData();
-    }
-
-
-    /*
-     * Output methods
-     */
-    @Override
-    public void flush() throws IOException {
-        // NOOP
-    }
-
-
-    @Override
-    public void write(int b) throws IOException {
-        Socket.send(socket, new byte[] {(byte) b}, 0, 1);
-    }
-
-
-    /*
-     * Input methods
-     */
-    @Override
-    public int read() throws IOException {
-        byte[] bytes = new byte[1];
-        Socket.recv(socket, bytes, 0, 1);
-        return bytes[0];
-    }
-
-
-    @Override
-    public int read(byte[] bytes) throws IOException {
-        return Socket.recv(socket, bytes, 0, bytes.length);
-    }
-
-
-    /*
-     * None of the following NO-OP methods are strictly necessary - assuming the
-     * there are no bugs in the connector code that cause upgraded connections
-     * to be treated as Http11, Comet or Async. These NO-OP methods are here for
-     * safety and to aid debugging during development.
-     */
-
-    @Override
-    public SocketState event(SocketStatus status) throws IOException {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState process(SocketWrapper<Long> socketWrapper)
-            throws IOException {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState asyncDispatch(SocketStatus status) {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState asyncPostProcess() {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.IOException;
+
+import org.apache.coyote.http11.Http11AprProcessor;
+import org.apache.tomcat.jni.Socket;
+import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
+import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketWrapper;
+
+/**
+ * Implementation note: The need to extend Http11Processor could probably be
+ * removed if the Processor interface was expanded to cover all of the methods
+ * required by the AbstractProtocol. That would simplify the code and further
+ * reduce the size of instances of this class.
+ */
+public class UpgradeAprProcessor extends Http11AprProcessor
+        implements UpgradeProcessor {
+
+    long socket;
+
+    public UpgradeAprProcessor(SocketWrapper<Long> wrapper,
+            UpgradeInbound inbound) {
+        this.socket = wrapper.getSocket().longValue();
+
+        this.upgradeInbound = inbound;
+        upgradeInbound.setUpgradeProcessor(this);
+        upgradeInbound.setUpgradeOutbound(new UpgradeOutbound(this));
+        // Remove the default - no need for it here
+        this.compressableMimeTypes = null;
+    }
+
+
+    @Override
+    public SocketState upgradeDispatch() throws IOException {
+        return upgradeInbound.onData();
+    }
+
+
+    /*
+     * Output methods
+     */
+    @Override
+    public void flush() throws IOException {
+        // NOOP
+    }
+
+
+    @Override
+    public void write(int b) throws IOException {
+        Socket.send(socket, new byte[] {(byte) b}, 0, 1);
+    }
+
+
+    /*
+     * Input methods
+     */
+    @Override
+    public int read() throws IOException {
+        byte[] bytes = new byte[1];
+        Socket.recv(socket, bytes, 0, 1);
+        return bytes[0];
+    }
+
+
+    @Override
+    public int read(byte[] bytes) throws IOException {
+        return Socket.recv(socket, bytes, 0, bytes.length);
+    }
+
+
+    /*
+     * None of the following NO-OP methods are strictly necessary - assuming the
+     * there are no bugs in the connector code that cause upgraded connections
+     * to be treated as Http11, Comet or Async. These NO-OP methods are here for
+     * safety and to aid debugging during development.
+     */
+
+    @Override
+    public SocketState event(SocketStatus status) throws IOException {
+        // TODO Log an error
+        return SocketState.CLOSED;
+    }
+
+
+    @Override
+    public SocketState process(SocketWrapper<Long> socketWrapper)
+            throws IOException {
+        // TODO Log an error
+        return SocketState.CLOSED;
+    }
+
+
+    @Override
+    public SocketState asyncDispatch(SocketStatus status) {
+        // TODO Log an error
+        return SocketState.CLOSED;
+    }
+
+
+    @Override
+    public SocketState asyncPostProcess() {
+        // TODO Log an error
+        return SocketState.CLOSED;
+    }
+
+}

==================================================
UpgradeNioProcessor.java
index a4cbe3bfa1..5e0ac162b9 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeBioProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeBioProcessor.java
@@ -1,123 +1,123 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Socket;
-
-import org.apache.coyote.http11.Http11Processor;
-import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
-import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-/**
- * Implementation note: The need to extend Http11Processor could probably be
- * removed if the Processor interface was expanded to cover all of the methods
- * required by the AbstractProtocol. That would simplify the code and further
- * reduce the size of instances of this class.
- */
-public class UpgradeBioProcessor extends Http11Processor
-        implements UpgradeProcessor{
-
-    private InputStream inputStream;
-    private OutputStream outputStream;
-
-    public UpgradeBioProcessor(SocketWrapper<Socket> wrapper,
-            UpgradeInbound inbound) throws IOException {
-        this.inputStream = wrapper.getSocket().getInputStream();
-        this.outputStream = wrapper.getSocket().getOutputStream();
-        this.upgradeInbound = inbound;
-        upgradeInbound.setUpgradeProcessor(this);
-        upgradeInbound.setUpgradeOutbound(new UpgradeOutbound(this));
-        // Remove the default - no need for it here
-        this.compressableMimeTypes = null;
-    }
-
-
-    @Override
-    public SocketState upgradeDispatch() throws IOException {
-        return upgradeInbound.onData();
-    }
-
-
-    /*
-     * Output methods
-     */
-    @Override
-    public void flush() throws IOException {
-        outputStream.flush();
-    }
-
-
-    @Override
-    public void write(int b) throws IOException {
-        outputStream.write(b);
-    }
-
-
-    /*
-     * Input methods
-     */
-    @Override
-    public int read() throws IOException {
-        return inputStream.read();
-    }
-
-
-    @Override
-    public int read(byte[] bytes) throws IOException {
-        return inputStream.read(bytes);
-    }
-
-
-    /*
-     * None of the following NO-OP methods are strictly necessary - assuming the
-     * there are no bugs in the connector code that cause upgraded connections
-     * to be treated as Http11, Comet or Async. These NO-OP methods are here for
-     * safety and to aid debugging during development.
-     */
-
-    @Override
-    public SocketState event(SocketStatus status) throws IOException {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState process(SocketWrapper<Socket> socketWrapper)
-            throws IOException {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState asyncDispatch(SocketStatus status) {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState asyncPostProcess() {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.Socket;
+
+import org.apache.coyote.http11.Http11Processor;
+import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
+import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketWrapper;
+
+/**
+ * Implementation note: The need to extend Http11Processor could probably be
+ * removed if the Processor interface was expanded to cover all of the methods
+ * required by the AbstractProtocol. That would simplify the code and further
+ * reduce the size of instances of this class.
+ */
+public class UpgradeBioProcessor extends Http11Processor
+        implements UpgradeProcessor{
+
+    private InputStream inputStream;
+    private OutputStream outputStream;
+
+    public UpgradeBioProcessor(SocketWrapper<Socket> wrapper,
+            UpgradeInbound inbound) throws IOException {
+        this.inputStream = wrapper.getSocket().getInputStream();
+        this.outputStream = wrapper.getSocket().getOutputStream();
+        this.upgradeInbound = inbound;
+        upgradeInbound.setUpgradeProcessor(this);
+        upgradeInbound.setUpgradeOutbound(new UpgradeOutbound(this));
+        // Remove the default - no need for it here
+        this.compressableMimeTypes = null;
+    }
+
+
+    @Override
+    public SocketState upgradeDispatch() throws IOException {
+        return upgradeInbound.onData();
+    }
+
+
+    /*
+     * Output methods
+     */
+    @Override
+    public void flush() throws IOException {
+        outputStream.flush();
+    }
+
+
+    @Override
+    public void write(int b) throws IOException {
+        outputStream.write(b);
+    }
+
+
+    /*
+     * Input methods
+     */
+    @Override
+    public int read() throws IOException {
+        return inputStream.read();
+    }
+
+
+    @Override
+    public int read(byte[] bytes) throws IOException {
+        return inputStream.read(bytes);
+    }
+
+
+    /*
+     * None of the following NO-OP methods are strictly necessary - assuming the
+     * there are no bugs in the connector code that cause upgraded connections
+     * to be treated as Http11, Comet or Async. These NO-OP methods are here for
+     * safety and to aid debugging during development.
+     */
+
+    @Override
+    public SocketState event(SocketStatus status) throws IOException {
+        // TODO Log an error
+        return SocketState.CLOSED;
+    }
+
+
+    @Override
+    public SocketState process(SocketWrapper<Socket> socketWrapper)
+            throws IOException {
+        // TODO Log an error
+        return SocketState.CLOSED;
+    }
+
+
+    @Override
+    public SocketState asyncDispatch(SocketStatus status) {
+        // TODO Log an error
+        return SocketState.CLOSED;
+    }
+
+
+    @Override
+    public SocketState asyncPostProcess() {
+        // TODO Log an error
+        return SocketState.CLOSED;
+    }
+}

==================================================
UpgradeProcessor.java
index 3f334411f9..8641ef3c9a 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeNioProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeNioProcessor.java
@@ -1,228 +1,228 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.nio.channels.Selector;
-
-import org.apache.coyote.http11.Http11NioProcessor;
-import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
-import org.apache.tomcat.util.net.NioChannel;
-import org.apache.tomcat.util.net.NioEndpoint;
-import org.apache.tomcat.util.net.NioSelectorPool;
-import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-/**
- * Implementation note: The need to extend Http11Processor could probably be
- * removed if the Processor interface was expanded to cover all of the methods
- * required by the AbstractProtocol. That would simplify the code and further
- * reduce the size of instances of this class.
- */
-public class UpgradeNioProcessor extends Http11NioProcessor
-        implements UpgradeProcessor {
-
-    private NioChannel nioChannel;
-    private NioSelectorPool pool;
-
-    public UpgradeNioProcessor(SocketWrapper<NioChannel> wrapper,
-            UpgradeInbound inbound, NioSelectorPool pool) {
-        this.nioChannel = wrapper.getSocket();
-        this.pool = pool;
-
-        this.upgradeInbound = inbound;
-        upgradeInbound.setUpgradeProcessor(this);
-        upgradeInbound.setUpgradeOutbound(new UpgradeOutbound(this));
-        // Remove the default - no need for it here
-        this.compressableMimeTypes = null;
-    }
-
-
-    @Override
-    public SocketState upgradeDispatch() throws IOException {
-        return upgradeInbound.onData();
-    }
-
-
-    /*
-     * Output methods
-     */
-    @Override
-    public void flush() throws IOException {
-        NioEndpoint.KeyAttachment att =
-                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
-        if (att == null) {
-            throw new IOException("Key must be cancelled");
-        }
-        long writeTimeout = att.getTimeout();
-        Selector selector = null;
-        try {
-            selector = pool.get();
-        } catch ( IOException x ) {
-            //ignore
-        }
-        try {
-            do {
-                if (nioChannel.flush(true, selector, writeTimeout)) {
-                    break;
-                }
-            } while (true);
-        } finally {
-            if (selector != null) {
-                pool.put(selector);
-            }
-        }
-    }
-
-    @Override
-    public void write(int b) throws IOException {
-        writeToSocket(new byte[] {(byte) b});
-    }
-
-    /*
-     * Input methods
-     */
-    @Override
-    public int read() throws IOException {
-        byte[] bytes = new byte[1];
-        readSocket(true, bytes, 0, 1);
-        return bytes[0];
-    }
-
-    @Override
-    public int read(byte[] bytes) throws IOException {
-        return readSocket(true, bytes, 0, bytes.length);
-    }
-
-
-    /*
-     * Adapted from the NioInputBuffer.
-     */
-    private int readSocket(boolean block, byte[] bytes, int offset, int len)
-            throws IOException {
-
-        int nRead = 0;
-        nioChannel.getBufHandler().getReadBuffer().clear();
-        nioChannel.getBufHandler().getReadBuffer().limit(len);
-        if (block) {
-            Selector selector = null;
-            try {
-                selector = pool.get();
-            } catch ( IOException x ) {
-                // Ignore
-            }
-            try {
-                NioEndpoint.KeyAttachment att =
-                        (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
-                if (att == null) {
-                    throw new IOException("Key must be cancelled.");
-                }
-                nRead = pool.read(nioChannel.getBufHandler().getReadBuffer(),
-                        nioChannel, selector, att.getTimeout());
-            } catch (EOFException eof) {
-                nRead = -1;
-            } finally {
-                if (selector != null) {
-                    pool.put(selector);
-                }
-            }
-        } else {
-            nRead = nioChannel.read(nioChannel.getBufHandler().getReadBuffer());
-        }
-        if (nRead > 0) {
-            nioChannel.getBufHandler().getReadBuffer().flip();
-            nioChannel.getBufHandler().getReadBuffer().limit(nRead);
-            nioChannel.getBufHandler().getReadBuffer().get(bytes, offset, nRead);
-            return nRead;
-        } else if (nRead == -1) {
-            //return false;
-            throw new EOFException(sm.getString("iib.eof.error"));
-        } else {
-            return 0;
-        }
-    }
-
-
-    /*
-     * Adapted from the NioOutputBuffer
-     */
-    private synchronized int writeToSocket(byte[] bytes) throws IOException {
-
-        nioChannel.getBufHandler().getWriteBuffer().clear();
-        nioChannel.getBufHandler().getWriteBuffer().put(bytes);
-        nioChannel.getBufHandler().getWriteBuffer().flip();
-
-        int written = 0;
-        NioEndpoint.KeyAttachment att =
-                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
-        if (att == null) {
-            throw new IOException("Key must be cancelled");
-        }
-        long writeTimeout = att.getTimeout();
-        Selector selector = null;
-        try {
-            selector = pool.get();
-        } catch ( IOException x ) {
-            //ignore
-        }
-        try {
-            written = pool.write(nioChannel.getBufHandler().getWriteBuffer(),
-                    nioChannel, selector, writeTimeout, true);
-        } finally {
-            if (selector != null) {
-                pool.put(selector);
-            }
-        }
-        return written;
-    }
-
-    /*
-     * None of the following NO-OP methods are strictly necessary - assuming the
-     * there are no bugs in the connector code that cause upgraded connections
-     * to be treated as Http11, Comet or Async. These NO-OP methods are here for
-     * safety and to aid debugging during development.
-     */
-
-    @Override
-    public SocketState event(SocketStatus status) throws IOException {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState process(SocketWrapper<NioChannel> socketWrapper)
-            throws IOException {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState asyncDispatch(SocketStatus status) {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState asyncPostProcess() {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.channels.Selector;
+
+import org.apache.coyote.http11.Http11NioProcessor;
+import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
+import org.apache.tomcat.util.net.NioChannel;
+import org.apache.tomcat.util.net.NioEndpoint;
+import org.apache.tomcat.util.net.NioSelectorPool;
+import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketWrapper;
+
+/**
+ * Implementation note: The need to extend Http11Processor could probably be
+ * removed if the Processor interface was expanded to cover all of the methods
+ * required by the AbstractProtocol. That would simplify the code and further
+ * reduce the size of instances of this class.
+ */
+public class UpgradeNioProcessor extends Http11NioProcessor
+        implements UpgradeProcessor {
+
+    private NioChannel nioChannel;
+    private NioSelectorPool pool;
+
+    public UpgradeNioProcessor(SocketWrapper<NioChannel> wrapper,
+            UpgradeInbound inbound, NioSelectorPool pool) {
+        this.nioChannel = wrapper.getSocket();
+        this.pool = pool;
+
+        this.upgradeInbound = inbound;
+        upgradeInbound.setUpgradeProcessor(this);
+        upgradeInbound.setUpgradeOutbound(new UpgradeOutbound(this));
+        // Remove the default - no need for it here
+        this.compressableMimeTypes = null;
+    }
+
+
+    @Override
+    public SocketState upgradeDispatch() throws IOException {
+        return upgradeInbound.onData();
+    }
+
+
+    /*
+     * Output methods
+     */
+    @Override
+    public void flush() throws IOException {
+        NioEndpoint.KeyAttachment att =
+                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
+        if (att == null) {
+            throw new IOException("Key must be cancelled");
+        }
+        long writeTimeout = att.getTimeout();
+        Selector selector = null;
+        try {
+            selector = pool.get();
+        } catch ( IOException x ) {
+            //ignore
+        }
+        try {
+            do {
+                if (nioChannel.flush(true, selector, writeTimeout)) {
+                    break;
+                }
+            } while (true);
+        } finally {
+            if (selector != null) {
+                pool.put(selector);
+            }
+        }
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+        writeToSocket(new byte[] {(byte) b});
+    }
+
+    /*
+     * Input methods
+     */
+    @Override
+    public int read() throws IOException {
+        byte[] bytes = new byte[1];
+        readSocket(true, bytes, 0, 1);
+        return bytes[0];
+    }
+
+    @Override
+    public int read(byte[] bytes) throws IOException {
+        return readSocket(true, bytes, 0, bytes.length);
+    }
+
+
+    /*
+     * Adapted from the NioInputBuffer.
+     */
+    private int readSocket(boolean block, byte[] bytes, int offset, int len)
+            throws IOException {
+
+        int nRead = 0;
+        nioChannel.getBufHandler().getReadBuffer().clear();
+        nioChannel.getBufHandler().getReadBuffer().limit(len);
+        if (block) {
+            Selector selector = null;
+            try {
+                selector = pool.get();
+            } catch ( IOException x ) {
+                // Ignore
+            }
+            try {
+                NioEndpoint.KeyAttachment att =
+                        (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
+                if (att == null) {
+                    throw new IOException("Key must be cancelled.");
+                }
+                nRead = pool.read(nioChannel.getBufHandler().getReadBuffer(),
+                        nioChannel, selector, att.getTimeout());
+            } catch (EOFException eof) {
+                nRead = -1;
+            } finally {
+                if (selector != null) {
+                    pool.put(selector);
+                }
+            }
+        } else {
+            nRead = nioChannel.read(nioChannel.getBufHandler().getReadBuffer());
+        }
+        if (nRead > 0) {
+            nioChannel.getBufHandler().getReadBuffer().flip();
+            nioChannel.getBufHandler().getReadBuffer().limit(nRead);
+            nioChannel.getBufHandler().getReadBuffer().get(bytes, offset, nRead);
+            return nRead;
+        } else if (nRead == -1) {
+            //return false;
+            throw new EOFException(sm.getString("iib.eof.error"));
+        } else {
+            return 0;
+        }
+    }
+
+
+    /*
+     * Adapted from the NioOutputBuffer
+     */
+    private synchronized int writeToSocket(byte[] bytes) throws IOException {
+
+        nioChannel.getBufHandler().getWriteBuffer().clear();
+        nioChannel.getBufHandler().getWriteBuffer().put(bytes);
+        nioChannel.getBufHandler().getWriteBuffer().flip();
+
+        int written = 0;
+        NioEndpoint.KeyAttachment att =
+                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
+        if (att == null) {
+            throw new IOException("Key must be cancelled");
+        }
+        long writeTimeout = att.getTimeout();
+        Selector selector = null;
+        try {
+            selector = pool.get();
+        } catch ( IOException x ) {
+            //ignore
+        }
+        try {
+            written = pool.write(nioChannel.getBufHandler().getWriteBuffer(),
+                    nioChannel, selector, writeTimeout, true);
+        } finally {
+            if (selector != null) {
+                pool.put(selector);
+            }
+        }
+        return written;
+    }
+
+    /*
+     * None of the following NO-OP methods are strictly necessary - assuming the
+     * there are no bugs in the connector code that cause upgraded connections
+     * to be treated as Http11, Comet or Async. These NO-OP methods are here for
+     * safety and to aid debugging during development.
+     */
+
+    @Override
+    public SocketState event(SocketStatus status) throws IOException {
+        // TODO Log an error
+        return SocketState.CLOSED;
+    }
+
+
+    @Override
+    public SocketState process(SocketWrapper<NioChannel> socketWrapper)
+            throws IOException {
+        // TODO Log an error
+        return SocketState.CLOSED;
+    }
+
+
+    @Override
+    public SocketState asyncDispatch(SocketStatus status) {
+        // TODO Log an error
+        return SocketState.CLOSED;
+    }
+
+
+    @Override
+    public SocketState asyncPostProcess() {
+        // TODO Log an error
+        return SocketState.CLOSED;
+    }
+}

==================================================
