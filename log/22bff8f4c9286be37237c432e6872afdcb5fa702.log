22bff8f4c9286be37237c432e6872afdcb5fa702
==================================================
Connector refactoring
==================================================
Mark Emlyn
==================================================
Wed Jun 22 23:29:51 2011 +0000
==================================================
AjpNioProtocol.java
Connector refactoring
Another small step towards SocketWrapper for NIO

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1138681 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http11NioProtocol.java
index 6aadcebc2a..9053c056e4 100644
--- a/java/org/apache/coyote/ajp/AjpNioProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpNioProtocol.java
@@ -94,8 +94,8 @@ public class AjpNioProtocol extends AbstractAjpProtocol {
 
         protected AjpNioProtocol proto;
 
-        protected ConcurrentHashMap<NioChannel, AjpNioProcessor> connections =
-            new ConcurrentHashMap<NioChannel, AjpNioProcessor>();
+        protected ConcurrentHashMap<SocketWrapper<NioChannel>, AjpNioProcessor> connections =
+            new ConcurrentHashMap<SocketWrapper<NioChannel>, AjpNioProcessor>();
 
         protected RecycledProcessors<AjpNioProcessor> recycledProcessors =
             new RecycledProcessors<AjpNioProcessor>(this);
@@ -130,10 +130,10 @@ public class AjpNioProtocol extends AbstractAjpProtocol {
             if (log.isDebugEnabled()) 
                 log.debug("Iterating through our connections to release a socket channel:"+socket);
             boolean released = false;
-            Iterator<java.util.Map.Entry<NioChannel, AjpNioProcessor>> it = connections.entrySet().iterator();
+            Iterator<java.util.Map.Entry<SocketWrapper<NioChannel>, AjpNioProcessor>> it = connections.entrySet().iterator();
             while (it.hasNext()) {
-                java.util.Map.Entry<NioChannel, AjpNioProcessor> entry = it.next();
-                if (entry.getKey().getIOChannel()==socket) {
+                java.util.Map.Entry<SocketWrapper<NioChannel>, AjpNioProcessor> entry = it.next();
+                if (entry.getKey().getSocket().getIOChannel()==socket) {
                     it.remove();
                     AjpNioProcessor result = entry.getValue();
                     result.recycle();
@@ -151,7 +151,7 @@ public class AjpNioProtocol extends AbstractAjpProtocol {
          * {@link #release(NioChannel, AjpNioProcessor)}.
          */
         @Override
-        public void release(NioChannel socket) {
+        public void release(SocketWrapper<NioChannel> socket) {
             AjpNioProcessor processor = connections.remove(socket);
             if (processor != null) {
                 processor.recycle();
@@ -160,7 +160,8 @@ public class AjpNioProtocol extends AbstractAjpProtocol {
         }
 
 
-        public void release(NioChannel socket, AjpNioProcessor processor) {
+        public void release(SocketWrapper<NioChannel> socket,
+                AjpNioProcessor processor) {
             connections.remove(socket);
             processor.recycle();
             recycledProcessors.offer(processor);
@@ -170,7 +171,7 @@ public class AjpNioProtocol extends AbstractAjpProtocol {
         public SocketState process(SocketWrapper<NioChannel> socketWrapper,
                 SocketStatus status) {
             NioChannel socket = socketWrapper.getSocket();
-            AjpNioProcessor processor = connections.remove(socket);
+            AjpNioProcessor processor = connections.remove(socketWrapper);
 
             socketWrapper.setAsync(false); //no longer check for timeout
 
@@ -198,17 +199,17 @@ public class AjpNioProtocol extends AbstractAjpProtocol {
                 if (state == SocketState.LONG) {
                     // In the middle of processing a request/response. Keep the
                     // socket associated with the processor.
-                    connections.put(socket, processor);
+                    connections.put(socketWrapper, processor);
                     
                     socketWrapper.setAsync(true);
                 } else if (state == SocketState.OPEN){
                     // In keep-alive but between requests. OK to recycle
                     // processor. Continue to poll for the next request.
-                    release(socket, processor);
+                    release(socketWrapper, processor);
                     socket.getPoller().add(socket);
                 } else {
                     // Connection closed. OK to recycle the processor.
-                    release(socket, processor);
+                    release(socketWrapper, processor);
                 }
                 return state;
 
@@ -231,7 +232,7 @@ public class AjpNioProtocol extends AbstractAjpProtocol {
                 // less-than-verbose logs.
                 log.error(sm.getString("ajpprotocol.proto.error"), e);
             }
-            release(socket, processor);
+            release(socketWrapper, processor);
             return SocketState.CLOSED;
         }
 

==================================================
NioEndpoint.java
index 092d0f573f..ed2394259a 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -156,8 +156,8 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
 
         protected Http11NioProtocol proto;
 
-        protected ConcurrentHashMap<NioChannel, Http11NioProcessor> connections =
-            new ConcurrentHashMap<NioChannel, Http11NioProcessor>();
+        protected ConcurrentHashMap<SocketWrapper<NioChannel>, Http11NioProcessor> connections =
+            new ConcurrentHashMap<SocketWrapper<NioChannel>, Http11NioProcessor>();
 
         protected RecycledProcessors<Http11NioProcessor> recycledProcessors =
             new RecycledProcessors<Http11NioProcessor>(this);
@@ -192,10 +192,10 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
             if (log.isDebugEnabled()) 
                 log.debug("Iterating through our connections to release a socket channel:"+socket);
             boolean released = false;
-            Iterator<java.util.Map.Entry<NioChannel, Http11NioProcessor>> it = connections.entrySet().iterator();
+            Iterator<java.util.Map.Entry<SocketWrapper<NioChannel>, Http11NioProcessor>> it = connections.entrySet().iterator();
             while (it.hasNext()) {
-                java.util.Map.Entry<NioChannel, Http11NioProcessor> entry = it.next();
-                if (entry.getKey().getIOChannel()==socket) {
+                java.util.Map.Entry<SocketWrapper<NioChannel>, Http11NioProcessor> entry = it.next();
+                if (entry.getKey().getSocket().getIOChannel()==socket) {
                     it.remove();
                     Http11NioProcessor result = entry.getValue();
                     result.recycle();
@@ -213,7 +213,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
          * {@link #release(NioChannel, Http11NioProcessor)}.
          */
         @Override
-        public void release(NioChannel socket) {
+        public void release(SocketWrapper<NioChannel> socket) {
             Http11NioProcessor processor = connections.remove(socket);
             if (processor != null) {
                 processor.recycle();
@@ -222,7 +222,8 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
         }
 
 
-        public void release(NioChannel socket, Http11NioProcessor processor) {
+        public void release(SocketWrapper<NioChannel> socket,
+                Http11NioProcessor processor) {
             connections.remove(socket);
             processor.recycle();
             recycledProcessors.offer(processor);
@@ -233,7 +234,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
         public SocketState process(SocketWrapper<NioChannel> socketWrapper,
                 SocketStatus status) {
             NioChannel socket = socketWrapper.getSocket();
-            Http11NioProcessor processor = connections.remove(socket);
+            Http11NioProcessor processor = connections.remove(socketWrapper);
 
             socketWrapper.setAsync(false); //no longer check for timeout
 
@@ -274,7 +275,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
                 if (state == SocketState.LONG) {
                     // In the middle of processing a request/response. Keep the
                     // socket associated with the processor.
-                    connections.put(socket, processor);
+                    connections.put(socketWrapper, processor);
                     
                     if (processor.isAsync()) {
                         socketWrapper.setAsync(true);
@@ -292,11 +293,11 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
                 } else if (state == SocketState.OPEN){
                     // In keep-alive but between requests. OK to recycle
                     // processor. Continue to poll for the next request.
-                    release(socket, processor);
+                    release(socketWrapper, processor);
                     socket.getPoller().add(socket);
                 } else {
                     // Connection closed. OK to recycle the processor.
-                    release(socket, processor);
+                    release(socketWrapper, processor);
                 }
                 return state;
 
@@ -319,7 +320,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
                 // less-than-verbose logs.
                 log.error(sm.getString("http11protocol.proto.error"), e);
             }
-            release(socket, processor);
+            release(socketWrapper, processor);
             return SocketState.CLOSED;
         }
 

==================================================
