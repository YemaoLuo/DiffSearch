a7da4da743212f6e17da49f159b7180d1472d34c
==================================================
Code cleanup (format). No functional change.
==================================================
Mark Thomas
==================================================
Tue Jan 24 13:03:02 2023 +0000
==================================================
AccessLogAdapter.java
Code cleanup (format). No functional change.


==================================================
ApplicationContext.java
index e3705664d1..8a107a4409 100644
--- a/java/org/apache/catalina/core/AccessLogAdapter.java
+++ b/java/org/apache/catalina/core/AccessLogAdapter.java
@@ -44,7 +44,7 @@ public class AccessLogAdapter implements AccessLog {
 
     @Override
     public void log(Request request, Response response, long time) {
-        for (AccessLog log: logs) {
+        for (AccessLog log : logs) {
             log.log(request, response, time);
         }
     }

==================================================
ApplicationContextFacade.java
index c91a62392d..6e95d1c7df 100644
--- a/java/org/apache/catalina/core/ApplicationContext.java
+++ b/java/org/apache/catalina/core/ApplicationContext.java
@@ -81,9 +81,8 @@ import org.apache.tomcat.util.res.StringManager;
 
 
 /**
- * Standard implementation of <code>ServletContext</code> that represents
- * a web application's execution environment.  An instance of this class is
- * associated with each instance of <code>StandardContext</code>.
+ * Standard implementation of <code>ServletContext</code> that represents a web application's execution environment. An
+ * instance of this class is associated with each instance of <code>StandardContext</code>.
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
@@ -93,8 +92,7 @@ public class ApplicationContext implements ServletContext {
     // ----------------------------------------------------------- Constructors
 
     /**
-     * Construct a new instance of this class, associated with the specified
-     * Context instance.
+     * Construct a new instance of this class, associated with the specified Context instance.
      *
      * @param context The associated Context instance
      */
@@ -115,13 +113,13 @@ public class ApplicationContext implements ServletContext {
     /**
      * The context attributes for this context.
      */
-    protected Map<String,Object> attributes = new ConcurrentHashMap<>();
+    protected Map<String, Object> attributes = new ConcurrentHashMap<>();
 
 
     /**
      * List of read only attributes for this context.
      */
-    private final Map<String,String> readOnlyAttributes = new ConcurrentHashMap<>();
+    private final Map<String, String> readOnlyAttributes = new ConcurrentHashMap<>();
 
 
     /**
@@ -145,7 +143,7 @@ public class ApplicationContext implements ServletContext {
     /**
      * The merged context initialization parameters for this Context.
      */
-    private final Map<String,String> parameters = new ConcurrentHashMap<>();
+    private final Map<String, String> parameters = new ConcurrentHashMap<>();
 
 
     /**
@@ -173,9 +171,8 @@ public class ApplicationContext implements ServletContext {
     private Set<SessionTrackingMode> supportedSessionTrackingModes = null;
 
     /**
-     * Flag that indicates if a new {@link ServletContextListener} may be added
-     * to the application. Once the first {@link ServletContextListener} is
-     * called, no more may be added.
+     * Flag that indicates if a new {@link ServletContextListener} may be added to the application. Once the first
+     * {@link ServletContextListener} is called, no more may be added.
      */
     private boolean newServletContextListenerAllowed = true;
 
@@ -221,9 +218,9 @@ public class ApplicationContext implements ServletContext {
                     uri = uri.substring(0, i);
                 }
                 // Note: This could be more efficient with a dedicated Mapper
-                //       method but such an implementation would require some
-                //       refactoring of the Mapper to avoid copy/paste of
-                //       existing code.
+                // method but such an implementation would require some
+                // refactoring of the Mapper to avoid copy/paste of
+                // existing code.
                 MessageBytes hostMB = MessageBytes.newInstance();
                 hostMB.setString(host.getName());
 
@@ -266,8 +263,7 @@ public class ApplicationContext implements ServletContext {
     public String getInitParameter(final String name) {
         // Special handling for XML settings as the context setting must
         // always override anything that might have been set by an application.
-        if (Globals.JASPER_XML_VALIDATION_TLD_INIT_PARAM.equals(name) &&
-                context.getTldValidation()) {
+        if (Globals.JASPER_XML_VALIDATION_TLD_INIT_PARAM.equals(name) && context.getTldValidation()) {
             return "true";
         }
         if (Globals.JASPER_XML_BLOCK_EXTERNAL_INIT_PARAM.equals(name)) {
@@ -308,8 +304,7 @@ public class ApplicationContext implements ServletContext {
 
 
     /**
-     * Return the MIME type of the specified file, or <code>null</code> if
-     * the MIME type cannot be determined.
+     * Return the MIME type of the specified file, or <code>null</code> if the MIME type cannot be determined.
      *
      * @param file Filename for which to identify a MIME type
      */
@@ -333,8 +328,7 @@ public class ApplicationContext implements ServletContext {
 
 
     /**
-     * Return a <code>RequestDispatcher</code> object that acts as a
-     * wrapper for the named servlet.
+     * Return a <code>RequestDispatcher</code> object that acts as a wrapper for the named servlet.
      *
      * @param name Name of the servlet for which a dispatcher is requested
      */
@@ -372,8 +366,7 @@ public class ApplicationContext implements ServletContext {
             return null;
         }
         if (!path.startsWith("/")) {
-            throw new IllegalArgumentException(
-                    sm.getString("applicationContext.requestDispatcher.iae", path));
+            throw new IllegalArgumentException(sm.getString("applicationContext.requestDispatcher.iae", path));
         }
 
         // Same processing order as InputBuffer / CoyoteAdapter
@@ -407,8 +400,7 @@ public class ApplicationContext implements ServletContext {
             // Security check to catch attempts to encode /../ sequences
             normalizedUri = RequestUtil.normalize(decodedUri);
             if (!decodedUri.equals(normalizedUri)) {
-                getContext().getLogger().warn(
-                        sm.getString("applicationContext.illegalDispatchPath", path),
+                getContext().getLogger().warn(sm.getString("applicationContext.illegalDispatchPath", path),
                         new IllegalArgumentException());
                 return null;
             }
@@ -457,8 +449,7 @@ public class ApplicationContext implements ServletContext {
             HttpServletMapping mapping = new ApplicationMapping(mappingData).getHttpServletMapping();
 
             // Construct a RequestDispatcher to process this request
-            return new ApplicationDispatcher(wrapper, uri, wrapperPath, pathInfo,
-                    queryString, mapping, null);
+            return new ApplicationDispatcher(wrapper, uri, wrapperPath, pathInfo, queryString, mapping, null);
         } finally {
             // Recycle thread local data at the end of the request so references
             // are not held to a completed request as there is potential for
@@ -506,8 +497,7 @@ public class ApplicationContext implements ServletContext {
         String validatedPath = validateResourcePath(path, !context.getContextGetResourceRequiresSlash());
 
         if (validatedPath == null) {
-            throw new MalformedURLException(
-                    sm.getString("applicationContext.requestDispatcher.iae", path));
+            throw new MalformedURLException(sm.getString("applicationContext.requestDispatcher.iae", path));
         }
 
         WebResourceRoot resources = context.getResources();
@@ -538,8 +528,7 @@ public class ApplicationContext implements ServletContext {
 
 
     /*
-     * Returns null if the input path is not valid or a path that will be
-     * acceptable to resources.getResource().
+     * Returns null if the input path is not valid or a path that will be acceptable to resources.getResource().
      */
     private String validateResourcePath(String path, boolean addMissingInitialSlash) {
         if (path == null) {
@@ -566,7 +555,7 @@ public class ApplicationContext implements ServletContext {
             return null;
         }
         if (!path.startsWith("/")) {
-            throw new IllegalArgumentException (sm.getString("applicationContext.resourcePaths.iae", path));
+            throw new IllegalArgumentException(sm.getString("applicationContext.resourcePaths.iae", path));
         }
 
         WebResourceRoot resources = context.getResources();
@@ -609,7 +598,7 @@ public class ApplicationContext implements ServletContext {
 
         // Remove the specified attribute
         // Check for read only attribute
-        if (readOnlyAttributes.containsKey(name)){
+        if (readOnlyAttributes.containsKey(name)) {
             return;
         }
         value = attributes.remove(name);
@@ -622,8 +611,7 @@ public class ApplicationContext implements ServletContext {
         if ((listeners == null) || (listeners.length == 0)) {
             return;
         }
-        ServletContextAttributeEvent event = new ServletContextAttributeEvent(
-                context.getServletContext(), name, value);
+        ServletContextAttributeEvent event = new ServletContextAttributeEvent(context.getServletContext(), name, value);
         for (Object obj : listeners) {
             if (!(obj instanceof ServletContextAttributeListener)) {
                 continue;
@@ -719,18 +707,16 @@ public class ApplicationContext implements ServletContext {
 
 
     @Override
-    public FilterRegistration.Dynamic addFilter(String filterName,
-            Class<? extends Filter> filterClass) {
+    public FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass) {
         return addFilter(filterName, filterClass.getName(), null);
     }
 
 
-    private FilterRegistration.Dynamic addFilter(String filterName,
-            String filterClass, Filter filter) throws IllegalStateException {
+    private FilterRegistration.Dynamic addFilter(String filterName, String filterClass, Filter filter)
+            throws IllegalStateException {
 
         if (filterName == null || filterName.equals("")) {
-            throw new IllegalArgumentException(sm.getString(
-                    "applicationContext.invalidFilterName", filterName));
+            throw new IllegalArgumentException(sm.getString("applicationContext.invalidFilterName", filterName));
         }
 
         // TODO Spec breaking enhancement to ignore this restriction
@@ -745,8 +731,7 @@ public class ApplicationContext implements ServletContext {
             filterDef.setFilterName(filterName);
             context.addFilterDef(filterDef);
         } else {
-            if (filterDef.getFilterName() != null &&
-                    filterDef.getFilterClass() != null) {
+            if (filterDef.getFilterName() != null && filterDef.getFilterClass() != null) {
                 return null;
             }
         }
@@ -800,8 +785,7 @@ public class ApplicationContext implements ServletContext {
 
 
     @Override
-    public ServletRegistration.Dynamic addServlet(String servletName,
-            Class<? extends Servlet> servletClass) {
+    public ServletRegistration.Dynamic addServlet(String servletName, Class<? extends Servlet> servletClass) {
         return addServlet(servletName, servletClass.getName(), null, null);
     }
 
@@ -811,12 +795,11 @@ public class ApplicationContext implements ServletContext {
 
         // jspName is validated in addServlet()
         if (jspFile == null || !jspFile.startsWith("/")) {
-            throw new IllegalArgumentException(
-                    sm.getString("applicationContext.addJspFile.iae", jspFile));
+            throw new IllegalArgumentException(sm.getString("applicationContext.addJspFile.iae", jspFile));
         }
 
         String jspServletClassName = null;
-        Map<String,String> jspFileInitParams = new HashMap<>();
+        Map<String, String> jspFileInitParams = new HashMap<>();
 
         Wrapper jspServlet = (Wrapper) context.findChild("jsp");
 
@@ -842,12 +825,11 @@ public class ApplicationContext implements ServletContext {
     }
 
 
-    private ServletRegistration.Dynamic addServlet(String servletName, String servletClass,
-            Servlet servlet, Map<String,String> initParams) throws IllegalStateException {
+    private ServletRegistration.Dynamic addServlet(String servletName, String servletClass, Servlet servlet,
+            Map<String, String> initParams) throws IllegalStateException {
 
         if (servletName == null || servletName.equals("")) {
-            throw new IllegalArgumentException(sm.getString(
-                    "applicationContext.invalidServletName", servletName));
+            throw new IllegalArgumentException(sm.getString("applicationContext.invalidServletName", servletName));
         }
 
         // TODO Spec breaking enhancement to ignore this restriction
@@ -862,8 +844,7 @@ public class ApplicationContext implements ServletContext {
             wrapper.setName(servletName);
             context.addChild(wrapper);
         } else {
-            if (wrapper.getName() != null &&
-                    wrapper.getServletClass() != null) {
+            if (wrapper.getName() != null && wrapper.getServletClass() != null) {
                 if (wrapper.isOverridable()) {
                     wrapper.setOverridable(false);
                 } else {
@@ -888,13 +869,12 @@ public class ApplicationContext implements ServletContext {
         }
 
         if (initParams != null) {
-            for (Map.Entry<String, String> initParam: initParams.entrySet()) {
+            for (Map.Entry<String, String> initParam : initParams.entrySet()) {
                 wrapper.addInitParameter(initParam.getKey(), initParam.getValue());
             }
         }
 
-        ServletRegistration.Dynamic registration =
-                new ApplicationServletRegistration(wrapper, context);
+        ServletRegistration.Dynamic registration = new ApplicationServletRegistration(wrapper, context);
         if (annotation != null) {
             registration.setServletSecurity(new ServletSecurityElement(annotation));
         }
@@ -981,8 +961,7 @@ public class ApplicationContext implements ServletContext {
         // Check that only supported tracking modes have been requested
         for (SessionTrackingMode sessionTrackingMode : sessionTrackingModes) {
             if (!supportedSessionTrackingModes.contains(sessionTrackingMode)) {
-                throw new IllegalArgumentException(sm.getString(
-                        "applicationContext.setSessionTracking.iae.invalid",
+                throw new IllegalArgumentException(sm.getString("applicationContext.setSessionTracking.iae.invalid",
                         sessionTrackingMode.toString(), getContextPath()));
             }
         }
@@ -990,9 +969,8 @@ public class ApplicationContext implements ServletContext {
         // Check SSL has not be configured with anything else
         if (sessionTrackingModes.contains(SessionTrackingMode.SSL)) {
             if (sessionTrackingModes.size() > 1) {
-                throw new IllegalArgumentException(sm.getString(
-                        "applicationContext.setSessionTracking.iae.ssl",
-                        getContextPath()));
+                throw new IllegalArgumentException(
+                        sm.getString("applicationContext.setSessionTracking.iae.ssl", getContextPath()));
             }
         }
 
@@ -1017,9 +995,8 @@ public class ApplicationContext implements ServletContext {
         try {
             listener = createListener(listenerClass);
         } catch (ServletException e) {
-            throw new IllegalArgumentException(sm.getString(
-                    "applicationContext.addListener.iae.init",
-                    listenerClass.getName()), e);
+            throw new IllegalArgumentException(
+                    sm.getString("applicationContext.addListener.iae.init", listenerClass.getName()), e);
         }
         addListener(listener);
     }
@@ -1033,9 +1010,8 @@ public class ApplicationContext implements ServletContext {
                 Object obj = context.getInstanceManager().newInstance(className);
 
                 if (!(obj instanceof EventListener)) {
-                    throw new IllegalArgumentException(sm.getString(
-                            "applicationContext.addListener.iae.wrongType",
-                            className));
+                    throw new IllegalArgumentException(
+                            sm.getString("applicationContext.addListener.iae.wrongType", className));
                 }
 
                 EventListener listener = (EventListener) obj;
@@ -1043,13 +1019,9 @@ public class ApplicationContext implements ServletContext {
             }
         } catch (InvocationTargetException e) {
             ExceptionUtils.handleThrowable(e.getCause());
-            throw new IllegalArgumentException(sm.getString(
-                    "applicationContext.addListener.iae.cnfe", className),
-                    e);
-        } catch (ReflectiveOperationException| NamingException e) {
-            throw new IllegalArgumentException(sm.getString(
-                    "applicationContext.addListener.iae.cnfe", className),
-                    e);
+            throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe", className), e);
+        } catch (ReflectiveOperationException | NamingException e) {
+            throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe", className), e);
         }
 
     }
@@ -1060,10 +1032,8 @@ public class ApplicationContext implements ServletContext {
         checkState("applicationContext.addListener.ise");
 
         boolean match = false;
-        if (t instanceof ServletContextAttributeListener ||
-                t instanceof ServletRequestListener ||
-                t instanceof ServletRequestAttributeListener ||
-                t instanceof HttpSessionIdListener ||
+        if (t instanceof ServletContextAttributeListener || t instanceof ServletRequestListener ||
+                t instanceof ServletRequestAttributeListener || t instanceof HttpSessionIdListener ||
                 t instanceof HttpSessionAttributeListener) {
             context.addApplicationEventListener(t);
             match = true;
@@ -1082,35 +1052,28 @@ public class ApplicationContext implements ServletContext {
         }
 
         if (t instanceof ServletContextListener) {
-            throw new IllegalArgumentException(sm.getString(
-                    "applicationContext.addListener.iae.sclNotAllowed",
-                    t.getClass().getName()));
+            throw new IllegalArgumentException(
+                    sm.getString("applicationContext.addListener.iae.sclNotAllowed", t.getClass().getName()));
         } else {
-            throw new IllegalArgumentException(sm.getString(
-                    "applicationContext.addListener.iae.wrongType",
-                    t.getClass().getName()));
+            throw new IllegalArgumentException(
+                    sm.getString("applicationContext.addListener.iae.wrongType", t.getClass().getName()));
         }
     }
 
 
     @Override
-    public <T extends EventListener> T createListener(Class<T> c)
-            throws ServletException {
+    public <T extends EventListener> T createListener(Class<T> c) throws ServletException {
         try {
             @SuppressWarnings("unchecked")
             T listener = (T) context.getInstanceManager().newInstance(c);
-            if (listener instanceof ServletContextListener ||
-                    listener instanceof ServletContextAttributeListener ||
-                    listener instanceof ServletRequestListener ||
-                    listener instanceof ServletRequestAttributeListener ||
-                    listener instanceof HttpSessionListener ||
-                    listener instanceof HttpSessionIdListener ||
+            if (listener instanceof ServletContextListener || listener instanceof ServletContextAttributeListener ||
+                    listener instanceof ServletRequestListener || listener instanceof ServletRequestAttributeListener ||
+                    listener instanceof HttpSessionListener || listener instanceof HttpSessionIdListener ||
                     listener instanceof HttpSessionAttributeListener) {
                 return listener;
             }
-            throw new IllegalArgumentException(sm.getString(
-                    "applicationContext.addListener.iae.wrongType",
-                    listener.getClass().getName()));
+            throw new IllegalArgumentException(
+                    sm.getString("applicationContext.addListener.iae.wrongType", listener.getClass().getName()));
         } catch (InvocationTargetException e) {
             ExceptionUtils.handleThrowable(e.getCause());
             throw new ServletException(e);
@@ -1127,16 +1090,12 @@ public class ApplicationContext implements ServletContext {
         checkState("applicationContext.addRole.ise");
 
         if (roleNames == null) {
-            throw new IllegalArgumentException(
-                    sm.getString("applicationContext.roles.iae",
-                            getContextPath()));
+            throw new IllegalArgumentException(sm.getString("applicationContext.roles.iae", getContextPath()));
         }
 
         for (String role : roleNames) {
             if (role == null || role.isEmpty()) {
-                throw new IllegalArgumentException(
-                        sm.getString("applicationContext.role.iae",
-                                getContextPath()));
+                throw new IllegalArgumentException(sm.getString("applicationContext.role.iae", getContextPath()));
             }
             context.addSecurityRole(role);
         }
@@ -1167,8 +1126,7 @@ public class ApplicationContext implements ServletContext {
 
         FilterDef[] filterDefs = context.findFilterDefs();
         for (FilterDef filterDef : filterDefs) {
-            result.put(filterDef.getFilterName(),
-                    new ApplicationFilterRegistration(filterDef, context));
+            result.put(filterDef.getFilterName(), new ApplicationFilterRegistration(filterDef, context));
         }
 
         return result;
@@ -1187,9 +1145,7 @@ public class ApplicationContext implements ServletContext {
 
         Container[] wrappers = context.findChildren();
         for (Container wrapper : wrappers) {
-            result.put(wrapper.getName(),
-                    new ApplicationServletRegistration(
-                            (Wrapper) wrapper, context));
+            result.put(wrapper.getName(), new ApplicationServletRegistration((Wrapper) wrapper, context));
         }
 
         return result;
@@ -1246,7 +1202,7 @@ public class ApplicationContext implements ServletContext {
 
     private void checkState(String messageKey) {
         if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
-            throw new IllegalStateException(sm.getString(messageKey,getContextPath()));
+            throw new IllegalStateException(sm.getString(messageKey, getContextPath()));
         }
     }
 
@@ -1298,8 +1254,7 @@ public class ApplicationContext implements ServletContext {
     }
 
     /**
-     * Internal class used as thread-local storage when doing path
-     * mapping during dispatch.
+     * Internal class used as thread-local storage when doing path mapping during dispatch.
      */
     private static final class DispatchData {
 

==================================================
ApplicationDispatcher.java
index 93a0fe49ae..260eaa91fd 100644
--- a/java/org/apache/catalina/core/ApplicationContextFacade.java
+++ b/java/org/apache/catalina/core/ApplicationContextFacade.java
@@ -40,8 +40,7 @@ import jakarta.servlet.descriptor.JspConfigDescriptor;
 
 
 /**
- * Facade object which masks the internal <code>ApplicationContext</code>
- * object from the web application.
+ * Facade object which masks the internal <code>ApplicationContext</code> object from the web application.
  *
  * @author Remy Maucherat
  */
@@ -51,14 +50,13 @@ public class ApplicationContextFacade implements ServletContext {
     /**
      * Cache Class object used for reflection.
      */
-    private final Map<String,Class<?>[]> classCache;
+    private final Map<String, Class<?>[]> classCache;
 
 
     // ----------------------------------------------------------- Constructors
 
     /**
-     * Construct a new instance of this class, associated with the specified
-     * Context instance.
+     * Construct a new instance of this class, associated with the specified Context instance.
      *
      * @param context The associated Context instance
      */
@@ -71,8 +69,8 @@ public class ApplicationContextFacade implements ServletContext {
     }
 
 
-    private void initClassCache(){
-        Class<?>[] clazz = new Class[]{String.class};
+    private void initClassCache() {
+        Class<?>[] clazz = new Class[] { String.class };
         classCache.put("getContext", clazz);
         classCache.put("getMimeType", clazz);
         classCache.put("getResourcePaths", clazz);
@@ -81,27 +79,27 @@ public class ApplicationContextFacade implements ServletContext {
         classCache.put("getRequestDispatcher", clazz);
         classCache.put("getNamedDispatcher", clazz);
         classCache.put("getServlet", clazz);
-        classCache.put("setInitParameter", new Class[]{String.class, String.class});
-        classCache.put("createServlet", new Class[]{Class.class});
-        classCache.put("addServlet", new Class[]{String.class, String.class});
-        classCache.put("createFilter", new Class[]{Class.class});
-        classCache.put("addFilter", new Class[]{String.class, String.class});
-        classCache.put("createListener", new Class[]{Class.class});
+        classCache.put("setInitParameter", new Class[] { String.class, String.class });
+        classCache.put("createServlet", new Class[] { Class.class });
+        classCache.put("addServlet", new Class[] { String.class, String.class });
+        classCache.put("createFilter", new Class[] { Class.class });
+        classCache.put("addFilter", new Class[] { String.class, String.class });
+        classCache.put("createListener", new Class[] { Class.class });
         classCache.put("addListener", clazz);
         classCache.put("getFilterRegistration", clazz);
         classCache.put("getServletRegistration", clazz);
         classCache.put("getInitParameter", clazz);
-        classCache.put("setAttribute", new Class[]{String.class, Object.class});
+        classCache.put("setAttribute", new Class[] { String.class, Object.class });
         classCache.put("removeAttribute", clazz);
         classCache.put("getRealPath", clazz);
         classCache.put("getAttribute", clazz);
         classCache.put("log", clazz);
-        classCache.put("setSessionTrackingModes", new Class[]{Set.class} );
-        classCache.put("addJspFile", new Class[]{String.class, String.class});
-        classCache.put("declareRoles", new Class[]{String[].class});
-        classCache.put("setSessionTimeout", new Class[]{int.class});
-        classCache.put("setRequestCharacterEncoding", new Class[]{String.class});
-        classCache.put("setResponseCharacterEncoding", new Class[]{String.class});
+        classCache.put("setSessionTrackingModes", new Class[] { Set.class });
+        classCache.put("addJspFile", new Class[] { String.class, String.class });
+        classCache.put("declareRoles", new Class[] { String[].class });
+        classCache.put("setSessionTimeout", new Class[] { int.class });
+        classCache.put("setRequestCharacterEncoding", new Class[] { String.class });
+        classCache.put("setResponseCharacterEncoding", new Class[] { String.class });
     }
 
 
@@ -120,9 +118,8 @@ public class ApplicationContextFacade implements ServletContext {
     @Override
     public ServletContext getContext(String uripath) {
         ServletContext theContext = context.getContext(uripath);
-        if ((theContext != null) &&
-            (theContext instanceof ApplicationContext)){
-            theContext = ((ApplicationContext)theContext).getFacade();
+        if ((theContext != null) && (theContext instanceof ApplicationContext)) {
+            theContext = ((ApplicationContext) theContext).getFacade();
         }
         return theContext;
     }
@@ -214,7 +211,7 @@ public class ApplicationContextFacade implements ServletContext {
     @Override
     public Object getAttribute(String name) {
         return context.getAttribute(name);
-     }
+    }
 
 
     @Override
@@ -260,8 +257,7 @@ public class ApplicationContextFacade implements ServletContext {
 
 
     @Override
-    public FilterRegistration.Dynamic addFilter(String filterName,
-            Class<? extends Filter> filterClass) {
+    public FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass) {
         return context.addFilter(filterName, filterClass);
     }
 

==================================================
ApplicationFilterChain.java
index 2e0d80ac32..15946f97c2 100644
--- a/java/org/apache/catalina/core/ApplicationDispatcher.java
+++ b/java/org/apache/catalina/core/ApplicationDispatcher.java
@@ -47,27 +47,22 @@ import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * Standard implementation of <code>RequestDispatcher</code> that allows a
- * request to be forwarded to a different resource to create the ultimate
- * response, or to include the output of another resource in the response
- * from this resource.  This implementation allows application level servlets
- * to wrap the request and/or response objects that are passed on to the
- * called resource, as long as the wrapping classes extend
- * <code>jakarta.servlet.ServletRequestWrapper</code> and
- * <code>jakarta.servlet.ServletResponseWrapper</code>.
+ * Standard implementation of <code>RequestDispatcher</code> that allows a request to be forwarded to a different
+ * resource to create the ultimate response, or to include the output of another resource in the response from this
+ * resource. This implementation allows application level servlets to wrap the request and/or response objects that are
+ * passed on to the called resource, as long as the wrapping classes extend
+ * <code>jakarta.servlet.ServletRequestWrapper</code> and <code>jakarta.servlet.ServletResponseWrapper</code>.
  *
  * @author Craig R. McClanahan
  */
 final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher {
 
     /**
-     * Used to pass state when the request dispatcher is used. Using instance
-     * variables causes threading issues and state is too complex to pass and
-     * return single ServletRequest or ServletResponse objects.
+     * Used to pass state when the request dispatcher is used. Using instance variables causes threading issues and
+     * state is too complex to pass and return single ServletRequest or ServletResponse objects.
      */
     private static class State {
-        State(ServletRequest request, ServletResponse response,
-                boolean including) {
+        State(ServletRequest request, ServletResponse response, boolean including) {
             this.outerRequest = request;
             this.outerResponse = response;
             this.including = including;
@@ -115,26 +110,20 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
 
 
     /**
-     * Construct a new instance of this class, configured according to the
-     * specified parameters.  If both servletPath and pathInfo are
-     * <code>null</code>, it will be assumed that this RequestDispatcher
-     * was acquired by name, rather than by path.
+     * Construct a new instance of this class, configured according to the specified parameters. If both servletPath and
+     * pathInfo are <code>null</code>, it will be assumed that this RequestDispatcher was acquired by name, rather than
+     * by path.
      *
-     * @param wrapper The Wrapper associated with the resource that will
-     *  be forwarded to or included (required)
-     * @param requestURI The request URI to this resource (if any)
+     * @param wrapper     The Wrapper associated with the resource that will be forwarded to or included (required)
+     * @param requestURI  The request URI to this resource (if any)
      * @param servletPath The revised servlet path to this resource (if any)
-     * @param pathInfo The revised extra path information to this resource
-     *  (if any)
-     * @param queryString Query string parameters included with this request
-     *  (if any)
-     * @param mapping The mapping for this resource (if any)
-     * @param name Servlet name (if a named dispatcher was created)
-     *  else <code>null</code>
+     * @param pathInfo    The revised extra path information to this resource (if any)
+     * @param queryString Query string parameters included with this request (if any)
+     * @param mapping     The mapping for this resource (if any)
+     * @param name        Servlet name (if a named dispatcher was created) else <code>null</code>
      */
-    public ApplicationDispatcher
-        (Wrapper wrapper, String requestURI, String servletPath,
-         String pathInfo, String queryString, HttpServletMapping mapping, String name) {
+    public ApplicationDispatcher(Wrapper wrapper, String requestURI, String servletPath, String pathInfo,
+            String queryString, HttpServletMapping mapping, String name) {
 
         super();
 
@@ -201,8 +190,7 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
 
 
     /**
-     * The Wrapper associated with the resource that will be forwarded to
-     * or included.
+     * The Wrapper associated with the resource that will be forwarded to or included.
      */
     private final Wrapper wrapper;
 
@@ -211,22 +199,20 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
 
 
     /**
-     * Forward this request and response to another resource for processing.
-     * Any runtime exception, IOException, or ServletException thrown by the
-     * called servlet will be propagated to the caller.
+     * Forward this request and response to another resource for processing. Any runtime exception, IOException, or
+     * ServletException thrown by the called servlet will be propagated to the caller.
      *
-     * @param request The servlet request to be forwarded
+     * @param request  The servlet request to be forwarded
      * @param response The servlet response to be forwarded
      *
-     * @exception IOException if an input/output error occurs
+     * @exception IOException      if an input/output error occurs
      * @exception ServletException if a servlet exception occurs
      */
     @Override
     public void forward(ServletRequest request, ServletResponse response) throws ServletException, IOException {
         // Reset any output that has been buffered, but keep headers/cookies
         if (response.isCommitted()) {
-            throw new IllegalStateException
-                (sm.getString("applicationDispatcher.forward.ise"));
+            throw new IllegalStateException(sm.getString("applicationDispatcher.forward.ise"));
         }
         try {
             response.resetBuffer();
@@ -246,8 +232,7 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
         // Handle an HTTP named dispatcher forward
         if ((servletPath == null) && (pathInfo == null)) {
 
-            ApplicationHttpRequest wrequest =
-                (ApplicationHttpRequest) wrapRequest(state);
+            ApplicationHttpRequest wrequest = (ApplicationHttpRequest) wrapRequest(state);
             HttpServletRequest hrequest = state.hrequest;
             wrequest.setRequestURI(hrequest.getRequestURI());
             wrequest.setContextPath(hrequest.getContextPath());
@@ -255,7 +240,7 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
             wrequest.setPathInfo(hrequest.getPathInfo());
             wrequest.setQueryString(hrequest.getQueryString());
 
-            processRequest(request,response,state);
+            processRequest(request, response, state);
         }
 
         // Handle an HTTP path-based forward
@@ -264,16 +249,11 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
             ApplicationHttpRequest wrequest = (ApplicationHttpRequest) wrapRequest(state);
             HttpServletRequest hrequest = state.hrequest;
             if (hrequest.getAttribute(RequestDispatcher.FORWARD_REQUEST_URI) == null) {
-                wrequest.setAttribute(RequestDispatcher.FORWARD_REQUEST_URI,
-                                      hrequest.getRequestURI());
-                wrequest.setAttribute(RequestDispatcher.FORWARD_CONTEXT_PATH,
-                                      hrequest.getContextPath());
-                wrequest.setAttribute(RequestDispatcher.FORWARD_SERVLET_PATH,
-                                      hrequest.getServletPath());
-                wrequest.setAttribute(RequestDispatcher.FORWARD_PATH_INFO,
-                                      hrequest.getPathInfo());
-                wrequest.setAttribute(RequestDispatcher.FORWARD_QUERY_STRING,
-                                      hrequest.getQueryString());
+                wrequest.setAttribute(RequestDispatcher.FORWARD_REQUEST_URI, hrequest.getRequestURI());
+                wrequest.setAttribute(RequestDispatcher.FORWARD_CONTEXT_PATH, hrequest.getContextPath());
+                wrequest.setAttribute(RequestDispatcher.FORWARD_SERVLET_PATH, hrequest.getServletPath());
+                wrequest.setAttribute(RequestDispatcher.FORWARD_PATH_INFO, hrequest.getPathInfo());
+                wrequest.setAttribute(RequestDispatcher.FORWARD_QUERY_STRING, hrequest.getQueryString());
                 wrequest.setAttribute(RequestDispatcher.FORWARD_MAPPING, hrequest.getHttpServletMapping());
             }
 
@@ -287,7 +267,7 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
             }
             wrequest.setMapping(mapping);
 
-            processRequest(request,response,state);
+            processRequest(request, response, state);
         }
 
         if (request.isAsyncStarted()) {
@@ -297,18 +277,18 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
         }
 
         // This is not a real close in order to support error processing
-        if (wrapper.getLogger().isDebugEnabled() ) {
+        if (wrapper.getLogger().isDebugEnabled()) {
             wrapper.getLogger().debug(" Disabling the response for further output");
         }
 
-        if  (response instanceof ResponseFacade) {
+        if (response instanceof ResponseFacade) {
             ((ResponseFacade) response).finish();
         } else {
             // Servlet SRV.6.2.2. The Request/Response may have been wrapped
             // and may no longer be instance of RequestFacade
-            if (wrapper.getLogger().isDebugEnabled()){
-                wrapper.getLogger().debug( " The Response is vehiculed using a wrapper: "
-                           + response.getClass().getName() );
+            if (wrapper.getLogger().isDebugEnabled()) {
+                wrapper.getLogger()
+                        .debug(" The Response is vehiculed using a wrapper: " + response.getClass().getName());
             }
 
             // Close anyway
@@ -332,35 +312,29 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
 
     /**
      * Prepare the request based on the filter configuration.
-     * @param request The servlet request we are processing
+     *
+     * @param request  The servlet request we are processing
      * @param response The servlet response we are creating
-     * @param state The RD state
+     * @param state    The RD state
      *
-     * @exception IOException if an input/output error occurs
+     * @exception IOException      if an input/output error occurs
      * @exception ServletException if a servlet error occurs
      */
-    private void processRequest(ServletRequest request,
-                                ServletResponse response,
-                                State state)
-        throws IOException, ServletException {
+    private void processRequest(ServletRequest request, ServletResponse response, State state)
+            throws IOException, ServletException {
 
         DispatcherType disInt = (DispatcherType) request.getAttribute(Globals.DISPATCHER_TYPE_ATTR);
         if (disInt != null) {
             boolean doInvoke = true;
 
-            if (context.getFireRequestListenersOnForwards() &&
-                    !context.fireRequestInitEvent(request)) {
+            if (context.getFireRequestListenersOnForwards() && !context.fireRequestInitEvent(request)) {
                 doInvoke = false;
             }
 
             if (doInvoke) {
                 if (disInt != DispatcherType.ERROR) {
-                    state.outerRequest.setAttribute(
-                            Globals.DISPATCHER_REQUEST_PATH_ATTR,
-                            getCombinedPath());
-                    state.outerRequest.setAttribute(
-                            Globals.DISPATCHER_TYPE_ATTR,
-                            DispatcherType.FORWARD);
+                    state.outerRequest.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, getCombinedPath());
+                    state.outerRequest.setAttribute(Globals.DISPATCHER_TYPE_ATTR, DispatcherType.FORWARD);
                     invoke(state.outerRequest, response, state);
                 } else {
                     invoke(state.outerRequest, response, state);
@@ -375,9 +349,9 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
 
 
     /**
-     * Combine the servletPath and the pathInfo. If pathInfo is
-     * <code>null</code> it is ignored. If servletPath is <code>null</code> then
-     * <code>null</code> is returned.
+     * Combine the servletPath and the pathInfo. If pathInfo is <code>null</code> it is ignored. If servletPath is
+     * <code>null</code> then <code>null</code> is returned.
+     *
      * @return The combined path with pathInfo appended to servletInfo
      */
     private String getCombinedPath() {
@@ -392,14 +366,13 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
 
 
     /**
-     * Include the response from another resource in the current response.
-     * Any runtime exception, IOException, or ServletException thrown by the
-     * called servlet will be propagated to the caller.
+     * Include the response from another resource in the current response. Any runtime exception, IOException, or
+     * ServletException thrown by the called servlet will be propagated to the caller.
      *
-     * @param request The servlet request that is including this one
+     * @param request  The servlet request that is including this one
      * @param response The servlet response to be appended to
      *
-     * @exception IOException if an input/output error occurs
+     * @exception IOException      if an input/output error occurs
      * @exception ServletException if a servlet exception occurs
      */
     @Override
@@ -431,8 +404,7 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
         // Handle an HTTP path based include
         else {
 
-            ApplicationHttpRequest wrequest =
-                (ApplicationHttpRequest) wrapRequest(state);
+            ApplicationHttpRequest wrequest = (ApplicationHttpRequest) wrapRequest(state);
             String contextPath = context.getPath();
             if (requestURI != null) {
                 wrequest.setAttribute(RequestDispatcher.INCLUDE_REQUEST_URI, requestURI);
@@ -454,10 +426,8 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
                 wrequest.setAttribute(RequestDispatcher.INCLUDE_MAPPING, mapping);
             }
 
-            wrequest.setAttribute(Globals.DISPATCHER_TYPE_ATTR,
-                    DispatcherType.INCLUDE);
-            wrequest.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,
-                    getCombinedPath());
+            wrequest.setAttribute(Globals.DISPATCHER_TYPE_ATTR, DispatcherType.INCLUDE);
+            wrequest.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, getCombinedPath());
             invoke(state.outerRequest, state.outerResponse, state);
         }
 
@@ -497,22 +467,20 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
 
 
     /**
-     * Ask the resource represented by this RequestDispatcher to process
-     * the associated request, and create (or append to) the associated
-     * response.
+     * Ask the resource represented by this RequestDispatcher to process the associated request, and create (or append
+     * to) the associated response.
      * <p>
-     * <strong>IMPLEMENTATION NOTE</strong>: This implementation assumes
-     * that no filters are applied to a forwarded or included resource,
-     * because they were already done for the original request.
+     * <strong>IMPLEMENTATION NOTE</strong>: This implementation assumes that no filters are applied to a forwarded or
+     * included resource, because they were already done for the original request.
      *
-     * @param request The servlet request we are processing
+     * @param request  The servlet request we are processing
      * @param response The servlet response we are creating
      *
-     * @exception IOException if an input/output error occurs
+     * @exception IOException      if an input/output error occurs
      * @exception ServletException if a servlet error occurs
      */
-    private void invoke(ServletRequest request, ServletResponse response,
-            State state) throws IOException, ServletException {
+    private void invoke(ServletRequest request, ServletResponse response, State state)
+            throws IOException, ServletException {
 
         // Checking to see if the context classloader is the current context
         // classloader. If it's not, we're saving it, and setting the context
@@ -529,9 +497,7 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
 
         // Check for the servlet being marked unavailable
         if (wrapper.isUnavailable()) {
-            wrapper.getLogger().warn(
-                    sm.getString("applicationDispatcher.isUnavailable",
-                    wrapper.getName()));
+            wrapper.getLogger().warn(sm.getString("applicationDispatcher.isUnavailable", wrapper.getName()));
             long available = wrapper.getAvailable();
             if ((available > 0L) && (available < Long.MAX_VALUE)) {
                 hresponse.setDateHeader("Retry-After", available);
@@ -547,51 +513,45 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
                 servlet = wrapper.allocate();
             }
         } catch (ServletException e) {
-            wrapper.getLogger().error(sm.getString("applicationDispatcher.allocateException",
-                             wrapper.getName()), StandardWrapper.getRootCause(e));
+            wrapper.getLogger().error(sm.getString("applicationDispatcher.allocateException", wrapper.getName()),
+                    StandardWrapper.getRootCause(e));
             servletException = e;
         } catch (Throwable e) {
             ExceptionUtils.handleThrowable(e);
-            wrapper.getLogger().error(sm.getString("applicationDispatcher.allocateException",
-                             wrapper.getName()), e);
-            servletException = new ServletException
-                (sm.getString("applicationDispatcher.allocateException",
-                              wrapper.getName()), e);
+            wrapper.getLogger().error(sm.getString("applicationDispatcher.allocateException", wrapper.getName()), e);
+            servletException = new ServletException(
+                    sm.getString("applicationDispatcher.allocateException", wrapper.getName()), e);
             servlet = null;
         }
 
         // Get the FilterChain Here
-        ApplicationFilterChain filterChain =
-                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);
+        ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);
 
         // Call the service() method for the allocated servlet instance
         try {
             // for includes/forwards
             if ((servlet != null) && (filterChain != null)) {
-               filterChain.doFilter(request, response);
-             }
+                filterChain.doFilter(request, response);
+            }
             // Servlet Service Method is called by the FilterChain
         } catch (ClientAbortException e) {
             ioException = e;
         } catch (IOException e) {
-            wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",
-                             wrapper.getName()), e);
+            wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException", wrapper.getName()), e);
             ioException = e;
         } catch (UnavailableException e) {
-            wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",
-                             wrapper.getName()), e);
+            wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException", wrapper.getName()), e);
             servletException = e;
             wrapper.unavailable(e);
         } catch (ServletException e) {
             Throwable rootCause = StandardWrapper.getRootCause(e);
             if (!(rootCause instanceof ClientAbortException)) {
-                wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",
-                        wrapper.getName()), rootCause);
+                wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException", wrapper.getName()),
+                        rootCause);
             }
             servletException = e;
         } catch (RuntimeException e) {
-            wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",
-                             wrapper.getName()), e);
+            wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException", wrapper.getName()), e);
             runtimeException = e;
         }
 
@@ -606,16 +566,13 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
                 wrapper.deallocate(servlet);
             }
         } catch (ServletException e) {
-            wrapper.getLogger().error(sm.getString("applicationDispatcher.deallocateException",
-                             wrapper.getName()), e);
+            wrapper.getLogger().error(sm.getString("applicationDispatcher.deallocateException", wrapper.getName()), e);
             servletException = e;
         } catch (Throwable e) {
             ExceptionUtils.handleThrowable(e);
-            wrapper.getLogger().error(sm.getString("applicationDispatcher.deallocateException",
-                             wrapper.getName()), e);
-            servletException = new ServletException
-                (sm.getString("applicationDispatcher.deallocateException",
-                              wrapper.getName()), e);
+            wrapper.getLogger().error(sm.getString("applicationDispatcher.deallocateException", wrapper.getName()), e);
+            servletException = new ServletException(
+                    sm.getString("applicationDispatcher.deallocateException", wrapper.getName()), e);
         }
 
         // Reset the old context class loader
@@ -667,8 +624,7 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
 
             // Remove the current request if it is our wrapper
             if (current == state.wrapRequest) {
-                ServletRequest next =
-                  ((ServletRequestWrapper) current).getRequest();
+                ServletRequest next = ((ServletRequestWrapper) current).getRequest();
                 if (previous == null) {
                     state.outerRequest = next;
                 } else {
@@ -711,8 +667,7 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
 
             // Remove the current response if it is our wrapper
             if (current == state.wrapResponse) {
-                ServletResponse next =
-                  ((ServletResponseWrapper) current).getResponse();
+                ServletResponse next = ((ServletResponseWrapper) current).getResponse();
                 if (previous == null) {
                     state.outerResponse = next;
                 } else {
@@ -731,8 +686,7 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
 
 
     /**
-     * Create and return a request wrapper that has been inserted in the
-     * appropriate spot in the request chain.
+     * Create and return a request wrapper that has been inserted in the appropriate spot in the request chain.
      */
     private ServletRequest wrapRequest(State state) {
 
@@ -740,8 +694,8 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
         ServletRequest previous = null;
         ServletRequest current = state.outerRequest;
         while (current != null) {
-            if(state.hrequest == null && (current instanceof HttpServletRequest)) {
-                state.hrequest = (HttpServletRequest)current;
+            if (state.hrequest == null && (current instanceof HttpServletRequest)) {
+                state.hrequest = (HttpServletRequest) current;
             }
             if (!(current instanceof ServletRequestWrapper)) {
                 break;
@@ -758,27 +712,22 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
 
         // Instantiate a new wrapper at this point and insert it in the chain
         ServletRequest wrapper = null;
-        if ((current instanceof ApplicationHttpRequest) ||
-            (current instanceof Request) ||
-            (current instanceof HttpServletRequest)) {
+        if ((current instanceof ApplicationHttpRequest) || (current instanceof Request) ||
+                (current instanceof HttpServletRequest)) {
             // Compute a crossContext flag
             HttpServletRequest hcurrent = (HttpServletRequest) current;
             boolean crossContext = false;
-            if ((state.outerRequest instanceof ApplicationHttpRequest) ||
-                (state.outerRequest instanceof Request) ||
-                (state.outerRequest instanceof HttpServletRequest)) {
-                HttpServletRequest houterRequest =
-                    (HttpServletRequest) state.outerRequest;
-                Object contextPath = houterRequest.getAttribute(
-                        RequestDispatcher.INCLUDE_CONTEXT_PATH);
+            if ((state.outerRequest instanceof ApplicationHttpRequest) || (state.outerRequest instanceof Request) ||
+                    (state.outerRequest instanceof HttpServletRequest)) {
+                HttpServletRequest houterRequest = (HttpServletRequest) state.outerRequest;
+                Object contextPath = houterRequest.getAttribute(RequestDispatcher.INCLUDE_CONTEXT_PATH);
                 if (contextPath == null) {
                     // Forward
                     contextPath = houterRequest.getContextPath();
                 }
                 crossContext = !(context.getPath().equals(contextPath));
             }
-            wrapper = new ApplicationHttpRequest
-                (hcurrent, context, crossContext);
+            wrapper = new ApplicationHttpRequest(hcurrent, context, crossContext);
         } else {
             wrapper = new ApplicationRequest(current);
         }
@@ -794,8 +743,7 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
 
 
     /**
-     * Create and return a response wrapper that has been inserted in the
-     * appropriate spot in the response chain.
+     * Create and return a response wrapper that has been inserted in the appropriate spot in the response chain.
      */
     private ServletResponse wrapResponse(State state) {
 
@@ -804,7 +752,7 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
         ServletResponse current = state.outerResponse;
         while (current != null) {
             if (state.hresponse == null && (current instanceof HttpServletResponse)) {
-                state.hresponse = (HttpServletResponse)current;
+                state.hresponse = (HttpServletResponse) current;
                 if (!state.including) { // Forward only needs hresponse
                     return null;
                 }
@@ -840,12 +788,9 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
 
     }
 
-    private void checkSameObjects(ServletRequest appRequest,
-            ServletResponse appResponse) throws ServletException {
-        ServletRequest originalRequest =
-            ApplicationFilterChain.getLastServicedRequest();
-        ServletResponse originalResponse =
-            ApplicationFilterChain.getLastServicedResponse();
+    private void checkSameObjects(ServletRequest appRequest, ServletResponse appResponse) throws ServletException {
+        ServletRequest originalRequest = ApplicationFilterChain.getLastServicedRequest();
+        ServletResponse originalResponse = ApplicationFilterChain.getLastServicedResponse();
 
         // Some forwards, eg from valves will not set original values
         if (originalRequest == null || originalResponse == null) {
@@ -855,56 +800,49 @@ final class ApplicationDispatcher implements AsyncDispatcher, RequestDispatcher
         boolean same = false;
         ServletRequest dispatchedRequest = appRequest;
 
-        //find the request that was passed into the service method
+        // find the request that was passed into the service method
         while (originalRequest instanceof ServletRequestWrapper &&
-                ((ServletRequestWrapper) originalRequest).getRequest()!=null ) {
-            originalRequest =
-                ((ServletRequestWrapper) originalRequest).getRequest();
+                ((ServletRequestWrapper) originalRequest).getRequest() != null) {
+            originalRequest = ((ServletRequestWrapper) originalRequest).getRequest();
         }
-        //compare with the dispatched request
+        // compare with the dispatched request
         while (!same) {
             if (originalRequest.equals(dispatchedRequest)) {
                 same = true;
             }
             if (!same && dispatchedRequest instanceof ServletRequestWrapper) {
-                dispatchedRequest =
-                    ((ServletRequestWrapper) dispatchedRequest).getRequest();
+                dispatchedRequest = ((ServletRequestWrapper) dispatchedRequest).getRequest();
             } else {
                 break;
             }
         }
         if (!same) {
-            throw new ServletException(sm.getString(
-                    "applicationDispatcher.specViolation.request"));
+            throw new ServletException(sm.getString("applicationDispatcher.specViolation.request"));
         }
 
         same = false;
         ServletResponse dispatchedResponse = appResponse;
 
-        //find the response that was passed into the service method
+        // find the response that was passed into the service method
         while (originalResponse instanceof ServletResponseWrapper &&
-                ((ServletResponseWrapper) originalResponse).getResponse() !=
-                    null ) {
-            originalResponse =
-                ((ServletResponseWrapper) originalResponse).getResponse();
+                ((ServletResponseWrapper) originalResponse).getResponse() != null) {
+            originalResponse = ((ServletResponseWrapper) originalResponse).getResponse();
         }
-        //compare with the dispatched response
+        // compare with the dispatched response
         while (!same) {
             if (originalResponse.equals(dispatchedResponse)) {
                 same = true;
             }
 
             if (!same && dispatchedResponse instanceof ServletResponseWrapper) {
-                dispatchedResponse =
-                    ((ServletResponseWrapper) dispatchedResponse).getResponse();
+                dispatchedResponse = ((ServletResponseWrapper) dispatchedResponse).getResponse();
             } else {
                 break;
             }
         }
 
         if (!same) {
-            throw new ServletException(sm.getString(
-                    "applicationDispatcher.specViolation.response"));
+            throw new ServletException(sm.getString("applicationDispatcher.specViolation.response"));
         }
     }
 

==================================================
ApplicationFilterConfig.java
index 6bc507f1ce..de4144ad68 100644
--- a/java/org/apache/catalina/core/ApplicationFilterChain.java
+++ b/java/org/apache/catalina/core/ApplicationFilterChain.java
@@ -31,11 +31,9 @@ import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * Implementation of <code>jakarta.servlet.FilterChain</code> used to manage
- * the execution of a set of filters for a particular request.  When the
- * set of defined filters has all been executed, the next call to
- * <code>doFilter()</code> will execute the servlet's <code>service()</code>
- * method itself.
+ * Implementation of <code>jakarta.servlet.FilterChain</code> used to manage the execution of a set of filters for a
+ * particular request. When the set of defined filters has all been executed, the next call to <code>doFilter()</code>
+ * will execute the servlet's <code>service()</code> method itself.
  *
  * @author Craig R. McClanahan
  */
@@ -61,8 +59,7 @@ public final class ApplicationFilterChain implements FilterChain {
 
 
     /**
-     * The int which is used to maintain the current position
-     * in the filter chain.
+     * The int which is used to maintain the current position in the filter chain.
      */
     private int pos = 0;
 
@@ -98,14 +95,13 @@ public final class ApplicationFilterChain implements FilterChain {
     // ---------------------------------------------------- FilterChain Methods
 
     /**
-     * Invoke the next filter in this chain, passing the specified request
-     * and response.  If there are no more filters in this chain, invoke
-     * the <code>service()</code> method of the servlet itself.
+     * Invoke the next filter in this chain, passing the specified request and response. If there are no more filters in
+     * this chain, invoke the <code>service()</code> method of the servlet itself.
      *
-     * @param request The servlet request we are processing
+     * @param request  The servlet request we are processing
      * @param response The servlet response we are creating
      *
-     * @exception IOException if an input/output error occurs
+     * @exception IOException      if an input/output error occurs
      * @exception ServletException if a servlet exception occurs
      */
     @Override
@@ -116,8 +112,8 @@ public final class ApplicationFilterChain implements FilterChain {
             try {
                 Filter filter = filterConfig.getFilter();
 
-                if (request.isAsyncSupported() && "false".equalsIgnoreCase(
-                        filterConfig.getFilterDef().getAsyncSupported())) {
+                if (request.isAsyncSupported() &&
+                        "false".equalsIgnoreCase(filterConfig.getFilterDef().getAsyncSupported())) {
                     request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);
                 }
                 filter.doFilter(request, response, this);
@@ -138,8 +134,7 @@ public final class ApplicationFilterChain implements FilterChain {
             }
 
             if (request.isAsyncSupported() && !servletSupportsAsync) {
-                request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,
-                        Boolean.FALSE);
+                request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);
             }
             // Use potentially wrapped request from this point
             servlet.service(request, response);
@@ -158,8 +153,7 @@ public final class ApplicationFilterChain implements FilterChain {
 
 
     /**
-     * The last request passed to a servlet for servicing from the current
-     * thread.
+     * The last request passed to a servlet for servicing from the current thread.
      *
      * @return The last request to be serviced.
      */
@@ -169,8 +163,7 @@ public final class ApplicationFilterChain implements FilterChain {
 
 
     /**
-     * The last response passed to a servlet for servicing from the current
-     * thread.
+     * The last response passed to a servlet for servicing from the current thread.
      *
      * @return The last response to be serviced.
      */
@@ -189,15 +182,14 @@ public final class ApplicationFilterChain implements FilterChain {
     void addFilter(ApplicationFilterConfig filterConfig) {
 
         // Prevent the same filter being added multiple times
-        for(ApplicationFilterConfig filter:filters) {
-            if(filter==filterConfig) {
+        for (ApplicationFilterConfig filter : filters) {
+            if (filter == filterConfig) {
                 return;
             }
         }
 
         if (n == filters.length) {
-            ApplicationFilterConfig[] newFilters =
-                new ApplicationFilterConfig[n + INCREMENT];
+            ApplicationFilterConfig[] newFilters = new ApplicationFilterConfig[n + INCREMENT];
             System.arraycopy(filters, 0, newFilters, 0, n);
             filters = newFilters;
         }
@@ -250,15 +242,13 @@ public final class ApplicationFilterChain implements FilterChain {
 
 
     /**
-     * Identifies the Filters, if any, in this FilterChain that do not support
-     * async.
+     * Identifies the Filters, if any, in this FilterChain that do not support async.
      *
-     * @param result The Set to which the fully qualified class names of each
-     *               Filter in this FilterChain that does not support async will
-     *               be added
+     * @param result The Set to which the fully qualified class names of each Filter in this FilterChain that does not
+     *                   support async will be added
      */
     public void findNonAsyncFilters(Set<String> result) {
-        for (int i = 0; i < n ; i++) {
+        for (int i = 0; i < n; i++) {
             ApplicationFilterConfig filter = filters[i];
             if ("false".equalsIgnoreCase(filter.getFilterDef().getAsyncSupported())) {
                 result.add(filter.getFilterClass());

==================================================
ApplicationFilterFactory.java
index 0fcac1fd9e..acf10b0d2a 100644
--- a/java/org/apache/catalina/core/ApplicationFilterConfig.java
+++ b/java/org/apache/catalina/core/ApplicationFilterConfig.java
@@ -45,9 +45,8 @@ import org.apache.tomcat.util.res.StringManager;
 
 
 /**
- * Implementation of a <code>jakarta.servlet.FilterConfig</code> useful in
- * managing the filter instances instantiated when a web application
- * is first started.
+ * Implementation of a <code>jakarta.servlet.FilterConfig</code> useful in managing the filter instances instantiated
+ * when a web application is first started.
  *
  * @author Craig R. McClanahan
  */
@@ -68,28 +67,24 @@ public final class ApplicationFilterConfig implements FilterConfig, Serializable
 
 
     /**
-     * Construct a new ApplicationFilterConfig for the specified filter
-     * definition.
+     * Construct a new ApplicationFilterConfig for the specified filter definition.
      *
-     * @param context The context with which we are associated
-     * @param filterDef Filter definition for which a FilterConfig is to be
-     *  constructed
+     * @param context   The context with which we are associated
+     * @param filterDef Filter definition for which a FilterConfig is to be constructed
      *
-     * @exception ClassCastException if the specified class does not implement
-     *  the <code>jakarta.servlet.Filter</code> interface
+     * @exception ClassCastException     if the specified class does not implement the
+     *                                       <code>jakarta.servlet.Filter</code> interface
      * @exception ClassNotFoundException if the filter class cannot be found
-     * @exception IllegalAccessException if the filter class cannot be
-     *  publicly instantiated
-     * @exception InstantiationException if an exception occurs while
-     *  instantiating the filter object
-     * @exception ServletException if thrown by the filter's init() method
-     * @throws NamingException If a JNDI lookup fails
-     * @throws IllegalArgumentException If the provided configuration is not
-     *         valid
+     * @exception IllegalAccessException if the filter class cannot be publicly instantiated
+     * @exception InstantiationException if an exception occurs while instantiating the filter object
+     * @exception ServletException       if thrown by the filter's init() method
+     *
+     * @throws NamingException          If a JNDI lookup fails
+     * @throws IllegalArgumentException If the provided configuration is not valid
      */
     ApplicationFilterConfig(Context context, FilterDef filterDef)
-            throws ClassCastException, ReflectiveOperationException, ServletException,
-            NamingException, IllegalArgumentException, SecurityException {
+            throws ClassCastException, ReflectiveOperationException, ServletException, NamingException,
+            IllegalArgumentException, SecurityException {
 
         super();
 
@@ -150,16 +145,15 @@ public final class ApplicationFilterConfig implements FilterConfig, Serializable
     }
 
     /**
-     * Return a <code>String</code> containing the value of the named
-     * initialization parameter, or <code>null</code> if the parameter
-     * does not exist.
+     * Return a <code>String</code> containing the value of the named initialization parameter, or <code>null</code> if
+     * the parameter does not exist.
      *
      * @param name Name of the requested initialization parameter
      */
     @Override
     public String getInitParameter(String name) {
 
-        Map<String,String> map = filterDef.getParameterMap();
+        Map<String, String> map = filterDef.getParameterMap();
         if (map == null) {
             return null;
         }
@@ -170,12 +164,11 @@ public final class ApplicationFilterConfig implements FilterConfig, Serializable
 
 
     /**
-     * Return an <code>Enumeration</code> of the names of the initialization
-     * parameters for this Filter.
+     * Return an <code>Enumeration</code> of the names of the initialization parameters for this Filter.
      */
     @Override
     public Enumeration<String> getInitParameterNames() {
-        Map<String,String> map = filterDef.getParameterMap();
+        Map<String, String> map = filterDef.getParameterMap();
 
         if (map == null) {
             return Collections.enumeration(emptyString);
@@ -222,21 +215,19 @@ public final class ApplicationFilterConfig implements FilterConfig, Serializable
     /**
      * Return the application Filter we are configured for.
      *
-     * @exception ClassCastException if the specified class does not implement
-     *  the <code>jakarta.servlet.Filter</code> interface
+     * @exception ClassCastException     if the specified class does not implement the
+     *                                       <code>jakarta.servlet.Filter</code> interface
      * @exception ClassNotFoundException if the filter class cannot be found
-     * @exception IllegalAccessException if the filter class cannot be
-     *  publicly instantiated
-     * @exception InstantiationException if an exception occurs while
-     *  instantiating the filter object
-     * @exception ServletException if thrown by the filter's init() method
-     * @throws NamingException If a JNDI lookup fails
+     * @exception IllegalAccessException if the filter class cannot be publicly instantiated
+     * @exception InstantiationException if an exception occurs while instantiating the filter object
+     * @exception ServletException       if thrown by the filter's init() method
+     *
+     * @throws NamingException              If a JNDI lookup fails
      * @throws ReflectiveOperationException If the creation of the filter fails
-     * @throws IllegalArgumentException If the provided configuration is not
-     *         valid
+     * @throws IllegalArgumentException     If the provided configuration is not valid
      */
-    Filter getFilter() throws ClassCastException, ReflectiveOperationException, ServletException,
-            NamingException, IllegalArgumentException, SecurityException {
+    Filter getFilter() throws ClassCastException, ReflectiveOperationException, ServletException, NamingException,
+            IllegalArgumentException, SecurityException {
 
         // Return the existing filter instance, if any
         if (this.filter != null) {
@@ -254,8 +245,7 @@ public final class ApplicationFilterConfig implements FilterConfig, Serializable
     }
 
     private void initFilter() throws ServletException {
-        if (context instanceof StandardContext &&
-                context.getSwallowOutput()) {
+        if (context instanceof StandardContext && context.getSwallowOutput()) {
             try {
                 SystemLogHandler.startCapture();
                 filter.init(this);
@@ -281,8 +271,7 @@ public final class ApplicationFilterConfig implements FilterConfig, Serializable
     }
 
     /**
-     * Release the Filter instance associated with this FilterConfig,
-     * if there is one.
+     * Release the Filter instance associated with this FilterConfig, if there is one.
      */
     void release() {
 
@@ -293,27 +282,23 @@ public final class ApplicationFilterConfig implements FilterConfig, Serializable
                 filter.destroy();
             } catch (Throwable t) {
                 ExceptionUtils.handleThrowable(t);
-                context.getLogger().error(sm.getString(
-                        "applicationFilterConfig.release",
-                        filterDef.getFilterName(),
+                context.getLogger().error(sm.getString("applicationFilterConfig.release", filterDef.getFilterName(),
                         filterDef.getFilterClass()), t);
             }
             if (!context.getIgnoreAnnotations()) {
                 try {
                     context.getInstanceManager().destroyInstance(this.filter);
                 } catch (Exception e) {
-                    Throwable t = ExceptionUtils
-                            .unwrapInvocationTargetException(e);
+                    Throwable t = ExceptionUtils.unwrapInvocationTargetException(e);
                     ExceptionUtils.handleThrowable(t);
-                    context.getLogger().error(
-                            sm.getString("applicationFilterConfig.preDestroy",
-                                    filterDef.getFilterName(), filterDef.getFilterClass()), t);
+                    context.getLogger().error(sm.getString("applicationFilterConfig.preDestroy",
+                            filterDef.getFilterName(), filterDef.getFilterClass()), t);
                 }
             }
         }
         this.filter = null;
 
-     }
+    }
 
 
     // -------------------------------------------------------- Private Methods
@@ -338,20 +323,16 @@ public final class ApplicationFilterConfig implements FilterConfig, Serializable
         }
         if (context instanceof StandardContext) {
             StandardContext standardContext = (StandardContext) context;
-            onameStr = domain + ":j2eeType=Filter,WebModule=" + webMod +
-                    ",name=" + filterName + ",J2EEApplication=" +
-                    standardContext.getJ2EEApplication() + ",J2EEServer=" +
-                    standardContext.getJ2EEServer();
+            onameStr = domain + ":j2eeType=Filter,WebModule=" + webMod + ",name=" + filterName + ",J2EEApplication=" +
+                    standardContext.getJ2EEApplication() + ",J2EEServer=" + standardContext.getJ2EEServer();
         } else {
-            onameStr = domain + ":j2eeType=Filter,name=" + filterName +
-                 ",WebModule=" + webMod;
+            onameStr = domain + ":j2eeType=Filter,name=" + filterName + ",WebModule=" + webMod;
         }
         try {
             oname = new ObjectName(onameStr);
             Registry.getRegistry(null, null).registerComponent(this, oname, null);
         } catch (Exception ex) {
-            log.warn(sm.getString("applicationFilterConfig.jmxRegisterFail",
-                    getFilterClass(), getFilterName()), ex);
+            log.warn(sm.getString("applicationFilterConfig.jmxRegisterFail", getFilterClass(), getFilterName()), ex);
         }
     }
 
@@ -362,12 +343,11 @@ public final class ApplicationFilterConfig implements FilterConfig, Serializable
             try {
                 Registry.getRegistry(null, null).unregisterComponent(oname);
                 if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("applicationFilterConfig.jmxUnregister",
-                            getFilterClass(), getFilterName()));
+                    log.debug(sm.getString("applicationFilterConfig.jmxUnregister", getFilterClass(), getFilterName()));
                 }
-            } catch(Exception ex) {
-                log.warn(sm.getString("applicationFilterConfig.jmxUnregisterFail",
-                        getFilterClass(), getFilterName()), ex);
+            } catch (Exception ex) {
+                log.warn(sm.getString("applicationFilterConfig.jmxUnregisterFail", getFilterClass(), getFilterName()),
+                        ex);
             }
         }
     }

==================================================
ApplicationFilterRegistration.java
index 18dc37561b..8774fa70af 100644
--- a/java/org/apache/catalina/core/ApplicationFilterFactory.java
+++ b/java/org/apache/catalina/core/ApplicationFilterFactory.java
@@ -26,8 +26,7 @@ import org.apache.catalina.connector.Request;
 import org.apache.tomcat.util.descriptor.web.FilterMap;
 
 /**
- * Factory for the creation and caching of Filters and creation
- * of Filter Chains.
+ * Factory for the creation and caching of Filters and creation of Filter Chains.
  *
  * @author Greg Murray
  * @author Remy Maucherat
@@ -40,18 +39,15 @@ public final class ApplicationFilterFactory {
 
 
     /**
-     * Construct a FilterChain implementation that will wrap the execution of
-     * the specified servlet instance.
+     * Construct a FilterChain implementation that will wrap the execution of the specified servlet instance.
      *
      * @param request The servlet request we are processing
      * @param wrapper The wrapper managing the servlet instance
      * @param servlet The servlet instance to be wrapped
      *
-     * @return The configured FilterChain instance or null if none is to be
-     *         executed.
+     * @return The configured FilterChain instance or null if none is to be executed.
      */
-    public static ApplicationFilterChain createFilterChain(ServletRequest request,
-            Wrapper wrapper, Servlet servlet) {
+    public static ApplicationFilterChain createFilterChain(ServletRequest request, Wrapper wrapper, Servlet servlet) {
 
         // If there is no servlet to execute, return null
         if (servlet == null) {
@@ -86,12 +82,11 @@ public final class ApplicationFilterFactory {
         }
 
         // Acquire the information we will need to match filter mappings
-        DispatcherType dispatcher =
-                (DispatcherType) request.getAttribute(Globals.DISPATCHER_TYPE_ATTR);
+        DispatcherType dispatcher = (DispatcherType) request.getAttribute(Globals.DISPATCHER_TYPE_ATTR);
 
         String requestPath = null;
         Object attribute = request.getAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR);
-        if (attribute != null){
+        if (attribute != null) {
             requestPath = attribute.toString();
         }
 
@@ -105,8 +100,8 @@ public final class ApplicationFilterFactory {
             if (!matchFiltersURL(filterMap, requestPath)) {
                 continue;
             }
-            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)
-                    context.findFilterConfig(filterMap.getFilterName());
+            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) context
+                    .findFilterConfig(filterMap.getFilterName());
             if (filterConfig == null) {
                 // FIXME - log configuration problem
                 continue;
@@ -122,8 +117,8 @@ public final class ApplicationFilterFactory {
             if (!matchFiltersServlet(filterMap, servletName)) {
                 continue;
             }
-            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)
-                    context.findFilterConfig(filterMap.getFilterName());
+            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) context
+                    .findFilterConfig(filterMap.getFilterName());
             if (filterConfig == null) {
                 // FIXME - log configuration problem
                 continue;
@@ -140,11 +135,10 @@ public final class ApplicationFilterFactory {
 
 
     /**
-     * Return <code>true</code> if the context-relative request path
-     * matches the requirements of the specified filter mapping;
-     * otherwise, return <code>false</code>.
+     * Return <code>true</code> if the context-relative request path matches the requirements of the specified filter
+     * mapping; otherwise, return <code>false</code>.
      *
-     * @param filterMap Filter mapping being checked
+     * @param filterMap   Filter mapping being checked
      * @param requestPath Context-relative request path of this request
      */
     private static boolean matchFiltersURL(FilterMap filterMap, String requestPath) {
@@ -175,11 +169,10 @@ public final class ApplicationFilterFactory {
 
 
     /**
-     * Return <code>true</code> if the context-relative request path
-     * matches the requirements of the specified filter mapping;
-     * otherwise, return <code>false</code>.
+     * Return <code>true</code> if the context-relative request path matches the requirements of the specified filter
+     * mapping; otherwise, return <code>false</code>.
      *
-     * @param testPath URL mapping being checked
+     * @param testPath    URL mapping being checked
      * @param requestPath Context-relative request path of this request
      */
     private static boolean matchFiltersURL(String testPath, String requestPath) {
@@ -198,8 +191,7 @@ public final class ApplicationFilterFactory {
             return true;
         }
         if (testPath.endsWith("/*")) {
-            if (testPath.regionMatches(0, requestPath, 0,
-                                       testPath.length() - 2)) {
+            if (testPath.regionMatches(0, requestPath, 0, testPath.length() - 2)) {
                 if (requestPath.length() == (testPath.length() - 2)) {
                     return true;
                 } else if ('/' == requestPath.charAt(testPath.length() - 2)) {
@@ -213,12 +205,9 @@ public final class ApplicationFilterFactory {
         if (testPath.startsWith("*.")) {
             int slash = requestPath.lastIndexOf('/');
             int period = requestPath.lastIndexOf('.');
-            if ((slash >= 0) && (period > slash)
-                && (period != requestPath.length() - 1)
-                && ((requestPath.length() - period)
-                    == (testPath.length() - 1))) {
-                return testPath.regionMatches(2, requestPath, period + 1,
-                                               testPath.length() - 2);
+            if ((slash >= 0) && (period > slash) && (period != requestPath.length() - 1) &&
+                    ((requestPath.length() - period) == (testPath.length() - 1))) {
+                return testPath.regionMatches(2, requestPath, period + 1, testPath.length() - 2);
             }
         }
 
@@ -229,15 +218,13 @@ public final class ApplicationFilterFactory {
 
 
     /**
-     * Return <code>true</code> if the specified servlet name matches
-     * the requirements of the specified filter mapping; otherwise
-     * return <code>false</code>.
+     * Return <code>true</code> if the specified servlet name matches the requirements of the specified filter mapping;
+     * otherwise return <code>false</code>.
      *
-     * @param filterMap Filter mapping being checked
+     * @param filterMap   Filter mapping being checked
      * @param servletName Servlet name being checked
      */
-    private static boolean matchFiltersServlet(FilterMap filterMap,
-                                        String servletName) {
+    private static boolean matchFiltersServlet(FilterMap filterMap, String servletName) {
 
         if (servletName == null) {
             return false;
@@ -259,32 +246,32 @@ public final class ApplicationFilterFactory {
 
 
     /**
-     * Convenience method which returns true if  the dispatcher type
-     * matches the dispatcher types specified in the FilterMap
+     * Convenience method which returns true if the dispatcher type matches the dispatcher types specified in the
+     * FilterMap
      */
     private static boolean matchDispatcher(FilterMap filterMap, DispatcherType type) {
         switch (type) {
-            case FORWARD :
+            case FORWARD:
                 if ((filterMap.getDispatcherMapping() & FilterMap.FORWARD) != 0) {
                     return true;
                 }
                 break;
-            case INCLUDE :
+            case INCLUDE:
                 if ((filterMap.getDispatcherMapping() & FilterMap.INCLUDE) != 0) {
                     return true;
                 }
                 break;
-            case REQUEST :
+            case REQUEST:
                 if ((filterMap.getDispatcherMapping() & FilterMap.REQUEST) != 0) {
                     return true;
                 }
                 break;
-            case ERROR :
+            case ERROR:
                 if ((filterMap.getDispatcherMapping() & FilterMap.ERROR) != 0) {
                     return true;
                 }
                 break;
-            case ASYNC :
+            case ASYNC:
                 if ((filterMap.getDispatcherMapping() & FilterMap.ASYNC) != 0) {
                     return true;
                 }

==================================================
ApplicationHttpRequest.java
index 844e178f0c..98839f0f2f 100644
--- a/java/org/apache/catalina/core/ApplicationFilterRegistration.java
+++ b/java/org/apache/catalina/core/ApplicationFilterRegistration.java
@@ -42,16 +42,14 @@ public class ApplicationFilterRegistration implements FilterRegistration.Dynamic
     private final FilterDef filterDef;
     private final Context context;
 
-    public ApplicationFilterRegistration(FilterDef filterDef,
-            Context context) {
+    public ApplicationFilterRegistration(FilterDef filterDef, Context context) {
         this.filterDef = filterDef;
         this.context = context;
 
     }
 
     @Override
-    public void addMappingForServletNames(
-            EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter,
+    public void addMappingForServletNames(EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter,
             String... servletNames) {
 
         FilterMap filterMap = new FilterMap();
@@ -79,8 +77,7 @@ public class ApplicationFilterRegistration implements FilterRegistration.Dynamic
     }
 
     @Override
-    public void addMappingForUrlPatterns(
-            EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter,
+    public void addMappingForUrlPatterns(EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter,
             String... urlPatterns) {
 
         FilterMap filterMap = new FilterMap();
@@ -140,7 +137,7 @@ public class ApplicationFilterRegistration implements FilterRegistration.Dynamic
     @Override
     public String getClassName() {
         return filterDef.getFilterClass();
-   }
+    }
 
     @Override
     public String getInitParameter(String name) {
@@ -149,7 +146,7 @@ public class ApplicationFilterRegistration implements FilterRegistration.Dynamic
 
     @Override
     public Map<String, String> getInitParameters() {
-        ParameterMap<String,String> result = new ParameterMap<>();
+        ParameterMap<String, String> result = new ParameterMap<>();
         result.putAll(filterDef.getParameterMap());
         result.setLocked(true);
         return result;
@@ -164,8 +161,7 @@ public class ApplicationFilterRegistration implements FilterRegistration.Dynamic
     public boolean setInitParameter(String name, String value) {
         if (name == null || value == null) {
             throw new IllegalArgumentException(
-                    sm.getString("applicationFilterRegistration.nullInitParam",
-                            name, value));
+                    sm.getString("applicationFilterRegistration.nullInitParam", name, value));
         }
         if (getInitParameter(name) != null) {
             return false;
@@ -183,9 +179,8 @@ public class ApplicationFilterRegistration implements FilterRegistration.Dynamic
 
         for (Map.Entry<String, String> entry : initParameters.entrySet()) {
             if (entry.getKey() == null || entry.getValue() == null) {
-                throw new IllegalArgumentException(sm.getString(
-                        "applicationFilterRegistration.nullInitParams",
-                                entry.getKey(), entry.getValue()));
+                throw new IllegalArgumentException(
+                        sm.getString("applicationFilterRegistration.nullInitParams", entry.getKey(), entry.getValue()));
             }
             if (getInitParameter(entry.getKey()) != null) {
                 conflicts.add(entry.getKey());

==================================================
ApplicationHttpResponse.java
index 36a0401d44..f4df803edb 100644
--- a/java/org/apache/catalina/core/ApplicationHttpRequest.java
+++ b/java/org/apache/catalina/core/ApplicationHttpRequest.java
@@ -55,16 +55,14 @@ import org.apache.tomcat.util.res.StringManager;
 
 
 /**
- * Wrapper around a <code>jakarta.servlet.http.HttpServletRequest</code>
- * that transforms an application request object (which might be the original
- * one passed to a servlet, or might be based on the 2.3
- * <code>jakarta.servlet.http.HttpServletRequestWrapper</code> class)
- * back into an internal <code>org.apache.catalina.HttpRequest</code>.
+ * Wrapper around a <code>jakarta.servlet.http.HttpServletRequest</code> that transforms an application request object
+ * (which might be the original one passed to a servlet, or might be based on the 2.3
+ * <code>jakarta.servlet.http.HttpServletRequestWrapper</code> class) back into an internal
+ * <code>org.apache.catalina.HttpRequest</code>.
  * <p>
- * <strong>WARNING</strong>:  Due to Java's lack of support for multiple
- * inheritance, all of the logic in <code>ApplicationRequest</code> is
- * duplicated in <code>ApplicationHttpRequest</code>.  Make sure that you
- * keep these two classes in synchronization when making changes!
+ * <strong>WARNING</strong>: Due to Java's lack of support for multiple inheritance, all of the logic in
+ * <code>ApplicationRequest</code> is duplicated in <code>ApplicationHttpRequest</code>. Make sure that you keep these
+ * two classes in synchronization when making changes!
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
@@ -76,19 +74,13 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
     /**
      * The set of attribute names that are special for request dispatchers.
      */
-    protected static final String specials[] =
-    { RequestDispatcher.INCLUDE_REQUEST_URI,
-      RequestDispatcher.INCLUDE_CONTEXT_PATH,
-      RequestDispatcher.INCLUDE_SERVLET_PATH,
-      RequestDispatcher.INCLUDE_PATH_INFO,
-      RequestDispatcher.INCLUDE_QUERY_STRING,
-      RequestDispatcher.INCLUDE_MAPPING,
-      RequestDispatcher.FORWARD_REQUEST_URI,
-      RequestDispatcher.FORWARD_CONTEXT_PATH,
-      RequestDispatcher.FORWARD_SERVLET_PATH,
-      RequestDispatcher.FORWARD_PATH_INFO,
-      RequestDispatcher.FORWARD_QUERY_STRING,
-      RequestDispatcher.FORWARD_MAPPING};
+    protected static final String specials[] = { RequestDispatcher.INCLUDE_REQUEST_URI,
+            RequestDispatcher.INCLUDE_CONTEXT_PATH, RequestDispatcher.INCLUDE_SERVLET_PATH,
+            RequestDispatcher.INCLUDE_PATH_INFO, RequestDispatcher.INCLUDE_QUERY_STRING,
+            RequestDispatcher.INCLUDE_MAPPING, RequestDispatcher.FORWARD_REQUEST_URI,
+            RequestDispatcher.FORWARD_CONTEXT_PATH, RequestDispatcher.FORWARD_SERVLET_PATH,
+            RequestDispatcher.FORWARD_PATH_INFO, RequestDispatcher.FORWARD_QUERY_STRING,
+            RequestDispatcher.FORWARD_MAPPING };
 
     private static final int SPECIALS_FIRST_FORWARD_INDEX = 6;
 
@@ -99,13 +91,11 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
     /**
      * Construct a new wrapped request around the specified servlet request.
      *
-     * @param request The servlet request being wrapped
-     * @param context The target context for the wrapped request
-     * @param crossContext {@code true} if the wrapped request will be a
-     *                     cross-context request, otherwise {@code false}
+     * @param request      The servlet request being wrapped
+     * @param context      The target context for the wrapped request
+     * @param crossContext {@code true} if the wrapped request will be a cross-context request, otherwise {@code false}
      */
-    public ApplicationHttpRequest(HttpServletRequest request, Context context,
-                                  boolean crossContext) {
+    public ApplicationHttpRequest(HttpServletRequest request, Context context, boolean crossContext) {
 
         super(request);
         this.context = context;
@@ -131,8 +121,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * If this request is cross context, since this changes session access
-     * behavior.
+     * If this request is cross context, since this changes session access behavior.
      */
     protected final boolean crossContext;
 
@@ -144,8 +133,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * The request parameters for this request.  This is initialized from the
-     * wrapped request.
+     * The request parameters for this request. This is initialized from the wrapped request.
      */
     protected Map<String, String[]> parameters = null;
 
@@ -232,7 +220,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
         if (name.equals(Globals.DISPATCHER_TYPE_ATTR)) {
             return dispatcherType;
         } else if (name.equals(Globals.DISPATCHER_REQUEST_PATH_ATTR)) {
-            if ( requestDispatcherPath != null ){
+            if (requestDispatcherPath != null) {
                 return requestDispatcherPath.toString();
             } else {
                 return null;
@@ -243,8 +231,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
         if (pos == -1) {
             return getRequest().getAttribute(name);
         } else {
-            if ((specialAttributes[pos] == null) &&
-                    (specialAttributes[SPECIALS_FIRST_FORWARD_INDEX] == null) &&
+            if ((specialAttributes[pos] == null) && (specialAttributes[SPECIALS_FIRST_FORWARD_INDEX] == null) &&
                     (pos >= SPECIALS_FIRST_FORWARD_INDEX)) {
                 // If it's a forward special attribute, and null, it means this
                 // is an include, so we check the wrapped request since
@@ -259,8 +246,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Override the <code>getAttributeNames()</code> method of the wrapped
-     * request.
+     * Override the <code>getAttributeNames()</code> method of the wrapped request.
      */
     @Override
     public Enumeration<String> getAttributeNames() {
@@ -269,8 +255,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Override the <code>removeAttribute()</code> method of the
-     * wrapped request.
+     * Override the <code>removeAttribute()</code> method of the wrapped request.
      *
      * @param name Name of the attribute to remove
      */
@@ -285,17 +270,16 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Override the <code>setAttribute()</code> method of the
-     * wrapped request.
+     * Override the <code>setAttribute()</code> method of the wrapped request.
      *
-     * @param name Name of the attribute to set
+     * @param name  Name of the attribute to set
      * @param value Value of the attribute to set
      */
     @Override
     public void setAttribute(String name, Object value) {
 
         if (name.equals(Globals.DISPATCHER_TYPE_ATTR)) {
-            dispatcherType = (DispatcherType)value;
+            dispatcherType = (DispatcherType) value;
             return;
         } else if (name.equals(Globals.DISPATCHER_REQUEST_PATH_ATTR)) {
             requestDispatcherPath = value;
@@ -310,8 +294,8 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Return a RequestDispatcher that wraps the resource at the specified
-     * path, which may be interpreted as relative to the current request path.
+     * Return a RequestDispatcher that wraps the resource at the specified path, which may be interpreted as relative to
+     * the current request path.
      *
      * @param path Path of the resource to be wrapped
      */
@@ -338,8 +322,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
         }
 
         // Convert a request-relative path to a context-relative one
-        String servletPath =
-            (String) getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);
+        String servletPath = (String) getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);
         if (servletPath == null) {
             servletPath = getServletPath();
         }
@@ -358,8 +341,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
         String relative = null;
         if (context.getDispatchersUseEncodedPaths()) {
             if (pos >= 0) {
-                relative = URLEncoder.DEFAULT.encode(
-                        requestPath.substring(0, pos + 1), StandardCharsets.UTF_8) + path;
+                relative = URLEncoder.DEFAULT.encode(requestPath.substring(0, pos + 1), StandardCharsets.UTF_8) + path;
             } else {
                 relative = URLEncoder.DEFAULT.encode(requestPath, StandardCharsets.UTF_8) + path;
             }
@@ -378,7 +360,6 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
     /**
      * Override the getDispatcherType() method of the wrapped request.
-     *
      */
     @Override
     public DispatcherType getDispatcherType() {
@@ -390,8 +371,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Override the <code>getContextPath()</code> method of the wrapped
-     * request.
+     * Override the <code>getContextPath()</code> method of the wrapped request.
      */
     @Override
     public String getContextPath() {
@@ -417,8 +397,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Override the <code>getParameterMap()</code> method of the
-     * wrapped request.
+     * Override the <code>getParameterMap()</code> method of the wrapped request.
      */
     @Override
     public Map<String, String[]> getParameterMap() {
@@ -428,8 +407,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Override the <code>getParameterNames()</code> method of the
-     * wrapped request.
+     * Override the <code>getParameterNames()</code> method of the wrapped request.
      */
     @Override
     public Enumeration<String> getParameterNames() {
@@ -439,8 +417,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Override the <code>getParameterValues()</code> method of the
-     * wrapped request.
+     * Override the <code>getParameterValues()</code> method of the wrapped request.
      *
      * @param name Name of the requested parameter
      */
@@ -461,8 +438,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Override the <code>getPathTranslated()</code> method of the wrapped
-     * request.
+     * Override the <code>getPathTranslated()</code> method of the wrapped request.
      */
     @Override
     public String getPathTranslated() {
@@ -475,8 +451,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Override the <code>getQueryString()</code> method of the wrapped
-     * request.
+     * Override the <code>getQueryString()</code> method of the wrapped request.
      */
     @Override
     public String getQueryString() {
@@ -485,8 +460,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Override the <code>getRequestURI()</code> method of the wrapped
-     * request.
+     * Override the <code>getRequestURI()</code> method of the wrapped request.
      */
     @Override
     public String getRequestURI() {
@@ -495,8 +469,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Override the <code>getRequestURL()</code> method of the wrapped
-     * request.
+     * Override the <code>getRequestURL()</code> method of the wrapped request.
      */
     @Override
     public StringBuffer getRequestURL() {
@@ -505,8 +478,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Override the <code>getServletPath()</code> method of the wrapped
-     * request.
+     * Override the <code>getServletPath()</code> method of the wrapped request.
      */
     @Override
     public String getServletPath() {
@@ -521,8 +493,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Return the session associated with this Request, creating one
-     * if necessary.
+     * Return the session associated with this Request, creating one if necessary.
      */
     @Override
     public HttpSession getSession() {
@@ -531,8 +502,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Return the session associated with this Request, creating one
-     * if necessary and requested.
+     * Return the session associated with this Request, creating one if necessary and requested.
      *
      * @param create Create a new session if one does not exist
      */
@@ -561,8 +531,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
             if (other != null) {
                 Session localSession = null;
                 try {
-                    localSession =
-                        context.getManager().findSession(other.getId());
+                    localSession = context.getManager().findSession(other.getId());
                     if (localSession != null && !localSession.isValid()) {
                         localSession = null;
                     }
@@ -570,8 +539,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
                     // Ignore
                 }
                 if (localSession == null && create) {
-                    localSession =
-                        context.getManager().createSession(other.getId());
+                    localSession = context.getManager().createSession(other.getId());
                 }
                 if (localSession != null) {
                     localSession.access();
@@ -589,11 +557,11 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Returns true if the request specifies a JSESSIONID that is valid within
-     * the context of this ApplicationHttpRequest, false otherwise.
+     * Returns true if the request specifies a JSESSIONID that is valid within the context of this
+     * ApplicationHttpRequest, false otherwise.
      *
-     * @return true if the request specifies a JSESSIONID that is valid within
-     * the context of this ApplicationHttpRequest, false otherwise.
+     * @return true if the request specifies a JSESSIONID that is valid within the context of this
+     *             ApplicationHttpRequest, false otherwise.
      */
     @Override
     public boolean isRequestedSessionIdValid() {
@@ -701,9 +669,8 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
         super.setRequest(request);
 
         // Initialize the attributes for this request
-        dispatcherType = (DispatcherType)request.getAttribute(Globals.DISPATCHER_TYPE_ATTR);
-        requestDispatcherPath =
-            request.getAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR);
+        dispatcherType = (DispatcherType) request.getAttribute(Globals.DISPATCHER_TYPE_ATTR);
+        requestDispatcherPath = request.getAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR);
 
         // Initialize the path elements for this request
         contextPath = request.getContextPath();
@@ -740,9 +707,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Parses the parameters of this request.
-     *
-     * If parameters are present in both the query string and the request
+     * Parses the parameters of this request. If parameters are present in both the query string and the request
      * content, they are merged.
      */
     void parseParameters() {
@@ -754,7 +719,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
         parameters = new ParameterMap<>();
         parameters.putAll(getRequest().getParameterMap());
         mergeParameters();
-        ((ParameterMap<String,String[]>) parameters).setLocked(true);
+        ((ParameterMap<String, String[]>) parameters).setLocked(true);
         parsedParams = true;
     }
 
@@ -762,8 +727,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
     /**
      * Save query parameters for this request.
      *
-     * @param queryString The query string containing parameters for this
-     *                    request
+     * @param queryString The query string containing parameters for this request
      */
     void setQueryParams(String queryString) {
         this.queryParamString = queryString;
@@ -778,8 +742,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
     // ------------------------------------------------------ Protected Methods
 
     /**
-     * Is this attribute name one of the special ones that is added only for
-     * included servlets?
+     * Is this attribute name one of the special ones that is added only for included servlets?
      *
      * @param name Attribute name to be tested
      */
@@ -798,8 +761,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
     /**
      * Get a special attribute.
      *
-     * @return the special attribute pos, or -1 if it is not a special
-     *         attribute
+     * @return the special attribute pos, or -1 if it is not a special attribute
      */
     protected int getSpecial(String name) {
         for (int i = 0; i < specials.length; i++) {
@@ -873,10 +835,9 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Merge the parameters from the saved query parameter string (if any), and
-     * the parameters already present on this request (if any), such that the
-     * parameter values from the query string show up first if there are
-     * duplicate parameter names.
+     * Merge the parameters from the saved query parameter string (if any), and the parameters already present on this
+     * request (if any), such that the parameter values from the query string show up first if there are duplicate
+     * parameter names.
      */
     private void mergeParameters() {
 
@@ -930,8 +891,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
 
     /**
-     * Utility class used to expose the special attributes as being available
-     * as request attributes.
+     * Utility class used to expose the special attributes as being available as request attributes.
      */
     protected class AttributeNamesEnumerator implements Enumeration<String> {
 
@@ -954,8 +914,7 @@ class ApplicationHttpRequest extends HttpServletRequestWrapper {
 
         @Override
         public boolean hasMoreElements() {
-            return ((pos != last) || (next != null)
-                    || ((next = findNext()) != null));
+            return ((pos != last) || (next != null) || ((next = findNext()) != null));
         }
 
         @Override

==================================================
ApplicationMapping.java
index 0fd93517d6..2942c84a0c 100644
--- a/java/org/apache/catalina/core/ApplicationHttpResponse.java
+++ b/java/org/apache/catalina/core/ApplicationHttpResponse.java
@@ -25,16 +25,14 @@ import jakarta.servlet.http.HttpServletResponseWrapper;
 
 
 /**
- * Wrapper around a <code>jakarta.servlet.http.HttpServletResponse</code>
- * that transforms an application response object (which might be the original
- * one passed to a servlet, or might be based on the 2.3
- * <code>jakarta.servlet.http.HttpServletResponseWrapper</code> class)
- * back into an internal <code>org.apache.catalina.HttpResponse</code>.
+ * Wrapper around a <code>jakarta.servlet.http.HttpServletResponse</code> that transforms an application response object
+ * (which might be the original one passed to a servlet, or might be based on the 2.3
+ * <code>jakarta.servlet.http.HttpServletResponseWrapper</code> class) back into an internal
+ * <code>org.apache.catalina.HttpResponse</code>.
  * <p>
- * <strong>WARNING</strong>:  Due to Java's lack of support for multiple
- * inheritance, all of the logic in <code>ApplicationResponse</code> is
- * duplicated in <code>ApplicationHttpResponse</code>.  Make sure that you
- * keep these two classes in synchronization when making changes!
+ * <strong>WARNING</strong>: Due to Java's lack of support for multiple inheritance, all of the logic in
+ * <code>ApplicationResponse</code> is duplicated in <code>ApplicationHttpResponse</code>. Make sure that you keep these
+ * two classes in synchronization when making changes!
  *
  * @author Craig R. McClanahan
  */
@@ -46,11 +44,10 @@ class ApplicationHttpResponse extends HttpServletResponseWrapper {
      * Construct a new wrapped response around the specified servlet response.
      *
      * @param response The servlet response being wrapped
-     * @param included <code>true</code> if this response is being processed
-     *  by a <code>RequestDispatcher.include()</code> call
+     * @param included <code>true</code> if this response is being processed by a
+     *                     <code>RequestDispatcher.include()</code> call
      */
-    public ApplicationHttpResponse(HttpServletResponse response,
-                                   boolean included) {
+    public ApplicationHttpResponse(HttpServletResponse response, boolean included) {
 
         super(response);
         setIncluded(included);
@@ -62,8 +59,7 @@ class ApplicationHttpResponse extends HttpServletResponseWrapper {
 
 
     /**
-     * Is this wrapped response the subject of an <code>include()</code>
-     * call?
+     * Is this wrapped response the subject of an <code>include()</code> call?
      */
     protected boolean included = false;
 
@@ -73,8 +69,7 @@ class ApplicationHttpResponse extends HttpServletResponseWrapper {
     /**
      * Disallow <code>reset()</code> calls on a included response.
      *
-     * @exception IllegalStateException if the response has already
-     *  been committed
+     * @exception IllegalStateException if the response has already been committed
      */
     @Override
     public void reset() {
@@ -88,8 +83,7 @@ class ApplicationHttpResponse extends HttpServletResponseWrapper {
 
 
     /**
-     * Disallow <code>setContentLength(int)</code> calls on an included
-     * response.
+     * Disallow <code>setContentLength(int)</code> calls on an included response.
      *
      * @param len The new content length
      */
@@ -104,8 +98,7 @@ class ApplicationHttpResponse extends HttpServletResponseWrapper {
 
 
     /**
-     * Disallow <code>setContentLengthLong(long)</code> calls on an included
-     * response.
+     * Disallow <code>setContentLengthLong(long)</code> calls on an included response.
      *
      * @param len The new content length
      */
@@ -183,7 +176,7 @@ class ApplicationHttpResponse extends HttpServletResponseWrapper {
     /**
      * Disallow <code>addDateHeader()</code> calls on an included response.
      *
-     * @param name The new header name
+     * @param name  The new header name
      * @param value The new header value
      */
     @Override
@@ -199,7 +192,7 @@ class ApplicationHttpResponse extends HttpServletResponseWrapper {
     /**
      * Disallow <code>addHeader()</code> calls on an included response.
      *
-     * @param name The new header name
+     * @param name  The new header name
      * @param value The new header value
      */
     @Override
@@ -215,7 +208,7 @@ class ApplicationHttpResponse extends HttpServletResponseWrapper {
     /**
      * Disallow <code>addIntHeader()</code> calls on an included response.
      *
-     * @param name The new header name
+     * @param name  The new header name
      * @param value The new header value
      */
     @Override
@@ -248,7 +241,7 @@ class ApplicationHttpResponse extends HttpServletResponseWrapper {
     /**
      * Disallow <code>sendError()</code> calls on an included response.
      *
-     * @param sc The new status code
+     * @param sc  The new status code
      * @param msg The new message
      *
      * @exception IOException if an input/output error occurs
@@ -283,7 +276,7 @@ class ApplicationHttpResponse extends HttpServletResponseWrapper {
     /**
      * Disallow <code>setDateHeader()</code> calls on an included response.
      *
-     * @param name The new header name
+     * @param name  The new header name
      * @param value The new header value
      */
     @Override
@@ -299,7 +292,7 @@ class ApplicationHttpResponse extends HttpServletResponseWrapper {
     /**
      * Disallow <code>setHeader()</code> calls on an included response.
      *
-     * @param name The new header name
+     * @param name  The new header name
      * @param value The new header value
      */
     @Override
@@ -315,7 +308,7 @@ class ApplicationHttpResponse extends HttpServletResponseWrapper {
     /**
      * Disallow <code>setIntHeader()</code> calls on an included response.
      *
-     * @param name The new header name
+     * @param name  The new header name
      * @param value The new header value
      */
     @Override

==================================================
ApplicationPart.java
index 3bd83a261b..52389434ab 100644
--- a/java/org/apache/catalina/core/ApplicationMapping.java
+++ b/java/org/apache/catalina/core/ApplicationMapping.java
@@ -56,8 +56,8 @@ public class ApplicationMapping {
                     case EXTENSION:
                         String path = mappingData.wrapperPath.toString();
                         int extIndex = path.lastIndexOf('.');
-                        mapping = new MappingImpl(path.substring(1, extIndex),
-                                "*" + path.substring(extIndex), mappingData.matchType, servletName);
+                        mapping = new MappingImpl(path.substring(1, extIndex), "*" + path.substring(extIndex),
+                                mappingData.matchType, servletName);
                         break;
                     case PATH:
                         String matchValue;
@@ -87,8 +87,7 @@ public class ApplicationMapping {
         private final MappingMatch mappingType;
         private final String servletName;
 
-        public MappingImpl(String matchValue, String pattern, MappingMatch mappingType,
-                String servletName) {
+        public MappingImpl(String matchValue, String pattern, MappingMatch mappingType, String servletName) {
             this.matchValue = matchValue;
             this.pattern = pattern;
             this.mappingType = mappingType;

==================================================
ApplicationPushBuilder.java
index ec10e36289..c5aaf264bd 100644
--- a/java/org/apache/catalina/core/ApplicationPart.java
+++ b/java/org/apache/catalina/core/ApplicationPart.java
@@ -35,9 +35,8 @@ import org.apache.tomcat.util.http.fileupload.disk.DiskFileItem;
 import org.apache.tomcat.util.http.parser.HttpParser;
 
 /**
- * Adaptor to allow {@link FileItem} objects generated by the package renamed
- * commons-upload to be used by the Servlet 3.0 upload API that expects
- * {@link Part}s.
+ * Adaptor to allow {@link FileItem} objects generated by the package renamed commons-upload to be used by the Servlet
+ * 3.0 upload API that expects {@link Part}s.
  */
 public class ApplicationPart implements Part {
 
@@ -71,8 +70,7 @@ public class ApplicationPart implements Part {
     public Collection<String> getHeaderNames() {
         if (fileItem instanceof DiskFileItem) {
             LinkedHashSet<String> headerNames = new LinkedHashSet<>();
-            Iterator<String> iter =
-                fileItem.getHeaders().getHeaderNames();
+            Iterator<String> iter = fileItem.getHeaders().getHeaderNames();
             while (iter.hasNext()) {
                 headerNames.add(iter.next());
             }
@@ -85,8 +83,7 @@ public class ApplicationPart implements Part {
     public Collection<String> getHeaders(String name) {
         if (fileItem instanceof DiskFileItem) {
             LinkedHashSet<String> headers = new LinkedHashSet<>();
-            Iterator<String> iter =
-                fileItem.getHeaders().getHeaders(name);
+            Iterator<String> iter = fileItem.getHeaders().getHeaders(name);
             while (iter.hasNext()) {
                 headers.add(iter.next());
             }
@@ -140,7 +137,7 @@ public class ApplicationPart implements Part {
                 ParameterParser paramParser = new ParameterParser();
                 paramParser.setLowerCaseNames(true);
                 // Parameter parser can handle null input
-                Map<String,String> params = paramParser.parse(cd, ';');
+                Map<String, String> params = paramParser.parse(cd, ';');
                 if (params.containsKey("filename")) {
                     fileName = params.get("filename");
                     // The parser will remove surrounding '"' but will not

==================================================
ApplicationRequest.java
index 42842ef869..b7a671dc9a 100644
--- a/java/org/apache/catalina/core/ApplicationPushBuilder.java
+++ b/java/org/apache/catalina/core/ApplicationPushBuilder.java
@@ -67,7 +67,7 @@ public class ApplicationPushBuilder implements PushBuilder {
     private final boolean addSessionCookie;
     private final boolean addSessionPathParameter;
 
-    private final Map<String,List<String>> headers = new CaseInsensitiveKeyMap<>();
+    private final Map<String, List<String>> headers = new CaseInsensitiveKeyMap<>();
     private final List<Cookie> cookies = new ArrayList<>();
     private String method = "GET";
     private String path;
@@ -127,10 +127,9 @@ public class ApplicationPushBuilder implements PushBuilder {
         if (sessionId == null) {
             sessionId = request.getRequestedSessionId();
         }
-        if (!request.isRequestedSessionIdFromCookie() && !request.isRequestedSessionIdFromURL() &&
-                sessionId != null) {
-            Set<SessionTrackingMode> sessionTrackingModes =
-                    request.getServletContext().getEffectiveSessionTrackingModes();
+        if (!request.isRequestedSessionIdFromCookie() && !request.isRequestedSessionIdFromURL() && sessionId != null) {
+            Set<SessionTrackingMode> sessionTrackingModes = request.getServletContext()
+                    .getEffectiveSessionTrackingModes();
             addSessionCookie = sessionTrackingModes.contains(SessionTrackingMode.COOKIE);
             addSessionPathParameter = sessionTrackingModes.contains(SessionTrackingMode.URL);
         } else {
@@ -153,16 +152,15 @@ public class ApplicationPushBuilder implements PushBuilder {
         }
         if (cookies.size() > 0) {
             List<String> cookieValues = new ArrayList<>(1);
-            cookieValues.add(generateCookieHeader(cookies,
-                    catalinaRequest.getContext().getCookieProcessor()));
+            cookieValues.add(generateCookieHeader(cookies, catalinaRequest.getContext().getCookieProcessor()));
             headers.put("cookie", cookieValues);
         }
 
         // Authentication
         if (catalinaRequest.getPrincipal() != null) {
-            if ((session == null) || catalinaRequest.getSessionInternal(false).getPrincipal() == null
-                    || !(context.getAuthenticator() instanceof AuthenticatorBase)
-                    || !((AuthenticatorBase) context.getAuthenticator()).getCache()) {
+            if ((session == null) || catalinaRequest.getSessionInternal(false).getPrincipal() == null ||
+                    !(context.getAuthenticator() instanceof AuthenticatorBase) ||
+                    !((AuthenticatorBase) context.getAuthenticator()).getCache()) {
                 // Set a username only if there is no session cache for the principal
                 userName = catalinaRequest.getPrincipal().getName();
             }
@@ -197,8 +195,7 @@ public class ApplicationPushBuilder implements PushBuilder {
     public PushBuilder method(String method) {
         String upperMethod = method.trim().toUpperCase(Locale.ENGLISH);
         if (DISALLOWED_METHODS.contains(upperMethod) || upperMethod.length() == 0) {
-            throw new IllegalArgumentException(
-                    sm.getString("applicationPushBuilder.methodInvalid", upperMethod));
+            throw new IllegalArgumentException(sm.getString("applicationPushBuilder.methodInvalid", upperMethod));
         }
         // Check a token was supplied
         if (!HttpParser.isToken(upperMethod)) {
@@ -303,7 +300,7 @@ public class ApplicationPushBuilder implements PushBuilder {
         pushTarget.scheme().setString(baseRequest.getScheme());
 
         // Copy headers
-        for (Map.Entry<String,List<String>> header : headers.entrySet()) {
+        for (Map.Entry<String, List<String>> header : headers.entrySet()) {
             for (String value : header.getValue()) {
                 pushTarget.getMimeHeaders().addValue(header.getKey()).setString(value);
             }
@@ -342,8 +339,7 @@ public class ApplicationPushBuilder implements PushBuilder {
 
         // Undecoded path - just %nn encoded
         pushTarget.requestURI().setString(pushPath);
-        pushTarget.decodedURI().setString(decode(pushPath,
-                catalinaRequest.getConnector().getURICharset()));
+        pushTarget.decodedURI().setString(decode(pushPath, catalinaRequest.getConnector().getURICharset()));
 
         // Query string
         if (pushQueryString == null && queryString != null) {
@@ -351,7 +347,7 @@ public class ApplicationPushBuilder implements PushBuilder {
         } else if (pushQueryString != null && queryString == null) {
             pushTarget.queryString().setString(pushQueryString);
         } else if (pushQueryString != null && queryString != null) {
-            pushTarget.queryString().setString(pushQueryString + "&" +queryString);
+            pushTarget.queryString().setString(pushQueryString + "&" + queryString);
         }
 
         // Authorization
@@ -386,7 +382,7 @@ public class ApplicationPushBuilder implements PushBuilder {
             result.append(input.substring(end, start));
             // Advance the end 3 characters: %nn
             end = start + 3;
-            while (end <input.length() && input.charAt(end) == '%') {
+            while (end < input.length() && input.charAt(end) == '%') {
                 end += 3;
             }
             result.append(decodePercentSequence(input.substring(start, end), charset));
@@ -400,7 +396,7 @@ public class ApplicationPushBuilder implements PushBuilder {
 
 
     private static String decodePercentSequence(String sequence, Charset charset) {
-        byte[] bytes = new byte[sequence.length()/3];
+        byte[] bytes = new byte[sequence.length() / 3];
         for (int i = 0; i < bytes.length; i += 3) {
             bytes[i] = (byte) ((HexUtils.getDec(sequence.charAt(1 + 3 * i)) << 4) +
                     HexUtils.getDec(sequence.charAt(2 + 3 * i)));

==================================================
ApplicationResponse.java
index 0d2622146f..6e2ff1993a 100644
--- a/java/org/apache/catalina/core/ApplicationRequest.java
+++ b/java/org/apache/catalina/core/ApplicationRequest.java
@@ -27,16 +27,14 @@ import jakarta.servlet.ServletRequestWrapper;
 
 
 /**
- * Wrapper around a <code>jakarta.servlet.ServletRequest</code>
- * that transforms an application request object (which might be the original
- * one passed to a servlet, or might be based on the 2.3
- * <code>jakarta.servlet.ServletRequestWrapper</code> class)
- * back into an internal <code>org.apache.catalina.Request</code>.
+ * Wrapper around a <code>jakarta.servlet.ServletRequest</code> that transforms an application request object (which
+ * might be the original one passed to a servlet, or might be based on the 2.3
+ * <code>jakarta.servlet.ServletRequestWrapper</code> class) back into an internal
+ * <code>org.apache.catalina.Request</code>.
  * <p>
- * <strong>WARNING</strong>:  Due to Java's lack of support for multiple
- * inheritance, all of the logic in <code>ApplicationRequest</code> is
- * duplicated in <code>ApplicationHttpRequest</code>.  Make sure that you
- * keep these two classes in synchronization when making changes!
+ * <strong>WARNING</strong>: Due to Java's lack of support for multiple inheritance, all of the logic in
+ * <code>ApplicationRequest</code> is duplicated in <code>ApplicationHttpRequest</code>. Make sure that you keep these
+ * two classes in synchronization when making changes!
  *
  * @author Craig R. McClanahan
  */
@@ -49,19 +47,13 @@ class ApplicationRequest extends ServletRequestWrapper {
     /**
      * The set of attribute names that are special for request dispatchers.
      */
-    protected static final String specials[] =
-    { RequestDispatcher.INCLUDE_REQUEST_URI,
-      RequestDispatcher.INCLUDE_CONTEXT_PATH,
-      RequestDispatcher.INCLUDE_SERVLET_PATH,
-      RequestDispatcher.INCLUDE_PATH_INFO,
-      RequestDispatcher.INCLUDE_QUERY_STRING,
-      RequestDispatcher.INCLUDE_MAPPING,
-      RequestDispatcher.FORWARD_REQUEST_URI,
-      RequestDispatcher.FORWARD_CONTEXT_PATH,
-      RequestDispatcher.FORWARD_SERVLET_PATH,
-      RequestDispatcher.FORWARD_PATH_INFO,
-      RequestDispatcher.FORWARD_QUERY_STRING,
-      RequestDispatcher.FORWARD_MAPPING};
+    protected static final String specials[] = { RequestDispatcher.INCLUDE_REQUEST_URI,
+            RequestDispatcher.INCLUDE_CONTEXT_PATH, RequestDispatcher.INCLUDE_SERVLET_PATH,
+            RequestDispatcher.INCLUDE_PATH_INFO, RequestDispatcher.INCLUDE_QUERY_STRING,
+            RequestDispatcher.INCLUDE_MAPPING, RequestDispatcher.FORWARD_REQUEST_URI,
+            RequestDispatcher.FORWARD_CONTEXT_PATH, RequestDispatcher.FORWARD_SERVLET_PATH,
+            RequestDispatcher.FORWARD_PATH_INFO, RequestDispatcher.FORWARD_QUERY_STRING,
+            RequestDispatcher.FORWARD_MAPPING };
 
 
     // ----------------------------------------------------------- Constructors
@@ -84,8 +76,7 @@ class ApplicationRequest extends ServletRequestWrapper {
 
 
     /**
-     * The request attributes for this request.  This is initialized from the
-     * wrapped request, but updates are allowed.
+     * The request attributes for this request. This is initialized from the wrapped request, but updates are allowed.
      */
     protected final HashMap<String, Object> attributes = new HashMap<>();
 
@@ -109,8 +100,7 @@ class ApplicationRequest extends ServletRequestWrapper {
 
 
     /**
-     * Override the <code>getAttributeNames()</code> method of the wrapped
-     * request.
+     * Override the <code>getAttributeNames()</code> method of the wrapped request.
      */
     @Override
     public Enumeration<String> getAttributeNames() {
@@ -123,8 +113,7 @@ class ApplicationRequest extends ServletRequestWrapper {
 
 
     /**
-     * Override the <code>removeAttribute()</code> method of the
-     * wrapped request.
+     * Override the <code>removeAttribute()</code> method of the wrapped request.
      *
      * @param name Name of the attribute to remove
      */
@@ -142,10 +131,9 @@ class ApplicationRequest extends ServletRequestWrapper {
 
 
     /**
-     * Override the <code>setAttribute()</code> method of the
-     * wrapped request.
+     * Override the <code>setAttribute()</code> method of the wrapped request.
      *
-     * @param name Name of the attribute to set
+     * @param name  Name of the attribute to set
      * @param value Value of the attribute to set
      */
     @Override
@@ -192,8 +180,7 @@ class ApplicationRequest extends ServletRequestWrapper {
 
 
     /**
-     * Is this attribute name one of the special ones that is added only for
-     * included servlets?
+     * Is this attribute name one of the special ones that is added only for included servlets?
      *
      * @param name Attribute name to be tested
      */

==================================================
ApplicationServletRegistration.java
index 8ecfe03777..2408a0efc1 100644
--- a/java/org/apache/catalina/core/ApplicationResponse.java
+++ b/java/org/apache/catalina/core/ApplicationResponse.java
@@ -23,16 +23,14 @@ import jakarta.servlet.ServletResponseWrapper;
 
 
 /**
- * Wrapper around a <code>jakarta.servlet.ServletResponse</code>
- * that transforms an application response object (which might be the original
- * one passed to a servlet, or might be based on the 2.3
- * <code>jakarta.servlet.ServletResponseWrapper</code> class)
- * back into an internal <code>org.apache.catalina.Response</code>.
+ * Wrapper around a <code>jakarta.servlet.ServletResponse</code> that transforms an application response object (which
+ * might be the original one passed to a servlet, or might be based on the 2.3
+ * <code>jakarta.servlet.ServletResponseWrapper</code> class) back into an internal
+ * <code>org.apache.catalina.Response</code>.
  * <p>
- * <strong>WARNING</strong>:  Due to Java's lack of support for multiple
- * inheritance, all of the logic in <code>ApplicationResponse</code> is
- * duplicated in <code>ApplicationHttpResponse</code>.  Make sure that you
- * keep these two classes in synchronization when making changes!
+ * <strong>WARNING</strong>: Due to Java's lack of support for multiple inheritance, all of the logic in
+ * <code>ApplicationResponse</code> is duplicated in <code>ApplicationHttpResponse</code>. Make sure that you keep these
+ * two classes in synchronization when making changes!
  *
  * @author Craig R. McClanahan
  */
@@ -44,8 +42,8 @@ class ApplicationResponse extends ServletResponseWrapper {
      * Construct a new wrapped response around the specified servlet response.
      *
      * @param response The servlet response being wrapped
-     * @param included <code>true</code> if this response is being processed
-     *  by a <code>RequestDispatcher.include()</code> call
+     * @param included <code>true</code> if this response is being processed by a
+     *                     <code>RequestDispatcher.include()</code> call
      */
     public ApplicationResponse(ServletResponse response, boolean included) {
 
@@ -59,8 +57,7 @@ class ApplicationResponse extends ServletResponseWrapper {
 
 
     /**
-     * Is this wrapped response the subject of an <code>include()</code>
-     * call?
+     * Is this wrapped response the subject of an <code>include()</code> call?
      */
     protected boolean included = false;
 
@@ -71,8 +68,7 @@ class ApplicationResponse extends ServletResponseWrapper {
     /**
      * Disallow <code>reset()</code> calls on a included response.
      *
-     * @exception IllegalStateException if the response has already
-     *  been committed
+     * @exception IllegalStateException if the response has already been committed
      */
     @Override
     public void reset() {
@@ -86,8 +82,7 @@ class ApplicationResponse extends ServletResponseWrapper {
 
 
     /**
-     * Disallow <code>setContentLength(int)</code> calls on an included
-     * response.
+     * Disallow <code>setContentLength(int)</code> calls on an included response.
      *
      * @param len The new content length
      */
@@ -102,8 +97,7 @@ class ApplicationResponse extends ServletResponseWrapper {
 
 
     /**
-     * Disallow <code>setContentLengthLong(long)</code> calls on an included
-     * response.
+     * Disallow <code>setContentLengthLong(long)</code> calls on an included response.
      *
      * @param len The new content length
      */

==================================================
ApplicationSessionCookieConfig.java
index 351836c5e3..808e16bf52 100644
--- a/java/org/apache/catalina/core/ApplicationServletRegistration.java
+++ b/java/org/apache/catalina/core/ApplicationServletRegistration.java
@@ -45,8 +45,7 @@ public class ApplicationServletRegistration implements ServletRegistration.Dynam
     private final Context context;
     private ServletSecurityElement constraint;
 
-    public ApplicationServletRegistration(Wrapper wrapper,
-            Context context) {
+    public ApplicationServletRegistration(Wrapper wrapper, Context context) {
         this.wrapper = wrapper;
         this.context = context;
 
@@ -64,7 +63,7 @@ public class ApplicationServletRegistration implements ServletRegistration.Dynam
 
     @Override
     public Map<String, String> getInitParameters() {
-        ParameterMap<String,String> result = new ParameterMap<>();
+        ParameterMap<String, String> result = new ParameterMap<>();
 
         String[] parameterNames = wrapper.findInitParameters();
 
@@ -85,8 +84,7 @@ public class ApplicationServletRegistration implements ServletRegistration.Dynam
     public boolean setInitParameter(String name, String value) {
         if (name == null || value == null) {
             throw new IllegalArgumentException(
-                    sm.getString("applicationFilterRegistration.nullInitParam",
-                            name, value));
+                    sm.getString("applicationFilterRegistration.nullInitParam", name, value));
         }
         if (getInitParameter(name) != null) {
             return false;
@@ -104,9 +102,8 @@ public class ApplicationServletRegistration implements ServletRegistration.Dynam
 
         for (Map.Entry<String, String> entry : initParameters.entrySet()) {
             if (entry.getKey() == null || entry.getValue() == null) {
-                throw new IllegalArgumentException(sm.getString(
-                        "applicationFilterRegistration.nullInitParams",
-                                entry.getKey(), entry.getValue()));
+                throw new IllegalArgumentException(
+                        sm.getString("applicationFilterRegistration.nullInitParams", entry.getKey(), entry.getValue()));
             }
             if (getInitParameter(entry.getKey()) != null) {
                 conflicts.add(entry.getKey());
@@ -147,14 +144,12 @@ public class ApplicationServletRegistration implements ServletRegistration.Dynam
     @Override
     public Set<String> setServletSecurity(ServletSecurityElement constraint) {
         if (constraint == null) {
-            throw new IllegalArgumentException(sm.getString(
-                    "applicationServletRegistration.setServletSecurity.iae",
+            throw new IllegalArgumentException(sm.getString("applicationServletRegistration.setServletSecurity.iae",
                     getName(), context.getName()));
         }
 
         if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
-            throw new IllegalStateException(sm.getString(
-                    "applicationServletRegistration.setServletSecurity.ise",
+            throw new IllegalStateException(sm.getString("applicationServletRegistration.setServletSecurity.ise",
                     getName(), context.getName()));
         }
 
@@ -190,8 +185,7 @@ public class ApplicationServletRegistration implements ServletRegistration.Dynam
         }
 
         for (String urlPattern : urlPatterns) {
-            context.addServletMappingDecoded(
-                    UDecoder.URLDecode(urlPattern, StandardCharsets.UTF_8), wrapper.getName());
+            context.addServletMappingDecoded(UDecoder.URLDecode(urlPattern, StandardCharsets.UTF_8), wrapper.getName());
         }
 
         if (constraint != null) {

==================================================
AprLifecycleListener.java
index b83647e87c..ab71ead321 100644
--- a/java/org/apache/catalina/core/ApplicationSessionCookieConfig.java
+++ b/java/org/apache/catalina/core/ApplicationSessionCookieConfig.java
@@ -40,7 +40,7 @@ public class ApplicationSessionCookieConfig implements SessionCookieConfig {
     private static final boolean DEFAULT_HTTP_ONLY = false;
     private static final boolean DEFAULT_SECURE = false;
 
-    private final Map<String,String> attributes = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
+    private final Map<String, String> attributes = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
 
     private String name;
     private StandardContext context;
@@ -99,18 +99,16 @@ public class ApplicationSessionCookieConfig implements SessionCookieConfig {
     @Override
     public void setComment(String comment) {
         if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
-            throw new IllegalStateException(sm.getString(
-                    "applicationSessionCookieConfig.ise", "comment",
-                    context.getPath()));
+            throw new IllegalStateException(
+                    sm.getString("applicationSessionCookieConfig.ise", "comment", context.getPath()));
         }
     }
 
     @Override
     public void setDomain(String domain) {
         if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
-            throw new IllegalStateException(sm.getString(
-                    "applicationSessionCookieConfig.ise", "domain name",
-                    context.getPath()));
+            throw new IllegalStateException(
+                    sm.getString("applicationSessionCookieConfig.ise", "domain name", context.getPath()));
         }
         setAttribute(Constants.COOKIE_DOMAIN_ATTR, domain);
     }
@@ -118,9 +116,8 @@ public class ApplicationSessionCookieConfig implements SessionCookieConfig {
     @Override
     public void setHttpOnly(boolean httpOnly) {
         if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
-            throw new IllegalStateException(sm.getString(
-                    "applicationSessionCookieConfig.ise", "HttpOnly",
-                    context.getPath()));
+            throw new IllegalStateException(
+                    sm.getString("applicationSessionCookieConfig.ise", "HttpOnly", context.getPath()));
         }
         setAttribute(Constants.COOKIE_HTTP_ONLY_ATTR, Boolean.toString(httpOnly));
     }
@@ -128,9 +125,8 @@ public class ApplicationSessionCookieConfig implements SessionCookieConfig {
     @Override
     public void setMaxAge(int maxAge) {
         if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
-            throw new IllegalStateException(sm.getString(
-                    "applicationSessionCookieConfig.ise", "max age",
-                    context.getPath()));
+            throw new IllegalStateException(
+                    sm.getString("applicationSessionCookieConfig.ise", "max age", context.getPath()));
         }
         setAttribute(Constants.COOKIE_MAX_AGE_ATTR, Integer.toString(maxAge));
     }
@@ -138,9 +134,8 @@ public class ApplicationSessionCookieConfig implements SessionCookieConfig {
     @Override
     public void setName(String name) {
         if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
-            throw new IllegalStateException(sm.getString(
-                    "applicationSessionCookieConfig.ise", "name",
-                    context.getPath()));
+            throw new IllegalStateException(
+                    sm.getString("applicationSessionCookieConfig.ise", "name", context.getPath()));
         }
         this.name = name;
     }
@@ -148,9 +143,8 @@ public class ApplicationSessionCookieConfig implements SessionCookieConfig {
     @Override
     public void setPath(String path) {
         if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
-            throw new IllegalStateException(sm.getString(
-                    "applicationSessionCookieConfig.ise", "path",
-                    context.getPath()));
+            throw new IllegalStateException(
+                    sm.getString("applicationSessionCookieConfig.ise", "path", context.getPath()));
         }
         setAttribute(Constants.COOKIE_PATH_ATTR, path);
     }
@@ -158,9 +152,8 @@ public class ApplicationSessionCookieConfig implements SessionCookieConfig {
     @Override
     public void setSecure(boolean secure) {
         if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
-            throw new IllegalStateException(sm.getString(
-                    "applicationSessionCookieConfig.ise", "secure",
-                    context.getPath()));
+            throw new IllegalStateException(
+                    sm.getString("applicationSessionCookieConfig.ise", "secure", context.getPath()));
         }
         setAttribute(Constants.COOKIE_SECURE_ATTR, Boolean.toString(secure));
     }
@@ -169,9 +162,8 @@ public class ApplicationSessionCookieConfig implements SessionCookieConfig {
     @Override
     public void setAttribute(String name, String value) {
         if (!context.getState().equals(LifecycleState.STARTING_PREP)) {
-            throw new IllegalStateException(sm.getString(
-                    "applicationSessionCookieConfig.ise", name,
-                    context.getPath()));
+            throw new IllegalStateException(
+                    sm.getString("applicationSessionCookieConfig.ise", name, context.getPath()));
         }
         attributes.put(name, value);
     }
@@ -190,25 +182,22 @@ public class ApplicationSessionCookieConfig implements SessionCookieConfig {
     /**
      * Creates a new session cookie for the given session ID
      *
-     * @param context     The Context for the web application
-     * @param sessionId   The ID of the session for which the cookie will be
-     *                    created
-     * @param secure      Should session cookie be configured as secure
+     * @param context   The Context for the web application
+     * @param sessionId The ID of the session for which the cookie will be created
+     * @param secure    Should session cookie be configured as secure
+     *
      * @return the cookie for the session
      */
-    public static Cookie createSessionCookie(Context context,
-            String sessionId, boolean secure) {
+    public static Cookie createSessionCookie(Context context, String sessionId, boolean secure) {
 
-        SessionCookieConfig scc =
-            context.getServletContext().getSessionCookieConfig();
+        SessionCookieConfig scc = context.getServletContext().getSessionCookieConfig();
 
         // NOTE: The priority order for session cookie configuration is:
-        //       1. Context level configuration
-        //       2. Values from SessionCookieConfig
-        //       3. Defaults
+        // 1. Context level configuration
+        // 2. Values from SessionCookieConfig
+        // 3. Defaults
 
-        Cookie cookie = new Cookie(
-                SessionConfig.getSessionCookieName(context), sessionId);
+        Cookie cookie = new Cookie(SessionConfig.getSessionCookieName(context), sessionId);
 
         // Just apply the defaults.
         cookie.setMaxAge(scc.getMaxAge());
@@ -235,19 +224,19 @@ public class ApplicationSessionCookieConfig implements SessionCookieConfig {
         cookie.setPath(SessionConfig.getSessionCookiePath(context));
 
         // Other attributes
-        for (Map.Entry<String,String> attribute : scc.getAttributes().entrySet()) {
+        for (Map.Entry<String, String> attribute : scc.getAttributes().entrySet()) {
             switch (attribute.getKey()) {
-            case Constants.COOKIE_COMMENT_ATTR:
-            case Constants.COOKIE_DOMAIN_ATTR:
-            case Constants.COOKIE_MAX_AGE_ATTR:
-            case Constants.COOKIE_PATH_ATTR:
-            case Constants.COOKIE_SECURE_ATTR:
-            case Constants.COOKIE_HTTP_ONLY_ATTR:
-                // Handled above so NO-OP
-                break;
-            default: {
-                cookie.setAttribute(attribute.getKey(), attribute.getValue());
-            }
+                case Constants.COOKIE_COMMENT_ATTR:
+                case Constants.COOKIE_DOMAIN_ATTR:
+                case Constants.COOKIE_MAX_AGE_ATTR:
+                case Constants.COOKIE_PATH_ATTR:
+                case Constants.COOKIE_SECURE_ATTR:
+                case Constants.COOKIE_HTTP_ONLY_ATTR:
+                    // Handled above so NO-OP
+                    break;
+                default: {
+                    cookie.setAttribute(attribute.getKey(), attribute.getValue());
+                }
             }
         }
 

==================================================
AsyncContextImpl.java
index ca31e01a38..6dad242a2c 100644
--- a/java/org/apache/catalina/core/AprLifecycleListener.java
+++ b/java/org/apache/catalina/core/AprLifecycleListener.java
@@ -34,16 +34,13 @@ import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * Implementation of <code>LifecycleListener</code> that will init and
- * and destroy APR.
+ * Implementation of <code>LifecycleListener</code> that will init and and destroy APR.
  * <p>
  * This listener must only be nested within {@link Server} elements.
  * <p>
- * <strong>Note</strong>: If you are running Tomcat in an embedded fashion and
- * have more than one Server instance per JVM, this listener <em>must not</em>
- * be added to the {@code Server} instances, but handled outside by the calling
- * code which is bootstrapping the embedded Tomcat instances. Not doing so will
- * lead to JVM crashes.
+ * <strong>Note</strong>: If you are running Tomcat in an embedded fashion and have more than one Server instance per
+ * JVM, this listener <em>must not</em> be added to the {@code Server} instances, but handled outside by the calling
+ * code which is bootstrapping the embedded Tomcat instances. Not doing so will lead to JVM crashes.
  *
  * @since 4.1
  */
@@ -52,9 +49,8 @@ public class AprLifecycleListener implements LifecycleListener {
     private static final Log log = LogFactory.getLog(AprLifecycleListener.class);
 
     /**
-     * Info messages during init() are cached until Lifecycle.BEFORE_INIT_EVENT
-     * so that, in normal (non-error) cases, init() related log messages appear
-     * at the expected point in the lifecycle.
+     * Info messages during init() are cached until Lifecycle.BEFORE_INIT_EVENT so that, in normal (non-error) cases,
+     * init() related log messages appear at the expected point in the lifecycle.
      */
     private static final List<String> initInfoLogMessages = new ArrayList<>(3);
 
@@ -81,21 +77,20 @@ public class AprLifecycleListener implements LifecycleListener {
     private static int tcnPatch = 0;
     private static int tcnVersion = 0;
 
-    protected static String SSLEngine = "on"; //default on
+    protected static String SSLEngine = "on"; // default on
     protected static String FIPSMode = "off"; // default off, valid only when SSLEngine="on"
     protected static String SSLRandomSeed = "builtin";
     protected static boolean sslInitialized = false;
     protected static boolean fipsModeActive = false;
 
     /**
-     * The "FIPS mode" level that we use as the argument to OpenSSL method
-     * <code>FIPS_mode_set()</code> to enable FIPS mode and that we expect as
-     * the return value of <code>FIPS_mode()</code> when FIPS mode is enabled.
+     * The "FIPS mode" level that we use as the argument to OpenSSL method <code>FIPS_mode_set()</code> to enable FIPS
+     * mode and that we expect as the return value of <code>FIPS_mode()</code> when FIPS mode is enabled.
      * <p>
-     * In the future the OpenSSL library might grow support for different
-     * non-zero "FIPS" modes that specify different allowed subsets of ciphers
-     * or whatever, but nowadays only "1" is the supported value.
+     * In the future the OpenSSL library might grow support for different non-zero "FIPS" modes that specify different
+     * allowed subsets of ciphers or whatever, but nowadays only "1" is the supported value.
      * </p>
+     *
      * @see <a href="http://wiki.openssl.org/index.php/FIPS_mode_set%28%29">OpenSSL method FIPS_mode_set()</a>
      * @see <a href="http://wiki.openssl.org/index.php/FIPS_mode%28%29">OpenSSL method FIPS_mode()</a>
      */
@@ -106,7 +101,7 @@ public class AprLifecycleListener implements LifecycleListener {
     protected static final Object lock = new Object();
 
     public static boolean isAprAvailable() {
-        //https://bz.apache.org/bugzilla/show_bug.cgi?id=48613
+        // https://bz.apache.org/bugzilla/show_bug.cgi?id=48613
         if (AprStatus.isInstanceCreated()) {
             synchronized (lock) {
                 init();
@@ -132,8 +127,7 @@ public class AprLifecycleListener implements LifecycleListener {
         if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
             synchronized (lock) {
                 if (!(event.getLifecycle() instanceof Server)) {
-                    log.warn(sm.getString("listener.notServer",
-                            event.getLifecycle().getClass().getSimpleName()));
+                    log.warn(sm.getString("listener.notServer", event.getLifecycle().getClass().getSimpleName()));
                 }
                 init();
                 for (String msg : initInfoLogMessages) {
@@ -175,12 +169,11 @@ public class AprLifecycleListener implements LifecycleListener {
 
     }
 
-    private static void terminateAPR() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException,
-            InvocationTargetException {
+    private static void terminateAPR()
+            throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
         String methodName = "terminate";
-        Method method = Class.forName("org.apache.tomcat.jni.Library")
-            .getMethod(methodName, (Class [])null);
-        method.invoke(null, (Object []) null);
+        Method method = Class.forName("org.apache.tomcat.jni.Library").getMethod(methodName, (Class[]) null);
+        method.invoke(null, (Object[]) null);
         AprStatus.setAprAvailable(false);
         AprStatus.setAprInitialized(false);
         sslInitialized = false; // Well we cleaned the pool in terminate.
@@ -205,12 +198,10 @@ public class AprLifecycleListener implements LifecycleListener {
         } catch (LibraryNotFoundError lnfe) {
             // Library not on path
             if (log.isDebugEnabled()) {
-                log.debug(sm.getString("aprListener.aprInitDebug",
-                        lnfe.getLibraryNames(), System.getProperty("java.library.path"),
-                        lnfe.getMessage()), lnfe);
+                log.debug(sm.getString("aprListener.aprInitDebug", lnfe.getLibraryNames(),
+                        System.getProperty("java.library.path"), lnfe.getMessage()), lnfe);
             }
-            initInfoLogMessages.add(sm.getString("aprListener.aprInit",
-                    System.getProperty("java.library.path")));
+            initInfoLogMessages.add(sm.getString("aprListener.aprInit", System.getProperty("java.library.path")));
             return;
         } catch (Throwable t) {
             // Library present but failed to load
@@ -231,11 +222,8 @@ public class AprLifecycleListener implements LifecycleListener {
             return;
         }
         if (tcnVersion < rqver) {
-            log.error(sm.getString("aprListener.tcnInvalid",
-                    Library.versionString(),
-                    TCN_REQUIRED_MAJOR + "." +
-                    TCN_REQUIRED_MINOR + "." +
-                    TCN_REQUIRED_PATCH));
+            log.error(sm.getString("aprListener.tcnInvalid", Library.versionString(),
+                    TCN_REQUIRED_MAJOR + "." + TCN_REQUIRED_MINOR + "." + TCN_REQUIRED_PATCH));
             try {
                 // Terminate the APR in case the version
                 // is below required.
@@ -247,16 +235,12 @@ public class AprLifecycleListener implements LifecycleListener {
             return;
         }
         if (tcnVersion < rcver) {
-            initInfoLogMessages.add(sm.getString("aprListener.tcnVersion",
-                    Library.versionString(),
-                    TCN_RECOMMENDED_MAJOR + "." +
-                    TCN_RECOMMENDED_MINOR + "." +
-                    TCN_RECOMMENDED_PV));
+            initInfoLogMessages.add(sm.getString("aprListener.tcnVersion", Library.versionString(),
+                    TCN_RECOMMENDED_MAJOR + "." + TCN_RECOMMENDED_MINOR + "." + TCN_RECOMMENDED_PV));
         }
 
-        initInfoLogMessages.add(sm.getString("aprListener.tcnValid",
-                Library.versionString(),
-                Library.aprVersionString()));
+        initInfoLogMessages
+                .add(sm.getString("aprListener.tcnValid", Library.versionString(), Library.aprVersionString()));
 
         AprStatus.setAprAvailable(true);
     }
@@ -284,7 +268,7 @@ public class AprLifecycleListener implements LifecycleListener {
 
 
         methodName = "initialize";
-        paramValues[0] = "on".equalsIgnoreCase(SSLEngine)?null:SSLEngine;
+        paramValues[0] = "on".equalsIgnoreCase(SSLEngine) ? null : SSLEngine;
         method = clazz.getMethod(methodName, paramTypes);
         method.invoke(null, paramValues);
 
@@ -299,7 +283,7 @@ public class AprLifecycleListener implements LifecycleListener {
             final boolean enterFipsMode;
             int fipsModeState = SSL.fipsModeGet();
 
-            if(log.isDebugEnabled()) {
+            if (log.isDebugEnabled()) {
                 log.debug(sm.getString("aprListener.currentFIPSMode", Integer.valueOf(fipsModeState)));
             }
 
@@ -345,13 +329,12 @@ public class AprLifecycleListener implements LifecycleListener {
                         fipsModeActive = true;
                         enterFipsMode = false;
                     } else {
-                        throw new IllegalStateException(sm.getString(
-                                "aprListener.enterAlreadyInFIPSMode", Integer.valueOf(fipsModeState)));
+                        throw new IllegalStateException(
+                                sm.getString("aprListener.enterAlreadyInFIPSMode", Integer.valueOf(fipsModeState)));
                     }
                 }
             } else {
-                throw new IllegalArgumentException(sm.getString(
-                        "aprListener.wrongFIPSMode", FIPSMode));
+                throw new IllegalArgumentException(sm.getString("aprListener.wrongFIPSMode", FIPSMode));
             }
 
             if (enterFipsMode) {
@@ -386,8 +369,7 @@ public class AprLifecycleListener implements LifecycleListener {
         if (!SSLEngine.equals(AprLifecycleListener.SSLEngine)) {
             // Ensure that the SSLEngine is consistent with that used for SSL init
             if (sslInitialized) {
-                throw new IllegalStateException(
-                        sm.getString("aprListener.tooLateForSSLEngine"));
+                throw new IllegalStateException(sm.getString("aprListener.tooLateForSSLEngine"));
             }
 
             AprLifecycleListener.SSLEngine = SSLEngine;
@@ -402,8 +384,7 @@ public class AprLifecycleListener implements LifecycleListener {
         if (!SSLRandomSeed.equals(AprLifecycleListener.SSLRandomSeed)) {
             // Ensure that the random seed is consistent with that used for SSL init
             if (sslInitialized) {
-                throw new IllegalStateException(
-                        sm.getString("aprListener.tooLateForSSLRandomSeed"));
+                throw new IllegalStateException(sm.getString("aprListener.tooLateForSSLRandomSeed"));
             }
 
             AprLifecycleListener.SSLRandomSeed = SSLRandomSeed;
@@ -418,8 +399,7 @@ public class AprLifecycleListener implements LifecycleListener {
         if (!FIPSMode.equals(AprLifecycleListener.FIPSMode)) {
             // Ensure that the FIPS mode is consistent with that used for SSL init
             if (sslInitialized) {
-                throw new IllegalStateException(
-                        sm.getString("aprListener.tooLateForFIPSMode"));
+                throw new IllegalStateException(sm.getString("aprListener.tooLateForFIPSMode"));
             }
 
             AprLifecycleListener.FIPSMode = FIPSMode;

==================================================
AsyncListenerWrapper.java
index 3b0fbd0b57..6f2fa4e8de 100644
--- a/java/org/apache/catalina/core/AsyncContextImpl.java
+++ b/java/org/apache/catalina/core/AsyncContextImpl.java
@@ -55,12 +55,11 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
 
     protected static final StringManager sm = StringManager.getManager(AsyncContextImpl.class);
 
-    /* When a request uses a sequence of multiple start(); dispatch() with
-     * non-container threads it is possible for a previous dispatch() to
-     * interfere with a following start(). This lock prevents that from
-     * happening. It is a dedicated object as user code may lock on the
-     * AsyncContext so if container code also locks on that object deadlocks may
-     * occur.
+    /*
+     * When a request uses a sequence of multiple start(); dispatch() with non-container threads it is possible for a
+     * previous dispatch() to interfere with a following start(). This lock prevents that from happening. It is a
+     * dedicated object as user code may lock on the AsyncContext so if container code also locks on that object
+     * deadlocks may occur.
      */
     private final Object asyncContextLock = new Object();
 
@@ -105,8 +104,7 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
                     listener.fireOnComplete(event);
                 } catch (Throwable t) {
                     ExceptionUtils.handleThrowable(t);
-                    log.warn(sm.getString("asyncContextImpl.onCompleteError",
-                            listener.getClass().getName()), t);
+                    log.warn(sm.getString("asyncContextImpl.onCompleteError", listener.getClass().getName()), t);
                 }
             }
         } finally {
@@ -135,12 +133,10 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
                         listener.fireOnTimeout(event);
                     } catch (Throwable t) {
                         ExceptionUtils.handleThrowable(t);
-                        log.warn(sm.getString("asyncContextImpl.onTimeoutError",
-                                listener.getClass().getName()), t);
+                        log.warn(sm.getString("asyncContextImpl.onTimeoutError", listener.getClass().getName()), t);
                     }
                 }
-                request.getCoyoteRequest().action(
-                        ActionCode.ASYNC_IS_TIMINGOUT, result);
+                request.getCoyoteRequest().action(ActionCode.ASYNC_IS_TIMINGOUT, result);
             } finally {
                 context.unbind(oldCL);
             }
@@ -185,10 +181,9 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
             }
             check();
             if (dispatch != null) {
-                throw new IllegalStateException(
-                        sm.getString("asyncContextImpl.dispatchingStarted"));
+                throw new IllegalStateException(sm.getString("asyncContextImpl.dispatchingStarted"));
             }
-            if (request.getAttribute(ASYNC_REQUEST_URI)==null) {
+            if (request.getAttribute(ASYNC_REQUEST_URI) == null) {
                 request.setAttribute(ASYNC_REQUEST_URI, request.getRequestURI());
                 request.setAttribute(ASYNC_CONTEXT_PATH, request.getContextPath());
                 request.setAttribute(ASYNC_SERVLET_PATH, request.getServletPath());
@@ -197,15 +192,12 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
             }
             final RequestDispatcher requestDispatcher = servletContext.getRequestDispatcher(path);
             if (!(requestDispatcher instanceof AsyncDispatcher)) {
-                throw new UnsupportedOperationException(
-                        sm.getString("asyncContextImpl.noAsyncDispatcher"));
+                throw new UnsupportedOperationException(sm.getString("asyncContextImpl.noAsyncDispatcher"));
             }
-            final AsyncDispatcher applicationDispatcher =
-                    (AsyncDispatcher) requestDispatcher;
+            final AsyncDispatcher applicationDispatcher = (AsyncDispatcher) requestDispatcher;
             final ServletRequest servletRequest = getRequest();
             final ServletResponse servletResponse = getResponse();
-            this.dispatch = new AsyncRunnable(
-                    request, applicationDispatcher, servletRequest, servletResponse);
+            this.dispatch = new AsyncRunnable(request, applicationDispatcher, servletRequest, servletResponse);
             this.request.getCoyoteRequest().action(ActionCode.ASYNC_DISPATCH, null);
             clearServletRequestResponse();
         }
@@ -215,8 +207,7 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
     public ServletRequest getRequest() {
         check();
         if (servletRequest == null) {
-            throw new IllegalStateException(
-                    sm.getString("asyncContextImpl.request.ise"));
+            throw new IllegalStateException(sm.getString("asyncContextImpl.request.ise"));
         }
         return servletRequest;
     }
@@ -225,8 +216,7 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
     public ServletResponse getResponse() {
         check();
         if (servletResponse == null) {
-            throw new IllegalStateException(
-                    sm.getString("asyncContextImpl.response.ise"));
+            throw new IllegalStateException(sm.getString("asyncContextImpl.response.ise"));
         }
         return servletResponse;
     }
@@ -250,8 +240,7 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
     }
 
     @Override
-    public void addListener(AsyncListener listener, ServletRequest servletRequest,
-            ServletResponse servletResponse) {
+    public void addListener(AsyncListener listener, ServletRequest servletRequest, ServletResponse servletResponse) {
         check();
         AsyncListenerWrapper wrapper = new AsyncListenerWrapper();
         wrapper.setListener(listener);
@@ -262,13 +251,11 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
 
     @SuppressWarnings("unchecked")
     @Override
-    public <T extends AsyncListener> T createListener(Class<T> clazz)
-            throws ServletException {
+    public <T extends AsyncListener> T createListener(Class<T> clazz) throws ServletException {
         check();
         T listener = null;
         try {
-             listener = (T) context.getInstanceManager().newInstance(
-                     clazz.getName(), clazz.getClassLoader());
+            listener = (T) context.getInstanceManager().newInstance(clazz.getName(), clazz.getClassLoader());
         } catch (ReflectiveOperationException | NamingException e) {
             ServletException se = new ServletException(e);
             throw se;
@@ -301,17 +288,15 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
 
     public boolean isStarted() {
         AtomicBoolean result = new AtomicBoolean(false);
-        request.getCoyoteRequest().action(
-                ActionCode.ASYNC_IS_STARTED, result);
+        request.getCoyoteRequest().action(ActionCode.ASYNC_IS_STARTED, result);
         return result.get();
     }
 
-    public void setStarted(Context context, ServletRequest request,
-            ServletResponse response, boolean originalRequestResponse) {
+    public void setStarted(Context context, ServletRequest request, ServletResponse response,
+            boolean originalRequestResponse) {
 
         synchronized (asyncContextLock) {
-            this.request.getCoyoteRequest().action(
-                    ActionCode.ASYNC_START, this);
+            this.request.getCoyoteRequest().action(ActionCode.ASYNC_START, this);
 
             this.context = context;
             context.incrementInProgressAsyncCount();
@@ -330,8 +315,7 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
                     listener.fireOnStartAsync(event);
                 } catch (Throwable t) {
                     ExceptionUtils.handleThrowable(t);
-                    log.warn(sm.getString("asyncContextImpl.onStartAsyncError",
-                            listener.getClass().getName()), t);
+                    log.warn(sm.getString("asyncContextImpl.onStartAsyncError", listener.getClass().getName()), t);
                 }
             }
         }
@@ -357,10 +341,10 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
         } catch (RuntimeException x) {
             // doInternalComplete(true);
             if (x.getCause() instanceof ServletException) {
-                throw (ServletException)x.getCause();
+                throw (ServletException) x.getCause();
             }
             if (x.getCause() instanceof IOException) {
-                throw (IOException)x.getCause();
+                throw (IOException) x.getCause();
             }
             throw new ServletException(x);
         }
@@ -378,12 +362,10 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
     public void setTimeout(long timeout) {
         check();
         this.timeout = timeout;
-        request.getCoyoteRequest().action(ActionCode.ASYNC_SETTIMEOUT,
-                Long.valueOf(timeout));
+        request.getCoyoteRequest().action(ActionCode.ASYNC_SETTIMEOUT, Long.valueOf(timeout));
     }
 
 
-
     @Override
     public boolean isAvailable() {
         Context context = this.context;
@@ -395,7 +377,7 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
 
 
     public void setErrorState(Throwable t, boolean fireOnError) {
-        if (t!=null) {
+        if (t != null) {
             request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
         }
         request.getCoyoteRequest().action(ActionCode.ASYNC_ERROR, null);
@@ -404,16 +386,15 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
             if (log.isDebugEnabled()) {
                 log.debug(sm.getString("asyncContextImpl.fireOnError"));
             }
-            AsyncEvent errorEvent = new AsyncEvent(event.getAsyncContext(),
-                    event.getSuppliedRequest(), event.getSuppliedResponse(), t);
+            AsyncEvent errorEvent = new AsyncEvent(event.getAsyncContext(), event.getSuppliedRequest(),
+                    event.getSuppliedResponse(), t);
             List<AsyncListenerWrapper> listenersCopy = new ArrayList<>(listeners);
             for (AsyncListenerWrapper listener : listenersCopy) {
                 try {
                     listener.fireOnError(errorEvent);
                 } catch (Throwable t2) {
                     ExceptionUtils.handleThrowable(t2);
-                    log.warn(sm.getString("asyncContextImpl.onErrorError",
-                            listener.getClass().getName()), t2);
+                    log.warn(sm.getString("asyncContextImpl.onErrorError", listener.getClass().getName()), t2);
                 }
             }
         }
@@ -429,19 +410,16 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
             // threads)
             ServletResponse servletResponse = this.servletResponse;
             if (servletResponse instanceof HttpServletResponse) {
-                ((HttpServletResponse) servletResponse).setStatus(
-                        HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
+                ((HttpServletResponse) servletResponse).setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
             }
 
             Host host = (Host) context.getParent();
             Valve stdHostValve = host.getPipeline().getBasic();
             if (stdHostValve instanceof StandardHostValve) {
-                ((StandardHostValve) stdHostValve).throwable(request,
-                        request.getResponse(), t);
+                ((StandardHostValve) stdHostValve).throwable(request, request.getResponse(), t);
             }
 
-            request.getCoyoteRequest().action(
-                    ActionCode.ASYNC_IS_ERROR, result);
+            request.getCoyoteRequest().action(ActionCode.ASYNC_IS_ERROR, result);
             if (result.get()) {
                 // Still in the error state. The error page did not call
                 // complete() or dispatch(). Complete the async processing.
@@ -506,9 +484,8 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
         }
         String msg = String.format(
                 "Req: %1$8s  CReq: %2$8s  RP: %3$8s  Stage: %4$s  " +
-                "Thread: %5$20s  State: %6$20s  Method: %7$11s  URI: %8$s",
-                rHashCode, crHashCode, rpHashCode, stage,
-                threadName, "N/A", method, uri);
+                        "Thread: %5$20s  State: %6$20s  Method: %7$11s  URI: %8$s",
+                rHashCode, crHashCode, rpHashCode, stage, threadName, "N/A", method, uri);
         if (log.isTraceEnabled()) {
             log.trace(msg, new DebugException());
         } else {
@@ -519,8 +496,7 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
     private void check() {
         if (request == null) {
             // AsyncContext has been recycled and should not be being used
-            throw new IllegalStateException(sm.getString(
-                    "asyncContextImpl.requestEnded"));
+            throw new IllegalStateException(sm.getString("asyncContextImpl.requestEnded"));
         }
     }
 
@@ -534,8 +510,7 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
         private final Context context;
         private final org.apache.coyote.Request coyoteRequest;
 
-        public RunnableWrapper(Runnable wrapped, Context ctxt,
-                org.apache.coyote.Request coyoteRequest) {
+        public RunnableWrapper(Runnable wrapped, Context ctxt, org.apache.coyote.Request coyoteRequest) {
             this.wrapped = wrapped;
             this.context = ctxt;
             this.coyoteRequest = coyoteRequest;
@@ -572,8 +547,8 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
         private final ServletRequest servletRequest;
         private final ServletResponse servletResponse;
 
-        public AsyncRunnable(Request request, AsyncDispatcher applicationDispatcher,
-                ServletRequest servletRequest, ServletResponse servletResponse) {
+        public AsyncRunnable(Request request, AsyncDispatcher applicationDispatcher, ServletRequest servletRequest,
+                ServletResponse servletResponse) {
             this.request = request;
             this.applicationDispatcher = applicationDispatcher;
             this.servletRequest = servletRequest;

==================================================
ContainerBase.java
index 873d4ad2de..41fbf57722 100644
--- a/java/org/apache/catalina/core/AsyncListenerWrapper.java
+++ b/java/org/apache/catalina/core/AsyncListenerWrapper.java
@@ -72,8 +72,7 @@ public class AsyncListenerWrapper {
 
     private AsyncEvent customizeEvent(AsyncEvent event) {
         if (servletRequest != null && servletResponse != null) {
-            return new AsyncEvent(event.getAsyncContext(), servletRequest, servletResponse,
-                    event.getThrowable());
+            return new AsyncEvent(event.getAsyncContext(), servletRequest, servletResponse, event.getThrowable());
         } else {
             return event;
         }

==================================================
DefaultInstanceManager.java
index 67b4354bc3..057a9fd3cc 100644
--- a/java/org/apache/catalina/core/ContainerBase.java
+++ b/java/org/apache/catalina/core/ContainerBase.java
@@ -65,61 +65,56 @@ import org.apache.tomcat.util.threads.InlineExecutorService;
 
 
 /**
- * Abstract implementation of the <b>Container</b> interface, providing common
- * functionality required by nearly every implementation.  Classes extending
- * this base class must may implement a replacement for <code>invoke()</code>.
+ * Abstract implementation of the <b>Container</b> interface, providing common functionality required by nearly every
+ * implementation. Classes extending this base class must may implement a replacement for <code>invoke()</code>.
  * <p>
- * All subclasses of this abstract base class will include support for a
- * Pipeline object that defines the processing to be performed for each request
- * received by the <code>invoke()</code> method of this class, utilizing the
- * "Chain of Responsibility" design pattern.  A subclass should encapsulate its
- * own processing functionality as a <code>Valve</code>, and configure this
- * Valve into the pipeline by calling <code>setBasic()</code>.
+ * All subclasses of this abstract base class will include support for a Pipeline object that defines the processing to
+ * be performed for each request received by the <code>invoke()</code> method of this class, utilizing the "Chain of
+ * Responsibility" design pattern. A subclass should encapsulate its own processing functionality as a
+ * <code>Valve</code>, and configure this Valve into the pipeline by calling <code>setBasic()</code>.
  * <p>
- * This implementation fires property change events, per the JavaBeans design
- * pattern, for changes in singleton properties.  In addition, it fires the
- * following <code>ContainerEvent</code> events to listeners who register
+ * This implementation fires property change events, per the JavaBeans design pattern, for changes in singleton
+ * properties. In addition, it fires the following <code>ContainerEvent</code> events to listeners who register
  * themselves with <code>addContainerListener()</code>:
  * <table border=1>
- *   <caption>ContainerEvents fired by this implementation</caption>
- *   <tr>
- *     <th>Type</th>
- *     <th>Data</th>
- *     <th>Description</th>
- *   </tr>
- *   <tr>
- *     <td><code>addChild</code></td>
- *     <td><code>Container</code></td>
- *     <td>Child container added to this Container.</td>
- *   </tr>
- *   <tr>
- *     <td><code>{@link #getPipeline() pipeline}.addValve</code></td>
- *     <td><code>Valve</code></td>
- *     <td>Valve added to this Container.</td>
- *   </tr>
- *   <tr>
- *     <td><code>removeChild</code></td>
- *     <td><code>Container</code></td>
- *     <td>Child container removed from this Container.</td>
- *   </tr>
- *   <tr>
- *     <td><code>{@link #getPipeline() pipeline}.removeValve</code></td>
- *     <td><code>Valve</code></td>
- *     <td>Valve removed from this Container.</td>
- *   </tr>
- *   <tr>
- *     <td><code>start</code></td>
- *     <td><code>null</code></td>
- *     <td>Container was started.</td>
- *   </tr>
- *   <tr>
- *     <td><code>stop</code></td>
- *     <td><code>null</code></td>
- *     <td>Container was stopped.</td>
- *   </tr>
+ * <caption>ContainerEvents fired by this implementation</caption>
+ * <tr>
+ * <th>Type</th>
+ * <th>Data</th>
+ * <th>Description</th>
+ * </tr>
+ * <tr>
+ * <td><code>addChild</code></td>
+ * <td><code>Container</code></td>
+ * <td>Child container added to this Container.</td>
+ * </tr>
+ * <tr>
+ * <td><code>{@link #getPipeline() pipeline}.addValve</code></td>
+ * <td><code>Valve</code></td>
+ * <td>Valve added to this Container.</td>
+ * </tr>
+ * <tr>
+ * <td><code>removeChild</code></td>
+ * <td><code>Container</code></td>
+ * <td>Child container removed from this Container.</td>
+ * </tr>
+ * <tr>
+ * <td><code>{@link #getPipeline() pipeline}.removeValve</code></td>
+ * <td><code>Valve</code></td>
+ * <td>Valve removed from this Container.</td>
+ * </tr>
+ * <tr>
+ * <td><code>start</code></td>
+ * <td><code>null</code></td>
+ * <td>Container was started.</td>
+ * </tr>
+ * <tr>
+ * <td><code>stop</code></td>
+ * <td><code>null</code></td>
+ * <td>Container was stopped.</td>
+ * </tr>
  * </table>
- * Subclasses that fire additional events should document them in the
- * class comments of the implementation class.
+ * Subclasses that fire additional events should document them in the class comments of the implementation class.
  *
  * @author Craig R. McClanahan
  */
@@ -149,10 +144,9 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
     protected ScheduledFuture<?> monitorFuture;
 
     /**
-     * The container event listeners for this Container. Implemented as a
-     * CopyOnWriteArrayList since listeners may invoke methods to add/remove
-     * themselves or other listeners and with a ReadWriteLock that would trigger
-     * a deadlock.
+     * The container event listeners for this Container. Implemented as a CopyOnWriteArrayList since listeners may
+     * invoke methods to add/remove themselves or other listeners and with a ReadWriteLock that would trigger a
+     * deadlock.
      */
     protected final List<ContainerListener> listeners = new CopyOnWriteArrayList<>();
 
@@ -225,21 +219,19 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
     /**
      * The property change support for this component.
      */
-    protected final PropertyChangeSupport support =
-            new PropertyChangeSupport(this);
+    protected final PropertyChangeSupport support = new PropertyChangeSupport(this);
 
 
     /**
-     * The access log to use for requests normally handled by this container
-     * that have been handled earlier in the processing chain.
+     * The access log to use for requests normally handled by this container that have been handled earlier in the
+     * processing chain.
      */
     protected volatile AccessLog accessLog = null;
     private volatile boolean accessLogScanComplete = false;
 
 
     /**
-     * The number of threads available to process start and stop events for any
-     * children associated with this container.
+     * The number of threads available to process start and stop events for any children associated with this container.
      */
     private int startStopThreads = 1;
     protected ExecutorService startStopExecutor;
@@ -265,13 +257,10 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Get the delay between the invocation of the backgroundProcess method on
-     * this container and its children. Child containers will not be invoked
-     * if their delay value is not negative (which would mean they are using
-     * their own thread). Setting this to a positive value will cause
-     * a thread to be spawn. After waiting the specified amount of time,
-     * the thread will invoke the executePeriodic method on this container
-     * and all its children.
+     * Get the delay between the invocation of the backgroundProcess method on this container and its children. Child
+     * containers will not be invoked if their delay value is not negative (which would mean they are using their own
+     * thread). Setting this to a positive value will cause a thread to be spawn. After waiting the specified amount of
+     * time, the thread will invoke the executePeriodic method on this container and all its children.
      */
     @Override
     public int getBackgroundProcessorDelay() {
@@ -280,11 +269,9 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Set the delay between the invocation of the execute method on this
-     * container and its children.
+     * Set the delay between the invocation of the execute method on this container and its children.
      *
-     * @param delay The delay in seconds between the invocation of
-     *              backgroundProcess methods
+     * @param delay The delay in seconds between the invocation of backgroundProcess methods
      */
     @Override
     public void setBackgroundProcessorDelay(int delay) {
@@ -323,8 +310,7 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
             } else if (name.startsWith("##")) {
                 name = "/" + name;
             }
-            loggerName = "[" + name + "]"
-                + ((loggerName != null) ? ("." + loggerName) : "");
+            loggerName = "[" + name + "]" + ((loggerName != null) ? ("." + loggerName) : "");
             current = current.getParent();
         }
         logName = ContainerBase.class.getName() + "." + loggerName;
@@ -334,9 +320,8 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Return the Cluster with which this Container is associated.  If there is
-     * no associated Cluster, return the Cluster associated with our parent
-     * Container (if any); otherwise return <code>null</code>.
+     * Return the Cluster with which this Container is associated. If there is no associated Cluster, return the Cluster
+     * associated with our parent Container (if any); otherwise return <code>null</code>.
      */
     @Override
     public Cluster getCluster() {
@@ -392,8 +377,7 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
             this.cluster = cluster;
 
             // Stop the old component if necessary
-            if (getState().isAvailable() && (oldCluster != null) &&
-                (oldCluster instanceof Lifecycle)) {
+            if (getState().isAvailable() && (oldCluster != null) && (oldCluster instanceof Lifecycle)) {
                 try {
                     ((Lifecycle) oldCluster).stop();
                 } catch (LifecycleException e) {
@@ -406,8 +390,7 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
                 cluster.setContainer(this);
             }
 
-            if (getState().isAvailable() && (cluster != null) &&
-                (cluster instanceof Lifecycle)) {
+            if (getState().isAvailable() && (cluster != null) && (cluster instanceof Lifecycle)) {
                 try {
                     ((Lifecycle) cluster).start();
                 } catch (LifecycleException e) {
@@ -424,9 +407,8 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Return a name string (suitable for use by humans) that describes this
-     * Container.  Within the set of child containers belonging to a particular
-     * parent, Container names must be unique.
+     * Return a name string (suitable for use by humans) that describes this Container. Within the set of child
+     * containers belonging to a particular parent, Container names must be unique.
      */
     @Override
     public String getName() {
@@ -435,15 +417,13 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Set a name string (suitable for use by humans) that describes this
-     * Container.  Within the set of child containers belonging to a particular
-     * parent, Container names must be unique.
+     * Set a name string (suitable for use by humans) that describes this Container. Within the set of child containers
+     * belonging to a particular parent, Container names must be unique.
      *
      * @param name New name of this container
      *
-     * @exception IllegalStateException if this Container has already been
-     *  added to the children of a parent Container (after which the name
-     *  may not be changed)
+     * @exception IllegalStateException if this Container has already been added to the children of a parent Container
+     *                                      (after which the name may not be changed)
      */
     @Override
     public void setName(String name) {
@@ -457,8 +437,7 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Return if children of this container will be started automatically when
-     * they are added to this container.
+     * Return if children of this container will be started automatically when they are added to this container.
      *
      * @return <code>true</code> if the children will be started
      */
@@ -468,8 +447,7 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Set if children of this container will be started automatically when
-     * they are added to this container.
+     * Set if children of this container will be started automatically when they are added to this container.
      *
      * @param startChildren New value of the startChildren flag
      */
@@ -482,8 +460,8 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Return the Container for which this Container is a child, if there is
-     * one.  If there is no defined parent, return <code>null</code>.
+     * Return the Container for which this Container is a child, if there is one. If there is no defined parent, return
+     * <code>null</code>.
      */
     @Override
     public Container getParent() {
@@ -492,15 +470,12 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Set the parent Container to which this Container is being added as a
-     * child.  This Container may refuse to become attached to the specified
-     * Container by throwing an exception.
+     * Set the parent Container to which this Container is being added as a child. This Container may refuse to become
+     * attached to the specified Container by throwing an exception.
      *
-     * @param container Container to which this Container is being added
-     *  as a child
+     * @param container Container to which this Container is being added as a child
      *
-     * @exception IllegalArgumentException if this Container refuses to become
-     *  attached to the specified Container
+     * @exception IllegalArgumentException if this Container refuses to become attached to the specified Container
      */
     @Override
     public void setParent(Container container) {
@@ -513,9 +488,8 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Return the parent class loader (if any) for this web application.
-     * This call is meaningful only <strong>after</strong> a Loader has
-     * been configured.
+     * Return the parent class loader (if any) for this web application. This call is meaningful only
+     * <strong>after</strong> a Loader has been configured.
      */
     @Override
     public ClassLoader getParentClassLoader() {
@@ -530,11 +504,9 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Set the parent class loader (if any) for this web application.
-     * This call is meaningful only <strong>before</strong> a Loader has
-     * been configured, and the specified value (if non-null) should be
-     * passed as an argument to the class loader constructor.
-     *
+     * Set the parent class loader (if any) for this web application. This call is meaningful only
+     * <strong>before</strong> a Loader has been configured, and the specified value (if non-null) should be passed as
+     * an argument to the class loader constructor.
      *
      * @param parent The new parent class loader
      */
@@ -542,15 +514,13 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
     public void setParentClassLoader(ClassLoader parent) {
         ClassLoader oldParentClassLoader = this.parentClassLoader;
         this.parentClassLoader = parent;
-        support.firePropertyChange("parentClassLoader", oldParentClassLoader,
-                                   this.parentClassLoader);
+        support.firePropertyChange("parentClassLoader", oldParentClassLoader, this.parentClassLoader);
 
     }
 
 
     /**
-     * Return the Pipeline object that manages the Valves associated with
-     * this Container.
+     * Return the Pipeline object that manages the Valves associated with this Container.
      */
     @Override
     public Pipeline getPipeline() {
@@ -559,9 +529,8 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Return the Realm with which this Container is associated.  If there is
-     * no associated Realm, return the Realm associated with our parent
-     * Container (if any); otherwise return <code>null</code>.
+     * Return the Realm with which this Container is associated. If there is no associated Realm, return the Realm
+     * associated with our parent Container (if any); otherwise return <code>null</code>.
      */
     @Override
     public Realm getRealm() {
@@ -611,8 +580,7 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
             this.realm = realm;
 
             // Stop the old component if necessary
-            if (getState().isAvailable() && (oldRealm != null) &&
-                (oldRealm instanceof Lifecycle)) {
+            if (getState().isAvailable() && (oldRealm != null) && (oldRealm instanceof Lifecycle)) {
                 try {
                     ((Lifecycle) oldRealm).stop();
                 } catch (LifecycleException e) {
@@ -624,8 +592,7 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
             if (realm != null) {
                 realm.setContainer(this);
             }
-            if (getState().isAvailable() && (realm != null) &&
-                (realm instanceof Lifecycle)) {
+            if (getState().isAvailable() && (realm != null) && (realm instanceof Lifecycle)) {
                 try {
                     ((Lifecycle) realm).start();
                 } catch (LifecycleException e) {
@@ -646,21 +613,18 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Add a new child Container to those associated with this Container,
-     * if supported.  Prior to adding this Container to the set of children,
-     * the child's <code>setParent()</code> method must be called, with this
-     * Container as an argument.  This method may thrown an
-     * <code>IllegalArgumentException</code> if this Container chooses not
-     * to be attached to the specified Container, in which case it is not added
+     * Add a new child Container to those associated with this Container, if supported. Prior to adding this Container
+     * to the set of children, the child's <code>setParent()</code> method must be called, with this Container as an
+     * argument. This method may thrown an <code>IllegalArgumentException</code> if this Container chooses not to be
+     * attached to the specified Container, in which case it is not added
      *
      * @param child New child Container to be added
      *
-     * @exception IllegalArgumentException if this exception is thrown by
-     *  the <code>setParent()</code> method of the child Container
-     * @exception IllegalArgumentException if the new child does not have
-     *  a name unique from that of existing children of this Container
-     * @exception IllegalStateException if this Container does not support
-     *  child Containers
+     * @exception IllegalArgumentException if this exception is thrown by the <code>setParent()</code> method of the
+     *                                         child Container
+     * @exception IllegalArgumentException if the new child does not have a name unique from that of existing children
+     *                                         of this Container
+     * @exception IllegalStateException    if this Container does not support child Containers
      */
     @Override
     public void addChild(Container child) {
@@ -668,12 +632,11 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
             log.debug("Add child " + child + " " + this);
         }
 
-        synchronized(children) {
+        synchronized (children) {
             if (children.get(child.getName()) != null) {
-                throw new IllegalArgumentException(
-                        sm.getString("containerBase.child.notUnique", child.getName()));
+                throw new IllegalArgumentException(sm.getString("containerBase.child.notUnique", child.getName()));
             }
-            child.setParent(this);  // May throw IAE
+            child.setParent(this); // May throw IAE
             children.put(child.getName(), child);
         }
 
@@ -683,9 +646,7 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
         // Don't do this inside sync block - start can be a slow process and
         // locking the children object can cause problems elsewhere
         try {
-            if ((getState().isAvailable() ||
-                    LifecycleState.STARTING_PREP.equals(getState())) &&
-                    startChildren) {
+            if ((getState().isAvailable() || LifecycleState.STARTING_PREP.equals(getState())) && startChildren) {
                 child.start();
             }
         } catch (LifecycleException e) {
@@ -717,8 +678,8 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Return the child Container, associated with this Container, with
-     * the specified name (if any); otherwise, return <code>null</code>
+     * Return the child Container, associated with this Container, with the specified name (if any); otherwise, return
+     * <code>null</code>
      *
      * @param name Name of the child Container to be retrieved
      */
@@ -734,8 +695,8 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Return the set of children Containers associated with this Container.
-     * If this Container has no children, a zero-length array is returned.
+     * Return the set of children Containers associated with this Container. If this Container has no children, a
+     * zero-length array is returned.
      */
     @Override
     public Container[] findChildren() {
@@ -746,9 +707,8 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Return the set of container listeners associated with this Container.
-     * If this Container has no registered container listeners, a zero-length
-     * array is returned.
+     * Return the set of container listeners associated with this Container. If this Container has no registered
+     * container listeners, a zero-length array is returned.
      */
     @Override
     public ContainerListener[] findContainerListeners() {
@@ -757,8 +717,7 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Remove an existing child Container from association with this parent
-     * Container.
+     * Remove an existing child Container from association with this parent Container.
      *
      * @param child Existing child Container to be removed
      */
@@ -794,7 +753,7 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
             fireContainerEvent(REMOVE_CHILD_EVENT, child);
         }
 
-        synchronized(children) {
+        synchronized (children) {
             if (children.get(child.getName()) == null) {
                 return;
             }
@@ -851,11 +810,11 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Start this component and implement the requirements
-     * of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
+     * Start this component and implement the requirements of
+     * {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
+     * @exception LifecycleException if this component detects a fatal error that prevents this component from being
+     *                                   used
      */
     @Override
     protected synchronized void startInternal() throws LifecycleException {
@@ -907,19 +866,18 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
         // Start our thread
         if (backgroundProcessorDelay > 0) {
-            monitorFuture = Container.getService(ContainerBase.this).getServer()
-                    .getUtilityExecutor().scheduleWithFixedDelay(
-                            new ContainerBackgroundProcessorMonitor(), 0, 60, TimeUnit.SECONDS);
+            monitorFuture = Container.getService(ContainerBase.this).getServer().getUtilityExecutor()
+                    .scheduleWithFixedDelay(new ContainerBackgroundProcessorMonitor(), 0, 60, TimeUnit.SECONDS);
         }
     }
 
 
     /**
-     * Stop this component and implement the requirements
-     * of {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
+     * Stop this component and implement the requirements of
+     * {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
+     * @exception LifecycleException if this component detects a fatal error that prevents this component from being
+     *                                   used
      */
     @Override
     protected synchronized void stopInternal() throws LifecycleException {
@@ -934,8 +892,7 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
         setState(LifecycleState.STOPPING);
 
         // Stop the Valves in our pipeline (including the basic), if any
-        if (pipeline instanceof Lifecycle &&
-                ((Lifecycle) pipeline).getState().isAvailable()) {
+        if (pipeline instanceof Lifecycle && ((Lifecycle) pipeline).getState().isAvailable()) {
             ((Lifecycle) pipeline).stop();
         }
 
@@ -956,8 +913,7 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
             }
         }
         if (fail) {
-            throw new LifecycleException(
-                    sm.getString("containerBase.threadedStopFailed"));
+            throw new LifecycleException(sm.getString("containerBase.threadedStopFailed"));
         }
 
         // Stop our subordinate components, if any
@@ -1008,13 +964,11 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Check this container for an access log and if none is found, look to the
-     * parent. If there is no parent and still none is found, use the NoOp
-     * access log.
+     * Check this container for an access log and if none is found, look to the parent. If there is no parent and still
+     * none is found, use the NoOp access log.
      */
     @Override
-    public void logAccess(Request request, Response response, long time,
-            boolean useDefault) {
+    public void logAccess(Request request, Response response, long time, boolean useDefault) {
 
         boolean logged = false;
 
@@ -1059,21 +1013,16 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Convenience method, intended for use by the digester to simplify the
-     * process of adding Valves to containers. See
-     * {@link Pipeline#addValve(Valve)} for full details. Components other than
-     * the digester should use {@link #getPipeline()}.{@link #addValve(Valve)} in case a
-     * future implementation provides an alternative method for the digester to
-     * use.
+     * Convenience method, intended for use by the digester to simplify the process of adding Valves to containers. See
+     * {@link Pipeline#addValve(Valve)} for full details. Components other than the digester should use
+     * {@link #getPipeline()}.{@link #addValve(Valve)} in case a future implementation provides an alternative method
+     * for the digester to use.
      *
      * @param valve Valve to be added
      *
-     * @exception IllegalArgumentException if this Container refused to
-     *  accept the specified Valve
-     * @exception IllegalArgumentException if the specified Valve refuses to be
-     *  associated with this Container
-     * @exception IllegalStateException if the specified Valve is already
-     *  associated with a different Container
+     * @exception IllegalArgumentException if this Container refused to accept the specified Valve
+     * @exception IllegalArgumentException if the specified Valve refuses to be associated with this Container
+     * @exception IllegalStateException    if the specified Valve is already associated with a different Container
      */
     public synchronized void addValve(Valve valve) {
 
@@ -1082,9 +1031,8 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
 
 
     /**
-     * Execute a periodic task, such as reloading, etc. This method will be
-     * invoked inside the classloading context of this container. Unexpected
-     * throwables will be caught and logged.
+     * Execute a periodic task, such as reloading, etc. This method will be invoked inside the classloading context of
+     * this container. Unexpected throwables will be caught and logged.
      */
     @Override
     public void backgroundProcess() {
@@ -1098,8 +1046,7 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
             try {
                 cluster.backgroundProcess();
             } catch (Exception e) {
-                log.warn(sm.getString("containerBase.backgroundProcess.cluster",
-                        cluster), e);
+                log.warn(sm.getString("containerBase.backgroundProcess.cluster", cluster), e);
             }
         }
         Realm realm = getRealmInternal();
@@ -1148,9 +1095,8 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
     // ------------------------------------------------------ Protected Methods
 
     /**
-     * Notify all container event listeners that a particular event has
-     * occurred for this Container.  The default implementation performs
-     * this notification synchronously using the calling thread.
+     * Notify all container event listeners that a particular event has occurred for this Container. The default
+     * implementation performs this notification synchronously using the calling thread.
      *
      * @param type Event type
      * @param data Event data
@@ -1170,7 +1116,7 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
     }
 
 
-    // -------------------- JMX and Registration  --------------------
+    // -------------------- JMX and Registration --------------------
 
     @Override
     protected String getDomainInternal() {
@@ -1199,7 +1145,7 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
             } else if (c instanceof Context) {
                 keyProperties.insert(0, ",context=");
                 ContextName cn = new ContextName(c.getName(), false);
-                keyProperties.insert(9,cn.getDisplayName());
+                keyProperties.insert(9, cn.getDisplayName());
             } else if (c instanceof Host) {
                 keyProperties.insert(0, ",host=");
                 keyProperties.insert(6, c.getName());
@@ -1235,13 +1181,12 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
     // -------------------- Background Thread --------------------
 
     /**
-     * Start the background thread that will periodically check for
-     * session timeouts.
+     * Start the background thread that will periodically check for session timeouts.
      */
     protected void threadStart() {
-        if (backgroundProcessorDelay > 0
-                && (getState().isAvailable() || LifecycleState.STARTING_PREP.equals(getState()))
-                && (backgroundProcessorFuture == null || backgroundProcessorFuture.isDone())) {
+        if (backgroundProcessorDelay > 0 &&
+                (getState().isAvailable() || LifecycleState.STARTING_PREP.equals(getState())) &&
+                (backgroundProcessorFuture == null || backgroundProcessorFuture.isDone())) {
             if (backgroundProcessorFuture != null && backgroundProcessorFuture.isDone()) {
                 // There was an error executing the scheduled task, get it and log it
                 try {
@@ -1251,16 +1196,14 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
                 }
             }
             backgroundProcessorFuture = Container.getService(this).getServer().getUtilityExecutor()
-                    .scheduleWithFixedDelay(new ContainerBackgroundProcessor(),
-                            backgroundProcessorDelay, backgroundProcessorDelay,
-                            TimeUnit.SECONDS);
+                    .scheduleWithFixedDelay(new ContainerBackgroundProcessor(), backgroundProcessorDelay,
+                            backgroundProcessorDelay, TimeUnit.SECONDS);
         }
     }
 
 
     /**
-     * Stop the background thread that is periodically checking for
-     * session timeouts.
+     * Stop the background thread that is periodically checking for session timeouts.
      */
     protected void threadStop() {
         if (backgroundProcessorFuture != null) {
@@ -1297,8 +1240,8 @@ public abstract class ContainerBase extends LifecycleMBeanBase implements Contai
     }
 
     /**
-     * Private runnable class to invoke the backgroundProcess method
-     * of this container and its children after a fixed delay.
+     * Private runnable class to invoke the backgroundProcess method of this container and its children after a fixed
+     * delay.
      */
     protected class ContainerBackgroundProcessor implements Runnable {
 

==================================================
FrameworkListener.java
index 859043ae9c..b2676c7480 100644
--- a/java/org/apache/catalina/core/DefaultInstanceManager.java
+++ b/java/org/apache/catalina/core/DefaultInstanceManager.java
@@ -53,8 +53,7 @@ import org.apache.tomcat.util.res.StringManager;
 public class DefaultInstanceManager implements InstanceManager {
 
     // Used when there are no annotations in a class
-    private static final AnnotationCacheEntry[] ANNOTATIONS_EMPTY
-        = new AnnotationCacheEntry[0];
+    private static final AnnotationCacheEntry[] ANNOTATIONS_EMPTY = new AnnotationCacheEntry[0];
 
     /**
      * The string manager for this package.
@@ -100,15 +99,12 @@ public class DefaultInstanceManager implements InstanceManager {
     protected final boolean ignoreAnnotations;
     protected final boolean metadataComplete;
     private final Set<String> restrictedClasses;
-    private final ManagedConcurrentWeakHashMap<Class<?>, AnnotationCacheEntry[]> annotationCache =
-            new ManagedConcurrentWeakHashMap<>();
+    private final ManagedConcurrentWeakHashMap<Class<?>, AnnotationCacheEntry[]> annotationCache = new ManagedConcurrentWeakHashMap<>();
     private final Map<String, String> postConstructMethods;
     private final Map<String, String> preDestroyMethods;
 
-    public DefaultInstanceManager(Context context,
-            Map<String, Map<String, String>> injectionMap,
-            org.apache.catalina.Context catalinaContext,
-            ClassLoader containerClassLoader) {
+    public DefaultInstanceManager(Context context, Map<String, Map<String, String>> injectionMap,
+            org.apache.catalina.Context catalinaContext, ClassLoader containerClassLoader) {
         classLoader = catalinaContext.getLoader().getClassLoader();
         privileged = catalinaContext.getPrivileged();
         this.containerClassLoader = containerClassLoader;
@@ -116,14 +112,11 @@ public class DefaultInstanceManager implements InstanceManager {
         metadataComplete = catalinaContext.getMetadataComplete();
         Log log = catalinaContext.getLogger();
         Set<String> classNames = new HashSet<>();
-        loadProperties(classNames,
-                "org/apache/catalina/core/RestrictedServlets.properties",
+        loadProperties(classNames, "org/apache/catalina/core/RestrictedServlets.properties",
                 "defaultInstanceManager.restrictedServletsResource", log);
-        loadProperties(classNames,
-                "org/apache/catalina/core/RestrictedListeners.properties",
+        loadProperties(classNames, "org/apache/catalina/core/RestrictedListeners.properties",
                 "defaultInstanceManager.restrictedListenersResource", log);
-        loadProperties(classNames,
-                "org/apache/catalina/core/RestrictedFilters.properties",
+        loadProperties(classNames, "org/apache/catalina/core/RestrictedFilters.properties",
                 "defaultInstanceManager.restrictedFiltersResource", log);
         restrictedClasses = Collections.unmodifiableSet(classNames);
         this.context = context;
@@ -133,15 +126,14 @@ public class DefaultInstanceManager implements InstanceManager {
     }
 
     @Override
-    public Object newInstance(Class<?> clazz) throws IllegalAccessException,
-            InvocationTargetException, NamingException, InstantiationException,
-            IllegalArgumentException, NoSuchMethodException, SecurityException {
+    public Object newInstance(Class<?> clazz) throws IllegalAccessException, InvocationTargetException, NamingException,
+            InstantiationException, IllegalArgumentException, NoSuchMethodException, SecurityException {
         return newInstance(clazz.getConstructor().newInstance(), clazz);
     }
 
     @Override
-    public Object newInstance(String className) throws IllegalAccessException,
-            InvocationTargetException, NamingException, InstantiationException,
+    public Object newInstance(String className)
+            throws IllegalAccessException, InvocationTargetException, NamingException, InstantiationException,
             ClassNotFoundException, IllegalArgumentException, NoSuchMethodException, SecurityException {
         Class<?> clazz = loadClassMaybePrivileged(className, classLoader);
         return newInstance(clazz.getConstructor().newInstance(), clazz);
@@ -149,16 +141,14 @@ public class DefaultInstanceManager implements InstanceManager {
 
     @Override
     public Object newInstance(final String className, final ClassLoader classLoader)
-            throws IllegalAccessException, NamingException, InvocationTargetException,
-            InstantiationException, ClassNotFoundException, IllegalArgumentException,
-            NoSuchMethodException, SecurityException {
+            throws IllegalAccessException, NamingException, InvocationTargetException, InstantiationException,
+            ClassNotFoundException, IllegalArgumentException, NoSuchMethodException, SecurityException {
         Class<?> clazz = classLoader.loadClass(className);
         return newInstance(clazz.getConstructor().newInstance(), clazz);
     }
 
     @Override
-    public void newInstance(Object o)
-            throws IllegalAccessException, InvocationTargetException, NamingException {
+    public void newInstance(Object o) throws IllegalAccessException, InvocationTargetException, NamingException {
         newInstance(o, o.getClass());
     }
 
@@ -187,22 +177,20 @@ public class DefaultInstanceManager implements InstanceManager {
     }
 
     @Override
-    public void destroyInstance(Object instance) throws IllegalAccessException,
-            InvocationTargetException {
+    public void destroyInstance(Object instance) throws IllegalAccessException, InvocationTargetException {
         if (!ignoreAnnotations) {
             preDestroy(instance, instance.getClass());
         }
     }
 
     /**
-     * Call postConstruct method on the specified instance recursively from
-     * deepest superclass to actual class.
+     * Call postConstruct method on the specified instance recursively from deepest superclass to actual class.
      *
      * @param instance object to call postconstruct methods on
      * @param clazz    (super) class to examine for postConstruct annotation.
-     * @throws IllegalAccessException if postConstruct method is inaccessible.
-     * @throws java.lang.reflect.InvocationTargetException
-     *                                if call fails
+     *
+     * @throws IllegalAccessException                      if postConstruct method is inaccessible.
+     * @throws java.lang.reflect.InvocationTargetException if call fails
      */
     protected void postConstruct(Object instance, final Class<?> clazz)
             throws IllegalAccessException, InvocationTargetException {
@@ -233,14 +221,13 @@ public class DefaultInstanceManager implements InstanceManager {
 
 
     /**
-     * Call preDestroy method on the specified instance recursively from deepest
-     * superclass to actual class.
+     * Call preDestroy method on the specified instance recursively from deepest superclass to actual class.
      *
      * @param instance object to call preDestroy methods on
      * @param clazz    (super) class to examine for preDestroy annotation.
-     * @throws IllegalAccessException if preDestroy method is inaccessible.
-     * @throws java.lang.reflect.InvocationTargetException
-     *                                if call fails
+     *
+     * @throws IllegalAccessException                      if preDestroy method is inaccessible.
+     * @throws java.lang.reflect.InvocationTargetException if call fails
      */
     protected void preDestroy(Object instance, final Class<?> clazz)
             throws IllegalAccessException, InvocationTargetException {
@@ -276,20 +263,17 @@ public class DefaultInstanceManager implements InstanceManager {
 
 
     /**
-     * Make sure that the annotations cache has been populated for the provided
-     * class.
+     * Make sure that the annotations cache has been populated for the provided class.
+     *
+     * @param clazz      clazz to populate annotations for
+     * @param injections map of injections for this class from xml deployment descriptor
      *
-     * @param clazz         clazz to populate annotations for
-     * @param injections    map of injections for this class from xml deployment
-     *                      descriptor
-     * @throws IllegalAccessException       if injection target is inaccessible
-     * @throws javax.naming.NamingException if value cannot be looked up in jndi
-     * @throws java.lang.reflect.InvocationTargetException
-     *                                      if injection fails
+     * @throws IllegalAccessException                      if injection target is inaccessible
+     * @throws javax.naming.NamingException                if value cannot be looked up in jndi
+     * @throws java.lang.reflect.InvocationTargetException if injection fails
      */
-    protected void populateAnnotationsCache(Class<?> clazz,
-            Map<String, String> injections) throws IllegalAccessException,
-            InvocationTargetException, NamingException {
+    protected void populateAnnotationsCache(Class<?> clazz, Map<String, String> injections)
+            throws IllegalAccessException, InvocationTargetException, NamingException {
 
         List<AnnotationCacheEntry> annotations = null;
         Set<String> injectionsMatchedToSetter = new HashSet<>();
@@ -316,11 +300,8 @@ public class DefaultInstanceManager implements InstanceManager {
                             String fieldName = Introspection.getPropertyName(method);
                             injectionsMatchedToSetter.add(fieldName);
                             if (injections.containsKey(fieldName)) {
-                                annotations.add(new AnnotationCacheEntry(
-                                        method.getName(),
-                                        method.getParameterTypes(),
-                                        injections.get(fieldName),
-                                        AnnotationCacheEntryType.SETTER));
+                                annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(),
+                                        injections.get(fieldName), AnnotationCacheEntryType.SETTER));
                                 continue;
                             }
                         }
@@ -331,37 +312,24 @@ public class DefaultInstanceManager implements InstanceManager {
                             Annotation persistenceContextAnnotation;
                             Annotation persistenceUnitAnnotation;
                             if ((resourceAnnotation = method.getAnnotation(Resource.class)) != null) {
-                                annotations.add(new AnnotationCacheEntry(
-                                        method.getName(),
-                                        method.getParameterTypes(),
-                                        resourceAnnotation.name(),
-                                        AnnotationCacheEntryType.SETTER));
-                            } else if (EJB_PRESENT &&
-                                    (ejbAnnotation = method.getAnnotation(EJB.class)) != null) {
-                                annotations.add(new AnnotationCacheEntry(
-                                        method.getName(),
-                                        method.getParameterTypes(),
-                                        ((EJB) ejbAnnotation).name(),
-                                        AnnotationCacheEntryType.SETTER));
-                            } else if (WS_PRESENT && (webServiceRefAnnotation =
-                                    method.getAnnotation(WebServiceRef.class)) != null) {
-                                annotations.add(new AnnotationCacheEntry(
-                                        method.getName(),
-                                        method.getParameterTypes(),
+                                annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(),
+                                        resourceAnnotation.name(), AnnotationCacheEntryType.SETTER));
+                            } else if (EJB_PRESENT && (ejbAnnotation = method.getAnnotation(EJB.class)) != null) {
+                                annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(),
+                                        ((EJB) ejbAnnotation).name(), AnnotationCacheEntryType.SETTER));
+                            } else if (WS_PRESENT &&
+                                    (webServiceRefAnnotation = method.getAnnotation(WebServiceRef.class)) != null) {
+                                annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(),
                                         ((WebServiceRef) webServiceRefAnnotation).name(),
                                         AnnotationCacheEntryType.SETTER));
-                            } else if (JPA_PRESENT && (persistenceContextAnnotation =
-                                    method.getAnnotation(PersistenceContext.class)) != null) {
-                                annotations.add(new AnnotationCacheEntry(
-                                        method.getName(),
-                                        method.getParameterTypes(),
+                            } else if (JPA_PRESENT && (persistenceContextAnnotation = method
+                                    .getAnnotation(PersistenceContext.class)) != null) {
+                                annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(),
                                         ((PersistenceContext) persistenceContextAnnotation).name(),
                                         AnnotationCacheEntryType.SETTER));
-                            } else if (JPA_PRESENT && (persistenceUnitAnnotation =
-                                    method.getAnnotation(PersistenceUnit.class)) != null) {
-                                annotations.add(new AnnotationCacheEntry(
-                                        method.getName(),
-                                        method.getParameterTypes(),
+                            } else if (JPA_PRESENT &&
+                                    (persistenceUnitAnnotation = method.getAnnotation(PersistenceUnit.class)) != null) {
+                                annotations.add(new AnnotationCacheEntry(method.getName(), method.getParameterTypes(),
                                         ((PersistenceUnit) persistenceUnitAnnotation).name(),
                                         AnnotationCacheEntryType.SETTER));
                             }
@@ -374,22 +342,18 @@ public class DefaultInstanceManager implements InstanceManager {
                 }
 
                 if (postConstruct != null) {
-                    annotations.add(new AnnotationCacheEntry(
-                            postConstruct.getName(),
-                            postConstruct.getParameterTypes(), null,
-                            AnnotationCacheEntryType.POST_CONSTRUCT));
+                    annotations.add(new AnnotationCacheEntry(postConstruct.getName(), postConstruct.getParameterTypes(),
+                            null, AnnotationCacheEntryType.POST_CONSTRUCT));
                 } else if (postConstructFromXml != null) {
                     throw new IllegalArgumentException(sm.getString("defaultInstanceManager.postConstructNotFound",
-                        postConstructFromXml, clazz.getName()));
+                            postConstructFromXml, clazz.getName()));
                 }
                 if (preDestroy != null) {
-                    annotations.add(new AnnotationCacheEntry(
-                            preDestroy.getName(),
-                            preDestroy.getParameterTypes(), null,
+                    annotations.add(new AnnotationCacheEntry(preDestroy.getName(), preDestroy.getParameterTypes(), null,
                             AnnotationCacheEntryType.PRE_DESTROY));
                 } else if (preDestroyFromXml != null) {
                     throw new IllegalArgumentException(sm.getString("defaultInstanceManager.preDestroyNotFound",
-                        preDestroyFromXml, clazz.getName()));
+                            preDestroyFromXml, clazz.getName()));
                 }
 
                 if (context != null) {
@@ -403,32 +367,29 @@ public class DefaultInstanceManager implements InstanceManager {
                         Annotation persistenceContextAnnotation;
                         Annotation persistenceUnitAnnotation;
                         String fieldName = field.getName();
-                        if (injections != null && injections.containsKey(fieldName) && !injectionsMatchedToSetter.contains(fieldName)) {
-                            annotations.add(new AnnotationCacheEntry(
-                                    fieldName, null,
-                                    injections.get(fieldName),
+                        if (injections != null && injections.containsKey(fieldName) &&
+                                !injectionsMatchedToSetter.contains(fieldName)) {
+                            annotations.add(new AnnotationCacheEntry(fieldName, null, injections.get(fieldName),
                                     AnnotationCacheEntryType.FIELD));
                         } else if (!metadataComplete) {
-                            if ((resourceAnnotation =
-                                    field.getAnnotation(Resource.class)) != null) {
-                                annotations.add(new AnnotationCacheEntry(fieldName, null,
-                                        resourceAnnotation.name(), AnnotationCacheEntryType.FIELD));
-                            } else if (EJB_PRESENT &&
-                                    (ejbAnnotation = field.getAnnotation(EJB.class)) != null) {
-                                annotations.add(new AnnotationCacheEntry(fieldName, null,
-                                        ((EJB) ejbAnnotation).name(), AnnotationCacheEntryType.FIELD));
-                            } else if (WS_PRESENT && (webServiceRefAnnotation =
-                                    field.getAnnotation(WebServiceRef.class)) != null) {
+                            if ((resourceAnnotation = field.getAnnotation(Resource.class)) != null) {
+                                annotations.add(new AnnotationCacheEntry(fieldName, null, resourceAnnotation.name(),
+                                        AnnotationCacheEntryType.FIELD));
+                            } else if (EJB_PRESENT && (ejbAnnotation = field.getAnnotation(EJB.class)) != null) {
+                                annotations.add(new AnnotationCacheEntry(fieldName, null, ((EJB) ejbAnnotation).name(),
+                                        AnnotationCacheEntryType.FIELD));
+                            } else if (WS_PRESENT &&
+                                    (webServiceRefAnnotation = field.getAnnotation(WebServiceRef.class)) != null) {
                                 annotations.add(new AnnotationCacheEntry(fieldName, null,
                                         ((WebServiceRef) webServiceRefAnnotation).name(),
                                         AnnotationCacheEntryType.FIELD));
-                            } else if (JPA_PRESENT && (persistenceContextAnnotation =
-                                    field.getAnnotation(PersistenceContext.class)) != null) {
+                            } else if (JPA_PRESENT && (persistenceContextAnnotation = field
+                                    .getAnnotation(PersistenceContext.class)) != null) {
                                 annotations.add(new AnnotationCacheEntry(fieldName, null,
                                         ((PersistenceContext) persistenceContextAnnotation).name(),
                                         AnnotationCacheEntryType.FIELD));
-                            } else if (JPA_PRESENT && (persistenceUnitAnnotation =
-                                    field.getAnnotation(PersistenceUnit.class)) != null) {
+                            } else if (JPA_PRESENT &&
+                                    (persistenceUnitAnnotation = field.getAnnotation(PersistenceUnit.class)) != null) {
                                 annotations.add(new AnnotationCacheEntry(fieldName, null,
                                         ((PersistenceUnit) persistenceUnitAnnotation).name(),
                                         AnnotationCacheEntryType.FIELD));
@@ -457,10 +418,10 @@ public class DefaultInstanceManager implements InstanceManager {
      *
      * @param instance   instance to inject into
      * @param injections map of injections for this class from xml deployment descriptor
-     * @throws IllegalAccessException       if injection target is inaccessible
-     * @throws javax.naming.NamingException if value cannot be looked up in jndi
-     * @throws java.lang.reflect.InvocationTargetException
-     *                                      if injection fails
+     *
+     * @throws IllegalAccessException                      if injection target is inaccessible
+     * @throws javax.naming.NamingException                if value cannot be looked up in jndi
+     * @throws java.lang.reflect.InvocationTargetException if injection fails
      */
     protected void processAnnotations(Object instance, Map<String, String> injections)
             throws IllegalAccessException, InvocationTargetException, NamingException {
@@ -476,13 +437,9 @@ public class DefaultInstanceManager implements InstanceManager {
             AnnotationCacheEntry[] annotations = annotationCache.get(clazz);
             for (AnnotationCacheEntry entry : annotations) {
                 if (entry.getType() == AnnotationCacheEntryType.SETTER) {
-                    lookupMethodResource(context, instance,
-                            getMethod(clazz, entry),
-                            entry.getName(), clazz);
+                    lookupMethodResource(context, instance, getMethod(clazz, entry), entry.getName(), clazz);
                 } else if (entry.getType() == AnnotationCacheEntryType.FIELD) {
-                    lookupFieldResource(context, instance,
-                            getField(clazz, entry),
-                            entry.getName(), clazz);
+                    lookupFieldResource(context, instance, getField(clazz, entry), entry.getName(), clazz);
                 }
             }
             clazz = clazz.getSuperclass();
@@ -500,15 +457,14 @@ public class DefaultInstanceManager implements InstanceManager {
     }
 
 
-    protected Class<?> loadClassMaybePrivileged(final String className,
-            final ClassLoader classLoader) throws ClassNotFoundException {
+    protected Class<?> loadClassMaybePrivileged(final String className, final ClassLoader classLoader)
+            throws ClassNotFoundException {
         Class<?> clazz = loadClass(className, classLoader);
         checkAccess(clazz);
         return clazz;
     }
 
-    protected Class<?> loadClass(String className, ClassLoader classLoader)
-            throws ClassNotFoundException {
+    protected Class<?> loadClass(String className, ClassLoader classLoader) throws ClassNotFoundException {
         if (className.startsWith("org.apache.catalina")) {
             return containerClassLoader.loadClass(className);
         }
@@ -528,13 +484,11 @@ public class DefaultInstanceManager implements InstanceManager {
             return;
         }
         if (ContainerServlet.class.isAssignableFrom(clazz)) {
-            throw new SecurityException(sm.getString(
-                    "defaultInstanceManager.restrictedContainerServlet", clazz));
+            throw new SecurityException(sm.getString("defaultInstanceManager.restrictedContainerServlet", clazz));
         }
         while (clazz != null) {
             if (restrictedClasses.contains(clazz.getName())) {
-                throw new SecurityException(sm.getString(
-                        "defaultInstanceManager.restrictedClass", clazz));
+                throw new SecurityException(sm.getString("defaultInstanceManager.restrictedClass", clazz));
             }
             clazz = clazz.getSuperclass();
         }
@@ -548,12 +502,12 @@ public class DefaultInstanceManager implements InstanceManager {
      * @param field    field target for injection
      * @param name     jndi name value is bound under
      * @param clazz    class annotation is defined in
+     *
      * @throws IllegalAccessException       if field is inaccessible
      * @throws javax.naming.NamingException if value is not accessible in naming context
      */
-    protected static void lookupFieldResource(Context context,
-            Object instance, Field field, String name, Class<?> clazz)
-            throws NamingException, IllegalAccessException {
+    protected static void lookupFieldResource(Context context, Object instance, Field field, String name,
+            Class<?> clazz) throws NamingException, IllegalAccessException {
 
         Object lookedupResource;
 
@@ -562,8 +516,7 @@ public class DefaultInstanceManager implements InstanceManager {
         if ((normalizedName != null) && (normalizedName.length() > 0)) {
             lookedupResource = context.lookup(normalizedName);
         } else {
-            lookedupResource =
-                context.lookup(clazz.getName() + "/" + field.getName());
+            lookedupResource = context.lookup(clazz.getName() + "/" + field.getName());
         }
 
         // This will always be a new Field instance
@@ -581,18 +534,16 @@ public class DefaultInstanceManager implements InstanceManager {
      * @param method   field target for injection
      * @param name     jndi name value is bound under
      * @param clazz    class annotation is defined in
-     * @throws IllegalAccessException       if method is inaccessible
-     * @throws javax.naming.NamingException if value is not accessible in naming context
-     * @throws java.lang.reflect.InvocationTargetException
-     *                                      if setter call fails
+     *
+     * @throws IllegalAccessException                      if method is inaccessible
+     * @throws javax.naming.NamingException                if value is not accessible in naming context
+     * @throws java.lang.reflect.InvocationTargetException if setter call fails
      */
-    protected static void lookupMethodResource(Context context,
-            Object instance, Method method, String name, Class<?> clazz)
-            throws NamingException, IllegalAccessException, InvocationTargetException {
+    protected static void lookupMethodResource(Context context, Object instance, Method method, String name,
+            Class<?> clazz) throws NamingException, IllegalAccessException, InvocationTargetException {
 
         if (!Introspection.isValidSetter(method)) {
-            throw new IllegalArgumentException(
-                    sm.getString("defaultInstanceManager.invalidInjection"));
+            throw new IllegalArgumentException(sm.getString("defaultInstanceManager.invalidInjection"));
         }
 
         Object lookedupResource;
@@ -602,8 +553,7 @@ public class DefaultInstanceManager implements InstanceManager {
         if ((normalizedName != null) && (normalizedName.length() > 0)) {
             lookedupResource = context.lookup(normalizedName);
         } else {
-            lookedupResource = context.lookup(
-                    clazz.getName() + "/" + Introspection.getPropertyName(method));
+            lookedupResource = context.lookup(clazz.getName() + "/" + Introspection.getPropertyName(method));
         }
 
         // This will always be a new Method instance
@@ -613,8 +563,7 @@ public class DefaultInstanceManager implements InstanceManager {
         method.invoke(instance, lookedupResource);
     }
 
-    private static void loadProperties(Set<String> classNames, String resourceName,
-            String messageKey, Log log) {
+    private static void loadProperties(Set<String> classNames, String resourceName, String messageKey, Log log) {
         Properties properties = new Properties();
         ClassLoader cl = DefaultInstanceManager.class.getClassLoader();
         try (InputStream is = cl.getResourceAsStream(resourceName)) {
@@ -633,34 +582,30 @@ public class DefaultInstanceManager implements InstanceManager {
             if ("restricted".equals(e.getValue())) {
                 classNames.add(e.getKey().toString());
             } else {
-                log.warn(sm.getString(
-                        "defaultInstanceManager.restrictedWrongValue",
-                        resourceName, e.getKey(), e.getValue()));
+                log.warn(sm.getString("defaultInstanceManager.restrictedWrongValue", resourceName, e.getKey(),
+                        e.getValue()));
             }
         }
     }
 
-    private static String normalize(String jndiName){
-        if(jndiName != null && jndiName.startsWith("java:comp/env/")){
+    private static String normalize(String jndiName) {
+        if (jndiName != null && jndiName.startsWith("java:comp/env/")) {
             return jndiName.substring(14);
         }
         return jndiName;
     }
 
-    private static Method getMethod(final Class<?> clazz,
-            final AnnotationCacheEntry entry) {
+    private static Method getMethod(final Class<?> clazz, final AnnotationCacheEntry entry) {
         Method result = null;
         try {
-            result = clazz.getDeclaredMethod(
-                    entry.getAccessibleObjectName(), entry.getParamTypes());
+            result = clazz.getDeclaredMethod(entry.getAccessibleObjectName(), entry.getParamTypes());
         } catch (NoSuchMethodException e) {
             // Should never happen. On that basis don't log it.
         }
         return result;
     }
 
-    private static Field getField(final Class<?> clazz,
-            final AnnotationCacheEntry entry) {
+    private static Field getField(final Class<?> clazz, final AnnotationCacheEntry entry) {
         Field result = null;
         try {
             result = clazz.getDeclaredField(entry.getAccessibleObjectName());
@@ -671,20 +616,15 @@ public class DefaultInstanceManager implements InstanceManager {
     }
 
 
-    private Method findPostConstruct(Method currentPostConstruct,
-            String postConstructFromXml, Method method) {
-        return findLifecycleCallback(currentPostConstruct,
-            postConstructFromXml, method, PostConstruct.class);
+    private Method findPostConstruct(Method currentPostConstruct, String postConstructFromXml, Method method) {
+        return findLifecycleCallback(currentPostConstruct, postConstructFromXml, method, PostConstruct.class);
     }
 
-    private Method findPreDestroy(Method currentPreDestroy,
-        String preDestroyFromXml, Method method) {
-        return findLifecycleCallback(currentPreDestroy,
-            preDestroyFromXml, method, PreDestroy.class);
+    private Method findPreDestroy(Method currentPreDestroy, String preDestroyFromXml, Method method) {
+        return findLifecycleCallback(currentPreDestroy, preDestroyFromXml, method, PreDestroy.class);
     }
 
-    private Method findLifecycleCallback(Method currentMethod,
-            String methodNameFromXml, Method method,
+    private Method findLifecycleCallback(Method currentMethod, String methodNameFromXml, Method method,
             Class<? extends Annotation> annotation) {
         Method result = currentMethod;
         if (methodNameFromXml != null) {
@@ -713,8 +653,7 @@ public class DefaultInstanceManager implements InstanceManager {
         private final String name;
         private final AnnotationCacheEntryType type;
 
-        public AnnotationCacheEntry(String accessibleObjectName,
-                Class<?>[] paramTypes, String name,
+        public AnnotationCacheEntry(String accessibleObjectName, Class<?>[] paramTypes, String name,
                 AnnotationCacheEntryType type) {
             this.accessibleObjectName = accessibleObjectName;
             this.paramTypes = paramTypes;
@@ -733,6 +672,7 @@ public class DefaultInstanceManager implements InstanceManager {
         public String getName() {
             return name;
         }
+
         public AnnotationCacheEntryType getType() {
             return type;
         }

==================================================
JniLifecycleListener.java
index 4b637fa668..3796390190 100644
--- a/java/org/apache/catalina/core/FrameworkListener.java
+++ b/java/org/apache/catalina/core/FrameworkListener.java
@@ -31,18 +31,18 @@ import org.apache.catalina.Server;
 import org.apache.catalina.Service;
 
 /**
- * This listener must be declared in server.xml as a Server listener, possibly optional.
- * It will register a lifecycle listener on all contexts. This is an alternative to
- * adding a Listener in context.xml with more flexibility.
+ * This listener must be declared in server.xml as a Server listener, possibly optional. It will register a lifecycle
+ * listener on all contexts. This is an alternative to adding a Listener in context.xml with more flexibility.
  */
 public abstract class FrameworkListener implements LifecycleListener, ContainerListener {
 
-    protected final ConcurrentHashMap<Context, LifecycleListener> contextListeners =
-            new ConcurrentHashMap<>();
+    protected final ConcurrentHashMap<Context, LifecycleListener> contextListeners = new ConcurrentHashMap<>();
 
     /**
      * Create a lifecycle listener which will then be added to the specified context.
+     *
      * @param context the associated Context
+     *
      * @return the lifecycle listener
      */
     protected abstract LifecycleListener createLifecycleListener(Context context);
@@ -50,8 +50,7 @@ public abstract class FrameworkListener implements LifecycleListener, ContainerL
     @Override
     public void lifecycleEvent(LifecycleEvent event) {
         Lifecycle lifecycle = event.getLifecycle();
-        if (Lifecycle.BEFORE_START_EVENT.equals(event.getType()) &&
-                lifecycle instanceof Server) {
+        if (Lifecycle.BEFORE_START_EVENT.equals(event.getType()) && lifecycle instanceof Server) {
             Server server = (Server) lifecycle;
             registerListenersForServer(server);
         }

==================================================
JreMemoryLeakPreventionListener.java
index 8e129da164..d1f3e797e0 100644
--- a/java/org/apache/catalina/core/JniLifecycleListener.java
+++ b/java/org/apache/catalina/core/JniLifecycleListener.java
@@ -26,14 +26,12 @@ import org.apache.tomcat.util.res.StringManager;
 /**
  * An implementation of LifeCycleListener that loads a native library into the JVM.
  * <p>
- * Native libraries are associated with the class loader of the class that loaded them,
- * and the same library may not be loaded by more than one class loader. Due to that
- * restriction, loading a native library from a Webapp's class loader makes it impossible
- * for other Webapps to load the native library.
+ * Native libraries are associated with the class loader of the class that loaded them, and the same library may not be
+ * loaded by more than one class loader. Due to that restriction, loading a native library from a Webapp's class loader
+ * makes it impossible for other Webapps to load the native library.
  * <p>
- * Loading the native library using this listener solves the issue as it is loaded
- * by a shared class loader (typically the Common class loader, but may vary in some
- * configurations).
+ * Loading the native library using this listener solves the issue as it is loaded by a shared class loader (typically
+ * the Common class loader, but may vary in some configurations).
  */
 public class JniLifecycleListener implements LifecycleListener {
 

==================================================
NamingContextListener.java
index 4206ff7885..5d87a8f5d4 100644
--- a/java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java
+++ b/java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java
@@ -31,18 +31,14 @@ import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * Provide a workaround for known places where the Java Runtime environment can
- * cause a memory leak or lock files.
+ * Provide a workaround for known places where the Java Runtime environment can cause a memory leak or lock files.
  * <p>
- * Memory leaks occur when JRE code uses
- * the context class loader to load a singleton as this will cause a memory leak
- * if a web application class loader happens to be the context class loader at
- * the time. The work-around is to initialise these singletons when Tomcat's
- * common class loader is the context class loader.
+ * Memory leaks occur when JRE code uses the context class loader to load a singleton as this will cause a memory leak
+ * if a web application class loader happens to be the context class loader at the time. The work-around is to
+ * initialise these singletons when Tomcat's common class loader is the context class loader.
  * <p>
- * Locked files usually occur when a resource inside a JAR is accessed without
- * first disabling Jar URL connection caching. The workaround is to disable this
- * caching by default.
+ * Locked files usually occur when a resource inside a JAR is accessed without first disabling Jar URL connection
+ * caching. The workaround is to disable this caching by default.
  * <p>
  * This listener must only be nested within {@link Server} elements.
  */
@@ -52,52 +48,60 @@ public class JreMemoryLeakPreventionListener implements LifecycleListener {
     private static final StringManager sm = StringManager.getManager(JreMemoryLeakPreventionListener.class);
 
     /**
-     * Protect against the memory leak caused when the first call to
-     * <code>sun.awt.AppContext.getAppContext()</code> is triggered by a web
-     * application. Defaults to <code>false</code> since Tomcat code no longer
-     * triggers this although application code may.
+     * Protect against the memory leak caused when the first call to <code>sun.awt.AppContext.getAppContext()</code> is
+     * triggered by a web application. Defaults to <code>false</code> since Tomcat code no longer triggers this although
+     * application code may.
      */
     private boolean appContextProtection = false;
-    public boolean isAppContextProtection() { return appContextProtection; }
+
+    public boolean isAppContextProtection() {
+        return appContextProtection;
+    }
+
     public void setAppContextProtection(boolean appContextProtection) {
         this.appContextProtection = appContextProtection;
     }
 
     /**
-     * Protect against resources being read for JAR files and, as a side-effect,
-     * the JAR file becoming locked. Note this disables caching for all
-     * {@link URLConnection}s, regardless of type. Defaults to
-     * <code>true</code>.
+     * Protect against resources being read for JAR files and, as a side-effect, the JAR file becoming locked. Note this
+     * disables caching for all {@link URLConnection}s, regardless of type. Defaults to <code>true</code>.
      */
     private boolean urlCacheProtection = true;
-    public boolean isUrlCacheProtection() { return urlCacheProtection; }
+
+    public boolean isUrlCacheProtection() {
+        return urlCacheProtection;
+    }
+
     public void setUrlCacheProtection(boolean urlCacheProtection) {
         this.urlCacheProtection = urlCacheProtection;
     }
 
     /**
-     * The first access to {@link DriverManager} will trigger the loading of
-     * all {@link java.sql.Driver}s in the the current class loader. The web
-     * application level memory leak protection can take care of this in most
-     * cases but triggering the loading here has fewer side-effects.
+     * The first access to {@link DriverManager} will trigger the loading of all {@link java.sql.Driver}s in the the
+     * current class loader. The web application level memory leak protection can take care of this in most cases but
+     * triggering the loading here has fewer side-effects.
      */
     private boolean driverManagerProtection = true;
+
     public boolean isDriverManagerProtection() {
         return driverManagerProtection;
     }
+
     public void setDriverManagerProtection(boolean driverManagerProtection) {
         this.driverManagerProtection = driverManagerProtection;
     }
 
     /**
-     * List of comma-separated fully qualified class names to load and initialize during
-     * the startup of this Listener. This allows to pre-load classes that are known to
-     * provoke classloader leaks if they are loaded during a request processing.
+     * List of comma-separated fully qualified class names to load and initialize during the startup of this Listener.
+     * This allows to pre-load classes that are known to provoke classloader leaks if they are loaded during a request
+     * processing.
      */
     private String classesToInitialize = null;
+
     public String getClassesToInitialize() {
         return classesToInitialize;
     }
+
     public void setClassesToInitialize(String classesToInitialize) {
         this.classesToInitialize = classesToInitialize;
     }
@@ -108,20 +112,16 @@ public class JreMemoryLeakPreventionListener implements LifecycleListener {
         // Initialise these classes when Tomcat starts
         if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
             if (!(event.getLifecycle() instanceof Server)) {
-                log.warn(sm.getString("listener.notServer",
-                        event.getLifecycle().getClass().getSimpleName()));
+                log.warn(sm.getString("listener.notServer", event.getLifecycle().getClass().getSimpleName()));
             }
 
             /*
-             * First call to this loads all drivers visible to the current class
-             * loader and its parents.
+             * First call to this loads all drivers visible to the current class loader and its parents.
              *
-             * Note: This is called before the context class loader is changed
-             *       because we want any drivers located in CATALINA_HOME/lib
-             *       and/or CATALINA_HOME/lib to be visible to DriverManager.
-             *       Users wishing to avoid having JDBC drivers loaded by this
-             *       class loader should add the JDBC driver(s) to the class
-             *       path so they are loaded by the system class loader.
+             * Note: This is called before the context class loader is changed because we want any drivers located in
+             * CATALINA_HOME/lib and/or CATALINA_HOME/lib to be visible to DriverManager. Users wishing to avoid having
+             * JDBC drivers loaded by this class loader should add the JDBC driver(s) to the class path so they are
+             * loaded by the system class loader.
              */
             if (driverManagerProtection) {
                 DriverManager.getDrivers();
@@ -132,22 +132,16 @@ public class JreMemoryLeakPreventionListener implements LifecycleListener {
             try {
                 // Use the system classloader as the victim for all this
                 // ClassLoader pinning we're about to do.
-                Thread.currentThread().setContextClassLoader(
-                        ClassLoader.getSystemClassLoader());
+                Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());
 
                 /*
-                 * Several components end up calling:
-                 * sun.awt.AppContext.getAppContext()
+                 * Several components end up calling: sun.awt.AppContext.getAppContext()
                  *
-                 * Those libraries / components known to trigger memory leaks
-                 * due to eventual calls to getAppContext() are:
-                 * - Google Web Toolkit via its use of javax.imageio
-                 * - Batik
-                 * - others TBD
+                 * Those libraries / components known to trigger memory leaks due to eventual calls to getAppContext()
+                 * are: - Google Web Toolkit via its use of javax.imageio - Batik - others TBD
                  *
-                 * Note that a call to sun.awt.AppContext.getAppContext() results
-                 * in a thread being started named AWT-AppKit that requires a
-                 * graphical environment to be available.
+                 * Note that a call to sun.awt.AppContext.getAppContext() results in a thread being started named
+                 * AWT-AppKit that requires a graphical environment to be available.
                  */
 
                 // Trigger a call to sun.awt.AppContext.getAppContext(). This
@@ -158,15 +152,12 @@ public class JreMemoryLeakPreventionListener implements LifecycleListener {
                 }
 
                 /*
-                 * Several components end up opening JarURLConnections without
-                 * first disabling caching. This effectively locks the file.
-                 * Whilst more noticeable and harder to ignore on Windows, it
-                 * affects all operating systems.
+                 * Several components end up opening JarURLConnections without first disabling caching. This effectively
+                 * locks the file. Whilst more noticeable and harder to ignore on Windows, it affects all operating
+                 * systems.
                  *
-                 * Those libraries/components known to trigger this issue
-                 * include:
-                 * - log4j versions 1.2.15 and earlier
-                 * - javax.xml.bind.JAXBContext.newInstance()
+                 * Those libraries/components known to trigger this issue include: - log4j versions 1.2.15 and earlier -
+                 * javax.xml.bind.JAXBContext.newInstance()
                  *
                  * https://bugs.openjdk.java.net/browse/JDK-8163449
                  *
@@ -179,16 +170,13 @@ public class JreMemoryLeakPreventionListener implements LifecycleListener {
                 }
 
                 if (classesToInitialize != null) {
-                    StringTokenizer strTok =
-                        new StringTokenizer(classesToInitialize, ", \r\n\t");
+                    StringTokenizer strTok = new StringTokenizer(classesToInitialize, ", \r\n\t");
                     while (strTok.hasMoreTokens()) {
                         String classNameToLoad = strTok.nextToken();
                         try {
                             Class.forName(classNameToLoad);
                         } catch (ClassNotFoundException e) {
-                            log.error(
-                                sm.getString("jreLeakListener.classToInitializeFail",
-                                    classNameToLoad), e);
+                            log.error(sm.getString("jreLeakListener.classToInitializeFail", classNameToLoad), e);
                             // continue with next class to load
                         }
                     }

==================================================
StandardContext.java
index b5a691a8bd..e20d62c47a 100644
--- a/java/org/apache/catalina/core/NamingContextListener.java
+++ b/java/org/apache/catalina/core/NamingContextListener.java
@@ -75,8 +75,7 @@ import org.apache.tomcat.util.res.StringManager;
 
 
 /**
- * Helper class used to initialize and populate the JNDI context associated
- * with each context and server.
+ * Helper class used to initialize and populate the JNDI context associated with each context and server.
  *
  * @author Remy Maucherat
  */
@@ -141,8 +140,7 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
 
 
     /**
-     * Determines if an attempt to write to a read-only context results in an
-     * exception or if the request is ignored.
+     * Determines if an attempt to write to a read-only context results in an exception or if the request is ignored.
      */
     private boolean exceptionOnFailedWrite = true;
 
@@ -150,8 +148,8 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
     // ------------------------------------------------------------- Properties
 
     /**
-     * @return whether or not an attempt to modify the JNDI context will trigger
-     * an exception or if the request will be ignored.
+     * @return whether or not an attempt to modify the JNDI context will trigger an exception or if the request will be
+     *             ignored.
      */
     public boolean getExceptionOnFailedWrite() {
         return exceptionOnFailedWrite;
@@ -159,10 +157,10 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
 
 
     /**
-     * Controls whether or not an attempt to modify the JNDI context will
-     * trigger an exception or if the request will be ignored.
+     * Controls whether or not an attempt to modify the JNDI context will trigger an exception or if the request will be
+     * ignored.
      *
-     * @param exceptionOnFailedWrite    The new value
+     * @param exceptionOnFailedWrite The new value
      */
     public void setExceptionOnFailedWrite(boolean exceptionOnFailedWrite) {
         this.exceptionOnFailedWrite = exceptionOnFailedWrite;
@@ -229,13 +227,12 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
                 ContextAccessController.setSecurityToken(getName(), token);
                 ContextAccessController.setSecurityToken(container, token);
                 ContextBindings.bindContext(container, namingContext, token);
-                if( log.isDebugEnabled() ) {
-                    log.debug("Bound " + container );
+                if (log.isDebugEnabled()) {
+                    log.debug("Bound " + container);
                 }
 
                 // Configure write when read-only behaviour
-                namingContext.setExceptionOnFailedWrite(
-                        getExceptionOnFailedWrite());
+                namingContext.setExceptionOnFailedWrite(getExceptionOnFailedWrite());
 
                 // Setting the context in read/write mode
                 ContextAccessController.setWritable(getName(), token);
@@ -243,8 +240,7 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
                 try {
                     createNamingContext();
                 } catch (NamingException e) {
-                    log.error
-                        (sm.getString("naming.namingContextCreationFailed", e));
+                    log.error(sm.getString("naming.namingContextCreationFailed", e));
                 }
 
                 namingResources.addPropertyChangeListener(this);
@@ -262,17 +258,14 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
                 }
 
                 if (container instanceof Server) {
-                    org.apache.naming.factory.ResourceLinkFactory.setGlobalContext
-                        (namingContext);
+                    org.apache.naming.factory.ResourceLinkFactory.setGlobalContext(namingContext);
                     try {
-                        ContextBindings.bindClassLoader(container, token,
-                                this.getClass().getClassLoader());
+                        ContextBindings.bindClassLoader(container, token, this.getClass().getClassLoader());
                     } catch (NamingException e) {
                         log.error(sm.getString("naming.bindFailed", e));
                     }
                     if (container instanceof StandardServer) {
-                        ((StandardServer) container).setGlobalNamingContext
-                            (namingContext);
+                        ((StandardServer) container).setGlobalNamingContext(namingContext);
                     }
                 }
 
@@ -298,8 +291,7 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
                 }
 
                 if (container instanceof Server) {
-                    ContextBindings.unbindClassLoader(container, token,
-                            this.getClass().getClassLoader());
+                    ContextBindings.unbindClassLoader(container, token, this.getClass().getClassLoader());
                 }
 
                 namingResources.removePropertyChangeListener(this);
@@ -355,9 +347,7 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
             // Setting the context in read/write mode
             ContextAccessController.setWritable(getName(), token);
 
-            processGlobalResourcesChange(event.getPropertyName(),
-                                         event.getOldValue(),
-                                         event.getNewValue());
+            processGlobalResourcesChange(event.getPropertyName(), event.getOldValue(), event.getNewValue());
 
             // Setting the context in read only mode
             ContextAccessController.setReadOnly(getName());
@@ -371,16 +361,14 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
 
 
     /**
-     * Process a property change on the naming resources, by making the
-     * corresponding addition or removal to the associated JNDI context.
+     * Process a property change on the naming resources, by making the corresponding addition or removal to the
+     * associated JNDI context.
      *
-     * @param name Property name of the change to be processed
+     * @param name     Property name of the change to be processed
      * @param oldValue The old value (or <code>null</code> if adding)
      * @param newValue The new value (or <code>null</code> if removing)
      */
-    private void processGlobalResourcesChange(String name,
-                                              Object oldValue,
-                                              Object newValue) {
+    private void processGlobalResourcesChange(String name, Object oldValue, Object newValue) {
 
         if (name.equals("ejb")) {
             if (oldValue != null) {
@@ -449,15 +437,13 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
             }
         } else if (name.equals("resourceEnvRef")) {
             if (oldValue != null) {
-                ContextResourceEnvRef resourceEnvRef =
-                    (ContextResourceEnvRef) oldValue;
+                ContextResourceEnvRef resourceEnvRef = (ContextResourceEnvRef) oldValue;
                 if (resourceEnvRef.getName() != null) {
                     removeResourceEnvRef(resourceEnvRef.getName());
                 }
             }
             if (newValue != null) {
-                ContextResourceEnvRef resourceEnvRef =
-                    (ContextResourceEnvRef) newValue;
+                ContextResourceEnvRef resourceEnvRef = (ContextResourceEnvRef) newValue;
                 if (resourceEnvRef.getName() != null) {
                     addResourceEnvRef(resourceEnvRef);
                 }
@@ -497,8 +483,7 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
     /**
      * Create and initialize the JNDI naming context.
      */
-    private void createNamingContext()
-        throws NamingException {
+    private void createNamingContext() throws NamingException {
 
         // Creating the comp subcontext
         if (container instanceof Server) {
@@ -521,8 +506,7 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
         }
 
         // Resource links
-        ContextResourceLink[] resourceLinks =
-            namingResources.findResourceLinks();
+        ContextResourceLink[] resourceLinks = namingResources.findResourceLinks();
         for (i = 0; i < resourceLinks.length; i++) {
             addResourceLink(resourceLinks[i]);
         }
@@ -540,8 +524,7 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
         }
 
         // Environment entries
-        ContextEnvironment[] contextEnvironments =
-            namingResources.findEnvironments();
+        ContextEnvironment[] contextEnvironments = namingResources.findEnvironments();
         for (i = 0; i < contextEnvironments.length; i++) {
             addEnvironment(contextEnvironments[i]);
         }
@@ -590,8 +573,7 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
         // Binding the resources directory context
         if (container instanceof Context) {
             try {
-                compCtx.bind("Resources",
-                             ((Context) container).getResources());
+                compCtx.bind("Resources", ((Context) container).getResources());
             } catch (NamingException e) {
                 log.error(sm.getString("naming.bindFailed", e));
             }
@@ -601,15 +583,15 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
 
 
     /**
-     * Create an <code>ObjectName</code> for this
-     * <code>ContextResource</code> object.
+     * Create an <code>ObjectName</code> for this <code>ContextResource</code> object.
      *
      * @param resource The resource
+     *
      * @return ObjectName The object name
+     *
      * @exception MalformedObjectNameException if a name cannot be created
      */
-    protected ObjectName createObjectName(ContextResource resource)
-        throws MalformedObjectNameException {
+    protected ObjectName createObjectName(ContextResource resource) throws MalformedObjectNameException {
 
         String domain = null;
         if (container instanceof StandardServer) {
@@ -624,20 +606,16 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
         ObjectName name = null;
         String quotedResourceName = ObjectName.quote(resource.getName());
         if (container instanceof Server) {
-            name = new ObjectName(domain + ":type=DataSource" +
-                        ",class=" + resource.getType() +
-                        ",name=" + quotedResourceName);
+            name = new ObjectName(
+                    domain + ":type=DataSource" + ",class=" + resource.getType() + ",name=" + quotedResourceName);
         } else if (container instanceof Context) {
-            String contextName = ((Context)container).getName();
+            String contextName = ((Context) container).getName();
             if (!contextName.startsWith("/")) {
                 contextName = "/" + contextName;
             }
-            Host host = (Host) ((Context)container).getParent();
-            name = new ObjectName(domain + ":type=DataSource" +
-                    ",host=" + host.getName() +
-                    ",context=" + contextName +
-                    ",class=" + resource.getType() +
-                    ",name=" + quotedResourceName);
+            Host host = (Host) ((Context) container).getParent();
+            name = new ObjectName(domain + ":type=DataSource" + ",host=" + host.getName() + ",context=" + contextName +
+                    ",class=" + resource.getType() + ",name=" + quotedResourceName);
         }
 
         return name;
@@ -743,8 +721,7 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
                 } else {
                     value = constructEnvEntry(env.getType(), env.getValue());
                     if (value == null) {
-                        log.error(sm.getString(
-                                "naming.invalidEnvEntryType", env.getName()));
+                        log.error(sm.getString("naming.invalidEnvEntryType", env.getName()));
                     }
                 }
             } catch (IllegalArgumentException e) {
@@ -772,8 +749,8 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
             Class<?> clazz = Class.forName(type);
             Constructor<?> c = null;
             try {
-                 c = clazz.getConstructor(String.class);
-                 return c.newInstance(value);
+                c = clazz.getConstructor(String.class);
+                return c.newInstance(value);
             } catch (NoSuchMethodException e) {
                 // Ignore
             }
@@ -840,18 +817,15 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
                 }
                 if (wsdlURL == null) {
                     try {
-                        wsdlURL = ((Context) container).getServletContext().getResource(
-                                service.getWsdlfile());
+                        wsdlURL = ((Context) container).getServletContext().getResource(service.getWsdlfile());
                     } catch (MalformedURLException e) {
                         // Ignore and carry on
                     }
                 }
                 if (wsdlURL == null) {
                     try {
-                        wsdlURL = ((Context) container).getServletContext().getResource(
-                                "/" + service.getWsdlfile());
-                        log.debug("  Changing service ref wsdl file for /"
-                                    + service.getWsdlfile());
+                        wsdlURL = ((Context) container).getServletContext().getResource("/" + service.getWsdlfile());
+                        log.debug("  Changing service ref wsdl file for /" + service.getWsdlfile());
                     } catch (MalformedURLException e) {
                         log.error(sm.getString("naming.wsdlFailed", e));
                     }
@@ -874,18 +848,17 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
                 }
                 if (jaxrpcURL == null) {
                     try {
-                        jaxrpcURL = ((Context) container).getServletContext().getResource(
-                                service.getJaxrpcmappingfile());
+                        jaxrpcURL = ((Context) container).getServletContext()
+                                .getResource(service.getJaxrpcmappingfile());
                     } catch (MalformedURLException e) {
                         // Ignore and carry on
                     }
                 }
                 if (jaxrpcURL == null) {
                     try {
-                        jaxrpcURL = ((Context) container).getServletContext().getResource(
-                                "/" + service.getJaxrpcmappingfile());
-                        log.debug("  Changing service ref jaxrpc file for /"
-                                    + service.getJaxrpcmappingfile());
+                        jaxrpcURL = ((Context) container).getServletContext()
+                                .getResource("/" + service.getJaxrpcmappingfile());
+                        log.debug("  Changing service ref jaxrpc file for /" + service.getJaxrpcmappingfile());
                     } catch (MalformedURLException e) {
                         log.error(sm.getString("naming.wsdlFailed", e));
                     }
@@ -898,9 +871,8 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
             }
 
             // Create a reference to the resource.
-            ref = new ServiceRef(service.getName(), service.getInterface(),
-                    service.getServiceqname(), service.getWsdlfile(),
-                    service.getJaxrpcmappingfile());
+            ref = new ServiceRef(service.getName(), service.getInterface(), service.getServiceqname(),
+                    service.getWsdlfile(), service.getJaxrpcmappingfile());
 
             // Adding the additional port-component-ref, if any
             Iterator<String> portcomponent = service.getServiceendpoints();
@@ -965,8 +937,8 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
 
         if (ref == null) {
             // Create a reference to the resource.
-            ref = new ResourceRef(resource.getType(), resource.getDescription(),
-                    resource.getScope(), resource.getAuth(), resource.getSingleton());
+            ref = new ResourceRef(resource.getType(), resource.getDescription(), resource.getScope(),
+                    resource.getAuth(), resource.getSingleton());
             // Adding the additional parameters, if any
             Iterator<String> params = resource.listProperties();
             while (params.hasNext()) {
@@ -987,9 +959,8 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
             log.error(sm.getString("naming.bindFailed", e));
         }
 
-        if (("javax.sql.DataSource".equals(ref.getClassName())  ||
-            "javax.sql.XADataSource".equals(ref.getClassName())) &&
-                resource.getSingleton()) {
+        if (("javax.sql.DataSource".equals(ref.getClassName()) ||
+                "javax.sql.XADataSource".equals(ref.getClassName())) && resource.getSingleton()) {
             Object actualResource = null;
             try {
                 ObjectName on = createObjectName(resource);
@@ -1050,20 +1021,18 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
     public void addResourceLink(ContextResourceLink resourceLink) {
 
         // Create a reference to the resource.
-        Reference ref = new ResourceLinkRef
-            (resourceLink.getType(), resourceLink.getGlobal(), resourceLink.getFactory(), null);
+        Reference ref = new ResourceLinkRef(resourceLink.getType(), resourceLink.getGlobal(), resourceLink.getFactory(),
+                null);
         Iterator<String> i = resourceLink.listProperties();
         while (i.hasNext()) {
             String key = i.next();
             Object val = resourceLink.getProperty(key);
-            if (val!=null) {
+            if (val != null) {
                 StringRefAddr refAddr = new StringRefAddr(key, val.toString());
                 ref.add(refAddr);
             }
         }
-        javax.naming.Context ctx =
-            "UserTransaction".equals(resourceLink.getName())
-            ? compCtx : envCtx;
+        javax.naming.Context ctx = "UserTransaction".equals(resourceLink.getName()) ? compCtx : envCtx;
         try {
             if (log.isDebugEnabled()) {
                 log.debug("  Adding resource link " + resourceLink.getName());
@@ -1074,8 +1043,8 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
             log.error(sm.getString("naming.bindFailed", e));
         }
 
-        ResourceLinkFactory.registerGlobalResourceAccess(
-                getGlobalNamingContext(), resourceLink.getName(), resourceLink.getGlobal());
+        ResourceLinkFactory.registerGlobalResourceAccess(getGlobalNamingContext(), resourceLink.getName(),
+                resourceLink.getGlobal());
     }
 
 
@@ -1143,8 +1112,7 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
     /**
      * Remove the specified message destination ref from the naming context.
      *
-     * @param name the name of the message destination ref which should be
-     *             removed
+     * @param name the name of the message destination ref which should be removed
      */
     public void removeMessageDestinationRef(String name) {
 
@@ -1195,11 +1163,9 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
 
 
     /**
-     * Remove the specified resource environment reference from the naming
-     * context.
+     * Remove the specified resource environment reference from the naming context.
      *
-     * @param name the name of the resource environment reference which should
-     *             be removed
+     * @param name the name of the resource environment reference which should be removed
      */
     public void removeResourceEnvRef(String name) {
 
@@ -1232,8 +1198,7 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
     /**
      * Create all intermediate subcontexts.
      */
-    private void createSubcontexts(javax.naming.Context ctx, String name)
-        throws NamingException {
+    private void createSubcontexts(javax.naming.Context ctx, String name) throws NamingException {
         javax.naming.Context currentContext = ctx;
         StringTokenizer tokenizer = new StringTokenizer(name, "/");
         while (tokenizer.hasMoreTokens()) {
@@ -1244,8 +1209,7 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
                 } catch (NamingException e) {
                     // Silent catch. Probably an object is already bound in
                     // the context.
-                    currentContext =
-                        (javax.naming.Context) currentContext.lookup(token);
+                    currentContext = (javax.naming.Context) currentContext.lookup(token);
                 }
             }
         }
@@ -1256,6 +1220,7 @@ public class NamingContextListener implements LifecycleListener, PropertyChangeL
      * Gets look up reference from resource if exist.
      *
      * @param resourceBase resource base object
+     *
      * @return lookup ref
      */
     private LookupRef lookForLookupRef(ResourceBase resourceBase) {

==================================================
StandardContextValve.java
index 1a3c33bdb5..459d5b4254 100644
--- a/java/org/apache/catalina/core/StandardContext.java
+++ b/java/org/apache/catalina/core/StandardContext.java
@@ -132,15 +132,13 @@ import org.apache.tomcat.util.http.Rfc6265CookieProcessor;
 import org.apache.tomcat.util.scan.StandardJarScanner;
 
 /**
- * Standard implementation of the <b>Context</b> interface.  Each
- * child container must be a Wrapper implementation to process the
- * requests directed to a particular servlet.
+ * Standard implementation of the <b>Context</b> interface. Each child container must be a Wrapper implementation to
+ * process the requests directed to a particular servlet.
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
  */
-public class StandardContext extends ContainerBase
-        implements Context, NotificationEmitter {
+public class StandardContext extends ContainerBase implements Context, NotificationEmitter {
 
     private static final Log log = LogFactory.getLog(StandardContext.class);
 
@@ -168,15 +166,14 @@ public class StandardContext extends ContainerBase
     // ----------------------------------------------------- Instance Variables
 
     /**
-     * Allow multipart/form-data requests to be parsed even when the
-     * target servlet doesn't specify @MultipartConfig or have a
-     * &lt;multipart-config&gt; element.
+     * Allow multipart/form-data requests to be parsed even when the target servlet doesn't specify @MultipartConfig or
+     * have a &lt;multipart-config&gt; element.
      */
     protected boolean allowCasualMultipartParsing = false;
 
     /**
-     * Control whether remaining request data will be read
-     * (swallowed) even if the request violates a data size constraint.
+     * Control whether remaining request data will be read (swallowed) even if the request violates a data size
+     * constraint.
      */
     private boolean swallowAbortedUploads = true;
 
@@ -199,49 +196,43 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * The set of application listener class names configured for this
-     * application, in the order they were encountered in the resulting merged
-     * web.xml file.
+     * The set of application listener class names configured for this application, in the order they were encountered
+     * in the resulting merged web.xml file.
      */
     private String applicationListeners[] = new String[0];
 
     private final Object applicationListenersLock = new Object();
 
     /**
-     * The set of application listeners that are required to have limited access
-     * to ServletContext methods. See Servlet 3.1 section 4.4.
+     * The set of application listeners that are required to have limited access to ServletContext methods. See Servlet
+     * 3.1 section 4.4.
      */
     private final Set<Object> noPluggabilityListeners = new HashSet<>();
 
     /**
-     * The list of instantiated application event listener objects. Note that
-     * SCIs and other code may use the pluggability APIs to add listener
-     * instances directly to this list before the application starts.
+     * The list of instantiated application event listener objects. Note that SCIs and other code may use the
+     * pluggability APIs to add listener instances directly to this list before the application starts.
      */
     private List<Object> applicationEventListenersList = new CopyOnWriteArrayList<>();
 
 
     /**
-     * The set of instantiated application lifecycle listener objects. Note that
-     * SCIs and other code may use the pluggability APIs to add listener
-     * instances directly to this list before the application starts.
+     * The set of instantiated application lifecycle listener objects. Note that SCIs and other code may use the
+     * pluggability APIs to add listener instances directly to this list before the application starts.
      */
-    private Object applicationLifecycleListenersObjects[] =
-        new Object[0];
+    private Object applicationLifecycleListenersObjects[] = new Object[0];
 
 
     /**
      * The ordered set of ServletContainerInitializers for this web application.
      */
-    private Map<ServletContainerInitializer,Set<Class<?>>> initializers =
-        new LinkedHashMap<>();
+    private Map<ServletContainerInitializer, Set<Class<?>>> initializers = new LinkedHashMap<>();
 
 
     /**
      * The set of application parameters defined for this application.
      */
-    private ApplicationParameter applicationParameters[] =
-        new ApplicationParameter[0];
+    private ApplicationParameter applicationParameters[] = new ApplicationParameter[0];
 
     private final Object applicationParametersLock = new Object();
 
@@ -260,8 +251,7 @@ public class StandardContext extends ContainerBase
     /**
      * The Java class name of the CharsetMapper class to be created.
      */
-    private String charsetMapperClass =
-      "org.apache.catalina.util.CharsetMapper";
+    private String charsetMapperClass = "org.apache.catalina.util.CharsetMapper";
 
 
     /**
@@ -279,8 +269,7 @@ public class StandardContext extends ContainerBase
     /**
      * The security constraints for this web application.
      */
-    private volatile SecurityConstraint constraints[] =
-            new SecurityConstraint[0];
+    private volatile SecurityConstraint constraints[] = new SecurityConstraint[0];
 
     private final Object constraintsLock = new Object();
 
@@ -291,9 +280,8 @@ public class StandardContext extends ContainerBase
     protected ApplicationContext context = null;
 
     /**
-     * The wrapped version of the associated ServletContext that is presented
-     * to listeners that are required to have limited access to ServletContext
-     * methods. See Servlet 3.1 section 4.4.
+     * The wrapped version of the associated ServletContext that is presented to listeners that are required to have
+     * limited access to ServletContext methods. See Servlet 3.1 section 4.4.
      */
     private NoPluggabilityServletContext noPluggabilityServletContext = null;
 
@@ -305,8 +293,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Should we allow the <code>ServletContext.getContext()</code> method
-     * to access the context of other web applications in this server?
+     * Should we allow the <code>ServletContext.getContext()</code> method to access the context of other web
+     * applications in this server?
      */
     private boolean crossContext = false;
 
@@ -324,10 +312,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * The "follow standard delegation model" flag that will be used to
-     * configure our ClassLoader.
-     * Graal cannot actually load a class from the webapp classloader,
-     * so delegate by default.
+     * The "follow standard delegation model" flag that will be used to configure our ClassLoader. Graal cannot actually
+     * load a class from the webapp classloader, so delegate by default.
      */
     private boolean delegate = JreCompat.isGraalAvailable();
 
@@ -368,24 +354,21 @@ public class StandardContext extends ContainerBase
     private final ErrorPageSupport errorPageSupport = new ErrorPageSupport();
 
     /**
-     * The set of filter configurations (and associated filter instances) we
-     * have initialized, keyed by filter name.
+     * The set of filter configurations (and associated filter instances) we have initialized, keyed by filter name.
      */
     private Map<String, ApplicationFilterConfig> filterConfigs = new HashMap<>();
 
 
     /**
-     * The set of filter definitions for this application, keyed by
-     * filter name.
+     * The set of filter definitions for this application, keyed by filter name.
      */
     private Map<String, FilterDef> filterDefs = new HashMap<>();
 
 
     /**
-     * The set of filter mappings for this application, in the order
-     * they were defined in the deployment descriptor with additional mappings
-     * added via the {@link ServletContext} possibly both before and after those
-     * defined in the deployment descriptor.
+     * The set of filter mappings for this application, in the order they were defined in the deployment descriptor with
+     * additional mappings added via the {@link ServletContext} possibly both before and after those defined in the
+     * deployment descriptor.
      */
     private final ContextFilterMaps filterMaps = new ContextFilterMaps();
 
@@ -435,8 +418,7 @@ public class StandardContext extends ContainerBase
     /**
      * The message destinations for this web application.
      */
-    private HashMap<String, MessageDestination> messageDestinations =
-        new HashMap<>();
+    private HashMap<String, MessageDestination> messageDestinations = new HashMap<>();
 
 
     /**
@@ -446,8 +428,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * The context initialization parameters for this web application,
-     * keyed by name.
+     * The context initialization parameters for this web application, keyed by name.
      */
     private final Map<String, String> parameters = new ConcurrentHashMap<>();
 
@@ -459,9 +440,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * The public identifier of the DTD for the web application deployment
-     * descriptor version we are currently parsing.  This is used to support
-     * relaxed validation rules when processing version 2.2 web.xml files.
+     * The public identifier of the DTD for the web application deployment descriptor version we are currently parsing.
+     * This is used to support relaxed validation rules when processing version 2.2 web.xml files.
      */
     private String publicId = null;
 
@@ -503,18 +483,15 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Should the next call to <code>addWelcomeFile()</code> cause replacement
-     * of any existing welcome files?  This will be set before processing the
-     * web application's deployment descriptor, so that application specified
-     * choices <strong>replace</strong>, rather than append to, those defined
-     * in the global descriptor.
+     * Should the next call to <code>addWelcomeFile()</code> cause replacement of any existing welcome files? This will
+     * be set before processing the web application's deployment descriptor, so that application specified choices
+     * <strong>replace</strong>, rather than append to, those defined in the global descriptor.
      */
     private boolean replaceWelcomeFiles = false;
 
 
     /**
-     * The security role mappings for this application, keyed by role
-     * name (as used within the application).
+     * The security role mappings for this application, keyed by role name (as used within the application).
      */
     private Map<String, String> roleMappings = new HashMap<>();
 
@@ -528,8 +505,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * The servlet mappings for this web application, keyed by
-     * matching pattern.
+     * The servlet mappings for this web application, keyed by matching pattern.
      */
     private Map<String, String> servletMappings = new HashMap<>();
 
@@ -548,8 +524,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Set flag to true to cause the system.out and system.err to be redirected
-     * to the logger when executing a servlet.
+     * Set flag to true to cause the system.out and system.err to be redirected to the logger when executing a servlet.
      */
     private boolean swallowOutput = false;
 
@@ -577,24 +552,23 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * The set of classnames of LifecycleListeners that will be added
-     * to each newly created Wrapper by <code>createWrapper()</code>.
+     * The set of classnames of LifecycleListeners that will be added to each newly created Wrapper by
+     * <code>createWrapper()</code>.
      */
     private String wrapperLifecycles[] = new String[0];
 
     private final Object wrapperLifecyclesLock = new Object();
 
     /**
-     * The set of classnames of ContainerListeners that will be added
-     * to each newly created Wrapper by <code>createWrapper()</code>.
+     * The set of classnames of ContainerListeners that will be added to each newly created Wrapper by
+     * <code>createWrapper()</code>.
      */
     private String wrapperListeners[] = new String[0];
 
     private final Object wrapperListenersLock = new Object();
 
     /**
-     * The pathname to the work directory for this context (relative to
-     * the server's home if not absolute).
+     * The pathname to the work directory for this context (relative to the server's home if not absolute).
      */
     private String workDir = null;
 
@@ -628,13 +602,12 @@ public class StandardContext extends ContainerBase
     /**
      * Name of the engine. If null, the domain is used.
      */
-    private String j2EEApplication="none";
-    private String j2EEServer="none";
+    private String j2EEApplication = "none";
+    private String j2EEServer = "none";
 
 
     /**
-     * Attribute value used to turn on/off XML validation for web.xml and
-     * web-fragment.xml files.
+     * Attribute value used to turn on/off XML validation for web.xml and web-fragment.xml files.
      */
     private boolean webXmlValidation = Globals.STRICT_SERVLET_COMPLIANCE;
 
@@ -658,8 +631,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * The name to use for session cookies. <code>null</code> indicates that
-     * the name is controlled by the application.
+     * The name to use for session cookies. <code>null</code> indicates that the name is controlled by the application.
      */
     private String sessionCookieName;
 
@@ -671,91 +643,81 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * The domain to use for session cookies. <code>null</code> indicates that
-     * the domain is controlled by the application.
+     * The domain to use for session cookies. <code>null</code> indicates that the domain is controlled by the
+     * application.
      */
     private String sessionCookieDomain;
 
 
     /**
-     * The path to use for session cookies. <code>null</code> indicates that
-     * the path is controlled by the application.
+     * The path to use for session cookies. <code>null</code> indicates that the path is controlled by the application.
      */
     private String sessionCookiePath;
 
 
     /**
-     * Is a / added to the end of the session cookie path to ensure browsers,
-     * particularly IE, don't send a session cookie for context /foo with
-     * requests intended for context /foobar.
+     * Is a / added to the end of the session cookie path to ensure browsers, particularly IE, don't send a session
+     * cookie for context /foo with requests intended for context /foobar.
      */
     private boolean sessionCookiePathUsesTrailingSlash = false;
 
 
     /**
-     * The Jar scanner to use to search for Jars that might contain
-     * configuration information such as TLDs or web-fragment.xml files.
+     * The Jar scanner to use to search for Jars that might contain configuration information such as TLDs or
+     * web-fragment.xml files.
      */
     private JarScanner jarScanner = null;
 
     /**
-     * Enables the RMI Target memory leak detection to be controlled. This is
-     * necessary since the detection can only work if some of the modularity
-     * checks are disabled.
+     * Enables the RMI Target memory leak detection to be controlled. This is necessary since the detection can only
+     * work if some of the modularity checks are disabled.
      */
     private boolean clearReferencesRmiTargets = true;
 
     /**
-     * Should Tomcat attempt to terminate threads that have been started by the
-     * web application? Stopping threads is performed via the deprecated (for
-     * good reason) <code>Thread.stop()</code> method and is likely to result in
-     * instability. As such, enabling this should be viewed as an option of last
-     * resort in a development environment and is not recommended in a
-     * production environment. If not specified, the default value of
-     * <code>false</code> will be used.
+     * Should Tomcat attempt to terminate threads that have been started by the web application? Stopping threads is
+     * performed via the deprecated (for good reason) <code>Thread.stop()</code> method and is likely to result in
+     * instability. As such, enabling this should be viewed as an option of last resort in a development environment and
+     * is not recommended in a production environment. If not specified, the default value of <code>false</code> will be
+     * used.
      */
     private boolean clearReferencesStopThreads = false;
 
     /**
-     * Should Tomcat attempt to terminate any {@link java.util.TimerThread}s
-     * that have been started by the web application? If not specified, the
-     * default value of <code>false</code> will be used.
+     * Should Tomcat attempt to terminate any {@link java.util.TimerThread}s that have been started by the web
+     * application? If not specified, the default value of <code>false</code> will be used.
      */
     private boolean clearReferencesStopTimerThreads = false;
 
     /**
-     * If an HttpClient keep-alive timer thread has been started by this web
-     * application and is still running, should Tomcat change the context class
-     * loader from the current {@link ClassLoader} to
-     * {@link ClassLoader#getParent()} to prevent a memory leak? Note that the
-     * keep-alive timer thread will stop on its own once the keep-alives all
-     * expire however, on a busy system that might not happen for some time.
+     * If an HttpClient keep-alive timer thread has been started by this web application and is still running, should
+     * Tomcat change the context class loader from the current {@link ClassLoader} to {@link ClassLoader#getParent()} to
+     * prevent a memory leak? Note that the keep-alive timer thread will stop on its own once the keep-alives all expire
+     * however, on a busy system that might not happen for some time.
      */
     private boolean clearReferencesHttpClientKeepAliveThread = true;
 
     /**
-     * Should Tomcat renew the threads of the thread pool when the application
-     * is stopped to avoid memory leaks because of uncleaned ThreadLocal
-     * variables. This also requires that the threadRenewalDelay property of the
+     * Should Tomcat renew the threads of the thread pool when the application is stopped to avoid memory leaks because
+     * of uncleaned ThreadLocal variables. This also requires that the threadRenewalDelay property of the
      * StandardThreadExecutor or ThreadPoolExecutor be set to a positive value.
      */
     private boolean renewThreadsWhenStoppingContext = true;
 
     /**
-     * Should Tomcat attempt to clear references to classes loaded by the web
-     * application class loader from the ObjectStreamClass caches?
+     * Should Tomcat attempt to clear references to classes loaded by the web application class loader from the
+     * ObjectStreamClass caches?
      */
     private boolean clearReferencesObjectStreamClassCaches = true;
 
     /**
-     * Should Tomcat attempt to clear references to classes loaded by this class
-     * loader from ThreadLocals?
+     * Should Tomcat attempt to clear references to classes loaded by this class loader from ThreadLocals?
      */
     private boolean clearReferencesThreadLocals = true;
 
     /**
-     * Should Tomcat skip the memory leak checks when the web application is
-     * stopped as part of the process of shutting down the JVM?
+     * Should Tomcat skip the memory leak checks when the web application is stopped as part of the process of shutting
+     * down the JVM?
      */
     private boolean skipMemoryLeakChecksOnJvmShutdown = false;
 
@@ -779,8 +741,7 @@ public class StandardContext extends ContainerBase
     private boolean fireRequestListenersOnForwards = false;
 
     /**
-     * Servlets created via {@link ApplicationContext#createServlet(Class)} for
-     * tracking purposes.
+     * Servlets created via {@link ApplicationContext#createServlet(Class)} for tracking purposes.
      */
     private Set<Servlet> createdServlets = new HashSet<>();
 
@@ -799,9 +760,12 @@ public class StandardContext extends ContainerBase
 
     protected static final ThreadBindingListener DEFAULT_NAMING_LISTENER = (new ThreadBindingListener() {
         @Override
-        public void bind() {}
+        public void bind() {
+        }
+
         @Override
-        public void unbind() {}
+        public void unbind() {
+        }
     });
     protected ThreadBindingListener threadBindingListener = DEFAULT_NAMING_LISTENER;
 
@@ -870,8 +834,7 @@ public class StandardContext extends ContainerBase
 
 
     @Override
-    public void setAllowMultipleLeadingForwardSlashInPath(
-            boolean allowMultipleLeadingForwardSlashInPath) {
+    public void setAllowMultipleLeadingForwardSlashInPath(boolean allowMultipleLeadingForwardSlashInPath) {
         this.allowMultipleLeadingForwardSlashInPath = allowMultipleLeadingForwardSlashInPath;
     }
 
@@ -901,8 +864,7 @@ public class StandardContext extends ContainerBase
 
 
     @Override
-    public void setContextGetResourceRequiresSlash(
-            boolean contextGetResourceRequiresSlash) {
+    public void setContextGetResourceRequiresSlash(boolean contextGetResourceRequiresSlash) {
         this.contextGetResourceRequiresSlash = contextGetResourceRequiresSlash;
     }
 
@@ -914,8 +876,7 @@ public class StandardContext extends ContainerBase
 
 
     @Override
-    public void setDispatcherWrapsSameObject(
-            boolean dispatcherWrapsSameObject) {
+    public void setDispatcherWrapsSameObject(boolean dispatcherWrapsSameObject) {
         this.dispatcherWrapsSameObject = dispatcherWrapsSameObject;
     }
 
@@ -941,10 +902,9 @@ public class StandardContext extends ContainerBase
     @Override
     public void setResponseCharacterEncoding(String responseEncoding) {
         /*
-         * This ensures that the context response encoding is represented by a
-         * unique String object. This enables the Default Servlet to
-         * differentiate between a Response using this default encoding and one
-         * that has been explicitly configured.
+         * This ensures that the context response encoding is represented by a unique String object. This enables the
+         * Default Servlet to differentiate between a Response using this default encoding and one that has been
+         * explicitly configured.
          */
         if (responseEncoding == null) {
             this.responseEncoding = null;
@@ -1042,8 +1002,7 @@ public class StandardContext extends ContainerBase
     @Override
     public void setCookieProcessor(CookieProcessor cookieProcessor) {
         if (cookieProcessor == null) {
-            throw new IllegalArgumentException(
-                    sm.getString("standardContext.cookieProcessor.null"));
+            throw new IllegalArgumentException(sm.getString("standardContext.cookieProcessor.null"));
         }
         this.cookieProcessor = cookieProcessor;
     }
@@ -1110,8 +1069,7 @@ public class StandardContext extends ContainerBase
 
 
     @Override
-    public void setAddWebinfClassesResources(
-            boolean addWebinfClassesResources) {
+    public void setAddWebinfClassesResources(boolean addWebinfClassesResources) {
         this.addWebinfClassesResources = addWebinfClassesResources;
     }
 
@@ -1158,7 +1116,7 @@ public class StandardContext extends ContainerBase
         }
         for (String servletName : resourceOnlyServlets.split(",")) {
             servletName = servletName.trim();
-            if (servletName.length()>0) {
+            if (servletName.length() > 0) {
                 this.resourceOnlyServlets.add(servletName);
             }
         }
@@ -1235,13 +1193,13 @@ public class StandardContext extends ContainerBase
 
     @Override
     public InstanceManager getInstanceManager() {
-       return instanceManager;
+        return instanceManager;
     }
 
 
     @Override
     public void setInstanceManager(InstanceManager instanceManager) {
-       this.instanceManager = instanceManager;
+        this.instanceManager = instanceManager;
     }
 
 
@@ -1252,27 +1210,22 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Set to <code>true</code> to allow requests mapped to servlets that
-     * do not explicitly declare @MultipartConfig or have
-     * &lt;multipart-config&gt; specified in web.xml to parse
-     * multipart/form-data requests.
+     * Set to <code>true</code> to allow requests mapped to servlets that do not explicitly declare @MultipartConfig or
+     * have &lt;multipart-config&gt; specified in web.xml to parse multipart/form-data requests.
      *
-     * @param allowCasualMultipartParsing <code>true</code> to allow such
-     *        casual parsing, <code>false</code> otherwise.
+     * @param allowCasualMultipartParsing <code>true</code> to allow such casual parsing, <code>false</code> otherwise.
      */
     @Override
-    public void setAllowCasualMultipartParsing(
-            boolean allowCasualMultipartParsing) {
+    public void setAllowCasualMultipartParsing(boolean allowCasualMultipartParsing) {
         this.allowCasualMultipartParsing = allowCasualMultipartParsing;
     }
 
     /**
-     * Returns <code>true</code> if requests mapped to servlets without
-     * "multipart config" to parse multipart/form-data requests anyway.
+     * Returns <code>true</code> if requests mapped to servlets without "multipart config" to parse multipart/form-data
+     * requests anyway.
      *
-     * @return <code>true</code> if requests mapped to servlets without
-     *    "multipart config" to parse multipart/form-data requests,
-     *    <code>false</code> otherwise.
+     * @return <code>true</code> if requests mapped to servlets without "multipart config" to parse multipart/form-data
+     *             requests, <code>false</code> otherwise.
      */
     @Override
     public boolean getAllowCasualMultipartParsing() {
@@ -1280,11 +1233,9 @@ public class StandardContext extends ContainerBase
     }
 
     /**
-     * Set to <code>false</code> to disable request data swallowing
-     * after an upload was aborted due to size constraints.
+     * Set to <code>false</code> to disable request data swallowing after an upload was aborted due to size constraints.
      *
-     * @param swallowAbortedUploads <code>false</code> to disable
-     *        swallowing, <code>true</code> otherwise (default).
+     * @param swallowAbortedUploads <code>false</code> to disable swallowing, <code>true</code> otherwise (default).
      */
     @Override
     public void setSwallowAbortedUploads(boolean swallowAbortedUploads) {
@@ -1292,11 +1243,10 @@ public class StandardContext extends ContainerBase
     }
 
     /**
-     * Returns <code>true</code> if remaining request data will be read
-     * (swallowed) even the request violates a data size constraint.
+     * Returns <code>true</code> if remaining request data will be read (swallowed) even the request violates a data
+     * size constraint.
      *
-     * @return <code>true</code> if data will be swallowed (default),
-     *    <code>false</code> otherwise.
+     * @return <code>true</code> if data will be swallowed (default), <code>false</code> otherwise.
      */
     @Override
     public boolean getSwallowAbortedUploads() {
@@ -1306,20 +1256,17 @@ public class StandardContext extends ContainerBase
     /**
      * Add a ServletContainerInitializer instance to this web application.
      *
-     * @param sci       The instance to add
-     * @param classes   The classes in which the initializer expressed an
-     *                  interest
+     * @param sci     The instance to add
+     * @param classes The classes in which the initializer expressed an interest
      */
     @Override
-    public void addServletContainerInitializer(
-            ServletContainerInitializer sci, Set<Class<?>> classes) {
+    public void addServletContainerInitializer(ServletContainerInitializer sci, Set<Class<?>> classes) {
         initializers.put(sci, classes);
     }
 
 
     /**
-     * Return the "follow standard delegation model" flag used to configure
-     * our ClassLoader.
+     * Return the "follow standard delegation model" flag used to configure our ClassLoader.
      *
      * @return <code>true</code> if classloading delegates to the parent classloader first
      */
@@ -1329,8 +1276,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Set the "follow standard delegation model" flag used to configure
-     * our ClassLoader.
+     * Set the "follow standard delegation model" flag used to configure our ClassLoader.
      *
      * @param delegate The new flag
      */
@@ -1338,8 +1284,7 @@ public class StandardContext extends ContainerBase
 
         boolean oldDelegate = this.delegate;
         this.delegate = delegate;
-        support.firePropertyChange("delegate", oldDelegate,
-                                   this.delegate);
+        support.firePropertyChange("delegate", oldDelegate, this.delegate);
 
     }
 
@@ -1369,11 +1314,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * {@inheritDoc}
-     *
-     * Note that this implementation is not thread safe. If two threads call
-     * this method concurrently, the result may be either set of listeners or a
-     * the union of both.
+     * {@inheritDoc} Note that this implementation is not thread safe. If two threads call this method concurrently, the
+     * result may be either set of listeners or a the union of both.
      */
     @Override
     public void setApplicationEventListeners(Object listeners[]) {
@@ -1385,8 +1327,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Add a listener to the end of the list of initialized application event
-     * listeners.
+     * Add a listener to the end of the list of initialized application event listeners.
      *
      * @param listener The listener to add
      */
@@ -1402,9 +1343,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Store the set of initialized application lifecycle listener objects,
-     * in the order they were specified in the web application deployment
-     * descriptor, for this application.
+     * Store the set of initialized application lifecycle listener objects, in the order they were specified in the web
+     * application deployment descriptor, for this application.
      *
      * @param listeners The set of instantiated listener objects.
      */
@@ -1415,15 +1355,13 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Add a listener to the end of the list of initialized application
-     * lifecycle listeners.
+     * Add a listener to the end of the list of initialized application lifecycle listeners.
      *
      * @param listener The listener to add
      */
     public void addApplicationLifecycleListener(Object listener) {
         int len = applicationLifecycleListenersObjects.length;
-        Object[] newListeners = Arrays.copyOf(
-                applicationLifecycleListenersObjects, len + 1);
+        Object[] newListeners = Arrays.copyOf(applicationLifecycleListenersObjects, len + 1);
         newListeners[len] = listener;
         applicationLifecycleListenersObjects = newListeners;
     }
@@ -1446,9 +1384,7 @@ public class StandardContext extends ContainerBase
 
         boolean oldAntiResourceLocking = this.antiResourceLocking;
         this.antiResourceLocking = antiResourceLocking;
-        support.firePropertyChange("antiResourceLocking",
-                                   oldAntiResourceLocking,
-                                   this.antiResourceLocking);
+        support.firePropertyChange("antiResourceLocking", oldAntiResourceLocking, this.antiResourceLocking);
 
     }
 
@@ -1500,11 +1436,10 @@ public class StandardContext extends ContainerBase
 
         CharsetMapper oldCharsetMapper = this.charsetMapper;
         this.charsetMapper = mapper;
-        if( mapper != null ) {
-            this.charsetMapperClass= mapper.getClass().getName();
+        if (mapper != null) {
+            this.charsetMapperClass = mapper.getClass().getName();
         }
-        support.firePropertyChange("charsetMapper", oldCharsetMapper,
-                                   this.charsetMapper);
+        support.firePropertyChange("charsetMapper", oldCharsetMapper, this.charsetMapper);
 
     }
 
@@ -1534,9 +1469,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Set the "correctly configured" flag for this Context.  This can be
-     * set to false by startup listeners that detect a fatal configuration
-     * error to avoid the application from being made available.
+     * Set the "correctly configured" flag for this Context. This can be set to false by startup listeners that detect a
+     * fatal configuration error to avoid the application from being made available.
      *
      * @param configured The new correctly configured flag
      */
@@ -1545,9 +1479,7 @@ public class StandardContext extends ContainerBase
 
         boolean oldConfigured = this.configured;
         this.configured = configured;
-        support.firePropertyChange("configured",
-                                   oldConfigured,
-                                   this.configured);
+        support.firePropertyChange("configured", oldConfigured, this.configured);
 
     }
 
@@ -1568,19 +1500,15 @@ public class StandardContext extends ContainerBase
 
         boolean oldCookies = this.cookies;
         this.cookies = cookies;
-        support.firePropertyChange("cookies",
-                                   oldCookies,
-                                   this.cookies);
+        support.firePropertyChange("cookies", oldCookies, this.cookies);
 
     }
 
 
     /**
-     * Gets the name to use for session cookies. Overrides any setting that
-     * may be specified by the application.
+     * Gets the name to use for session cookies. Overrides any setting that may be specified by the application.
      *
-     * @return  The value of the default session cookie name or null if not
-     *          specified
+     * @return The value of the default session cookie name or null if not specified
      */
     @Override
     public String getSessionCookieName() {
@@ -1589,25 +1517,22 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Sets the name to use for session cookies. Overrides any setting that
-     * may be specified by the application.
+     * Sets the name to use for session cookies. Overrides any setting that may be specified by the application.
      *
-     * @param sessionCookieName   The name to use
+     * @param sessionCookieName The name to use
      */
     @Override
     public void setSessionCookieName(String sessionCookieName) {
         String oldSessionCookieName = this.sessionCookieName;
         this.sessionCookieName = sessionCookieName;
-        support.firePropertyChange("sessionCookieName",
-                oldSessionCookieName, sessionCookieName);
+        support.firePropertyChange("sessionCookieName", oldSessionCookieName, sessionCookieName);
     }
 
 
     /**
      * Gets the value of the use HttpOnly cookies for session cookies flag.
      *
-     * @return <code>true</code> if the HttpOnly flag should be set on session
-     *         cookies
+     * @return <code>true</code> if the HttpOnly flag should be set on session cookies
      */
     @Override
     public boolean getUseHttpOnly() {
@@ -1618,25 +1543,20 @@ public class StandardContext extends ContainerBase
     /**
      * Sets the use HttpOnly cookies for session cookies flag.
      *
-     * @param useHttpOnly   Set to <code>true</code> to use HttpOnly cookies
-     *                          for session cookies
+     * @param useHttpOnly Set to <code>true</code> to use HttpOnly cookies for session cookies
      */
     @Override
     public void setUseHttpOnly(boolean useHttpOnly) {
         boolean oldUseHttpOnly = this.useHttpOnly;
         this.useHttpOnly = useHttpOnly;
-        support.firePropertyChange("useHttpOnly",
-                oldUseHttpOnly,
-                this.useHttpOnly);
+        support.firePropertyChange("useHttpOnly", oldUseHttpOnly, this.useHttpOnly);
     }
 
 
     /**
-     * Gets the domain to use for session cookies. Overrides any setting that
-     * may be specified by the application.
+     * Gets the domain to use for session cookies. Overrides any setting that may be specified by the application.
      *
-     * @return  The value of the default session cookie domain or null if not
-     *          specified
+     * @return The value of the default session cookie domain or null if not specified
      */
     @Override
     public String getSessionCookieDomain() {
@@ -1645,26 +1565,22 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Sets the domain to use for session cookies. Overrides any setting that
-     * may be specified by the application.
+     * Sets the domain to use for session cookies. Overrides any setting that may be specified by the application.
      *
-     * @param sessionCookieDomain   The domain to use
+     * @param sessionCookieDomain The domain to use
      */
     @Override
     public void setSessionCookieDomain(String sessionCookieDomain) {
         String oldSessionCookieDomain = this.sessionCookieDomain;
         this.sessionCookieDomain = sessionCookieDomain;
-        support.firePropertyChange("sessionCookieDomain",
-                oldSessionCookieDomain, sessionCookieDomain);
+        support.firePropertyChange("sessionCookieDomain", oldSessionCookieDomain, sessionCookieDomain);
     }
 
 
     /**
-     * Gets the path to use for session cookies. Overrides any setting that
-     * may be specified by the application.
+     * Gets the path to use for session cookies. Overrides any setting that may be specified by the application.
      *
-     * @return  The value of the default session cookie path or null if not
-     *          specified
+     * @return The value of the default session cookie path or null if not specified
      */
     @Override
     public String getSessionCookiePath() {
@@ -1673,17 +1589,15 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Sets the path to use for session cookies. Overrides any setting that
-     * may be specified by the application.
+     * Sets the path to use for session cookies. Overrides any setting that may be specified by the application.
      *
-     * @param sessionCookiePath   The path to use
+     * @param sessionCookiePath The path to use
      */
     @Override
     public void setSessionCookiePath(String sessionCookiePath) {
         String oldSessionCookiePath = this.sessionCookiePath;
         this.sessionCookiePath = sessionCookiePath;
-        support.firePropertyChange("sessionCookiePath",
-                oldSessionCookiePath, sessionCookiePath);
+        support.firePropertyChange("sessionCookiePath", oldSessionCookiePath, sessionCookiePath);
     }
 
 
@@ -1694,10 +1608,8 @@ public class StandardContext extends ContainerBase
 
 
     @Override
-    public void setSessionCookiePathUsesTrailingSlash(
-            boolean sessionCookiePathUsesTrailingSlash) {
-        this.sessionCookiePathUsesTrailingSlash =
-            sessionCookiePathUsesTrailingSlash;
+    public void setSessionCookiePathUsesTrailingSlash(boolean sessionCookiePathUsesTrailingSlash) {
+        this.sessionCookiePathUsesTrailingSlash = sessionCookiePathUsesTrailingSlash;
     }
 
 
@@ -1717,9 +1629,7 @@ public class StandardContext extends ContainerBase
 
         boolean oldCrossContext = this.crossContext;
         this.crossContext = crossContext;
-        support.firePropertyChange("crossContext",
-                                   oldCrossContext,
-                                   this.crossContext);
+        support.firePropertyChange("crossContext", oldCrossContext, this.crossContext);
 
     }
 
@@ -1728,9 +1638,8 @@ public class StandardContext extends ContainerBase
     }
 
     /**
-     * Set the location of the default context xml that will be used.
-     * If not absolute, it'll be made relative to the engine's base dir
-     * ( which defaults to catalina.base system property ).
+     * Set the location of the default context xml that will be used. If not absolute, it'll be made relative to the
+     * engine's base dir ( which defaults to catalina.base system property ).
      *
      * @param defaultContextXml The default web xml
      */
@@ -1743,9 +1652,8 @@ public class StandardContext extends ContainerBase
     }
 
     /**
-     * Set the location of the default web xml that will be used.
-     * If not absolute, it'll be made relative to the engine's base dir
-     * ( which defaults to catalina.base system property ).
+     * Set the location of the default web xml that will be used. If not absolute, it'll be made relative to the
+     * engine's base dir ( which defaults to catalina.base system property ).
      *
      * @param defaultWebXml The default web xml
      */
@@ -1800,7 +1708,7 @@ public class StandardContext extends ContainerBase
      * @return the alternate Deployment Descriptor name.
      */
     @Override
-    public String getAltDDName(){
+    public String getAltDDName() {
         return altDDName;
     }
 
@@ -1814,7 +1722,7 @@ public class StandardContext extends ContainerBase
     public void setAltDDName(String altDDName) {
         this.altDDName = altDDName;
         if (context != null) {
-            context.setAttribute(Globals.ALT_DD_ATTR,altDDName);
+            context.setAttribute(Globals.ALT_DD_ATTR, altDDName);
         }
     }
 
@@ -1829,8 +1737,7 @@ public class StandardContext extends ContainerBase
 
         String oldDisplayName = this.displayName;
         this.displayName = displayName;
-        support.firePropertyChange("displayName", oldDisplayName,
-                                   this.displayName);
+        support.firePropertyChange("displayName", oldDisplayName, this.displayName);
     }
 
 
@@ -1851,9 +1758,7 @@ public class StandardContext extends ContainerBase
     public void setDistributable(boolean distributable) {
         boolean oldDistributable = this.distributable;
         this.distributable = distributable;
-        support.firePropertyChange("distributable",
-                                   oldDistributable,
-                                   this.distributable);
+        support.firePropertyChange("distributable", oldDistributable, this.distributable);
     }
 
 
@@ -1912,8 +1817,7 @@ public class StandardContext extends ContainerBase
             this.loader = loader;
 
             // Stop the old component if necessary
-            if (getState().isAvailable() && (oldLoader != null) &&
-                (oldLoader instanceof Lifecycle)) {
+            if (getState().isAvailable() && (oldLoader != null) && (oldLoader instanceof Lifecycle)) {
                 try {
                     ((Lifecycle) oldLoader).stop();
                 } catch (LifecycleException e) {
@@ -1925,8 +1829,7 @@ public class StandardContext extends ContainerBase
             if (loader != null) {
                 loader.setContext(this);
             }
-            if (getState().isAvailable() && (loader != null) &&
-                (loader instanceof Lifecycle)) {
+            if (getState().isAvailable() && (loader != null) && (loader instanceof Lifecycle)) {
                 try {
                     ((Lifecycle) loader).start();
                 } catch (LifecycleException e) {
@@ -2008,8 +1911,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Set the boolean on the annotations parsing for this web
-     * application.
+     * Set the boolean on the annotations parsing for this web application.
      *
      * @param ignoreAnnotations The boolean on the annotations parsing
      */
@@ -2017,8 +1919,7 @@ public class StandardContext extends ContainerBase
     public void setIgnoreAnnotations(boolean ignoreAnnotations) {
         boolean oldIgnoreAnnotations = this.ignoreAnnotations;
         this.ignoreAnnotations = ignoreAnnotations;
-        support.firePropertyChange("ignoreAnnotations", oldIgnoreAnnotations,
-                this.ignoreAnnotations);
+        support.firePropertyChange("ignoreAnnotations", oldIgnoreAnnotations, this.ignoreAnnotations);
     }
 
 
@@ -2032,8 +1933,7 @@ public class StandardContext extends ContainerBase
     public void setMetadataComplete(boolean metadataComplete) {
         boolean oldMetadataComplete = this.metadataComplete;
         this.metadataComplete = metadataComplete;
-        support.firePropertyChange("metadataComplete", oldMetadataComplete,
-                this.metadataComplete);
+        support.firePropertyChange("metadataComplete", oldMetadataComplete, this.metadataComplete);
     }
 
 
@@ -2056,43 +1956,35 @@ public class StandardContext extends ContainerBase
 
         // Validate the incoming property value
         if (config == null) {
-            throw new IllegalArgumentException
-                (sm.getString("standardContext.loginConfig.required"));
+            throw new IllegalArgumentException(sm.getString("standardContext.loginConfig.required"));
         }
         String loginPage = config.getLoginPage();
         if ((loginPage != null) && !loginPage.startsWith("/")) {
             if (isServlet22()) {
-                if(log.isDebugEnabled()) {
-                    log.debug(sm.getString("standardContext.loginConfig.loginWarning",
-                                 loginPage));
+                if (log.isDebugEnabled()) {
+                    log.debug(sm.getString("standardContext.loginConfig.loginWarning", loginPage));
                 }
                 config.setLoginPage("/" + loginPage);
             } else {
-                throw new IllegalArgumentException
-                    (sm.getString("standardContext.loginConfig.loginPage",
-                                  loginPage));
+                throw new IllegalArgumentException(sm.getString("standardContext.loginConfig.loginPage", loginPage));
             }
         }
         String errorPage = config.getErrorPage();
         if ((errorPage != null) && !errorPage.startsWith("/")) {
             if (isServlet22()) {
-                if(log.isDebugEnabled()) {
-                    log.debug(sm.getString("standardContext.loginConfig.errorWarning",
-                                 errorPage));
+                if (log.isDebugEnabled()) {
+                    log.debug(sm.getString("standardContext.loginConfig.errorWarning", errorPage));
                 }
                 config.setErrorPage("/" + errorPage);
             } else {
-                throw new IllegalArgumentException
-                    (sm.getString("standardContext.loginConfig.errorPage",
-                                  errorPage));
+                throw new IllegalArgumentException(sm.getString("standardContext.loginConfig.errorPage", errorPage));
             }
         }
 
         // Process the property setting change
         LoginConfig oldLoginConfig = this.loginConfig;
         this.loginConfig = config;
-        support.firePropertyChange("loginConfig",
-                                   oldLoginConfig, this.loginConfig);
+        support.firePropertyChange("loginConfig", oldLoginConfig, this.loginConfig);
 
     }
 
@@ -2123,11 +2015,9 @@ public class StandardContext extends ContainerBase
         if (namingResources != null) {
             namingResources.setContainer(this);
         }
-        support.firePropertyChange("namingResources",
-                                   oldNamingResources, this.namingResources);
+        support.firePropertyChange("namingResources", oldNamingResources, this.namingResources);
 
-        if (getState() == LifecycleState.NEW ||
-                getState() == LifecycleState.INITIALIZING ||
+        if (getState() == LifecycleState.NEW || getState() == LifecycleState.INITIALIZING ||
                 getState() == LifecycleState.INITIALIZED) {
             // NEW will occur if Context is defined in server.xml
             // At this point getObjectKeyPropertiesNameOnly() will trigger an
@@ -2192,8 +2082,7 @@ public class StandardContext extends ContainerBase
             this.path = this.path.substring(0, this.path.length() - 1);
         }
         if (invalid) {
-            log.warn(sm.getString(
-                    "standardContext.pathInvalid", path, this.path));
+            log.warn(sm.getString("standardContext.pathInvalid", path, this.path));
         }
         encodedPath = URLEncoder.DEFAULT.encode(this.path, StandardCharsets.UTF_8);
         if (getName() == null) {
@@ -2203,8 +2092,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the public identifier of the deployment descriptor DTD that is
-     * currently being parsed.
+     * @return the public identifier of the deployment descriptor DTD that is currently being parsed.
      */
     @Override
     public String getPublicId() {
@@ -2213,8 +2101,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Set the public identifier of the deployment descriptor DTD that is
-     * currently being parsed.
+     * Set the public identifier of the deployment descriptor DTD that is currently being parsed.
      *
      * @param publicId The public identifier
      */
@@ -2222,8 +2109,7 @@ public class StandardContext extends ContainerBase
     public void setPublicId(String publicId) {
 
         if (log.isDebugEnabled()) {
-            log.debug("Setting deployment descriptor public ID to '" +
-                publicId + "'");
+            log.debug("Setting deployment descriptor public ID to '" + publicId + "'");
         }
 
         String oldPublicId = this.publicId;
@@ -2252,17 +2138,15 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the original document root for this Context.  This can be an absolute
-     * pathname, a relative pathname, or a URL.
-     * Is only set as deployment has change docRoot!
+     * @return the original document root for this Context. This can be an absolute pathname, a relative pathname, or a
+     *             URL. Is only set as deployment has change docRoot!
      */
     public String getOriginalDocBase() {
         return this.originalDocBase;
     }
 
     /**
-     * Set the original document root for this Context.  This can be an absolute
-     * pathname, a relative pathname, or a URL.
+     * Set the original document root for this Context. This can be an absolute pathname, a relative pathname, or a URL.
      *
      * @param docBase The original document root
      */
@@ -2273,9 +2157,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the parent class loader (if any) for this web application.
-     * This call is meaningful only <strong>after</strong> a Loader has
-     * been configured.
+     * @return the parent class loader (if any) for this web application. This call is meaningful only
+     *             <strong>after</strong> a Loader has been configured.
      */
     @Override
     public ClassLoader getParentClassLoader() {
@@ -2310,9 +2193,7 @@ public class StandardContext extends ContainerBase
 
         boolean oldPrivileged = this.privileged;
         this.privileged = privileged;
-        support.firePropertyChange("privileged",
-                                   oldPrivileged,
-                                   this.privileged);
+        support.firePropertyChange("privileged", oldPrivileged, this.privileged);
 
     }
 
@@ -2327,9 +2208,7 @@ public class StandardContext extends ContainerBase
 
         boolean oldReloadable = this.reloadable;
         this.reloadable = reloadable;
-        support.firePropertyChange("reloadable",
-                                   oldReloadable,
-                                   this.reloadable);
+        support.firePropertyChange("reloadable", oldReloadable, this.reloadable);
 
     }
 
@@ -2344,9 +2223,7 @@ public class StandardContext extends ContainerBase
 
         boolean oldOverride = this.override;
         this.override = override;
-        support.firePropertyChange("override",
-                                   oldOverride,
-                                   this.override);
+        support.firePropertyChange("override", oldOverride, this.override);
 
     }
 
@@ -2360,9 +2237,7 @@ public class StandardContext extends ContainerBase
 
         boolean oldReplaceWelcomeFiles = this.replaceWelcomeFiles;
         this.replaceWelcomeFiles = replaceWelcomeFiles;
-        support.firePropertyChange("replaceWelcomeFiles",
-                                   oldReplaceWelcomeFiles,
-                                   this.replaceWelcomeFiles);
+        support.firePropertyChange("replaceWelcomeFiles", oldReplaceWelcomeFiles, this.replaceWelcomeFiles);
 
     }
 
@@ -2375,7 +2250,7 @@ public class StandardContext extends ContainerBase
         if (context == null) {
             context = new ApplicationContext(this);
             if (altDDName != null) {
-                context.setAttribute(Globals.ALT_DD_ATTR,altDDName);
+                context.setAttribute(Globals.ALT_DD_ATTR, altDDName);
             }
         }
         return context.getFacade();
@@ -2383,8 +2258,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the default session timeout (in minutes) for this
-     * web application.
+     * @return the default session timeout (in minutes) for this web application.
      */
     @Override
     public int getSessionTimeout() {
@@ -2393,8 +2267,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Set the default session timeout (in minutes) for this
-     * web application.
+     * Set the default session timeout (in minutes) for this web application.
      *
      * @param timeout The new default session timeout
      */
@@ -2403,14 +2276,11 @@ public class StandardContext extends ContainerBase
 
         int oldSessionTimeout = this.sessionTimeout;
         /*
-         * SRV.13.4 ("Deployment Descriptor"):
-         * If the timeout is 0 or less, the container ensures the default
-         * behaviour of sessions is never to time out.
+         * SRV.13.4 ("Deployment Descriptor"): If the timeout is 0 or less, the container ensures the default behaviour
+         * of sessions is never to time out.
          */
         this.sessionTimeout = (timeout == 0) ? -1 : timeout;
-        support.firePropertyChange("sessionTimeout",
-                                   oldSessionTimeout,
-                                   this.sessionTimeout);
+        support.firePropertyChange("sessionTimeout", oldSessionTimeout, this.sessionTimeout);
 
     }
 
@@ -2425,9 +2295,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Set the value of the swallowOutput flag. If set to true, the system.out
-     * and system.err will be redirected to the logger during a servlet
-     * execution.
+     * Set the value of the swallowOutput flag. If set to true, the system.out and system.err will be redirected to the
+     * logger during a servlet execution.
      *
      * @param swallowOutput The new value
      */
@@ -2436,9 +2305,7 @@ public class StandardContext extends ContainerBase
 
         boolean oldSwallowOutput = this.swallowOutput;
         this.swallowOutput = swallowOutput;
-        support.firePropertyChange("swallowOutput",
-                                   oldSwallowOutput,
-                                   this.swallowOutput);
+        support.firePropertyChange("swallowOutput", oldSwallowOutput, this.swallowOutput);
 
     }
 
@@ -2452,10 +2319,9 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Set the value of the unloadDelay flag, which represents the amount
-     * of ms that the container will wait when unloading servlets.
-     * Setting this to a small value may cause more requests to fail
-     * to complete when stopping a web application.
+     * Set the value of the unloadDelay flag, which represents the amount of ms that the container will wait when
+     * unloading servlets. Setting this to a small value may cause more requests to fail to complete when stopping a web
+     * application.
      *
      * @param unloadDelay The new value
      */
@@ -2463,9 +2329,7 @@ public class StandardContext extends ContainerBase
 
         long oldUnloadDelay = this.unloadDelay;
         this.unloadDelay = unloadDelay;
-        support.firePropertyChange("unloadDelay",
-                                   Long.valueOf(oldUnloadDelay),
-                                   Long.valueOf(this.unloadDelay));
+        support.firePropertyChange("unloadDelay", Long.valueOf(oldUnloadDelay), Long.valueOf(this.unloadDelay));
 
     }
 
@@ -2489,11 +2353,11 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Flag which indicates if bundled context.xml files should be copied to the
-     * config folder. The doesn't occur by default.
+     * Flag which indicates if bundled context.xml files should be copied to the config folder. The doesn't occur by
+     * default.
      *
-     * @return <code>true</code> if the <code>META-INF/context.xml</code> file included
-     *     in a WAR will be copied to the host configuration base folder on deployment
+     * @return <code>true</code> if the <code>META-INF/context.xml</code> file included in a WAR will be copied to the
+     *             host configuration base folder on deployment
      */
     public boolean getCopyXML() {
         return copyXML;
@@ -2501,8 +2365,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Allows copying a bundled context.xml file to the host configuration base
-     * folder on deployment.
+     * Allows copying a bundled context.xml file to the host configuration base folder on deployment.
      *
      * @param copyXML the new flag value
      */
@@ -2512,8 +2375,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the Java class name of the Wrapper implementation used
-     * for servlets registered in this Context.
+     * @return the Java class name of the Wrapper implementation used for servlets registered in this Context.
      */
     @Override
     public String getWrapperClass() {
@@ -2522,13 +2384,12 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Set the Java class name of the Wrapper implementation used
-     * for servlets registered in this Context.
+     * Set the Java class name of the Wrapper implementation used for servlets registered in this Context.
      *
      * @param wrapperClassName The new wrapper class name
      *
-     * @throws IllegalArgumentException if the specified wrapper class
-     * cannot be found or is not a subclass of StandardWrapper
+     * @throws IllegalArgumentException if the specified wrapper class cannot be found or is not a subclass of
+     *                                      StandardWrapper
      */
     @Override
     public void setWrapperClass(String wrapperClassName) {
@@ -2539,8 +2400,7 @@ public class StandardContext extends ContainerBase
             wrapperClass = Class.forName(wrapperClassName);
             if (!StandardWrapper.class.isAssignableFrom(wrapperClass)) {
                 throw new IllegalArgumentException(
-                    sm.getString("standardContext.invalidWrapperClass",
-                                 wrapperClassName));
+                        sm.getString("standardContext.invalidWrapperClass", wrapperClassName));
             }
         } catch (ClassNotFoundException cnfe) {
             throw new IllegalArgumentException(cnfe.getMessage());
@@ -2568,8 +2428,7 @@ public class StandardContext extends ContainerBase
         WebResourceRoot oldResources = null;
         try {
             if (getState().isAvailable()) {
-                throw new IllegalStateException
-                    (sm.getString("standardContext.resourcesStart"));
+                throw new IllegalStateException(sm.getString("standardContext.resourcesStart"));
             }
 
             oldResources = this.resources;
@@ -2585,8 +2444,7 @@ public class StandardContext extends ContainerBase
                 resources.setContext(this);
             }
 
-            support.firePropertyChange("resources", oldResources,
-                    resources);
+            support.firePropertyChange("resources", oldResources, resources);
         } finally {
             writeLock.unlock();
         }
@@ -2617,8 +2475,8 @@ public class StandardContext extends ContainerBase
     // ------------------------------------------------------ Public Properties
 
     /**
-     * @return whether or not an attempt to modify the JNDI context will trigger
-     * an exception or if the request will be ignored.
+     * @return whether or not an attempt to modify the JNDI context will trigger an exception or if the request will be
+     *             ignored.
      */
     public boolean getJndiExceptionOnFailedWrite() {
         return jndiExceptionOnFailedWrite;
@@ -2626,13 +2484,12 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Controls whether or not an attempt to modify the JNDI context will
-     * trigger an exception or if the request will be ignored.
+     * Controls whether or not an attempt to modify the JNDI context will trigger an exception or if the request will be
+     * ignored.
      *
      * @param jndiExceptionOnFailedWrite <code>false</code> to avoid an exception
      */
-    public void setJndiExceptionOnFailedWrite(
-            boolean jndiExceptionOnFailedWrite) {
+    public void setJndiExceptionOnFailedWrite(boolean jndiExceptionOnFailedWrite) {
         this.jndiExceptionOnFailedWrite = jndiExceptionOnFailedWrite;
     }
 
@@ -2654,9 +2511,7 @@ public class StandardContext extends ContainerBase
 
         String oldCharsetMapperClass = this.charsetMapperClass;
         this.charsetMapperClass = mapper;
-        support.firePropertyChange("charsetMapperClass",
-                                   oldCharsetMapperClass,
-                                   this.charsetMapperClass);
+        support.firePropertyChange("charsetMapperClass", oldCharsetMapperClass, this.charsetMapperClass);
 
     }
 
@@ -2673,11 +2528,9 @@ public class StandardContext extends ContainerBase
         File workDir = new File(getWorkDir());
         if (!workDir.isAbsolute()) {
             try {
-                workDir = new File(getCatalinaBase().getCanonicalFile(),
-                        getWorkDir());
+                workDir = new File(getCatalinaBase().getCanonicalFile(), getWorkDir());
             } catch (IOException e) {
-                log.warn(sm.getString("standardContext.workPath", getName()),
-                        e);
+                log.warn(sm.getString("standardContext.workPath", getName()), e);
             }
         }
         return workDir.getAbsolutePath();
@@ -2714,8 +2567,8 @@ public class StandardContext extends ContainerBase
     public void setClearReferencesRmiTargets(boolean clearReferencesRmiTargets) {
         boolean oldClearReferencesRmiTargets = this.clearReferencesRmiTargets;
         this.clearReferencesRmiTargets = clearReferencesRmiTargets;
-        support.firePropertyChange("clearReferencesRmiTargets",
-                oldClearReferencesRmiTargets, this.clearReferencesRmiTargets);
+        support.firePropertyChange("clearReferencesRmiTargets", oldClearReferencesRmiTargets,
+                this.clearReferencesRmiTargets);
     }
 
 
@@ -2732,14 +2585,12 @@ public class StandardContext extends ContainerBase
      *
      * @param clearReferencesStopThreads The new flag value
      */
-    public void setClearReferencesStopThreads(
-            boolean clearReferencesStopThreads) {
+    public void setClearReferencesStopThreads(boolean clearReferencesStopThreads) {
 
         boolean oldClearReferencesStopThreads = this.clearReferencesStopThreads;
         this.clearReferencesStopThreads = clearReferencesStopThreads;
-        support.firePropertyChange("clearReferencesStopThreads",
-                                   oldClearReferencesStopThreads,
-                                   this.clearReferencesStopThreads);
+        support.firePropertyChange("clearReferencesStopThreads", oldClearReferencesStopThreads,
+                this.clearReferencesStopThreads);
 
     }
 
@@ -2757,21 +2608,17 @@ public class StandardContext extends ContainerBase
      *
      * @param clearReferencesStopTimerThreads The new flag value
      */
-    public void setClearReferencesStopTimerThreads(
-            boolean clearReferencesStopTimerThreads) {
+    public void setClearReferencesStopTimerThreads(boolean clearReferencesStopTimerThreads) {
 
-        boolean oldClearReferencesStopTimerThreads =
-            this.clearReferencesStopTimerThreads;
+        boolean oldClearReferencesStopTimerThreads = this.clearReferencesStopTimerThreads;
         this.clearReferencesStopTimerThreads = clearReferencesStopTimerThreads;
-        support.firePropertyChange("clearReferencesStopTimerThreads",
-                                   oldClearReferencesStopTimerThreads,
-                                   this.clearReferencesStopTimerThreads);
+        support.firePropertyChange("clearReferencesStopTimerThreads", oldClearReferencesStopTimerThreads,
+                this.clearReferencesStopTimerThreads);
     }
 
 
     /**
-     * @return the clearReferencesHttpClientKeepAliveThread flag for this
-     * Context.
+     * @return the clearReferencesHttpClientKeepAliveThread flag for this Context.
      */
     public boolean getClearReferencesHttpClientKeepAliveThread() {
         return this.clearReferencesHttpClientKeepAliveThread;
@@ -2779,15 +2626,12 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Set the clearReferencesHttpClientKeepAliveThread feature for this
-     * Context.
+     * Set the clearReferencesHttpClientKeepAliveThread feature for this Context.
      *
      * @param clearReferencesHttpClientKeepAliveThread The new flag value
      */
-    public void setClearReferencesHttpClientKeepAliveThread(
-            boolean clearReferencesHttpClientKeepAliveThread) {
-        this.clearReferencesHttpClientKeepAliveThread =
-            clearReferencesHttpClientKeepAliveThread;
+    public void setClearReferencesHttpClientKeepAliveThread(boolean clearReferencesHttpClientKeepAliveThread) {
+        this.clearReferencesHttpClientKeepAliveThread = clearReferencesHttpClientKeepAliveThread;
     }
 
 
@@ -2795,13 +2639,10 @@ public class StandardContext extends ContainerBase
         return this.renewThreadsWhenStoppingContext;
     }
 
-    public void setRenewThreadsWhenStoppingContext(
-            boolean renewThreadsWhenStoppingContext) {
-        boolean oldRenewThreadsWhenStoppingContext =
-                this.renewThreadsWhenStoppingContext;
+    public void setRenewThreadsWhenStoppingContext(boolean renewThreadsWhenStoppingContext) {
+        boolean oldRenewThreadsWhenStoppingContext = this.renewThreadsWhenStoppingContext;
         this.renewThreadsWhenStoppingContext = renewThreadsWhenStoppingContext;
-        support.firePropertyChange("renewThreadsWhenStoppingContext",
-                oldRenewThreadsWhenStoppingContext,
+        support.firePropertyChange("renewThreadsWhenStoppingContext", oldRenewThreadsWhenStoppingContext,
                 this.renewThreadsWhenStoppingContext);
     }
 
@@ -2811,13 +2652,10 @@ public class StandardContext extends ContainerBase
     }
 
 
-    public void setClearReferencesObjectStreamClassCaches(
-            boolean clearReferencesObjectStreamClassCaches) {
-        boolean oldClearReferencesObjectStreamClassCaches =
-                this.clearReferencesObjectStreamClassCaches;
+    public void setClearReferencesObjectStreamClassCaches(boolean clearReferencesObjectStreamClassCaches) {
+        boolean oldClearReferencesObjectStreamClassCaches = this.clearReferencesObjectStreamClassCaches;
         this.clearReferencesObjectStreamClassCaches = clearReferencesObjectStreamClassCaches;
-        support.firePropertyChange("clearReferencesObjectStreamClassCaches",
-                oldClearReferencesObjectStreamClassCaches,
+        support.firePropertyChange("clearReferencesObjectStreamClassCaches", oldClearReferencesObjectStreamClassCaches,
                 this.clearReferencesObjectStreamClassCaches);
     }
 
@@ -2830,8 +2668,7 @@ public class StandardContext extends ContainerBase
     public void setClearReferencesThreadLocals(boolean clearReferencesThreadLocals) {
         boolean oldClearReferencesThreadLocals = this.clearReferencesThreadLocals;
         this.clearReferencesThreadLocals = clearReferencesThreadLocals;
-        support.firePropertyChange("clearReferencesThreadLocals",
-                oldClearReferencesThreadLocals,
+        support.firePropertyChange("clearReferencesThreadLocals", oldClearReferencesThreadLocals,
                 this.clearReferencesThreadLocals);
     }
 
@@ -2850,32 +2687,29 @@ public class StandardContext extends ContainerBase
         return failCtxIfServletStartFails;
     }
 
-    public void setFailCtxIfServletStartFails(
-            Boolean failCtxIfServletStartFails) {
+    public void setFailCtxIfServletStartFails(Boolean failCtxIfServletStartFails) {
         Boolean oldFailCtxIfServletStartFails = this.failCtxIfServletStartFails;
         this.failCtxIfServletStartFails = failCtxIfServletStartFails;
-        support.firePropertyChange("failCtxIfServletStartFails",
-                oldFailCtxIfServletStartFails,
+        support.firePropertyChange("failCtxIfServletStartFails", oldFailCtxIfServletStartFails,
                 failCtxIfServletStartFails);
     }
 
     protected boolean getComputedFailCtxIfServletStartFails() {
-        if(failCtxIfServletStartFails != null) {
+        if (failCtxIfServletStartFails != null) {
             return failCtxIfServletStartFails.booleanValue();
         }
-        //else look at Host config
-        if(getParent() instanceof StandardHost) {
-            return ((StandardHost)getParent()).isFailCtxIfServletStartFails();
+        // else look at Host config
+        if (getParent() instanceof StandardHost) {
+            return ((StandardHost) getParent()).isFailCtxIfServletStartFails();
         }
-        //else
+        // else
         return false;
     }
 
     // -------------------------------------------------------- Context Methods
 
     /**
-     * Add a new Listener class name to the set of Listeners
-     * configured for this application.
+     * Add a new Listener class name to the set of Listeners configured for this application.
      *
      * @param listener Java class name of a listener class
      */
@@ -2886,7 +2720,7 @@ public class StandardContext extends ContainerBase
             String results[] = new String[applicationListeners.length + 1];
             for (int i = 0; i < applicationListeners.length; i++) {
                 if (listener.equals(applicationListeners[i])) {
-                    log.info(sm.getString("standardContext.duplicateListener",listener));
+                    log.info(sm.getString("standardContext.duplicateListener", listener));
                     return;
                 }
                 results[i] = applicationListeners[i];
@@ -2914,8 +2748,7 @@ public class StandardContext extends ContainerBase
                     return;
                 }
             }
-            ApplicationParameter results[] = Arrays.copyOf(
-                    applicationParameters, applicationParameters.length + 1);
+            ApplicationParameter results[] = Arrays.copyOf(applicationParameters, applicationParameters.length + 1);
             results[applicationParameters.length] = parameter;
             applicationParameters = results;
         }
@@ -2925,13 +2758,11 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Add a child Container, only if the proposed child is an implementation
-     * of Wrapper.
+     * Add a child Container, only if the proposed child is an implementation of Wrapper.
      *
      * @param child Child container to be added
      *
-     * @exception IllegalArgumentException if the proposed container is
-     *  not an implementation of Wrapper
+     * @exception IllegalArgumentException if the proposed container is not an implementation of Wrapper
      */
     @Override
     public void addChild(Container child) {
@@ -2940,8 +2771,7 @@ public class StandardContext extends ContainerBase
         Wrapper oldJspServlet = null;
 
         if (!(child instanceof Wrapper)) {
-            throw new IllegalArgumentException
-                (sm.getString("standardContext.notWrapper"));
+            throw new IllegalArgumentException(sm.getString("standardContext.notWrapper"));
         }
 
         boolean isJspServlet = "jsp".equals(child.getName());
@@ -2958,11 +2788,11 @@ public class StandardContext extends ContainerBase
 
         if (isJspServlet && oldJspServlet != null) {
             /*
-             * The webapp-specific JspServlet inherits all the mappings
-             * specified in the global web.xml, and may add additional ones.
+             * The webapp-specific JspServlet inherits all the mappings specified in the global web.xml, and may add
+             * additional ones.
              */
             String[] jspMappings = oldJspServlet.findMappings();
-            for (int i=0; jspMappings!=null && i<jspMappings.length; i++) {
+            for (int i = 0; jspMappings != null && i < jspMappings.length; i++) {
                 addServletMappingDecoded(jspMappings[i], child.getName());
             }
         }
@@ -2984,16 +2814,12 @@ public class StandardContext extends ContainerBase
             for (int j = 0; j < patterns.length; j++) {
                 patterns[j] = adjustURLPattern(patterns[j]);
                 if (!validateURLPattern(patterns[j])) {
-                    throw new IllegalArgumentException
-                            (sm.getString
-                                    ("standardContext.securityConstraint.pattern",
-                                            patterns[j]));
+                    throw new IllegalArgumentException(
+                            sm.getString("standardContext.securityConstraint.pattern", patterns[j]));
                 }
             }
-            if (collection.findMethods().length > 0 &&
-                    collection.findOmittedMethods().length > 0) {
-                throw new IllegalArgumentException(sm.getString(
-                        "standardContext.securityConstraint.mixHttpMethod"));
+            if (collection.findMethods().length > 0 && collection.findOmittedMethods().length > 0) {
+                throw new IllegalArgumentException(sm.getString("standardContext.securityConstraint.mixHttpMethod"));
             }
         }
 
@@ -3007,7 +2833,6 @@ public class StandardContext extends ContainerBase
     }
 
 
-
     /**
      * Add an error page for the specified error or Java exception.
      *
@@ -3017,21 +2842,17 @@ public class StandardContext extends ContainerBase
     public void addErrorPage(ErrorPage errorPage) {
         // Validate the input parameters
         if (errorPage == null) {
-            throw new IllegalArgumentException
-                (sm.getString("standardContext.errorPage.required"));
+            throw new IllegalArgumentException(sm.getString("standardContext.errorPage.required"));
         }
         String location = errorPage.getLocation();
         if ((location != null) && !location.startsWith("/")) {
             if (isServlet22()) {
-                if(log.isDebugEnabled()) {
-                    log.debug(sm.getString("standardContext.errorPage.warning",
-                                 location));
+                if (log.isDebugEnabled()) {
+                    log.debug(sm.getString("standardContext.errorPage.warning", location));
                 }
                 errorPage.setLocation("/" + location);
             } else {
-                throw new IllegalArgumentException
-                    (sm.getString("standardContext.errorPage.error",
-                                  location));
+                throw new IllegalArgumentException(sm.getString("standardContext.errorPage.error", location));
             }
         }
 
@@ -3057,14 +2878,12 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Add a filter mapping to this Context at the end of the current set
-     * of filter mappings.
+     * Add a filter mapping to this Context at the end of the current set of filter mappings.
      *
      * @param filterMap The filter mapping to be added
      *
-     * @exception IllegalArgumentException if the specified filter name
-     *  does not match an existing filter definition, or the filter mapping
-     *  is malformed
+     * @exception IllegalArgumentException if the specified filter name does not match an existing filter definition, or
+     *                                         the filter mapping is malformed
      */
     @Override
     public void addFilterMap(FilterMap filterMap) {
@@ -3076,14 +2895,13 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Add a filter mapping to this Context before the mappings defined in the
-     * deployment descriptor but after any other mappings added via this method.
+     * Add a filter mapping to this Context before the mappings defined in the deployment descriptor but after any other
+     * mappings added via this method.
      *
      * @param filterMap The filter mapping to be added
      *
-     * @exception IllegalArgumentException if the specified filter name
-     *  does not match an existing filter definition, or the filter mapping
-     *  is malformed
+     * @exception IllegalArgumentException if the specified filter name does not match an existing filter definition, or
+     *                                         the filter mapping is malformed
      */
     @Override
     public void addFilterMapBefore(FilterMap filterMap) {
@@ -3105,21 +2923,16 @@ public class StandardContext extends ContainerBase
         String[] servletNames = filterMap.getServletNames();
         String[] urlPatterns = filterMap.getURLPatterns();
         if (findFilterDef(filterName) == null) {
-            throw new IllegalArgumentException
-                (sm.getString("standardContext.filterMap.name", filterName));
+            throw new IllegalArgumentException(sm.getString("standardContext.filterMap.name", filterName));
         }
 
-        if (!filterMap.getMatchAllServletNames() &&
-            !filterMap.getMatchAllUrlPatterns() &&
-            (servletNames.length == 0) && (urlPatterns.length == 0)) {
-            throw new IllegalArgumentException
-                (sm.getString("standardContext.filterMap.either"));
+        if (!filterMap.getMatchAllServletNames() && !filterMap.getMatchAllUrlPatterns() && (servletNames.length == 0) &&
+                (urlPatterns.length == 0)) {
+            throw new IllegalArgumentException(sm.getString("standardContext.filterMap.either"));
         }
         for (String urlPattern : urlPatterns) {
             if (!validateURLPattern(urlPattern)) {
-                throw new IllegalArgumentException
-                        (sm.getString("standardContext.filterMap.pattern",
-                                urlPattern));
+                throw new IllegalArgumentException(sm.getString("standardContext.filterMap.pattern", urlPattern));
             }
         }
     }
@@ -3128,11 +2941,11 @@ public class StandardContext extends ContainerBase
     /**
      * Add a Locale Encoding Mapping (see Sec 5.4 of Servlet spec 2.4)
      *
-     * @param locale locale to map an encoding for
+     * @param locale   locale to map an encoding for
      * @param encoding encoding to be used for a give locale
      */
     @Override
-    public void addLocaleEncodingMappingParameter(String locale, String encoding){
+    public void addLocaleEncodingMappingParameter(String locale, String encoding) {
         getCharsetMapper().addCharsetMappingFromDeploymentDescriptor(locale, encoding);
     }
 
@@ -3153,11 +2966,10 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Add a new MIME mapping, replacing any existing mapping for
-     * the specified extension.
+     * Add a new MIME mapping, replacing any existing mapping for the specified extension.
      *
      * @param extension Filename extension being mapped
-     * @param mimeType Corresponding MIME type
+     * @param mimeType  Corresponding MIME type
      */
     @Override
     public void addMimeMapping(String extension, String mimeType) {
@@ -3173,27 +2985,24 @@ public class StandardContext extends ContainerBase
     /**
      * Add a new context initialization parameter.
      *
-     * @param name Name of the new parameter
-     * @param value Value of the new  parameter
+     * @param name  Name of the new parameter
+     * @param value Value of the new parameter
      *
-     * @exception IllegalArgumentException if the name or value is missing,
-     *  or if this context initialization parameter has already been
-     *  registered
+     * @exception IllegalArgumentException if the name or value is missing, or if this context initialization parameter
+     *                                         has already been registered
      */
     @Override
     public void addParameter(String name, String value) {
         // Validate the proposed context initialization parameter
         if ((name == null) || (value == null)) {
-            throw new IllegalArgumentException
-                (sm.getString("standardContext.parameter.required"));
+            throw new IllegalArgumentException(sm.getString("standardContext.parameter.required"));
         }
 
         // Add this parameter to our defined set if not already present
         String oldValue = parameters.putIfAbsent(name, value);
 
         if (oldValue != null) {
-            throw new IllegalArgumentException(
-                    sm.getString("standardContext.parameter.duplicate", name));
+            throw new IllegalArgumentException(sm.getString("standardContext.parameter.duplicate", name));
         }
 
         fireContainerEvent("addParameter", name);
@@ -3236,29 +3045,23 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Add a new servlet mapping, replacing any existing mapping for
-     * the specified pattern.
+     * Add a new servlet mapping, replacing any existing mapping for the specified pattern.
      *
-     * @param pattern URL pattern to be mapped
-     * @param name Name of the corresponding servlet to execute
-     * @param jspWildCard true if name identifies the JspServlet
-     * and pattern contains a wildcard; false otherwise
+     * @param pattern     URL pattern to be mapped
+     * @param name        Name of the corresponding servlet to execute
+     * @param jspWildCard true if name identifies the JspServlet and pattern contains a wildcard; false otherwise
      *
-     * @exception IllegalArgumentException if the specified servlet name
-     *  is not known to this Context
+     * @exception IllegalArgumentException if the specified servlet name is not known to this Context
      */
     @Override
-    public void addServletMappingDecoded(String pattern, String name,
-                                  boolean jspWildCard) {
+    public void addServletMappingDecoded(String pattern, String name, boolean jspWildCard) {
         // Validate the proposed mapping
         if (findChild(name) == null) {
-            throw new IllegalArgumentException
-                (sm.getString("standardContext.servletMap.name", name));
+            throw new IllegalArgumentException(sm.getString("standardContext.servletMap.name", name));
         }
         String adjustedPattern = adjustURLPattern(pattern);
         if (!validateURLPattern(adjustedPattern)) {
-            throw new IllegalArgumentException
-                (sm.getString("standardContext.servletMap.pattern", adjustedPattern));
+            throw new IllegalArgumentException(sm.getString("standardContext.servletMap.pattern", adjustedPattern));
         }
 
         // Add this mapping to our registered set
@@ -3315,15 +3118,14 @@ public class StandardContext extends ContainerBase
             results[welcomeFiles.length] = name;
             welcomeFiles = results;
         }
-        if(this.getState().equals(LifecycleState.STARTED)) {
+        if (this.getState().equals(LifecycleState.STARTED)) {
             fireContainerEvent(ADD_WELCOME_FILE_EVENT, name);
         }
     }
 
 
     /**
-     * Add the classname of a LifecycleListener to be added to each
-     * Wrapper appended to this Context.
+     * Add the classname of a LifecycleListener to be added to each Wrapper appended to this Context.
      *
      * @param listener Java class name of a LifecycleListener class
      */
@@ -3341,8 +3143,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Add the classname of a ContainerListener to be added to each
-     * Wrapper appended to this Context.
+     * Add the classname of a ContainerListener to be added to each Wrapper appended to this Context.
      *
      * @param listener Java class name of a ContainerListener class
      */
@@ -3360,10 +3161,9 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Factory method to create and return a new Wrapper instance, of
-     * the Java implementation class appropriate for this Context
-     * implementation.  The constructor of the instantiated Wrapper
-     * will have been called, but no properties will have been set.
+     * Factory method to create and return a new Wrapper instance, of the Java implementation class appropriate for this
+     * Context implementation. The constructor of the instantiated Wrapper will have been called, but no properties will
+     * have been set.
      */
     @Override
     public Wrapper createWrapper() {
@@ -3385,8 +3185,7 @@ public class StandardContext extends ContainerBase
             for (String wrapperLifecycle : wrapperLifecycles) {
                 try {
                     Class<?> clazz = Class.forName(wrapperLifecycle);
-                    LifecycleListener listener =
-                            (LifecycleListener) clazz.getConstructor().newInstance();
+                    LifecycleListener listener = (LifecycleListener) clazz.getConstructor().newInstance();
                     wrapper.addLifecycleListener(listener);
                 } catch (Throwable t) {
                     ExceptionUtils.handleThrowable(t);
@@ -3400,8 +3199,7 @@ public class StandardContext extends ContainerBase
             for (String wrapperListener : wrapperListeners) {
                 try {
                     Class<?> clazz = Class.forName(wrapperListener);
-                    ContainerListener listener =
-                            (ContainerListener) clazz.getConstructor().newInstance();
+                    ContainerListener listener = (ContainerListener) clazz.getConstructor().newInstance();
                     wrapper.addContainerListener(listener);
                 } catch (Throwable t) {
                     ExceptionUtils.handleThrowable(t);
@@ -3416,8 +3214,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Return the set of application listener class names configured
-     * for this application.
+     * Return the set of application listener class names configured for this application.
      */
     @Override
     public String[] findApplicationListeners() {
@@ -3439,8 +3236,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Return the security constraints for this web application.
-     * If there are none, a zero-length array is returned.
+     * Return the security constraints for this web application. If there are none, a zero-length array is returned.
      */
     @Override
     public SecurityConstraint[] findConstraints() {
@@ -3449,8 +3245,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Return the error page entry for the specified HTTP error code,
-     * if any; otherwise return <code>null</code>.
+     * Return the error page entry for the specified HTTP error code, if any; otherwise return <code>null</code>.
      *
      * @param errorCode Error code to look up
      */
@@ -3467,8 +3262,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Return the set of defined error pages for all specified error codes
-     * and exception types.
+     * Return the set of defined error pages for all specified error codes and exception types.
      */
     @Override
     public ErrorPage[] findErrorPages() {
@@ -3477,8 +3271,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Return the filter definition for the specified filter name, if any;
-     * otherwise return <code>null</code>.
+     * Return the filter definition for the specified filter name, if any; otherwise return <code>null</code>.
      *
      * @param filterName Filter name to look up
      */
@@ -3511,8 +3304,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the message destination with the specified name, if any;
-     * otherwise, return <code>null</code>.
+     * @return the message destination with the specified name, if any; otherwise, return <code>null</code>.
      *
      * @param name Name of the desired message destination
      */
@@ -3524,9 +3316,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the set of defined message destinations for this web
-     * application.  If none have been defined, a zero-length array
-     * is returned.
+     * @return the set of defined message destinations for this web application. If none have been defined, a
+     *             zero-length array is returned.
      */
     public MessageDestination[] findMessageDestinations() {
         synchronized (messageDestinations) {
@@ -3536,8 +3327,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the MIME type to which the specified extension is mapped,
-     * if any; otherwise return <code>null</code>.
+     * @return the MIME type to which the specified extension is mapped, if any; otherwise return <code>null</code>.
      *
      * @param extension Extension to map to a MIME type
      */
@@ -3548,8 +3338,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the extensions for which MIME mappings are defined.  If there
-     * are none, a zero-length array is returned.
+     * @return the extensions for which MIME mappings are defined. If there are none, a zero-length array is returned.
      */
     @Override
     public String[] findMimeMappings() {
@@ -3560,8 +3349,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the value for the specified context initialization
-     * parameter name, if any; otherwise return <code>null</code>.
+     * @return the value for the specified context initialization parameter name, if any; otherwise return
+     *             <code>null</code>.
      *
      * @param name Name of the parameter to return
      */
@@ -3572,9 +3361,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the names of all defined context initialization parameters
-     * for this Context.  If no parameters are defined, a zero-length
-     * array is returned.
+     * @return the names of all defined context initialization parameters for this Context. If no parameters are
+     *             defined, a zero-length array is returned.
      */
     @Override
     public String[] findParameters() {
@@ -3583,11 +3371,11 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * For the given security role (as used by an application), return the
-     * corresponding role name (as defined by the underlying Realm) if there
-     * is one.  Otherwise, return the specified role unchanged.
+     * For the given security role (as used by an application), return the corresponding role name (as defined by the
+     * underlying Realm) if there is one. Otherwise, return the specified role unchanged.
      *
      * @param role Security role to map
+     *
      * @return the role name
      */
     @Override
@@ -3605,8 +3393,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return <code>true</code> if the specified security role is defined
-     * for this application; otherwise return <code>false</code>.
+     * @return <code>true</code> if the specified security role is defined for this application; otherwise return
+     *             <code>false</code>.
      *
      * @param role Security role to verify
      */
@@ -3626,8 +3414,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the security roles defined for this application.  If none
-     * have been defined, a zero-length array is returned.
+     * @return the security roles defined for this application. If none have been defined, a zero-length array is
+     *             returned.
      */
     @Override
     public String[] findSecurityRoles() {
@@ -3638,8 +3426,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the servlet name mapped by the specified pattern (if any);
-     * otherwise return <code>null</code>.
+     * @return the servlet name mapped by the specified pattern (if any); otherwise return <code>null</code>.
      *
      * @param pattern Pattern for which a mapping is requested
      */
@@ -3652,8 +3439,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the patterns of all defined servlet mappings for this
-     * Context.  If no mappings are defined, a zero-length array is returned.
+     * @return the patterns of all defined servlet mappings for this Context. If no mappings are defined, a zero-length
+     *             array is returned.
      */
     @Override
     public String[] findServletMappings() {
@@ -3664,8 +3451,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return <code>true</code> if the specified welcome file is defined
-     * for this Context; otherwise return <code>false</code>.
+     * @return <code>true</code> if the specified welcome file is defined for this Context; otherwise return
+     *             <code>false</code>.
      *
      * @param name Welcome file to verify
      */
@@ -3685,8 +3472,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the set of watched resources for this Context. If none are
-     * defined, a zero length array will be returned.
+     * @return the set of watched resources for this Context. If none are defined, a zero length array will be returned.
      */
     @Override
     public String[] findWatchedResources() {
@@ -3697,8 +3483,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the set of welcome files defined for this Context.  If none are
-     * defined, a zero-length array is returned.
+     * @return the set of welcome files defined for this Context. If none are defined, a zero-length array is returned.
      */
     @Override
     public String[] findWelcomeFiles() {
@@ -3709,8 +3494,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the set of LifecycleListener classes that will be added to
-     * newly created Wrappers automatically.
+     * @return the set of LifecycleListener classes that will be added to newly created Wrappers automatically.
      */
     @Override
     public String[] findWrapperLifecycles() {
@@ -3721,8 +3505,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * @return the set of ContainerListener classes that will be added to
-     * newly created Wrappers automatically.
+     * @return the set of ContainerListener classes that will be added to newly created Wrappers automatically.
      */
     @Override
     public String[] findWrapperListeners() {
@@ -3735,30 +3518,24 @@ public class StandardContext extends ContainerBase
     /**
      * Reload this web application, if reloading is supported.
      * <p>
-     * <b>IMPLEMENTATION NOTE</b>:  This method is designed to deal with
-     * reloads required by changes to classes in the underlying repositories
-     * of our class loader and changes to the web.xml file. It does not handle
-     * changes to any context.xml file. If the context.xml has changed, you
-     * should stop this Context and create (and start) a new Context instance
-     * instead. Note that there is additional code in
-     * <code>CoyoteAdapter#postParseRequest()</code> to handle mapping requests
-     * to paused Contexts.
+     * <b>IMPLEMENTATION NOTE</b>: This method is designed to deal with reloads required by changes to classes in the
+     * underlying repositories of our class loader and changes to the web.xml file. It does not handle changes to any
+     * context.xml file. If the context.xml has changed, you should stop this Context and create (and start) a new
+     * Context instance instead. Note that there is additional code in <code>CoyoteAdapter#postParseRequest()</code> to
+     * handle mapping requests to paused Contexts.
      *
-     * @exception IllegalStateException if the <code>reloadable</code>
-     *  property is set to <code>false</code>.
+     * @exception IllegalStateException if the <code>reloadable</code> property is set to <code>false</code>.
      */
     @Override
     public synchronized void reload() {
 
         // Validate our current component state
         if (!getState().isAvailable()) {
-            throw new IllegalStateException
-                (sm.getString("standardContext.notStarted", getName()));
+            throw new IllegalStateException(sm.getString("standardContext.notStarted", getName()));
         }
 
-        if(log.isInfoEnabled()) {
-            log.info(sm.getString("standardContext.reloadingStarted",
-                    getName()));
+        if (log.isInfoEnabled()) {
+            log.info(sm.getString("standardContext.reloadingStarted", getName()));
         }
 
         // Stop accepting requests temporarily.
@@ -3767,30 +3544,26 @@ public class StandardContext extends ContainerBase
         try {
             stop();
         } catch (LifecycleException e) {
-            log.error(
-                sm.getString("standardContext.stoppingContext", getName()), e);
+            log.error(sm.getString("standardContext.stoppingContext", getName()), e);
         }
 
         try {
             start();
         } catch (LifecycleException e) {
-            log.error(
-                sm.getString("standardContext.startingContext", getName()), e);
+            log.error(sm.getString("standardContext.startingContext", getName()), e);
         }
 
         setPaused(false);
 
-        if(log.isInfoEnabled()) {
-            log.info(sm.getString("standardContext.reloadingCompleted",
-                    getName()));
+        if (log.isInfoEnabled()) {
+            log.info(sm.getString("standardContext.reloadingCompleted", getName()));
         }
 
     }
 
 
     /**
-     * Remove the specified application listener class from the set of
-     * listeners for this application.
+     * Remove the specified application listener class from the set of listeners for this application.
      *
      * @param listener Java class name of the listener to be removed
      */
@@ -3830,8 +3603,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Remove the application parameter with the specified name from
-     * the set for this application.
+     * Remove the application parameter with the specified name from the set for this application.
      *
      * @param name Name of the application parameter to remove
      */
@@ -3854,8 +3626,7 @@ public class StandardContext extends ContainerBase
 
             // Remove the specified parameter
             int j = 0;
-            ApplicationParameter results[] =
-                new ApplicationParameter[applicationParameters.length - 1];
+            ApplicationParameter results[] = new ApplicationParameter[applicationParameters.length - 1];
             for (int i = 0; i < applicationParameters.length; i++) {
                 if (i != n) {
                     results[j++] = applicationParameters[i];
@@ -3872,20 +3643,17 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Add a child Container, only if the proposed child is an implementation
-     * of Wrapper.
+     * Add a child Container, only if the proposed child is an implementation of Wrapper.
      *
      * @param child Child container to be added
      *
-     * @exception IllegalArgumentException if the proposed container is
-     *  not an implementation of Wrapper
+     * @exception IllegalArgumentException if the proposed container is not an implementation of Wrapper
      */
     @Override
     public void removeChild(Container child) {
 
         if (!(child instanceof Wrapper)) {
-            throw new IllegalArgumentException
-                (sm.getString("standardContext.notWrapper"));
+            throw new IllegalArgumentException(sm.getString("standardContext.notWrapper"));
         }
 
         super.removeChild(child);
@@ -3917,8 +3685,7 @@ public class StandardContext extends ContainerBase
 
             // Remove the specified constraint
             int j = 0;
-            SecurityConstraint results[] =
-                new SecurityConstraint[constraints.length - 1];
+            SecurityConstraint results[] = new SecurityConstraint[constraints.length - 1];
             for (int i = 0; i < constraints.length; i++) {
                 if (i != n) {
                     results[j++] = constraints[i];
@@ -3935,8 +3702,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Remove the error page for the specified error code or
-     * Java language exception, if it exists; otherwise, no action is taken.
+     * Remove the error page for the specified error code or Java language exception, if it exists; otherwise, no action
+     * is taken.
      *
      * @param errorPage The error page definition to be removed
      */
@@ -3948,8 +3715,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Remove the specified filter definition from this Context, if it exists;
-     * otherwise, no action is taken.
+     * Remove the specified filter definition from this Context, if it exists; otherwise, no action is taken.
      *
      * @param filterDef Filter definition to be removed
      */
@@ -3993,8 +3759,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Remove the MIME mapping for the specified extension, if it exists;
-     * otherwise, no action is taken.
+     * Remove the MIME mapping for the specified extension, if it exists; otherwise, no action is taken.
      *
      * @param extension Extension to remove the mapping for
      */
@@ -4010,8 +3775,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Remove the context initialization parameter with the specified
-     * name, if it exists; otherwise, no action is taken.
+     * Remove the context initialization parameter with the specified name, if it exists; otherwise, no action is taken.
      *
      * @param name Name of the parameter to remove
      */
@@ -4079,8 +3843,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Remove any servlet mapping for the specified pattern, if it exists;
-     * otherwise, no action is taken.
+     * Remove any servlet mapping for the specified pattern, if it exists; otherwise, no action is taken.
      *
      * @param pattern URL pattern of the mapping to remove
      */
@@ -4092,7 +3855,7 @@ public class StandardContext extends ContainerBase
             name = servletMappings.remove(pattern);
         }
         Wrapper wrapper = (Wrapper) findChild(name);
-        if( wrapper != null ) {
+        if (wrapper != null) {
             wrapper.removeMapping(pattern);
         }
         fireContainerEvent("removeServletMapping", pattern);
@@ -4100,8 +3863,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Remove the specified watched resource name from the list associated
-     * with this Context.
+     * Remove the specified watched resource name from the list associated with this Context.
      *
      * @param name Name of the watched resource to be removed
      */
@@ -4140,8 +3902,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Remove the specified welcome file name from the list recognized
-     * by this Context.
+     * Remove the specified welcome file name from the list recognized by this Context.
      *
      * @param name Name of the welcome file to be removed
      */
@@ -4175,7 +3936,7 @@ public class StandardContext extends ContainerBase
         }
 
         // Inform interested listeners
-        if(this.getState().equals(LifecycleState.STARTED)) {
+        if (this.getState().equals(LifecycleState.STARTED)) {
             fireContainerEvent(REMOVE_WELCOME_FILE_EVENT, name);
         }
 
@@ -4183,8 +3944,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Remove a class name from the set of LifecycleListener classes that
-     * will be added to newly created Wrappers.
+     * Remove a class name from the set of LifecycleListener classes that will be added to newly created Wrappers.
      *
      * @param listener Class name of a LifecycleListener class to be removed
      */
@@ -4225,8 +3985,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Remove a class name from the set of ContainerListener classes that
-     * will be added to newly created Wrappers.
+     * Remove a class name from the set of ContainerListener classes that will be added to newly created Wrappers.
      *
      * @param listener Class name of a ContainerListener class to be removed
      */
@@ -4267,11 +4026,9 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Gets the cumulative processing times of all servlets in this
-     * StandardContext.
+     * Gets the cumulative processing times of all servlets in this StandardContext.
      *
-     * @return Cumulative processing times of all servlets in this
-     * StandardContext
+     * @return Cumulative processing times of all servlets in this StandardContext
      */
     public long getProcessingTime() {
 
@@ -4288,11 +4045,9 @@ public class StandardContext extends ContainerBase
     }
 
     /**
-     * Gets the maximum processing time of all servlets in this
-     * StandardContext.
+     * Gets the maximum processing time of all servlets in this StandardContext.
      *
-     * @return Maximum processing time of all servlets in this
-     * StandardContext
+     * @return Maximum processing time of all servlets in this StandardContext
      */
     public long getMaxTime() {
 
@@ -4313,11 +4068,9 @@ public class StandardContext extends ContainerBase
     }
 
     /**
-     * Gets the minimum processing time of all servlets in this
-     * StandardContext.
+     * Gets the minimum processing time of all servlets in this StandardContext.
      *
-     * @return Minimum processing time of all servlets in this
-     * StandardContext
+     * @return Minimum processing time of all servlets in this StandardContext
      */
     public long getMinTime() {
 
@@ -4338,11 +4091,9 @@ public class StandardContext extends ContainerBase
     }
 
     /**
-     * Gets the cumulative request count of all servlets in this
-     * StandardContext.
+     * Gets the cumulative request count of all servlets in this StandardContext.
      *
-     * @return Cumulative request count of all servlets in this
-     * StandardContext
+     * @return Cumulative request count of all servlets in this StandardContext
      */
     public int getRequestCount() {
 
@@ -4359,11 +4110,9 @@ public class StandardContext extends ContainerBase
     }
 
     /**
-     * Gets the cumulative error count of all servlets in this
-     * StandardContext.
+     * Gets the cumulative error count of all servlets in this StandardContext.
      *
-     * @return Cumulative error count of all servlets in this
-     * StandardContext
+     * @return Cumulative error count of all servlets in this StandardContext
      */
     public int getErrorCount() {
 
@@ -4381,8 +4130,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Return the real path for a given virtual path, if possible; otherwise
-     * return <code>null</code>.
+     * Return the real path for a given virtual path, if possible; otherwise return <code>null</code>.
      *
      * @param path The path to the desired resource
      */
@@ -4399,8 +4147,8 @@ public class StandardContext extends ContainerBase
                 String canonicalPath = resource.getCanonicalPath();
                 if (canonicalPath == null) {
                     return null;
-                } else if ((resource.isDirectory() && !canonicalPath.endsWith(File.separator) ||
-                        !resource.exists()) && path.endsWith("/")) {
+                } else if ((resource.isDirectory() && !canonicalPath.endsWith(File.separator) || !resource.exists()) &&
+                        path.endsWith("/")) {
                     return canonicalPath + File.separatorChar;
                 } else {
                     return canonicalPath;
@@ -4414,8 +4162,7 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Hook to track which Servlets were created via
-     * {@link ServletContext#createServlet(Class)}.
+     * Hook to track which Servlets were created via {@link ServletContext#createServlet(Class)}.
      *
      * @param servlet the created Servlet
      */
@@ -4436,21 +4183,18 @@ public class StandardContext extends ContainerBase
         private final Object lock = new Object();
 
         /**
-         * The set of filter mappings for this application, in the order they
-         * were defined in the deployment descriptor with additional mappings
-         * added via the {@link ServletContext} possibly both before and after
-         * those defined in the deployment descriptor.
+         * The set of filter mappings for this application, in the order they were defined in the deployment descriptor
+         * with additional mappings added via the {@link ServletContext} possibly both before and after those defined in
+         * the deployment descriptor.
          */
         private FilterMap[] array = new FilterMap[0];
 
         /**
-         * Filter mappings added via {@link ServletContext} may have to be
-         * inserted before the mappings in the deployment descriptor but must be
-         * inserted in the order the {@link ServletContext} methods are called.
-         * This isn't an issue for the mappings added after the deployment
-         * descriptor - they are just added to the end - but correctly the
-         * adding mappings before the deployment descriptor mappings requires
-         * knowing where the last 'before' mapping was added.
+         * Filter mappings added via {@link ServletContext} may have to be inserted before the mappings in the
+         * deployment descriptor but must be inserted in the order the {@link ServletContext} methods are called. This
+         * isn't an issue for the mappings added after the deployment descriptor - they are just added to the end - but
+         * correctly the adding mappings before the deployment descriptor mappings requires knowing where the last
+         * 'before' mapping was added.
          */
         private int insertPoint = 0;
 
@@ -4464,11 +4208,9 @@ public class StandardContext extends ContainerBase
         }
 
         /**
-         * Add a filter mapping at the end of the current set of filter
-         * mappings.
+         * Add a filter mapping at the end of the current set of filter mappings.
          *
-         * @param filterMap
-         *            The filter mapping to be added
+         * @param filterMap The filter mapping to be added
          */
         public void add(FilterMap filterMap) {
             synchronized (lock) {
@@ -4479,18 +4221,16 @@ public class StandardContext extends ContainerBase
         }
 
         /**
-         * Add a filter mapping before the mappings defined in the deployment
-         * descriptor but after any other mappings added via this method.
+         * Add a filter mapping before the mappings defined in the deployment descriptor but after any other mappings
+         * added via this method.
          *
-         * @param filterMap
-         *            The filter mapping to be added
+         * @param filterMap The filter mapping to be added
          */
         public void addBefore(FilterMap filterMap) {
             synchronized (lock) {
                 FilterMap results[] = new FilterMap[array.length + 1];
                 System.arraycopy(array, 0, results, 0, insertPoint);
-                System.arraycopy(array, insertPoint, results, insertPoint + 1,
-                        array.length - insertPoint);
+                System.arraycopy(array, insertPoint, results, insertPoint + 1, array.length - insertPoint);
                 results[insertPoint] = filterMap;
                 array = results;
                 insertPoint++;
@@ -4519,8 +4259,7 @@ public class StandardContext extends ContainerBase
                 // Remove the specified filter mapping
                 FilterMap results[] = new FilterMap[array.length - 1];
                 System.arraycopy(array, 0, results, 0, n);
-                System.arraycopy(array, n + 1, results, n, (array.length - 1)
-                        - n);
+                System.arraycopy(array, n + 1, results, n, (array.length - 1) - n);
                 array = results;
                 if (n < insertPoint) {
                     insertPoint--;
@@ -4534,8 +4273,8 @@ public class StandardContext extends ContainerBase
 
     /**
      * Configure and initialize the set of filters for this Context.
-     * @return <code>true</code> if all filter initialization completed
-     * successfully, or <code>false</code> otherwise.
+     *
+     * @return <code>true</code> if all filter initialization completed successfully, or <code>false</code> otherwise.
      */
     public boolean filterStart() {
 
@@ -4546,20 +4285,18 @@ public class StandardContext extends ContainerBase
         boolean ok = true;
         synchronized (filterConfigs) {
             filterConfigs.clear();
-            for (Entry<String,FilterDef> entry : filterDefs.entrySet()) {
+            for (Entry<String, FilterDef> entry : filterDefs.entrySet()) {
                 String name = entry.getKey();
                 if (getLogger().isDebugEnabled()) {
                     getLogger().debug(" Starting filter '" + name + "'");
                 }
                 try {
-                    ApplicationFilterConfig filterConfig =
-                            new ApplicationFilterConfig(this, entry.getValue());
+                    ApplicationFilterConfig filterConfig = new ApplicationFilterConfig(this, entry.getValue());
                     filterConfigs.put(name, filterConfig);
                 } catch (Throwable t) {
                     t = ExceptionUtils.unwrapInvocationTargetException(t);
                     ExceptionUtils.handleThrowable(t);
-                    getLogger().error(sm.getString(
-                            "standardContext.filterStart", name), t);
+                    getLogger().error(sm.getString("standardContext.filterStart", name), t);
                     ok = false;
                 }
             }
@@ -4571,8 +4308,8 @@ public class StandardContext extends ContainerBase
 
     /**
      * Finalize and release the set of filters for this Context.
-     * @return <code>true</code> if all filter finalization completed
-     * successfully, or <code>false</code> otherwise.
+     *
+     * @return <code>true</code> if all filter finalization completed successfully, or <code>false</code> otherwise.
      */
     public boolean filterStop() {
 
@@ -4597,10 +4334,11 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Find and return the initialized <code>FilterConfig</code> for the
-     * specified filter name, if any; otherwise return <code>null</code>.
+     * Find and return the initialized <code>FilterConfig</code> for the specified filter name, if any; otherwise return
+     * <code>null</code>.
      *
      * @param name Name of the desired filter
+     *
      * @return the filter config object
      */
     public FilterConfig findFilterConfig(String name) {
@@ -4609,10 +4347,9 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Configure the set of instantiated application event listeners
-     * for this Context.
-     * @return <code>true</code> if all listeners wre
-     * initialized successfully, or <code>false</code> otherwise.
+     * Configure the set of instantiated application event listeners for this Context.
+     *
+     * @return <code>true</code> if all listeners wre initialized successfully, or <code>false</code> otherwise.
      */
     public boolean listenerStart() {
 
@@ -4626,8 +4363,7 @@ public class StandardContext extends ContainerBase
         boolean ok = true;
         for (int i = 0; i < results.length; i++) {
             if (getLogger().isDebugEnabled()) {
-                getLogger().debug(" Configuring event listener class '" +
-                    listeners[i] + "'");
+                getLogger().debug(" Configuring event listener class '" + listeners[i] + "'");
             }
             try {
                 String listener = listeners[i];
@@ -4635,8 +4371,7 @@ public class StandardContext extends ContainerBase
             } catch (Throwable t) {
                 t = ExceptionUtils.unwrapInvocationTargetException(t);
                 ExceptionUtils.handleThrowable(t);
-                getLogger().error(sm.getString(
-                        "standardContext.applicationListener", listeners[i]), t);
+                getLogger().error(sm.getString("standardContext.applicationListener", listeners[i]), t);
                 ok = false;
             }
         }
@@ -4649,15 +4384,12 @@ public class StandardContext extends ContainerBase
         List<Object> eventListeners = new ArrayList<>();
         List<Object> lifecycleListeners = new ArrayList<>();
         for (Object result : results) {
-            if ((result instanceof ServletContextAttributeListener)
-                    || (result instanceof ServletRequestAttributeListener)
-                    || (result instanceof ServletRequestListener)
-                    || (result instanceof HttpSessionIdListener)
-                    || (result instanceof HttpSessionAttributeListener)) {
+            if ((result instanceof ServletContextAttributeListener) ||
+                    (result instanceof ServletRequestAttributeListener) || (result instanceof ServletRequestListener) ||
+                    (result instanceof HttpSessionIdListener) || (result instanceof HttpSessionAttributeListener)) {
                 eventListeners.add(result);
             }
-            if ((result instanceof ServletContextListener)
-                    || (result instanceof HttpSessionListener)) {
+            if ((result instanceof ServletContextListener) || (result instanceof HttpSessionListener)) {
                 lifecycleListeners.add(result);
             }
         }
@@ -4669,7 +4401,7 @@ public class StandardContext extends ContainerBase
         // list.
         eventListeners.addAll(Arrays.asList(getApplicationEventListeners()));
         setApplicationEventListeners(eventListeners.toArray());
-        for (Object lifecycleListener: getApplicationLifecycleListeners()) {
+        for (Object lifecycleListener : getApplicationLifecycleListeners()) {
             lifecycleListeners.add(lifecycleListener);
             if (lifecycleListener instanceof ServletContextListener) {
                 noPluggabilityListeners.add(lifecycleListener);
@@ -4714,8 +4446,7 @@ public class StandardContext extends ContainerBase
             } catch (Throwable t) {
                 ExceptionUtils.handleThrowable(t);
                 fireContainerEvent("afterContextInitialized", listener);
-                getLogger().error(sm.getString("standardContext.listenerStart",
-                        instance.getClass().getName()), t);
+                getLogger().error(sm.getString("standardContext.listenerStart", instance.getClass().getName()), t);
                 ok = false;
             }
         }
@@ -4726,8 +4457,8 @@ public class StandardContext extends ContainerBase
 
     /**
      * Send an application stop event to all interested listeners.
-     * @return <code>true</code> if all events were sent successfully,
-     * or <code>false</code> otherwise.
+     *
+     * @return <code>true</code> if all events were sent successfully, or <code>false</code> otherwise.
      */
     public boolean listenerStop() {
 
@@ -4749,8 +4480,7 @@ public class StandardContext extends ContainerBase
                     continue;
                 }
                 if (listeners[j] instanceof ServletContextListener) {
-                    ServletContextListener listener =
-                        (ServletContextListener) listeners[j];
+                    ServletContextListener listener = (ServletContextListener) listeners[j];
                     try {
                         fireContainerEvent("beforeContextDestroyed", listener);
                         if (noPluggabilityListeners.contains(listener)) {
@@ -4762,9 +4492,8 @@ public class StandardContext extends ContainerBase
                     } catch (Throwable t) {
                         ExceptionUtils.handleThrowable(t);
                         fireContainerEvent("afterContextDestroyed", listener);
-                        getLogger().error
-                            (sm.getString("standardContext.listenerStop",
-                                listeners[j].getClass().getName()), t);
+                        getLogger().error(
+                                sm.getString("standardContext.listenerStop", listeners[j].getClass().getName()), t);
                         ok = false;
                     }
                 }
@@ -4775,9 +4504,8 @@ public class StandardContext extends ContainerBase
                 } catch (Throwable t) {
                     t = ExceptionUtils.unwrapInvocationTargetException(t);
                     ExceptionUtils.handleThrowable(t);
-                    getLogger().error
-                       (sm.getString("standardContext.listenerStop",
-                            listeners[j].getClass().getName()), t);
+                    getLogger().error(sm.getString("standardContext.listenerStop", listeners[j].getClass().getName()),
+                            t);
                     ok = false;
                 }
             }
@@ -4798,9 +4526,8 @@ public class StandardContext extends ContainerBase
                 } catch (Throwable t) {
                     t = ExceptionUtils.unwrapInvocationTargetException(t);
                     ExceptionUtils.handleThrowable(t);
-                    getLogger().error
-                        (sm.getString("standardContext.listenerStop",
-                            listeners[j].getClass().getName()), t);
+                    getLogger().error(sm.getString("standardContext.listenerStop", listeners[j].getClass().getName()),
+                            t);
                     ok = false;
                 }
             }
@@ -4818,6 +4545,7 @@ public class StandardContext extends ContainerBase
 
     /**
      * Allocate resources, including proxy.
+     *
      * @throws LifecycleException if a start error occurs
      */
     public void resourcesStart() throws LifecycleException {
@@ -4828,12 +4556,10 @@ public class StandardContext extends ContainerBase
             resources.start();
         }
 
-        if (effectiveMajorVersion >=3 && addWebinfClassesResources) {
-            WebResource webinfClassesResource = resources.getResource(
-                    "/WEB-INF/classes/META-INF/resources");
+        if (effectiveMajorVersion >= 3 && addWebinfClassesResources) {
+            WebResource webinfClassesResource = resources.getResource("/WEB-INF/classes/META-INF/resources");
             if (webinfClassesResource.isDirectory()) {
-                getResources().createWebResourceSet(
-                        WebResourceRoot.ResourceSetType.RESOURCE_JAR, "/",
+                getResources().createWebResourceSet(WebResourceRoot.ResourceSetType.RESOURCE_JAR, "/",
                         webinfClassesResource.getURL(), "/");
             }
         }
@@ -4842,6 +4568,7 @@ public class StandardContext extends ContainerBase
 
     /**
      * Deallocate resources and destroy proxy.
+     *
      * @return <code>true</code> if no error occurred
      */
     public boolean resourcesStop() {
@@ -4867,11 +4594,11 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Load and initialize all servlets marked "load on startup" in the
-     * web application deployment descriptor.
+     * Load and initialize all servlets marked "load on startup" in the web application deployment descriptor.
+     *
+     * @param children Array of wrappers for all currently defined servlets (including those not declared load on
+     *                     startup)
      *
-     * @param children Array of wrappers for all currently defined
-     *  servlets (including those not declared load on startup)
      * @return <code>true</code> if load on startup was considered successful
      */
     public boolean loadOnStartup(Container children[]) {
@@ -4894,13 +4621,14 @@ public class StandardContext extends ContainerBase
                 try {
                     wrapper.load();
                 } catch (ServletException e) {
-                    getLogger().error(sm.getString("standardContext.loadOnStartup.loadException",
-                          getName(), wrapper.getName()), StandardWrapper.getRootCause(e));
+                    getLogger().error(
+                            sm.getString("standardContext.loadOnStartup.loadException", getName(), wrapper.getName()),
+                            StandardWrapper.getRootCause(e));
                     // NOTE: load errors (including a servlet that throws
                     // UnavailableException from the init() method) are NOT
                     // fatal to application startup
                     // unless failCtxIfServletStartFails="true" is specified
-                    if(getComputedFailCtxIfServletStartFails()) {
+                    if (getComputedFailCtxIfServletStartFails()) {
                         return false;
                     }
                 }
@@ -4912,23 +4640,23 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Start this component and implement the requirements
-     * of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
+     * Start this component and implement the requirements of
+     * {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
+     * @exception LifecycleException if this component detects a fatal error that prevents this component from being
+     *                                   used
      */
     @Override
     protected synchronized void startInternal() throws LifecycleException {
 
-        if(log.isDebugEnabled()) {
+        if (log.isDebugEnabled()) {
             log.debug("Starting " + getBaseName());
         }
 
         // Send j2ee.state.starting notification
         if (this.getObjectName() != null) {
-            Notification notification = new Notification("j2ee.state.starting",
-                    this.getObjectName(), sequenceNumber.getAndIncrement());
+            Notification notification = new Notification("j2ee.state.starting", this.getObjectName(),
+                    sequenceNumber.getAndIncrement());
             broadcaster.sendNotification(notification);
         }
 
@@ -4945,7 +4673,7 @@ public class StandardContext extends ContainerBase
         postWorkDirectory();
 
         // Add missing components as necessary
-        if (getResources() == null) {   // (1) Required by Loader
+        if (getResources() == null) { // (1) Required by Loader
             if (log.isDebugEnabled()) {
                 log.debug("Configuring default Resources");
             }
@@ -4977,8 +4705,7 @@ public class StandardContext extends ContainerBase
 
         // Reading the "catalina.useNaming" environment variable
         String useNamingProperty = System.getProperty("catalina.useNaming");
-        if ((useNamingProperty != null)
-            && (useNamingProperty.equals("false"))) {
+        if ((useNamingProperty != null) && (useNamingProperty.equals("false"))) {
             useNaming = false;
         }
 
@@ -5044,7 +4771,8 @@ public class StandardContext extends ContainerBase
                     CredentialHandler safeHandler = new CredentialHandler() {
                         @Override
                         public boolean matches(String inputCredentials, String storedCredentials) {
-                            return getRealmInternal().getCredentialHandler().matches(inputCredentials, storedCredentials);
+                            return getRealmInternal().getCredentialHandler().matches(inputCredentials,
+                                    storedCredentials);
                         }
 
                         @Override
@@ -5077,8 +4805,7 @@ public class StandardContext extends ContainerBase
                 if (manager == null) {
                     if (log.isDebugEnabled()) {
                         log.debug(sm.getString("standardContext.cluster.noManager",
-                                Boolean.valueOf((getCluster() != null)),
-                                Boolean.valueOf(distributable)));
+                                Boolean.valueOf((getCluster() != null)), Boolean.valueOf(distributable)));
                     }
                     if ((getCluster() != null) && distributable) {
                         try {
@@ -5095,15 +4822,14 @@ public class StandardContext extends ContainerBase
                 // Configure default manager if none was specified
                 if (contextManager != null) {
                     if (log.isDebugEnabled()) {
-                        log.debug(sm.getString("standardContext.manager",
-                                contextManager.getClass().getName()));
+                        log.debug(sm.getString("standardContext.manager", contextManager.getClass().getName()));
                     }
                     setManager(contextManager);
                 }
 
-                if (manager!=null && (getCluster() != null) && distributable) {
-                    //let the cluster know that there is a context that is distributable
-                    //and that it has its own manager
+                if (manager != null && (getCluster() != null) && distributable) {
+                    // let the cluster know that there is a context that is distributable
+                    // and that it has its own manager
                     getCluster().registerManager(manager);
                 }
             }
@@ -5115,19 +4841,16 @@ public class StandardContext extends ContainerBase
 
             // We put the resources into the servlet context
             if (ok) {
-                getServletContext().setAttribute
-                    (Globals.RESOURCES_ATTR, getResources());
+                getServletContext().setAttribute(Globals.RESOURCES_ATTR, getResources());
 
                 if (getInstanceManager() == null) {
                     setInstanceManager(createInstanceManager());
                 }
-                getServletContext().setAttribute(
-                        InstanceManager.class.getName(), getInstanceManager());
+                getServletContext().setAttribute(InstanceManager.class.getName(), getInstanceManager());
                 InstanceManagerBindings.bind(getLoader().getClassLoader(), getInstanceManager());
 
                 // Create context attributes that will be required
-                getServletContext().setAttribute(
-                        JarScanner.class.getName(), getJarScanner());
+                getServletContext().setAttribute(JarScanner.class.getName(), getJarScanner());
 
                 // Make the version info available
                 getServletContext().setAttribute(Globals.WEBAPP_VERSION, getWebappVersion());
@@ -5137,11 +4860,9 @@ public class StandardContext extends ContainerBase
             mergeParameters();
 
             // Call ServletContainerInitializers
-            for (Map.Entry<ServletContainerInitializer, Set<Class<?>>> entry :
-                initializers.entrySet()) {
+            for (Map.Entry<ServletContainerInitializer, Set<Class<?>>> entry : initializers.entrySet()) {
                 try {
-                    entry.getKey().onStartup(entry.getValue(),
-                            getServletContext());
+                    entry.getKey().onStartup(entry.getValue(), getServletContext());
                 } catch (ServletException e) {
                     log.error(sm.getString("standardContext.sciFail"), e);
                     ok = false;
@@ -5170,7 +4891,7 @@ public class StandardContext extends ContainerBase
                 if (manager instanceof Lifecycle) {
                     ((Lifecycle) manager).start();
                 }
-            } catch(Exception e) {
+            } catch (Exception e) {
                 log.error(sm.getString("standardContext.managerFail"), e);
                 ok = false;
             }
@@ -5185,7 +4906,7 @@ public class StandardContext extends ContainerBase
 
             // Load and initialize all "load on startup" servlets
             if (ok) {
-                if (!loadOnStartup(findChildren())){
+                if (!loadOnStartup(findChildren())) {
                     log.error(sm.getString("standardContext.servletFail"));
                     ok = false;
                 }
@@ -5207,13 +4928,12 @@ public class StandardContext extends ContainerBase
             log.error(sm.getString("standardContext.startFailed", getName()));
         }
 
-        startTime=System.currentTimeMillis();
+        startTime = System.currentTimeMillis();
 
         // Send j2ee.state.running notification
         if (ok && (this.getObjectName() != null)) {
-            Notification notification =
-                new Notification("j2ee.state.running", this.getObjectName(),
-                                 sequenceNumber.getAndIncrement());
+            Notification notification = new Notification("j2ee.state.running", this.getObjectName(),
+                    sequenceNumber.getAndIncrement());
             broadcaster.sendNotification(notification);
         }
 
@@ -5228,8 +4948,8 @@ public class StandardContext extends ContainerBase
             setState(LifecycleState.FAILED);
             // Send j2ee.object.failed notification
             if (this.getObjectName() != null) {
-                Notification notification = new Notification("j2ee.object.failed",
-                        this.getObjectName(), sequenceNumber.getAndIncrement());
+                Notification notification = new Notification("j2ee.object.failed", this.getObjectName(),
+                        sequenceNumber.getAndIncrement());
                 broadcaster.sendNotification(notification);
             }
         } else {
@@ -5238,11 +4958,9 @@ public class StandardContext extends ContainerBase
     }
 
 
-    private void checkConstraintsForUncoveredMethods(
-            SecurityConstraint[] constraints) {
-        SecurityConstraint[] newConstraints =
-                SecurityConstraint.findUncoveredHttpMethods(constraints,
-                        getDenyUncoveredHttpMethods(), getLogger());
+    private void checkConstraintsForUncoveredMethods(SecurityConstraint[] constraints) {
+        SecurityConstraint[] newConstraints = SecurityConstraint.findUncoveredHttpMethods(constraints,
+                getDenyUncoveredHttpMethods(), getLogger());
         for (SecurityConstraint constraint : newConstraints) {
             addConstraint(constraint);
         }
@@ -5256,32 +4974,31 @@ public class StandardContext extends ContainerBase
             context = getNamingContextListener().getEnvContext();
         }
         Map<String, Map<String, String>> injectionMap = buildInjectionMap(
-                getIgnoreAnnotations() ? new NamingResourcesImpl(): getNamingResources());
-       return new DefaultInstanceManager(context, injectionMap,
-               this, this.getClass().getClassLoader());
+                getIgnoreAnnotations() ? new NamingResourcesImpl() : getNamingResources());
+        return new DefaultInstanceManager(context, injectionMap, this, this.getClass().getClassLoader());
     }
 
     private Map<String, Map<String, String>> buildInjectionMap(NamingResourcesImpl namingResources) {
         Map<String, Map<String, String>> injectionMap = new HashMap<>();
-        for (Injectable resource: namingResources.findLocalEjbs()) {
+        for (Injectable resource : namingResources.findLocalEjbs()) {
             addInjectionTarget(resource, injectionMap);
         }
-        for (Injectable resource: namingResources.findEjbs()) {
+        for (Injectable resource : namingResources.findEjbs()) {
             addInjectionTarget(resource, injectionMap);
         }
-        for (Injectable resource: namingResources.findEnvironments()) {
+        for (Injectable resource : namingResources.findEnvironments()) {
             addInjectionTarget(resource, injectionMap);
         }
-        for (Injectable resource: namingResources.findMessageDestinationRefs()) {
+        for (Injectable resource : namingResources.findMessageDestinationRefs()) {
             addInjectionTarget(resource, injectionMap);
         }
-        for (Injectable resource: namingResources.findResourceEnvRefs()) {
+        for (Injectable resource : namingResources.findResourceEnvRefs()) {
             addInjectionTarget(resource, injectionMap);
         }
-        for (Injectable resource: namingResources.findResources()) {
+        for (Injectable resource : namingResources.findResources()) {
             addInjectionTarget(resource, injectionMap);
         }
-        for (Injectable resource: namingResources.findServices()) {
+        for (Injectable resource : namingResources.findServices()) {
             addInjectionTarget(resource, injectionMap);
         }
         return injectionMap;
@@ -5291,24 +5008,22 @@ public class StandardContext extends ContainerBase
         List<InjectionTarget> injectionTargets = resource.getInjectionTargets();
         if (injectionTargets != null && injectionTargets.size() > 0) {
             String jndiName = resource.getName();
-            for (InjectionTarget injectionTarget: injectionTargets) {
+            for (InjectionTarget injectionTarget : injectionTargets) {
                 String clazz = injectionTarget.getTargetClass();
-                injectionMap.computeIfAbsent(clazz, k -> new HashMap<>())
-                    .put(injectionTarget.getTargetName(), jndiName);
+                injectionMap.computeIfAbsent(clazz, k -> new HashMap<>()).put(injectionTarget.getTargetName(),
+                        jndiName);
             }
         }
     }
 
 
-
     /**
-     * Merge the context initialization parameters specified in the application
-     * deployment descriptor with the application parameters described in the
-     * server configuration, respecting the <code>override</code> property of
+     * Merge the context initialization parameters specified in the application deployment descriptor with the
+     * application parameters described in the server configuration, respecting the <code>override</code> property of
      * the application parameters appropriately.
      */
     private void mergeParameters() {
-        Map<String,String> mergedParams = new HashMap<>();
+        Map<String, String> mergedParams = new HashMap<>();
 
         String names[] = findParameters();
         for (String s : names) {
@@ -5318,15 +5033,14 @@ public class StandardContext extends ContainerBase
         ApplicationParameter params[] = findApplicationParameters();
         for (ApplicationParameter param : params) {
             if (param.getOverride()) {
-                mergedParams.computeIfAbsent(param.getName(),
-                    k -> param.getValue());
+                mergedParams.computeIfAbsent(param.getName(), k -> param.getValue());
             } else {
                 mergedParams.put(param.getName(), param.getValue());
             }
         }
 
         ServletContext sc = getServletContext();
-        for (Map.Entry<String,String> entry : mergedParams.entrySet()) {
+        for (Map.Entry<String, String> entry : mergedParams.entrySet()) {
             sc.setInitParameter(entry.getKey(), entry.getValue());
         }
 
@@ -5334,20 +5048,19 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Stop this component and implement the requirements
-     * of {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
+     * Stop this component and implement the requirements of
+     * {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
+     * @exception LifecycleException if this component detects a fatal error that prevents this component from being
+     *                                   used
      */
     @Override
     protected synchronized void stopInternal() throws LifecycleException {
 
         // Send j2ee.state.stopping notification
         if (this.getObjectName() != null) {
-            Notification notification =
-                new Notification("j2ee.state.stopping", this.getObjectName(),
-                                 sequenceNumber.getAndIncrement());
+            Notification notification = new Notification("j2ee.state.stopping", this.getObjectName(),
+                    sequenceNumber.getAndIncrement());
             broadcaster.sendNotification(notification);
         }
 
@@ -5413,8 +5126,7 @@ public class StandardContext extends ContainerBase
             fireLifecycleEvent(Lifecycle.CONFIGURE_STOP_EVENT, null);
 
             // Stop the Valves in our pipeline (including the basic), if any
-            if (pipeline instanceof Lifecycle &&
-                    ((Lifecycle) pipeline).getState().isAvailable()) {
+            if (pipeline instanceof Lifecycle && ((Lifecycle) pipeline).getState().isAvailable()) {
                 ((Lifecycle) pipeline).stop();
             }
 
@@ -5448,9 +5160,8 @@ public class StandardContext extends ContainerBase
 
         // Send j2ee.state.stopped notification
         if (this.getObjectName() != null) {
-            Notification notification =
-                new Notification("j2ee.state.stopped", this.getObjectName(),
-                                sequenceNumber.getAndIncrement());
+            Notification notification = new Notification("j2ee.state.stopped", this.getObjectName(),
+                    sequenceNumber.getAndIncrement());
             broadcaster.sendNotification(notification);
         }
 
@@ -5460,11 +5171,11 @@ public class StandardContext extends ContainerBase
         // This object will no longer be visible or used.
         try {
             resetContext();
-        } catch( Exception ex ) {
-            log.error( "Error resetting context " + this + " " + ex, ex );
+        } catch (Exception ex) {
+            log.error("Error resetting context " + this + " " + ex, ex);
         }
 
-        //reset the instance manager
+        // reset the instance manager
         setInstanceManager(null);
 
         if (log.isDebugEnabled()) {
@@ -5474,14 +5185,10 @@ public class StandardContext extends ContainerBase
     }
 
     /**
-     * Destroy needs to clean up the context completely.
-     *
-     * The problem is that undoing all the config in start() and restoring
-     * a 'fresh' state is impossible. After stop()/destroy()/init()/start()
-     * we should have the same state as if a fresh start was done - i.e
-     * read modified web.xml, etc. This can only be done by completely
-     * removing the context object and remapping a new one, or by cleaning
-     * up everything.
+     * Destroy needs to clean up the context completely. The problem is that undoing all the config in start() and
+     * restoring a 'fresh' state is impossible. After stop()/destroy()/init()/start() we should have the same state as
+     * if a fresh start was done - i.e read modified web.xml, etc. This can only be done by completely removing the
+     * context object and remapping a new one, or by cleaning up everything.
      */
     @Override
     protected void destroyInternal() throws LifecycleException {
@@ -5490,9 +5197,8 @@ public class StandardContext extends ContainerBase
         // have been set so the notification can't be created
         if (getObjectName() != null) {
             // Send j2ee.object.deleted notification
-            Notification notification =
-                new Notification("j2ee.object.deleted", this.getObjectName(),
-                                 sequenceNumber.getAndIncrement());
+            Notification notification = new Notification("j2ee.object.deleted", this.getObjectName(),
+                    sequenceNumber.getAndIncrement());
             broadcaster.sendNotification(notification);
         }
 
@@ -5530,8 +5236,7 @@ public class StandardContext extends ContainerBase
             try {
                 loader.backgroundProcess();
             } catch (Exception e) {
-                log.warn(sm.getString(
-                        "standardContext.backgroundProcess.loader", loader), e);
+                log.warn(sm.getString("standardContext.backgroundProcess.loader", loader), e);
             }
         }
         Manager manager = getManager();
@@ -5539,9 +5244,7 @@ public class StandardContext extends ContainerBase
             try {
                 manager.backgroundProcess();
             } catch (Exception e) {
-                log.warn(sm.getString(
-                        "standardContext.backgroundProcess.manager", manager),
-                        e);
+                log.warn(sm.getString("standardContext.backgroundProcess.manager", manager), e);
             }
         }
         WebResourceRoot resources = getResources();
@@ -5549,9 +5252,7 @@ public class StandardContext extends ContainerBase
             try {
                 resources.backgroundProcess();
             } catch (Exception e) {
-                log.warn(sm.getString(
-                        "standardContext.backgroundProcess.resources",
-                        resources), e);
+                log.warn(sm.getString("standardContext.backgroundProcess.resources", resources), e);
             }
         }
         InstanceManager instanceManager = getInstanceManager();
@@ -5559,9 +5260,7 @@ public class StandardContext extends ContainerBase
             try {
                 instanceManager.backgroundProcess();
             } catch (Exception e) {
-                log.warn(sm.getString(
-                        "standardContext.backgroundProcess.instanceManager",
-                        resources), e);
+                log.warn(sm.getString("standardContext.backgroundProcess.instanceManager", resources), e);
             }
         }
         super.backgroundProcess();
@@ -5597,7 +5296,7 @@ public class StandardContext extends ContainerBase
         postConstructMethods.clear();
         preDestroyMethods.clear();
 
-        if(log.isDebugEnabled()) {
+        if (log.isDebugEnabled()) {
             log.debug("resetContext " + getObjectName());
         }
     }
@@ -5606,12 +5305,11 @@ public class StandardContext extends ContainerBase
     // ------------------------------------------------------ Protected Methods
 
     /**
-     * Adjust the URL pattern to begin with a leading slash, if appropriate
-     * (i.e. we are running a servlet 2.2 application).  Otherwise, return
-     * the specified URL pattern unchanged.
+     * Adjust the URL pattern to begin with a leading slash, if appropriate (i.e. we are running a servlet 2.2
+     * application). Otherwise, return the specified URL pattern unchanged.
+     *
+     * @param urlPattern The URL pattern to be adjusted (if needed) and returned
      *
-     * @param urlPattern The URL pattern to be adjusted (if needed)
-     *  and returned
      * @return the URL pattern with a leading slash if needed
      */
     protected String adjustURLPattern(String urlPattern) {
@@ -5625,9 +5323,8 @@ public class StandardContext extends ContainerBase
         if (!isServlet22()) {
             return urlPattern;
         }
-        if(log.isDebugEnabled()) {
-            log.debug(sm.getString("standardContext.urlPattern.patternWarning",
-                         urlPattern));
+        if (log.isDebugEnabled()) {
+            log.debug(sm.getString("standardContext.urlPattern.patternWarning", urlPattern));
         }
         return "/" + urlPattern;
 
@@ -5646,8 +5343,7 @@ public class StandardContext extends ContainerBase
 
 
     @Override
-    public Set<String> addServletSecurity(
-            ServletRegistration.Dynamic registration,
+    public Set<String> addServletSecurity(ServletRegistration.Dynamic registration,
             ServletSecurityElement servletSecurityElement) {
 
         Set<String> conflicts = new HashSet<>();
@@ -5656,12 +5352,10 @@ public class StandardContext extends ContainerBase
         for (String urlPattern : urlPatterns) {
             boolean foundConflict = false;
 
-            SecurityConstraint[] securityConstraints =
-                findConstraints();
+            SecurityConstraint[] securityConstraints = findConstraints();
             for (SecurityConstraint securityConstraint : securityConstraints) {
 
-                SecurityCollection[] collections =
-                    securityConstraint.findCollections();
+                SecurityCollection[] collections = securityConstraint.findCollections();
                 for (SecurityCollection collection : collections) {
                     if (collection.findPattern(urlPattern)) {
                         // First pattern found will indicate if there is a
@@ -5697,21 +5391,18 @@ public class StandardContext extends ContainerBase
             }
 
             // Note: For programmatically added Servlets this may not be the
-            //       complete set of security constraints since additional
-            //       URL patterns can be added after the application has called
-            //       setSecurity. For all programmatically added servlets, the
-            //       #dynamicServletAdded() method sets a flag that ensures that
-            //       the constraints are re-evaluated before the servlet is
-            //       first used
+            // complete set of security constraints since additional
+            // URL patterns can be added after the application has called
+            // setSecurity. For all programmatically added servlets, the
+            // #dynamicServletAdded() method sets a flag that ensures that
+            // the constraints are re-evaluated before the servlet is
+            // first used
 
             // If the pattern did not conflict, add the new constraint(s).
             if (!foundConflict) {
-                SecurityConstraint[] newSecurityConstraints =
-                        SecurityConstraint.createConstraints(
-                                servletSecurityElement,
-                                urlPattern);
-                for (SecurityConstraint securityConstraint :
-                        newSecurityConstraints) {
+                SecurityConstraint[] newSecurityConstraints = SecurityConstraint
+                        .createConstraints(servletSecurityElement, urlPattern);
+                for (SecurityConstraint securityConstraint : newSecurityConstraints) {
                     addConstraint(securityConstraint);
                 }
             }
@@ -5722,8 +5413,8 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Bind current thread, both for CL purposes and for JNDI ENC support
-     * during : startup, shutdown and reloading of the context.
+     * Bind current thread, both for CL purposes and for JNDI ENC support during : startup, shutdown and reloading of
+     * the context.
      *
      * @return the previous context class loader
      */
@@ -5777,8 +5468,7 @@ public class StandardContext extends ContainerBase
             originalClassLoader = Thread.currentThread().getContextClassLoader();
         }
 
-        if (webApplicationClassLoader == null ||
-                webApplicationClassLoader == originalClassLoader) {
+        if (webApplicationClassLoader == null || webApplicationClassLoader == originalClassLoader) {
             // Not possible or not necessary to switch class loaders. Return
             // null to indicate this.
             return null;
@@ -5792,8 +5482,7 @@ public class StandardContext extends ContainerBase
                 threadBindingListener.bind();
             } catch (Throwable t) {
                 ExceptionUtils.handleThrowable(t);
-                log.error(sm.getString(
-                        "standardContext.threadBindingListenerError", getName()), t);
+                log.error(sm.getString("standardContext.threadBindingListenerError", getName()), t);
             }
         }
 
@@ -5818,8 +5507,7 @@ public class StandardContext extends ContainerBase
                 threadBindingListener.unbind();
             } catch (Throwable t) {
                 ExceptionUtils.handleThrowable(t);
-                log.error(sm.getString(
-                        "standardContext.threadBindingListenerError", getName()), t);
+                log.error(sm.getString("standardContext.threadBindingListenerError", getName()), t);
             }
         }
 
@@ -5836,19 +5524,19 @@ public class StandardContext extends ContainerBase
         if (namingContextName == null) {
             Container parent = getParent();
             if (parent == null) {
-            namingContextName = getName();
+                namingContextName = getName();
             } else {
-            Deque<String> stk = new ArrayDeque<>();
-            StringBuilder buff = new StringBuilder();
-            while (parent != null) {
-                stk.addFirst(parent.getName());
-                parent = parent.getParent();
-            }
-            while (!stk.isEmpty()) {
-                buff.append("/").append(stk.remove());
-            }
-            buff.append(getName());
-            namingContextName = buff.toString();
+                Deque<String> stk = new ArrayDeque<>();
+                StringBuilder buff = new StringBuilder();
+                while (parent != null) {
+                    stk.addFirst(parent.getName());
+                    parent = parent.getParent();
+                }
+                while (!stk.isEmpty()) {
+                    buff.append("/").append(stk.remove());
+                }
+                buff.append(getName());
+                namingContextName = buff.toString();
             }
         }
         return namingContextName;
@@ -5891,8 +5579,7 @@ public class StandardContext extends ContainerBase
 
         if ((instances != null) && (instances.length > 0)) {
 
-            ServletRequestEvent event =
-                    new ServletRequestEvent(getServletContext(), request);
+            ServletRequestEvent event = new ServletRequestEvent(getServletContext(), request);
 
             for (Object instance : instances) {
                 if (instance == null) {
@@ -5907,9 +5594,9 @@ public class StandardContext extends ContainerBase
                     listener.requestInitialized(event);
                 } catch (Throwable t) {
                     ExceptionUtils.handleThrowable(t);
-                    getLogger().error(sm.getString(
-                            "standardContext.requestListener.requestInit",
-                            instance.getClass().getName()), t);
+                    getLogger().error(
+                            sm.getString("standardContext.requestListener.requestInit", instance.getClass().getName()),
+                            t);
                     request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
                     return false;
                 }
@@ -5925,26 +5612,23 @@ public class StandardContext extends ContainerBase
 
         if ((instances != null) && (instances.length > 0)) {
 
-            ServletRequestEvent event =
-                new ServletRequestEvent(getServletContext(), request);
+            ServletRequestEvent event = new ServletRequestEvent(getServletContext(), request);
 
             for (int i = 0; i < instances.length; i++) {
-                int j = (instances.length -1) -i;
+                int j = (instances.length - 1) - i;
                 if (instances[j] == null) {
                     continue;
                 }
                 if (!(instances[j] instanceof ServletRequestListener)) {
                     continue;
                 }
-                ServletRequestListener listener =
-                    (ServletRequestListener) instances[j];
+                ServletRequestListener listener = (ServletRequestListener) instances[j];
 
                 try {
                     listener.requestDestroyed(event);
                 } catch (Throwable t) {
                     ExceptionUtils.handleThrowable(t);
-                    getLogger().error(sm.getString(
-                            "standardContext.requestListener.requestInit",
+                    getLogger().error(sm.getString("standardContext.requestListener.requestInit",
                             instances[j].getClass().getName()), t);
                     request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
                     return false;
@@ -5958,12 +5642,10 @@ public class StandardContext extends ContainerBase
     @Override
     public void addPostConstructMethod(String clazz, String method) {
         if (clazz == null || method == null) {
-            throw new IllegalArgumentException(
-                    sm.getString("standardContext.postconstruct.required"));
+            throw new IllegalArgumentException(sm.getString("standardContext.postconstruct.required"));
         }
         if (postConstructMethods.get(clazz) != null) {
-            throw new IllegalArgumentException(sm.getString(
-                    "standardContext.postconstruct.duplicate", clazz));
+            throw new IllegalArgumentException(sm.getString("standardContext.postconstruct.duplicate", clazz));
         }
 
         postConstructMethods.put(clazz, method);
@@ -5981,12 +5663,10 @@ public class StandardContext extends ContainerBase
     @Override
     public void addPreDestroyMethod(String clazz, String method) {
         if (clazz == null || method == null) {
-            throw new IllegalArgumentException(
-                    sm.getString("standardContext.predestroy.required"));
+            throw new IllegalArgumentException(sm.getString("standardContext.predestroy.required"));
         }
         if (preDestroyMethods.get(clazz) != null) {
-            throw new IllegalArgumentException(sm.getString(
-                    "standardContext.predestroy.duplicate", clazz));
+            throw new IllegalArgumentException(sm.getString("standardContext.predestroy.duplicate", clazz));
         }
 
         preDestroyMethods.put(clazz, method);
@@ -6042,11 +5722,11 @@ public class StandardContext extends ContainerBase
             if (parentHost != null) {
                 hostName = parentHost.getName();
                 if (parentHost instanceof StandardHost) {
-                    hostWorkDir = ((StandardHost)parentHost).getWorkDir();
+                    hostWorkDir = ((StandardHost) parentHost).getWorkDir();
                 }
                 Container parentEngine = parentHost.getParent();
                 if (parentEngine != null) {
-                   engineName = parentEngine.getName();
+                    engineName = parentEngine.getName();
                 }
             }
             if ((hostName == null) || (hostName.length() < 1)) {
@@ -6065,11 +5745,10 @@ public class StandardContext extends ContainerBase
             if (temp.length() < 1) {
                 temp = ContextName.ROOT_NAME;
             }
-            if (hostWorkDir != null ) {
+            if (hostWorkDir != null) {
                 workDir = hostWorkDir + File.separator + temp;
             } else {
-                workDir = "work" + File.separator + engineName +
-                    File.separator + hostName + File.separator + temp;
+                workDir = "work" + File.separator + engineName + File.separator + hostName + File.separator + temp;
             }
             setWorkDir(workDir);
         }
@@ -6082,13 +5761,11 @@ public class StandardContext extends ContainerBase
                 catalinaHomePath = getCatalinaBase().getCanonicalPath();
                 dir = new File(catalinaHomePath, workDir);
             } catch (IOException e) {
-                log.warn(sm.getString("standardContext.workCreateException",
-                        workDir, catalinaHomePath, getName()), e);
+                log.warn(sm.getString("standardContext.workCreateException", workDir, catalinaHomePath, getName()), e);
             }
         }
         if (!dir.mkdirs() && !dir.isDirectory()) {
-            log.warn(sm.getString("standardContext.workCreateFail", dir,
-                    getName()));
+            log.warn(sm.getString("standardContext.workCreateFail", dir, getName()));
         }
 
         // Set the appropriate servlet context attribute
@@ -6113,10 +5790,11 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Validate the syntax of a proposed <code>&lt;url-pattern&gt;</code>
-     * for conformance with specification requirements.
+     * Validate the syntax of a proposed <code>&lt;url-pattern&gt;</code> for conformance with specification
+     * requirements.
      *
      * @param urlPattern URL pattern to be validated
+     *
      * @return <code>true</code> if the URL pattern is conformant
      */
     private boolean validateURLPattern(String urlPattern) {
@@ -6149,17 +5827,15 @@ public class StandardContext extends ContainerBase
 
 
     /**
-     * Check for unusual but valid <code>&lt;url-pattern&gt;</code>s.
-     * See Bugzilla 34805, 43079 & 43080
+     * Check for unusual but valid <code>&lt;url-pattern&gt;</code>s. See Bugzilla 34805, 43079 & 43080
      */
     private void checkUnusualURLPattern(String urlPattern) {
         if (log.isInfoEnabled()) {
             // First group checks for '*' or '/foo*' style patterns
             // Second group checks for *.foo.bar style patterns
-            if((urlPattern.endsWith("*") && (urlPattern.length() < 2 ||
-                        urlPattern.charAt(urlPattern.length()-2) != '/')) ||
-                    urlPattern.startsWith("*.") && urlPattern.length() > 2 &&
-                        urlPattern.lastIndexOf('.') > 1) {
+            if ((urlPattern.endsWith("*") &&
+                    (urlPattern.length() < 2 || urlPattern.charAt(urlPattern.length() - 2) != '/')) ||
+                    urlPattern.startsWith("*.") && urlPattern.length() > 2 && urlPattern.lastIndexOf('.') > 1) {
                 log.info(sm.getString("standardContext.suspiciousUrl", urlPattern, getName()));
             }
         }
@@ -6171,8 +5847,7 @@ public class StandardContext extends ContainerBase
     @Override
     protected String getObjectNameKeyProperties() {
 
-        StringBuilder keyProperties =
-            new StringBuilder("j2eeType=WebModule,");
+        StringBuilder keyProperties = new StringBuilder("j2eeType=WebModule,");
         keyProperties.append(getObjectKeyPropertiesNameOnly());
         keyProperties.append(",J2EEApplication=");
         keyProperties.append(getJ2EEApplication());
@@ -6211,8 +5886,8 @@ public class StandardContext extends ContainerBase
 
         // Send j2ee.object.created notification
         if (this.getObjectName() != null) {
-            Notification notification = new Notification("j2ee.object.created",
-                    this.getObjectName(), sequenceNumber.getAndIncrement());
+            Notification notification = new Notification("j2ee.object.created", this.getObjectName(),
+                    sequenceNumber.getAndIncrement());
             broadcaster.sendNotification(notification);
         }
     }
@@ -6220,18 +5895,21 @@ public class StandardContext extends ContainerBase
 
     /**
      * Remove a JMX notificationListener
-     * @see javax.management.NotificationEmitter#removeNotificationListener(javax.management.NotificationListener, javax.management.NotificationFilter, java.lang.Object)
+     *
+     * @see javax.management.NotificationEmitter#removeNotificationListener(javax.management.NotificationListener,
+     *          javax.management.NotificationFilter, java.lang.Object)
      */
     @Override
-    public void removeNotificationListener(NotificationListener listener,
-            NotificationFilter filter, Object object) throws ListenerNotFoundException {
-        broadcaster.removeNotificationListener(listener,filter,object);
+    public void removeNotificationListener(NotificationListener listener, NotificationFilter filter, Object object)
+            throws ListenerNotFoundException {
+        broadcaster.removeNotificationListener(listener, filter, object);
     }
 
     private MBeanNotificationInfo[] notificationInfo;
 
     /**
      * Get JMX Broadcaster Info
+     *
      * @see javax.management.NotificationBroadcaster#getNotificationInfo()
      */
     @Override
@@ -6239,33 +5917,19 @@ public class StandardContext extends ContainerBase
         // FIXME: we not send j2ee.attribute.changed
         if (notificationInfo == null) {
             notificationInfo = new MBeanNotificationInfo[] {
-                    new MBeanNotificationInfo(
-                            new String[] { "j2ee.object.created" },
-                            Notification.class.getName(),
+                    new MBeanNotificationInfo(new String[] { "j2ee.object.created" }, Notification.class.getName(),
                             "web application is created"),
-                    new MBeanNotificationInfo(
-                            new String[] { "j2ee.state.starting" },
-                            Notification.class.getName(),
+                    new MBeanNotificationInfo(new String[] { "j2ee.state.starting" }, Notification.class.getName(),
                             "change web application is starting"),
-                    new MBeanNotificationInfo(
-                            new String[] { "j2ee.state.running" },
-                            Notification.class.getName(),
+                    new MBeanNotificationInfo(new String[] { "j2ee.state.running" }, Notification.class.getName(),
                             "web application is running"),
-                    new MBeanNotificationInfo(
-                            new String[] { "j2ee.state.stopping" },
-                            Notification.class.getName(),
+                    new MBeanNotificationInfo(new String[] { "j2ee.state.stopping" }, Notification.class.getName(),
                             "web application start to stopped"),
-                    new MBeanNotificationInfo(
-                            new String[] { "j2ee.object.stopped" },
-                            Notification.class.getName(),
+                    new MBeanNotificationInfo(new String[] { "j2ee.object.stopped" }, Notification.class.getName(),
                             "web application is stopped"),
-                    new MBeanNotificationInfo(
-                            new String[] { "j2ee.object.deleted" },
-                            Notification.class.getName(),
+                    new MBeanNotificationInfo(new String[] { "j2ee.object.deleted" }, Notification.class.getName(),
                             "web application is deleted"),
-                    new MBeanNotificationInfo(
-                            new String[] { "j2ee.object.failed" },
-                            Notification.class.getName(),
+                    new MBeanNotificationInfo(new String[] { "j2ee.object.failed" }, Notification.class.getName(),
                             "web application failed") };
         }
 
@@ -6275,22 +5939,24 @@ public class StandardContext extends ContainerBase
 
     /**
      * Add a JMX NotificationListener
-     * @see javax.management.NotificationBroadcaster#addNotificationListener(javax.management.NotificationListener, javax.management.NotificationFilter, java.lang.Object)
+     *
+     * @see javax.management.NotificationBroadcaster#addNotificationListener(javax.management.NotificationListener,
+     *          javax.management.NotificationFilter, java.lang.Object)
      */
     @Override
-    public void addNotificationListener(NotificationListener listener,
-            NotificationFilter filter, Object object) throws IllegalArgumentException {
-        broadcaster.addNotificationListener(listener,filter,object);
+    public void addNotificationListener(NotificationListener listener, NotificationFilter filter, Object object)
+            throws IllegalArgumentException {
+        broadcaster.addNotificationListener(listener, filter, object);
     }
 
 
     /**
      * Remove a JMX-NotificationListener
+     *
      * @see javax.management.NotificationBroadcaster#removeNotificationListener(javax.management.NotificationListener)
      */
     @Override
-    public void removeNotificationListener(NotificationListener listener)
-    throws ListenerNotFoundException {
+    public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException {
         broadcaster.removeNotificationListener(listener);
     }
 
@@ -6365,22 +6031,20 @@ public class StandardContext extends ContainerBase
     }
 
     public String setServer(String server) {
-        return this.server=server;
+        return this.server = server;
     }
 
     /**
      * Gets the time this context was started.
      *
-     * @return Time (in milliseconds since January 1, 1970, 00:00:00) when this
-     * context was started
+     * @return Time (in milliseconds since January 1, 1970, 00:00:00) when this context was started
      */
     public long getStartTime() {
         return startTime;
     }
 
 
-    private static class NoPluggabilityServletContext
-            implements ServletContext {
+    private static class NoPluggabilityServletContext implements ServletContext {
 
         private final ServletContext sc;
 
@@ -6400,7 +6064,7 @@ public class StandardContext extends ContainerBase
 
         @Override
         public int getMajorVersion() {
-           return sc.getMajorVersion();
+            return sc.getMajorVersion();
         }
 
         @Override
@@ -6480,8 +6144,7 @@ public class StandardContext extends ContainerBase
 
         @Override
         public boolean setInitParameter(String name, String value) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
@@ -6511,99 +6174,78 @@ public class StandardContext extends ContainerBase
 
         @Override
         public Dynamic addServlet(String servletName, String className) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
         public Dynamic addServlet(String servletName, Servlet servlet) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
-        public Dynamic addServlet(String servletName,
-                Class<? extends Servlet> servletClass) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+        public Dynamic addServlet(String servletName, Class<? extends Servlet> servletClass) {
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
         public Dynamic addJspFile(String jspName, String jspFile) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
-        public <T extends Servlet> T createServlet(Class<T> c)
-                throws ServletException {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+        public <T extends Servlet> T createServlet(Class<T> c) throws ServletException {
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
         public ServletRegistration getServletRegistration(String servletName) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
-        public Map<String,? extends ServletRegistration> getServletRegistrations() {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+        public Map<String, ? extends ServletRegistration> getServletRegistrations() {
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
-        public jakarta.servlet.FilterRegistration.Dynamic addFilter(
-                String filterName, String className) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+        public jakarta.servlet.FilterRegistration.Dynamic addFilter(String filterName, String className) {
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
-        public jakarta.servlet.FilterRegistration.Dynamic addFilter(
-                String filterName, Filter filter) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+        public jakarta.servlet.FilterRegistration.Dynamic addFilter(String filterName, Filter filter) {
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
-        public jakarta.servlet.FilterRegistration.Dynamic addFilter(
-                String filterName, Class<? extends Filter> filterClass) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+        public jakarta.servlet.FilterRegistration.Dynamic addFilter(String filterName,
+                Class<? extends Filter> filterClass) {
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
-        public <T extends Filter> T createFilter(Class<T> c)
-                throws ServletException {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+        public <T extends Filter> T createFilter(Class<T> c) throws ServletException {
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
         public FilterRegistration getFilterRegistration(String filterName) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
-        public Map<String,? extends FilterRegistration> getFilterRegistrations() {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+        public Map<String, ? extends FilterRegistration> getFilterRegistrations() {
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
         public SessionCookieConfig getSessionCookieConfig() {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
-        public void setSessionTrackingModes(
-                Set<SessionTrackingMode> sessionTrackingModes) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+        public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
@@ -6618,27 +6260,22 @@ public class StandardContext extends ContainerBase
 
         @Override
         public void addListener(String className) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
         public <T extends EventListener> void addListener(T t) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
         public void addListener(Class<? extends EventListener> listenerClass) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
-        public <T extends EventListener> T createListener(Class<T> c)
-                throws ServletException {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+        public <T extends EventListener> T createListener(Class<T> c) throws ServletException {
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
@@ -6653,8 +6290,7 @@ public class StandardContext extends ContainerBase
 
         @Override
         public void declareRoles(String... roleNames) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
@@ -6669,8 +6305,7 @@ public class StandardContext extends ContainerBase
 
         @Override
         public void setSessionTimeout(int sessionTimeout) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
@@ -6680,8 +6315,7 @@ public class StandardContext extends ContainerBase
 
         @Override
         public void setRequestCharacterEncoding(String encoding) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
 
         @Override
@@ -6691,8 +6325,7 @@ public class StandardContext extends ContainerBase
 
         @Override
         public void setResponseCharacterEncoding(String encoding) {
-            throw new UnsupportedOperationException(
-                    sm.getString("noPluggabilityServletContext.notAllowed"));
+            throw new UnsupportedOperationException(sm.getString("noPluggabilityServletContext.notAllowed"));
         }
     }
 }

==================================================
StandardEngine.java
index 33dc8dccb5..85fe03aa3e 100644
--- a/java/org/apache/catalina/core/StandardContextValve.java
+++ b/java/org/apache/catalina/core/StandardContextValve.java
@@ -31,11 +31,9 @@ import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * Valve that implements the default basic behavior for the
- * <code>StandardContext</code> container implementation.
+ * Valve that implements the default basic behavior for the <code>StandardContext</code> container implementation.
  * <p>
- * <b>USAGE CONSTRAINT</b>:  This implementation is likely to be useful only
- * when processing HTTP requests.
+ * <b>USAGE CONSTRAINT</b>: This implementation is likely to be useful only when processing HTTP requests.
  *
  * @author Craig R. McClanahan
  */
@@ -49,26 +47,22 @@ final class StandardContextValve extends ValveBase {
 
 
     /**
-     * Select the appropriate child Wrapper to process this request,
-     * based on the specified request URI.  If no matching Wrapper can
-     * be found, return an appropriate HTTP error.
+     * Select the appropriate child Wrapper to process this request, based on the specified request URI. If no matching
+     * Wrapper can be found, return an appropriate HTTP error.
      *
-     * @param request Request to be processed
+     * @param request  Request to be processed
      * @param response Response to be produced
      *
-     * @exception IOException if an input/output error occurred
+     * @exception IOException      if an input/output error occurred
      * @exception ServletException if a servlet error occurred
      */
     @Override
-    public final void invoke(Request request, Response response)
-        throws IOException, ServletException {
+    public final void invoke(Request request, Response response) throws IOException, ServletException {
 
         // Disallow any direct access to resources under WEB-INF or META-INF
         MessageBytes requestPathMB = request.getRequestPathMB();
-        if ((requestPathMB.startsWithIgnoreCase("/META-INF/", 0))
-                || (requestPathMB.equalsIgnoreCase("/META-INF"))
-                || (requestPathMB.startsWithIgnoreCase("/WEB-INF/", 0))
-                || (requestPathMB.equalsIgnoreCase("/WEB-INF"))) {
+        if ((requestPathMB.startsWithIgnoreCase("/META-INF/", 0)) || (requestPathMB.equalsIgnoreCase("/META-INF")) ||
+                (requestPathMB.startsWithIgnoreCase("/WEB-INF/", 0)) || (requestPathMB.equalsIgnoreCase("/WEB-INF"))) {
             response.sendError(HttpServletResponse.SC_NOT_FOUND);
             return;
         }
@@ -84,8 +78,7 @@ final class StandardContextValve extends ValveBase {
         try {
             response.sendAcknowledgement(ContinueResponseTiming.IMMEDIATELY);
         } catch (IOException ioe) {
-            container.getLogger().error(sm.getString(
-                    "standardContextValve.acknowledgeException"), ioe);
+            container.getLogger().error(sm.getString("standardContextValve.acknowledgeException"), ioe);
             request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, ioe);
             response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
             return;

==================================================
StandardEngineValve.java
index 0206369888..06afa6702c 100644
--- a/java/org/apache/catalina/core/StandardEngine.java
+++ b/java/org/apache/catalina/core/StandardEngine.java
@@ -44,9 +44,8 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 
 /**
- * Standard implementation of the <b>Engine</b> interface.  Each
- * child container must be a Host implementation to process the specific
- * fully qualified host name of that virtual host.
+ * Standard implementation of the <b>Engine</b> interface. Each child container must be a Host implementation to process
+ * the specific fully qualified host name of that virtual host.
  *
  * @author Craig R. McClanahan
  */
@@ -70,8 +69,7 @@ public class StandardEngine extends ContainerBase implements Engine {
     // ----------------------------------------------------- Instance Variables
 
     /**
-     * Host name to use when no server host, or an unknown host,
-     * is specified in the request.
+     * Host name to use when no server host, or an unknown host, is specified in the request.
      */
     private String defaultHost = null;
 
@@ -82,23 +80,19 @@ public class StandardEngine extends ContainerBase implements Engine {
     private Service service = null;
 
     /**
-     * The JVM Route ID for this Tomcat instance. All Route ID's must be unique
-     * across the cluster.
+     * The JVM Route ID for this Tomcat instance. All Route ID's must be unique across the cluster.
      */
     private String jvmRouteId;
 
     /**
-     * Default access log to use for request/response pairs where we can't ID
-     * the intended host and context.
+     * Default access log to use for request/response pairs where we can't ID the intended host and context.
      */
-    private final AtomicReference<AccessLog> defaultAccessLog =
-        new AtomicReference<>();
+    private final AtomicReference<AccessLog> defaultAccessLog = new AtomicReference<>();
 
     // ------------------------------------------------------------- Properties
 
     /**
-     * Obtain the configured Realm and provide a default Realm implementation
-     * when no explicit configuration is set.
+     * Obtain the configured Realm and provide a default Realm implementation when no explicit configuration is set.
      *
      * @return configured realm, or a {@link NullRealm} by default
      */
@@ -141,15 +135,13 @@ public class StandardEngine extends ContainerBase implements Engine {
         if (getState().isAvailable()) {
             service.getMapper().setDefaultHostName(host);
         }
-        support.firePropertyChange("defaultHost", oldDefaultHost,
-                                   this.defaultHost);
+        support.firePropertyChange("defaultHost", oldDefaultHost, this.defaultHost);
 
     }
 
 
     /**
-     * Set the cluster-wide unique identifier for this Engine.
-     * This value is only useful in a load-balancing scenario.
+     * Set the cluster-wide unique identifier for this Engine. This value is only useful in a load-balancing scenario.
      * <p>
      * This property should not be changed once it is set.
      */
@@ -160,8 +152,8 @@ public class StandardEngine extends ContainerBase implements Engine {
 
 
     /**
-     * Retrieve the cluster-wide unique identifier for this Engine.
-     * This value is only useful in a load-balancing scenario.
+     * Retrieve the cluster-wide unique identifier for this Engine. This value is only useful in a load-balancing
+     * scenario.
      */
     @Override
     public String getJvmRoute() {
@@ -192,8 +184,7 @@ public class StandardEngine extends ContainerBase implements Engine {
 
 
     /**
-     * Add a child Container, only if the proposed child is an implementation
-     * of Host.
+     * Add a child Container, only if the proposed child is an implementation of Host.
      *
      * @param child Child container to be added
      */
@@ -201,8 +192,7 @@ public class StandardEngine extends ContainerBase implements Engine {
     public void addChild(Container child) {
 
         if (!(child instanceof Host)) {
-            throw new IllegalArgumentException
-                (sm.getString("standardEngine.notHost"));
+            throw new IllegalArgumentException(sm.getString("standardEngine.notHost"));
         }
         super.addChild(child);
 
@@ -210,16 +200,15 @@ public class StandardEngine extends ContainerBase implements Engine {
 
 
     /**
-     * Disallow any attempt to set a parent for this Container, since an
-     * Engine is supposed to be at the top of the Container hierarchy.
+     * Disallow any attempt to set a parent for this Container, since an Engine is supposed to be at the top of the
+     * Container hierarchy.
      *
      * @param container Proposed parent Container
      */
     @Override
     public void setParent(Container container) {
 
-        throw new IllegalArgumentException
-            (sm.getString("standardEngine.notParent"));
+        throw new IllegalArgumentException(sm.getString("standardEngine.notParent"));
 
     }
 
@@ -234,11 +223,11 @@ public class StandardEngine extends ContainerBase implements Engine {
 
 
     /**
-     * Start this component and implement the requirements
-     * of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
+     * Start this component and implement the requirements of
+     * {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
+     * @exception LifecycleException if this component detects a fatal error that prevents this component from being
+     *                                   used
      */
     @Override
     protected synchronized void startInternal() throws LifecycleException {
@@ -254,14 +243,12 @@ public class StandardEngine extends ContainerBase implements Engine {
 
 
     /**
-     * Override the default implementation. If no access log is defined for the
-     * Engine, look for one in the Engine's default host and then the default
-     * host's ROOT context. If still none is found, return the default NoOp
-     * access log.
+     * Override the default implementation. If no access log is defined for the Engine, look for one in the Engine's
+     * default host and then the default host's ROOT context. If still none is found, return the default NoOp access
+     * log.
      */
     @Override
-    public void logAccess(Request request, Response response, long time,
-            boolean useDefault) {
+    public void logAccess(Request request, Response response, long time, boolean useDefault) {
 
         boolean logged = false;
 
@@ -281,23 +268,18 @@ public class StandardEngine extends ContainerBase implements Engine {
                     newDefaultAccessLog = host.getAccessLog();
 
                     if (newDefaultAccessLog != null) {
-                        if (defaultAccessLog.compareAndSet(null,
-                                newDefaultAccessLog)) {
-                            AccessLogListener l = new AccessLogListener(this,
-                                    host, null);
+                        if (defaultAccessLog.compareAndSet(null, newDefaultAccessLog)) {
+                            AccessLogListener l = new AccessLogListener(this, host, null);
                             l.install();
                         }
                     } else {
                         // Try the ROOT context of default host
                         context = (Context) host.findChild("");
-                        if (context != null &&
-                                context.getState().isAvailable()) {
+                        if (context != null && context.getState().isAvailable()) {
                             newDefaultAccessLog = context.getAccessLog();
                             if (newDefaultAccessLog != null) {
-                                if (defaultAccessLog.compareAndSet(null,
-                                        newDefaultAccessLog)) {
-                                    AccessLogListener l = new AccessLogListener(
-                                            this, null, context);
+                                if (defaultAccessLog.compareAndSet(null, newDefaultAccessLog)) {
+                                    AccessLogListener l = new AccessLogListener(this, null, context);
                                     l.install();
                                 }
                             }
@@ -307,10 +289,8 @@ public class StandardEngine extends ContainerBase implements Engine {
 
                 if (newDefaultAccessLog == null) {
                     newDefaultAccessLog = new NoopAccessLog();
-                    if (defaultAccessLog.compareAndSet(null,
-                            newDefaultAccessLog)) {
-                        AccessLogListener l = new AccessLogListener(this, host,
-                                context);
+                    if (defaultAccessLog.compareAndSet(null, newDefaultAccessLog)) {
+                        AccessLogListener l = new AccessLogListener(this, host, context);
                         l.install();
                     }
                 }
@@ -368,7 +348,7 @@ public class StandardEngine extends ContainerBase implements Engine {
     }
 
 
-    // -------------------- JMX registration  --------------------
+    // -------------------- JMX registration --------------------
 
     @Override
     protected String getObjectNameKeyProperties() {
@@ -391,8 +371,7 @@ public class StandardEngine extends ContainerBase implements Engine {
         }
 
         @Override
-        public void setRequestAttributesEnabled(
-                boolean requestAttributesEnabled) {
+        public void setRequestAttributesEnabled(boolean requestAttributesEnabled) {
             // NOOP
 
         }
@@ -405,16 +384,14 @@ public class StandardEngine extends ContainerBase implements Engine {
     }
 
     protected static final class AccessLogListener
-            implements PropertyChangeListener, LifecycleListener,
-            ContainerListener {
+            implements PropertyChangeListener, LifecycleListener, ContainerListener {
 
         private final StandardEngine engine;
         private final Host host;
         private final Context context;
         private volatile boolean disabled = false;
 
-        public AccessLogListener(StandardEngine engine, Host host,
-                Context context) {
+        public AccessLogListener(StandardEngine engine, Host host, Context context) {
             this.engine = engine;
             this.host = host;
             this.context = context;
@@ -450,8 +427,7 @@ public class StandardEngine extends ContainerBase implements Engine {
             }
 
             String type = event.getType();
-            if (Lifecycle.AFTER_START_EVENT.equals(type) ||
-                    Lifecycle.BEFORE_STOP_EVENT.equals(type) ||
+            if (Lifecycle.AFTER_START_EVENT.equals(type) || Lifecycle.BEFORE_STOP_EVENT.equals(type) ||
                     Lifecycle.BEFORE_DESTROY_EVENT.equals(type)) {
                 // Container is being started/stopped/removed
                 // Force re-calculation and disable listener since it won't

==================================================
StandardHost.java
index c9e83b386b..5e21a1c418 100644
--- a/java/org/apache/catalina/core/StandardEngineValve.java
+++ b/java/org/apache/catalina/core/StandardEngineValve.java
@@ -26,17 +26,15 @@ import org.apache.catalina.connector.Response;
 import org.apache.catalina.valves.ValveBase;
 
 /**
- * Valve that implements the default basic behavior for the
- * <code>StandardEngine</code> container implementation.
+ * Valve that implements the default basic behavior for the <code>StandardEngine</code> container implementation.
  * <p>
- * <b>USAGE CONSTRAINT</b>:  This implementation is likely to be useful only
- * when processing HTTP requests.
+ * <b>USAGE CONSTRAINT</b>: This implementation is likely to be useful only when processing HTTP requests.
  *
  * @author Craig R. McClanahan
  */
 final class StandardEngineValve extends ValveBase {
 
-    //------------------------------------------------------ Constructor
+    // ------------------------------------------------------ Constructor
     public StandardEngineValve() {
         super(true);
     }
@@ -45,19 +43,17 @@ final class StandardEngineValve extends ValveBase {
     // --------------------------------------------------------- Public Methods
 
     /**
-     * Select the appropriate child Host to process this request,
-     * based on the requested server name.  If no matching Host can
-     * be found, return an appropriate HTTP error.
+     * Select the appropriate child Host to process this request, based on the requested server name. If no matching
+     * Host can be found, return an appropriate HTTP error.
      *
-     * @param request Request to be processed
+     * @param request  Request to be processed
      * @param response Response to be produced
      *
-     * @exception IOException if an input/output error occurred
+     * @exception IOException      if an input/output error occurred
      * @exception ServletException if a servlet error occurred
      */
     @Override
-    public final void invoke(Request request, Response response)
-        throws IOException, ServletException {
+    public final void invoke(Request request, Response response) throws IOException, ServletException {
 
         // Select the Host to be used for this Request
         Host host = request.getHost();

==================================================
StandardHostValve.java
index 2f5a758617..f2297fa2e0 100644
--- a/java/org/apache/catalina/core/StandardHost.java
+++ b/java/org/apache/catalina/core/StandardHost.java
@@ -47,9 +47,8 @@ import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.ExceptionUtils;
 
 /**
- * Standard implementation of the <b>Host</b> interface.  Each
- * child container must be a Context implementation to process the
- * requests directed to a particular web application.
+ * Standard implementation of the <b>Host</b> interface. Each child container must be a Context implementation to
+ * process the requests directed to a particular web application.
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
@@ -114,19 +113,15 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * The Java class name of the default context configuration class
-     * for deployed web applications.
+     * The Java class name of the default context configuration class for deployed web applications.
      */
-    private String configClass =
-        "org.apache.catalina.startup.ContextConfig";
+    private String configClass = "org.apache.catalina.startup.ContextConfig";
 
 
     /**
-     * The Java class name of the default Context implementation class for
-     * deployed web applications.
+     * The Java class name of the default Context implementation class for deployed web applications.
      */
-    private String contextClass =
-        "org.apache.catalina.core.StandardContext";
+    private String contextClass = "org.apache.catalina.core.StandardContext";
 
 
     /**
@@ -142,19 +137,16 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * Should XML files be copied to
-     * $CATALINA_BASE/conf/&lt;engine&gt;/&lt;host&gt; by default when
-     * a web application is deployed?
+     * Should XML files be copied to $CATALINA_BASE/conf/&lt;engine&gt;/&lt;host&gt; by default when a web application
+     * is deployed?
      */
     private boolean copyXML = false;
 
 
     /**
-     * The Java class name of the default error reporter implementation class
-     * for deployed web applications.
+     * The Java class name of the default error reporter implementation class for deployed web applications.
      */
-    private String errorReportValveClass =
-        "org.apache.catalina.valves.ErrorReportValve";
+    private String errorReportValveClass = "org.apache.catalina.valves.ErrorReportValve";
 
 
     /**
@@ -176,17 +168,14 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * Track the class loaders for the child web applications so memory leaks
-     * can be detected.
+     * Track the class loaders for the child web applications so memory leaks can be detected.
      */
-    private final Map<ClassLoader, String> childClassLoaders =
-            new WeakHashMap<>();
+    private final Map<ClassLoader, String> childClassLoaders = new WeakHashMap<>();
 
 
     /**
-     * Any file or directory in {@link #appBase} that this pattern matches will
-     * be ignored by the automatic deployment process (both
-     * {@link #deployOnStartup} and {@link #autoDeploy}).
+     * Any file or directory in {@link #appBase} that this pattern matches will be ignored by the automatic deployment
+     * process (both {@link #deployOnStartup} and {@link #autoDeploy}).
      */
     private Pattern deployIgnore = null;
 
@@ -332,7 +321,7 @@ public class StandardHost extends ContainerBase implements Host {
             return hostConfigBase;
         }
         String path = null;
-        if (getXmlBase()!=null) {
+        if (getXmlBase() != null) {
             path = getXmlBase();
         } else {
             StringBuilder xmlDir = new StringBuilder("conf");
@@ -359,8 +348,8 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * @return <code>true</code> if the Host will attempt to create directories for appBase and xmlBase
-     * unless they already exist.
+     * @return <code>true</code> if the Host will attempt to create directories for appBase and xmlBase unless they
+     *             already exist.
      */
     @Override
     public boolean getCreateDirs() {
@@ -369,6 +358,7 @@ public class StandardHost extends ContainerBase implements Host {
 
     /**
      * Set to <code>true</code> if the Host should attempt to create directories for xmlBase and appBase upon startup
+     *
      * @param createDirs the new flag value
      */
     @Override
@@ -377,8 +367,8 @@ public class StandardHost extends ContainerBase implements Host {
     }
 
     /**
-     * @return the value of the auto deploy flag.  If true, it indicates that
-     * this host's child webapps will be dynamically deployed.
+     * @return the value of the auto deploy flag. If true, it indicates that this host's child webapps will be
+     *             dynamically deployed.
      */
     @Override
     public boolean getAutoDeploy() {
@@ -396,15 +386,13 @@ public class StandardHost extends ContainerBase implements Host {
 
         boolean oldAutoDeploy = this.autoDeploy;
         this.autoDeploy = autoDeploy;
-        support.firePropertyChange("autoDeploy", oldAutoDeploy,
-                                   this.autoDeploy);
+        support.firePropertyChange("autoDeploy", oldAutoDeploy, this.autoDeploy);
 
     }
 
 
     /**
-     * @return the Java class name of the context configuration class
-     * for new web applications.
+     * @return the Java class name of the context configuration class for new web applications.
      */
     @Override
     public String getConfigClass() {
@@ -413,8 +401,7 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * Set the Java class name of the context configuration class
-     * for new web applications.
+     * Set the Java class name of the context configuration class for new web applications.
      *
      * @param configClass The new context configuration class
      */
@@ -423,15 +410,13 @@ public class StandardHost extends ContainerBase implements Host {
 
         String oldConfigClass = this.configClass;
         this.configClass = configClass;
-        support.firePropertyChange("configClass",
-                                   oldConfigClass, this.configClass);
+        support.firePropertyChange("configClass", oldConfigClass, this.configClass);
 
     }
 
 
     /**
-     * @return the Java class name of the Context implementation class
-     * for new web applications.
+     * @return the Java class name of the Context implementation class for new web applications.
      */
     public String getContextClass() {
         return this.contextClass;
@@ -439,8 +424,7 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * Set the Java class name of the Context implementation class
-     * for new web applications.
+     * Set the Java class name of the Context implementation class for new web applications.
      *
      * @param contextClass The new context implementation class
      */
@@ -448,16 +432,14 @@ public class StandardHost extends ContainerBase implements Host {
 
         String oldContextClass = this.contextClass;
         this.contextClass = contextClass;
-        support.firePropertyChange("contextClass",
-                                   oldContextClass, this.contextClass);
+        support.firePropertyChange("contextClass", oldContextClass, this.contextClass);
 
     }
 
 
     /**
-     * @return the value of the deploy on startup flag.  If <code>true</code>, it indicates
-     * that this host's child webapps should be discovered and automatically
-     * deployed at startup time.
+     * @return the value of the deploy on startup flag. If <code>true</code>, it indicates that this host's child
+     *             webapps should be discovered and automatically deployed at startup time.
      */
     @Override
     public boolean getDeployOnStartup() {
@@ -475,8 +457,7 @@ public class StandardHost extends ContainerBase implements Host {
 
         boolean oldDeployOnStartup = this.deployOnStartup;
         this.deployOnStartup = deployOnStartup;
-        support.firePropertyChange("deployOnStartup", oldDeployOnStartup,
-                                   this.deployOnStartup);
+        support.firePropertyChange("deployOnStartup", oldDeployOnStartup, this.deployOnStartup);
 
     }
 
@@ -518,8 +499,7 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * @return the Java class name of the error report valve class
-     * for new web applications.
+     * @return the Java class name of the error report valve class for new web applications.
      */
     public String getErrorReportValveClass() {
         return this.errorReportValveClass;
@@ -527,8 +507,7 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * Set the Java class name of the error report valve class
-     * for new web applications.
+     * Set the Java class name of the error report valve class for new web applications.
      *
      * @param errorReportValveClass The new error report valve class
      */
@@ -536,16 +515,13 @@ public class StandardHost extends ContainerBase implements Host {
 
         String oldErrorReportValveClassClass = this.errorReportValveClass;
         this.errorReportValveClass = errorReportValveClass;
-        support.firePropertyChange("errorReportValveClass",
-                                   oldErrorReportValveClassClass,
-                                   this.errorReportValveClass);
+        support.firePropertyChange("errorReportValveClass", oldErrorReportValveClassClass, this.errorReportValveClass);
 
     }
 
 
     /**
-     * @return the canonical, fully qualified, name of the virtual host
-     * this Container represents.
+     * @return the canonical, fully qualified, name of the virtual host this Container represents.
      */
     @Override
     public String getName() {
@@ -554,8 +530,7 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * Set the canonical, fully qualified, name of the virtual host
-     * this Container represents.
+     * Set the canonical, fully qualified, name of the virtual host this Container represents.
      *
      * @param name Virtual host name
      *
@@ -565,11 +540,10 @@ public class StandardHost extends ContainerBase implements Host {
     public void setName(String name) {
 
         if (name == null) {
-            throw new IllegalArgumentException
-                (sm.getString("standardHost.nullName"));
+            throw new IllegalArgumentException(sm.getString("standardHost.nullName"));
         }
 
-        name = name.toLowerCase(Locale.ENGLISH);      // Internally all names are lower case
+        name = name.toLowerCase(Locale.ENGLISH); // Internally all names are lower case
 
         String oldName = this.name;
         this.name = name;
@@ -615,9 +589,8 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * @return the regular expression that defines the files and directories in
-     * the host's {@link #getAppBase} that will be ignored by the automatic
-     * deployment process.
+     * @return the regular expression that defines the files and directories in the host's {@link #getAppBase} that will
+     *             be ignored by the automatic deployment process.
      */
     @Override
     public String getDeployIgnore() {
@@ -629,9 +602,8 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * @return the compiled regular expression that defines the files and
-     * directories in the host's {@link #getAppBase} that will be ignored by the
-     * automatic deployment process.
+     * @return the compiled regular expression that defines the files and directories in the host's {@link #getAppBase}
+     *             that will be ignored by the automatic deployment process.
      */
     @Override
     public Pattern getDeployIgnorePattern() {
@@ -640,9 +612,8 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * Set the regular expression that defines the files and directories in
-     * the host's {@link #getAppBase} that will be ignored by the automatic
-     * deployment process.
+     * Set the regular expression that defines the files and directories in the host's {@link #getAppBase} that will be
+     * ignored by the automatic deployment process.
      *
      * @param deployIgnore the regexp
      */
@@ -659,9 +630,7 @@ public class StandardHost extends ContainerBase implements Host {
         } else {
             this.deployIgnore = Pattern.compile(deployIgnore);
         }
-        support.firePropertyChange("deployIgnore",
-                                   oldDeployIgnore,
-                                   deployIgnore);
+        support.firePropertyChange("deployIgnore", oldDeployIgnore, deployIgnore);
     }
 
 
@@ -675,15 +644,14 @@ public class StandardHost extends ContainerBase implements Host {
 
     /**
      * Change the behavior of Servlet startup errors on web application starts.
-     * @param failCtxIfServletStartFails <code>false</code> to ignore errors on Servlets which
-     *    are stated when the web application starts
+     *
+     * @param failCtxIfServletStartFails <code>false</code> to ignore errors on Servlets which are stated when the web
+     *                                       application starts
      */
-    public void setFailCtxIfServletStartFails(
-            boolean failCtxIfServletStartFails) {
+    public void setFailCtxIfServletStartFails(boolean failCtxIfServletStartFails) {
         boolean oldFailCtxIfServletStartFails = this.failCtxIfServletStartFails;
         this.failCtxIfServletStartFails = failCtxIfServletStartFails;
-        support.firePropertyChange("failCtxIfServletStartFails",
-                oldFailCtxIfServletStartFails,
+        support.firePropertyChange("failCtxIfServletStartFails", oldFailCtxIfServletStartFails,
                 failCtxIfServletStartFails);
     }
 
@@ -720,8 +688,7 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * Add a child Container, only if the proposed child is an implementation
-     * of Context.
+     * Add a child Container, only if the proposed child is an implementation of Context.
      *
      * @param child Child container to be added
      */
@@ -729,8 +696,7 @@ public class StandardHost extends ContainerBase implements Host {
     public void addChild(Container child) {
 
         if (!(child instanceof Context)) {
-            throw new IllegalArgumentException
-                (sm.getString("standardHost.notContext"));
+            throw new IllegalArgumentException(sm.getString("standardHost.notContext"));
         }
 
         child.addLifecycleListener(new MemoryLeakTrackingListener());
@@ -749,8 +715,8 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * Used to ensure the regardless of {@link Context} implementation, a record
-     * is kept of the class loader used every time a context starts.
+     * Used to ensure the regardless of {@link Context} implementation, a record is kept of the class loader used every
+     * time a context starts.
      */
     private class MemoryLeakTrackingListener implements LifecycleListener {
         @Override
@@ -767,10 +733,9 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * Attempt to identify the contexts that have a class loader memory leak.
-     * This is usually triggered on context reload. Note: This method attempts
-     * to force a full garbage collection. This should be used with extreme
-     * caution on a production system.
+     * Attempt to identify the contexts that have a class loader memory leak. This is usually triggered on context
+     * reload. Note: This method attempts to force a full garbage collection. This should be used with extreme caution
+     * on a production system.
      *
      * @return a list of possibly leaking contexts
      */
@@ -780,8 +745,7 @@ public class StandardHost extends ContainerBase implements Host {
 
         List<String> result = new ArrayList<>();
 
-        for (Map.Entry<ClassLoader, String> entry :
-                childClassLoaders.entrySet()) {
+        for (Map.Entry<ClassLoader, String> entry : childClassLoaders.entrySet()) {
             ClassLoader cl = entry.getKey();
             if (cl instanceof WebappClassLoaderBase) {
                 if (!((WebappClassLoaderBase) cl).getState().isAvailable()) {
@@ -794,8 +758,7 @@ public class StandardHost extends ContainerBase implements Host {
     }
 
     /**
-     * @return the set of alias names for this Host.  If none are defined,
-     * a zero length array is returned.
+     * @return the set of alias names for this Host. If none are defined, a zero length array is returned.
      */
     @Override
     public String[] findAliases() {
@@ -848,11 +811,11 @@ public class StandardHost extends ContainerBase implements Host {
 
 
     /**
-     * Start this component and implement the requirements
-     * of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
+     * Start this component and implement the requirements of
+     * {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
+     * @exception LifecycleException if this component detects a fatal error that prevents this component from being
+     *                                   used
      */
     @Override
     protected synchronized void startInternal() throws LifecycleException {
@@ -869,32 +832,29 @@ public class StandardHost extends ContainerBase implements Host {
                         break;
                     }
                 }
-                if(!found) {
-                    Valve valve = ErrorReportValve.class.getName().equals(errorValve) ?
-                        new ErrorReportValve() :
-                        (Valve) Class.forName(errorValve).getConstructor().newInstance();
+                if (!found) {
+                    Valve valve = ErrorReportValve.class.getName().equals(errorValve) ? new ErrorReportValve()
+                            : (Valve) Class.forName(errorValve).getConstructor().newInstance();
                     getPipeline().addValve(valve);
                 }
             } catch (Throwable t) {
                 ExceptionUtils.handleThrowable(t);
-                log.error(sm.getString(
-                        "standardHost.invalidErrorReportValveClass",
-                        errorValve), t);
+                log.error(sm.getString("standardHost.invalidErrorReportValveClass", errorValve), t);
             }
         }
         super.startInternal();
     }
 
 
-    // -------------------- JMX  --------------------
+    // -------------------- JMX --------------------
     /**
      * @return the MBean Names of the Valves associated with this Host
      *
      * @exception Exception if an MBean cannot be created or registered
      */
     public String[] getValveNames() throws Exception {
-        Valve [] valves = this.getPipeline().getValves();
-        String [] mbeanNames = new String[valves.length];
+        Valve[] valves = this.getPipeline().getValves();
+        String[] mbeanNames = new String[valves.length];
         for (int i = 0; i < valves.length; i++) {
             if (valves[i] instanceof JmxEnabled) {
                 ObjectName oname = ((JmxEnabled) valves[i]).getObjectName();

==================================================
StandardPipeline.java
index 76250cd173..474d0be5e3 100644
--- a/java/org/apache/catalina/core/StandardHostValve.java
+++ b/java/org/apache/catalina/core/StandardHostValve.java
@@ -40,11 +40,9 @@ import org.apache.tomcat.util.descriptor.web.ErrorPage;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * Valve that implements the default basic behavior for the
- * <code>StandardHost</code> container implementation.
+ * Valve that implements the default basic behavior for the <code>StandardHost</code> container implementation.
  * <p>
- * <b>USAGE CONSTRAINT</b>:  This implementation is likely to be useful only
- * when processing HTTP requests.
+ * <b>USAGE CONSTRAINT</b>: This implementation is likely to be useful only when processing HTTP requests.
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
@@ -59,7 +57,7 @@ final class StandardHostValve extends ValveBase {
     // minor one) in a profiler.
     private static final ClassLoader MY_CLASSLOADER = StandardHostValve.class.getClassLoader();
 
-    //------------------------------------------------------ Constructor
+    // ------------------------------------------------------ Constructor
 
     public StandardHostValve() {
         super(true);
@@ -69,19 +67,17 @@ final class StandardHostValve extends ValveBase {
     // --------------------------------------------------------- Public Methods
 
     /**
-     * Select the appropriate child Context to process this request,
-     * based on the specified request URI.  If no matching Context can
-     * be found, return an appropriate HTTP error.
+     * Select the appropriate child Context to process this request, based on the specified request URI. If no matching
+     * Context can be found, return an appropriate HTTP error.
      *
-     * @param request Request to be processed
+     * @param request  Request to be processed
      * @param response Response to be produced
      *
-     * @exception IOException if an input/output error occurred
+     * @exception IOException      if an input/output error occurred
      * @exception ServletException if a servlet error occurred
      */
     @Override
-    public final void invoke(Request request, Response response)
-        throws IOException, ServletException {
+    public final void invoke(Request request, Response response) throws IOException, ServletException {
 
         // Select the Context to be used for this Request
         Context context = request.getContext();
@@ -175,12 +171,11 @@ final class StandardHostValve extends ValveBase {
     // -------------------------------------------------------- Private Methods
 
     /**
-     * Handle the HTTP status code (and corresponding message) generated
-     * while processing the specified Request to produce the specified
-     * Response.  Any exceptions that occur during generation of the error
-     * report are logged and swallowed.
+     * Handle the HTTP status code (and corresponding message) generated while processing the specified Request to
+     * produce the specified Response. Any exceptions that occur during generation of the error report are logged and
+     * swallowed.
      *
-     * @param request The request being processed
+     * @param request  The request being processed
      * @param response The response being generated
      */
     private void status(Request request, Response response) {
@@ -193,10 +188,9 @@ final class StandardHostValve extends ValveBase {
             return;
         }
 
-        /* Only look for error pages when isError() is set.
-         * isError() is set when response.sendError() is invoked. This
-         * allows custom error pages without relying on default from
-         * web.xml.
+        /*
+         * Only look for error pages when isError() is set. isError() is set when response.sendError() is invoked. This
+         * allows custom error pages without relying on default from web.xml.
          */
         if (!response.isError()) {
             return;
@@ -241,15 +235,12 @@ final class StandardHostValve extends ValveBase {
 
 
     /**
-     * Handle the specified Throwable encountered while processing
-     * the specified Request to produce the specified Response.  Any
-     * exceptions that occur during generation of the exception report are
-     * logged and swallowed.
+     * Handle the specified Throwable encountered while processing the specified Request to produce the specified
+     * Response. Any exceptions that occur during generation of the exception report are logged and swallowed.
      *
-     * @param request The request being processed
-     * @param response The response being generated
-     * @param throwable The exception that occurred (which possibly wraps
-     *  a root cause exception
+     * @param request   The request being processed
+     * @param response  The response being generated
+     * @param throwable The exception that occurred (which possibly wraps a root cause exception
      */
     protected void throwable(Request request, Response response, Throwable throwable) {
         Context context = request.getContext();
@@ -267,7 +258,7 @@ final class StandardHostValve extends ValveBase {
         }
 
         // If this is an aborted request from a client just log it and return
-        if (realError instanceof ClientAbortException ) {
+        if (realError instanceof ClientAbortException) {
             if (log.isDebugEnabled()) {
                 log.debug(sm.getString("standardHost.clientAbort", realError.getCause().getMessage()));
             }
@@ -318,19 +309,16 @@ final class StandardHostValve extends ValveBase {
 
 
     /**
-     * Handle an HTTP status code or Java exception by forwarding control
-     * to the location included in the specified errorPage object.  It is
-     * assumed that the caller has already recorded any request attributes
-     * that are to be forwarded to this page.  Return <code>true</code> if
-     * we successfully utilized the specified error page location, or
-     * <code>false</code> if the default error report should be rendered.
+     * Handle an HTTP status code or Java exception by forwarding control to the location included in the specified
+     * errorPage object. It is assumed that the caller has already recorded any request attributes that are to be
+     * forwarded to this page. Return <code>true</code> if we successfully utilized the specified error page location,
+     * or <code>false</code> if the default error report should be rendered.
      *
-     * @param request The request being processed
-     * @param response The response being generated
+     * @param request   The request being processed
+     * @param response  The response being generated
      * @param errorPage The errorPage directive we are obeying
      */
-    private boolean custom(Request request, Response response,
-                             ErrorPage errorPage) {
+    private boolean custom(Request request, Response response, ErrorPage errorPage) {
 
         if (container.getLogger().isDebugEnabled()) {
             container.getLogger().debug("Processing " + errorPage);
@@ -338,14 +326,12 @@ final class StandardHostValve extends ValveBase {
 
         try {
             // Forward control to the specified location
-            ServletContext servletContext =
-                request.getContext().getServletContext();
-            RequestDispatcher rd =
-                servletContext.getRequestDispatcher(errorPage.getLocation());
+            ServletContext servletContext = request.getContext().getServletContext();
+            RequestDispatcher rd = servletContext.getRequestDispatcher(errorPage.getLocation());
 
             if (rd == null) {
-                container.getLogger().error(
-                    sm.getString("standardHostValue.customStatusFailed", errorPage.getLocation()));
+                container.getLogger()
+                        .error(sm.getString("standardHostValue.customStatusFailed", errorPage.getLocation()));
                 return false;
             }
 

==================================================
StandardServer.java
index 6673fed829..b2c19fcf05 100644
--- a/java/org/apache/catalina/core/StandardPipeline.java
+++ b/java/org/apache/catalina/core/StandardPipeline.java
@@ -38,14 +38,11 @@ import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * Standard implementation of a processing <b>Pipeline</b> that will invoke
- * a series of Valves that have been configured to be called in order.  This
- * implementation can be used for any type of Container.
- *
- * <b>IMPLEMENTATION WARNING</b> - This implementation assumes that no
- * calls to <code>addValve()</code> or <code>removeValve</code> are allowed
- * while a request is currently being processed.  Otherwise, the mechanism
- * by which per-thread state is maintained will need to be modified.
+ * Standard implementation of a processing <b>Pipeline</b> that will invoke a series of Valves that have been configured
+ * to be called in order. This implementation can be used for any type of Container. <b>IMPLEMENTATION WARNING</b> -
+ * This implementation assumes that no calls to <code>addValve()</code> or <code>removeValve</code> are allowed while a
+ * request is currently being processed. Otherwise, the mechanism by which per-thread state is maintained will need to
+ * be modified.
  *
  * @author Craig R. McClanahan
  */
@@ -68,8 +65,7 @@ public class StandardPipeline extends LifecycleBase implements Pipeline {
 
 
     /**
-     * Construct a new StandardPipeline instance that is associated with the
-     * specified Container.
+     * Construct a new StandardPipeline instance that is associated with the specified Container.
      *
      * @param container The container we should be associated with
      */
@@ -106,9 +102,9 @@ public class StandardPipeline extends LifecycleBase implements Pipeline {
 
     @Override
     public boolean isAsyncSupported() {
-        Valve valve = (first!=null)?first:basic;
+        Valve valve = (first != null) ? first : basic;
         boolean supported = true;
-        while (supported && valve!=null) {
+        while (supported && valve != null) {
             supported = supported & valve.isAsyncSupported();
             valve = valve.getNext();
         }
@@ -118,7 +114,7 @@ public class StandardPipeline extends LifecycleBase implements Pipeline {
 
     @Override
     public void findNonAsyncValves(Set<String> result) {
-        Valve valve = (first!=null) ? first : basic;
+        Valve valve = (first != null) ? first : basic;
         while (valve != null) {
             if (!valve.isAsyncSupported()) {
                 result.add(valve.getClass().getName());
@@ -157,11 +153,10 @@ public class StandardPipeline extends LifecycleBase implements Pipeline {
 
 
     /**
-     * Start {@link Valve}s) in this pipeline and implement the requirements
-     * of {@link LifecycleBase#startInternal()}.
+     * Start {@link Valve}s) in this pipeline and implement the requirements of {@link LifecycleBase#startInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
+     * @exception LifecycleException if this component detects a fatal error that prevents this component from being
+     *                                   used
      */
     @Override
     protected synchronized void startInternal() throws LifecycleException {
@@ -183,11 +178,10 @@ public class StandardPipeline extends LifecycleBase implements Pipeline {
 
 
     /**
-     * Stop {@link Valve}s) in this pipeline and implement the requirements
-     * of {@link LifecycleBase#stopInternal()}.
+     * Stop {@link Valve}s) in this pipeline and implement the requirements of {@link LifecycleBase#stopInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
+     * @exception LifecycleException if this component detects a fatal error that prevents this component from being
+     *                                   used
      */
     @Override
     protected synchronized void stopInternal() throws LifecycleException {
@@ -230,8 +224,8 @@ public class StandardPipeline extends LifecycleBase implements Pipeline {
 
 
     /**
-     * <p>Return the Valve instance that has been distinguished as the basic
-     * Valve for this Pipeline (if any).
+     * <p>
+     * Return the Valve instance that has been distinguished as the basic Valve for this Pipeline (if any).
      */
     @Override
     public Valve getBasic() {
@@ -240,14 +234,13 @@ public class StandardPipeline extends LifecycleBase implements Pipeline {
 
 
     /**
-     * <p>Set the Valve instance that has been distinguished as the basic
-     * Valve for this Pipeline (if any).  Prior to setting the basic Valve,
-     * the Valve's <code>setContainer()</code> will be called, if it
-     * implements <code>Contained</code>, with the owning Container as an
-     * argument.  The method may throw an <code>IllegalArgumentException</code>
-     * if this Valve chooses not to be associated with this Container, or
-     * <code>IllegalStateException</code> if it is already associated with
-     * a different Container.</p>
+     * <p>
+     * Set the Valve instance that has been distinguished as the basic Valve for this Pipeline (if any). Prior to
+     * setting the basic Valve, the Valve's <code>setContainer()</code> will be called, if it implements
+     * <code>Contained</code>, with the owning Container as an argument. The method may throw an
+     * <code>IllegalArgumentException</code> if this Valve chooses not to be associated with this Container, or
+     * <code>IllegalStateException</code> if it is already associated with a different Container.
+     * </p>
      *
      * @param valve Valve to be distinguished as the basic Valve
      */
@@ -310,23 +303,19 @@ public class StandardPipeline extends LifecycleBase implements Pipeline {
 
 
     /**
-     * <p>Add a new Valve to the end of the pipeline associated with this
-     * Container.  Prior to adding the Valve, the Valve's
-     * <code>setContainer()</code> method will be called, if it implements
-     * <code>Contained</code>, with the owning Container as an argument.
-     * The method may throw an
-     * <code>IllegalArgumentException</code> if this Valve chooses not to
-     * be associated with this Container, or <code>IllegalStateException</code>
-     * if it is already associated with a different Container.</p>
+     * <p>
+     * Add a new Valve to the end of the pipeline associated with this Container. Prior to adding the Valve, the Valve's
+     * <code>setContainer()</code> method will be called, if it implements <code>Contained</code>, with the owning
+     * Container as an argument. The method may throw an <code>IllegalArgumentException</code> if this Valve chooses not
+     * to be associated with this Container, or <code>IllegalStateException</code> if it is already associated with a
+     * different Container.
+     * </p>
      *
      * @param valve Valve to be added
      *
-     * @exception IllegalArgumentException if this Container refused to
-     *  accept the specified Valve
-     * @exception IllegalArgumentException if the specified Valve refuses to be
-     *  associated with this Container
-     * @exception IllegalStateException if the specified Valve is already
-     *  associated with a different Container
+     * @exception IllegalArgumentException if this Container refused to accept the specified Valve
+     * @exception IllegalArgumentException if the specified Valve refuses to be associated with this Container
+     * @exception IllegalStateException    if the specified Valve is already associated with a different Container
      */
     @Override
     public void addValve(Valve valve) {
@@ -368,9 +357,8 @@ public class StandardPipeline extends LifecycleBase implements Pipeline {
 
 
     /**
-     * Return the set of Valves in the pipeline associated with this
-     * Container, including the basic Valve (if any).  If there are no
-     * such Valves, a zero-length array is returned.
+     * Return the set of Valves in the pipeline associated with this Container, including the basic Valve (if any). If
+     * there are no such Valves, a zero-length array is returned.
      */
     @Override
     public Valve[] getValves() {
@@ -408,10 +396,9 @@ public class StandardPipeline extends LifecycleBase implements Pipeline {
     }
 
     /**
-     * Remove the specified Valve from the pipeline associated with this
-     * Container, if it is found; otherwise, do nothing.  If the Valve is
-     * found and removed, the Valve's <code>setContainer(null)</code> method
-     * will be called if it implements <code>Contained</code>.
+     * Remove the specified Valve from the pipeline associated with this Container, if it is found; otherwise, do
+     * nothing. If the Valve is found and removed, the Valve's <code>setContainer(null)</code> method will be called if
+     * it implements <code>Contained</code>.
      *
      * @param valve Valve to be removed
      */
@@ -419,7 +406,7 @@ public class StandardPipeline extends LifecycleBase implements Pipeline {
     public void removeValve(Valve valve) {
 
         Valve current;
-        if(first == valve) {
+        if (first == valve) {
             first = first.getNext();
             current = null;
         } else {

==================================================
StandardService.java
index e7d12b9d05..7dfa3276b6 100644
--- a/java/org/apache/catalina/core/StandardServer.java
+++ b/java/org/apache/catalina/core/StandardServer.java
@@ -58,8 +58,8 @@ import org.apache.tomcat.util.threads.TaskThreadFactory;
 
 
 /**
- * Standard implementation of the <b>Server</b> interface, available for use
- * (but not required) when deploying and starting Catalina.
+ * Standard implementation of the <b>Server</b> interface, available for use (but not required) when deploying and
+ * starting Catalina.
  *
  * @author Craig R. McClanahan
  */
@@ -126,8 +126,8 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
 
 
     /**
-     * A random number generator that is <strong>only</strong> used if
-     * the shutdown command string is longer than 1024 characters.
+     * A random number generator that is <strong>only</strong> used if the shutdown command string is longer than 1024
+     * characters.
      */
     private Random random = null;
 
@@ -249,22 +249,19 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
      * @param globalNamingResources The new global naming resources
      */
     @Override
-    public void setGlobalNamingResources
-        (NamingResourcesImpl globalNamingResources) {
+    public void setGlobalNamingResources(NamingResourcesImpl globalNamingResources) {
 
-        NamingResourcesImpl oldGlobalNamingResources =
-            this.globalNamingResources;
+        NamingResourcesImpl oldGlobalNamingResources = this.globalNamingResources;
         this.globalNamingResources = globalNamingResources;
         this.globalNamingResources.setContainer(this);
-        support.firePropertyChange("globalNamingResources",
-                                   oldGlobalNamingResources,
-                                   this.globalNamingResources);
+        support.firePropertyChange("globalNamingResources", oldGlobalNamingResources, this.globalNamingResources);
 
     }
 
 
     /**
      * Report the current Tomcat Server Release number
+     *
      * @return Tomcat release identifier
      */
     public String getServerInfo() {
@@ -274,6 +271,7 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
 
     /**
      * Return the current server built timestamp
+     *
      * @return server built timestamp.
      */
     public String getServerBuilt() {
@@ -283,6 +281,7 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
 
     /**
      * Return the current server's version number.
+     *
      * @return server's version number.
      */
     public String getServerNumber() {
@@ -437,14 +436,14 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
             if (utilityExecutor != null) {
                 utilityExecutor.setCorePoolSize(threads);
             } else {
-                ScheduledThreadPoolExecutor scheduledThreadPoolExecutor =
-                        new ScheduledThreadPoolExecutor(threads,
-                                new TaskThreadFactory("Catalina-utility-", utilityThreadsAsDaemon, Thread.MIN_PRIORITY));
+                ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(threads,
+                        new TaskThreadFactory("Catalina-utility-", utilityThreadsAsDaemon, Thread.MIN_PRIORITY));
                 scheduledThreadPoolExecutor.setKeepAliveTime(10, TimeUnit.SECONDS);
                 scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true);
                 scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
                 utilityExecutor = scheduledThreadPoolExecutor;
-                utilityExecutorWrapper = new org.apache.tomcat.util.threads.ScheduledThreadPoolExecutor(utilityExecutor);
+                utilityExecutorWrapper = new org.apache.tomcat.util.threads.ScheduledThreadPoolExecutor(
+                        utilityExecutor);
             }
         }
     }
@@ -452,6 +451,7 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
 
     /**
      * Get if the utility threads are daemon threads.
+     *
      * @return the threads daemon flag
      */
     public boolean getUtilityThreadsAsDaemon() {
@@ -461,6 +461,7 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
 
     /**
      * Set the utility threads daemon flag. The default value is true.
+     *
      * @param utilityThreadsAsDaemon the new thread daemon flag
      */
     public void setUtilityThreadsAsDaemon(boolean utilityThreadsAsDaemon) {
@@ -478,8 +479,8 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
 
     /**
      * Set the new period between two lifecycle events in seconds.
-     * @param periodicEventDelay The period in seconds, negative or zero will
-     *  disable events
+     *
+     * @param periodicEventDelay The period in seconds, negative or zero will disable events
      */
     public final void setPeriodicEventDelay(int periodicEventDelay) {
         this.periodicEventDelay = periodicEventDelay;
@@ -520,7 +521,7 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
     }
 
     public void stopAwait() {
-        stopAwait=true;
+        stopAwait = true;
         Thread t = awaitThread;
         if (t != null) {
             ServerSocket s = awaitSocket;
@@ -542,9 +543,8 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
     }
 
     /**
-     * Wait until a proper shutdown command is received, then return.
-     * This keeps the main thread alive - the thread pool listening for http
-     * connections is daemon threads.
+     * Wait until a proper shutdown command is received, then return. This keeps the main thread alive - the thread pool
+     * listening for http connections is daemon threads.
      */
     @Override
     public void await() {
@@ -556,10 +556,10 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
         if (getPortWithOffset() == -1) {
             try {
                 awaitThread = Thread.currentThread();
-                while(!stopAwait) {
+                while (!stopAwait) {
                     try {
-                        Thread.sleep( 10000 );
-                    } catch( InterruptedException ex ) {
+                        Thread.sleep(10000);
+                    } catch (InterruptedException ex) {
                         // continue and check the flag
                     }
                 }
@@ -571,12 +571,10 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
 
         // Set up a server socket to wait on
         try {
-            awaitSocket = new ServerSocket(getPortWithOffset(), 1,
-                    InetAddress.getByName(address));
+            awaitSocket = new ServerSocket(getPortWithOffset(), 1, InetAddress.getByName(address));
         } catch (IOException e) {
-            log.error(sm.getString("standardServer.awaitSocket.fail", address,
-                    String.valueOf(getPortWithOffset()), String.valueOf(getPort()),
-                    String.valueOf(getPortOffset())), e);
+            log.error(sm.getString("standardServer.awaitSocket.fail", address, String.valueOf(getPortWithOffset()),
+                    String.valueOf(getPort()), String.valueOf(getPortOffset())), e);
             return;
         }
 
@@ -598,7 +596,7 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
                     long acceptStartTime = System.currentTimeMillis();
                     try {
                         socket = serverSocket.accept();
-                        socket.setSoTimeout(10 * 1000);  // Ten seconds
+                        socket.setSoTimeout(10 * 1000); // Ten seconds
                         stream = socket.getInputStream();
                     } catch (SocketTimeoutException ste) {
                         // This should never happen but bug 56684 suggests that
@@ -676,8 +674,7 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
 
 
     /**
-     * @return the specified Service (if it exists); otherwise return
-     * <code>null</code>.
+     * @return the specified Service (if it exists); otherwise return <code>null</code>.
      *
      * @param name Name of the Service to be returned
      */
@@ -709,17 +706,16 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
      * @return the JMX service names.
      */
     public ObjectName[] getServiceNames() {
-        ObjectName onames[]=new ObjectName[ services.length ];
-        for( int i=0; i<services.length; i++ ) {
-            onames[i]=((StandardService)services[i]).getObjectName();
+        ObjectName onames[] = new ObjectName[services.length];
+        for (int i = 0; i < services.length; i++) {
+            onames[i] = ((StandardService) services[i]).getObjectName();
         }
         return onames;
     }
 
 
     /**
-     * Remove the specified Service from the set associated from this
-     * Server.
+     * Remove the specified Service from the set associated from this Server.
      *
      * @param service The Service to be removed
      */
@@ -826,16 +822,12 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
 
 
     /**
-     * Write the configuration information for this entire <code>Server</code>
-     * out to the server.xml configuration file.
+     * Write the configuration information for this entire <code>Server</code> out to the server.xml configuration file.
      *
-     * @exception InstanceNotFoundException
-     *            if the managed resource object cannot be found
-     * @exception MBeanException
-     *            if the initializer of the object throws an exception, or
-     *            persistence is not supported
-     * @exception javax.management.RuntimeOperationsException
-     *            if an exception is reported by the persistence mechanism
+     * @exception InstanceNotFoundException                   if the managed resource object cannot be found
+     * @exception MBeanException                              if the initializer of the object throws an exception, or
+     *                                                            persistence is not supported
+     * @exception javax.management.RuntimeOperationsException if an exception is reported by the persistence mechanism
      */
     public synchronized void storeConfig() throws InstanceNotFoundException, MBeanException {
         try {
@@ -855,17 +847,14 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
 
 
     /**
-     * Write the configuration information for <code>Context</code>
-     * out to the specified configuration file.
+     * Write the configuration information for <code>Context</code> out to the specified configuration file.
      *
      * @param context the context which should save its configuration
-     * @exception InstanceNotFoundException
-     *            if the managed resource object cannot be found
-     * @exception MBeanException
-     *            if the initializer of the object throws an exception
-     *            or persistence is not supported
-     * @exception javax.management.RuntimeOperationsException
-     *            if an exception is reported by the persistence mechanism
+     *
+     * @exception InstanceNotFoundException                   if the managed resource object cannot be found
+     * @exception MBeanException                              if the initializer of the object throws an exception or
+     *                                                            persistence is not supported
+     * @exception javax.management.RuntimeOperationsException if an exception is reported by the persistence mechanism
      */
     public synchronized void storeContext(Context context) throws InstanceNotFoundException, MBeanException {
         try {
@@ -873,9 +862,7 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
             ObjectName sname = new ObjectName("Catalina:type=StoreConfig");
             MBeanServer server = Registry.getRegistry(null, null).getMBeanServer();
             if (server.isRegistered(sname)) {
-                server.invoke(sname, "store",
-                    new Object[] {context},
-                    new String [] { "java.lang.String"});
+                server.invoke(sname, "store", new Object[] { context }, new String[] { "java.lang.String" });
             } else {
                 log.error(sm.getString("standardServer.storeConfig.notAvailable", sname));
             }
@@ -893,8 +880,7 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
         boolean useNaming = true;
         // Reading the "catalina.useNaming" environment variable
         String useNamingProperty = System.getProperty("catalina.useNaming");
-        if ((useNamingProperty != null)
-            && (useNamingProperty.equals("false"))) {
+        if ((useNamingProperty != null) && (useNamingProperty.equals("false"))) {
             useNaming = false;
         }
         return useNaming;
@@ -902,11 +888,11 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
 
 
     /**
-     * Start nested components ({@link Service}s) and implement the requirements
-     * of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
+     * Start nested components ({@link Service}s) and implement the requirements of
+     * {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
+     * @exception LifecycleException if this component detects a fatal error that prevents this component from being
+     *                                   used
      */
     @Override
     protected void startInternal() throws LifecycleException {
@@ -924,14 +910,15 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
         }
 
         if (periodicEventDelay > 0) {
-            monitorFuture = getUtilityExecutor().scheduleWithFixedDelay(
-                    () -> startPeriodicLifecycleEvent(), 0, 60, TimeUnit.SECONDS);
+            monitorFuture = getUtilityExecutor().scheduleWithFixedDelay(() -> startPeriodicLifecycleEvent(), 0, 60,
+                    TimeUnit.SECONDS);
         }
     }
 
 
     protected void startPeriodicLifecycleEvent() {
-        if (periodicLifecycleEventFuture == null || (periodicLifecycleEventFuture != null && periodicLifecycleEventFuture.isDone())) {
+        if (periodicLifecycleEventFuture == null ||
+                (periodicLifecycleEventFuture != null && periodicLifecycleEventFuture.isDone())) {
             if (periodicLifecycleEventFuture != null && periodicLifecycleEventFuture.isDone()) {
                 // There was an error executing the scheduled task, get it and log it
                 try {
@@ -941,17 +928,17 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
                 }
             }
             periodicLifecycleEventFuture = getUtilityExecutor().scheduleAtFixedRate(
-                    () -> fireLifecycleEvent(Lifecycle.PERIODIC_EVENT, null), periodicEventDelay, periodicEventDelay, TimeUnit.SECONDS);
+                    () -> fireLifecycleEvent(Lifecycle.PERIODIC_EVENT, null), periodicEventDelay, periodicEventDelay,
+                    TimeUnit.SECONDS);
         }
     }
 
 
     /**
-     * Stop nested components ({@link Service}s) and implement the requirements
-     * of {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
+     * Stop nested components ({@link Service}s) and implement the requirements of
+     * {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that needs to be reported
+     * @exception LifecycleException if this component detects a fatal error that needs to be reported
      */
     @Override
     protected void stopInternal() throws LifecycleException {
@@ -980,8 +967,8 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
     }
 
     /**
-     * Invoke a pre-startup initialization. This is used to allow connectors
-     * to bind to restricted ports under Unix operating environments.
+     * Invoke a pre-startup initialization. This is used to allow connectors to bind to restricted ports under Unix
+     * operating environments.
      */
     @Override
     protected void initInternal() throws LifecycleException {
@@ -1057,8 +1044,7 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
     public void setParentClassLoader(ClassLoader parent) {
         ClassLoader oldParentClassLoader = this.parentClassLoader;
         this.parentClassLoader = parent;
-        support.firePropertyChange("parentClassLoader", oldParentClassLoader,
-                                   this.parentClassLoader);
+        support.firePropertyChange("parentClassLoader", oldParentClassLoader, this.parentClassLoader);
     }
 
 
@@ -1066,8 +1052,7 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
     private ObjectName onameMBeanFactory;
 
     /**
-     * Obtain the MBean domain for this server. The domain is obtained using
-     * the following search order:
+     * Obtain the MBean domain for this server. The domain is obtained using the following search order:
      * <ol>
      * <li>Name of first {@link org.apache.catalina.Engine}.</li>
      * <li>Name of first {@link Service}.</li>

==================================================
StandardThreadExecutor.java
index 15a7d89ac9..c52dca88f4 100644
--- a/java/org/apache/catalina/core/StandardService.java
+++ b/java/org/apache/catalina/core/StandardService.java
@@ -41,9 +41,8 @@ import org.apache.tomcat.util.res.StringManager;
 
 
 /**
- * Standard implementation of the <code>Service</code> interface.  The
- * associated Container is generally an instance of Engine, but this is
- * not required.
+ * Standard implementation of the <code>Service</code> interface. The associated Container is generally an instance of
+ * Engine, but this is not required.
  *
  * @author Craig R. McClanahan
  */
@@ -213,8 +212,7 @@ public class StandardService extends LifecycleMBeanBase implements Service {
     // --------------------------------------------------------- Public Methods
 
     /**
-     * Add a new Connector to the set of defined Connectors, and associate it
-     * with this Service's Container.
+     * Add a new Connector to the set of defined Connectors, and associate it with this Service's Container.
      *
      * @param connector The Connector to be added
      */
@@ -234,8 +232,7 @@ public class StandardService extends LifecycleMBeanBase implements Service {
                 connector.start();
             }
         } catch (LifecycleException e) {
-            throw new IllegalArgumentException(
-                    sm.getString("standardService.connector.startFailed", connector), e);
+            throw new IllegalArgumentException(sm.getString("standardService.connector.startFailed", connector), e);
         }
 
         // Report this property change to interested listeners
@@ -245,7 +242,7 @@ public class StandardService extends LifecycleMBeanBase implements Service {
 
     public ObjectName[] getConnectorNames() {
         ObjectName results[] = new ObjectName[connectors.length];
-        for (int i=0; i<results.length; i++) {
+        for (int i = 0; i < results.length; i++) {
             results[i] = connectors[i].getObjectName();
         }
         return results;
@@ -272,9 +269,8 @@ public class StandardService extends LifecycleMBeanBase implements Service {
 
 
     /**
-     * Remove the specified Connector from the set associated from this
-     * Service.  The removed Connector will also be disassociated from our
-     * Container.
+     * Remove the specified Connector from the set associated from this Service. The removed Connector will also be
+     * disassociated from our Container.
      *
      * @param connector The Connector to be removed
      */
@@ -296,9 +292,7 @@ public class StandardService extends LifecycleMBeanBase implements Service {
                 try {
                     connectors[j].stop();
                 } catch (LifecycleException e) {
-                    log.error(sm.getString(
-                            "standardService.connector.stopFailed",
-                            connectors[j]), e);
+                    log.error(sm.getString("standardService.connector.stopFailed", connectors[j]), e);
                 }
             }
             connector.setService(null);
@@ -341,6 +335,7 @@ public class StandardService extends LifecycleMBeanBase implements Service {
 
     /**
      * Adds a named executor to the service
+     *
      * @param ex Executor
      */
     @Override
@@ -362,6 +357,7 @@ public class StandardService extends LifecycleMBeanBase implements Service {
 
     /**
      * Retrieves all executors
+     *
      * @return Executor[]
      */
     @Override
@@ -374,13 +370,15 @@ public class StandardService extends LifecycleMBeanBase implements Service {
 
     /**
      * Retrieves executor by name, null if not found
+     *
      * @param executorName String
+     *
      * @return Executor
      */
     @Override
     public Executor getExecutor(String executorName) {
         synchronized (executors) {
-            for (Executor executor: executors) {
+            for (Executor executor : executors) {
                 if (executorName.equals(executor.getName())) {
                     return executor;
                 }
@@ -392,12 +390,13 @@ public class StandardService extends LifecycleMBeanBase implements Service {
 
     /**
      * Removes an executor from the service
+     *
      * @param ex Executor
      */
     @Override
     public void removeExecutor(Executor ex) {
         synchronized (executors) {
-            if ( executors.remove(ex) && getState().isAvailable() ) {
+            if (executors.remove(ex) && getState().isAvailable()) {
                 try {
                     ex.stop();
                 } catch (LifecycleException e) {
@@ -409,17 +408,16 @@ public class StandardService extends LifecycleMBeanBase implements Service {
 
 
     /**
-     * Start nested components ({@link Executor}s, {@link Connector}s and
-     * {@link Container}s) and implement the requirements of
-     * {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
+     * Start nested components ({@link Executor}s, {@link Connector}s and {@link Container}s) and implement the
+     * requirements of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
+     * @exception LifecycleException if this component detects a fatal error that prevents this component from being
+     *                                   used
      */
     @Override
     protected void startInternal() throws LifecycleException {
 
-        if(log.isInfoEnabled()) {
+        if (log.isInfoEnabled()) {
             log.info(sm.getString("standardService.start.name", this.name));
         }
         setState(LifecycleState.STARTING);
@@ -432,7 +430,7 @@ public class StandardService extends LifecycleMBeanBase implements Service {
         }
 
         synchronized (executors) {
-            for (Executor executor: executors) {
+            for (Executor executor : executors) {
                 executor.start();
             }
         }
@@ -441,7 +439,7 @@ public class StandardService extends LifecycleMBeanBase implements Service {
 
         // Start our defined Connectors second
         synchronized (connectorsLock) {
-            for (Connector connector: connectors) {
+            for (Connector connector : connectors) {
                 // If it has already failed, don't try and start it
                 if (connector.getState() != LifecycleState.FAILED) {
                     connector.start();
@@ -452,12 +450,10 @@ public class StandardService extends LifecycleMBeanBase implements Service {
 
 
     /**
-     * Stop nested components ({@link Executor}s, {@link Connector}s and
-     * {@link Container}s) and implement the requirements of
-     * {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
+     * Stop nested components ({@link Executor}s, {@link Connector}s and {@link Container}s) and implement the
+     * requirements of {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that needs to be reported
+     * @exception LifecycleException if this component detects a fatal error that needs to be reported
      */
     @Override
     protected void stopInternal() throws LifecycleException {
@@ -466,25 +462,25 @@ public class StandardService extends LifecycleMBeanBase implements Service {
             // Initiate a graceful stop for each connector
             // This will only work if the bindOnInit==false which is not the
             // default.
-            for (Connector connector: connectors) {
+            for (Connector connector : connectors) {
                 connector.getProtocolHandler().closeServerSocketGraceful();
             }
 
             // Wait for the graceful shutdown to complete
             long waitMillis = gracefulStopAwaitMillis;
             if (waitMillis > 0) {
-                for (Connector connector: connectors) {
+                for (Connector connector : connectors) {
                     waitMillis = connector.getProtocolHandler().awaitConnectionsClose(waitMillis);
                 }
             }
 
             // Pause the connectors
-            for (Connector connector: connectors) {
+            for (Connector connector : connectors) {
                 connector.pause();
             }
         }
 
-        if(log.isInfoEnabled()) {
+        if (log.isInfoEnabled()) {
             log.info(sm.getString("standardService.stop.name", this.name));
         }
         setState(LifecycleState.STOPPING);
@@ -498,9 +494,8 @@ public class StandardService extends LifecycleMBeanBase implements Service {
 
         // Now stop the connectors
         synchronized (connectorsLock) {
-            for (Connector connector: connectors) {
-                if (!LifecycleState.STARTED.equals(
-                        connector.getState())) {
+            for (Connector connector : connectors) {
+                if (!LifecycleState.STARTED.equals(connector.getState())) {
                     // Connectors only need stopping if they are currently
                     // started. They may have failed to start or may have been
                     // stopped (e.g. via a JMX call)
@@ -517,7 +512,7 @@ public class StandardService extends LifecycleMBeanBase implements Service {
         }
 
         synchronized (executors) {
-            for (Executor executor: executors) {
+            for (Executor executor : executors) {
                 executor.stop();
             }
         }
@@ -525,8 +520,8 @@ public class StandardService extends LifecycleMBeanBase implements Service {
 
 
     /**
-     * Invoke a pre-startup initialization. This is used to allow connectors
-     * to bind to restricted ports under Unix operating environments.
+     * Invoke a pre-startup initialization. This is used to allow connectors to bind to restricted ports under Unix
+     * operating environments.
      */
     @Override
     protected void initInternal() throws LifecycleException {
@@ -605,8 +600,7 @@ public class StandardService extends LifecycleMBeanBase implements Service {
     public void setParentClassLoader(ClassLoader parent) {
         ClassLoader oldParentClassLoader = this.parentClassLoader;
         this.parentClassLoader = parent;
-        support.firePropertyChange("parentClassLoader", oldParentClassLoader,
-                                   this.parentClassLoader);
+        support.firePropertyChange("parentClassLoader", oldParentClassLoader, this.parentClassLoader);
     }
 
 

==================================================
StandardWrapper.java
index 09c34fb4a4..83a95e6fac 100644
--- a/java/org/apache/catalina/core/StandardThreadExecutor.java
+++ b/java/org/apache/catalina/core/StandardThreadExecutor.java
@@ -28,8 +28,7 @@ import org.apache.tomcat.util.threads.TaskQueue;
 import org.apache.tomcat.util.threads.TaskThreadFactory;
 import org.apache.tomcat.util.threads.ThreadPoolExecutor;
 
-public class StandardThreadExecutor extends LifecycleMBeanBase
-        implements Executor, ResizableExecutor {
+public class StandardThreadExecutor extends LifecycleMBeanBase implements Executor, ResizableExecutor {
 
     protected static final StringManager sm = StringManager.getManager(StandardThreadExecutor.class);
 
@@ -80,35 +79,35 @@ public class StandardThreadExecutor extends LifecycleMBeanBase
     protected int maxQueueSize = Integer.MAX_VALUE;
 
     /**
-     * After a context is stopped, threads in the pool are renewed. To avoid
-     * renewing all threads at the same time, this delay is observed between 2
-     * threads being renewed.
+     * After a context is stopped, threads in the pool are renewed. To avoid renewing all threads at the same time, this
+     * delay is observed between 2 threads being renewed.
      */
-    protected long threadRenewalDelay =
-        org.apache.tomcat.util.threads.Constants.DEFAULT_THREAD_RENEWAL_DELAY;
+    protected long threadRenewalDelay = org.apache.tomcat.util.threads.Constants.DEFAULT_THREAD_RENEWAL_DELAY;
 
     private TaskQueue taskqueue = null;
+
     // ---------------------------------------------- Constructors
     public StandardThreadExecutor() {
-        //empty constructor for the digester
+        // empty constructor for the digester
     }
 
 
     // ---------------------------------------------- Public Methods
 
     /**
-     * Start the component and implement the requirements
-     * of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
+     * Start the component and implement the requirements of
+     * {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
+     * @exception LifecycleException if this component detects a fatal error that prevents this component from being
+     *                                   used
      */
     @Override
     protected void startInternal() throws LifecycleException {
 
         taskqueue = new TaskQueue(maxQueueSize);
-        TaskThreadFactory tf = new TaskThreadFactory(namePrefix,daemon,getThreadPriority());
-        executor = new ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), maxIdleTime, TimeUnit.MILLISECONDS,taskqueue, tf);
+        TaskThreadFactory tf = new TaskThreadFactory(namePrefix, daemon, getThreadPriority());
+        executor = new ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), maxIdleTime, TimeUnit.MILLISECONDS,
+                taskqueue, tf);
         executor.setThreadRenewalDelay(threadRenewalDelay);
         taskqueue.setParent(executor);
 
@@ -117,11 +116,10 @@ public class StandardThreadExecutor extends LifecycleMBeanBase
 
 
     /**
-     * Stop the component and implement the requirements
-     * of {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
+     * Stop the component and implement the requirements of
+     * {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that needs to be reported
+     * @exception LifecycleException if this component detects a fatal error that needs to be reported
      */
     @Override
     protected void stopInternal() throws LifecycleException {

==================================================
StandardWrapperFacade.java
index af12983b7c..e81964ef35 100644
--- a/java/org/apache/catalina/core/StandardWrapper.java
+++ b/java/org/apache/catalina/core/StandardWrapper.java
@@ -60,20 +60,17 @@ import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.modeler.Util;
 
 /**
- * Standard implementation of the <b>Wrapper</b> interface that represents
- * an individual servlet definition.  No child Containers are allowed, and
- * the parent Container must be a Context.
+ * Standard implementation of the <b>Wrapper</b> interface that represents an individual servlet definition. No child
+ * Containers are allowed, and the parent Container must be a Context.
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
  */
-public class StandardWrapper extends ContainerBase
-    implements ServletConfig, Wrapper, NotificationEmitter {
+public class StandardWrapper extends ContainerBase implements ServletConfig, Wrapper, NotificationEmitter {
 
     private final Log log = LogFactory.getLog(StandardWrapper.class); // must not be static
 
-    protected static final String[] DEFAULT_SERVLET_METHODS = new String[] {
-                                                    "GET", "HEAD", "POST" };
+    protected static final String[] DEFAULT_SERVLET_METHODS = new String[] { "GET", "HEAD", "POST" };
 
     // ----------------------------------------------------------- Constructors
 
@@ -84,7 +81,7 @@ public class StandardWrapper extends ContainerBase
     public StandardWrapper() {
 
         super();
-        swValve=new StandardWrapperValve();
+        swValve = new StandardWrapperValve();
         pipeline.setBasic(swValve);
         broadcaster = new NotificationBroadcasterSupport();
 
@@ -95,10 +92,9 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * The date and time at which this servlet will become available (in
-     * milliseconds since the epoch), or zero if the servlet is available.
-     * If this value equals Long.MAX_VALUE, the unavailability of this
-     * servlet is considered permanent.
+     * The date and time at which this servlet will become available (in milliseconds since the epoch), or zero if the
+     * servlet is available. If this value equals Long.MAX_VALUE, the unavailability of this servlet is considered
+     * permanent.
      */
     protected long available = 0L;
 
@@ -132,8 +128,7 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * The load-on-startup order value (negative value means load on
-     * first call) for this servlet.
+     * The load-on-startup order value (negative value means load on first call) for this servlet.
      */
     protected int loadOnStartup = -1;
 
@@ -145,16 +140,14 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * The initialization parameters for this servlet, keyed by
-     * parameter name.
+     * The initialization parameters for this servlet, keyed by parameter name.
      */
     protected HashMap<String, String> parameters = new HashMap<>();
 
 
     /**
-     * The security role references for this servlet, keyed by role name
-     * used in the servlet.  The corresponding value is the role name of
-     * the web application itself.
+     * The security role references for this servlet, keyed by role name used in the servlet. The corresponding value is
+     * the role name of the web application itself.
      */
     protected HashMap<String, String> references = new HashMap<>();
 
@@ -206,8 +199,8 @@ public class StandardWrapper extends ContainerBase
 
     // To support jmx attributes
     protected StandardWrapperValve swValve;
-    protected long loadTime=0;
-    protected int classLoadTime=0;
+    protected long loadTime = 0;
+    protected int classLoadTime = 0;
 
     /**
      * Multipart config
@@ -226,14 +219,11 @@ public class StandardWrapper extends ContainerBase
 
     private boolean overridable = false;
 
-    private final ReentrantReadWriteLock parametersLock =
-            new ReentrantReadWriteLock();
+    private final ReentrantReadWriteLock parametersLock = new ReentrantReadWriteLock();
 
-    private final ReentrantReadWriteLock mappingsLock =
-            new ReentrantReadWriteLock();
+    private final ReentrantReadWriteLock mappingsLock = new ReentrantReadWriteLock();
 
-    private final ReentrantReadWriteLock referencesLock =
-            new ReentrantReadWriteLock();
+    private final ReentrantReadWriteLock referencesLock = new ReentrantReadWriteLock();
 
 
     // ------------------------------------------------------------- Properties
@@ -249,12 +239,10 @@ public class StandardWrapper extends ContainerBase
     }
 
     /**
-     * Return the available date/time for this servlet, in milliseconds since
-     * the epoch.  If this date/time is Long.MAX_VALUE, it is considered to mean
-     * that unavailability is permanent and any request for this servlet will return
-     * an SC_NOT_FOUND error.  If this date/time is in the future, any request for
-     * this servlet will return an SC_SERVICE_UNAVAILABLE error.  If it is zero,
-     * the servlet is currently available.
+     * Return the available date/time for this servlet, in milliseconds since the epoch. If this date/time is
+     * Long.MAX_VALUE, it is considered to mean that unavailability is permanent and any request for this servlet will
+     * return an SC_NOT_FOUND error. If this date/time is in the future, any request for this servlet will return an
+     * SC_SERVICE_UNAVAILABLE error. If it is zero, the servlet is currently available.
      */
     @Override
     public long getAvailable() {
@@ -263,11 +251,10 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * Set the available date/time for this servlet, in milliseconds since the
-     * epoch.  If this date/time is Long.MAX_VALUE, it is considered to mean
-     * that unavailability is permanent and any request for this servlet will return
-     * an SC_NOT_FOUND error. If this date/time is in the future, any request for
-     * this servlet will return an SC_SERVICE_UNAVAILABLE error.
+     * Set the available date/time for this servlet, in milliseconds since the epoch. If this date/time is
+     * Long.MAX_VALUE, it is considered to mean that unavailability is permanent and any request for this servlet will
+     * return an SC_NOT_FOUND error. If this date/time is in the future, any request for this servlet will return an
+     * SC_SERVICE_UNAVAILABLE error.
      *
      * @param available The new available date/time
      */
@@ -279,8 +266,7 @@ public class StandardWrapper extends ContainerBase
         } else {
             this.available = 0L;
         }
-        support.firePropertyChange("available", Long.valueOf(oldAvailable),
-                                   Long.valueOf(this.available));
+        support.firePropertyChange("available", Long.valueOf(oldAvailable), Long.valueOf(this.available));
     }
 
 
@@ -293,19 +279,17 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * @return the load-on-startup order value (negative value means
-     * load on first call).
+     * @return the load-on-startup order value (negative value means load on first call).
      */
     @Override
     public int getLoadOnStartup() {
 
         if (isJspServlet && loadOnStartup == -1) {
             /*
-             * JspServlet must always be preloaded, because its instance is
-             * used during registerJMX (when registering the JSP
-             * monitoring mbean)
+             * JspServlet must always be preloaded, because its instance is used during registerJMX (when registering
+             * the JSP monitoring mbean)
              */
-             return Integer.MAX_VALUE;
+            return Integer.MAX_VALUE;
         } else {
             return this.loadOnStartup;
         }
@@ -313,8 +297,7 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * Set the load-on-startup order value (negative value means
-     * load on first call).
+     * Set the load-on-startup order value (negative value means load on first call).
      *
      * @param value New load-on-startup value
      */
@@ -323,19 +306,16 @@ public class StandardWrapper extends ContainerBase
 
         int oldLoadOnStartup = this.loadOnStartup;
         this.loadOnStartup = value;
-        support.firePropertyChange("loadOnStartup",
-                                   Integer.valueOf(oldLoadOnStartup),
-                                   Integer.valueOf(this.loadOnStartup));
+        support.firePropertyChange("loadOnStartup", Integer.valueOf(oldLoadOnStartup),
+                Integer.valueOf(this.loadOnStartup));
 
     }
 
 
-
     /**
-     * Set the load-on-startup order value from a (possibly null) string.
-     * Per the specification, any missing or non-numeric value is converted
-     * to a zero, so that this servlet will still be loaded at startup
-     * time, but in an arbitrary order.
+     * Set the load-on-startup order value from a (possibly null) string. Per the specification, any missing or
+     * non-numeric value is converted to a zero, so that this servlet will still be loaded at startup time, but in an
+     * arbitrary order.
      *
      * @param value New load-on-startup value
      */
@@ -352,7 +332,7 @@ public class StandardWrapper extends ContainerBase
      * @return the load-on-startup value that was parsed
      */
     public String getLoadOnStartupString() {
-        return Integer.toString( getLoadOnStartup());
+        return Integer.toString(getLoadOnStartup());
     }
 
 
@@ -364,14 +344,12 @@ public class StandardWrapper extends ContainerBase
     @Override
     public void setParent(Container container) {
 
-        if ((container != null) &&
-            !(container instanceof Context)) {
-            throw new IllegalArgumentException
-                (sm.getString("standardWrapper.notContext"));
+        if ((container != null) && !(container instanceof Context)) {
+            throw new IllegalArgumentException(sm.getString("standardWrapper.notContext"));
         }
         if (container instanceof StandardContext) {
-            swallowOutput = ((StandardContext)container).getSwallowOutput();
-            unloadDelay = ((StandardContext)container).getUnloadDelay();
+            swallowOutput = ((StandardContext) container).getSwallowOutput();
+            unloadDelay = ((StandardContext) container).getUnloadDelay();
         }
         super.setParent(container);
 
@@ -421,20 +399,16 @@ public class StandardWrapper extends ContainerBase
 
         String oldServletClass = this.servletClass;
         this.servletClass = servletClass;
-        support.firePropertyChange("servletClass", oldServletClass,
-                                   this.servletClass);
+        support.firePropertyChange("servletClass", oldServletClass, this.servletClass);
         if (Constants.JSP_SERVLET_CLASS.equals(servletClass)) {
             isJspServlet = true;
         }
     }
 
 
-
     /**
-     * Set the name of this servlet.  This is an alias for the normal
-     * <code>Container.setName()</code> method, and complements the
-     * <code>getServletName()</code> method required by the
-     * <code>ServletConfig</code> interface.
+     * Set the name of this servlet. This is an alias for the normal <code>Container.setName()</code> method, and
+     * complements the <code>getServletName()</code> method required by the <code>ServletConfig</code> interface.
      *
      * @param name The new name of this servlet
      */
@@ -471,8 +445,7 @@ public class StandardWrapper extends ContainerBase
         instance = loadServlet();
 
         Class<? extends Servlet> servletClazz = instance.getClass();
-        if (!jakarta.servlet.http.HttpServlet.class.isAssignableFrom(
-                                                        servletClazz)) {
+        if (!jakarta.servlet.http.HttpServlet.class.isAssignableFrom(servletClazz)) {
             return DEFAULT_SERVLET_METHODS;
         }
 
@@ -487,7 +460,7 @@ public class StandardWrapper extends ContainerBase
             allow.add("TRACE");
 
             Method[] methods = getAllDeclaredMethods(servletClazz);
-            for (int i=0; methods != null && i<methods.length; i++) {
+            for (int i = 0; methods != null && i < methods.length; i++) {
                 Method m = methods[i];
 
                 if (m.getName().equals("doGet")) {
@@ -528,9 +501,8 @@ public class StandardWrapper extends ContainerBase
     // --------------------------------------------------------- Public Methods
 
     /**
-     * Execute a periodic task, such as reloading, etc. This method will be
-     * invoked inside the classloading context of this container. Unexpected
-     * throwables will be caught and logged.
+     * Execute a periodic task, such as reloading, etc. This method will be invoked inside the classloading context of
+     * this container. Unexpected throwables will be caught and logged.
      */
     @Override
     public void backgroundProcess() {
@@ -550,6 +522,7 @@ public class StandardWrapper extends ContainerBase
      * Extract the root cause from a servlet exception.
      *
      * @param e The servlet exception
+     *
      * @return the root cause of the Servlet exception
      */
     public static Throwable getRootCause(ServletException e) {
@@ -569,16 +542,14 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * Refuse to add a child Container, because Wrappers are the lowest level
-     * of the Container hierarchy.
+     * Refuse to add a child Container, because Wrappers are the lowest level of the Container hierarchy.
      *
      * @param child Child container to be added
      */
     @Override
     public void addChild(Container child) {
 
-        throw new IllegalStateException
-            (sm.getString("standardWrapper.notChild"));
+        throw new IllegalStateException(sm.getString("standardWrapper.notChild"));
 
     }
 
@@ -586,7 +557,7 @@ public class StandardWrapper extends ContainerBase
     /**
      * Add a new servlet initialization parameter for this servlet.
      *
-     * @param name Name of this initialization parameter to add
+     * @param name  Name of this initialization parameter to add
      * @param value Value of this initialization parameter to add
      */
     @Override
@@ -617,7 +588,7 @@ public class StandardWrapper extends ContainerBase
         } finally {
             mappingsLock.writeLock().unlock();
         }
-        if(parent.getState().equals(LifecycleState.STARTED)) {
+        if (parent.getState().equals(LifecycleState.STARTED)) {
             fireContainerEvent(ADD_MAPPING_EVENT, mapping);
         }
 
@@ -625,8 +596,7 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * Add a new security role reference record to the set of records for
-     * this servlet.
+     * Add a new security role reference record to the set of records for this servlet.
      *
      * @param name Role name used within this servlet
      * @param link Role name used within the web application
@@ -646,11 +616,9 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * Allocate an initialized instance of this Servlet that is ready to have
-     * its <code>service()</code> method called.
+     * Allocate an initialized instance of this Servlet that is ready to have its <code>service()</code> method called.
      *
-     * @exception ServletException if the servlet init() method threw
-     *  an exception
+     * @exception ServletException if the servlet init() method threw an exception
      * @exception ServletException if a loading error occurs
      */
     @Override
@@ -715,8 +683,7 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * Return the value for the specified initialization parameter name,
-     * if any; otherwise return <code>null</code>.
+     * Return the value for the specified initialization parameter name, if any; otherwise return <code>null</code>.
      *
      * @param name Name of the requested initialization parameter
      */
@@ -734,8 +701,7 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * Return the names of all defined initialization parameters for this
-     * servlet.
+     * Return the names of all defined initialization parameters for this servlet.
      */
     @Override
     public String[] findInitParameters() {
@@ -767,8 +733,8 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * Return the security role link for the specified security role
-     * reference name, if any; otherwise return <code>null</code>.
+     * Return the security role link for the specified security role reference name, if any; otherwise return
+     * <code>null</code>.
      *
      * @param name Security role reference used within this servlet
      */
@@ -798,8 +764,8 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * Return the set of security role reference names associated with
-     * this servlet, if any; otherwise return a zero-length array.
+     * Return the set of security role reference names associated with this servlet, if any; otherwise return a
+     * zero-length array.
      */
     @Override
     public String[] findSecurityReferences() {
@@ -815,20 +781,16 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * Load and initialize an instance of this servlet, if there is not already
-     * at least one initialized instance.  This can be used, for example, to
-     * load servlets that are marked in the deployment descriptor to be loaded
-     * at server startup time.
+     * Load and initialize an instance of this servlet, if there is not already at least one initialized instance. This
+     * can be used, for example, to load servlets that are marked in the deployment descriptor to be loaded at server
+     * startup time.
      * <p>
-     * <b>IMPLEMENTATION NOTE</b>:  Servlets whose classnames begin with
-     * <code>org.apache.catalina.</code> (so-called "container" servlets)
-     * are loaded by the same classloader that loaded this class, rather than
-     * the classloader for the current web application.
-     * This gives such classes access to Catalina internals, which are
-     * prevented for classes loaded for web applications.
+     * <b>IMPLEMENTATION NOTE</b>: Servlets whose classnames begin with <code>org.apache.catalina.</code> (so-called
+     * "container" servlets) are loaded by the same classloader that loaded this class, rather than the classloader for
+     * the current web application. This gives such classes access to Catalina internals, which are prevented for
+     * classes loaded for web applications.
      *
-     * @exception ServletException if the servlet init() method threw
-     *  an exception
+     * @exception ServletException if the servlet init() method threw an exception
      * @exception ServletException if some other loading problem occurs
      */
     @Override
@@ -862,12 +824,12 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * Load and initialize an instance of this servlet, if there is not already
-     * an initialized instance.  This can be used, for example, to load servlets
-     * that are marked in the deployment descriptor to be loaded at server
-     * startup time.
+     * Load and initialize an instance of this servlet, if there is not already an initialized instance. This can be
+     * used, for example, to load servlets that are marked in the deployment descriptor to be loaded at server startup
+     * time.
      *
      * @return the loaded Servlet instance
+     *
      * @throws ServletException for a Servlet load error
      */
     public synchronized Servlet loadServlet() throws ServletException {
@@ -884,22 +846,20 @@ public class StandardWrapper extends ContainerBase
 
         Servlet servlet;
         try {
-            long t1=System.currentTimeMillis();
+            long t1 = System.currentTimeMillis();
             // Complain if no servlet class has been specified
             if (servletClass == null) {
                 unavailable(null);
-                throw new ServletException
-                    (sm.getString("standardWrapper.notClass", getName()));
+                throw new ServletException(sm.getString("standardWrapper.notClass", getName()));
             }
 
-            InstanceManager instanceManager = ((StandardContext)getParent()).getInstanceManager();
+            InstanceManager instanceManager = ((StandardContext) getParent()).getInstanceManager();
             try {
                 servlet = (Servlet) instanceManager.newInstance(servletClass);
             } catch (ClassCastException e) {
                 unavailable(null);
                 // Restore the context ClassLoader
-                throw new ServletException
-                    (sm.getString("standardWrapper.notServlet", servletClass), e);
+                throw new ServletException(sm.getString("standardWrapper.notServlet", servletClass), e);
             } catch (Throwable e) {
                 e = ExceptionUtils.unwrapInvocationTargetException(e);
                 ExceptionUtils.handleThrowable(e);
@@ -907,38 +867,35 @@ public class StandardWrapper extends ContainerBase
 
                 // Added extra log statement for Bugzilla 36630:
                 // https://bz.apache.org/bugzilla/show_bug.cgi?id=36630
-                if(log.isDebugEnabled()) {
+                if (log.isDebugEnabled()) {
                     log.debug(sm.getString("standardWrapper.instantiate", servletClass), e);
                 }
 
                 // Restore the context ClassLoader
-                throw new ServletException
-                    (sm.getString("standardWrapper.instantiate", servletClass), e);
+                throw new ServletException(sm.getString("standardWrapper.instantiate", servletClass), e);
             }
 
             if (multipartConfigElement == null) {
-                MultipartConfig annotation =
-                        servlet.getClass().getAnnotation(MultipartConfig.class);
+                MultipartConfig annotation = servlet.getClass().getAnnotation(MultipartConfig.class);
                 if (annotation != null) {
-                    multipartConfigElement =
-                            new MultipartConfigElement(annotation);
+                    multipartConfigElement = new MultipartConfigElement(annotation);
                 }
             }
 
             // Special handling for ContainerServlet instances
             // Note: The InstanceManager checks if the application is permitted
-            //       to load ContainerServlets
+            // to load ContainerServlets
             if (servlet instanceof ContainerServlet) {
                 ((ContainerServlet) servlet).setWrapper(this);
             }
 
-            classLoadTime=(int) (System.currentTimeMillis() -t1);
+            classLoadTime = (int) (System.currentTimeMillis() - t1);
 
             initServlet(servlet);
 
             fireContainerEvent("load", this);
 
-            loadTime=System.currentTimeMillis() -t1;
+            loadTime = System.currentTimeMillis() - t1;
         } finally {
             if (swallowOutput) {
                 String log = SystemLogHandler.stopCapture();
@@ -956,8 +913,7 @@ public class StandardWrapper extends ContainerBase
     }
 
 
-    private synchronized void initServlet(Servlet servlet)
-            throws ServletException {
+    private synchronized void initServlet(Servlet servlet) throws ServletException {
 
         if (instanceInitialized) {
             return;
@@ -979,8 +935,7 @@ public class StandardWrapper extends ContainerBase
             getServletContext().log(sm.getString("standardWrapper.initException", getName()), f);
             // If the servlet wanted to be unavailable it would have
             // said so, so do not call unavailable(null).
-            throw new ServletException
-                (sm.getString("standardWrapper.initException", getName()), f);
+            throw new ServletException(sm.getString("standardWrapper.initException", getName()), f);
         }
     }
 
@@ -1017,7 +972,7 @@ public class StandardWrapper extends ContainerBase
         } finally {
             mappingsLock.writeLock().unlock();
         }
-        if(parent.getState().equals(LifecycleState.STARTED)) {
+        if (parent.getState().equals(LifecycleState.STARTED)) {
             fireContainerEvent(REMOVE_MAPPING_EVENT, mapping);
         }
 
@@ -1044,11 +999,10 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * Process an UnavailableException, marking this servlet as unavailable
-     * for the specified amount of time.
+     * Process an UnavailableException, marking this servlet as unavailable for the specified amount of time.
      *
-     * @param unavailable The exception that occurred, or <code>null</code>
-     *  to mark this servlet as permanently unavailable
+     * @param unavailable The exception that occurred, or <code>null</code> to mark this servlet as permanently
+     *                        unavailable
      */
     @Override
     public void unavailable(UnavailableException unavailable) {
@@ -1059,26 +1013,21 @@ public class StandardWrapper extends ContainerBase
             setAvailable(Long.MAX_VALUE);
         } else {
             int unavailableSeconds = unavailable.getUnavailableSeconds();
-            if (unavailableSeconds <= 0)
-             {
-                unavailableSeconds = 60;        // Arbitrary default
+            if (unavailableSeconds <= 0) {
+                unavailableSeconds = 60; // Arbitrary default
             }
-            setAvailable(System.currentTimeMillis() +
-                         (unavailableSeconds * 1000L));
+            setAvailable(System.currentTimeMillis() + (unavailableSeconds * 1000L));
         }
 
     }
 
 
     /**
-     * Unload all initialized instances of this servlet, after calling the
-     * <code>destroy()</code> method for each instance.  This can be used,
-     * for example, prior to shutting down the entire servlet engine, or
-     * prior to reloading all of the classes from the Loader associated with
-     * our Loader's repository.
+     * Unload all initialized instances of this servlet, after calling the <code>destroy()</code> method for each
+     * instance. This can be used, for example, prior to shutting down the entire servlet engine, or prior to reloading
+     * all of the classes from the Loader associated with our Loader's repository.
      *
-     * @exception ServletException if an exception is thrown by the
-     *  destroy() method
+     * @exception ServletException if an exception is thrown by the destroy() method
      */
     @Override
     public synchronized void unload() throws ServletException {
@@ -1095,9 +1044,7 @@ public class StandardWrapper extends ContainerBase
             long delay = unloadDelay / 20;
             while ((nRetries < 21) && (countAllocated.get() > 0)) {
                 if ((nRetries % 10) == 0) {
-                    log.info(sm.getString("standardWrapper.waiting",
-                                          countAllocated.toString(),
-                                          getName()));
+                    log.info(sm.getString("standardWrapper.waiting", countAllocated.toString(), getName()));
                 }
                 try {
                     Thread.sleep(delay);
@@ -1122,14 +1069,12 @@ public class StandardWrapper extends ContainerBase
                 ExceptionUtils.handleThrowable(t);
                 fireContainerEvent("unload", this);
                 unloading = false;
-                throw new ServletException
-                    (sm.getString("standardWrapper.destroyException", getName()),
-                     t);
+                throw new ServletException(sm.getString("standardWrapper.destroyException", getName()), t);
             } finally {
                 // Annotation processing
                 if (!((Context) getParent()).getIgnoreAnnotations()) {
                     try {
-                        ((Context)getParent()).getInstanceManager().destroyInstance(instance);
+                        ((Context) getParent()).getInstanceManager().destroyInstance(instance);
                     } catch (Throwable t) {
                         ExceptionUtils.handleThrowable(t);
                         log.error(sm.getString("standardWrapper.destroyInstance", getName()), t);
@@ -1154,7 +1099,7 @@ public class StandardWrapper extends ContainerBase
         // Deregister the destroyed instance
         instance = null;
 
-        if (isJspServlet && jspMonitorON != null ) {
+        if (isJspServlet && jspMonitorON != null) {
             Registry.getRegistry(null, null).unregisterComponent(jspMonitorON);
         }
 
@@ -1167,8 +1112,7 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * @return the initialization parameter value for the specified name,
-     * if any; otherwise return <code>null</code>.
+     * @return the initialization parameter value for the specified name, if any; otherwise return <code>null</code>.
      *
      * @param name Name of the initialization parameter to retrieve
      */
@@ -1179,8 +1123,8 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * @return the set of initialization parameter names defined for this
-     * servlet.  If none are defined, an empty Enumeration is returned.
+     * @return the set of initialization parameter names defined for this servlet. If none are defined, an empty
+     *             Enumeration is returned.
      */
     @Override
     public Enumeration<String> getInitParameterNames() {
@@ -1242,7 +1186,7 @@ public class StandardWrapper extends ContainerBase
      * Increment the error count used for monitoring.
      */
     @Override
-    public void incrementErrorCount(){
+    public void incrementErrorCount() {
         swValve.incrementErrorCount();
     }
 
@@ -1260,8 +1204,7 @@ public class StandardWrapper extends ContainerBase
     }
 
     @Override
-    public void setMultipartConfigElement(
-            MultipartConfigElement multipartConfigElement) {
+    public void setMultipartConfigElement(MultipartConfigElement multipartConfigElement) {
         this.multipartConfigElement = multipartConfigElement;
     }
 
@@ -1305,12 +1248,9 @@ public class StandardWrapper extends ContainerBase
         }
 
         if ((parentMethods != null) && (parentMethods.length > 0)) {
-            Method[] allMethods =
-                new Method[parentMethods.length + thisMethods.length];
-            System.arraycopy(parentMethods, 0, allMethods, 0,
-                             parentMethods.length);
-            System.arraycopy(thisMethods, 0, allMethods, parentMethods.length,
-                             thisMethods.length);
+            Method[] allMethods = new Method[parentMethods.length + thisMethods.length];
+            System.arraycopy(parentMethods, 0, allMethods, 0, parentMethods.length);
+            System.arraycopy(thisMethods, 0, allMethods, parentMethods.length, thisMethods.length);
 
             thisMethods = allMethods;
         }
@@ -1323,20 +1263,18 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * Start this component and implement the requirements
-     * of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
+     * Start this component and implement the requirements of
+     * {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
+     * @exception LifecycleException if this component detects a fatal error that prevents this component from being
+     *                                   used
      */
     @Override
     protected synchronized void startInternal() throws LifecycleException {
 
         // Send j2ee.state.starting notification
         if (this.getObjectName() != null) {
-            Notification notification = new Notification("j2ee.state.starting",
-                                                        this.getObjectName(),
-                                                        sequenceNumber++);
+            Notification notification = new Notification("j2ee.state.starting", this.getObjectName(), sequenceNumber++);
             broadcaster.sendNotification(notification);
         }
 
@@ -1347,9 +1285,7 @@ public class StandardWrapper extends ContainerBase
 
         // Send j2ee.state.running notification
         if (this.getObjectName() != null) {
-            Notification notification =
-                new Notification("j2ee.state.running", this.getObjectName(),
-                                sequenceNumber++);
+            Notification notification = new Notification("j2ee.state.running", this.getObjectName(), sequenceNumber++);
             broadcaster.sendNotification(notification);
         }
 
@@ -1357,11 +1293,11 @@ public class StandardWrapper extends ContainerBase
 
 
     /**
-     * Stop this component and implement the requirements
-     * of {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
+     * Stop this component and implement the requirements of
+     * {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
      *
-     * @exception LifecycleException if this component detects a fatal error
-     *  that prevents this component from being used
+     * @exception LifecycleException if this component detects a fatal error that prevents this component from being
+     *                                   used
      */
     @Override
     protected synchronized void stopInternal() throws LifecycleException {
@@ -1370,9 +1306,7 @@ public class StandardWrapper extends ContainerBase
 
         // Send j2ee.state.stopping notification
         if (this.getObjectName() != null) {
-            Notification notification =
-                new Notification("j2ee.state.stopping", this.getObjectName(),
-                                sequenceNumber++);
+            Notification notification = new Notification("j2ee.state.stopping", this.getObjectName(), sequenceNumber++);
             broadcaster.sendNotification(notification);
         }
 
@@ -1380,8 +1314,7 @@ public class StandardWrapper extends ContainerBase
         try {
             unload();
         } catch (ServletException e) {
-            getServletContext().log(sm.getString
-                      ("standardWrapper.unloadException", getName()), e);
+            getServletContext().log(sm.getString("standardWrapper.unloadException", getName()), e);
         }
 
         // Shut down this component
@@ -1389,16 +1322,12 @@ public class StandardWrapper extends ContainerBase
 
         // Send j2ee.state.stopped notification
         if (this.getObjectName() != null) {
-            Notification notification =
-                new Notification("j2ee.state.stopped", this.getObjectName(),
-                                sequenceNumber++);
+            Notification notification = new Notification("j2ee.state.stopped", this.getObjectName(), sequenceNumber++);
             broadcaster.sendNotification(notification);
         }
 
         // Send j2ee.object.deleted notification
-        Notification notification =
-            new Notification("j2ee.object.deleted", this.getObjectName(),
-                            sequenceNumber++);
+        Notification notification = new Notification("j2ee.object.deleted", this.getObjectName(), sequenceNumber++);
         broadcaster.sendNotification(notification);
 
     }
@@ -1407,8 +1336,7 @@ public class StandardWrapper extends ContainerBase
     @Override
     protected String getObjectNameKeyProperties() {
 
-        StringBuilder keyProperties =
-            new StringBuilder("j2eeType=Servlet");
+        StringBuilder keyProperties = new StringBuilder("j2eeType=Servlet");
 
         keyProperties.append(getWebModuleKeyProperties());
 
@@ -1472,18 +1400,21 @@ public class StandardWrapper extends ContainerBase
 
     /**
      * Remove a JMX notificationListener
-     * @see javax.management.NotificationEmitter#removeNotificationListener(javax.management.NotificationListener, javax.management.NotificationFilter, java.lang.Object)
+     *
+     * @see javax.management.NotificationEmitter#removeNotificationListener(javax.management.NotificationListener,
+     *          javax.management.NotificationFilter, java.lang.Object)
      */
     @Override
-    public void removeNotificationListener(NotificationListener listener,
-            NotificationFilter filter, Object object) throws ListenerNotFoundException {
-        broadcaster.removeNotificationListener(listener,filter,object);
+    public void removeNotificationListener(NotificationListener listener, NotificationFilter filter, Object object)
+            throws ListenerNotFoundException {
+        broadcaster.removeNotificationListener(listener, filter, object);
     }
 
     protected MBeanNotificationInfo[] notificationInfo;
 
     /**
      * Get JMX Broadcaster Info
+     *
      * @see javax.management.NotificationBroadcaster#getNotificationInfo()
      */
     @Override
@@ -1492,26 +1423,17 @@ public class StandardWrapper extends ContainerBase
         // FIXME: we not send j2ee.attribute.changed
         if (notificationInfo == null) {
             notificationInfo = new MBeanNotificationInfo[] {
-                    new MBeanNotificationInfo(
-                            new String[] { "j2ee.object.created" },
-                            Notification.class.getName(), "servlet is created"),
-                    new MBeanNotificationInfo(
-                            new String[] { "j2ee.state.starting" },
-                            Notification.class.getName(),
+                    new MBeanNotificationInfo(new String[] { "j2ee.object.created" }, Notification.class.getName(),
+                            "servlet is created"),
+                    new MBeanNotificationInfo(new String[] { "j2ee.state.starting" }, Notification.class.getName(),
                             "servlet is starting"),
-                    new MBeanNotificationInfo(
-                            new String[] { "j2ee.state.running" },
-                            Notification.class.getName(), "servlet is running"),
-                    new MBeanNotificationInfo(
-                            new String[] { "j2ee.state.stopped" },
-                            Notification.class.getName(),
+                    new MBeanNotificationInfo(new String[] { "j2ee.state.running" }, Notification.class.getName(),
+                            "servlet is running"),
+                    new MBeanNotificationInfo(new String[] { "j2ee.state.stopped" }, Notification.class.getName(),
                             "servlet start to stopped"),
-                    new MBeanNotificationInfo(
-                            new String[] { "j2ee.object.stopped" },
-                            Notification.class.getName(), "servlet is stopped"),
-                    new MBeanNotificationInfo(
-                            new String[] { "j2ee.object.deleted" },
-                            Notification.class.getName(),
+                    new MBeanNotificationInfo(new String[] { "j2ee.object.stopped" }, Notification.class.getName(),
+                            "servlet is stopped"),
+                    new MBeanNotificationInfo(new String[] { "j2ee.object.deleted" }, Notification.class.getName(),
                             "servlet is deleted") };
         }
         return notificationInfo;
@@ -1520,22 +1442,24 @@ public class StandardWrapper extends ContainerBase
 
     /**
      * Add a JMX-NotificationListener
-     * @see javax.management.NotificationBroadcaster#addNotificationListener(javax.management.NotificationListener, javax.management.NotificationFilter, java.lang.Object)
+     *
+     * @see javax.management.NotificationBroadcaster#addNotificationListener(javax.management.NotificationListener,
+     *          javax.management.NotificationFilter, java.lang.Object)
      */
     @Override
-    public void addNotificationListener(NotificationListener listener,
-            NotificationFilter filter, Object object) throws IllegalArgumentException {
-        broadcaster.addNotificationListener(listener,filter,object);
+    public void addNotificationListener(NotificationListener listener, NotificationFilter filter, Object object)
+            throws IllegalArgumentException {
+        broadcaster.addNotificationListener(listener, filter, object);
     }
 
 
     /**
      * Remove a JMX-NotificationListener
+     *
      * @see javax.management.NotificationBroadcaster#removeNotificationListener(javax.management.NotificationListener)
      */
     @Override
-    public void removeNotificationListener(NotificationListener listener)
-        throws ListenerNotFoundException {
+    public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException {
         broadcaster.removeNotificationListener(listener);
     }
 }

==================================================
StandardWrapperValve.java
index b6c3f00a51..b7c0c8060b 100644
--- a/java/org/apache/catalina/core/StandardWrapperFacade.java
+++ b/java/org/apache/catalina/core/StandardWrapperFacade.java
@@ -28,8 +28,7 @@ import jakarta.servlet.ServletContext;
  *
  * @author Remy Maucherat
  */
-public final class StandardWrapperFacade
-    implements ServletConfig {
+public final class StandardWrapperFacade implements ServletConfig {
 
 
     // ----------------------------------------------------------- Constructors
@@ -37,6 +36,7 @@ public final class StandardWrapperFacade
 
     /**
      * Create a new facade around a StandardWrapper.
+     *
      * @param config the associated wrapper
      */
     public StandardWrapperFacade(StandardWrapper config) {

==================================================
ThreadLocalLeakPreventionListener.java
index db565a033f..e22d755e01 100644
--- a/java/org/apache/catalina/core/StandardWrapperValve.java
+++ b/java/org/apache/catalina/core/StandardWrapperValve.java
@@ -42,8 +42,7 @@ import org.apache.tomcat.util.log.SystemLogHandler;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * Valve that implements the default basic behavior for the
- * <code>StandardWrapper</code> container implementation.
+ * Valve that implements the default basic behavior for the <code>StandardWrapper</code> container implementation.
  *
  * @author Craig R. McClanahan
  */
@@ -52,7 +51,7 @@ final class StandardWrapperValve extends ValveBase {
     private static final StringManager sm = StringManager.getManager(StandardWrapperValve.class);
 
 
-    //------------------------------------------------------ Constructor
+    // ------------------------------------------------------ Constructor
 
     public StandardWrapperValve() {
         super(true);
@@ -74,24 +73,22 @@ final class StandardWrapperValve extends ValveBase {
     // --------------------------------------------------------- Public Methods
 
     /**
-     * Invoke the servlet we are managing, respecting the rules regarding
-     * servlet lifecycle support.
+     * Invoke the servlet we are managing, respecting the rules regarding servlet lifecycle support.
      *
-     * @param request Request to be processed
+     * @param request  Request to be processed
      * @param response Response to be produced
      *
-     * @exception IOException if an input/output error occurred
+     * @exception IOException      if an input/output error occurred
      * @exception ServletException if a servlet error occurred
      */
     @Override
-    public final void invoke(Request request, Response response)
-        throws IOException, ServletException {
+    public final void invoke(Request request, Response response) throws IOException, ServletException {
 
         // Initialize local variables we may need
         boolean unavailable = false;
         Throwable throwable = null;
         // This should be a Request attribute...
-        long t1=System.currentTimeMillis();
+        long t1 = System.currentTimeMillis();
         requestCount.incrementAndGet();
         StandardWrapper wrapper = (StandardWrapper) getContainer();
         Servlet servlet = null;
@@ -100,14 +97,13 @@ final class StandardWrapperValve extends ValveBase {
         // Check for the application being marked unavailable
         if (!context.getState().isAvailable()) {
             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,
-                           sm.getString("standardContext.isUnavailable"));
+                    sm.getString("standardContext.isUnavailable"));
             unavailable = true;
         }
 
         // Check for the servlet being marked unavailable
         if (!unavailable && wrapper.isUnavailable()) {
-            container.getLogger().info(sm.getString("standardWrapper.isUnavailable",
-                    wrapper.getName()));
+            container.getLogger().info(sm.getString("standardWrapper.isUnavailable", wrapper.getName()));
             checkWrapperAvailable(response, wrapper);
             unavailable = true;
         }
@@ -118,19 +114,16 @@ final class StandardWrapperValve extends ValveBase {
                 servlet = wrapper.allocate();
             }
         } catch (UnavailableException e) {
-            container.getLogger().error(
-                    sm.getString("standardWrapper.allocateException",
-                            wrapper.getName()), e);
+            container.getLogger().error(sm.getString("standardWrapper.allocateException", wrapper.getName()), e);
             checkWrapperAvailable(response, wrapper);
         } catch (ServletException e) {
-            container.getLogger().error(sm.getString("standardWrapper.allocateException",
-                             wrapper.getName()), StandardWrapper.getRootCause(e));
+            container.getLogger().error(sm.getString("standardWrapper.allocateException", wrapper.getName()),
+                    StandardWrapper.getRootCause(e));
             throwable = e;
             exception(request, response, e);
         } catch (Throwable e) {
             ExceptionUtils.handleThrowable(e);
-            container.getLogger().error(sm.getString("standardWrapper.allocateException",
-                             wrapper.getName()), e);
+            container.getLogger().error(sm.getString("standardWrapper.allocateException", wrapper.getName()), e);
             throwable = e;
             exception(request, response, e);
             servlet = null;
@@ -138,15 +131,13 @@ final class StandardWrapperValve extends ValveBase {
 
         MessageBytes requestPathMB = request.getRequestPathMB();
         DispatcherType dispatcherType = DispatcherType.REQUEST;
-        if (request.getDispatcherType()==DispatcherType.ASYNC) {
+        if (request.getDispatcherType() == DispatcherType.ASYNC) {
             dispatcherType = DispatcherType.ASYNC;
         }
-        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);
-        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,
-                requestPathMB);
+        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, dispatcherType);
+        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);
         // Create the filter chain for this request
-        ApplicationFilterChain filterChain =
-                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);
+        ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);
 
         // Call the filter chain for this request
         // NOTE: This also calls the servlet's service() method
@@ -160,8 +151,7 @@ final class StandardWrapperValve extends ValveBase {
                         if (request.isAsyncDispatching()) {
                             request.getAsyncContextInternal().doInternalDispatch();
                         } else {
-                            filterChain.doFilter(request.getRequest(),
-                                    response.getResponse());
+                            filterChain.doFilter(request.getRequest(), response.getResponse());
                         }
                     } finally {
                         String log = SystemLogHandler.stopCapture();
@@ -173,30 +163,26 @@ final class StandardWrapperValve extends ValveBase {
                     if (request.isAsyncDispatching()) {
                         request.getAsyncContextInternal().doInternalDispatch();
                     } else {
-                        filterChain.doFilter
-                            (request.getRequest(), response.getResponse());
+                        filterChain.doFilter(request.getRequest(), response.getResponse());
                     }
                 }
 
             }
         } catch (ClientAbortException | CloseNowException e) {
             if (container.getLogger().isDebugEnabled()) {
-                container.getLogger().debug(sm.getString(
-                        "standardWrapper.serviceException", wrapper.getName(),
-                        context.getName()), e);
+                container.getLogger().debug(
+                        sm.getString("standardWrapper.serviceException", wrapper.getName(), context.getName()), e);
             }
             throwable = e;
             exception(request, response, e);
         } catch (IOException e) {
-            container.getLogger().error(sm.getString(
-                    "standardWrapper.serviceException", wrapper.getName(),
-                    context.getName()), e);
+            container.getLogger()
+                    .error(sm.getString("standardWrapper.serviceException", wrapper.getName(), context.getName()), e);
             throwable = e;
             exception(request, response, e);
         } catch (UnavailableException e) {
-            container.getLogger().error(sm.getString(
-                    "standardWrapper.serviceException", wrapper.getName(),
-                    context.getName()), e);
+            container.getLogger()
+                    .error(sm.getString("standardWrapper.serviceException", wrapper.getName(), context.getName()), e);
             wrapper.unavailable(e);
             checkWrapperAvailable(response, wrapper);
             // Do not save exception in 'throwable', because we
@@ -204,18 +190,15 @@ final class StandardWrapperValve extends ValveBase {
         } catch (ServletException e) {
             Throwable rootCause = StandardWrapper.getRootCause(e);
             if (!(rootCause instanceof ClientAbortException)) {
-                container.getLogger().error(sm.getString(
-                        "standardWrapper.serviceExceptionRoot",
-                        wrapper.getName(), context.getName(), e.getMessage()),
-                        rootCause);
+                container.getLogger().error(sm.getString("standardWrapper.serviceExceptionRoot", wrapper.getName(),
+                        context.getName(), e.getMessage()), rootCause);
             }
             throwable = e;
             exception(request, response, e);
         } catch (Throwable e) {
             ExceptionUtils.handleThrowable(e);
-            container.getLogger().error(sm.getString(
-                    "standardWrapper.serviceException", wrapper.getName(),
-                    context.getName()), e);
+            container.getLogger()
+                    .error(sm.getString("standardWrapper.serviceException", wrapper.getName(), context.getName()), e);
             throwable = e;
             exception(request, response, e);
         } finally {
@@ -231,8 +214,7 @@ final class StandardWrapperValve extends ValveBase {
                 }
             } catch (Throwable e) {
                 ExceptionUtils.handleThrowable(e);
-                container.getLogger().error(sm.getString("standardWrapper.deallocateException",
-                                 wrapper.getName()), e);
+                container.getLogger().error(sm.getString("standardWrapper.deallocateException", wrapper.getName()), e);
                 if (throwable == null) {
                     throwable = e;
                     exception(request, response, e);
@@ -242,27 +224,25 @@ final class StandardWrapperValve extends ValveBase {
             // If this servlet has been marked permanently unavailable,
             // unload it and release this instance
             try {
-                if ((servlet != null) &&
-                    (wrapper.getAvailable() == Long.MAX_VALUE)) {
+                if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {
                     wrapper.unload();
                 }
             } catch (Throwable e) {
                 ExceptionUtils.handleThrowable(e);
-                container.getLogger().error(sm.getString("standardWrapper.unloadException",
-                                 wrapper.getName()), e);
+                container.getLogger().error(sm.getString("standardWrapper.unloadException", wrapper.getName()), e);
                 if (throwable == null) {
                     exception(request, response, e);
                 }
             }
-            long t2=System.currentTimeMillis();
+            long t2 = System.currentTimeMillis();
 
-            long time=t2-t1;
+            long time = t2 - t1;
             processingTime += time;
-            if( time > maxTime) {
-                maxTime=time;
+            if (time > maxTime) {
+                maxTime = time;
             }
-            if( time < minTime) {
-                minTime=time;
+            if (time < minTime) {
+                minTime = time;
             }
         }
     }
@@ -272,12 +252,10 @@ final class StandardWrapperValve extends ValveBase {
         if ((available > 0L) && (available < Long.MAX_VALUE)) {
             response.setDateHeader("Retry-After", available);
             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,
-                       sm.getString("standardWrapper.isUnavailable",
-                                    wrapper.getName()));
+                    sm.getString("standardWrapper.isUnavailable", wrapper.getName()));
         } else if (available == Long.MAX_VALUE) {
             response.sendError(HttpServletResponse.SC_NOT_FOUND,
-                        sm.getString("standardWrapper.notFound",
-                                    wrapper.getName()));
+                    sm.getString("standardWrapper.notFound", wrapper.getName()));
         }
     }
 
@@ -285,18 +263,14 @@ final class StandardWrapperValve extends ValveBase {
     // -------------------------------------------------------- Private Methods
 
     /**
-     * Handle the specified ServletException encountered while processing
-     * the specified Request to produce the specified Response.  Any
-     * exceptions that occur during generation of the exception report are
-     * logged and swallowed.
+     * Handle the specified ServletException encountered while processing the specified Request to produce the specified
+     * Response. Any exceptions that occur during generation of the exception report are logged and swallowed.
      *
-     * @param request The request being processed
-     * @param response The response being generated
-     * @param exception The exception that occurred (which possibly wraps
-     *  a root cause exception
+     * @param request   The request being processed
+     * @param response  The response being generated
+     * @param exception The exception that occurred (which possibly wraps a root cause exception
      */
-    private void exception(Request request, Response response,
-                           Throwable exception) {
+    private void exception(Request request, Response response, Throwable exception) {
         request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, exception);
         response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
         response.setError();

==================================================
