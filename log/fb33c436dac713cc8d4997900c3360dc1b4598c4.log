fb33c436dac713cc8d4997900c3360dc1b4598c4
==================================================
Refactor the TLD JAR scanning. This a) reduces duplication between Catalina and Jasper b) allows the Jar scanning to be controlled by configuration rather than system properties and c) (hopefully) allows the scanning code to be re-used for web-fragment.xml scanning
==================================================
Mark Emlyn
==================================================
Tue Sep 22 14:54:28 2009 +0000
==================================================
Context.java
Refactor the TLD JAR scanning. This a) reduces duplication between Catalina and Jasper b) allows the Jar scanning to be controlled by configuration rather than system properties and c) (hopefully) allows the scanning code to be re-used for web-fragment.xml scanning
The JSP TCK passes with this patch applied

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@817685 13f79535-47bb-0310-9956-ffa450edef68



==================================================
StandardContext.java
index 0f6c20a319..b8478f4ac4 100644
--- a/java/org/apache/catalina/Context.java
+++ b/java/org/apache/catalina/Context.java
@@ -21,6 +21,7 @@ package org.apache.catalina;
 
 import javax.servlet.ServletContext;
 
+import org.apache.tomcat.JarScanner;
 import org.apache.tomcat.util.http.mapper.Mapper;
 
 import org.apache.catalina.deploy.ApplicationParameter;
@@ -1081,5 +1082,19 @@ public interface Context extends Container {
      */
     public String getRealPath(String path);
 
+    /**
+     * Get the Jar Scanner to be used to scan for JAR resources for this
+     * context.
+     * @return  The Jar Scanner configured for this context.
+     */
+    public JarScanner getJarScanner();
+
+    /**
+     * Set the Jar Scanner to be used to scan for JAR resources for this
+     * context.
+     * @param jarScanner    The Jar Scanner to be used for this context.
+     */
+    public void setJarScanner(JarScanner jarScanner);
+
 }
 

==================================================
ContextRuleSet.java
index d291f5d509..910861b69e 100644
--- a/java/org/apache/catalina/core/StandardContext.java
+++ b/java/org/apache/catalina/core/StandardContext.java
@@ -85,6 +85,7 @@ import org.apache.catalina.deploy.SecurityConstraint;
 import org.apache.catalina.loader.WebappLoader;
 import org.apache.catalina.session.StandardManager;
 import org.apache.catalina.startup.ContextConfig;
+import org.apache.catalina.startup.DefaultJarScanner;
 import org.apache.catalina.startup.TldConfig;
 import org.apache.catalina.util.CharsetMapper;
 import org.apache.catalina.util.ExtensionValidator;
@@ -99,6 +100,7 @@ import org.apache.naming.resources.FileDirContext;
 import org.apache.naming.resources.ProxyDirContext;
 import org.apache.naming.resources.WARDirContext;
 import org.apache.tomcat.InstanceManager;
+import org.apache.tomcat.JarScanner;
 import org.apache.tomcat.util.modeler.Registry;
 
 /**
@@ -725,12 +727,30 @@ public class StandardContext
      */
     private boolean useHttpOnly = true;
 
+    /**
+     * The Jar scanner to use to search for Jars that might contain
+     * configuration information such as TLDs or web-fragment.xml files. 
+     */
+    private JarScanner jarScanner = null;
 
 
 
     // ----------------------------------------------------- Context Properties
 
 
+    public JarScanner getJarScanner() {
+        if (jarScanner == null) {
+            jarScanner = new DefaultJarScanner();
+        }
+        return jarScanner;
+    }
+
+
+    public void setJarScanner(JarScanner jarScanner) {
+        this.jarScanner = jarScanner;
+    }
+
+     
     public InstanceManager getInstanceManager() {
        return instanceManager;
     }
@@ -4458,6 +4478,11 @@ public class StandardContext
         try {
             
             // Create context attributes that will be required
+            if (ok) {
+                getServletContext().setAttribute(
+                        JarScanner.class.getName(), getJarScanner());
+            }
+
             if (ok) {
                 postWelcomeFiles();
             }

==================================================
DefaultJarScanner.java
index 9f176e9c34..762ae73a54 100644
--- a/java/org/apache/catalina/startup/ContextRuleSet.java
+++ b/java/org/apache/catalina/startup/ContextRuleSet.java
@@ -203,6 +203,14 @@ public class ContextRuleSet extends RuleSetBase {
         digester.addCallMethod(prefix + "Context/WrapperListener",
                                "addWrapperListener", 0);
 
+        digester.addObjectCreate(prefix + "Context/JarScanner",
+                                 "org.apache.catalina.deploy.DefaultJarScanner",
+                                 "className");
+        digester.addSetProperties(prefix + "Context/JarScanner");
+        digester.addSetNext(prefix + "Context/JarScanner",
+                            "setJarScanner",
+                            "org.apache.tomcat.JarScanner");
+
     }
 
 }

==================================================
TldConfig.java
index 594f4e4c10..e69fd106df 100644
--- a/java/org/apache/catalina/startup/LocalStrings.properties
+++ b/java/org/apache/catalina/startup/LocalStrings.properties
@@ -83,20 +83,21 @@ hostConfig.stop=HostConfig: Processing STOP
 hostConfig.undeploy=Undeploying context [{0}]
 hostConfig.undeploy.error=Error undeploying web application at context path {0}
 hostConfig.undeploying=Undeploying deployed web applications
+jarScan.classloaderFail=Failed to scan [{0}] from classloader hierarchy
+jarScan.classloaderStart=Scanning for JARs in classloader hierarchy
+jarScan.jarUrlStart=Scanning JAR at URL [{0}]
+jarScan.webinflibFail=Failed to scan JAR [{0}] from WEB-INF/lib
+jarScan.webinflibStart=Scanning WEB-INF/lib for JARs
 tldConfig.addListeners=Adding {0} listeners from TLD files
 tldConfig.cce=Lifecycle event data object {0} is not a Context
-tldConfig.classloaderFail=Failed to process ''{0}'' for TLDs.
-tldConfig.classloaderStart=Scanning for TLDs in classloader hierarchy
-tldConfig.dirScan=Scanning for TLD files in directory ''{0}''
+tldConfig.dirFail=Failed to process directory [{0}] for TLD files
+tldConfig.dirScan=Scanning for TLD files in directory [{0}]
 tldConfig.execute=Error processing TLD files for context path {0}
-tldConfig.jarUrlStart=Scanning for TLD files in URL ''{0}''
-tldConfig.webinflibStart=Scanning WEB-INF/lib for JARs containing META-INF/**/*.TLD
-tldConfig.webinflibJarFail=Failed to scan JAR ''{0}'' for TLDs
-tldConfig.webinfFail=Failed to process TLD found at ''{0}''
-tldConfig.webinfScan=Scanning WEB-INF for TLD files in ''{0}''
-tldConfig.webxmlAdd=Adding path ''{0}'' for URI ''{1}''
-tldConfig.webxmlFail=Failed to process TLD with path ''{1}'' and URI ''{0}''
-tldConfig.webxmlSkip=Path ''{1}'' skipped since URI ''{0}'' is a duplicate
+tldConfig.webinfFail=Failed to process TLD found at [{0}]
+tldConfig.webinfScan=Scanning WEB-INF for TLD files in [{0}]
+tldConfig.webxmlAdd=Adding path [{0}] for URI [{1}]
+tldConfig.webxmlFail=Failed to process TLD with path [{1}] and URI [{0}]
+tldConfig.webxmlSkip=Path [{1}] skipped since URI [{0}] is a duplicate
 tldConfig.webxmlStart=Scanning <taglib> elements in web.xml
 userConfig.database=Exception loading user database
 userConfig.deploy=Deploying web application for user {0}

==================================================
JarScannerFactory.java
index 530bb71b36..1dd6d9595c 100644
--- a/java/org/apache/catalina/startup/TldConfig.java
+++ b/java/org/apache/catalina/startup/TldConfig.java
@@ -24,10 +24,6 @@ import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.JarURLConnection;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.net.URLClassLoader;
-import java.net.URLConnection;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.HashSet;
@@ -45,6 +41,8 @@ import org.apache.catalina.LifecycleEvent;
 import org.apache.catalina.LifecycleListener;
 import org.apache.catalina.core.StandardContext;
 import org.apache.catalina.core.StandardHost;
+import org.apache.tomcat.JarScanner;
+import org.apache.tomcat.JarScannerCallback;
 import org.apache.tomcat.util.res.StringManager;
 import org.apache.tomcat.util.digester.Digester;
 import org.xml.sax.InputSource;
@@ -61,27 +59,10 @@ import org.xml.sax.SAXException;
  */
 public final class TldConfig  implements LifecycleListener {
 
-    private static final String JAR_EXT = ".jar";
     private static final String TLD_EXT = ".tld";
     private static final String WEB_INF = "/WEB-INF/";
     private static final String WEB_INF_LIB = "/WEB-INF/lib/";
     
-    // Configuration properties
-    private static final boolean SCAN_CLASSPATH = Boolean.valueOf(
-            System.getProperty(
-                "org.apache.jasper.compiler.TldLocationsCache.SCAN_CLASSPATH",
-                "true")).booleanValue();
-
-    private static final boolean SCAN_ALL_FILES = Boolean.valueOf(
-            System.getProperty(
-                "org.apache.jasper.compiler.TldLocationsCache.SCAN_ALL_FILES",
-                "false")).booleanValue();
-
-    private static final boolean SCAN_ALL_DIRS = Boolean.valueOf(
-            System.getProperty(
-                "org.apache.jasper.compiler.TldLocationsCache.SCAN_ALL_DIRS",
-                "false")).booleanValue();
-
     // Names of JARs that are known not to contain any TLDs
     private static HashSet<String> noTldJars;
 
@@ -327,7 +308,18 @@ public final class TldConfig  implements LifecycleListener {
     /**
      * Scan for and configure all tag library descriptors found in this
      * web application.
+     * 
+     * This supports a Tomcat-specific extension to the TLD search
+     * order defined in the JSP spec. It allows tag libraries packaged as JAR
+     * files to be shared by web applications by simply dropping them in a 
+     * location that all web applications have access to (e.g.,
+     * <CATALINA_HOME>/lib). It also supports some of the weird and
+     * wonderful arrangements present when Tomcat gets embedded.
      *
+     * The set of shared JARs to be scanned for TLDs is narrowed down by
+     * the <tt>noTldJars</tt> class variable, which contains the names of JARs
+     * that are known not to contain any TLDs.
+     * 
      * @exception Exception if a fatal input/output or parsing error occurs
      */
     public void execute() throws Exception {
@@ -349,14 +341,12 @@ public final class TldConfig  implements LifecycleListener {
         // Stage 3a - TLDs under WEB-INF (not lib or classes)
         tldScanResourcePaths(WEB_INF);
 
-        // Stage 3b - .jar files in WEB-INF/lib/
-        tldScanWebInfLib();
+        // Stages 3b & 4
+        JarScanner jarScanner = context.getJarScanner();
+        jarScanner.scan(context.getServletContext(),
+                context.getLoader().getClassLoader(),
+                new TldJarScannerCallback(), noTldJars);
         
-        // Stage 4 - Additional entries from the container
-        if (SCAN_CLASSPATH) {
-            tldScanClassloaders();
-        }
-
         // Now add all the listeners we found to the listeners for this context
         String list[] = getTldListeners();
 
@@ -375,6 +365,22 @@ public final class TldConfig  implements LifecycleListener {
 
     }
 
+    private class TldJarScannerCallback implements JarScannerCallback {
+
+        @Override
+        public void scan(JarURLConnection urlConn) throws IOException {
+            tldScanJar(urlConn);
+        }
+
+        @Override
+        public void scan(File file) {
+            File metaInf = new File(file, "META-INF");
+            if (metaInf.isDirectory()) {
+                tldScanDir(metaInf);
+            }
+        }
+    }
+
     // -------------------------------------------------------- Private Methods
 
 
@@ -477,136 +483,6 @@ public final class TldConfig  implements LifecycleListener {
         }
     }
     
-    /*
-     * Scan the JARs in the WEB-INF/lib directory. Skip the JARs known not to
-     * have any TLDs in them.
-     * 
-     * Keep in sync with o.a.j.comiler.TldLocationsCache
-     */
-    private void tldScanWebInfLib() {
-
-        if (log.isTraceEnabled()) {
-            log.trace(sm.getString("tldConfig.webinflibStart"));
-        }
-        ServletContext ctxt = context.getServletContext();
-        
-        Set<String> dirList = ctxt.getResourcePaths(WEB_INF_LIB);
-        if (dirList != null) {
-            Iterator<String> it = dirList.iterator();
-            while (it.hasNext()) {
-                String path = it.next();
-                if (path.endsWith(JAR_EXT) &&
-                        !noTldJars.contains(
-                                path.substring(path.lastIndexOf('/')))) {
-                    // Need to scan this JAR for TLDs
-                    URL url = null;
-                    try {
-                        url = ctxt.getResource(path);
-                        tldScanJar(url);
-                    } catch (IOException e) {
-                        log.warn(sm.getString("tldConfig.webinflibJarFail"), e);
-                    }
-                }
-            }
-        }
-    }
-
-    /*
-     * Scan the classloader hierarchy for JARs and, optionally, for JARs where
-     * the name doesn't end in .jar and directories that represent exploded
-     * JARs. The JARs under WEB-INF/lib will be skipped as they have been
-     * scanned previously.
-     *
-     * This represents a Tomcat-specific extension to the TLD search
-     * order defined in the JSP spec. It allows tag libraries packaged as JAR
-     * files to be shared by web applications by simply dropping them in a 
-     * location that all web applications have access to (e.g.,
-     * <CATALINA_HOME>/lib). It also supports some of the weird and
-     * wonderful arrangements present when Tomcat gets embedded.
-     *
-     * The set of shared JARs to be scanned for TLDs is narrowed down by
-     * the <tt>noTldJars</tt> class variable, which contains the names of JARs
-     * that are known not to contain any TLDs.
-     * 
-     * Keep in sync with o.a.j.comiler.TldLocationsCache
-     */
-    private void tldScanClassloaders() {
-
-        if (log.isTraceEnabled()) {
-            log.trace(sm.getString("tldConfig.classloaderStart"));
-        }
-
-        ClassLoader loader = 
-            Thread.currentThread().getContextClassLoader();
-        
-        while (loader != null) {
-            if (loader instanceof URLClassLoader) {
-                URL[] urls = ((URLClassLoader) loader).getURLs();
-                for (int i=0; i<urls.length; i++) {
-                    // Extract the jarName if there is one to be found
-                    String jarName = getJarName(urls[i]);
-                    
-                    // Skip JARs with known not to contain TLDs and JARs in
-                    // WEB-INF/lib we have already scanned
-                    if (!(noTldJars.contains(jarName) ||
-                            urls[i].toString().contains(
-                                    WEB_INF_LIB + jarName))) {
-                        try {
-                            tldScanJar(urls[i]);
-                        } catch (IOException ioe) {
-                            log.warn(sm.getString(
-                                    "tldConfig.classloaderFail",urls[i]), ioe);
-                        }
-                    }
-                }
-            }
-            loader = loader.getParent();
-        }
-    }
-
-    /*
-     * Keep in sync with o.a.j.comiler.TldLocationsCache
-     */
-    private void tldScanJar(URL url) throws IOException {
-        if (log.isTraceEnabled()) {
-            log.trace(sm.getString("tldConfig.jarUrlStart", url));
-        }
-
-        URLConnection conn = url.openConnection();
-        if (conn instanceof JarURLConnection) {
-            tldScanJar((JarURLConnection) conn);
-        } else {
-            String urlStr = url.toString();
-            if (urlStr.startsWith("file:")) {
-                if (urlStr.endsWith(JAR_EXT)) {
-                    URL jarURL = new URL("jar:" + urlStr + "!/");
-                    tldScanJar((JarURLConnection) jarURL.openConnection());
-                } else {
-                    File f;
-                    try {
-                        f = new File(url.toURI());
-                        if (f.isFile() && SCAN_ALL_FILES) {
-                            // Treat this file as a JAR
-                            URL jarURL = new URL("jar:" + urlStr + "!/");
-                            tldScanJar((JarURLConnection) jarURL.openConnection());
-                        } else if (f.isDirectory() && SCAN_ALL_DIRS) {
-                            File metainf = new File(f.getAbsoluteFile() +
-                                    File.separator + "META-INF");
-                            if (metainf.isDirectory()) {
-                                tldScanDir(metainf);
-                            }
-                        }
-                    } catch (URISyntaxException e) {
-                        // Wrap the exception and re-throw
-                        IOException ioe = new IOException();
-                        ioe.initCause(e);
-                        throw ioe;
-                    }
-                }
-            }
-        }
-    }
-
     /*
      * Scans the directory identified by startPath, along with its
      * sub-directories, for TLDs.
@@ -683,25 +559,6 @@ public final class TldConfig  implements LifecycleListener {
     }
 
 
-    /*
-     * Extract the JAR name, if present, from a URL
-     * 
-     * Keep in sync with o.a.j.comiler.TldLocationsCache
-     */
-    private String getJarName(URL url) {
-        
-        String name = null;
-        
-        String path = url.getPath();
-        int end = path.indexOf(JAR_EXT);
-        if (end != -1) {
-            int start = path.lastIndexOf('/', end);
-            name = path.substring(start + 1, end + 4);
-        }
-        
-        return name;
-    }
-
     /*
      * Scan the TLD contents in the specified input stream, and register
      * any application event listeners found there.  <b>NOTE</b> - This 
@@ -779,4 +636,5 @@ public final class TldConfig  implements LifecycleListener {
             tldDigester = createTldDigester(tldNamespaceAware, tldValidation);
         }
     }
+
 }

==================================================
TldLocationsCache.java
new file mode 100644
index 0000000000..d7f1664fac
--- /dev/null
+++ b/java/org/apache/jasper/compiler/JarScannerFactory.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+
+package org.apache.jasper.compiler;
+
+import javax.servlet.ServletContext;
+
+import org.apache.tomcat.JarScanner;
+
+/**
+ * Provide a mechanism for Jasper to obtain a reference to the JarScanner
+ * impementation.
+ */
+public class JarScannerFactory {
+
+    /*
+     * Don't want any instances so hide the default constructor.
+     */
+    private JarScannerFactory() {
+    }
+
+    /**
+     * Obtain the {@link JarScanner} associated with the specificed {@link
+     * ServletContext}. It is obtained via a context parameter.
+     */
+    public static JarScanner getJarScanner(ServletContext ctxt) {
+        JarScanner jarScanner = 
+        	(JarScanner) ctxt.getAttribute(JarScanner.class.getName());
+        if (jarScanner == null) {
+            ctxt.log(Localizer.getMessage("jsp.warning.noJarScanner"));
+        }
+        return jarScanner;
+    }
+
+}

==================================================
JarScanner.java
index 2b8bab4859..29b5cba5a2 100644
--- a/java/org/apache/jasper/resources/LocalStrings.properties
+++ b/java/org/apache/jasper/resources/LocalStrings.properties
@@ -454,3 +454,6 @@ jsp.error.page.invalid.trimdirectivewhitespaces=Page directive: invalid value fo
 jsp.error.tag.invalid.trimdirectivewhitespaces=Tag directive: invalid value for trimDirectiveWhitespaces
 jsp.error.page.conflict.trimdirectivewhitespaces=Page directive: illegal to have multiple occurrences of 'trimDirectiveWhitespaces' with different values (old: {0}, new: {1})
 jsp.error.tag.conflict.trimdirectivewhitespaces=Tag directive: illegal to have multiple occurrences of 'trimDirectiveWhitespaces' with different values (old: {0}, new: {1})
+
+# JarScanner
+jsp.warning.noJarScanner=Warning: No org.apache.tomcat.JarScanner set in ServletContext. Jar scanning for TLDs and web-fragment.xml files is disabled
\ No newline at end of file

==================================================
JarScannerCallback.java
new file mode 100644
index 0000000000..978b725936
--- /dev/null
+++ b/java/org/apache/tomcat/JarScanner.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+
+package org.apache.tomcat;
+
+import java.util.Set;
+
+import javax.servlet.ServletContext;
+
+/**
+ * Scans a web application and classloader hierarchy for JAR files. Uses
+ * include TLD scanning and web-fragment.xml scanning. Uses a call-back
+ * mechanism so the caller can process each JAR found. 
+ */
+public interface JarScanner {
+
+    /**
+     * Scan the provided ServletContext and classloader for JAR files. Each JAR
+     * file found will be passed to the callback handler to be processed.
+     *  
+     * @param context       The ServletContext - used to locate and access
+     *                      WEB-INF/lib
+     * @param classloader   The classloader - used to access JARs not in
+     *                      WEB-INF/lib
+     * @param callback      The handler to process any JARs found
+     * @param jarsToSkip    List of JARs to ignore
+     */
+    public void scan(ServletContext context, ClassLoader classloader,
+            JarScannerCallback callback, Set<String> jarsToSkip);
+    
+}

==================================================
