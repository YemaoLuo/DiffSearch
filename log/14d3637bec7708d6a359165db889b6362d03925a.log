14d3637bec7708d6a359165db889b6362d03925a
==================================================
Implement new allocation algorithm
==================================================
Mark Thomas
==================================================
Wed Dec 7 11:14:46 2022 +0000
==================================================
AbstractNonZeroStream.java
Implement new allocation algorithm

Currently using defaults as priorities aren't read yet.



==================================================
AbstractStream.java
index 0876fc88c6..5a9c3e3a48 100644
--- a/java/org/apache/coyote/http2/AbstractNonZeroStream.java
+++ b/java/org/apache/coyote/http2/AbstractNonZeroStream.java
@@ -17,7 +17,6 @@
 package org.apache.coyote.http2;
 
 import java.nio.ByteBuffer;
-import java.util.Iterator;
 
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
@@ -36,8 +35,6 @@ abstract class AbstractNonZeroStream extends AbstractStream {
 
     protected final StreamStateMachine state;
 
-    private volatile int weight = Constants.DEFAULT_WEIGHT;
-
 
     AbstractNonZeroStream(String connectionId, Integer identifier) {
         super(identifier);
@@ -51,12 +48,6 @@ abstract class AbstractNonZeroStream extends AbstractStream {
     }
 
 
-    @Override
-    final int getWeight() {
-        return weight;
-    }
-
-
     /*
      * General method used when reprioritising a stream and care needs to be
      * taken not to create circular references.
@@ -71,27 +62,7 @@ abstract class AbstractNonZeroStream extends AbstractStream {
                     parent.getIdAsString(), Integer.toString(weight)));
         }
 
-        // Check if new parent is a descendant of this stream
-        if (isDescendant(parent)) {
-            parent.detachFromParent();
-            // Cast is always safe since any descendant of this stream must be
-            // an instance of AbstractNonZeroStream
-            getParentStream().addChild((AbstractNonZeroStream) parent);
-        }
-
-        if (exclusive) {
-            // Need to move children of the new parent to be children of this
-            // stream. Slightly convoluted to avoid concurrent modification.
-            Iterator<AbstractNonZeroStream> parentsChildren = parent.getChildStreams().iterator();
-            while (parentsChildren.hasNext()) {
-                AbstractNonZeroStream parentsChild = parentsChildren.next();
-                parentsChildren.remove();
-                this.addChild(parentsChild);
-            }
-        }
-        detachFromParent();
-        parent.addChild(this);
-        this.weight = weight;
+        // TODO
     }
 
 
@@ -109,29 +80,7 @@ abstract class AbstractNonZeroStream extends AbstractStream {
                     parent.getIdAsString(), Integer.toString(weight)));
         }
 
-        parent.addChild(this);
-        this.weight = weight;
-    }
-
-
-    /*
-     * Used when "recycling" a stream and replacing a Stream instance with a
-     * RecycledStream instance.
-     *
-     * Replace this stream with the provided stream in the parent/child
-     * hierarchy.
-     *
-     * Changes to the priority tree need to be synchronized at the connection
-     * level. This is the caller's responsibility.
-     */
-    void replaceStream(AbstractNonZeroStream replacement) {
-        getParentStream().addChild(replacement);
-        detachFromParent();
-        for (AbstractNonZeroStream child : getChildStreams()) {
-            replacement.addChild(child);
-        }
-        getChildStreams().clear();
-        replacement.weight = weight;
+        // TODO
     }
 
 

==================================================
Constants.java
index dc651d30e9..d3533c5bd8 100644
--- a/java/org/apache/coyote/http2/AbstractStream.java
+++ b/java/org/apache/coyote/http2/AbstractStream.java
@@ -16,9 +16,6 @@
  */
 package org.apache.coyote.http2;
 
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.res.StringManager;
@@ -35,8 +32,6 @@ abstract class AbstractStream {
     private final Integer identifier;
     private final String idAsString;
 
-    private volatile AbstractStream parentStream = null;
-    private final Set<AbstractNonZeroStream> childStreams = ConcurrentHashMap.newKeySet();
     private long windowSize = ConnectionSettingsBase.DEFAULT_INITIAL_WINDOW_SIZE;
 
     private volatile int connectionAllocationRequested = 0;
@@ -64,46 +59,6 @@ abstract class AbstractStream {
     }
 
 
-    final void detachFromParent() {
-        if (parentStream != null) {
-            parentStream.getChildStreams().remove(this);
-            parentStream = null;
-        }
-    }
-
-
-    final void addChild(AbstractNonZeroStream child) {
-        child.setParentStream(this);
-        childStreams.add(child);
-    }
-
-
-    final boolean isDescendant(AbstractStream stream) {
-        // Is the passed in Stream a descendant of this Stream?
-        // Start at the passed in Stream and work up
-        AbstractStream parent = stream.getParentStream();
-        while (parent != null && parent != this) {
-            parent = parent.getParentStream();
-        }
-        return parent != null;
-    }
-
-
-    final AbstractStream getParentStream() {
-        return parentStream;
-    }
-
-
-    final void setParentStream(AbstractStream parentStream) {
-        this.parentStream = parentStream;
-    }
-
-
-    final Set<AbstractNonZeroStream> getChildStreams() {
-        return childStreams;
-    }
-
-
     final synchronized void setWindowSize(long windowSize) {
         this.windowSize = windowSize;
     }
@@ -181,6 +136,4 @@ abstract class AbstractStream {
 
 
     abstract String getConnectionId();
-
-    abstract int getWeight();
 }

==================================================
Http2UpgradeHandler.java
index 739ae7eb12..e1ee63bb34 100644
--- a/java/org/apache/coyote/http2/Constants.java
+++ b/java/org/apache/coyote/http2/Constants.java
@@ -19,7 +19,11 @@ package org.apache.coyote.http2;
 public class Constants {
 
     // Prioritisation
-    public static final int DEFAULT_WEIGHT = 16;
+    public static final int DEFAULT_URGENCY = 3;
+    public static final boolean DEFAULT_INCREMENTAL = false;
+    // Range 0 to 7 inclusive
+    public static final int URGENCY_RANGE = 8;
+
 
     // Parsing
     static final int DEFAULT_HEADER_READ_BUFFER_SIZE = 1024;

==================================================
Stream.java
index d0713e931a..ec4c7612ba 100644
--- a/java/org/apache/coyote/http2/LocalStrings_zh_CN.properties
+++ b/java/org/apache/coyote/http2/LocalStrings_zh_CN.properties
@@ -126,7 +126,6 @@ streamStateMachine.invalidFrame=连接{0}、流{1}、状态{2}、帧类型{3}
 
 upgradeHandler.allocate.debug=连接[{0}]，流[{1}]，已分配[{2}]字节
 upgradeHandler.allocate.left=连接[{0}]，流[{1}]，[{2}]字节未分配 - 尝试分配给子项
-upgradeHandler.allocate.recipient=(:连接[{0}]，流[{1}]，潜在接收者[{2}]，权重为[{3}]
 upgradeHandler.connectionError=连接错误
 upgradeHandler.goaway.debug=连接[{0}]，离开，最后的流[{1}]，错误码[{2}]，调试数据[{3}]
 upgradeHandler.init=连接[{0}]，状态[{1}]
@@ -141,7 +140,6 @@ upgradeHandler.prefaceReceived=连接[{0}]，从客户端收到连接准备。
 upgradeHandler.pruneIncomplete=连接[{0}]，流[{1}]，无法完全修剪连接，因为有[{2}]个活动流太多
 upgradeHandler.pruneStart=连接[{0}]正在开始修剪旧流。限制为[{1}]，当前有[{2}]个流。
 upgradeHandler.pruned=连接[{0}]已修剪完成的流[{1}]
-upgradeHandler.prunedPriority=连接[{0}]已经成为了属于优先级树中未使用的流[{1}]
 upgradeHandler.releaseBacklog=连接[{0}]，流[{1}]已从待办事项列表中释放
 upgradeHandler.reset.receive=连接[{0}],流[{1}],由于[{2}]而重置
 upgradeHandler.rst.debug=连接[{0}]，流[{1}]，错误[{2}]，消息[{3}]，RST（关闭流）

==================================================
