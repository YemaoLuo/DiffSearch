baba920c234359e1e0f82d60be6c0a279679ce8c
==================================================
Drop panama-foreign
==================================================
remm remm@apache.org
==================================================
Mon Nov 8 11:33:01 2021 +0100
==================================================
Asn1Parser.java
deleted file mode 100644
index 89088d7784..0000000000
--- a/modules/openssl-panama-foreign/pom.xml
+++ /dev/null
@@ -1,72 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one or more
-    contributor license agreements. See the NOTICE file distributed with
-    this work for additional information regarding copyright ownership.
-    The ASF licenses this file to You under the Apache License, Version
-    2.0 (the "License"); you may not use this file except in compliance
-    with the License. You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0 Unless required by
-    applicable law or agreed to in writing, software distributed under the
-    License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
-    CONDITIONS OF ANY KIND, either express or implied. See the License for
-    the specific language governing permissions and limitations under the
-    License.
--->
-
-    <modelVersion>4.0.0</modelVersion>
-
-    <parent>
-        <groupId>org.apache</groupId>
-        <artifactId>apache</artifactId>
-        <version>23</version>
-    </parent>
-
-    <groupId>org.apache.tomcat</groupId>
-    <artifactId>tomcat-openssl</artifactId>
-    <name>Apache Tomcat OpenSSL support for Panama</name>
-    <description>OpenSSL support using the Panama API</description>
-    <!-- This is the Apache OpenWebBeans version -->
-    <version>0.1</version>
-    <packaging>jar</packaging>
-
-    <properties>
-        <tomcat.version>10.0.12</tomcat.version>
-    </properties>
-
-    <dependencies>
-        <dependency>
-            <groupId>org.apache.tomcat</groupId>
-            <artifactId>tomcat-catalina</artifactId>
-            <version>${tomcat.version}</version>
-            <scope>provided</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.apache.tomcat</groupId>
-            <artifactId>tomcat-coyote</artifactId>
-            <version>${tomcat.version}</version>
-            <scope>provided</scope>
-        </dependency>
-    </dependencies>
-
-    <build>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.8.1</version>
-                <configuration>
-                    <source>17</source>
-                    <target>17</target>
-                    <compilerArgs>
-                        <arg>--add-modules</arg>
-                        <arg>jdk.incubator.foreign</arg>
-                    </compilerArgs>
-                </configuration>
-            </plugin>
-        </plugins>
-    </build>
-
-</project>

==================================================
OpenSSLContext.java
deleted file mode 100644
index ec32d48f72..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/Asn1Parser.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.net.openssl.panama;
-
-import java.math.BigInteger;
-
-import org.apache.tomcat.util.res.StringManager;
-
-/**
- * This is a very basic ASN.1 parser that provides the limited functionality
- * required by Tomcat. It is a long way from a complete parser.
- *
- * TODO: Consider extending this parser and refactoring the SpnegoTokenFixer to
- *       use it.
- */
-public class Asn1Parser {
-
-    private static final StringManager sm = StringManager.getManager(Asn1Parser.class);
-
-    private final byte[] source;
-
-    private int pos = 0;
-
-
-    public Asn1Parser(byte[] source) {
-        this.source = source;
-    }
-
-
-    public boolean eof() {
-        return pos == source.length;
-    }
-
-
-    public int peekTag() {
-        return source[pos] & 0xFF;
-    }
-
-
-    public void parseTag(int tag) {
-        int value = next();
-        if (value != tag) {
-            throw new IllegalArgumentException(sm.getString("asn1Parser.tagMismatch",
-                    Integer.valueOf(tag), Integer.valueOf(value)));
-        }
-    }
-
-
-    public void parseFullLength() {
-        int len = parseLength();
-        if (len + pos != source.length) {
-            throw new IllegalArgumentException(sm.getString("asn1Parser.lengthInvalid",
-                    Integer.valueOf(len), Integer.valueOf(source.length - pos)));
-        }
-    }
-
-
-    public int parseLength() {
-        int len = next();
-        if (len > 127) {
-            int bytes = len - 128;
-            len = 0;
-            for (int i = 0; i < bytes; i++) {
-                len = len << 8;
-                len = len + next();
-            }
-        }
-        return len;
-    }
-
-
-    public BigInteger parseInt() {
-        parseTag(0x02);
-        int len = parseLength();
-        byte[] val = new byte[len];
-        System.arraycopy(source, pos, val, 0, len);
-        pos += len;
-        return new BigInteger(val);
-    }
-
-
-    public void parseBytes(byte[] dest) {
-        System.arraycopy(source, pos, dest, 0, dest.length);
-        pos += dest.length;
-    }
-
-
-    private int next() {
-        return source[pos++] & 0xFF;
-    }
-}

==================================================
OpenSSLEngine.java
deleted file mode 100644
index 27b9efc0b8..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLContext.java
+++ /dev/null
@@ -1,1498 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.net.openssl.panama;
-
-import jdk.incubator.foreign.Addressable;
-import jdk.incubator.foreign.CLinker;
-import jdk.incubator.foreign.FunctionDescriptor;
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.NativeSymbol;
-import jdk.incubator.foreign.ResourceScope;
-import jdk.incubator.foreign.SegmentAllocator;
-import jdk.incubator.foreign.ValueLayout;
-
-import static org.apache.tomcat.util.openssl.openssl_h.*;
-
-import java.io.File;
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodHandles;
-import java.lang.invoke.MethodType;
-import java.lang.ref.Cleaner;
-import java.lang.ref.Cleaner.Cleanable;
-import java.nio.charset.StandardCharsets;
-import java.security.PrivateKey;
-import java.security.SecureRandom;
-import java.security.cert.CertificateException;
-import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Base64;
-import java.util.Iterator;
-import java.util.List;
-
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.SSLEngine;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLParameters;
-import javax.net.ssl.SSLServerSocketFactory;
-import javax.net.ssl.SSLSessionContext;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509KeyManager;
-import javax.net.ssl.X509TrustManager;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.net.AbstractEndpoint;
-import org.apache.tomcat.util.net.Constants;
-import org.apache.tomcat.util.net.SSLHostConfig;
-import org.apache.tomcat.util.net.SSLHostConfig.CertificateVerification;
-import org.apache.tomcat.util.net.SSLHostConfigCertificate;
-import org.apache.tomcat.util.net.SSLHostConfigCertificate.Type;
-import org.apache.tomcat.util.net.openssl.OpenSSLConf;
-import org.apache.tomcat.util.net.openssl.OpenSSLConfCmd;
-import org.apache.tomcat.util.res.StringManager;
-
-public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
-
-    private static final Log log = LogFactory.getLog(OpenSSLContext.class);
-
-    private static final StringManager netSm = StringManager.getManager(AbstractEndpoint.class);
-    private static final StringManager sm = StringManager.getManager(OpenSSLContext.class);
-
-    private static final String defaultProtocol = "TLS";
-
-    private static final int SSL_AIDX_RSA     = 0;
-    private static final int SSL_AIDX_DSA     = 1;
-    private static final int SSL_AIDX_ECC     = 3;
-    private static final int SSL_AIDX_MAX     = 4;
-
-    public static final int SSL_PROTOCOL_NONE  = 0;
-    public static final int SSL_PROTOCOL_SSLV2 = (1<<0);
-    public static final int SSL_PROTOCOL_SSLV3 = (1<<1);
-    public static final int SSL_PROTOCOL_TLSV1 = (1<<2);
-    public static final int SSL_PROTOCOL_TLSV1_1 = (1<<3);
-    public static final int SSL_PROTOCOL_TLSV1_2 = (1<<4);
-    public static final int SSL_PROTOCOL_TLSV1_3 = (1<<5);
-    public static final int SSL_PROTOCOL_ALL = (SSL_PROTOCOL_TLSV1 | SSL_PROTOCOL_TLSV1_1 | SSL_PROTOCOL_TLSV1_2 |
-            SSL_PROTOCOL_TLSV1_3);
-
-    private static final String BEGIN_KEY = "-----BEGIN PRIVATE KEY-----\n";
-    private static final Object END_KEY = "\n-----END PRIVATE KEY-----";
-
-    private static final byte[] HTTP_11_PROTOCOL =
-            new byte[] { 'h', 't', 't', 'p', '/', '1', '.', '1' };
-
-    private static final byte[] DEFAULT_SESSION_ID_CONTEXT =
-            new byte[] { 'd', 'e', 'f', 'a', 'u', 'l', 't' };
-
-    static final CertificateFactory X509_CERT_FACTORY;
-    static {
-        try {
-            X509_CERT_FACTORY = CertificateFactory.getInstance("X.509");
-        } catch (CertificateException e) {
-            throw new IllegalStateException(sm.getString("openssl.X509FactoryError"), e);
-        }
-    }
-
-    private static final MethodHandle openSSLCallbackVerifyHandle;
-    private static final MethodHandle openSSLCallbackPasswordHandle;
-    private static final MethodHandle openSSLCallbackCertVerifyHandle;
-    private static final MethodHandle openSSLCallbackAlpnSelectProtoHandle;
-    private static final MethodHandle openSSLCallbackTmpDHHandle;
-
-    private static final FunctionDescriptor openSSLCallbackVerifyFunctionDescriptor =
-            FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.ADDRESS);
-    private static final FunctionDescriptor openSSLCallbackPasswordFunctionDescriptor =
-            FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.JAVA_INT,
-            ValueLayout.JAVA_INT, ValueLayout.ADDRESS);
-    private static final FunctionDescriptor openSSLCallbackCertVerifyFunctionDescriptor =
-            FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.ADDRESS);
-    private static final FunctionDescriptor openSSLCallbackAlpnSelectProtoFunctionDescriptor =
-            FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS,
-            ValueLayout.ADDRESS, ValueLayout.ADDRESS, ValueLayout.ADDRESS,
-            ValueLayout.JAVA_INT, ValueLayout.ADDRESS);
-    private static final FunctionDescriptor openSSLCallbackTmpDHFunctionDescriptor =
-            FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.ADDRESS,
-            ValueLayout.JAVA_INT, ValueLayout.JAVA_INT);
-
-    static {
-        MethodHandles.Lookup lookup = MethodHandles.lookup();
-        try {
-            openSSLCallbackVerifyHandle = lookup.findVirtual(OpenSSLContext.class, "openSSLCallbackVerify",
-                    MethodType.methodType(int.class, int.class, MemoryAddress.class));
-            openSSLCallbackPasswordHandle = lookup.findVirtual(OpenSSLContext.class, "openSSLCallbackPassword",
-                    MethodType.methodType(int.class, MemoryAddress.class, int.class, int.class, MemoryAddress.class));
-            openSSLCallbackCertVerifyHandle = lookup.findVirtual(OpenSSLContext.class, "openSSLCallbackCertVerify",
-                    MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));
-            openSSLCallbackAlpnSelectProtoHandle = lookup.findVirtual(OpenSSLContext.class, "openSSLCallbackAlpnSelectProto",
-                    MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class,
-                            MemoryAddress.class, MemoryAddress.class, int.class, MemoryAddress.class));
-            openSSLCallbackTmpDHHandle = lookup.findVirtual(OpenSSLContext.class, "openSSLCallbackTmpDH",
-                    MethodType.methodType(Addressable.class, MemoryAddress.class, int.class, int.class));
-        } catch (Exception e) {
-            throw new IllegalStateException(e);
-        }
-    }
-
-    /*
-    { BN_get_rfc3526_prime_8192, NULL, 6145 },
-    { BN_get_rfc3526_prime_6144, NULL, 4097 },
-    { BN_get_rfc3526_prime_4096, NULL, 3073 },
-    { BN_get_rfc3526_prime_3072, NULL, 2049 },
-    { BN_get_rfc3526_prime_2048, NULL, 1025 },
-    { BN_get_rfc2409_prime_1024, NULL, 0 }
-     */
-    private static final class DHParam {
-        private final MemoryAddress dh;
-        private final int min;
-        private DHParam(MemoryAddress dh, int min) {
-            this.dh = dh;
-            this.min = min;
-        }
-    }
-    private static final DHParam[] dhParameters = new DHParam[6];
-
-    static {
-
-        OpenSSLLifecycleListener.initLibrary();
-
-        var dh = DH_new();
-        var p = BN_get_rfc3526_prime_8192(MemoryAddress.NULL);
-        var g = BN_new();
-        BN_set_word(g, 2);
-        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
-        dhParameters[0] = new DHParam(dh, 6145);
-        dh = DH_new();
-        p = BN_get_rfc3526_prime_6144(MemoryAddress.NULL);
-        g = BN_new();
-        BN_set_word(g, 2);
-        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
-        dhParameters[1] = new DHParam(dh, 4097);
-        dh = DH_new();
-        p = BN_get_rfc3526_prime_4096(MemoryAddress.NULL);
-        g = BN_new();
-        BN_set_word(g, 2);
-        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
-        dhParameters[2] = new DHParam(dh, 3073);
-        dh = DH_new();
-        p = BN_get_rfc3526_prime_3072(MemoryAddress.NULL);
-        g = BN_new();
-        BN_set_word(g, 2);
-        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
-        dhParameters[3] = new DHParam(dh, 2049);
-        dh = DH_new();
-        p = BN_get_rfc3526_prime_2048(MemoryAddress.NULL);
-        g = BN_new();
-        BN_set_word(g, 2);
-        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
-        dhParameters[4] = new DHParam(dh, 1025);
-        dh = DH_new();
-        p = BN_get_rfc2409_prime_1024(MemoryAddress.NULL);
-        g = BN_new();
-        BN_set_word(g, 2);
-        DH_set0_pqg(dh, p, MemoryAddress.NULL, g);
-        dhParameters[5] = new DHParam(dh, 0);
-    }
-
-    private static final Cleaner cleaner = Cleaner.create();
-
-    private final SSLHostConfig sslHostConfig;
-    private final SSLHostConfigCertificate certificate;
-    private final List<String> negotiableProtocols;
-
-    private int certificateVerifyMode = -1;
-
-    private OpenSSLSessionContext sessionContext;
-    private X509TrustManager x509TrustManager;
-    private String enabledProtocol;
-    private boolean initialized = false;
-
-    private boolean noOcspCheck = false;
-
-    // Password callback
-    private final NativeSymbol openSSLCallbackPassword;
-
-    private final OpenSSLState state;
-    private final Cleanable cleanable;
-
-    private static String[] getCiphers(MemoryAddress sslCtx) {
-        MemoryAddress sk = SSL_CTX_get_ciphers(sslCtx);
-        int len = OPENSSL_sk_num(sk);
-        if (len <= 0) {
-            return null;
-        }
-        ArrayList<String> ciphers = new ArrayList<>(len);
-        for (int i = 0; i < len; i++) {
-            MemoryAddress cipher = OPENSSL_sk_value(sk, i);
-            MemoryAddress cipherName = SSL_CIPHER_get_name(cipher);
-            ciphers.add(cipherName.getUtf8String(0));
-        }
-        return ciphers.toArray(new String[0]);
-    }
-
-    public OpenSSLContext(SSLHostConfigCertificate certificate, List<String> negotiableProtocols)
-            throws SSLException {
-
-        // Check that OpenSSL was initialized
-        if (!OpenSSLStatus.isInitialized()) {
-            try {
-                OpenSSLLifecycleListener.init();
-            } catch (Exception e) {
-                throw new SSLException(e);
-            }
-        }
-
-        this.sslHostConfig = certificate.getSSLHostConfig();
-        this.certificate = certificate;
-        ResourceScope scope = ResourceScope.newSharedScope();
-
-        MemoryAddress ctx = MemoryAddress.NULL;
-        MemoryAddress cctx = MemoryAddress.NULL;
-        boolean success = false;
-        try {
-            // Create OpenSSLConfCmd context if used
-            OpenSSLConf openSslConf = sslHostConfig.getOpenSslConf();
-            if (openSslConf != null) {
-                var allocator = SegmentAllocator.nativeAllocator(scope);
-                try {
-                    if (log.isDebugEnabled()) {
-                        log.debug(sm.getString("openssl.makeConf"));
-                    }
-                    cctx = SSL_CONF_CTX_new();
-                    long errCode = ERR_get_error();
-                    if (errCode != 0) {
-                        var buf = allocator.allocateArray(ValueLayout.JAVA_BYTE, new byte[128]);
-                        ERR_error_string(errCode, buf);
-                        log.error(sm.getString("openssl.errorLoadingCertificate", buf.getUtf8String(0)));
-                    }
-                    SSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_FILE() |
-                            SSL_CONF_FLAG_SERVER() |
-                            SSL_CONF_FLAG_CERTIFICATE() |
-                            SSL_CONF_FLAG_SHOW_ERRORS());
-                } catch (Exception e) {
-                    throw new SSLException(sm.getString("openssl.errMakeConf"), e);
-                }
-            }
-
-            // SSL protocol
-            ctx = SSL_CTX_new(TLS_server_method());
-
-            int protocol = SSL_PROTOCOL_NONE;
-            for (String enabledProtocol : sslHostConfig.getEnabledProtocols()) {
-                if (Constants.SSL_PROTO_SSLv2Hello.equalsIgnoreCase(enabledProtocol)) {
-                    // NO-OP. OpenSSL always supports SSLv2Hello
-                } else if (Constants.SSL_PROTO_SSLv2.equalsIgnoreCase(enabledProtocol)) {
-                    protocol |= SSL_PROTOCOL_SSLV2;
-                } else if (Constants.SSL_PROTO_SSLv3.equalsIgnoreCase(enabledProtocol)) {
-                    protocol |= SSL_PROTOCOL_SSLV3;
-                } else if (Constants.SSL_PROTO_TLSv1.equalsIgnoreCase(enabledProtocol)) {
-                    protocol |= SSL_PROTOCOL_TLSV1;
-                } else if (Constants.SSL_PROTO_TLSv1_1.equalsIgnoreCase(enabledProtocol)) {
-                    protocol |= SSL_PROTOCOL_TLSV1_1;
-                } else if (Constants.SSL_PROTO_TLSv1_2.equalsIgnoreCase(enabledProtocol)) {
-                    protocol |= SSL_PROTOCOL_TLSV1_2;
-                } else if (Constants.SSL_PROTO_TLSv1_3.equalsIgnoreCase(enabledProtocol)) {
-                    protocol |= SSL_PROTOCOL_TLSV1_3;
-                } else if (Constants.SSL_PROTO_ALL.equalsIgnoreCase(enabledProtocol)) {
-                    protocol |= SSL_PROTOCOL_ALL;
-                } else {
-                    // Should not happen since filtering to build
-                    // enabled protocols removes invalid values.
-                    throw new Exception(netSm.getString(
-                            "endpoint.apr.invalidSslProtocol", enabledProtocol));
-                }
-            }
-            // Set maximum and minimum protocol versions
-            int prot = SSL2_VERSION();
-            if ((protocol & SSL_PROTOCOL_TLSV1_3) > 0) {
-                prot = TLS1_3_VERSION();
-            } else if ((protocol & SSL_PROTOCOL_TLSV1_2) > 0) {
-                prot = TLS1_2_VERSION();
-            } else if ((protocol & SSL_PROTOCOL_TLSV1_1) > 0) {
-                prot = TLS1_1_VERSION();
-            } else if ((protocol & SSL_PROTOCOL_TLSV1) > 0) {
-                prot = TLS1_VERSION();
-            } else if ((protocol & SSL_PROTOCOL_SSLV3) > 0) {
-                prot = SSL3_VERSION();
-            }
-            // # define SSL_CTX_set_max_proto_version(ctx, version) \
-            //          SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_PROTO_VERSION, version, NULL)
-            SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_PROTO_VERSION(), prot, MemoryAddress.NULL);
-            if (prot == TLS1_3_VERSION() && (protocol & SSL_PROTOCOL_TLSV1_2) > 0) {
-                prot = TLS1_2_VERSION();
-            }
-            if (prot == TLS1_2_VERSION() && (protocol & SSL_PROTOCOL_TLSV1_1) > 0) {
-                prot = TLS1_1_VERSION();
-            }
-            if (prot == TLS1_1_VERSION() && (protocol & SSL_PROTOCOL_TLSV1) > 0) {
-                prot = TLS1_VERSION();
-            }
-            if (prot == TLS1_VERSION() && (protocol & SSL_PROTOCOL_SSLV3) > 0) {
-                prot = SSL3_VERSION();
-            }
-            //# define SSL_CTX_set_min_proto_version(ctx, version) \
-            //         SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MIN_PROTO_VERSION, version, NULL)
-            SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MIN_PROTO_VERSION(), prot, MemoryAddress.NULL);
-
-            // Disable compression, usually unsafe
-            SSL_CTX_set_options(ctx, SSL_OP_NO_COMPRESSION());
-
-            // Disallow a session from being resumed during a renegotiation,
-            // so that an acceptable cipher suite can be negotiated.
-            SSL_CTX_set_options(ctx, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION());
-
-            SSL_CTX_set_options(ctx, SSL_OP_SINGLE_DH_USE());
-            SSL_CTX_set_options(ctx, SSL_OP_SINGLE_ECDH_USE());
-
-            // Default session context id and cache size
-            // # define SSL_CTX_sess_set_cache_size(ctx,t) \
-            //          SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SESS_CACHE_SIZE,t,NULL)
-            SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_SIZE(), 256, MemoryAddress.NULL);
-
-            // Session cache is disabled by default
-            // # define SSL_CTX_set_session_cache_mode(ctx,m) \
-            //          SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SESS_CACHE_MODE,m,NULL)
-            SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_MODE(), SSL_SESS_CACHE_OFF(), MemoryAddress.NULL);
-
-            // Longer session timeout
-            SSL_CTX_set_timeout(ctx, 14400);
-
-            // From SSLContext.make, possibly set ssl_callback_ServerNameIndication
-            // From SSLContext.make, possibly set ssl_callback_ClientHello
-            // Probably not needed
-
-            // Set int pem_password_cb(char *buf, int size, int rwflag, void *u) callback
-            openSSLCallbackPassword =
-                    CLinker.systemCLinker().upcallStub(openSSLCallbackPasswordHandle.bindTo(this),
-                    openSSLCallbackPasswordFunctionDescriptor, scope);
-            SSL_CTX_set_default_passwd_cb(ctx, openSSLCallbackPassword);
-
-            this.negotiableProtocols = negotiableProtocols;
-
-            success = true;
-        } catch(Exception e) {
-            throw new SSLException(sm.getString("openssl.errorSSLCtxInit"), e);
-        } finally {
-            state = new OpenSSLState(scope, cctx, ctx);
-            /*
-             * When an SSLHostConfig is replaced at runtime, it is not possible to
-             * call destroy() on the associated OpenSSLContext since it is likely
-             * that there will be in-progress connections using the OpenSSLContext.
-             * A reference chain has been deliberately established (see
-             * OpenSSLSessionContext) to ensure that the OpenSSLContext remains
-             * ineligible for GC while those connections are alive. Once those
-             * connections complete, the OpenSSLContext will become eligible for GC
-             * and this method will ensure that the associated native resources are
-             * cleaned up.
-             */
-            cleanable = cleaner.register(this, state);
-
-            if (!success) {
-                destroy();
-            }
-        }
-    }
-
-
-    public String getEnabledProtocol() {
-        return enabledProtocol;
-    }
-
-
-    public void setEnabledProtocol(String protocol) {
-        enabledProtocol = (protocol == null) ? defaultProtocol : protocol;
-    }
-
-
-    @Override
-    public synchronized void destroy() {
-        cleanable.clean();
-    }
-
-
-    private boolean checkConf(OpenSSLConf conf) throws Exception {
-        boolean result = true;
-        OpenSSLConfCmd cmd;
-        String name;
-        String value;
-        int rc;
-        for (OpenSSLConfCmd command : conf.getCommands()) {
-            cmd = command;
-            name = cmd.getName();
-            value = cmd.getValue();
-            if (name == null) {
-                log.error(sm.getString("opensslconf.noCommandName", value));
-                result = false;
-                continue;
-            }
-            if (log.isDebugEnabled()) {
-                log.debug(sm.getString("opensslconf.checkCommand", name, value));
-            }
-            try (var scope = ResourceScope.newConfinedScope()) {
-                // rc = SSLConf.check(cctx, name, value);
-                if (name.equals("NO_OCSP_CHECK")) {
-                    rc = 1;
-                } else {
-                    var allocator = SegmentAllocator.nativeAllocator(scope);
-                    int code = SSL_CONF_cmd_value_type(state.cctx, allocator.allocateUtf8String(name));
-                    rc = 1;
-                    long errCode = ERR_get_error();
-                    if (errCode != 0) {
-                        var buf = allocator.allocateArray(ValueLayout.JAVA_BYTE, new byte[128]);
-                        ERR_error_string(errCode, buf);
-                        log.error(sm.getString("opensslconf.checkFailed", buf.getUtf8String(0)));
-                        rc = 0;
-                    }
-                    if (code == SSL_CONF_TYPE_UNKNOWN()) {
-                        log.error(sm.getString("opensslconf.typeUnknown", name));
-                        rc = 0;
-                    }
-                    if (code == SSL_CONF_TYPE_FILE()) {
-                        // Check file
-                        File file = new File(value);
-                        if (!file.isFile() && !file.canRead()) {
-                            log.error(sm.getString("opensslconf.badFile", name, value));
-                            rc = 0;
-                        }
-                    }
-                    if (code == SSL_CONF_TYPE_DIR()) {
-                        // Check dir
-                        File file = new File(value);
-                        if (!file.isDirectory()) {
-                            log.error(sm.getString("opensslconf.badDirectory", name, value));
-                            rc = 0;
-                        }
-                    }
-                }
-            } catch (Exception e) {
-                log.error(sm.getString("opensslconf.checkFailed", e.getLocalizedMessage()));
-                return false;
-            }
-            if (rc <= 0) {
-                log.error(sm.getString("opensslconf.failedCommand", name, value,
-                        Integer.toString(rc)));
-                result = false;
-            } else if (log.isDebugEnabled()) {
-                log.debug(sm.getString("opensslconf.resultCommand", name, value,
-                        Integer.toString(rc)));
-            }
-        }
-        if (!result) {
-            log.error(sm.getString("opensslconf.checkFailed"));
-        }
-        return result;
-    }
-
-
-    private boolean applyConf(OpenSSLConf conf) throws Exception {
-        boolean result = true;
-        // SSLConf.assign(cctx, ctx);
-        SSL_CONF_CTX_set_ssl_ctx(state.cctx, state.ctx);
-        OpenSSLConfCmd cmd;
-        String name;
-        String value;
-        int rc;
-        for (OpenSSLConfCmd command : conf.getCommands()) {
-            cmd = command;
-            name = cmd.getName();
-            value = cmd.getValue();
-            if (name == null) {
-                log.error(sm.getString("opensslconf.noCommandName", value));
-                result = false;
-                continue;
-            }
-            if (log.isDebugEnabled()) {
-                log.debug(sm.getString("opensslconf.applyCommand", name, value));
-            }
-            try (var scope = ResourceScope.newConfinedScope()) {
-                // rc = SSLConf.apply(cctx, name, value);
-                if (name.equals("NO_OCSP_CHECK")) {
-                    noOcspCheck = Boolean.valueOf(value);
-                    rc = 1;
-                } else {
-                    var allocator = SegmentAllocator.nativeAllocator(scope);
-                    rc = SSL_CONF_cmd(state.cctx, allocator.allocateUtf8String(name),
-                            allocator.allocateUtf8String(value));
-                    long errCode = ERR_get_error();
-                    if (rc <= 0 || errCode != 0) {
-                        var buf = allocator.allocateArray(ValueLayout.JAVA_BYTE, new byte[128]);
-                        ERR_error_string(errCode, buf);
-                        log.error(sm.getString("opensslconf.commandError", name, value, buf.getUtf8String(0)));
-                        rc = 0;
-                    }
-                }
-            } catch (Exception e) {
-                log.error(sm.getString("opensslconf.applyFailed"));
-                return false;
-            }
-            if (rc <= 0) {
-                log.error(sm.getString("opensslconf.failedCommand", name, value,
-                        Integer.toString(rc)));
-                result = false;
-            } else if (log.isDebugEnabled()) {
-                log.debug(sm.getString("opensslconf.resultCommand", name, value,
-                        Integer.toString(rc)));
-            }
-        }
-        // rc = SSLConf.finish(cctx);
-        rc = SSL_CONF_CTX_finish(state.cctx);
-        if (rc <= 0) {
-            log.error(sm.getString("opensslconf.finishFailed", Integer.toString(rc)));
-            result = false;
-        }
-        if (!result) {
-            log.error(sm.getString("opensslconf.applyFailed"));
-        }
-        return result;
-    }
-
-    private static final int OPTIONAL_NO_CA = 3;
-
-    /**
-     * Setup the SSL_CTX.
-     *
-     * @param kms Must contain a KeyManager of the type
-     *            {@code OpenSSLKeyManager}
-     * @param tms Must contain a TrustManager of the type
-     *            {@code X509TrustManager}
-     * @param sr Is not used for this implementation.
-     */
-    @Override
-    public synchronized void init(KeyManager[] kms, TrustManager[] tms, SecureRandom sr) {
-        if (initialized) {
-            log.warn(sm.getString("openssl.doubleInit"));
-            return;
-        }
-        try {
-            if (sslHostConfig.getInsecureRenegotiation()) {
-                SSL_CTX_set_options(state.ctx, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION());
-            } else {
-                SSL_CTX_clear_options(state.ctx, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION());
-            }
-
-            // Use server's preference order for ciphers (rather than
-            // client's)
-            if (sslHostConfig.getHonorCipherOrder()) {
-                SSL_CTX_set_options(state.ctx, SSL_OP_CIPHER_SERVER_PREFERENCE());
-            } else {
-                SSL_CTX_clear_options(state.ctx, SSL_OP_CIPHER_SERVER_PREFERENCE());
-            }
-
-            // Disable compression if requested
-            if (sslHostConfig.getDisableCompression()) {
-                SSL_CTX_set_options(state.ctx, SSL_OP_NO_COMPRESSION());
-            } else {
-                SSL_CTX_clear_options(state.ctx, SSL_OP_NO_COMPRESSION());
-            }
-
-            // Disable TLS Session Tickets (RFC4507) to protect perfect forward secrecy
-            if (sslHostConfig.getDisableSessionTickets()) {
-                SSL_CTX_set_options(state.ctx, SSL_OP_NO_TICKET());
-            } else {
-                SSL_CTX_clear_options(state.ctx, SSL_OP_NO_TICKET());
-            }
-
-            // List the ciphers that the client is permitted to negotiate
-            if (SSL_CTX_set_cipher_list(state.ctx,
-                    SegmentAllocator.nativeAllocator(state.scope).allocateUtf8String(sslHostConfig.getCiphers())) <= 0) {
-                log.warn(sm.getString("engine.failedCipherSuite", sslHostConfig.getCiphers()));
-            }
-
-            if (certificate.getCertificateFile() == null) {
-                certificate.setCertificateKeyManager(OpenSSLUtil.chooseKeyManager(kms));
-            }
-
-            addCertificate(certificate);
-
-            // Client certificate verification
-            int value = 0;
-            switch (sslHostConfig.getCertificateVerification()) {
-            case NONE:
-                value = SSL_VERIFY_NONE();
-                break;
-            case OPTIONAL:
-                value = SSL_VERIFY_PEER();
-                break;
-            case OPTIONAL_NO_CA:
-                value = OPTIONAL_NO_CA;
-                break;
-            case REQUIRED:
-                value = SSL_VERIFY_FAIL_IF_NO_PEER_CERT();
-                break;
-            }
-            certificateVerifyMode = value;
-
-            // SSLContext.setVerify(state.ctx, value, sslHostConfig.getCertificateVerificationDepth());
-            if (SSL_CTX_set_default_verify_paths(state.ctx) > 0) {
-                var store = SSL_CTX_get_cert_store(state.ctx);
-                X509_STORE_set_flags(store, 0);
-            }
-
-            // Set int verify_callback(int preverify_ok, X509_STORE_CTX *x509_ctx) callback
-            NativeSymbol openSSLCallbackVerify =
-                    CLinker.systemCLinker().upcallStub(openSSLCallbackVerifyHandle.bindTo(this),
-                    openSSLCallbackVerifyFunctionDescriptor, state.scope);
-            // Leave this just in case but in Tomcat this is always set again by the engine
-            SSL_CTX_set_verify(state.ctx, value, openSSLCallbackVerify);
-
-            // Trust and certificate verification
-            try (var scope = ResourceScope.newConfinedScope()) {
-                var allocator = SegmentAllocator.nativeAllocator(scope);
-                if (tms != null) {
-                    // Client certificate verification based on custom trust managers
-                    x509TrustManager = chooseTrustManager(tms);
-                    NativeSymbol openSSLCallbackCertVerify =
-                            CLinker.systemCLinker().upcallStub(openSSLCallbackCertVerifyHandle.bindTo(this),
-                            openSSLCallbackCertVerifyFunctionDescriptor, state.scope);
-                    SSL_CTX_set_cert_verify_callback(state.ctx, openSSLCallbackCertVerify, MemoryAddress.NULL);
-
-                    // Pass along the DER encoded certificates of the accepted client
-                    // certificate issuers, so that their subjects can be presented
-                    // by the server during the handshake to allow the client choosing
-                    // an acceptable certificate
-                    for (X509Certificate caCert : x509TrustManager.getAcceptedIssuers()) {
-                        //SSLContext.addClientCACertificateRaw(state.ctx, caCert.getEncoded());
-                        var rawCACertificate = allocator.allocateArray(ValueLayout.JAVA_BYTE, caCert.getEncoded());
-                        var rawCACertificatePointer = allocator.allocate(ValueLayout.ADDRESS, rawCACertificate);
-                        var x509CACert = d2i_X509(MemoryAddress.NULL, rawCACertificatePointer, rawCACertificate.byteSize());
-                        if (MemoryAddress.NULL.equals(x509CACert)) {
-                            logLastError(allocator, "openssl.errorLoadingCertificate");
-                        } else if (SSL_CTX_add_client_CA(state.ctx, x509CACert) <= 0) {
-                            logLastError(allocator, "openssl.errorAddingCertificate");
-                        } else if (log.isDebugEnabled()) {
-                            log.debug(sm.getString("openssl.addedClientCaCert", caCert.toString()));
-                        }
-                    }
-                } else if (sslHostConfig.getCaCertificateFile() != null || sslHostConfig.getCaCertificatePath() != null) {
-                    // Client certificate verification based on trusted CA files and dirs
-                    //SSLContext.setCACertificate(state.ctx,
-                    //        SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificateFile()),
-                    //        SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificatePath()));
-                    MemorySegment caCertificateFileNative = sslHostConfig.getCaCertificateFile() != null
-                            ? allocator.allocateUtf8String(SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificateFile())) : null;
-                    MemorySegment caCertificatePathNative = sslHostConfig.getCaCertificatePath() != null
-                            ? allocator.allocateUtf8String(SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificatePath())) : null;
-                    if (SSL_CTX_load_verify_locations(state.ctx,
-                            caCertificateFileNative == null ? MemoryAddress.NULL : caCertificateFileNative,
-                            caCertificatePathNative == null ? MemoryAddress.NULL : caCertificatePathNative) <= 0) {
-                        logLastError(allocator, "openssl.errorConfiguringLocations");
-                    } else {
-                        var caCerts = SSL_CTX_get_client_CA_list(state.ctx);
-                        if (MemoryAddress.NULL.equals(caCerts)) {
-                            caCerts = SSL_load_client_CA_file(caCertificateFileNative);
-                            if (!MemoryAddress.NULL.equals(caCerts)) {
-                                SSL_CTX_set_client_CA_list(state.ctx, caCerts);
-                            }
-                        } else {
-                            if (SSL_add_file_cert_subjects_to_stack(caCerts, caCertificateFileNative) <= 0) {
-                                caCerts = MemoryAddress.NULL;
-                            }
-                        }
-                        if (MemoryAddress.NULL.equals(caCerts)) {
-                            log.warn(sm.getString("openssl.noCACerts"));
-                        }
-                    }
-                }
-            }
-
-            if (negotiableProtocols != null && negotiableProtocols.size() > 0) {
-                // int openSSLCallbackAlpnSelectProto(MemoryAddress ssl, MemoryAddress out, MemoryAddress outlen,
-                //        MemoryAddress in, int inlen, MemoryAddress arg
-                NativeSymbol openSSLCallbackAlpnSelectProto =
-                        CLinker.systemCLinker().upcallStub(openSSLCallbackAlpnSelectProtoHandle.bindTo(this),
-                        openSSLCallbackAlpnSelectProtoFunctionDescriptor, state.scope);
-                SSL_CTX_set_alpn_select_cb(state.ctx, openSSLCallbackAlpnSelectProto, MemoryAddress.NULL);
-
-                // Skip NPN (annoying and likely not useful anymore)
-                //SSLContext.setNpnProtos(state.ctx, protocolsArray, SSL.SSL_SELECTOR_FAILURE_NO_ADVERTISE);
-            }
-
-            // Apply OpenSSLConfCmd if used
-            OpenSSLConf openSslConf = sslHostConfig.getOpenSslConf();
-            if (openSslConf != null && !MemoryAddress.NULL.equals(state.cctx)) {
-                // Check OpenSSLConfCmd if used
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("openssl.checkConf"));
-                }
-                try {
-                    if (!checkConf(openSslConf)) {
-                        log.error(sm.getString("openssl.errCheckConf"));
-                        throw new Exception(sm.getString("openssl.errCheckConf"));
-                    }
-                } catch (Exception e) {
-                    throw new Exception(sm.getString("openssl.errCheckConf"), e);
-                }
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("openssl.applyConf"));
-                }
-                try {
-                    if (!applyConf(openSslConf)) {
-                        log.error(sm.getString("openssl.errApplyConf"));
-                        throw new SSLException(sm.getString("openssl.errApplyConf"));
-                    }
-                } catch (Exception e) {
-                    throw new SSLException(sm.getString("openssl.errApplyConf"), e);
-                }
-                // Reconfigure the enabled protocols
-                long opts = SSL_CTX_get_options(state.ctx);
-                List<String> enabled = new ArrayList<>();
-                // Seems like there is no way to explicitly disable SSLv2Hello
-                // in OpenSSL so it is always enabled
-                enabled.add(Constants.SSL_PROTO_SSLv2Hello);
-                if ((opts & SSL_OP_NO_TLSv1()) == 0) {
-                    enabled.add(Constants.SSL_PROTO_TLSv1);
-                }
-                if ((opts & SSL_OP_NO_TLSv1_1()) == 0) {
-                    enabled.add(Constants.SSL_PROTO_TLSv1_1);
-                }
-                if ((opts & SSL_OP_NO_TLSv1_2()) == 0) {
-                    enabled.add(Constants.SSL_PROTO_TLSv1_2);
-                }
-                if ((opts & SSL_OP_NO_TLSv1_3()) == 0) {
-                    enabled.add(Constants.SSL_PROTO_TLSv1_3);
-                }
-                if ((opts & SSL_OP_NO_SSLv2()) == 0) {
-                    enabled.add(Constants.SSL_PROTO_SSLv2);
-                }
-                if ((opts & SSL_OP_NO_SSLv3()) == 0) {
-                    enabled.add(Constants.SSL_PROTO_SSLv3);
-                }
-                sslHostConfig.setEnabledProtocols(
-                        enabled.toArray(new String[0]));
-                // Reconfigure the enabled ciphers
-                sslHostConfig.setEnabledCiphers(getCiphers(state.ctx));
-            }
-
-            sessionContext = new OpenSSLSessionContext(this);
-            // If client authentication is being used, OpenSSL requires that
-            // this is set so always set it in case an app is configured to
-            // require it
-            sessionContext.setSessionIdContext(DEFAULT_SESSION_ID_CONTEXT);
-            sslHostConfig.setOpenSslContext(state.ctx.toRawLongValue());
-            initialized = true;
-        } catch (Exception e) {
-            log.warn(sm.getString("openssl.errorSSLCtxInit"), e);
-            destroy();
-        }
-    }
-
-
-    public MemoryAddress getSSLContext() {
-        return state.ctx;
-    }
-
-    // DH *(*tmp_dh_callback)(SSL *ssl, int is_export, int keylength)
-    public Addressable openSSLCallbackTmpDH(MemoryAddress ssl, int isExport, int keylength) {
-        var pkey = SSL_get_privatekey(ssl);
-        int type = (MemoryAddress.NULL.equals(pkey)) ? EVP_PKEY_NONE() : EVP_PKEY_base_id(pkey);
-        /*
-         * OpenSSL will call us with either keylen == 512 or keylen == 1024
-         * (see the definition of SSL_EXPORT_PKEYLENGTH in ssl_locl.h).
-         * Adjust the DH parameter length according to the size of the
-         * RSA/DSA private key used for the current connection, and always
-         * use at least 1024-bit parameters.
-         * Note: This may cause interoperability issues with implementations
-         * which limit their DH support to 1024 bit - e.g. Java 7 and earlier.
-         * In this case, SSLCertificateFile can be used to specify fixed
-         * 1024-bit DH parameters (with the effect that OpenSSL skips this
-         * callback).
-         */
-        int keylen = 0;
-        if ((type == EVP_PKEY_RSA()) || (type == EVP_PKEY_DSA())) {
-            keylen = EVP_PKEY_bits(pkey);
-        }
-        for (int i = 0; i < dhParameters.length; i++) {
-            if (keylen >= dhParameters[i].min) {
-                return dhParameters[i].dh;
-            }
-        }
-        return MemoryAddress.NULL;
-    }
-
-    // int SSL_callback_alpn_select_proto(SSL* ssl, const unsigned char **out, unsigned char *outlen,
-    //        const unsigned char *in, unsigned int inlen, void *arg)
-    public int openSSLCallbackAlpnSelectProto(MemoryAddress ssl, MemoryAddress out, MemoryAddress outlen,
-            MemoryAddress in, int inlen, MemoryAddress arg) {
-        // No scope, so byte by byte read, the ALPN data is small
-        byte[] advertisedBytes = new byte[inlen];
-        for (int i = 0; i < inlen; i++) {
-            advertisedBytes[i] = in.get(ValueLayout.JAVA_BYTE, i);
-        }
-        ArrayList<byte[]> negotiableProtocolsBytes = new ArrayList<>(negotiableProtocols.size() + 1);
-        for (String negotiableProtocol : negotiableProtocols) {
-            negotiableProtocolsBytes.add(negotiableProtocol.getBytes());
-        }
-        negotiableProtocolsBytes.add(HTTP_11_PROTOCOL);
-        for (byte[] negotiableProtocolBytes : negotiableProtocolsBytes) {
-            for (int i = 0; i <= advertisedBytes.length - negotiableProtocolBytes.length; i++) {
-                if (advertisedBytes[i] == negotiableProtocolBytes[0]) {
-                    for (int j = 0; j < negotiableProtocolBytes.length; j++) {
-                        if (advertisedBytes[i + j] == negotiableProtocolBytes[j]) {
-                            if (j == negotiableProtocolBytes.length - 1) {
-                                // Match
-                                out.set(ValueLayout.ADDRESS, 0, in.addOffset(i));
-                                outlen.set(ValueLayout.JAVA_BYTE, 0, (byte) negotiableProtocolBytes.length);
-                                return SSL_TLSEXT_ERR_OK();
-                            }
-                        } else {
-                            break;
-                        }
-                    }
-                }
-            }
-        }
-        return SSL_TLSEXT_ERR_NOACK();
-    }
-
-    public int openSSLCallbackVerify(int preverify_ok, MemoryAddress /*X509_STORE_CTX*/ x509ctx) {
-        if (log.isDebugEnabled()) {
-            log.debug("Verification with mode [" + certificateVerifyMode + "]");
-        }
-        MemoryAddress ssl = X509_STORE_CTX_get_ex_data(x509ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
-        int ok = preverify_ok;
-        int errnum = X509_STORE_CTX_get_error(x509ctx);
-        int errdepth = X509_STORE_CTX_get_error_depth(x509ctx);
-        if (certificateVerifyMode == -1 /*SSL_CVERIFY_UNSET*/
-                || certificateVerifyMode == SSL_VERIFY_NONE()) {
-            return 1;
-        }
-        /*SSL_VERIFY_ERROR_IS_OPTIONAL(errnum) -> ((errnum == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT)
-                || (errnum == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN)
-                || (errnum == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)
-                || (errnum == X509_V_ERR_CERT_UNTRUSTED)
-                || (errnum == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE))*/
-        boolean verifyErrorIsOptional = (errnum == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT())
-                || (errnum == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN())
-                || (errnum == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY())
-                || (errnum == X509_V_ERR_CERT_UNTRUSTED())
-                || (errnum == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE());
-        if (verifyErrorIsOptional && (certificateVerifyMode == OPTIONAL_NO_CA)) {
-            ok = 1;
-            SSL_set_verify_result(ssl, X509_V_OK());
-        }
-        /*
-         * Expired certificates vs. "expired" CRLs: by default, OpenSSL
-         * turns X509_V_ERR_CRL_HAS_EXPIRED into a "certificate_expired(45)"
-         * SSL alert, but that's not really the message we should convey to the
-         * peer (at the very least, it's confusing, and in many cases, it's also
-         * inaccurate, as the certificate itself may very well not have expired
-         * yet). We set the X509_STORE_CTX error to something which OpenSSL's
-         * s3_both.c:ssl_verify_alarm_type() maps to SSL_AD_CERTIFICATE_UNKNOWN,
-         * i.e. the peer will receive a "certificate_unknown(46)" alert.
-         * We do not touch errnum, though, so that later on we will still log
-         * the "real" error, as returned by OpenSSL.
-         */
-        if (ok == 0 && errnum == X509_V_ERR_CRL_HAS_EXPIRED()) {
-            X509_STORE_CTX_set_error(x509ctx, -1);
-        }
-
-        // OCSP
-        if (!noOcspCheck && (ok > 0)) {
-            /* If there was an optional verification error, it's not
-             * possible to perform OCSP validation since the issuer may be
-             * missing/untrusted.  Fail in that case.
-             */
-            if (verifyErrorIsOptional) {
-                if (certificateVerifyMode != OPTIONAL_NO_CA) {
-                    X509_STORE_CTX_set_error(x509ctx, X509_V_ERR_APPLICATION_VERIFICATION());
-                    errnum = X509_V_ERR_APPLICATION_VERIFICATION();
-                    ok = 0;
-                }
-            } else {
-                int ocspResponse = OpenSSLEngine.processOCSP(x509ctx);
-                if (ocspResponse == V_OCSP_CERTSTATUS_REVOKED()) {
-                    ok = 0;
-                    errnum = X509_STORE_CTX_get_error(x509ctx);
-                } else if (ocspResponse == V_OCSP_CERTSTATUS_UNKNOWN()) {
-                    errnum = X509_STORE_CTX_get_error(x509ctx);
-                    if (errnum <= 0) {
-                        ok = 0;
-                    }
-                }
-            }
-        }
-
-        if (errdepth > sslHostConfig.getCertificateVerificationDepth()) {
-            // Certificate Verification: Certificate Chain too long
-            ok = 0;
-        }
-        return ok;
-    }
-
-
-    public int openSSLCallbackCertVerify(MemoryAddress /*X509_STORE_CTX*/ x509_ctx, MemoryAddress param) {
-        if (log.isDebugEnabled()) {
-            log.debug("Certificate verification");
-        }
-        MemoryAddress ssl = X509_STORE_CTX_get_ex_data(x509_ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
-        MemoryAddress /*STACK_OF(X509)*/ sk = X509_STORE_CTX_get0_untrusted(x509_ctx);
-        int len = OPENSSL_sk_num(sk);
-        byte[][] certificateChain = new byte[len][];
-        try (var scope = ResourceScope.newConfinedScope()) {
-            var allocator = SegmentAllocator.nativeAllocator(scope);
-            for (int i = 0; i < len; i++) {
-                MemoryAddress/*(X509*)*/ x509 = OPENSSL_sk_value(sk, i);
-                MemorySegment bufPointer = allocator.allocate(ValueLayout.ADDRESS, MemoryAddress.NULL);
-                int length = i2d_X509(x509, bufPointer);
-                if (length < 0) {
-                    certificateChain[i] = new byte[0];
-                    continue;
-                }
-                MemoryAddress buf = bufPointer.get(ValueLayout.ADDRESS, 0);
-                certificateChain[i] = MemorySegment.ofAddressNative(buf, length, scope).toArray(ValueLayout.JAVA_BYTE);
-                CRYPTO_free(buf, OPENSSL_FILE(), OPENSSL_LINE()); // OPENSSL_free macro
-            }
-            MemoryAddress cipher = SSL_get_current_cipher(ssl);
-            String authMethod = (MemoryAddress.NULL.equals(cipher)) ? "UNKNOWN"
-                    : getCipherAuthenticationMethod(SSL_CIPHER_get_auth_nid(cipher), SSL_CIPHER_get_kx_nid(cipher));
-            X509Certificate[] peerCerts = certificates(certificateChain);
-            try {
-                x509TrustManager.checkClientTrusted(peerCerts, authMethod);
-                return 1;
-            } catch (Exception e) {
-                log.debug(sm.getString("openssl.certificateVerificationFailed"), e);
-            }
-        }
-        return 0;
-    }
-
-    private static final int NID_kx_rsa = 1037/*NID_kx_rsa()*/;
-    //private static final int NID_kx_dhe = NID_kx_dhe();
-    //private static final int NID_kx_ecdhe = NID_kx_ecdhe();
-
-    //private static final int NID_auth_rsa = NID_auth_rsa();
-    //private static final int NID_auth_dss = NID_auth_dss();
-    //private static final int NID_auth_null = NID_auth_null();
-    //private static final int NID_auth_ecdsa = NID_auth_ecdsa();
-
-    //private static final int SSL_kRSA = 1;
-    private static final int SSL_kDHr = 2;
-    private static final int SSL_kDHd = 4;
-    private static final int SSL_kEDH = 8;
-    private static final int SSL_kDHE = SSL_kEDH;
-    private static final int SSL_kKRB5 = 10;
-    private static final int SSL_kECDHr = 20;
-    private static final int SSL_kECDHe = 40;
-    private static final int SSL_kEECDH = 80;
-    private static final int SSL_kECDHE = SSL_kEECDH;
-    //private static final int SSL_kPSK = 100;
-    //private static final int SSL_kGOST = 200;
-    //private static final int SSL_kSRP = 400;
-
-    private static final int SSL_aRSA = 1;
-    private static final int SSL_aDSS = 2;
-    private static final int SSL_aNULL = 4;
-    //private static final int SSL_aDH = 8;
-    //private static final int SSL_aECDH = 10;
-    //private static final int SSL_aKRB5 = 20;
-    private static final int SSL_aECDSA = 40;
-    //private static final int SSL_aPSK = 80;
-    //private static final int SSL_aGOST94 = 100;
-    //private static final int SSL_aGOST01 = 200;
-    //private static final int SSL_aSRP = 400;
-
-    private static final String SSL_TXT_RSA = SSL_TXT_RSA().getUtf8String(0);
-    private static final String SSL_TXT_DH = SSL_TXT_DH().getUtf8String(0);
-    private static final String SSL_TXT_DSS = SSL_TXT_DSS().getUtf8String(0);
-    private static final String SSL_TXT_KRB5 = "KRB5";
-    private static final String SSL_TXT_ECDH = SSL_TXT_ECDH().getUtf8String(0);
-    private static final String SSL_TXT_ECDSA = SSL_TXT_ECDSA().getUtf8String(0);
-
-    private static String getCipherAuthenticationMethod(int auth, int kx) {
-        switch (kx) {
-        case NID_kx_rsa:
-            return SSL_TXT_RSA;
-        case SSL_kDHr:
-            return SSL_TXT_DH + "_" + SSL_TXT_RSA;
-        case SSL_kDHd:
-            return SSL_TXT_DH + "_" + SSL_TXT_DSS;
-        case SSL_kDHE:
-            switch (auth) {
-            case SSL_aDSS:
-                return "DHE_" + SSL_TXT_DSS;
-            case SSL_aRSA:
-                return "DHE_" + SSL_TXT_RSA;
-            case SSL_aNULL:
-                return SSL_TXT_DH + "_anon";
-            default:
-                return "UNKNOWN";
-            }
-        case SSL_kKRB5:
-            return SSL_TXT_KRB5;
-        case SSL_kECDHr:
-            return SSL_TXT_ECDH + "_" + SSL_TXT_RSA;
-        case SSL_kECDHe:
-            return SSL_TXT_ECDH + "_" + SSL_TXT_ECDSA;
-        case SSL_kECDHE:
-            switch (auth) {
-            case SSL_aECDSA:
-                return "ECDHE_" + SSL_TXT_ECDSA;
-            case SSL_aRSA:
-                return "ECDHE_" + SSL_TXT_RSA;
-            case SSL_aNULL:
-                return SSL_TXT_ECDH + "_anon";
-            default:
-                return "UNKNOWN";
-            }
-        default:
-            return "UNKNOWN";
-        }
-    }
-
-    private String callbackPassword = null;
-
-    public int openSSLCallbackPassword(MemoryAddress /*char **/ buf, int bufsiz, int verify, MemoryAddress /*void **/ cb) {
-        if (log.isDebugEnabled()) {
-            log.debug("Return password for certificate");
-        }
-        try (var scope = ResourceScope.newConfinedScope()) {
-            var allocator = SegmentAllocator.nativeAllocator(scope);
-            MemorySegment callbackPasswordNative = allocator.allocateUtf8String(callbackPassword);
-            if (callbackPasswordNative.byteSize() > bufsiz) {
-                // The password is too long
-                log.error(sm.getString("openssl.passwordTooLong"));
-            } else {
-                MemorySegment bufSegment = MemorySegment.ofAddressNative(buf, bufsiz, scope);
-                bufSegment.copyFrom(callbackPasswordNative);
-                return (int) callbackPasswordNative.byteSize();
-            }
-        }        
-        return 0;
-    }
-
-
-    public void addCertificate(SSLHostConfigCertificate certificate) throws Exception {
-        try (var scope = ResourceScope.newConfinedScope()) {
-            var allocator = SegmentAllocator.nativeAllocator(scope);
-            int index = getCertificateIndex(certificate);
-            // Load Server key and certificate
-            if (certificate.getCertificateFile() != null) {
-                // Set certificate
-                // Make the password available for the callback
-                callbackPassword = certificate.getCertificateKeyPassword();
-                //SSLContext.setCertificate(state.ctx,
-                //        SSLHostConfig.adjustRelativePath(certificate.getCertificateFile()),
-                //        SSLHostConfig.adjustRelativePath(certificate.getCertificateKeyFile()),
-                //        certificate.getCertificateKeyPassword(), getCertificateIndex(certificate));
-                var certificateFileNative = allocator.allocateUtf8String(SSLHostConfig.adjustRelativePath(certificate.getCertificateFile()));
-                var certificateKeyFileNative = (certificate.getCertificateKeyFile() == null) ? certificateFileNative
-                        : allocator.allocateUtf8String(SSLHostConfig.adjustRelativePath(certificate.getCertificateKeyFile()));
-                MemoryAddress bio;
-                MemoryAddress cert = MemoryAddress.NULL;
-                MemoryAddress key = MemoryAddress.NULL;
-                if (certificate.getCertificateFile().endsWith(".pkcs12")) {
-                    // Load pkcs12
-                    bio = BIO_new(BIO_s_file());
-                    //#  define BIO_read_filename(b,name)
-                    //        (int)BIO_ctrl(b,BIO_C_SET_FILENAME, BIO_CLOSE|BIO_FP_READ,(char *)(name))
-                    if (BIO_ctrl(bio, BIO_C_SET_FILENAME(), BIO_CLOSE() | BIO_FP_READ(), certificateFileNative) <= 0) {
-                        BIO_free(bio);
-                        log.error(sm.getString("openssl.errorLoadingCertificate", "[0]:" + certificate.getCertificateFile()));
-                        return;
-                    }
-                    MemoryAddress p12 = d2i_PKCS12_bio(bio, MemoryAddress.NULL);
-                    BIO_free(bio);
-                    if (MemoryAddress.NULL.equals(p12)) {
-                        log.error(sm.getString("openssl.errorLoadingCertificate", "[1]:" + certificate.getCertificateFile()));
-                        return;
-                    }
-                    MemoryAddress passwordAddress = MemoryAddress.NULL;
-                    int passwordLength = 0;
-                    if (callbackPassword != null && callbackPassword.length() > 0) {
-                        MemorySegment password = allocator.allocateUtf8String(callbackPassword);
-                        passwordAddress = password.address();
-                        passwordLength = (int) (password.byteSize() - 1);
-                    }
-                    if (PKCS12_verify_mac(p12, passwordAddress, passwordLength) <= 0) {
-                        // Bad password
-                        log.error(sm.getString("openssl.errorLoadingCertificate", "[2]:" + certificate.getCertificateFile()));
-                        PKCS12_free(p12);
-                        return;
-                    }
-                    MemorySegment certPointer = allocator.allocate(ValueLayout.ADDRESS);
-                    MemorySegment keyPointer = allocator.allocate(ValueLayout.ADDRESS);
-                    if (PKCS12_parse(p12, passwordAddress, keyPointer, certPointer, MemoryAddress.NULL) <= 0) {
-                        log.error(sm.getString("openssl.errorLoadingCertificate", "[3]:" + certificate.getCertificateFile()));
-                        PKCS12_free(p12);
-                        return;
-                    }
-                    PKCS12_free(p12);
-                    cert = certPointer.get(ValueLayout.ADDRESS, 0);
-                    key = keyPointer.get(ValueLayout.ADDRESS, 0);
-                } else {
-                    // Load key
-                    bio = BIO_new(BIO_s_file());
-                    //#  define BIO_read_filename(b,name)
-                    //        (int)BIO_ctrl(b,BIO_C_SET_FILENAME, BIO_CLOSE|BIO_FP_READ,(char *)(name))
-                    if (BIO_ctrl(bio, BIO_C_SET_FILENAME(), BIO_CLOSE() | BIO_FP_READ(), certificateKeyFileNative) <= 0) {
-                        BIO_free(bio);
-                        log.error(sm.getString("openssl.errorLoadingCertificate", certificate.getCertificateKeyFile()));
-                        return;
-                    }
-                    key = MemoryAddress.NULL;
-                    for (int i = 0; i < 3; i++) {
-                        key = PEM_read_bio_PrivateKey(bio, MemoryAddress.NULL, openSSLCallbackPassword, MemoryAddress.NULL);
-                        if (!MemoryAddress.NULL.equals(key)) {
-                            break;
-                        }
-                        BIO_ctrl(bio, BIO_CTRL_RESET(), 0, MemoryAddress.NULL);
-                    }
-                    BIO_free(bio);
-                    if (MemoryAddress.NULL.equals(key)) {
-                        if (!MemoryAddress.NULL.equals(OpenSSLLifecycleListener.enginePointer)) {
-                            key = ENGINE_load_private_key(OpenSSLLifecycleListener.enginePointer, certificateKeyFileNative,
-                                    MemoryAddress.NULL, MemoryAddress.NULL);
-                        }
-                    }
-                    if (MemoryAddress.NULL.equals(key)) {
-                        log.error(sm.getString("openssl.errorLoadingCertificate", certificate.getCertificateKeyFile()));
-                        return;
-                    }
-                    // Load certificate
-                    bio = BIO_new(BIO_s_file());
-                    if (BIO_ctrl(bio, BIO_C_SET_FILENAME(), BIO_CLOSE() | BIO_FP_READ(), certificateFileNative) <= 0) {
-                        BIO_free(bio);
-                        log.error(sm.getString("openssl.errorLoadingCertificate", certificate.getCertificateFile()));
-                        return;
-                    }
-                    cert = PEM_read_bio_X509_AUX(bio, MemoryAddress.NULL, openSSLCallbackPassword, MemoryAddress.NULL);
-                    if (MemoryAddress.NULL.equals(cert) &&
-                            // Missing ERR_GET_REASON(ERR_peek_last_error())
-                            /*int ERR_GET_REASON(unsigned long errcode) {
-                             *    if (ERR_SYSTEM_ERROR(errcode))
-                             *        return errcode & ERR_SYSTEM_MASK;
-                             *    return errcode & ERR_REASON_MASK;
-                             *}
-                             *# define ERR_SYSTEM_ERROR(errcode)      (((errcode) & ERR_SYSTEM_FLAG) != 0)
-                             *# define ERR_SYSTEM_FLAG                ((unsigned int)INT_MAX + 1)
-                             *# define ERR_SYSTEM_MASK                ((unsigned int)INT_MAX)
-                             *# define ERR_REASON_MASK                0X7FFFFF
-                             */
-                            ((ERR_peek_last_error() & 0X7FFFFF) == PEM_R_NO_START_LINE())) {
-                        ERR_clear_error();
-                        BIO_ctrl(bio, BIO_CTRL_RESET(), 0, MemoryAddress.NULL);
-                        cert = d2i_X509_bio(bio, MemoryAddress.NULL);
-                    }
-                    BIO_free(bio);
-                    if (MemoryAddress.NULL.equals(cert)) {
-                        log.error(sm.getString("openssl.errorLoadingCertificate", certificate.getCertificateFile()));
-                        return;
-                    }
-                }
-                if (SSL_CTX_use_certificate(state.ctx, cert) <= 0) {
-                    logLastError(allocator, "openssl.errorLoadingCertificate");
-                    return;
-                }
-                if (SSL_CTX_use_PrivateKey(state.ctx, key) <= 0) {
-                    logLastError(allocator, "openssl.errorLoadingPrivateKey");
-                    return;
-                }
-                if (SSL_CTX_check_private_key(state.ctx) <= 0) {
-                    logLastError(allocator, "openssl.errorPrivateKeyCheck");
-                    return;
-                }
-                // Try to read DH parameters from the (first) SSLCertificateFile
-                if (index == SSL_AIDX_RSA) {
-                    bio = BIO_new_file(certificateFileNative, allocator.allocateUtf8String("r"));
-                    var dh = PEM_read_bio_DHparams(bio, MemoryAddress.NULL, MemoryAddress.NULL, MemoryAddress.NULL);
-                    BIO_free(bio);
-                    // #  define SSL_CTX_set_tmp_dh(ctx,dh) \
-                    //           SSL_CTX_ctrl(ctx,SSL_CTRL_SET_TMP_DH,0,(char *)(dh))
-                    if (!MemoryAddress.NULL.equals(dh)) {
-                        SSL_CTX_ctrl(state.ctx, SSL_CTRL_SET_TMP_DH(), 0, dh);
-                        DH_free(dh);
-                    }
-                }
-                // Similarly, try to read the ECDH curve name from SSLCertificateFile...
-                bio = BIO_new_file(certificateFileNative, allocator.allocateUtf8String("r"));
-                var ecparams = PEM_read_bio_ECPKParameters(bio, MemoryAddress.NULL, MemoryAddress.NULL, MemoryAddress.NULL);
-                BIO_free(bio);
-                if (!MemoryAddress.NULL.equals(ecparams)) {
-                    int nid = EC_GROUP_get_curve_name(ecparams);
-                    var eckey = EC_KEY_new_by_curve_name(nid);
-                    // #  define SSL_CTX_set_tmp_ecdh(ctx,ecdh) \
-                    //           SSL_CTX_ctrl(ctx,SSL_CTRL_SET_TMP_ECDH,0,(char *)(ecdh))
-                    SSL_CTX_ctrl(state.ctx, SSL_CTRL_SET_TMP_ECDH(), 0, eckey);
-                    EC_KEY_free(eckey);
-                    EC_GROUP_free(ecparams);
-                }
-                // Set callback for DH parameters
-                NativeSymbol openSSLCallbackTmpDH =
-                        CLinker.systemCLinker().upcallStub(openSSLCallbackTmpDHHandle.bindTo(this),
-                        openSSLCallbackTmpDHFunctionDescriptor, state.scope);
-                SSL_CTX_set_tmp_dh_callback(state.ctx, openSSLCallbackTmpDH);
-                callbackPassword = null;
-                // Set certificate chain file
-                if (certificate.getCertificateChainFile() != null) {
-                    var certificateChainFileNative =
-                            allocator.allocateUtf8String(SSLHostConfig.adjustRelativePath(certificate.getCertificateChainFile()));
-                    // SSLContext.setCertificateChainFile(state.ctx,
-                    //        SSLHostConfig.adjustRelativePath(certificate.getCertificateChainFile()), false);
-                    if (SSL_CTX_use_certificate_chain_file(state.ctx, certificateChainFileNative) <= 0) {
-                        log.error(sm.getString("openssl.errorLoadingCertificate", certificate.getCertificateChainFile()));
-                    }
-                }
-                // Set revocation
-                //SSLContext.setCARevocation(state.ctx,
-                //        SSLHostConfig.adjustRelativePath(
-                //                sslHostConfig.getCertificateRevocationListFile()),
-                //        SSLHostConfig.adjustRelativePath(
-                //                sslHostConfig.getCertificateRevocationListPath()));
-                MemoryAddress certificateStore = (state.ctx);
-                if (sslHostConfig.getCertificateRevocationListFile() != null) {
-                    MemoryAddress x509Lookup = X509_STORE_add_lookup(certificateStore, X509_LOOKUP_file());
-                    var certificateRevocationListFileNative =
-                            allocator.allocateUtf8String(SSLHostConfig.adjustRelativePath(sslHostConfig.getCertificateRevocationListFile()));
-                    //X509_LOOKUP_ctrl(lookup,X509_L_FILE_LOAD,file,type,NULL)
-                    if (X509_LOOKUP_ctrl(x509Lookup, X509_L_FILE_LOAD(), certificateRevocationListFileNative,
-                            X509_FILETYPE_PEM(), MemoryAddress.NULL) <= 0) {
-                        log.error(sm.getString("openssl.errorLoadingCertificateRevocationList", sslHostConfig.getCertificateRevocationListFile()));
-                    }
-                }
-                if (sslHostConfig.getCertificateRevocationListPath() != null) {
-                    MemoryAddress x509Lookup = X509_STORE_add_lookup(certificateStore, X509_LOOKUP_hash_dir());
-                    var certificateRevocationListPathNative =
-                            allocator.allocateUtf8String(SSLHostConfig.adjustRelativePath(sslHostConfig.getCertificateRevocationListPath()));
-                    //X509_LOOKUP_ctrl(lookup,X509_L_ADD_DIR,path,type,NULL)
-                    if (X509_LOOKUP_ctrl(x509Lookup, X509_L_ADD_DIR(), certificateRevocationListPathNative,
-                            X509_FILETYPE_PEM(), MemoryAddress.NULL) <= 0) {
-                        log.error(sm.getString("openssl.errorLoadingCertificateRevocationList", sslHostConfig.getCertificateRevocationListPath()));
-                    }
-                }
-                X509_STORE_set_flags(certificateStore, X509_V_FLAG_CRL_CHECK() | X509_V_FLAG_CRL_CHECK_ALL());
-            } else {
-                String alias = certificate.getCertificateKeyAlias();
-                X509KeyManager x509KeyManager = certificate.getCertificateKeyManager();
-                if (alias == null) {
-                    alias = "tomcat";
-                }
-                X509Certificate[] chain = x509KeyManager.getCertificateChain(alias);
-                if (chain == null) {
-                    alias = findAlias(x509KeyManager, certificate);
-                    chain = x509KeyManager.getCertificateChain(alias);
-                }
-                PrivateKey key = x509KeyManager.getPrivateKey(alias);
-                StringBuilder sb = new StringBuilder(BEGIN_KEY);
-                sb.append(Base64.getMimeEncoder(64, new byte[] {'\n'}).encodeToString(key.getEncoded()));
-                sb.append(END_KEY);
-                //SSLContext.setCertificateRaw(state.ctx, chain[0].getEncoded(),
-                //        sb.toString().getBytes(StandardCharsets.US_ASCII),
-                //        getCertificateIndex(certificate));
-                var rawCertificate = allocator.allocateArray(ValueLayout.JAVA_BYTE, chain[0].getEncoded());
-                var rawCertificatePointer = allocator.allocate(ValueLayout.ADDRESS, rawCertificate);
-                var rawKey = allocator.allocateArray(ValueLayout.JAVA_BYTE, sb.toString().getBytes(StandardCharsets.US_ASCII));
-                var x509cert = d2i_X509(MemoryAddress.NULL, rawCertificatePointer, rawCertificate.byteSize());
-                if (MemoryAddress.NULL.equals(x509cert)) {
-                    logLastError(allocator, "openssl.errorLoadingCertificate");
-                    return;
-                }
-                var bio = BIO_new(BIO_s_mem());
-                BIO_write(bio, rawKey.address(), (int) rawKey.byteSize());
-                MemoryAddress privateKeyAddress = PEM_read_bio_PrivateKey(bio, MemoryAddress.NULL, MemoryAddress.NULL, MemoryAddress.NULL);
-                BIO_free(bio);
-                if (MemoryAddress.NULL.equals(privateKeyAddress)) {
-                    logLastError(allocator, "openssl.errorLoadingPrivateKey");
-                    return;
-                }
-                if (SSL_CTX_use_certificate(state.ctx, x509cert) <= 0) {
-                    logLastError(allocator, "openssl.errorLoadingCertificate");
-                    return;
-                }
-                if (SSL_CTX_use_PrivateKey(state.ctx, privateKeyAddress) <= 0) {
-                    logLastError(allocator, "openssl.errorLoadingPrivateKey");
-                    return;
-                }
-                if (SSL_CTX_check_private_key(state.ctx) <= 0) {
-                    logLastError(allocator, "openssl.errorPrivateKeyCheck");
-                    return;
-                }
-                // Set callback for DH parameters
-                NativeSymbol openSSLCallbackTmpDH =
-                        CLinker.systemCLinker().upcallStub(openSSLCallbackTmpDHHandle.bindTo(this),
-                        openSSLCallbackTmpDHFunctionDescriptor, state.scope);
-                SSL_CTX_set_tmp_dh_callback(state.ctx, openSSLCallbackTmpDH);
-                for (int i = 1; i < chain.length; i++) {
-                    //SSLContext.addChainCertificateRaw(state.ctx, chain[i].getEncoded());
-                    var rawCertificateChain = allocator.allocateArray(ValueLayout.JAVA_BYTE, chain[i].getEncoded());
-                    var rawCertificateChainPointer = allocator.allocate(ValueLayout.ADDRESS, rawCertificateChain);
-                    var x509certChain = d2i_X509(MemoryAddress.NULL, rawCertificateChainPointer, rawCertificateChain.byteSize());
-                    if (MemoryAddress.NULL.equals(x509certChain)) {
-                        logLastError(allocator, "openssl.errorLoadingCertificate");
-                        return;
-                    }
-                    // # define SSL_CTX_add0_chain_cert(ctx,x509) SSL_CTX_ctrl(ctx,SSL_CTRL_CHAIN_CERT,0,(char *)(x509))
-                    if (SSL_CTX_ctrl(state.ctx, SSL_CTRL_CHAIN_CERT(), 0, x509certChain) <= 0) {
-                        logLastError(allocator, "openssl.errorAddingCertificate");
-                        return;
-                    }
-                }
-            }
-        }
-    }
-
-
-    private static int getCertificateIndex(SSLHostConfigCertificate certificate) {
-        int result = -1;
-        // If the type is undefined there will only be one certificate (enforced
-        // in SSLHostConfig) so use the RSA slot.
-        if (certificate.getType() == Type.RSA || certificate.getType() == Type.UNDEFINED) {
-            result = SSL_AIDX_RSA;
-        } else if (certificate.getType() == Type.EC) {
-            result = SSL_AIDX_ECC;
-        } else if (certificate.getType() == Type.DSA) {
-            result = SSL_AIDX_DSA;
-        } else {
-            result = SSL_AIDX_MAX;
-        }
-        return result;
-    }
-
-
-    /*
-     * Find a valid alias when none was specified in the config.
-     */
-    private static String findAlias(X509KeyManager keyManager,
-            SSLHostConfigCertificate certificate) {
-
-        Type type = certificate.getType();
-        String result = null;
-
-        List<Type> candidateTypes = new ArrayList<>();
-        if (Type.UNDEFINED.equals(type)) {
-            // Try all types to find an suitable alias
-            candidateTypes.addAll(Arrays.asList(Type.values()));
-            candidateTypes.remove(Type.UNDEFINED);
-        } else {
-            // Look for the specific type to find a suitable alias
-            candidateTypes.add(type);
-        }
-
-        Iterator<Type> iter = candidateTypes.iterator();
-        while (result == null && iter.hasNext()) {
-            result = keyManager.chooseServerAlias(iter.next().toString(),  null,  null);
-        }
-
-        return result;
-    }
-
-    private static X509TrustManager chooseTrustManager(TrustManager[] managers) {
-        for (TrustManager m : managers) {
-            if (m instanceof X509TrustManager) {
-                return (X509TrustManager) m;
-            }
-        }
-        throw new IllegalStateException(sm.getString("openssl.trustManagerMissing"));
-    }
-
-    private static X509Certificate[] certificates(byte[][] chain) {
-        X509Certificate[] peerCerts = new X509Certificate[chain.length];
-        for (int i = 0; i < peerCerts.length; i++) {
-            peerCerts[i] = new OpenSSLX509Certificate(chain[i]);
-        }
-        return peerCerts;
-    }
-
-
-    private static void logLastError(SegmentAllocator allocator, String string) {
-        var buf = allocator.allocateArray(ValueLayout.JAVA_BYTE, new byte[128]);
-        ERR_error_string(ERR_get_error(), buf);
-        String err = buf.getUtf8String(0);
-        log.error(sm.getString(string, err));
-    }
-
-
-    @Override
-    public SSLSessionContext getServerSessionContext() {
-        return sessionContext;
-    }
-
-    @Override
-    public SSLEngine createSSLEngine() {
-        return new OpenSSLEngine(cleaner, state.ctx, defaultProtocol, false, sessionContext,
-                (negotiableProtocols != null && negotiableProtocols.size() > 0), initialized,
-                sslHostConfig.getCertificateVerificationDepth(),
-                sslHostConfig.getCertificateVerification() == CertificateVerification.OPTIONAL_NO_CA,
-                noOcspCheck);
-    }
-
-    @Override
-    public SSLServerSocketFactory getServerSocketFactory() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public SSLParameters getSupportedSSLParameters() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public X509Certificate[] getCertificateChain(String alias) {
-        X509Certificate[] chain = null;
-        X509KeyManager x509KeyManager = certificate.getCertificateKeyManager();
-        if (x509KeyManager != null) {
-            if (alias == null) {
-                alias = "tomcat";
-            }
-            chain = x509KeyManager.getCertificateChain(alias);
-            if (chain == null) {
-                alias = findAlias(x509KeyManager, certificate);
-                chain = x509KeyManager.getCertificateChain(alias);
-            }
-        }
-
-        return chain;
-    }
-
-    @Override
-    public X509Certificate[] getAcceptedIssuers() {
-        X509Certificate[] acceptedCerts = null;
-        if (x509TrustManager != null) {
-            acceptedCerts = x509TrustManager.getAcceptedIssuers();
-        }
-        return acceptedCerts;
-    }
-
-
-    private static class OpenSSLState implements Runnable {
-
-        final ResourceScope scope;
-        // SSL context
-        final MemoryAddress ctx;
-        // OpenSSLConfCmd context
-        final MemoryAddress cctx;
-
-        private OpenSSLState(ResourceScope scope, MemoryAddress cctx, MemoryAddress ctx) {
-            this.scope = scope;
-            this.cctx = cctx;
-            this.ctx = ctx;
-        }
-
-        @Override
-        public void run() {
-            try {
-                SSL_CTX_free(ctx);
-                if (!MemoryAddress.NULL.equals(cctx)) {
-                    SSL_CONF_CTX_free(cctx);
-                }
-            } finally {
-                scope.close();
-            }
-        }
-    }
-}

==================================================
OpenSSLImplementation.java
deleted file mode 100644
index 1ccca9a08d..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLEngine.java
+++ /dev/null
@@ -1,1881 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.net.openssl.panama;
-
-import java.io.ByteArrayOutputStream;
-import java.io.InputStream;
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodHandles;
-import java.lang.invoke.MethodType;
-import java.lang.ref.Cleaner;
-import java.lang.ref.Cleaner.Cleanable;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.nio.ByteBuffer;
-import java.nio.ReadOnlyBufferException;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import javax.net.ssl.SSLEngine;
-import javax.net.ssl.SSLEngineResult;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSessionBindingEvent;
-import javax.net.ssl.SSLSessionBindingListener;
-import javax.net.ssl.SSLSessionContext;
-
-import jdk.incubator.foreign.CLinker;
-import jdk.incubator.foreign.FunctionDescriptor;
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.NativeSymbol;
-import jdk.incubator.foreign.ResourceScope;
-import jdk.incubator.foreign.SegmentAllocator;
-import jdk.incubator.foreign.ValueLayout;
-
-import static org.apache.tomcat.util.openssl.openssl_h.*;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.buf.ByteBufferUtils;
-import org.apache.tomcat.util.net.Constants;
-import org.apache.tomcat.util.net.SSLUtil;
-import org.apache.tomcat.util.net.openssl.ciphers.OpenSSLCipherConfigurationParser;
-import org.apache.tomcat.util.res.StringManager;
-
-/**
- * Implements a {@link SSLEngine} using
- * <a href="https://www.openssl.org/docs/crypto/BIO_s_bio.html#EXAMPLE">OpenSSL
- * BIO abstractions</a>.
- */
-public final class OpenSSLEngine extends SSLEngine implements SSLUtil.ProtocolInfo {
-
-    private static final Log logger = LogFactory.getLog(OpenSSLEngine.class);
-    private static final StringManager sm = StringManager.getManager(OpenSSLEngine.class);
-
-    private static final Certificate[] EMPTY_CERTIFICATES = new Certificate[0];
-
-    public static final Set<String> AVAILABLE_CIPHER_SUITES;
-
-    public static final Set<String> IMPLEMENTED_PROTOCOLS_SET;
-
-    private static final MethodHandle openSSLCallbackInfoHandle;
-    private static final MethodHandle openSSLCallbackVerifyHandle;
-
-    private static final FunctionDescriptor openSSLCallbackInfoFunctionDescriptor =
-            FunctionDescriptor.ofVoid(ValueLayout.ADDRESS, ValueLayout.JAVA_INT, ValueLayout.JAVA_INT);
-    private static final FunctionDescriptor openSSLCallbackVerifyFunctionDescriptor =
-            FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.ADDRESS);
-
-    static {
-        MethodHandles.Lookup lookup = MethodHandles.lookup();
-        try {
-            openSSLCallbackInfoHandle = lookup.findVirtual(OpenSSLEngine.class, "openSSLCallbackInfo",
-                    MethodType.methodType(void.class, MemoryAddress.class, int.class, int.class));
-            openSSLCallbackVerifyHandle = lookup.findVirtual(OpenSSLEngine.class, "openSSLCallbackVerify",
-                    MethodType.methodType(int.class, int.class, MemoryAddress.class));
-        } catch (Exception e) {
-            throw new IllegalStateException(e);
-        }
-
-        OpenSSLLifecycleListener.initLibrary();
-
-        final Set<String> availableCipherSuites = new LinkedHashSet<>(128);
-        try (var scope = ResourceScope.newConfinedScope()) {
-            var allocator = SegmentAllocator.nativeAllocator(scope);
-            var sslCtx = SSL_CTX_new(TLS_server_method());
-            try {
-                SSL_CTX_set_options(sslCtx, SSL_OP_ALL());
-                SSL_CTX_set_cipher_list(sslCtx, allocator.allocateUtf8String("ALL"));
-                var ssl = SSL_new(sslCtx);
-                SSL_set_accept_state(ssl);
-                try {
-                    for (String c : getCiphers(ssl)) {
-                        // Filter out bad input.
-                        if (c == null || c.length() == 0 || availableCipherSuites.contains(c)) {
-                            continue;
-                        }
-                        availableCipherSuites.add(OpenSSLCipherConfigurationParser.openSSLToJsse(c));
-                    }
-                } finally {
-                    SSL_free(ssl);
-                }
-            } finally {
-                SSL_CTX_free(sslCtx);
-            }
-        } catch (Exception e) {
-            logger.warn(sm.getString("engine.ciphersFailure"), e);
-        }
-        AVAILABLE_CIPHER_SUITES = Collections.unmodifiableSet(availableCipherSuites);
-
-        HashSet<String> protocols = new HashSet<>();
-        protocols.add(Constants.SSL_PROTO_SSLv2Hello);
-        protocols.add(Constants.SSL_PROTO_SSLv2);
-        protocols.add(Constants.SSL_PROTO_SSLv3);
-        protocols.add(Constants.SSL_PROTO_TLSv1);
-        protocols.add(Constants.SSL_PROTO_TLSv1_1);
-        protocols.add(Constants.SSL_PROTO_TLSv1_2);
-        protocols.add(Constants.SSL_PROTO_TLSv1_3);
-        IMPLEMENTED_PROTOCOLS_SET = Collections.unmodifiableSet(protocols);
-    }
-
-    private static String[] getCiphers(MemoryAddress ssl) {
-        MemoryAddress sk = SSL_get_ciphers(ssl);
-        int len = OPENSSL_sk_num(sk);
-        if (len <= 0) {
-            return null;
-        }
-        ArrayList<String> ciphers = new ArrayList<>(len);
-        for (int i = 0; i < len; i++) {
-            MemoryAddress cipher = OPENSSL_sk_value(sk, i);
-            MemoryAddress cipherName = SSL_CIPHER_get_name(cipher);
-            ciphers.add(cipherName.getUtf8String(0));
-        }
-        return ciphers.toArray(new String[0]);
-    }
-
-    private static final int MAX_PLAINTEXT_LENGTH = 16 * 1024; // 2^14
-    private static final int MAX_COMPRESSED_LENGTH = MAX_PLAINTEXT_LENGTH + 1024;
-    private static final int MAX_CIPHERTEXT_LENGTH = MAX_COMPRESSED_LENGTH + 1024;
-
-    // Protocols
-    static final int VERIFY_DEPTH = 10;
-
-    // Header (5) + Data (2^14) + Compression (1024) + Encryption (1024) + MAC (20) + Padding (256)
-    static final int MAX_ENCRYPTED_PACKET_LENGTH = MAX_CIPHERTEXT_LENGTH + 5 + 20 + 256;
-
-    static final int MAX_ENCRYPTION_OVERHEAD_LENGTH = MAX_ENCRYPTED_PACKET_LENGTH - MAX_PLAINTEXT_LENGTH;
-
-    enum ClientAuthMode {
-        NONE,
-        OPTIONAL,
-        REQUIRE,
-    }
-
-    private static final String INVALID_CIPHER = "SSL_NULL_WITH_NULL_NULL";
-
-    private final OpenSSLState state;
-    private final Cleanable cleanable;
-
-    private enum Accepted { NOT, IMPLICIT, EXPLICIT }
-    private Accepted accepted = Accepted.NOT;
-    private enum PHAState { NONE, START, COMPLETE }
-    private PHAState phaState = PHAState.NONE;
-    private boolean handshakeFinished;
-    private int currentHandshake;
-    private int handshakeCount = 0;
-    private boolean receivedShutdown;
-    private volatile boolean destroyed;
-
-    // Use an invalid cipherSuite until the handshake is completed
-    // See http://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html#getSession()
-    private volatile String version;
-    private volatile String cipher;
-    private volatile String applicationProtocol;
-
-    private volatile Certificate[] peerCerts;
-    @Deprecated
-    private volatile javax.security.cert.X509Certificate[] x509PeerCerts;
-    private volatile ClientAuthMode clientAuth = ClientAuthMode.NONE;
-
-    // SSL Engine status variables
-    private boolean isInboundDone;
-    private boolean isOutboundDone;
-    private boolean engineClosed;
-    private boolean sendHandshakeError = false;
-
-    private final boolean clientMode;
-    private final boolean noOcspCheck;
-    private final String fallbackApplicationProtocol;
-    private final OpenSSLSessionContext sessionContext;
-    private final boolean alpn;
-    private final boolean initialized;
-    private final boolean certificateVerificationOptionalNoCA;
-    private final int certificateVerificationDepth;
-
-    private int certificateVerifyMode = 0;
-
-    private String selectedProtocol = null;
-
-    private final OpenSSLSession session;
-
-    /**
-     * Creates a new instance
-     *
-     * @param cleaner   Used to clean up references to instances before they are
-     *                  garbage collected
-     * @param sslCtx an OpenSSL {@code SSL_CTX} object
-     * @param fallbackApplicationProtocol the fallback application protocol
-     * @param clientMode {@code true} if this is used for clients, {@code false}
-     * otherwise
-     * @param sessionContext the {@link OpenSSLSessionContext} this
-     * {@link SSLEngine} belongs to.
-     * @param alpn {@code true} if alpn should be used, {@code false}
-     * otherwise
-     * @param initialized {@code true} if this instance gets its protocol,
-     * cipher and client verification from the {@code SSL_CTX} {@code sslCtx}
-     * @param certificateVerificationDepth Certificate verification depth
-     * @param certificateVerificationOptionalNoCA Skip CA verification in
-     *   optional mode
-     */
-    OpenSSLEngine(Cleaner cleaner, MemoryAddress sslCtx, String fallbackApplicationProtocol,
-            boolean clientMode, OpenSSLSessionContext sessionContext, boolean alpn,
-            boolean initialized, int certificateVerificationDepth,
-            boolean certificateVerificationOptionalNoCA, boolean noOcspCheck) {
-        if (sslCtx == null) {
-            throw new IllegalArgumentException(sm.getString("engine.noSSLContext"));
-        }
-        ResourceScope scope = ResourceScope.newSharedScope();
-        var allocator = SegmentAllocator.nativeAllocator(scope);
-        session = new OpenSSLSession();
-        var ssl = SSL_new(sslCtx);
-        this.certificateVerificationDepth = certificateVerificationDepth;
-        // Set ssl_info_callback
-        NativeSymbol openSSLCallbackInfo = CLinker.systemCLinker().upcallStub(openSSLCallbackInfoHandle.bindTo(this),
-                openSSLCallbackInfoFunctionDescriptor, scope);
-        SSL_set_info_callback(ssl, openSSLCallbackInfo);
-        if (clientMode) {
-            SSL_set_connect_state(ssl);
-        } else {
-            SSL_set_accept_state(ssl);
-        }
-        SSL_set_verify_result(ssl, X509_V_OK());
-        var internalBIOPointer = allocator.allocate(ValueLayout.ADDRESS);
-        var networkBIOPointer = allocator.allocate(ValueLayout.ADDRESS);
-        BIO_new_bio_pair(internalBIOPointer, 0, networkBIOPointer, 0);
-        var internalBIO = internalBIOPointer.get(ValueLayout.ADDRESS, 0);
-        var networkBIO = networkBIOPointer.get(ValueLayout.ADDRESS, 0);
-        SSL_set_bio(ssl, internalBIO, internalBIO);
-        state = new OpenSSLState(scope, ssl, networkBIO);
-        cleanable = cleaner.register(this, state);
-        this.fallbackApplicationProtocol = fallbackApplicationProtocol;
-        this.clientMode = clientMode;
-        this.sessionContext = sessionContext;
-        this.alpn = alpn;
-        this.initialized = initialized;
-        this.certificateVerificationOptionalNoCA = certificateVerificationOptionalNoCA;
-        this.noOcspCheck = noOcspCheck;
-    }
-
-    @Override
-    public String getNegotiatedProtocol() {
-        return selectedProtocol;
-    }
-
-    /**
-     * Destroys this engine.
-     */
-    public synchronized void shutdown() {
-        if (!destroyed) {
-            destroyed = true;
-            cleanable.clean();
-            // internal errors can cause shutdown without marking the engine closed
-            isInboundDone = isOutboundDone = engineClosed = true;
-        }
-    }
-
-    /**
-     * Write plain text data to the OpenSSL internal BIO
-     *
-     * Calling this function with src.remaining == 0 is undefined.
-     * @throws SSLException if the OpenSSL error check fails
-     */
-    private int writePlaintextData(final MemoryAddress ssl, final ByteBuffer src) throws SSLException {
-        clearLastError();
-        final int pos = src.position();
-        final int limit = src.limit();
-        final int len = Math.min(limit - pos, MAX_PLAINTEXT_LENGTH);
-        final int sslWrote;
-
-        if (src.isDirect()) {
-            sslWrote = SSL_write(ssl, MemorySegment.ofByteBuffer(src), len);
-            if (sslWrote > 0) {
-                src.position(pos + sslWrote);
-                return sslWrote;
-            } else {
-                checkLastError();
-            }
-        } else {
-            try (var scope = ResourceScope.newConfinedScope()) {
-                var allocator = SegmentAllocator.nativeAllocator(scope);
-                MemorySegment bufSegment = allocator.allocateArray(ValueLayout.JAVA_BYTE, len);
-                MemorySegment.copy(src.array(), pos, bufSegment, ValueLayout.JAVA_BYTE, 0, len);
-                sslWrote = SSL_write(ssl, bufSegment, len);
-                if (sslWrote > 0) {
-                    src.position(pos + sslWrote);
-                    return sslWrote;
-                } else {
-                    checkLastError();
-                }
-            }
-        }
-
-        return 0;
-    }
-
-    /**
-     * Write encrypted data to the OpenSSL network BIO.
-     * @throws SSLException if the OpenSSL error check fails
-     */
-    private int writeEncryptedData(final MemoryAddress networkBIO, final ByteBuffer src) throws SSLException {
-        clearLastError();
-        final int pos = src.position();
-        final int len = src.remaining();
-        if (src.isDirect()) {
-            final int netWrote = BIO_write(networkBIO, MemorySegment.ofByteBuffer(src), len);
-            if (netWrote > 0) {
-                src.position(pos + netWrote);
-                return netWrote;
-            } else {
-                checkLastError();
-            }
-        } else {
-            // This uses unsafe and does not need to be used: the connector should be configured with direct buffers
-            ByteBuffer buf = ByteBuffer.allocateDirect(len);
-            try {
-                buf.put(src);
-                buf.flip();
-                final int netWrote = BIO_write(networkBIO, MemorySegment.ofByteBuffer(buf), len);
-                if (netWrote > 0) {
-                    src.position(pos + netWrote);
-                    return netWrote;
-                } else {
-                    src.position(pos);
-                    checkLastError();
-                }
-            } finally {
-                buf.clear();
-                ByteBufferUtils.cleanDirectBuffer(buf);
-            }
-        }
-
-        return 0;
-    }
-
-    /**
-     * Read plain text data from the OpenSSL internal BIO
-     * @throws SSLException if the OpenSSL error check fails
-     */
-    private int readPlaintextData(final MemoryAddress ssl, final ByteBuffer dst) throws SSLException {
-        clearLastError();
-        final int pos = dst.position();
-
-        if (dst.isDirect()) {
-            final int len = dst.remaining();
-            final int sslRead = SSL_read(ssl, MemorySegment.ofByteBuffer(dst), len);
-            if (sslRead > 0) {
-                dst.position(dst.position() + sslRead);
-                return sslRead;
-            } else {
-                checkLastError();
-            }
-        } else {
-            final int limit = dst.limit();
-            final int len = Math.min(MAX_ENCRYPTED_PACKET_LENGTH, limit - pos);
-            try (var scope = ResourceScope.newConfinedScope()) {
-                var allocator = SegmentAllocator.nativeAllocator(scope);
-                MemorySegment bufSegment = allocator.allocateArray(ValueLayout.JAVA_BYTE, len);
-                final int sslRead = SSL_read(ssl, bufSegment, len);
-                if (sslRead > 0) {
-                    MemorySegment.copy(bufSegment, ValueLayout.JAVA_BYTE, 0, dst.array(), pos, sslRead);
-                    dst.position(dst.position() + sslRead);
-                    return sslRead;
-                } else {
-                    checkLastError();
-                }
-            }
-        }
-
-        return 0;
-    }
-
-    /**
-     * Read encrypted data from the OpenSSL network BIO
-     * @throws SSLException if the OpenSSL error check fails
-     */
-    private int readEncryptedData(final MemoryAddress networkBIO, final ByteBuffer dst, final int pending) throws SSLException {
-        clearLastError();
-        if (dst.isDirect()) {
-            final int pos = dst.position();
-            final int bioRead = BIO_read(networkBIO, MemorySegment.ofByteBuffer(dst), pending);
-            if (bioRead > 0) {
-                dst.position(pos + bioRead);
-                return bioRead;
-            } else {
-                checkLastError();
-            }
-        } else {
-            // This uses unsafe and does not need to be used: the connector should be configured with direct buffers
-            final ByteBuffer buf = ByteBuffer.allocateDirect(pending);
-            try {
-                final int bioRead = BIO_read(networkBIO, MemorySegment.ofByteBuffer(buf), pending);
-                if (bioRead > 0) {
-                    buf.limit(bioRead);
-                    int oldLimit = dst.limit();
-                    dst.limit(dst.position() + bioRead);
-                    dst.put(buf);
-                    dst.limit(oldLimit);
-                    return bioRead;
-                } else {
-                    checkLastError();
-                }
-            } finally {
-                buf.clear();
-                ByteBufferUtils.cleanDirectBuffer(buf);
-            }
-        }
-
-        return 0;
-    }
-
-    @Override
-    public synchronized SSLEngineResult wrap(final ByteBuffer[] srcs, final int offset, final int length, final ByteBuffer dst) throws SSLException {
-        // Check to make sure the engine has not been closed
-        if (destroyed) {
-            return new SSLEngineResult(SSLEngineResult.Status.CLOSED, SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING, 0, 0);
-        }
-
-        // Throw required runtime exceptions
-        if (srcs == null || dst == null) {
-            throw new IllegalArgumentException(sm.getString("engine.nullBuffer"));
-        }
-        if (offset >= srcs.length || offset + length > srcs.length) {
-            throw new IndexOutOfBoundsException(sm.getString("engine.invalidBufferArray",
-                    Integer.toString(offset), Integer.toString(length),
-                    Integer.toString(srcs.length)));
-        }
-        if (dst.isReadOnly()) {
-            throw new ReadOnlyBufferException();
-        }
-        // Prepare OpenSSL to work in server mode and receive handshake
-        if (accepted == Accepted.NOT) {
-            beginHandshakeImplicitly();
-        }
-
-        // In handshake or close_notify stages, check if call to wrap was made
-        // without regard to the handshake status.
-        SSLEngineResult.HandshakeStatus handshakeStatus = getHandshakeStatus();
-
-        if ((!handshakeFinished || engineClosed) && handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
-            return new SSLEngineResult(getEngineStatus(), SSLEngineResult.HandshakeStatus.NEED_UNWRAP, 0, 0);
-        }
-
-        int bytesProduced = 0;
-        int pendingNet;
-
-        // Check for pending data in the network BIO
-        pendingNet = (int) BIO_ctrl_pending(state.networkBIO);
-        if (pendingNet > 0) {
-            // Do we have enough room in destination to write encrypted data?
-            int capacity = dst.remaining();
-            if (capacity < pendingNet) {
-                return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW, handshakeStatus, 0, 0);
-            }
-
-            // Write the pending data from the network BIO into the dst buffer
-            try {
-                bytesProduced = readEncryptedData(state.networkBIO, dst, pendingNet);
-            } catch (Exception e) {
-                throw new SSLException(e);
-            }
-
-            // If isOutboundDone is set, then the data from the network BIO
-            // was the close_notify message -- we are not required to wait
-            // for the receipt the peer's close_notify message -- shutdown.
-            if (isOutboundDone) {
-                shutdown();
-            }
-
-            return new SSLEngineResult(getEngineStatus(), getHandshakeStatus(), 0, bytesProduced);
-        }
-
-        // There was no pending data in the network BIO -- encrypt any application data
-        int bytesConsumed = 0;
-        int endOffset = offset + length;
-        for (int i = offset; i < endOffset; ++i) {
-            final ByteBuffer src = srcs[i];
-            if (src == null) {
-                throw new IllegalArgumentException(sm.getString("engine.nullBufferInArray"));
-            }
-            while (src.hasRemaining()) {
-
-                int bytesWritten = 0;
-                // Write plain text application data to the SSL engine
-                try {
-                    bytesWritten = writePlaintextData(state.ssl, src);
-                    bytesConsumed += bytesWritten;
-                } catch (Exception e) {
-                    throw new SSLException(e);
-                }
-
-                if (bytesWritten == 0) {
-                    throw new IllegalStateException(sm.getString("engine.failedToWriteBytes"));
-                }
-
-                // Check to see if the engine wrote data into the network BIO
-                pendingNet = (int) BIO_ctrl_pending(state.networkBIO);
-                if (pendingNet > 0) {
-                    // Do we have enough room in dst to write encrypted data?
-                    int capacity = dst.remaining();
-                    if (capacity < pendingNet) {
-                        return new SSLEngineResult(
-                                SSLEngineResult.Status.BUFFER_OVERFLOW, getHandshakeStatus(), bytesConsumed, bytesProduced);
-                    }
-
-                    // Write the pending data from the network BIO into the dst buffer
-                    try {
-                        bytesProduced += readEncryptedData(state.networkBIO, dst, pendingNet);
-                    } catch (Exception e) {
-                        throw new SSLException(e);
-                    }
-
-                    return new SSLEngineResult(getEngineStatus(), getHandshakeStatus(), bytesConsumed, bytesProduced);
-                }
-            }
-        }
-
-        return new SSLEngineResult(getEngineStatus(), getHandshakeStatus(), bytesConsumed, bytesProduced);
-    }
-
-    @Override
-    public synchronized SSLEngineResult unwrap(final ByteBuffer src, final ByteBuffer[] dsts, final int offset, final int length) throws SSLException {
-        // Check to make sure the engine has not been closed
-        if (destroyed) {
-            return new SSLEngineResult(SSLEngineResult.Status.CLOSED, SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING, 0, 0);
-        }
-
-        // Throw required runtime exceptions
-        if (src == null || dsts == null) {
-            throw new IllegalArgumentException(sm.getString("engine.nullBuffer"));
-        }
-        if (offset >= dsts.length || offset + length > dsts.length) {
-            throw new IndexOutOfBoundsException(sm.getString("engine.invalidBufferArray",
-                    Integer.toString(offset), Integer.toString(length),
-                    Integer.toString(dsts.length)));
-        }
-        int capacity = 0;
-        final int endOffset = offset + length;
-        for (int i = offset; i < endOffset; i++) {
-            ByteBuffer dst = dsts[i];
-            if (dst == null) {
-                throw new IllegalArgumentException(sm.getString("engine.nullBufferInArray"));
-            }
-            if (dst.isReadOnly()) {
-                throw new ReadOnlyBufferException();
-            }
-            capacity += dst.remaining();
-        }
-
-        // Prepare OpenSSL to work in server mode and receive handshake
-        if (accepted == Accepted.NOT) {
-            beginHandshakeImplicitly();
-        }
-
-        // In handshake or close_notify stages, check if call to unwrap was made
-        // without regard to the handshake status.
-        SSLEngineResult.HandshakeStatus handshakeStatus = getHandshakeStatus();
-        if ((!handshakeFinished || engineClosed) && handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
-            return new SSLEngineResult(getEngineStatus(), SSLEngineResult.HandshakeStatus.NEED_WRAP, 0, 0);
-        }
-
-        int len = src.remaining();
-
-        // protect against protocol overflow attack vector
-        if (len > MAX_ENCRYPTED_PACKET_LENGTH) {
-            isInboundDone = true;
-            isOutboundDone = true;
-            engineClosed = true;
-            shutdown();
-            throw new SSLException(sm.getString("engine.oversizedPacket"));
-        }
-
-        // Write encrypted data to network BIO
-        int written = 0;
-        try {
-            written = writeEncryptedData(state.networkBIO, src);
-        } catch (Exception e) {
-            throw new SSLException(e);
-        }
-
-        // There won't be any application data until we're done handshaking
-        //
-        // We first check handshakeFinished to eliminate the overhead of extra JNI call if possible.
-        int pendingApp = pendingReadableBytesInSSL();
-        if (!handshakeFinished) {
-            pendingApp = 0;
-        }
-        int bytesProduced = 0;
-        int idx = offset;
-        // Do we have enough room in dsts to write decrypted data?
-        if (capacity == 0) {
-            return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW, getHandshakeStatus(), written, 0);
-        }
-
-        while (pendingApp > 0) {
-            if (idx == endOffset) {
-                // Destination buffer state changed (no remaining space although
-                // capacity is still available), so break loop with an error
-                throw new IllegalStateException(sm.getString("engine.invalidDestinationBuffersState"));
-            }
-            // Write decrypted data to dsts buffers
-            while (idx < endOffset) {
-                ByteBuffer dst = dsts[idx];
-                if (!dst.hasRemaining()) {
-                    idx++;
-                    continue;
-                }
-
-                if (pendingApp <= 0) {
-                    break;
-                }
-
-                int bytesRead;
-                try {
-                    bytesRead = readPlaintextData(state.ssl, dst);
-                } catch (Exception e) {
-                    throw new SSLException(e);
-                }
-
-                if (bytesRead == 0) {
-                    // This should not be possible. pendingApp is positive
-                    // therefore the read should have read at least one byte.
-                    throw new IllegalStateException(sm.getString("engine.failedToReadAvailableBytes"));
-                }
-
-                bytesProduced += bytesRead;
-                pendingApp -= bytesRead;
-                capacity -= bytesRead;
-
-                if (!dst.hasRemaining()) {
-                    idx++;
-                }
-            }
-            if (capacity == 0) {
-                break;
-            } else if (pendingApp == 0) {
-                pendingApp = pendingReadableBytesInSSL();
-            }
-        }
-
-        // Check to see if we received a close_notify message from the peer
-        if (!receivedShutdown && (SSL_get_shutdown(state.ssl) & SSL_RECEIVED_SHUTDOWN()) == SSL_RECEIVED_SHUTDOWN()) {
-            receivedShutdown = true;
-            closeOutbound();
-            closeInbound();
-        }
-
-        if (bytesProduced == 0 && (written == 0 || (written > 0 && !src.hasRemaining() && handshakeFinished))) {
-            return new SSLEngineResult(SSLEngineResult.Status.BUFFER_UNDERFLOW, getHandshakeStatus(), written, 0);
-        } else {
-            return new SSLEngineResult(getEngineStatus(), getHandshakeStatus(), written, bytesProduced);
-        }
-    }
-
-    private int pendingReadableBytesInSSL()
-            throws SSLException {
-        // NOTE: Calling a fake read is necessary before calling pendingReadableBytesInSSL because
-        // SSL_pending will return 0 if OpenSSL has not started the current TLS record
-        // See https://www.openssl.org/docs/manmaster/man3/SSL_pending.html
-        clearLastError();
-        int lastPrimingReadResult = SSL_read(state.ssl, MemoryAddress.NULL, 0); // priming read
-        // check if SSL_read returned <= 0. In this case we need to check the error and see if it was something
-        // fatal.
-        if (lastPrimingReadResult <= 0) {
-            checkLastError();
-        }
-        int pendingReadableBytesInSSL = SSL_pending(state.ssl);
-
-        // TLS 1.0 needs additional handling
-        if (Constants.SSL_PROTO_TLSv1.equals(version) && lastPrimingReadResult == 0 &&
-                pendingReadableBytesInSSL == 0) {
-            // Perform another priming read
-            lastPrimingReadResult = SSL_read(state.ssl, MemoryAddress.NULL, 0);
-            if (lastPrimingReadResult <= 0) {
-                checkLastError();
-            }
-            pendingReadableBytesInSSL = SSL_pending(state.ssl);
-        }
-
-        return pendingReadableBytesInSSL;
-    }
-
-    @Override
-    public Runnable getDelegatedTask() {
-        // Currently, we do not delegate SSL computation tasks
-        return null;
-    }
-
-    @Override
-    public synchronized void closeInbound() throws SSLException {
-        if (isInboundDone) {
-            return;
-        }
-
-        isInboundDone = true;
-        engineClosed = true;
-
-        shutdown();
-
-        if (accepted != Accepted.NOT && !receivedShutdown) {
-            throw new SSLException(sm.getString("engine.inboundClose"));
-        }
-    }
-
-    @Override
-    public synchronized boolean isInboundDone() {
-        return isInboundDone || engineClosed;
-    }
-
-    @Override
-    public synchronized void closeOutbound() {
-        if (isOutboundDone) {
-            return;
-        }
-
-        isOutboundDone = true;
-        engineClosed = true;
-
-        if (accepted != Accepted.NOT && !destroyed) {
-            int mode = SSL_get_shutdown(state.ssl);
-            if ((mode & SSL_SENT_SHUTDOWN()) != SSL_SENT_SHUTDOWN()) {
-                SSL_shutdown(state.ssl);
-            }
-        } else {
-            // engine closing before initial handshake
-            shutdown();
-        }
-    }
-
-    @Override
-    public synchronized boolean isOutboundDone() {
-        return isOutboundDone;
-    }
-
-    @Override
-    public String[] getSupportedCipherSuites() {
-        Set<String> availableCipherSuites = AVAILABLE_CIPHER_SUITES;
-        return availableCipherSuites.toArray(new String[0]);
-    }
-
-    @Override
-    public synchronized String[] getEnabledCipherSuites() {
-        if (destroyed) {
-            return new String[0];
-        }
-        String[] enabled = getCiphers(state.ssl);
-        if (enabled == null) {
-            return new String[0];
-        } else {
-            for (int i = 0; i < enabled.length; i++) {
-                String mapped = OpenSSLCipherConfigurationParser.openSSLToJsse(enabled[i]);
-                if (mapped != null) {
-                    enabled[i] = mapped;
-                }
-            }
-            return enabled;
-        }
-    }
-
-    @Override
-    public synchronized void setEnabledCipherSuites(String[] cipherSuites) {
-        if (initialized) {
-            return;
-        }
-        if (cipherSuites == null) {
-            throw new IllegalArgumentException(sm.getString("engine.nullCipherSuite"));
-        }
-        if (destroyed) {
-            return;
-        }
-        final StringBuilder buf = new StringBuilder();
-        for (String cipherSuite : cipherSuites) {
-            if (cipherSuite == null) {
-                break;
-            }
-            String converted = OpenSSLCipherConfigurationParser.jsseToOpenSSL(cipherSuite);
-            if (!AVAILABLE_CIPHER_SUITES.contains(cipherSuite)) {
-                logger.debug(sm.getString("engine.unsupportedCipher", cipherSuite, converted));
-            }
-            if (converted != null) {
-                cipherSuite = converted;
-            }
-
-            buf.append(cipherSuite);
-            buf.append(':');
-        }
-
-        if (buf.length() == 0) {
-            throw new IllegalArgumentException(sm.getString("engine.emptyCipherSuite"));
-        }
-        buf.setLength(buf.length() - 1);
-
-        final String cipherSuiteSpec = buf.toString();
-        try {
-            SSL_set_cipher_list(state.ssl, SegmentAllocator.nativeAllocator(state.scope)
-                    .allocateUtf8String(cipherSuiteSpec));
-        } catch (Exception e) {
-            throw new IllegalStateException(sm.getString("engine.failedCipherSuite", cipherSuiteSpec), e);
-        }
-    }
-
-    @Override
-    public String[] getSupportedProtocols() {
-        return IMPLEMENTED_PROTOCOLS_SET.toArray(new String[0]);
-    }
-
-    @Override
-    public synchronized String[] getEnabledProtocols() {
-        if (destroyed) {
-            return new String[0];
-        }
-        List<String> enabled = new ArrayList<>();
-        // Seems like there is no way to explicitly disable SSLv2Hello in OpenSSL so it is always enabled
-        enabled.add(Constants.SSL_PROTO_SSLv2Hello);
-        long opts = SSL_get_options(state.ssl);
-        if ((opts & SSL_OP_NO_TLSv1()) == 0) {
-            enabled.add(Constants.SSL_PROTO_TLSv1);
-        }
-        if ((opts & SSL_OP_NO_TLSv1_1()) == 0) {
-            enabled.add(Constants.SSL_PROTO_TLSv1_1);
-        }
-        if ((opts & SSL_OP_NO_TLSv1_2()) == 0) {
-            enabled.add(Constants.SSL_PROTO_TLSv1_2);
-        }
-        if ((opts & SSL_OP_NO_TLSv1_3()) == 0) {
-            enabled.add(Constants.SSL_PROTO_TLSv1_3);
-        }
-        if ((opts & SSL_OP_NO_SSLv2()) == 0) {
-            enabled.add(Constants.SSL_PROTO_SSLv2);
-        }
-        if ((opts & SSL_OP_NO_SSLv3()) == 0) {
-            enabled.add(Constants.SSL_PROTO_SSLv3);
-        }
-        int size = enabled.size();
-        if (size == 0) {
-            return new String[0];
-        } else {
-            return enabled.toArray(new String[size]);
-        }
-    }
-
-    @Override
-    public synchronized void setEnabledProtocols(String[] protocols) {
-        if (initialized) {
-            return;
-        }
-        if (protocols == null) {
-            // This is correct from the API docs
-            throw new IllegalArgumentException();
-        }
-        if (destroyed) {
-            return;
-        }
-        boolean sslv2 = false;
-        boolean sslv3 = false;
-        boolean tlsv1 = false;
-        boolean tlsv1_1 = false;
-        boolean tlsv1_2 = false;
-        boolean tlsv1_3 = false;
-        for (String p : protocols) {
-            if (!IMPLEMENTED_PROTOCOLS_SET.contains(p)) {
-                throw new IllegalArgumentException(sm.getString("engine.unsupportedProtocol", p));
-            }
-            if (p.equals(Constants.SSL_PROTO_SSLv2)) {
-                sslv2 = true;
-            } else if (p.equals(Constants.SSL_PROTO_SSLv3)) {
-                sslv3 = true;
-            } else if (p.equals(Constants.SSL_PROTO_TLSv1)) {
-                tlsv1 = true;
-            } else if (p.equals(Constants.SSL_PROTO_TLSv1_1)) {
-                tlsv1_1 = true;
-            } else if (p.equals(Constants.SSL_PROTO_TLSv1_2)) {
-                tlsv1_2 = true;
-            } else if (p.equals(Constants.SSL_PROTO_TLSv1_3)) {
-                tlsv1_3 = true;
-            }
-        }
-        // Enable all and then disable what we not want
-        SSL_set_options(state.ssl, SSL_OP_ALL());
-
-        if (!sslv2) {
-            SSL_set_options(state.ssl, SSL_OP_NO_SSLv2());
-        }
-        if (!sslv3) {
-            SSL_set_options(state.ssl, SSL_OP_NO_SSLv3());
-        }
-        if (!tlsv1) {
-            SSL_set_options(state.ssl, SSL_OP_NO_TLSv1());
-        }
-        if (!tlsv1_1) {
-            SSL_set_options(state.ssl, SSL_OP_NO_TLSv1_1());
-        }
-        if (!tlsv1_2) {
-            SSL_set_options(state.ssl, SSL_OP_NO_TLSv1_2());
-        }
-        if (!tlsv1_3) {
-            SSL_set_options(state.ssl, SSL_OP_NO_TLSv1_3());
-        }
-    }
-
-    @Override
-    public SSLSession getSession() {
-        return session;
-    }
-
-    @Override
-    public synchronized void beginHandshake() throws SSLException {
-        if (engineClosed || destroyed) {
-            throw new SSLException(sm.getString("engine.engineClosed"));
-        }
-        switch (accepted) {
-        case NOT:
-            handshake();
-            accepted = Accepted.EXPLICIT;
-            break;
-        case IMPLICIT:
-            // A user did not start handshake by calling this method by themselves,
-            // but handshake has been started already by wrap() or unwrap() implicitly.
-            // Because it's the user's first time to call this method, it is unfair to
-            // raise an exception.  From the user's standpoint, they never asked for
-            // renegotiation.
-
-            accepted = Accepted.EXPLICIT; // Next time this method is invoked by the user, we should raise an exception.
-            break;
-        case EXPLICIT:
-            renegotiate();
-            break;
-        }
-    }
-
-    private byte[] getPeerCertificate() {
-        var allocator = SegmentAllocator.nativeAllocator(state.scope);
-        MemoryAddress/*(X509*)*/ x509 = SSL_get_peer_certificate(state.ssl);
-        MemorySegment bufPointer = allocator.allocate(ValueLayout.ADDRESS, MemoryAddress.NULL);
-        int length = i2d_X509(x509, bufPointer);
-        if (length <= 0) {
-            return null;
-        }
-        MemoryAddress buf = bufPointer.get(ValueLayout.ADDRESS, 0);
-        byte[] certificate = MemorySegment.ofAddressNative(buf, length, state.scope).toArray(ValueLayout.JAVA_BYTE);
-        X509_free(x509);
-        CRYPTO_free(buf, OPENSSL_FILE(), OPENSSL_LINE()); // OPENSSL_free macro
-        return certificate;
-    }
-
-    private byte[][] getPeerCertChain() {
-        MemoryAddress/*STACK_OF(X509)*/ sk = SSL_get_peer_cert_chain(state.ssl);
-        int len = OPENSSL_sk_num(sk);
-        if (len <= 0) {
-            return null;
-        }
-        byte[][] certificateChain = new byte[len][];
-        var allocator = SegmentAllocator.nativeAllocator(state.scope);
-        for (int i = 0; i < len; i++) {
-            MemoryAddress/*(X509*)*/ x509 = OPENSSL_sk_value(sk, i);
-            MemorySegment bufPointer = allocator.allocate(ValueLayout.ADDRESS, MemoryAddress.NULL);
-            int length = i2d_X509(x509, bufPointer);
-            if (length < 0) {
-                certificateChain[i] = new byte[0];
-                continue;
-            }
-            MemoryAddress buf = bufPointer.get(ValueLayout.ADDRESS, 0);
-            byte[] certificate = MemorySegment.ofAddressNative(buf, length, state.scope).toArray(ValueLayout.JAVA_BYTE);
-            certificateChain[i] = certificate;
-            CRYPTO_free(buf, OPENSSL_FILE(), OPENSSL_LINE()); // OPENSSL_free macro
-        }
-        return certificateChain;
-    }
-
-    private String getProtocolNegotiated() {
-        var allocator = SegmentAllocator.nativeAllocator(state.scope);
-        MemorySegment lenAddress = allocator.allocate(ValueLayout.JAVA_INT, 0);
-        MemorySegment protocolPointer = allocator.allocate(ValueLayout.ADDRESS, MemoryAddress.NULL);
-        SSL_get0_alpn_selected(state.ssl, protocolPointer, lenAddress);
-        if (MemoryAddress.NULL.equals(protocolPointer.address())) {
-            SSL_get0_next_proto_negotiated(state.ssl, protocolPointer, lenAddress);
-        }
-        if (MemoryAddress.NULL.equals(protocolPointer.address())) {
-            return null;
-        }
-        int len = lenAddress.get(ValueLayout.JAVA_INT, 0);
-        if (len == 0) {
-            return null;
-        }
-        MemoryAddress protocolAddress = protocolPointer.get(ValueLayout.ADDRESS, 0);
-        byte[] name = MemorySegment.ofAddressNative(protocolAddress, len, state.scope).toArray(ValueLayout.JAVA_BYTE);
-        if (logger.isDebugEnabled()) {
-            logger.debug("Protocol negotiated [" + new String(name) + "]");
-        }
-        return new String(name);
-    }
-
-    private void beginHandshakeImplicitly() throws SSLException {
-        handshake();
-        accepted = Accepted.IMPLICIT;
-    }
-
-    private void handshake() throws SSLException {
-        currentHandshake = handshakeCount;
-        clearLastError();
-        int code = SSL_do_handshake(state.ssl);
-        if (code <= 0) {
-            checkLastError();
-        } else {
-            if (alpn) {
-                selectedProtocol = getProtocolNegotiated();
-            }
-            session.lastAccessedTime = System.currentTimeMillis();
-            // if SSL_do_handshake returns > 0 it means the handshake was finished. This means we can update
-            // handshakeFinished directly and so eliminate unnecessary calls to SSL.isInInit(...)
-            handshakeFinished = true;
-        }
-    }
-
-    private synchronized void renegotiate() throws SSLException {
-        if (logger.isDebugEnabled()) {
-            logger.debug("Start renegotiate");
-        }
-        clearLastError();
-        int code;
-        if (SSL_get_version(state.ssl).getUtf8String(0).equals(Constants.SSL_PROTO_TLSv1_3)) {
-            phaState = PHAState.START;
-            code = SSL_verify_client_post_handshake(state.ssl);
-        } else {
-            code = SSL_renegotiate(state.ssl);
-        }
-        if (code <= 0) {
-            checkLastError();
-        }
-        handshakeFinished = false;
-        peerCerts = null;
-        x509PeerCerts = null;
-        currentHandshake = handshakeCount;
-        int code2 = SSL_do_handshake(state.ssl);
-        if (code2 <= 0) {
-            checkLastError();
-        }
-    }
-
-    private void checkLastError() throws SSLException {
-        String sslError = getLastError();
-        if (sslError != null) {
-            // Many errors can occur during handshake and need to be reported
-            if (!handshakeFinished) {
-                sendHandshakeError = true;
-            } else {
-                throw new SSLException(sslError);
-            }
-        }
-    }
-
-
-    /**
-     * Clear out any errors, but log a warning.
-     */
-    private static void clearLastError() {
-        getLastError();
-    }
-
-    /**
-     * Many calls to SSL methods do not check the last error. Those that do
-     * check the last error need to ensure that any previously ignored error is
-     * cleared prior to the method call else errors may be falsely reported.
-     * Ideally, before any SSL_read, SSL_write, clearLastError should always
-     * be called, and getLastError should be called after on any negative or
-     * zero result.
-     * @return the first error in the stack
-     */
-    private static String getLastError() {
-        String sslError = null;
-        long error = ERR_get_error();
-        if (error != SSL_ERROR_NONE()) {
-            try (var scope = ResourceScope.newConfinedScope()) {
-                var allocator = SegmentAllocator.nativeAllocator(scope);
-                do {
-                    // Loop until getLastErrorNumber() returns SSL_ERROR_NONE
-                    var buf = allocator.allocateArray(ValueLayout.JAVA_BYTE, new byte[128]);
-                    ERR_error_string(error, buf);
-                    String err = buf.getUtf8String(0);
-                    if (sslError == null) {
-                        sslError = err;
-                    }
-                    if (logger.isDebugEnabled()) {
-                        logger.debug(sm.getString("engine.openSSLError", Long.toString(error), err));
-                    }
-                } while ((error = ERR_get_error()) != SSL_ERROR_NONE());
-            }
-        }
-        return sslError;
-    }
-
-    private SSLEngineResult.Status getEngineStatus() {
-        return engineClosed ? SSLEngineResult.Status.CLOSED : SSLEngineResult.Status.OK;
-    }
-
-    @Override
-    public synchronized SSLEngineResult.HandshakeStatus getHandshakeStatus() {
-        if (accepted == Accepted.NOT || destroyed) {
-            return SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
-        }
-
-        // Check if we are in the initial handshake phase
-        if (!handshakeFinished) {
-
-            // There is pending data in the network BIO -- call wrap
-            if (sendHandshakeError || BIO_ctrl_pending(state.networkBIO) != 0) {
-                if (sendHandshakeError) {
-                    // After a last wrap, consider it is going to be done
-                    sendHandshakeError = false;
-                    currentHandshake++;
-                }
-                return SSLEngineResult.HandshakeStatus.NEED_WRAP;
-            }
-
-            /*
-             * Tomcat Native stores a count of the completed handshakes in the
-             * SSL instance and increments it every time a handshake is
-             * completed. Comparing the handshake count when the handshake
-             * started to the current handshake count enables this code to
-             * detect when the handshake has completed.
-             *
-             * Obtaining client certificates after the connection has been
-             * established requires additional checks. We need to trigger
-             * additional reads until the certificates have been read but we
-             * don't know how many reads we will need as it depends on both
-             * client and network behaviour.
-             *
-             * The additional reads are triggered by returning NEED_UNWRAP
-             * rather than FINISHED. This allows the standard I/O code to be
-             * used.
-             *
-             * For TLSv1.2 and below, the handshake completes before the
-             * renegotiation. We therefore use SSL.renegotiatePending() to
-             * check on the current status of the renegotiation and return
-             * NEED_UNWRAP until it completes which means the client
-             * certificates will have been read from the client.
-             *
-             * For TLSv1.3, Tomcat Native sets a flag when post handshake
-             * authentication is started and updates it once the client
-             * certificate has been received. We therefore use
-             * SSL.getPostHandshakeAuthInProgress() to check the current status
-             * and return NEED_UNWRAP until that methods indicates that PHA is
-             * no longer in progress.
-             */
-
-            // No pending data to be sent to the peer
-            // Check to see if we have finished handshaking
-            if (handshakeCount != currentHandshake && SSL_renegotiate_pending(state.ssl) == 0 &&
-                    (phaState != PHAState.START)) {
-                if (alpn) {
-                    selectedProtocol = getProtocolNegotiated();
-                }
-                session.lastAccessedTime = System.currentTimeMillis();
-                version = SSL_get_version(state.ssl).getUtf8String(0);
-                handshakeFinished = true;
-                return SSLEngineResult.HandshakeStatus.FINISHED;
-            }
-
-            // No pending data
-            // Still handshaking / renegotiation / post-handshake auth pending
-            // Must be waiting on the peer to send more data
-            return SSLEngineResult.HandshakeStatus.NEED_UNWRAP;
-        }
-
-        // Check if we are in the shutdown phase
-        if (engineClosed) {
-            // Waiting to send the close_notify message
-            if (BIO_ctrl_pending(state.networkBIO) != 0) {
-                return SSLEngineResult.HandshakeStatus.NEED_WRAP;
-            }
-
-            // Must be waiting to receive the close_notify message
-            return SSLEngineResult.HandshakeStatus.NEED_UNWRAP;
-        }
-
-        return SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
-    }
-
-    @Override
-    public void setUseClientMode(boolean clientMode) {
-        if (clientMode != this.clientMode) {
-            throw new UnsupportedOperationException();
-        }
-    }
-
-    @Override
-    public boolean getUseClientMode() {
-        return clientMode;
-    }
-
-    @Override
-    public void setNeedClientAuth(boolean b) {
-        setClientAuth(b ? ClientAuthMode.REQUIRE : ClientAuthMode.NONE);
-    }
-
-    @Override
-    public boolean getNeedClientAuth() {
-        return clientAuth == ClientAuthMode.REQUIRE;
-    }
-
-    @Override
-    public void setWantClientAuth(boolean b) {
-        setClientAuth(b ? ClientAuthMode.OPTIONAL : ClientAuthMode.NONE);
-    }
-
-    @Override
-    public boolean getWantClientAuth() {
-        return clientAuth == ClientAuthMode.OPTIONAL;
-    }
-
-    private static final int OPTIONAL_NO_CA = 3;
-
-    private void setClientAuth(ClientAuthMode mode) {
-        if (clientMode) {
-            return;
-        }
-        synchronized (this) {
-            if (clientAuth == mode) {
-                return;
-            }
-            certificateVerifyMode = switch (mode) {
-                case NONE -> SSL_VERIFY_NONE();
-                case REQUIRE -> SSL_VERIFY_FAIL_IF_NO_PEER_CERT();
-                case OPTIONAL -> certificateVerificationOptionalNoCA ? OPTIONAL_NO_CA : SSL_VERIFY_PEER();
-            };
-            // SSL.setVerify(state.ssl, value, certificateVerificationDepth);
-            // Set int verify_callback(int preverify_ok, X509_STORE_CTX *x509_ctx) callback
-            NativeSymbol openSSLCallbackVerify =
-                    CLinker.systemCLinker().upcallStub(openSSLCallbackVerifyHandle.bindTo(this),
-                    openSSLCallbackVerifyFunctionDescriptor, state.scope);
-            int value = switch (mode) {
-                case NONE -> SSL_VERIFY_NONE();
-                case REQUIRE -> SSL_VERIFY_PEER() | SSL_VERIFY_FAIL_IF_NO_PEER_CERT();
-                case OPTIONAL -> SSL_VERIFY_PEER();
-            };
-            SSL_set_verify(state.ssl, value, openSSLCallbackVerify);
-            clientAuth = mode;
-        }
-    }
-
-    public synchronized void openSSLCallbackInfo(MemoryAddress ssl, int where, int ret) {
-        if (0 != (where & SSL_CB_HANDSHAKE_DONE())) {
-            handshakeCount++;
-        }
-    }
-
-    public synchronized int openSSLCallbackVerify(int preverify_ok, MemoryAddress /*X509_STORE_CTX*/ x509ctx) {
-        if (logger.isDebugEnabled()) {
-            logger.debug("Verification in engine with mode [" + certificateVerifyMode + "] for " + state.ssl);
-        }
-        int ok = preverify_ok;
-        int errnum = X509_STORE_CTX_get_error(x509ctx);
-        int errdepth = X509_STORE_CTX_get_error_depth(x509ctx);
-        phaState = PHAState.COMPLETE;
-        if (certificateVerifyMode == -1 /*SSL_CVERIFY_UNSET*/ || certificateVerifyMode == SSL_VERIFY_NONE()) {
-            return 1;
-        }
-        /*SSL_VERIFY_ERROR_IS_OPTIONAL(errnum) -> ((errnum == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT)
-                || (errnum == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN)
-                || (errnum == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)
-                || (errnum == X509_V_ERR_CERT_UNTRUSTED)
-                || (errnum == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE))*/
-        boolean verifyErrorIsOptional = (errnum == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT())
-                || (errnum == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN())
-                || (errnum == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY())
-                || (errnum == X509_V_ERR_CERT_UNTRUSTED())
-                || (errnum == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE());
-        if (verifyErrorIsOptional && (certificateVerifyMode == OPTIONAL_NO_CA)) {
-            ok = 1;
-            SSL_set_verify_result(state.ssl, X509_V_OK());
-        }
-        /*
-         * Expired certificates vs. "expired" CRLs: by default, OpenSSL
-         * turns X509_V_ERR_CRL_HAS_EXPIRED into a "certificate_expired(45)"
-         * SSL alert, but that's not really the message we should convey to the
-         * peer (at the very least, it's confusing, and in many cases, it's also
-         * inaccurate, as the certificate itself may very well not have expired
-         * yet). We set the X509_STORE_CTX error to something which OpenSSL's
-         * s3_both.c:ssl_verify_alarm_type() maps to SSL_AD_CERTIFICATE_UNKNOWN,
-         * i.e. the peer will receive a "certificate_unknown(46)" alert.
-         * We do not touch errnum, though, so that later on we will still log
-         * the "real" error, as returned by OpenSSL.
-         */
-        if (ok == 0 && errnum == X509_V_ERR_CRL_HAS_EXPIRED()) {
-            X509_STORE_CTX_set_error(x509ctx, -1);
-        }
-
-        // OCSP
-        if (!noOcspCheck && (ok > 0)) {
-            /* If there was an optional verification error, it's not
-             * possible to perform OCSP validation since the issuer may be
-             * missing/untrusted.  Fail in that case.
-             */
-            if (verifyErrorIsOptional) {
-                if (certificateVerifyMode != OPTIONAL_NO_CA) {
-                    X509_STORE_CTX_set_error(x509ctx, X509_V_ERR_APPLICATION_VERIFICATION());
-                    errnum = X509_V_ERR_APPLICATION_VERIFICATION();
-                    ok = 0;
-                }
-            } else {
-                int ocspResponse = processOCSP(x509ctx);
-                if (ocspResponse == V_OCSP_CERTSTATUS_REVOKED()) {
-                    ok = 0;
-                    errnum = X509_STORE_CTX_get_error(x509ctx);
-                } else if (ocspResponse == V_OCSP_CERTSTATUS_UNKNOWN()) {
-                    errnum = X509_STORE_CTX_get_error(x509ctx);
-                    if (errnum <= 0) {
-                        ok = 0;
-                    }
-                }
-            }
-        }
-
-        if (errdepth > certificateVerificationDepth) {
-            // Certificate Verification: Certificate Chain too long
-            ok = 0;
-        }
-        return ok;
-    }
-
-    static int processOCSP(MemoryAddress /*X509_STORE_CTX*/ x509ctx) {
-        int ocspResponse = V_OCSP_CERTSTATUS_UNKNOWN();
-        // ocspResponse = ssl_verify_OCSP(x509_ctx);
-        MemoryAddress x509 = X509_STORE_CTX_get_current_cert(x509ctx);
-        if (!MemoryAddress.NULL.equals(x509)) {
-            // No need to check cert->valid, because ssl_verify_OCSP() only
-            // is called if OpenSSL already successfully verified the certificate
-            // (parameter "ok" in SSL_callback_SSL_verify() must be true).
-            if (X509_check_issued(x509, x509) == X509_V_OK()) {
-                // don't do OCSP checking for valid self-issued certs
-                X509_STORE_CTX_set_error(x509ctx, X509_V_OK());
-            } else {
-                // If we can't get the issuer, we cannot perform OCSP verification
-                MemoryAddress issuer = X509_STORE_CTX_get0_current_issuer(x509ctx);
-                if (!MemoryAddress.NULL.equals(issuer)) {
-                    // sslutils.c ssl_ocsp_request(x509, issuer, x509ctx);
-                    int nid = X509_get_ext_by_NID(x509, NID_info_access(), -1);
-                    if (nid >= 0) {
-                        try (var scope = ResourceScope.newConfinedScope()) {
-                            MemoryAddress ext = X509_get_ext(x509, nid);
-                            MemoryAddress os = X509_EXTENSION_get_data(ext);
-                            int length = ASN1_STRING_length(os);
-                            MemoryAddress data = ASN1_STRING_get0_data(os);
-                            // ocsp_urls = decode_OCSP_url(os);
-                            byte[] asn1String = MemorySegment.ofAddressNative(data, length, scope).toArray(ValueLayout.JAVA_BYTE);
-                            Asn1Parser parser = new Asn1Parser(asn1String);
-                            // Parse the byte sequence
-                            ArrayList<String> urls = new ArrayList<>();
-                            try {
-                                parseOCSPURLs(parser, urls);
-                            } catch (Exception e) {
-                                logger.error(sm.getString("engine.ocspParseError"), e);
-                            }
-                            if (!urls.isEmpty()) {
-                                // Use OpenSSL to build OCSP request
-                                for (String urlString : urls) {
-                                    try {
-                                        URL url = new URL(urlString);
-                                        ocspResponse = processOCSPRequest(url, issuer, x509, x509ctx, scope);
-                                        if (logger.isDebugEnabled()) {
-                                            logger.debug("OCSP response for URL: " + urlString + " was " + ocspResponse);
-                                        }
-                                    } catch (MalformedURLException e) {
-                                        logger.warn(sm.getString("engine.invalidOCSPURL", urlString));
-                                    }
-                                    if (ocspResponse != V_OCSP_CERTSTATUS_UNKNOWN()) {
-                                        break;
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        }
-        return ocspResponse;
-    }
-
-    private static final int ASN1_SEQUENCE = 0x30;
-    private static final int ASN1_OID      = 0x06;
-    private static final int ASN1_STRING   = 0x86;
-    private static final byte[] OCSP_OID = {0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01};
-
-    private static void parseOCSPURLs(Asn1Parser parser, ArrayList<String> urls) {
-        while (!parser.eof()) {
-            int tag = parser.peekTag();
-            if (tag == ASN1_SEQUENCE) {
-                parser.parseTag(ASN1_SEQUENCE);
-                parser.parseFullLength();
-            } else if (tag == ASN1_OID) {
-                parser.parseTag(ASN1_OID);
-                int oidLen = parser.parseLength();
-                byte[] oid = new byte[oidLen];
-                parser.parseBytes(oid);
-                if (Arrays.compareUnsigned(oid, 0, OCSP_OID.length, OCSP_OID, 0, OCSP_OID.length) == 0) {
-                    parser.parseTag(ASN1_STRING);
-                    int urlLen = parser.parseLength();
-                    byte[] url = new byte[urlLen];
-                    parser.parseBytes(url);
-                    urls.add(new String(url));
-                }
-            } else {
-                return;
-            }
-        }
-    }
-
-    private static int processOCSPRequest(URL url, MemoryAddress issuer, MemoryAddress x509,
-            MemoryAddress /*X509_STORE_CTX*/ x509ctx, ResourceScope scope) {
-        MemoryAddress ocspRequest = MemoryAddress.NULL;
-        MemoryAddress ocspResponse = MemoryAddress.NULL;
-        MemoryAddress id = MemoryAddress.NULL;
-        MemoryAddress ocspOneReq = MemoryAddress.NULL;
-        HttpURLConnection connection = null;
-        MemoryAddress basicResponse = MemoryAddress.NULL;
-        MemoryAddress certId = MemoryAddress.NULL;
-        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
-            var allocator = SegmentAllocator.nativeAllocator(scope);
-            ocspRequest = OCSP_REQUEST_new();
-            if (MemoryAddress.NULL.equals(ocspRequest)) {
-                return V_OCSP_CERTSTATUS_UNKNOWN();
-            }
-            id = OCSP_cert_to_id(MemoryAddress.NULL, x509, issuer);
-            if (MemoryAddress.NULL.equals(id)) {
-                return V_OCSP_CERTSTATUS_UNKNOWN();
-            }
-            ocspOneReq = OCSP_request_add0_id(ocspRequest, id);
-            if (MemoryAddress.NULL.equals(ocspOneReq)) {
-                return V_OCSP_CERTSTATUS_UNKNOWN();
-            }
-            MemorySegment bufPointer = allocator.allocate(ValueLayout.ADDRESS, MemoryAddress.NULL);
-            int requestLength = i2d_OCSP_REQUEST(ocspRequest, bufPointer);
-            if (requestLength <= 0) {
-                return V_OCSP_CERTSTATUS_UNKNOWN();
-            }
-            MemoryAddress buf = bufPointer.get(ValueLayout.ADDRESS, 0);
-            // HTTP request with the following header
-            // POST urlPath HTTP/1.1
-            // Host: urlHost:urlPort
-            // Content-Type: application/ocsp-request
-            // Content-Length: ocspRequestData.length
-            byte[] ocspRequestData = MemorySegment.ofAddressNative(buf, requestLength, scope).toArray(ValueLayout.JAVA_BYTE);
-            connection = (HttpURLConnection) url.openConnection();
-            connection.setRequestMethod("POST");
-            connection.setDoInput(true);
-            connection.setDoOutput(true);
-            connection.setFixedLengthStreamingMode(requestLength);
-            connection.setRequestProperty("Content-Type", "application/ocsp-request");
-            connection.connect();
-            connection.getOutputStream().write(ocspRequestData);
-            int responseCode = connection.getResponseCode();
-            if (responseCode != HttpURLConnection.HTTP_OK) {
-                return V_OCSP_CERTSTATUS_UNKNOWN();
-            }
-            InputStream is = connection.getInputStream();
-            int read = 0;
-            byte[] responseBuf = new byte[1024];
-            while ((read = is.read(responseBuf)) > 0) {
-                baos.write(responseBuf, 0, read);
-            }
-            byte[] responseData = baos.toByteArray();
-            var nativeResponseData = allocator.allocateArray(ValueLayout.JAVA_BYTE, responseData);
-            var nativeResponseDataPointer = allocator.allocate(ValueLayout.ADDRESS, nativeResponseData);
-            ocspResponse = d2i_OCSP_RESPONSE(MemoryAddress.NULL, nativeResponseDataPointer, responseData.length);
-            if (!MemoryAddress.NULL.equals(ocspResponse)) {
-                if (OCSP_response_status(ocspResponse) == OCSP_RESPONSE_STATUS_SUCCESSFUL()) {
-                    basicResponse = OCSP_response_get1_basic(ocspResponse);
-                    certId = OCSP_cert_to_id(MemoryAddress.NULL, x509, issuer);
-                    if (MemoryAddress.NULL.equals(certId)) {
-                        return V_OCSP_CERTSTATUS_UNKNOWN();
-                    }
-                    // Find by serial number and get the matching response
-                    MemoryAddress singleResponse = OCSP_resp_get0(basicResponse, OCSP_resp_find(basicResponse, certId, -1));
-                    return OCSP_single_get0_status(singleResponse, MemoryAddress.NULL,
-                            MemoryAddress.NULL, MemoryAddress.NULL, MemoryAddress.NULL);
-                }
-            }
-        } catch (Exception e) {
-            logger.warn(sm.getString("engine.ocspRequestError", url.toString()), e);
-        } finally {
-            if (MemoryAddress.NULL.equals(ocspResponse)) {
-                // Failed to get a valid response
-                X509_STORE_CTX_set_error(x509ctx, X509_V_ERR_APPLICATION_VERIFICATION());
-            }
-            OCSP_CERTID_free(certId);
-            OCSP_BASICRESP_free(basicResponse);
-            OCSP_RESPONSE_free(ocspResponse);
-            OCSP_REQUEST_free(ocspRequest);
-            if (connection != null) {
-                connection.disconnect();
-            }
-        }
-        return V_OCSP_CERTSTATUS_UNKNOWN();
-    }
-
-    @Override
-    public void setEnableSessionCreation(boolean b) {
-        if (!b) {
-            String msg = sm.getString("engine.noRestrictSessionCreation");
-            throw new UnsupportedOperationException(msg);
-        }
-    }
-
-    @Override
-    public boolean getEnableSessionCreation() {
-        return true;
-    }
-
-
-    private class OpenSSLSession implements SSLSession {
-
-        // lazy init for memory reasons
-        private Map<String, Object> values;
-
-        // Last accessed time
-        private long lastAccessedTime = -1;
-
-        @Override
-        public byte[] getId() {
-            byte[] id = null;
-            synchronized (OpenSSLEngine.this) {
-                if (!destroyed) {
-                    try (var scope = ResourceScope.newConfinedScope()) {
-                        var allocator = SegmentAllocator.nativeAllocator(scope);
-                        MemorySegment lenPointer = allocator.allocate(ValueLayout.ADDRESS);
-                        var session = SSL_get_session(state.ssl);
-                        MemoryAddress sessionId = SSL_SESSION_get_id(session, lenPointer);
-                        int len = lenPointer.get(ValueLayout.JAVA_INT, 0);
-                        id = (len == 0) ? new byte[0]
-                                : MemorySegment.ofAddressNative(sessionId, len, scope).toArray(ValueLayout.JAVA_BYTE);
-                    }
-                }
-            }
-
-            return id;
-        }
-
-        @Override
-        public SSLSessionContext getSessionContext() {
-            return sessionContext;
-        }
-
-        @Override
-        public long getCreationTime() {
-            // We need to multiply by 1000 as OpenSSL uses seconds and we need milliseconds.
-            long creationTime = 0;
-            synchronized (OpenSSLEngine.this) {
-                if (!destroyed) {
-                    var session = SSL_get_session(state.ssl);
-                    creationTime = SSL_SESSION_get_time(session);
-                }
-            }
-            return creationTime * 1000L;
-        }
-
-        @Override
-        public long getLastAccessedTime() {
-            return (lastAccessedTime > 0) ? lastAccessedTime : getCreationTime();
-        }
-
-        @Override
-        public void invalidate() {
-            // NOOP
-        }
-
-        @Override
-        public boolean isValid() {
-            return false;
-        }
-
-        @Override
-        public void putValue(String name, Object value) {
-            if (name == null) {
-                throw new IllegalArgumentException(sm.getString("engine.nullName"));
-            }
-            if (value == null) {
-                throw new IllegalArgumentException(sm.getString("engine.nullValue"));
-            }
-            Map<String, Object> values = this.values;
-            if (values == null) {
-                // Use size of 2 to keep the memory overhead small
-                values = this.values = new HashMap<>(2);
-            }
-            Object old = values.put(name, value);
-            if (value instanceof SSLSessionBindingListener) {
-                ((SSLSessionBindingListener) value).valueBound(new SSLSessionBindingEvent(this, name));
-            }
-            notifyUnbound(old, name);
-        }
-
-        @Override
-        public Object getValue(String name) {
-            if (name == null) {
-                throw new IllegalArgumentException(sm.getString("engine.nullName"));
-            }
-            if (values == null) {
-                return null;
-            }
-            return values.get(name);
-        }
-
-        @Override
-        public void removeValue(String name) {
-            if (name == null) {
-                throw new IllegalArgumentException(sm.getString("engine.nullName"));
-            }
-            Map<String, Object> values = this.values;
-            if (values == null) {
-                return;
-            }
-            Object old = values.remove(name);
-            notifyUnbound(old, name);
-        }
-
-        @Override
-        public String[] getValueNames() {
-            Map<String, Object> values = this.values;
-            if (values == null || values.isEmpty()) {
-                return new String[0];
-            }
-            return values.keySet().toArray(new String[0]);
-        }
-
-        private void notifyUnbound(Object value, String name) {
-            if (value instanceof SSLSessionBindingListener) {
-                ((SSLSessionBindingListener) value).valueUnbound(new SSLSessionBindingEvent(this, name));
-            }
-        }
-
-        @Override
-        public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {
-            // these are lazy created to reduce memory overhead
-            Certificate[] c = peerCerts;
-            if (c == null) {
-                byte[] clientCert;
-                byte[][] chain;
-                synchronized (OpenSSLEngine.this) {
-                    if (destroyed || SSL_in_init(state.ssl) != 0) {
-                        throw new SSLPeerUnverifiedException(sm.getString("engine.unverifiedPeer"));
-                    }
-                    chain = getPeerCertChain();
-                    if (!clientMode) {
-                        // if used on the server side SSL_get_peer_cert_chain(...) will not include the remote peer certificate.
-                        // We use SSL_get_peer_certificate to get it in this case and add it to our array later.
-                        //
-                        // See https://www.openssl.org/docs/ssl/SSL_get_peer_cert_chain.html
-                        clientCert = getPeerCertificate();
-                    } else {
-                        clientCert = null;
-                    }
-                }
-                if (chain == null && clientCert == null) {
-                    return null;
-                }
-                int len = 0;
-                if (chain != null) {
-                    len += chain.length;
-                }
-
-                int i = 0;
-                Certificate[] certificates;
-                if (clientCert != null) {
-                    len++;
-                    certificates = new Certificate[len];
-                    certificates[i++] = new OpenSSLX509Certificate(clientCert);
-                } else {
-                    certificates = new Certificate[len];
-                }
-                if (chain != null) {
-                    int a = 0;
-                    for (; i < certificates.length; i++) {
-                        certificates[i] = new OpenSSLX509Certificate(chain[a++]);
-                    }
-                }
-                c = peerCerts = certificates;
-            }
-            return c;
-        }
-
-        @Override
-        public Certificate[] getLocalCertificates() {
-            // FIXME (if possible): Not available in the OpenSSL API
-            return EMPTY_CERTIFICATES;
-        }
-
-        @Deprecated
-        @Override
-        public javax.security.cert.X509Certificate[] getPeerCertificateChain()
-                throws SSLPeerUnverifiedException {
-            // these are lazy created to reduce memory overhead
-            javax.security.cert.X509Certificate[] c = x509PeerCerts;
-            if (c == null) {
-                byte[][] chain;
-                synchronized (OpenSSLEngine.this) {
-                    if (destroyed || SSL_in_init(state.ssl) != 0) {
-                        throw new SSLPeerUnverifiedException(sm.getString("engine.unverifiedPeer"));
-                    }
-                    chain = getPeerCertChain();
-                }
-                if (chain == null) {
-                    throw new SSLPeerUnverifiedException(sm.getString("engine.unverifiedPeer"));
-                }
-                javax.security.cert.X509Certificate[] peerCerts =
-                        new javax.security.cert.X509Certificate[chain.length];
-                for (int i = 0; i < peerCerts.length; i++) {
-                    try {
-                        peerCerts[i] = javax.security.cert.X509Certificate.getInstance(chain[i]);
-                    } catch (javax.security.cert.CertificateException e) {
-                        throw new IllegalStateException(e);
-                    }
-                }
-                c = x509PeerCerts = peerCerts;
-            }
-            return c;
-        }
-
-        @Override
-        public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-            Certificate[] peer = getPeerCertificates();
-            if (peer == null || peer.length == 0) {
-                return null;
-            }
-            return principal(peer);
-        }
-
-        @Override
-        public Principal getLocalPrincipal() {
-            Certificate[] local = getLocalCertificates();
-            if (local == null || local.length == 0) {
-                return null;
-            }
-            return principal(local);
-        }
-
-        private Principal principal(Certificate[] certs) {
-            return ((java.security.cert.X509Certificate) certs[0]).getIssuerX500Principal();
-        }
-
-        @Override
-        public String getCipherSuite() {
-            if (cipher == null) {
-                String ciphers;
-                synchronized (OpenSSLEngine.this) {
-                    if (!handshakeFinished) {
-                        return INVALID_CIPHER;
-                    }
-                    if (destroyed) {
-                        return INVALID_CIPHER;
-                    }
-                    ciphers = SSL_CIPHER_get_name(SSL_get_current_cipher(state.ssl)).getUtf8String(0);
-                }
-                String c = OpenSSLCipherConfigurationParser.openSSLToJsse(ciphers);
-                if (c != null) {
-                    cipher = c;
-                }
-            }
-            return cipher;
-        }
-
-        @Override
-        public String getProtocol() {
-            String applicationProtocol = OpenSSLEngine.this.applicationProtocol;
-            if (applicationProtocol == null) {
-                synchronized (OpenSSLEngine.this) {
-                    if (!destroyed) {
-                        applicationProtocol = getProtocolNegotiated();
-                    }
-                }
-                if (applicationProtocol == null) {
-                    applicationProtocol = fallbackApplicationProtocol;
-                }
-                if (applicationProtocol != null) {
-                    OpenSSLEngine.this.applicationProtocol = applicationProtocol.replace(':', '_');
-                } else {
-                    OpenSSLEngine.this.applicationProtocol = applicationProtocol = "";
-                }
-            }
-            String version = null;
-            synchronized (OpenSSLEngine.this) {
-                if (!destroyed) {
-                    version = SSL_get_version(state.ssl).getUtf8String(0);
-                }
-            }
-            if (applicationProtocol.isEmpty()) {
-                return version;
-            } else {
-                return version + ':' + applicationProtocol;
-            }
-        }
-
-        @Override
-        public String getPeerHost() {
-            // Not available for now in Tomcat (needs to be passed during engine creation)
-            return null;
-        }
-
-        @Override
-        public int getPeerPort() {
-            // Not available for now in Tomcat (needs to be passed during engine creation)
-            return 0;
-        }
-
-        @Override
-        public int getPacketBufferSize() {
-            return MAX_ENCRYPTED_PACKET_LENGTH;
-        }
-
-        @Override
-        public int getApplicationBufferSize() {
-            return MAX_PLAINTEXT_LENGTH;
-        }
-
-    }
-
-    private static class OpenSSLState implements Runnable {
-
-        private final ResourceScope scope;
-        private final MemoryAddress ssl;
-        private final MemoryAddress networkBIO;
-
-        private OpenSSLState(ResourceScope scope, MemoryAddress ssl, MemoryAddress networkBIO) {
-            this.scope = scope;
-            this.ssl = ssl;
-            this.networkBIO = networkBIO;
-        }
-
-        @Override
-        public void run() {
-            try {
-                BIO_free(networkBIO);
-                SSL_free(ssl);
-            } finally {
-                scope.close();
-            }
-        }
-    }
-}

==================================================
OpenSSLLifecycleListener.java
deleted file mode 100644
index 28d7ae2b8f..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLImplementation.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.net.openssl.panama;
-
-import java.util.List;
-import java.util.Map;
-
-import javax.net.ssl.SSLSession;
-
-import org.apache.tomcat.util.net.SSLHostConfigCertificate;
-import org.apache.tomcat.util.net.SSLImplementation;
-import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.SSLUtil;
-import org.apache.tomcat.util.net.jsse.JSSESupport;
-
-public class OpenSSLImplementation extends SSLImplementation {
-
-    @Deprecated
-    public SSLSupport getSSLSupport(SSLSession session) {
-        return new JSSESupport(session, null);
-    }
-
-    @Override
-    public SSLSupport getSSLSupport(SSLSession session, Map<String, List<String>> additionalAttributes) {
-        return new JSSESupport(session, additionalAttributes);
-    }
-
-    @Override
-    public SSLUtil getSSLUtil(SSLHostConfigCertificate certificate) {
-        return new OpenSSLUtil(certificate);
-    }
-
-    public boolean isAlpnSupported() {
-        // OpenSSL supported ALPN
-        return true;
-    }
-}

==================================================
OpenSSLSessionContext.java
deleted file mode 100644
index af02ca2892..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLLifecycleListener.java
+++ /dev/null
@@ -1,328 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.net.openssl.panama;
-
-
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.ResourceScope;
-import jdk.incubator.foreign.SegmentAllocator;
-import jdk.incubator.foreign.ValueLayout;
-
-import static org.apache.tomcat.util.openssl.openssl_h.*;
-
-import java.security.SecureRandom;
-
-import org.apache.catalina.Lifecycle;
-import org.apache.catalina.LifecycleEvent;
-import org.apache.catalina.LifecycleListener;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.ExceptionUtils;
-import org.apache.tomcat.util.res.StringManager;
-
-
-
-/**
- * Implementation of <code>LifecycleListener</code> that will do the global
- * initialization of OpenSSL according to specified configuration parameters.
- * Using the listener is completely optional, but is needed for configuration.
- */
-public class OpenSSLLifecycleListener implements LifecycleListener {
-
-    private static final Log log = LogFactory.getLog(OpenSSLLifecycleListener.class);
-
-    /**
-     * The string manager for this package.
-     */
-    protected static final StringManager sm = StringManager.getManager(OpenSSLLifecycleListener.class);
-
-
-    // ---------------------------------------------- Properties
-    protected static String SSLEngine = "on"; //default on
-    protected static String FIPSMode = "off"; // default off, valid only when SSLEngine="on"
-    protected static String SSLRandomSeed = "builtin";
-    protected static boolean fipsModeActive = false;
-
-    /**
-     * The "FIPS mode" level that we use as the argument to OpenSSL method
-     * <code>FIPS_mode_set()</code> to enable FIPS mode and that we expect as
-     * the return value of <code>FIPS_mode()</code> when FIPS mode is enabled.
-     * <p>
-     * In the future the OpenSSL library might grow support for different
-     * non-zero "FIPS" modes that specify different allowed subsets of ciphers
-     * or whatever, but nowadays only "1" is the supported value.
-     * </p>
-     * @see <a href="http://wiki.openssl.org/index.php/FIPS_mode_set%28%29">OpenSSL method FIPS_mode_set()</a>
-     * @see <a href="http://wiki.openssl.org/index.php/FIPS_mode%28%29">OpenSSL method FIPS_mode()</a>
-     */
-    private static final int FIPS_ON = 1;
-
-    private static final int FIPS_OFF = 0;
-
-    protected static final Object lock = new Object();
-
-    public OpenSSLLifecycleListener() {
-        OpenSSLStatus.setInstanceCreated(true);
-    }
-
-    // ---------------------------------------------- LifecycleListener Methods
-
-    /**
-     * Primary entry point for startup and shutdown events.
-     *
-     * @param event The event that has occurred
-     */
-    @Override
-    public void lifecycleEvent(LifecycleEvent event) {
-
-        if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
-            synchronized (lock) {
-                try {
-                    init();
-                } catch (Throwable t) {
-                    t = ExceptionUtils.unwrapInvocationTargetException(t);
-                    ExceptionUtils.handleThrowable(t);
-                    log.error(sm.getString("listener.sslInit"), t);
-                }
-                // Failure to initialize FIPS mode is fatal
-                if (!(null == FIPSMode || "off".equalsIgnoreCase(FIPSMode)) && !isFIPSModeActive()) {
-                    String errorMessage = sm.getString("listener.initializeFIPSFailed");
-                    Error e = new Error(errorMessage);
-                    // Log here, because thrown error might be not logged
-                    log.fatal(errorMessage, e);
-                    throw e;
-                }
-            }
-        } else if (Lifecycle.AFTER_DESTROY_EVENT.equals(event.getType())) {
-            synchronized (lock) {
-                if (!OpenSSLStatus.isAvailable()) {
-                    return;
-                }
-                try {
-                    OpenSSLStatus.setAvailable(false);
-                    OpenSSLStatus.setInitialized(false);
-                    fipsModeActive = false;
-                } catch (Throwable t) {
-                    t = ExceptionUtils.unwrapInvocationTargetException(t);
-                    ExceptionUtils.handleThrowable(t);
-                    log.info(sm.getString("listener.destroy"));
-                }
-            }
-        }
-
-    }
-
-    static MemoryAddress enginePointer = MemoryAddress.NULL;
-
-    static void initLibrary() {
-        synchronized (OpenSSLStatus.class) {
-            if (OpenSSLStatus.isLibraryInitialized()) {
-                return;
-            }
-            OpenSSLStatus.setLibraryInitialized(true);
-            OPENSSL_init_ssl(OPENSSL_INIT_ENGINE_ALL_BUILTIN(), MemoryAddress.NULL);
-        }
-    }
-
-    static void init() throws Exception {
-
-        if (OpenSSLStatus.isInitialized()) {
-            return;
-        }
-        OpenSSLStatus.setInitialized(true);
-
-        if ("off".equalsIgnoreCase(SSLEngine)) {
-            return;
-        }
-
-        var scope = ResourceScope.globalScope();
-        var allocator = SegmentAllocator.nativeAllocator(scope);
-
-        // FIXME: implement ssl_init_cleanup to use if there's an error or when the library is unloaded, possibly only ENGINE_free
-
-        // Main library init
-        initLibrary();
-
-        // Setup engine
-        String engineName = "on".equalsIgnoreCase(SSLEngine) ? null : SSLEngine;
-        if (engineName != null) {
-            if ("auto".equals(engineName)) {
-                ENGINE_register_all_complete();
-            } else {
-                var engine = allocator.allocateUtf8String(engineName);
-                enginePointer = ENGINE_by_id(engine);
-                if (MemoryAddress.NULL.equals(enginePointer)) {
-                    enginePointer = ENGINE_by_id(allocator.allocateUtf8String("dynamic"));
-                    if (enginePointer != null) {
-                        if (ENGINE_ctrl_cmd_string(enginePointer, allocator.allocateUtf8String("SO_PATH"), engine, 0) == 0
-                                || ENGINE_ctrl_cmd_string(enginePointer, allocator.allocateUtf8String("LOAD"),
-                                        MemoryAddress.NULL, 0) == 0) {
-                            // Engine load error
-                            ENGINE_free(enginePointer);
-                            enginePointer = MemoryAddress.NULL;
-                        }
-                    }
-                }
-                if (!MemoryAddress.NULL.equals(enginePointer)) {
-                    if (ENGINE_set_default(enginePointer, ENGINE_METHOD_ALL()) == 0) {
-                        // Engine load error
-                        ENGINE_free(enginePointer);
-                        enginePointer = MemoryAddress.NULL;
-                    }
-                }
-                if (MemoryAddress.NULL.equals(enginePointer)) {
-                    throw new IllegalStateException(sm.getString("listener.engineError"));
-                }
-            }
-        }
-
-        // Set the random seed, translated to the Java way
-        boolean seedDone = false;
-        if (SSLRandomSeed != null || SSLRandomSeed.length() != 0 || !"builtin".equals(SSLRandomSeed)) {
-            var randomSeed = allocator.allocateUtf8String(SSLRandomSeed);
-            seedDone = RAND_load_file(randomSeed, 128) > 0;
-        }
-        if (!seedDone) {
-            // Use a regular random to get some bytes
-            SecureRandom random = new SecureRandom();
-            byte[] randomBytes = random.generateSeed(128);
-            RAND_seed(allocator.allocateArray(ValueLayout.JAVA_BYTE, randomBytes), 128);
-        }
-
-        // init_dh_params is done in OpenSSLContext static init
-        
-        // FIXME: Keylog ?
-
-        if (!(null == FIPSMode || "off".equalsIgnoreCase(FIPSMode))) {
-
-            fipsModeActive = false;
-
-            final boolean enterFipsMode;
-            int fipsModeState = FIPS_mode();
-
-            if(log.isDebugEnabled()) {
-                log.debug(sm.getString("listener.currentFIPSMode",
-                        Integer.valueOf(fipsModeState)));
-            }
-
-            if ("on".equalsIgnoreCase(FIPSMode)) {
-                if (fipsModeState == FIPS_ON) {
-                    log.info(sm.getString("listener.skipFIPSInitialization"));
-                    fipsModeActive = true;
-                    enterFipsMode = false;
-                } else {
-                    enterFipsMode = true;
-                }
-            } else if ("require".equalsIgnoreCase(FIPSMode)) {
-                if (fipsModeState == FIPS_ON) {
-                    fipsModeActive = true;
-                    enterFipsMode = false;
-                } else {
-                    throw new IllegalStateException(
-                            sm.getString("listener.requireNotInFIPSMode"));
-                }
-            } else if ("enter".equalsIgnoreCase(FIPSMode)) {
-                if (fipsModeState == FIPS_OFF) {
-                    enterFipsMode = true;
-                } else {
-                    throw new IllegalStateException(sm.getString(
-                            "listener.enterAlreadyInFIPSMode",
-                            Integer.valueOf(fipsModeState)));
-                }
-            } else {
-                throw new IllegalArgumentException(sm.getString(
-                        "listener.wrongFIPSMode", FIPSMode));
-            }
-
-            if (enterFipsMode) {
-                log.info(sm.getString("listener.initializingFIPS"));
-
-                fipsModeState = FIPS_mode_set(FIPS_ON);
-                if (fipsModeState != FIPS_ON) {
-                    // This case should be handled by the native method,
-                    // but we'll make absolutely sure, here.
-                    String message = sm.getString("listener.initializeFIPSFailed");
-                    log.error(message);
-                    throw new IllegalStateException(message);
-                }
-
-                fipsModeActive = true;
-                log.info(sm.getString("listener.initializeFIPSSuccess"));
-            }
-        }
-
-        log.info(sm.getString("listener.initializedOpenSSL", OPENSSL_VERSION_TEXT().getUtf8String(0)));
-        OpenSSLStatus.setAvailable(true);
-    }
-
-    public String getSSLEngine() {
-        return SSLEngine;
-    }
-
-    public void setSSLEngine(String SSLEngine) {
-        if (!SSLEngine.equals(OpenSSLLifecycleListener.SSLEngine)) {
-            // Ensure that the SSLEngine is consistent with that used for SSL init
-            if (OpenSSLStatus.isInitialized()) {
-                throw new IllegalStateException(
-                        sm.getString("listener.tooLateForSSLEngine"));
-            }
-
-            OpenSSLLifecycleListener.SSLEngine = SSLEngine;
-        }
-    }
-
-    public String getSSLRandomSeed() {
-        return SSLRandomSeed;
-    }
-
-    public void setSSLRandomSeed(String SSLRandomSeed) {
-        if (!SSLRandomSeed.equals(OpenSSLLifecycleListener.SSLRandomSeed)) {
-            // Ensure that the random seed is consistent with that used for SSL init
-            if (OpenSSLStatus.isInitialized()) {
-                throw new IllegalStateException(
-                        sm.getString("listener.tooLateForSSLRandomSeed"));
-            }
-
-            OpenSSLLifecycleListener.SSLRandomSeed = SSLRandomSeed;
-        }
-    }
-
-    public String getFIPSMode() {
-        return FIPSMode;
-    }
-
-    public void setFIPSMode(String FIPSMode) {
-        if (!FIPSMode.equals(OpenSSLLifecycleListener.FIPSMode)) {
-            // Ensure that the FIPS mode is consistent with that used for SSL init
-            if (OpenSSLStatus.isInitialized()) {
-                throw new IllegalStateException(
-                        sm.getString("listener.tooLateForFIPSMode"));
-            }
-
-            OpenSSLLifecycleListener.FIPSMode = FIPSMode;
-        }
-    }
-
-    public boolean isFIPSModeActive() {
-        return fipsModeActive;
-    }
-
-    public static boolean isInstanceCreated() {
-        return OpenSSLStatus.isInstanceCreated();
-    }
-
-}

==================================================
OpenSSLSessionStats.java
deleted file mode 100644
index 36709c1b75..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLSessionContext.java
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.net.openssl.panama;
-
-import java.util.Enumeration;
-import java.util.NoSuchElementException;
-
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSessionContext;
-
-import static org.apache.tomcat.util.openssl.openssl_h.*;
-
-import org.apache.tomcat.util.res.StringManager;
-
-import jdk.incubator.foreign.ResourceScope;
-import jdk.incubator.foreign.SegmentAllocator;
-import jdk.incubator.foreign.ValueLayout;
-
-/**
- * OpenSSL specific {@link SSLSessionContext} implementation.
- */
-public class OpenSSLSessionContext implements SSLSessionContext {
-    private static final StringManager sm = StringManager.getManager(OpenSSLSessionContext.class);
-    private static final Enumeration<byte[]> EMPTY = new EmptyEnumeration();
-
-    private static final int TICKET_KEYS_SIZE = 48;
-
-    private final OpenSSLSessionStats stats;
-    private final OpenSSLContext context;
-
-    OpenSSLSessionContext(OpenSSLContext context) {
-        this.context = context;
-        stats = new OpenSSLSessionStats(context.getSSLContext());
-    }
-
-    @Override
-    public SSLSession getSession(byte[] bytes) {
-        return null;
-    }
-
-    @Override
-    public Enumeration<byte[]> getIds() {
-        return EMPTY;
-    }
-
-    /**
-     * Sets the SSL session ticket keys of this context.
-     *
-     * @param keys The session ticket keys
-     */
-    public void setTicketKeys(byte[] keys) {
-        if (keys == null) {
-            throw new IllegalArgumentException(sm.getString("sessionContext.nullTicketKeys"));
-        }
-        if (keys.length != TICKET_KEYS_SIZE) {
-            throw new IllegalArgumentException(sm.getString("sessionContext.invalidTicketKeysLength", keys.length));
-        }
-        try (var scope = ResourceScope.newConfinedScope()) {
-            var array = SegmentAllocator.nativeAllocator(scope).allocateArray(ValueLayout.JAVA_BYTE, keys);
-            // #define SSL_CTX_set_tlsext_ticket_keys(ctx, keys, keylen)
-            //     SSL_CTX_ctrl((ctx),SSL_CTRL_SET_TLSEXT_TICKET_KEYS, (keylen), (keys))
-            SSL_CTX_ctrl(context.getSSLContext(), SSL_CTRL_SET_TLSEXT_TICKET_KEYS(), TICKET_KEYS_SIZE, array);
-        }
-    }
-
-    /**
-     * Enable or disable caching of SSL sessions.
-     *
-     * @param enabled {@code true} to enable caching, {@code false} to disable
-     */
-    public void setSessionCacheEnabled(boolean enabled) {
-        long mode = enabled ? SSL_SESS_CACHE_SERVER() : SSL_SESS_CACHE_OFF();
-        // # define SSL_CTX_set_session_cache_mode(ctx,m) \
-        //     SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SESS_CACHE_MODE,m,NULL)
-        SSL_CTX_ctrl(context.getSSLContext(), SSL_CTRL_SET_SESS_CACHE_MODE(), mode, null);
-    }
-
-    /**
-     * @return {@code true} if caching of SSL sessions is enabled, {@code false}
-     *         otherwise.
-     */
-    public boolean isSessionCacheEnabled() {
-        // # define SSL_CTX_get_session_cache_mode(ctx) \
-        //    SSL_CTX_ctrl(ctx,SSL_CTRL_GET_SESS_CACHE_MODE,0,NULL)
-        return SSL_CTX_ctrl(context.getSSLContext(), SSL_CTRL_GET_SESS_CACHE_MODE(), 0, null) == SSL_SESS_CACHE_SERVER();
-    }
-
-    /**
-     * @return The statistics for this context.
-     */
-    public OpenSSLSessionStats stats() {
-        return stats;
-    }
-
-    @Override
-    public void setSessionTimeout(int seconds) {
-        if (seconds < 0) {
-            throw new IllegalArgumentException();
-        }
-        SSL_CTX_set_timeout(context.getSSLContext(), seconds);
-    }
-
-    @Override
-    public int getSessionTimeout() {
-        return (int) SSL_CTX_get_timeout(context.getSSLContext());
-    }
-
-    @Override
-    public void setSessionCacheSize(int size) {
-        if (size < 0) {
-            throw new IllegalArgumentException();
-        }
-        // # define SSL_CTX_sess_set_cache_size(ctx,t) \
-        //     SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SESS_CACHE_SIZE,t,NULL)
-        SSL_CTX_ctrl(context.getSSLContext(), SSL_CTRL_SET_SESS_CACHE_SIZE(), size, null);
-    }
-
-    @Override
-    public int getSessionCacheSize() {
-        // # define SSL_CTX_sess_get_cache_size(ctx) \
-        //     SSL_CTX_ctrl(ctx,SSL_CTRL_GET_SESS_CACHE_SIZE,0,NULL)
-        return (int) SSL_CTX_ctrl(context.getSSLContext(), SSL_CTRL_GET_SESS_CACHE_SIZE(), 0, null);
-    }
-
-    /**
-     * Set the context within which session be reused (server side only)
-     * See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_session_id_context.html">
-     *     man SSL_CTX_set_session_id_context</a>
-     *
-     * @param sidCtx can be any kind of binary data, it is therefore possible to use e.g. the name
-     *               of the application and/or the hostname and/or service name
-     * @return {@code true} if success, {@code false} otherwise.
-     */
-    public boolean setSessionIdContext(byte[] sidCtx) {
-        try (var scope = ResourceScope.newConfinedScope()) {
-            var array = SegmentAllocator.nativeAllocator(scope).allocateArray(ValueLayout.JAVA_BYTE, sidCtx);
-            return (SSL_CTX_set_session_id_context(context.getSSLContext(), array, sidCtx.length) == 1);
-        }
-    }
-
-    private static final class EmptyEnumeration implements Enumeration<byte[]> {
-        @Override
-        public boolean hasMoreElements() {
-            return false;
-        }
-
-        @Override
-        public byte[] nextElement() {
-            throw new NoSuchElementException();
-        }
-    }
-}

==================================================
OpenSSLStatus.java
deleted file mode 100644
index 658dd7466e..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLSessionStats.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.net.openssl.panama;
-
-import static org.apache.tomcat.util.openssl.openssl_h.*;
-
-import jdk.incubator.foreign.MemoryAddress;
-
-/**
- * Stats exposed by an OpenSSL session context.
- *
- * @see <a href="https://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html"><code>SSL_CTX_sess_number</code></a>
- */
-public final class OpenSSLSessionStats {
-
-    private final MemoryAddress ctx;
-
-    OpenSSLSessionStats(MemoryAddress ctx) {
-        this.ctx = ctx;
-    }
-
-    /**
-     * @return The current number of sessions in the internal session cache.
-     */
-    public long number() {
-        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_NUMBER(), 0, null);
-    }
-
-    /**
-     * @return The number of started SSL/TLS handshakes in client mode.
-     */
-    public long connect() {
-        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT() ,0, null);
-    }
-
-    /**
-     * @return The number of successfully established SSL/TLS sessions in client mode.
-     */
-    public long connectGood() {
-        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT_GOOD() , 0, null);
-    }
-
-    /**
-     * @return The number of start renegotiations in client mode.
-     */
-    public long connectRenegotiate() {
-        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT_RENEGOTIATE() , 0, null);
-    }
-
-    /**
-     * @return The number of started SSL/TLS handshakes in server mode.
-     */
-    public long accept() {
-        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT(), 0, null);
-    }
-
-    /**
-     * @return The number of successfully established SSL/TLS sessions in server mode.
-     */
-    public long acceptGood() {
-        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT_GOOD(), 0, null);
-    }
-
-    /**
-     * @return The number of start renegotiations in server mode.
-     */
-    public long acceptRenegotiate() {
-        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT_RENEGOTIATE(), 0, null);
-    }
-
-    /**
-     * @return The number of successfully reused sessions. In client mode, a
-     *         session set with {@code SSL_set_session} successfully reused is
-     *         counted as a hit. In server mode, a session successfully
-     *         retrieved from internal or external cache is counted as a hit.
-     */
-    public long hits() {
-        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_HIT(), 0, null);
-    }
-
-    /**
-     * @return The number of successfully retrieved sessions from the external
-     *         session cache in server mode.
-     */
-    public long cbHits() {
-        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CB_HIT(), 0, null);
-    }
-
-    /**
-     * @return The number of sessions proposed by clients that were not found in
-     *         the internal session cache in server mode.
-     */
-    public long misses() {
-        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_MISSES(), 0, null);
-    }
-
-    /**
-     * @return The number of sessions proposed by clients and either found in
-     *         the internal or external session cache in server mode, but that
-     *         were invalid due to timeout. These sessions are not included in
-     *         the {@link #hits()} count.
-     */
-    public long timeouts() {
-        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_TIMEOUTS(), 0, null);
-    }
-
-    /**
-     * @return The number of sessions that were removed because the maximum
-     *         session cache size was exceeded.
-     */
-    public long cacheFull() {
-        return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CACHE_FULL(), 0, null);
-    }
-}

==================================================
OpenSSLUtil.java
deleted file mode 100644
index a45f442708..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLStatus.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.net.openssl.panama;
-
-/**
- * Holds OpenSSL status without the need to load other classes.
- */
-public class OpenSSLStatus {
-    private static volatile boolean libraryInitialized = false;
-    private static volatile boolean initialized = false;
-    private static volatile boolean available = false;
-    private static volatile boolean instanceCreated = false;
-
-
-    public static boolean isLibraryInitialized() {
-        return libraryInitialized;
-    }
-
-    public static boolean isInitialized() {
-        return initialized;
-    }
-
-    public static boolean isAvailable() {
-        return available;
-    }
-
-    public static boolean isInstanceCreated() {
-        return instanceCreated;
-    }
-
-    public static void setLibraryInitialized(boolean libraryInitialized) {
-        OpenSSLStatus.libraryInitialized = libraryInitialized;
-    }
-
-    public static void setInitialized(boolean initialized) {
-        OpenSSLStatus.initialized = initialized;
-    }
-
-    public static void setAvailable(boolean available) {
-        OpenSSLStatus.available = available;
-    }
-
-    public static void setInstanceCreated(boolean instanceCreated) {
-        OpenSSLStatus.instanceCreated = instanceCreated;
-    }
-}

==================================================
OpenSSLX509Certificate.java
deleted file mode 100644
index 781dd4889a..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLUtil.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.net.openssl.panama;
-
-import java.io.IOException;
-import java.security.KeyStoreException;
-import java.util.List;
-import java.util.Set;
-
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.X509KeyManager;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.net.SSLContext;
-import org.apache.tomcat.util.net.SSLHostConfigCertificate;
-import org.apache.tomcat.util.net.SSLUtilBase;
-import org.apache.tomcat.util.net.jsse.JSSEKeyManager;
-import org.apache.tomcat.util.res.StringManager;
-
-public class OpenSSLUtil extends SSLUtilBase {
-
-    private static final Log log = LogFactory.getLog(OpenSSLUtil.class);
-    private static final StringManager sm = StringManager.getManager(OpenSSLUtil.class);
-
-
-    public OpenSSLUtil(SSLHostConfigCertificate certificate) {
-        super(certificate);
-    }
-
-
-    @Override
-    protected Log getLog() {
-        return log;
-    }
-
-
-    @Override
-    protected Set<String> getImplementedProtocols() {
-        return OpenSSLEngine.IMPLEMENTED_PROTOCOLS_SET;
-    }
-
-
-    @Override
-    protected Set<String> getImplementedCiphers() {
-        return OpenSSLEngine.AVAILABLE_CIPHER_SUITES;
-    }
-
-
-    @Override
-    protected boolean isTls13RenegAuthAvailable() {
-        // OpenSSL does support authentication after the initial handshake
-        return true;
-    }
-
-
-    @Override
-    public SSLContext createSSLContextInternal(List<String> negotiableProtocols) throws Exception {
-        return new OpenSSLContext(certificate, negotiableProtocols);
-    }
-
-
-    public static X509KeyManager chooseKeyManager(KeyManager[] managers) throws Exception {
-        if (managers == null) {
-            return null;
-        }
-        for (KeyManager manager : managers) {
-            if (manager instanceof JSSEKeyManager) {
-                return (JSSEKeyManager) manager;
-            }
-        }
-        for (KeyManager manager : managers) {
-            if (manager instanceof X509KeyManager) {
-                return (X509KeyManager) manager;
-            }
-        }
-        throw new IllegalStateException(sm.getString("openssl.keyManagerMissing"));
-    }
-
-
-    @Override
-    public KeyManager[] getKeyManagers() throws Exception {
-        try {
-            return super.getKeyManagers();
-        } catch (IllegalArgumentException e) {
-            // No (or invalid?) certificate chain was provided for the cert
-            String msg = sm.getString("openssl.nonJsseChain", certificate.getCertificateChainFile());
-            if (log.isDebugEnabled()) {
-                log.info(msg, e);
-            } else {
-                log.info(msg);
-            }
-            return null;
-        } catch (KeyStoreException | IOException e) {
-            // Depending on what is presented, JSSE may also throw
-            // KeyStoreException or IOException if it doesn't understand the
-            // provided file.
-            if (certificate.getCertificateFile() != null) {
-                String msg = sm.getString("openssl.nonJsseCertificate",
-                        certificate.getCertificateFile(), certificate.getCertificateKeyFile());
-                if (log.isDebugEnabled()) {
-                    log.info(msg, e);
-                } else {
-                    log.info(msg);
-                }
-                // Assume JSSE processing of the certificate failed, try again with OpenSSL
-                // without a key manager
-                return null;
-            }
-            throw e;
-        }
-    }
-
-}

==================================================
RuntimeHelper.java
deleted file mode 100644
index b4e6f381bf..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/net/openssl/panama/OpenSSLX509Certificate.java
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.util.net.openssl.panama;
-
-import java.io.ByteArrayInputStream;
-import java.math.BigInteger;
-import java.security.InvalidKeyException;
-import java.security.NoSuchAlgorithmException;
-import java.security.NoSuchProviderException;
-import java.security.Principal;
-import java.security.PublicKey;
-import java.security.SignatureException;
-import java.security.cert.CertificateEncodingException;
-import java.security.cert.CertificateException;
-import java.security.cert.CertificateExpiredException;
-import java.security.cert.CertificateNotYetValidException;
-import java.security.cert.X509Certificate;
-import java.util.Date;
-import java.util.Set;
-
-final class OpenSSLX509Certificate extends X509Certificate {
-
-    private final byte[] bytes;
-    private X509Certificate wrapped;
-
-    public OpenSSLX509Certificate(byte[] bytes) {
-        this.bytes = bytes;
-    }
-
-    @Override
-    public void checkValidity() throws CertificateExpiredException, CertificateNotYetValidException {
-        unwrap().checkValidity();
-    }
-
-    @Override
-    public void checkValidity(Date date) throws CertificateExpiredException, CertificateNotYetValidException {
-        unwrap().checkValidity(date);
-    }
-
-    @Override
-    public int getVersion() {
-        return unwrap().getVersion();
-    }
-
-    @Override
-    public BigInteger getSerialNumber() {
-        return unwrap().getSerialNumber();
-    }
-
-    @Override
-    public Principal getIssuerDN() {
-        return unwrap().getIssuerDN();
-    }
-
-    @Override
-    public Principal getSubjectDN() {
-        return unwrap().getSubjectDN();
-    }
-
-    @Override
-    public Date getNotBefore() {
-        return unwrap().getNotBefore();
-    }
-
-    @Override
-    public Date getNotAfter() {
-        return unwrap().getNotAfter();
-    }
-
-    @Override
-    public byte[] getTBSCertificate() throws CertificateEncodingException {
-        return unwrap().getTBSCertificate();
-    }
-
-    @Override
-    public byte[] getSignature() {
-        return unwrap().getSignature();
-    }
-
-    @Override
-    public String getSigAlgName() {
-        return unwrap().getSigAlgName();
-    }
-
-    @Override
-    public String getSigAlgOID() {
-        return unwrap().getSigAlgOID();
-    }
-
-    @Override
-    public byte[] getSigAlgParams() {
-        return unwrap().getSigAlgParams();
-    }
-
-    @Override
-    public boolean[] getIssuerUniqueID() {
-        return unwrap().getIssuerUniqueID();
-    }
-
-    @Override
-    public boolean[] getSubjectUniqueID() {
-        return unwrap().getSubjectUniqueID();
-    }
-
-    @Override
-    public boolean[] getKeyUsage() {
-        return unwrap().getKeyUsage();
-    }
-
-    @Override
-    public int getBasicConstraints() {
-        return unwrap().getBasicConstraints();
-    }
-
-    @Override
-    public byte[] getEncoded() {
-        return bytes.clone();
-    }
-
-    @Override
-    public void verify(PublicKey key)
-            throws CertificateException, NoSuchAlgorithmException,
-            InvalidKeyException, NoSuchProviderException, SignatureException {
-        unwrap().verify(key);
-    }
-
-    @Override
-    public void verify(PublicKey key, String sigProvider)
-            throws CertificateException, NoSuchAlgorithmException, InvalidKeyException,
-            NoSuchProviderException, SignatureException {
-        unwrap().verify(key, sigProvider);
-    }
-
-    @Override
-    public String toString() {
-        return unwrap().toString();
-    }
-
-    @Override
-    public PublicKey getPublicKey() {
-        return unwrap().getPublicKey();
-    }
-
-    @Override
-    public boolean hasUnsupportedCriticalExtension() {
-        return unwrap().hasUnsupportedCriticalExtension();
-    }
-
-    @Override
-    public Set<String> getCriticalExtensionOIDs() {
-        return unwrap().getCriticalExtensionOIDs();
-    }
-
-    @Override
-    public Set<String> getNonCriticalExtensionOIDs() {
-        return unwrap().getNonCriticalExtensionOIDs();
-    }
-
-    @Override
-    public byte[] getExtensionValue(String oid) {
-        return unwrap().getExtensionValue(oid);
-    }
-
-    private X509Certificate unwrap() {
-        X509Certificate wrapped = this.wrapped;
-        if (wrapped == null) {
-            try {
-                wrapped = this.wrapped = (X509Certificate) OpenSSLContext.X509_CERT_FACTORY.generateCertificate(
-                        new ByteArrayInputStream(bytes));
-            } catch (CertificateException e) {
-                throw new IllegalStateException(e);
-            }
-        }
-        return wrapped;
-    }
-}

==================================================
SSL_CTX_set_cert_verify_callback$cb.java
deleted file mode 100644
index 935a017570..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/RuntimeHelper.java
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.tomcat.util.openssl;
-// Generated by jextract
-
-import jdk.incubator.foreign.Addressable;
-import jdk.incubator.foreign.CLinker;
-import jdk.incubator.foreign.FunctionDescriptor;
-import jdk.incubator.foreign.GroupLayout;
-import jdk.incubator.foreign.NativeSymbol;
-import jdk.incubator.foreign.SymbolLookup;
-import jdk.incubator.foreign.MemoryAddress;
-import jdk.incubator.foreign.MemoryLayout;
-import jdk.incubator.foreign.MemorySegment;
-import jdk.incubator.foreign.ResourceScope;
-import jdk.incubator.foreign.SegmentAllocator;
-import jdk.incubator.foreign.ValueLayout;
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodHandles;
-import java.lang.invoke.MethodType;
-import java.io.File;
-import java.nio.file.Path;
-import java.nio.charset.StandardCharsets;
-import java.util.Arrays;
-import java.util.Optional;
-import java.util.stream.Stream;
-
-import static jdk.incubator.foreign.CLinker.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-
-final class RuntimeHelper {
-
-    private RuntimeHelper() {}
-    private final static CLinker LINKER = CLinker.systemCLinker();
-    private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();
-    private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();
-    private final static SymbolLookup SYMBOL_LOOKUP;
-
-    final static SegmentAllocator CONSTANT_ALLOCATOR =
-            (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());
-
-    static {
-        System.loadLibrary("ssl");
-        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();
-        SYMBOL_LOOKUP = name -> loaderLookup.lookup(name).or(() -> LINKER.lookup(name));
-    }
-
-    static <T> T requireNonNull(T obj, String symbolName) {
-        if (obj == null) {
-            throw new UnsatisfiedLinkError("unresolved symbol: " + symbolName);
-        }
-        return obj;
-    }
-
-    private final static SegmentAllocator THROWING_ALLOCATOR = (x, y) -> { throw new AssertionError("should not reach here"); };
-
-    static final MemorySegment lookupGlobalVariable(String name, MemoryLayout layout) {
-        return SYMBOL_LOOKUP.lookup(name).map(symbol -> MemorySegment.ofAddressNative(symbol.address(), layout.byteSize(), ResourceScope.newSharedScope())).orElse(null);
-    }
-
-    static final MethodHandle downcallHandle(String name, FunctionDescriptor fdesc, boolean variadic) {
-        return SYMBOL_LOOKUP.lookup(name).map(
-                addr -> {
-                    return variadic ?
-                        VarargsInvoker.make(addr, fdesc) :
-                        LINKER.downcallHandle(addr, fdesc);
-                }).orElse(null);
-    }
-
-    static final MethodHandle downcallHandle(FunctionDescriptor fdesc, boolean variadic) {
-        if (variadic) {
-            throw new AssertionError("Cannot get here!");
-        }
-        return LINKER.downcallHandle(fdesc);
-    }
-
-    static final <Z> NativeSymbol upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc, ResourceScope scope) {
-        try {
-            MethodHandle handle = MH_LOOKUP.findVirtual(fi, "apply",
-                    MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));
-            handle = handle.bindTo(z);
-            return LINKER.upcallStub(handle, fdesc, scope);
-        } catch (Throwable ex) {
-            throw new AssertionError(ex);
-        }
-    }
-
-    static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements, ResourceScope scope) {
-         return MemorySegment.ofAddressNative(addr, numElements * layout.byteSize(), scope);
-    }
-
-    // Internals only below this point
-
-    private static class VarargsInvoker {
-        private static final MethodHandle INVOKE_MH;
-        private final NativeSymbol symbol;
-        private final FunctionDescriptor function;
-
-        private VarargsInvoker(NativeSymbol symbol, FunctionDescriptor function) {
-            this.symbol = symbol;
-            this.function = function;
-        }
-
-        static {
-            try {
-                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, "invoke", MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class));
-            } catch (ReflectiveOperationException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        static MethodHandle make(NativeSymbol symbol, FunctionDescriptor function) {
-            VarargsInvoker invoker = new VarargsInvoker(symbol, function);
-            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, function.argumentLayouts().size() + 1);
-            MethodType mtype = MethodType.methodType(function.returnLayout().isPresent() ? carrier(function.returnLayout().get(), true) : void.class);
-            for (MemoryLayout layout : function.argumentLayouts()) {
-                mtype = mtype.appendParameterTypes(carrier(layout, false));
-            }
-            mtype = mtype.appendParameterTypes(Object[].class);
-            if (mtype.returnType().equals(MemorySegment.class)) {
-                mtype = mtype.insertParameterTypes(0, SegmentAllocator.class);
-            } else {
-                handle = MethodHandles.insertArguments(handle, 0, THROWING_ALLOCATOR);
-            }
-            return handle.asType(mtype);
-        }
-
-        static Class<?> carrier(MemoryLayout layout, boolean ret) {
-            if (layout instanceof ValueLayout valueLayout) {
-                return (ret || valueLayout.carrier() != MemoryAddress.class) ?
-                        valueLayout.carrier() : Addressable.class;
-            } else if (layout instanceof GroupLayout) {
-                return MemorySegment.class;
-            } else {
-                throw new AssertionError("Cannot get here!");
-            }
-        }
-
-        private Object invoke(SegmentAllocator allocator, Object[] args) throws Throwable {
-            // one trailing Object[]
-            int nNamedArgs = function.argumentLayouts().size();
-            assert(args.length == nNamedArgs + 1);
-            // The last argument is the array of vararg collector
-            Object[] unnamedArgs = (Object[]) args[args.length - 1];
-
-            int argsCount = nNamedArgs + unnamedArgs.length;
-            Class<?>[] argTypes = new Class<?>[argsCount];
-            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];
-
-            int pos = 0;
-            for (pos = 0; pos < nNamedArgs; pos++) {
-                argLayouts[pos] = function.argumentLayouts().get(pos);
-            }
-
-            assert pos == nNamedArgs;
-            for (Object o: unnamedArgs) {
-                argLayouts[pos] = variadicLayout(normalize(o.getClass()));
-                pos++;
-            }
-            assert pos == argsCount;
-
-            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?
-                    FunctionDescriptor.ofVoid(argLayouts) :
-                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);
-            MethodHandle mh = LINKER.downcallHandle(symbol, f);
-            if (mh.type().returnType() == MemorySegment.class) {
-                mh = mh.bindTo(allocator);
-            }
-            // flatten argument list so that it can be passed to an asSpreader MH
-            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];
-            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);
-            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);
-
-            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);
-        }
-
-        private static Class<?> unboxIfNeeded(Class<?> clazz) {
-            if (clazz == Boolean.class) {
-                return boolean.class;
-            } else if (clazz == Void.class) {
-                return void.class;
-            } else if (clazz == Byte.class) {
-                return byte.class;
-            } else if (clazz == Character.class) {
-                return char.class;
-            } else if (clazz == Short.class) {
-                return short.class;
-            } else if (clazz == Integer.class) {
-                return int.class;
-            } else if (clazz == Long.class) {
-                return long.class;
-            } else if (clazz == Float.class) {
-                return float.class;
-            } else if (clazz == Double.class) {
-                return double.class;
-            } else {
-                return clazz;
-            }
-        }
-
-        private Class<?> promote(Class<?> c) {
-            if (c == byte.class || c == char.class || c == short.class || c == int.class) {
-                return long.class;
-            } else if (c == float.class) {
-                return double.class;
-            } else {
-                return c;
-            }
-        }
-
-        private Class<?> normalize(Class<?> c) {
-            c = unboxIfNeeded(c);
-            if (c.isPrimitive()) {
-                return promote(c);
-            }
-            if (MemoryAddress.class.isAssignableFrom(c)) {
-                return MemoryAddress.class;
-            }
-            if (MemorySegment.class.isAssignableFrom(c)) {
-                return MemorySegment.class;
-            }
-            throw new IllegalArgumentException("Invalid type for ABI: " + c.getTypeName());
-        }
-
-        private MemoryLayout variadicLayout(Class<?> c) {
-            if (c == long.class) {
-                return JAVA_LONG;
-            } else if (c == double.class) {
-                return JAVA_DOUBLE;
-            } else if (MemoryAddress.class.isAssignableFrom(c)) {
-                return ADDRESS;
-            } else {
-                throw new IllegalArgumentException("Unhandled variadic argument class: " + c);
-            }
-        }
-    }
-}

==================================================
SSL_CTX_set_tmp_dh_callback$dh.java
deleted file mode 100644
index 9df644f6d3..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/SSL_CTX_set_cert_verify_callback$cb.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-public interface SSL_CTX_set_cert_verify_callback$cb {
-
-    int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
-    static NativeSymbol allocate(SSL_CTX_set_cert_verify_callback$cb fi, ResourceScope scope) {
-        return RuntimeHelper.upcallStub(SSL_CTX_set_cert_verify_callback$cb.class, fi, constants$15.SSL_CTX_set_cert_verify_callback$cb$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
-    }
-    static SSL_CTX_set_cert_verify_callback$cb ofAddress(MemoryAddress addr, ResourceScope scope) {
-        NativeSymbol symbol = NativeSymbol.ofAddress("SSL_CTX_set_cert_verify_callback$cb::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
-return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
-            try {
-                return (int)constants$15.SSL_CTX_set_cert_verify_callback$cb$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
-            } catch (Throwable ex$) {
-                throw new AssertionError("should not reach here", ex$);
-            }
-        };
-    }
-}
-
-

==================================================
SSL_set_info_callback$cb.java
deleted file mode 100644
index 9fcbdc8b9e..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/SSL_CTX_set_tmp_dh_callback$dh.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-public interface SSL_CTX_set_tmp_dh_callback$dh {
-
-    jdk.incubator.foreign.Addressable apply(jdk.incubator.foreign.MemoryAddress x0, int x1, int x2);
-    static NativeSymbol allocate(SSL_CTX_set_tmp_dh_callback$dh fi, ResourceScope scope) {
-        return RuntimeHelper.upcallStub(SSL_CTX_set_tmp_dh_callback$dh.class, fi, constants$21.SSL_CTX_set_tmp_dh_callback$dh$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;II)Ljdk/incubator/foreign/Addressable;", scope);
-    }
-    static SSL_CTX_set_tmp_dh_callback$dh ofAddress(MemoryAddress addr, ResourceScope scope) {
-        NativeSymbol symbol = NativeSymbol.ofAddress("SSL_CTX_set_tmp_dh_callback$dh::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
-return (jdk.incubator.foreign.MemoryAddress x0, int x1, int x2) -> {
-            try {
-                return (jdk.incubator.foreign.Addressable)(jdk.incubator.foreign.MemoryAddress)constants$21.SSL_CTX_set_tmp_dh_callback$dh$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1, x2);
-            } catch (Throwable ex$) {
-                throw new AssertionError("should not reach here", ex$);
-            }
-        };
-    }
-}
-
-

==================================================
constants$0.java
deleted file mode 100644
index 4d58c12676..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/SSL_set_info_callback$cb.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-public interface SSL_set_info_callback$cb {
-
-    void apply(jdk.incubator.foreign.MemoryAddress x0, int x1, int x2);
-    static NativeSymbol allocate(SSL_set_info_callback$cb fi, ResourceScope scope) {
-        return RuntimeHelper.upcallStub(SSL_set_info_callback$cb.class, fi, constants$20.SSL_set_info_callback$cb$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;II)V", scope);
-    }
-    static SSL_set_info_callback$cb ofAddress(MemoryAddress addr, ResourceScope scope) {
-        NativeSymbol symbol = NativeSymbol.ofAddress("SSL_set_info_callback$cb::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
-return (jdk.incubator.foreign.MemoryAddress x0, int x1, int x2) -> {
-            try {
-                constants$20.SSL_set_info_callback$cb$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1, x2);
-            } catch (Throwable ex$) {
-                throw new AssertionError("should not reach here", ex$);
-            }
-        };
-    }
-}
-
-

==================================================
constants$1.java
deleted file mode 100644
index 67b5c8bc11..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$0.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$0 {
-
-    static final FunctionDescriptor OPENSSL_sk_num$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle OPENSSL_sk_num$MH = RuntimeHelper.downcallHandle(
-        "OPENSSL_sk_num",
-        constants$0.OPENSSL_sk_num$FUNC, false
-    );
-    static final FunctionDescriptor OPENSSL_sk_value$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle OPENSSL_sk_value$MH = RuntimeHelper.downcallHandle(
-        "OPENSSL_sk_value",
-        constants$0.OPENSSL_sk_value$FUNC, false
-    );
-    static final FunctionDescriptor CRYPTO_free$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle CRYPTO_free$MH = RuntimeHelper.downcallHandle(
-        "CRYPTO_free",
-        constants$0.CRYPTO_free$FUNC, false
-    );
-    static final FunctionDescriptor FIPS_mode$FUNC = FunctionDescriptor.of(JAVA_INT);
-    static final MethodHandle FIPS_mode$MH = RuntimeHelper.downcallHandle(
-        "FIPS_mode",
-        constants$0.FIPS_mode$FUNC, false
-    );
-    static final FunctionDescriptor FIPS_mode_set$FUNC = FunctionDescriptor.of(JAVA_INT,
-        JAVA_INT
-    );
-    static final MethodHandle FIPS_mode_set$MH = RuntimeHelper.downcallHandle(
-        "FIPS_mode_set",
-        constants$0.FIPS_mode_set$FUNC, false
-    );
-    static final FunctionDescriptor BIO_ctrl_pending$FUNC = FunctionDescriptor.of(JAVA_LONG,
-        ADDRESS
-    );
-    static final MethodHandle BIO_ctrl_pending$MH = RuntimeHelper.downcallHandle(
-        "BIO_ctrl_pending",
-        constants$0.BIO_ctrl_pending$FUNC, false
-    );
-}
-
-

==================================================
constants$10.java
deleted file mode 100644
index f381b13b78..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$1.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$1 {
-
-    static final FunctionDescriptor BIO_s_file$FUNC = FunctionDescriptor.of(ADDRESS);
-    static final MethodHandle BIO_s_file$MH = RuntimeHelper.downcallHandle(
-        "BIO_s_file",
-        constants$1.BIO_s_file$FUNC, false
-    );
-    static final FunctionDescriptor BIO_new_file$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle BIO_new_file$MH = RuntimeHelper.downcallHandle(
-        "BIO_new_file",
-        constants$1.BIO_new_file$FUNC, false
-    );
-    static final FunctionDescriptor BIO_new$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle BIO_new$MH = RuntimeHelper.downcallHandle(
-        "BIO_new",
-        constants$1.BIO_new$FUNC, false
-    );
-    static final FunctionDescriptor BIO_free$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle BIO_free$MH = RuntimeHelper.downcallHandle(
-        "BIO_free",
-        constants$1.BIO_free$FUNC, false
-    );
-    static final FunctionDescriptor BIO_read$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle BIO_read$MH = RuntimeHelper.downcallHandle(
-        "BIO_read",
-        constants$1.BIO_read$FUNC, false
-    );
-    static final FunctionDescriptor BIO_write$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle BIO_write$MH = RuntimeHelper.downcallHandle(
-        "BIO_write",
-        constants$1.BIO_write$FUNC, false
-    );
-}
-
-

==================================================
constants$11.java
deleted file mode 100644
index ea3d91d7ae..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$10.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$10 {
-
-    static final FunctionDescriptor SSL_CTX_get_options$FUNC = FunctionDescriptor.of(JAVA_LONG,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_get_options$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_get_options",
-        constants$10.SSL_CTX_get_options$FUNC, false
-    );
-    static final FunctionDescriptor SSL_get_options$FUNC = FunctionDescriptor.of(JAVA_LONG,
-        ADDRESS
-    );
-    static final MethodHandle SSL_get_options$MH = RuntimeHelper.downcallHandle(
-        "SSL_get_options",
-        constants$10.SSL_get_options$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_clear_options$FUNC = FunctionDescriptor.of(JAVA_LONG,
-        ADDRESS,
-        JAVA_LONG
-    );
-    static final MethodHandle SSL_CTX_clear_options$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_clear_options",
-        constants$10.SSL_CTX_clear_options$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_set_options$FUNC = FunctionDescriptor.of(JAVA_LONG,
-        ADDRESS,
-        JAVA_LONG
-    );
-    static final MethodHandle SSL_CTX_set_options$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_set_options",
-        constants$10.SSL_CTX_set_options$FUNC, false
-    );
-    static final FunctionDescriptor SSL_set_options$FUNC = FunctionDescriptor.of(JAVA_LONG,
-        ADDRESS,
-        JAVA_LONG
-    );
-    static final MethodHandle SSL_set_options$MH = RuntimeHelper.downcallHandle(
-        "SSL_set_options",
-        constants$10.SSL_set_options$FUNC, false
-    );
-    static final FunctionDescriptor SSL_get0_next_proto_negotiated$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_get0_next_proto_negotiated$MH = RuntimeHelper.downcallHandle(
-        "SSL_get0_next_proto_negotiated",
-        constants$10.SSL_get0_next_proto_negotiated$FUNC, false
-    );
-}
-
-

==================================================
constants$12.java
deleted file mode 100644
index 86e51501a3..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$11.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$11 {
-
-    static final FunctionDescriptor SSL_CTX_set_alpn_select_cb$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_set_alpn_select_cb$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_set_alpn_select_cb",
-        constants$11.SSL_CTX_set_alpn_select_cb$FUNC, false
-    );
-    static final FunctionDescriptor SSL_get0_alpn_selected$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_get0_alpn_selected$MH = RuntimeHelper.downcallHandle(
-        "SSL_get0_alpn_selected",
-        constants$11.SSL_get0_alpn_selected$FUNC, false
-    );
-    static final FunctionDescriptor SSL_in_init$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle SSL_in_init$MH = RuntimeHelper.downcallHandle(
-        "SSL_in_init",
-        constants$11.SSL_in_init$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_set_cipher_list$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_set_cipher_list$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_set_cipher_list",
-        constants$11.SSL_CTX_set_cipher_list$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_new$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_new$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_new",
-        constants$11.SSL_CTX_new$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_free$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_free$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_free",
-        constants$11.SSL_CTX_free$FUNC, false
-    );
-}
-
-

==================================================
constants$13.java
deleted file mode 100644
index 7ba1cc018d..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$12.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$12 {
-
-    static final FunctionDescriptor SSL_CTX_set_timeout$FUNC = FunctionDescriptor.of(JAVA_LONG,
-        ADDRESS,
-        JAVA_LONG
-    );
-    static final MethodHandle SSL_CTX_set_timeout$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_set_timeout",
-        constants$12.SSL_CTX_set_timeout$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_get_timeout$FUNC = FunctionDescriptor.of(JAVA_LONG,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_get_timeout$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_get_timeout",
-        constants$12.SSL_CTX_get_timeout$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_get_cert_store$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_get_cert_store$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_get_cert_store",
-        constants$12.SSL_CTX_get_cert_store$FUNC, false
-    );
-    static final FunctionDescriptor SSL_get_current_cipher$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_get_current_cipher$MH = RuntimeHelper.downcallHandle(
-        "SSL_get_current_cipher",
-        constants$12.SSL_get_current_cipher$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CIPHER_get_name$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CIPHER_get_name$MH = RuntimeHelper.downcallHandle(
-        "SSL_CIPHER_get_name",
-        constants$12.SSL_CIPHER_get_name$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CIPHER_get_kx_nid$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CIPHER_get_kx_nid$MH = RuntimeHelper.downcallHandle(
-        "SSL_CIPHER_get_kx_nid",
-        constants$12.SSL_CIPHER_get_kx_nid$FUNC, false
-    );
-}
-
-

==================================================
constants$14.java
deleted file mode 100644
index d682bc9769..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$13.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$13 {
-
-    static final FunctionDescriptor SSL_CIPHER_get_auth_nid$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CIPHER_get_auth_nid$MH = RuntimeHelper.downcallHandle(
-        "SSL_CIPHER_get_auth_nid",
-        constants$13.SSL_CIPHER_get_auth_nid$FUNC, false
-    );
-    static final FunctionDescriptor SSL_pending$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle SSL_pending$MH = RuntimeHelper.downcallHandle(
-        "SSL_pending",
-        constants$13.SSL_pending$FUNC, false
-    );
-    static final FunctionDescriptor SSL_set_bio$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_set_bio$MH = RuntimeHelper.downcallHandle(
-        "SSL_set_bio",
-        constants$13.SSL_set_bio$FUNC, false
-    );
-    static final FunctionDescriptor SSL_set_cipher_list$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_set_cipher_list$MH = RuntimeHelper.downcallHandle(
-        "SSL_set_cipher_list",
-        constants$13.SSL_set_cipher_list$FUNC, false
-    );
-    static final FunctionDescriptor SSL_set_verify$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle SSL_set_verify$MH = RuntimeHelper.downcallHandle(
-        "SSL_set_verify",
-        constants$13.SSL_set_verify$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_use_certificate_chain_file$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_use_certificate_chain_file$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_use_certificate_chain_file",
-        constants$13.SSL_CTX_use_certificate_chain_file$FUNC, false
-    );
-}
-
-

==================================================
constants$15.java
deleted file mode 100644
index 3be40cad28..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$14.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$14 {
-
-    static final FunctionDescriptor SSL_load_client_CA_file$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_load_client_CA_file$MH = RuntimeHelper.downcallHandle(
-        "SSL_load_client_CA_file",
-        constants$14.SSL_load_client_CA_file$FUNC, false
-    );
-    static final FunctionDescriptor SSL_add_file_cert_subjects_to_stack$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_add_file_cert_subjects_to_stack$MH = RuntimeHelper.downcallHandle(
-        "SSL_add_file_cert_subjects_to_stack",
-        constants$14.SSL_add_file_cert_subjects_to_stack$FUNC, false
-    );
-    static final FunctionDescriptor SSL_SESSION_get_time$FUNC = FunctionDescriptor.of(JAVA_LONG,
-        ADDRESS
-    );
-    static final MethodHandle SSL_SESSION_get_time$MH = RuntimeHelper.downcallHandle(
-        "SSL_SESSION_get_time",
-        constants$14.SSL_SESSION_get_time$FUNC, false
-    );
-    static final FunctionDescriptor SSL_SESSION_get_id$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_SESSION_get_id$MH = RuntimeHelper.downcallHandle(
-        "SSL_SESSION_get_id",
-        constants$14.SSL_SESSION_get_id$FUNC, false
-    );
-    static final FunctionDescriptor SSL_get_peer_certificate$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_get_peer_certificate$MH = RuntimeHelper.downcallHandle(
-        "SSL_get_peer_certificate",
-        constants$14.SSL_get_peer_certificate$FUNC, false
-    );
-    static final FunctionDescriptor SSL_get_peer_cert_chain$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_get_peer_cert_chain$MH = RuntimeHelper.downcallHandle(
-        "SSL_get_peer_cert_chain",
-        constants$14.SSL_get_peer_cert_chain$FUNC, false
-    );
-}
-
-

==================================================
constants$16.java
deleted file mode 100644
index d331dba419..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$15.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$15 {
-
-    static final FunctionDescriptor SSL_CTX_set_verify$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_set_verify$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_set_verify",
-        constants$15.SSL_CTX_set_verify$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_set_cert_verify_callback$cb$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_set_cert_verify_callback$cb$MH = RuntimeHelper.downcallHandle(
-        constants$15.SSL_CTX_set_cert_verify_callback$cb$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_set_cert_verify_callback$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_set_cert_verify_callback$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_set_cert_verify_callback",
-        constants$15.SSL_CTX_set_cert_verify_callback$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_use_PrivateKey$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_use_PrivateKey$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_use_PrivateKey",
-        constants$15.SSL_CTX_use_PrivateKey$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_use_certificate$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_use_certificate$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_use_certificate",
-        constants$15.SSL_CTX_use_certificate$FUNC, false
-    );
-}
-
-

==================================================
constants$17.java
deleted file mode 100644
index c502ad25e8..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$16.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$16 {
-
-    static final FunctionDescriptor SSL_CTX_set_default_passwd_cb$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_set_default_passwd_cb$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_set_default_passwd_cb",
-        constants$16.SSL_CTX_set_default_passwd_cb$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_check_private_key$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_check_private_key$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_check_private_key",
-        constants$16.SSL_CTX_check_private_key$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_set_session_id_context$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle SSL_CTX_set_session_id_context$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_set_session_id_context",
-        constants$16.SSL_CTX_set_session_id_context$FUNC, false
-    );
-    static final FunctionDescriptor SSL_new$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_new$MH = RuntimeHelper.downcallHandle(
-        "SSL_new",
-        constants$16.SSL_new$FUNC, false
-    );
-    static final FunctionDescriptor SSL_free$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS
-    );
-    static final MethodHandle SSL_free$MH = RuntimeHelper.downcallHandle(
-        "SSL_free",
-        constants$16.SSL_free$FUNC, false
-    );
-    static final FunctionDescriptor SSL_read$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle SSL_read$MH = RuntimeHelper.downcallHandle(
-        "SSL_read",
-        constants$16.SSL_read$FUNC, false
-    );
-}
-
-

==================================================
constants$18.java
deleted file mode 100644
index 089e6e2cfa..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$17.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$17 {
-
-    static final FunctionDescriptor SSL_write$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle SSL_write$MH = RuntimeHelper.downcallHandle(
-        "SSL_write",
-        constants$17.SSL_write$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_ctrl$FUNC = FunctionDescriptor.of(JAVA_LONG,
-        ADDRESS,
-        JAVA_INT,
-        JAVA_LONG,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_ctrl$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_ctrl",
-        constants$17.SSL_CTX_ctrl$FUNC, false
-    );
-    static final FunctionDescriptor SSL_get_version$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_get_version$MH = RuntimeHelper.downcallHandle(
-        "SSL_get_version",
-        constants$17.SSL_get_version$FUNC, false
-    );
-    static final FunctionDescriptor TLS_server_method$FUNC = FunctionDescriptor.of(ADDRESS);
-    static final MethodHandle TLS_server_method$MH = RuntimeHelper.downcallHandle(
-        "TLS_server_method",
-        constants$17.TLS_server_method$FUNC, false
-    );
-    static final FunctionDescriptor SSL_get_ciphers$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_get_ciphers$MH = RuntimeHelper.downcallHandle(
-        "SSL_get_ciphers",
-        constants$17.SSL_get_ciphers$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_get_ciphers$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_get_ciphers$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_get_ciphers",
-        constants$17.SSL_CTX_get_ciphers$FUNC, false
-    );
-}
-
-

==================================================
constants$19.java
deleted file mode 100644
index 6f5c72e892..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$18.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$18 {
-
-    static final FunctionDescriptor SSL_do_handshake$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle SSL_do_handshake$MH = RuntimeHelper.downcallHandle(
-        "SSL_do_handshake",
-        constants$18.SSL_do_handshake$FUNC, false
-    );
-    static final FunctionDescriptor SSL_renegotiate$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle SSL_renegotiate$MH = RuntimeHelper.downcallHandle(
-        "SSL_renegotiate",
-        constants$18.SSL_renegotiate$FUNC, false
-    );
-    static final FunctionDescriptor SSL_renegotiate_pending$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle SSL_renegotiate_pending$MH = RuntimeHelper.downcallHandle(
-        "SSL_renegotiate_pending",
-        constants$18.SSL_renegotiate_pending$FUNC, false
-    );
-    static final FunctionDescriptor SSL_shutdown$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle SSL_shutdown$MH = RuntimeHelper.downcallHandle(
-        "SSL_shutdown",
-        constants$18.SSL_shutdown$FUNC, false
-    );
-    static final FunctionDescriptor SSL_verify_client_post_handshake$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle SSL_verify_client_post_handshake$MH = RuntimeHelper.downcallHandle(
-        "SSL_verify_client_post_handshake",
-        constants$18.SSL_verify_client_post_handshake$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_set_client_CA_list$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_set_client_CA_list$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_set_client_CA_list",
-        constants$18.SSL_CTX_set_client_CA_list$FUNC, false
-    );
-}
-
-

==================================================
constants$2.java
deleted file mode 100644
index 963b3836e2..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$19.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$19 {
-
-    static final FunctionDescriptor SSL_CTX_get_client_CA_list$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_get_client_CA_list$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_get_client_CA_list",
-        constants$19.SSL_CTX_get_client_CA_list$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_add_client_CA$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_add_client_CA$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_add_client_CA",
-        constants$19.SSL_CTX_add_client_CA$FUNC, false
-    );
-    static final FunctionDescriptor SSL_set_connect_state$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS
-    );
-    static final MethodHandle SSL_set_connect_state$MH = RuntimeHelper.downcallHandle(
-        "SSL_set_connect_state",
-        constants$19.SSL_set_connect_state$FUNC, false
-    );
-    static final FunctionDescriptor SSL_set_accept_state$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS
-    );
-    static final MethodHandle SSL_set_accept_state$MH = RuntimeHelper.downcallHandle(
-        "SSL_set_accept_state",
-        constants$19.SSL_set_accept_state$FUNC, false
-    );
-    static final FunctionDescriptor SSL_get_privatekey$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_get_privatekey$MH = RuntimeHelper.downcallHandle(
-        "SSL_get_privatekey",
-        constants$19.SSL_get_privatekey$FUNC, false
-    );
-    static final FunctionDescriptor SSL_get_shutdown$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle SSL_get_shutdown$MH = RuntimeHelper.downcallHandle(
-        "SSL_get_shutdown",
-        constants$19.SSL_get_shutdown$FUNC, false
-    );
-}
-
-

==================================================
constants$20.java
deleted file mode 100644
index 3bf3f1acad..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$2.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$2 {
-
-    static final FunctionDescriptor BIO_ctrl$FUNC = FunctionDescriptor.of(JAVA_LONG,
-        ADDRESS,
-        JAVA_INT,
-        JAVA_LONG,
-        ADDRESS
-    );
-    static final MethodHandle BIO_ctrl$MH = RuntimeHelper.downcallHandle(
-        "BIO_ctrl",
-        constants$2.BIO_ctrl$FUNC, false
-    );
-    static final FunctionDescriptor BIO_s_mem$FUNC = FunctionDescriptor.of(ADDRESS);
-    static final MethodHandle BIO_s_mem$MH = RuntimeHelper.downcallHandle(
-        "BIO_s_mem",
-        constants$2.BIO_s_mem$FUNC, false
-    );
-    static final FunctionDescriptor BIO_s_bio$FUNC = FunctionDescriptor.of(ADDRESS);
-    static final MethodHandle BIO_s_bio$MH = RuntimeHelper.downcallHandle(
-        "BIO_s_bio",
-        constants$2.BIO_s_bio$FUNC, false
-    );
-    static final FunctionDescriptor BIO_new_bio_pair$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        JAVA_LONG,
-        ADDRESS,
-        JAVA_LONG
-    );
-    static final MethodHandle BIO_new_bio_pair$MH = RuntimeHelper.downcallHandle(
-        "BIO_new_bio_pair",
-        constants$2.BIO_new_bio_pair$FUNC, false
-    );
-    static final FunctionDescriptor BN_new$FUNC = FunctionDescriptor.of(ADDRESS);
-    static final MethodHandle BN_new$MH = RuntimeHelper.downcallHandle(
-        "BN_new",
-        constants$2.BN_new$FUNC, false
-    );
-    static final FunctionDescriptor BN_set_word$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        JAVA_LONG
-    );
-    static final MethodHandle BN_set_word$MH = RuntimeHelper.downcallHandle(
-        "BN_set_word",
-        constants$2.BN_set_word$FUNC, false
-    );
-}
-
-

==================================================
constants$21.java
deleted file mode 100644
index 0a6115f309..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$20.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$20 {
-
-    static final FunctionDescriptor SSL_CTX_set_default_verify_paths$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_set_default_verify_paths$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_set_default_verify_paths",
-        constants$20.SSL_CTX_set_default_verify_paths$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_load_verify_locations$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_load_verify_locations$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_load_verify_locations",
-        constants$20.SSL_CTX_load_verify_locations$FUNC, false
-    );
-    static final FunctionDescriptor SSL_get_session$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_get_session$MH = RuntimeHelper.downcallHandle(
-        "SSL_get_session",
-        constants$20.SSL_get_session$FUNC, false
-    );
-    static final FunctionDescriptor SSL_set_info_callback$cb$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        JAVA_INT,
-        JAVA_INT
-    );
-    static final MethodHandle SSL_set_info_callback$cb$MH = RuntimeHelper.downcallHandle(
-        constants$20.SSL_set_info_callback$cb$FUNC, false
-    );
-    static final FunctionDescriptor SSL_set_info_callback$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_set_info_callback$MH = RuntimeHelper.downcallHandle(
-        "SSL_set_info_callback",
-        constants$20.SSL_set_info_callback$FUNC, false
-    );
-}
-
-

==================================================
constants$22.java
deleted file mode 100644
index d8aaa85474..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$21.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$21 {
-
-    static final FunctionDescriptor SSL_set_verify_result$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        JAVA_LONG
-    );
-    static final MethodHandle SSL_set_verify_result$MH = RuntimeHelper.downcallHandle(
-        "SSL_set_verify_result",
-        constants$21.SSL_set_verify_result$FUNC, false
-    );
-    static final FunctionDescriptor SSL_get_ex_data_X509_STORE_CTX_idx$FUNC = FunctionDescriptor.of(JAVA_INT);
-    static final MethodHandle SSL_get_ex_data_X509_STORE_CTX_idx$MH = RuntimeHelper.downcallHandle(
-        "SSL_get_ex_data_X509_STORE_CTX_idx",
-        constants$21.SSL_get_ex_data_X509_STORE_CTX_idx$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_set_tmp_dh_callback$dh$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        JAVA_INT,
-        JAVA_INT
-    );
-    static final MethodHandle SSL_CTX_set_tmp_dh_callback$dh$MH = RuntimeHelper.downcallHandle(
-        constants$21.SSL_CTX_set_tmp_dh_callback$dh$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CTX_set_tmp_dh_callback$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CTX_set_tmp_dh_callback$MH = RuntimeHelper.downcallHandle(
-        "SSL_CTX_set_tmp_dh_callback",
-        constants$21.SSL_CTX_set_tmp_dh_callback$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CONF_CTX_new$FUNC = FunctionDescriptor.of(ADDRESS);
-    static final MethodHandle SSL_CONF_CTX_new$MH = RuntimeHelper.downcallHandle(
-        "SSL_CONF_CTX_new",
-        constants$21.SSL_CONF_CTX_new$FUNC, false
-    );
-}
-
-

==================================================
constants$23.java
deleted file mode 100644
index 0e68fc5b3b..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$22.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$22 {
-
-    static final FunctionDescriptor SSL_CONF_CTX_finish$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CONF_CTX_finish$MH = RuntimeHelper.downcallHandle(
-        "SSL_CONF_CTX_finish",
-        constants$22.SSL_CONF_CTX_finish$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CONF_CTX_free$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS
-    );
-    static final MethodHandle SSL_CONF_CTX_free$MH = RuntimeHelper.downcallHandle(
-        "SSL_CONF_CTX_free",
-        constants$22.SSL_CONF_CTX_free$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CONF_CTX_set_flags$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle SSL_CONF_CTX_set_flags$MH = RuntimeHelper.downcallHandle(
-        "SSL_CONF_CTX_set_flags",
-        constants$22.SSL_CONF_CTX_set_flags$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CONF_CTX_set_ssl_ctx$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CONF_CTX_set_ssl_ctx$MH = RuntimeHelper.downcallHandle(
-        "SSL_CONF_CTX_set_ssl_ctx",
-        constants$22.SSL_CONF_CTX_set_ssl_ctx$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CONF_cmd$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CONF_cmd$MH = RuntimeHelper.downcallHandle(
-        "SSL_CONF_cmd",
-        constants$22.SSL_CONF_cmd$FUNC, false
-    );
-    static final FunctionDescriptor SSL_CONF_cmd_value_type$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle SSL_CONF_cmd_value_type$MH = RuntimeHelper.downcallHandle(
-        "SSL_CONF_cmd_value_type",
-        constants$22.SSL_CONF_cmd_value_type$FUNC, false
-    );
-}
-
-

==================================================
constants$24.java
deleted file mode 100644
index ce47bfbaba..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$23.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$23 {
-
-    static final FunctionDescriptor OPENSSL_init_ssl$FUNC = FunctionDescriptor.of(JAVA_INT,
-        JAVA_LONG,
-        ADDRESS
-    );
-    static final MethodHandle OPENSSL_init_ssl$MH = RuntimeHelper.downcallHandle(
-        "OPENSSL_init_ssl",
-        constants$23.OPENSSL_init_ssl$FUNC, false
-    );
-    static final FunctionDescriptor ERR_get_error$FUNC = FunctionDescriptor.of(JAVA_LONG);
-    static final MethodHandle ERR_get_error$MH = RuntimeHelper.downcallHandle(
-        "ERR_get_error",
-        constants$23.ERR_get_error$FUNC, false
-    );
-    static final FunctionDescriptor ERR_peek_last_error$FUNC = FunctionDescriptor.of(JAVA_LONG);
-    static final MethodHandle ERR_peek_last_error$MH = RuntimeHelper.downcallHandle(
-        "ERR_peek_last_error",
-        constants$23.ERR_peek_last_error$FUNC, false
-    );
-    static final FunctionDescriptor ERR_clear_error$FUNC = FunctionDescriptor.ofVoid();
-    static final MethodHandle ERR_clear_error$MH = RuntimeHelper.downcallHandle(
-        "ERR_clear_error",
-        constants$23.ERR_clear_error$FUNC, false
-    );
-    static final FunctionDescriptor ERR_error_string$FUNC = FunctionDescriptor.of(ADDRESS,
-        JAVA_LONG,
-        ADDRESS
-    );
-    static final MethodHandle ERR_error_string$MH = RuntimeHelper.downcallHandle(
-        "ERR_error_string",
-        constants$23.ERR_error_string$FUNC, false
-    );
-    static final FunctionDescriptor PKCS12_verify_mac$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle PKCS12_verify_mac$MH = RuntimeHelper.downcallHandle(
-        "PKCS12_verify_mac",
-        constants$23.PKCS12_verify_mac$FUNC, false
-    );
-}
-
-

==================================================
constants$25.java
deleted file mode 100644
index 2fe8bf5611..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$24.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$24 {
-
-    static final FunctionDescriptor PKCS12_free$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS
-    );
-    static final MethodHandle PKCS12_free$MH = RuntimeHelper.downcallHandle(
-        "PKCS12_free",
-        constants$24.PKCS12_free$FUNC, false
-    );
-    static final FunctionDescriptor PKCS12_parse$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle PKCS12_parse$MH = RuntimeHelper.downcallHandle(
-        "PKCS12_parse",
-        constants$24.PKCS12_parse$FUNC, false
-    );
-    static final FunctionDescriptor d2i_PKCS12_bio$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle d2i_PKCS12_bio$MH = RuntimeHelper.downcallHandle(
-        "d2i_PKCS12_bio",
-        constants$24.d2i_PKCS12_bio$FUNC, false
-    );
-    static final FunctionDescriptor RAND_seed$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle RAND_seed$MH = RuntimeHelper.downcallHandle(
-        "RAND_seed",
-        constants$24.RAND_seed$FUNC, false
-    );
-    static final FunctionDescriptor RAND_load_file$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        JAVA_LONG
-    );
-    static final MethodHandle RAND_load_file$MH = RuntimeHelper.downcallHandle(
-        "RAND_load_file",
-        constants$24.RAND_load_file$FUNC, false
-    );
-    static final FunctionDescriptor X509_check_issued$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle X509_check_issued$MH = RuntimeHelper.downcallHandle(
-        "X509_check_issued",
-        constants$24.X509_check_issued$FUNC, false
-    );
-}
-
-

==================================================
constants$26.java
deleted file mode 100644
index 765f497f2c..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$25.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$25 {
-
-    static final FunctionDescriptor ENGINE_by_id$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle ENGINE_by_id$MH = RuntimeHelper.downcallHandle(
-        "ENGINE_by_id",
-        constants$25.ENGINE_by_id$FUNC, false
-    );
-    static final FunctionDescriptor ENGINE_register_all_complete$FUNC = FunctionDescriptor.of(JAVA_INT);
-    static final MethodHandle ENGINE_register_all_complete$MH = RuntimeHelper.downcallHandle(
-        "ENGINE_register_all_complete",
-        constants$25.ENGINE_register_all_complete$FUNC, false
-    );
-    static final FunctionDescriptor ENGINE_ctrl_cmd_string$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle ENGINE_ctrl_cmd_string$MH = RuntimeHelper.downcallHandle(
-        "ENGINE_ctrl_cmd_string",
-        constants$25.ENGINE_ctrl_cmd_string$FUNC, false
-    );
-    static final FunctionDescriptor ENGINE_free$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle ENGINE_free$MH = RuntimeHelper.downcallHandle(
-        "ENGINE_free",
-        constants$25.ENGINE_free$FUNC, false
-    );
-    static final FunctionDescriptor ENGINE_load_private_key$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle ENGINE_load_private_key$MH = RuntimeHelper.downcallHandle(
-        "ENGINE_load_private_key",
-        constants$25.ENGINE_load_private_key$FUNC, false
-    );
-    static final FunctionDescriptor ENGINE_set_default$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle ENGINE_set_default$MH = RuntimeHelper.downcallHandle(
-        "ENGINE_set_default",
-        constants$25.ENGINE_set_default$FUNC, false
-    );
-}
-
-

==================================================
constants$27.java
deleted file mode 100644
index d29be084d7..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$26.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$26 {
-
-    static final FunctionDescriptor OCSP_cert_to_id$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle OCSP_cert_to_id$MH = RuntimeHelper.downcallHandle(
-        "OCSP_cert_to_id",
-        constants$26.OCSP_cert_to_id$FUNC, false
-    );
-    static final FunctionDescriptor OCSP_request_add0_id$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle OCSP_request_add0_id$MH = RuntimeHelper.downcallHandle(
-        "OCSP_request_add0_id",
-        constants$26.OCSP_request_add0_id$FUNC, false
-    );
-    static final FunctionDescriptor OCSP_response_status$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle OCSP_response_status$MH = RuntimeHelper.downcallHandle(
-        "OCSP_response_status",
-        constants$26.OCSP_response_status$FUNC, false
-    );
-    static final FunctionDescriptor OCSP_response_get1_basic$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle OCSP_response_get1_basic$MH = RuntimeHelper.downcallHandle(
-        "OCSP_response_get1_basic",
-        constants$26.OCSP_response_get1_basic$FUNC, false
-    );
-    static final FunctionDescriptor OCSP_resp_get0$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle OCSP_resp_get0$MH = RuntimeHelper.downcallHandle(
-        "OCSP_resp_get0",
-        constants$26.OCSP_resp_get0$FUNC, false
-    );
-    static final FunctionDescriptor OCSP_resp_find$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle OCSP_resp_find$MH = RuntimeHelper.downcallHandle(
-        "OCSP_resp_find",
-        constants$26.OCSP_resp_find$FUNC, false
-    );
-}
-
-

==================================================
constants$28.java
deleted file mode 100644
index 972249561d..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$27.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$27 {
-
-    static final FunctionDescriptor OCSP_single_get0_status$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle OCSP_single_get0_status$MH = RuntimeHelper.downcallHandle(
-        "OCSP_single_get0_status",
-        constants$27.OCSP_single_get0_status$FUNC, false
-    );
-    static final FunctionDescriptor OCSP_BASICRESP_free$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS
-    );
-    static final MethodHandle OCSP_BASICRESP_free$MH = RuntimeHelper.downcallHandle(
-        "OCSP_BASICRESP_free",
-        constants$27.OCSP_BASICRESP_free$FUNC, false
-    );
-    static final FunctionDescriptor OCSP_RESPONSE_free$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS
-    );
-    static final MethodHandle OCSP_RESPONSE_free$MH = RuntimeHelper.downcallHandle(
-        "OCSP_RESPONSE_free",
-        constants$27.OCSP_RESPONSE_free$FUNC, false
-    );
-    static final FunctionDescriptor d2i_OCSP_RESPONSE$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        JAVA_LONG
-    );
-    static final MethodHandle d2i_OCSP_RESPONSE$MH = RuntimeHelper.downcallHandle(
-        "d2i_OCSP_RESPONSE",
-        constants$27.d2i_OCSP_RESPONSE$FUNC, false
-    );
-    static final FunctionDescriptor OCSP_CERTID_free$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS
-    );
-    static final MethodHandle OCSP_CERTID_free$MH = RuntimeHelper.downcallHandle(
-        "OCSP_CERTID_free",
-        constants$27.OCSP_CERTID_free$FUNC, false
-    );
-    static final FunctionDescriptor OCSP_REQUEST_new$FUNC = FunctionDescriptor.of(ADDRESS);
-    static final MethodHandle OCSP_REQUEST_new$MH = RuntimeHelper.downcallHandle(
-        "OCSP_REQUEST_new",
-        constants$27.OCSP_REQUEST_new$FUNC, false
-    );
-}
-
-

==================================================
constants$29.java
deleted file mode 100644
index 22b3c14b17..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$28.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$28 {
-
-    static final FunctionDescriptor OCSP_REQUEST_free$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS
-    );
-    static final MethodHandle OCSP_REQUEST_free$MH = RuntimeHelper.downcallHandle(
-        "OCSP_REQUEST_free",
-        constants$28.OCSP_REQUEST_free$FUNC, false
-    );
-    static final FunctionDescriptor i2d_OCSP_REQUEST$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle i2d_OCSP_REQUEST$MH = RuntimeHelper.downcallHandle(
-        "i2d_OCSP_REQUEST",
-        constants$28.i2d_OCSP_REQUEST$FUNC, false
-    );
-    static final MemorySegment OPENSSL_VERSION_TEXT$SEGMENT = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String("OpenSSL 1.1.1l  FIPS 24 Aug 2021");
-    static final MemorySegment SHLIB_VERSION_HISTORY$SEGMENT = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String("");
-    static final MemorySegment SHLIB_VERSION_NUMBER$SEGMENT = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String("1.1");
-    static final MemorySegment OPENSSL_FILE$SEGMENT = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String("/tmp/jextract$14118250997508934609.h");
-}
-
-

==================================================
constants$3.java
deleted file mode 100644
index ed011ed3d6..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$29.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$29 {
-
-    static final MemorySegment SSL_TXT_DSS$SEGMENT = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String("DSS");
-    static final MemorySegment SSL_TXT_DH$SEGMENT = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String("DH");
-    static final MemorySegment SSL_TXT_RSA$SEGMENT = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String("RSA");
-    static final MemorySegment SSL_TXT_ECDH$SEGMENT = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String("ECDH");
-    static final MemorySegment SSL_TXT_ECDSA$SEGMENT = RuntimeHelper.CONSTANT_ALLOCATOR.allocateUtf8String("ECDSA");
-}
-
-

==================================================
constants$4.java
deleted file mode 100644
index b3d7c75c2b..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$3.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$3 {
-
-    static final FunctionDescriptor BN_get_rfc2409_prime_768$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle BN_get_rfc2409_prime_768$MH = RuntimeHelper.downcallHandle(
-        "BN_get_rfc2409_prime_768",
-        constants$3.BN_get_rfc2409_prime_768$FUNC, false
-    );
-    static final FunctionDescriptor BN_get_rfc2409_prime_1024$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle BN_get_rfc2409_prime_1024$MH = RuntimeHelper.downcallHandle(
-        "BN_get_rfc2409_prime_1024",
-        constants$3.BN_get_rfc2409_prime_1024$FUNC, false
-    );
-    static final FunctionDescriptor BN_get_rfc3526_prime_1536$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle BN_get_rfc3526_prime_1536$MH = RuntimeHelper.downcallHandle(
-        "BN_get_rfc3526_prime_1536",
-        constants$3.BN_get_rfc3526_prime_1536$FUNC, false
-    );
-    static final FunctionDescriptor BN_get_rfc3526_prime_2048$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle BN_get_rfc3526_prime_2048$MH = RuntimeHelper.downcallHandle(
-        "BN_get_rfc3526_prime_2048",
-        constants$3.BN_get_rfc3526_prime_2048$FUNC, false
-    );
-    static final FunctionDescriptor BN_get_rfc3526_prime_3072$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle BN_get_rfc3526_prime_3072$MH = RuntimeHelper.downcallHandle(
-        "BN_get_rfc3526_prime_3072",
-        constants$3.BN_get_rfc3526_prime_3072$FUNC, false
-    );
-    static final FunctionDescriptor BN_get_rfc3526_prime_4096$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle BN_get_rfc3526_prime_4096$MH = RuntimeHelper.downcallHandle(
-        "BN_get_rfc3526_prime_4096",
-        constants$3.BN_get_rfc3526_prime_4096$FUNC, false
-    );
-}
-
-

==================================================
constants$5.java
deleted file mode 100644
index c27607fc96..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$4.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$4 {
-
-    static final FunctionDescriptor BN_get_rfc3526_prime_6144$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle BN_get_rfc3526_prime_6144$MH = RuntimeHelper.downcallHandle(
-        "BN_get_rfc3526_prime_6144",
-        constants$4.BN_get_rfc3526_prime_6144$FUNC, false
-    );
-    static final FunctionDescriptor BN_get_rfc3526_prime_8192$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle BN_get_rfc3526_prime_8192$MH = RuntimeHelper.downcallHandle(
-        "BN_get_rfc3526_prime_8192",
-        constants$4.BN_get_rfc3526_prime_8192$FUNC, false
-    );
-    static final FunctionDescriptor ASN1_STRING_length$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle ASN1_STRING_length$MH = RuntimeHelper.downcallHandle(
-        "ASN1_STRING_length",
-        constants$4.ASN1_STRING_length$FUNC, false
-    );
-    static final FunctionDescriptor ASN1_STRING_get0_data$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle ASN1_STRING_get0_data$MH = RuntimeHelper.downcallHandle(
-        "ASN1_STRING_get0_data",
-        constants$4.ASN1_STRING_get0_data$FUNC, false
-    );
-    static final FunctionDescriptor EVP_PKEY_base_id$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle EVP_PKEY_base_id$MH = RuntimeHelper.downcallHandle(
-        "EVP_PKEY_base_id",
-        constants$4.EVP_PKEY_base_id$FUNC, false
-    );
-    static final FunctionDescriptor EVP_PKEY_bits$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle EVP_PKEY_bits$MH = RuntimeHelper.downcallHandle(
-        "EVP_PKEY_bits",
-        constants$4.EVP_PKEY_bits$FUNC, false
-    );
-}
-
-

==================================================
constants$6.java
deleted file mode 100644
index 81030be1da..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$5.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$5 {
-
-    static final FunctionDescriptor EC_GROUP_free$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS
-    );
-    static final MethodHandle EC_GROUP_free$MH = RuntimeHelper.downcallHandle(
-        "EC_GROUP_free",
-        constants$5.EC_GROUP_free$FUNC, false
-    );
-    static final FunctionDescriptor EC_GROUP_get_curve_name$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle EC_GROUP_get_curve_name$MH = RuntimeHelper.downcallHandle(
-        "EC_GROUP_get_curve_name",
-        constants$5.EC_GROUP_get_curve_name$FUNC, false
-    );
-    static final FunctionDescriptor EC_KEY_new_by_curve_name$FUNC = FunctionDescriptor.of(ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle EC_KEY_new_by_curve_name$MH = RuntimeHelper.downcallHandle(
-        "EC_KEY_new_by_curve_name",
-        constants$5.EC_KEY_new_by_curve_name$FUNC, false
-    );
-    static final FunctionDescriptor EC_KEY_free$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS
-    );
-    static final MethodHandle EC_KEY_free$MH = RuntimeHelper.downcallHandle(
-        "EC_KEY_free",
-        constants$5.EC_KEY_free$FUNC, false
-    );
-    static final FunctionDescriptor DH_new$FUNC = FunctionDescriptor.of(ADDRESS);
-    static final MethodHandle DH_new$MH = RuntimeHelper.downcallHandle(
-        "DH_new",
-        constants$5.DH_new$FUNC, false
-    );
-    static final FunctionDescriptor DH_free$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS
-    );
-    static final MethodHandle DH_free$MH = RuntimeHelper.downcallHandle(
-        "DH_free",
-        constants$5.DH_free$FUNC, false
-    );
-}
-
-

==================================================
constants$7.java
deleted file mode 100644
index 89c532958f..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$6.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$6 {
-
-    static final FunctionDescriptor DH_set0_pqg$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle DH_set0_pqg$MH = RuntimeHelper.downcallHandle(
-        "DH_set0_pqg",
-        constants$6.DH_set0_pqg$FUNC, false
-    );
-    static final FunctionDescriptor X509_STORE_set_flags$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        JAVA_LONG
-    );
-    static final MethodHandle X509_STORE_set_flags$MH = RuntimeHelper.downcallHandle(
-        "X509_STORE_set_flags",
-        constants$6.X509_STORE_set_flags$FUNC, false
-    );
-    static final FunctionDescriptor X509_STORE_CTX_get0_untrusted$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle X509_STORE_CTX_get0_untrusted$MH = RuntimeHelper.downcallHandle(
-        "X509_STORE_CTX_get0_untrusted",
-        constants$6.X509_STORE_CTX_get0_untrusted$FUNC, false
-    );
-    static final FunctionDescriptor X509_STORE_add_lookup$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle X509_STORE_add_lookup$MH = RuntimeHelper.downcallHandle(
-        "X509_STORE_add_lookup",
-        constants$6.X509_STORE_add_lookup$FUNC, false
-    );
-    static final FunctionDescriptor X509_LOOKUP_hash_dir$FUNC = FunctionDescriptor.of(ADDRESS);
-    static final MethodHandle X509_LOOKUP_hash_dir$MH = RuntimeHelper.downcallHandle(
-        "X509_LOOKUP_hash_dir",
-        constants$6.X509_LOOKUP_hash_dir$FUNC, false
-    );
-    static final FunctionDescriptor X509_LOOKUP_file$FUNC = FunctionDescriptor.of(ADDRESS);
-    static final MethodHandle X509_LOOKUP_file$MH = RuntimeHelper.downcallHandle(
-        "X509_LOOKUP_file",
-        constants$6.X509_LOOKUP_file$FUNC, false
-    );
-}
-
-

==================================================
constants$8.java
deleted file mode 100644
index 6fc95ec503..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$7.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$7 {
-
-    static final FunctionDescriptor X509_LOOKUP_ctrl$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        JAVA_INT,
-        ADDRESS,
-        JAVA_LONG,
-        ADDRESS
-    );
-    static final MethodHandle X509_LOOKUP_ctrl$MH = RuntimeHelper.downcallHandle(
-        "X509_LOOKUP_ctrl",
-        constants$7.X509_LOOKUP_ctrl$FUNC, false
-    );
-    static final FunctionDescriptor X509_STORE_CTX_get_ex_data$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle X509_STORE_CTX_get_ex_data$MH = RuntimeHelper.downcallHandle(
-        "X509_STORE_CTX_get_ex_data",
-        constants$7.X509_STORE_CTX_get_ex_data$FUNC, false
-    );
-    static final FunctionDescriptor X509_STORE_CTX_get_error$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle X509_STORE_CTX_get_error$MH = RuntimeHelper.downcallHandle(
-        "X509_STORE_CTX_get_error",
-        constants$7.X509_STORE_CTX_get_error$FUNC, false
-    );
-    static final FunctionDescriptor X509_STORE_CTX_set_error$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle X509_STORE_CTX_set_error$MH = RuntimeHelper.downcallHandle(
-        "X509_STORE_CTX_set_error",
-        constants$7.X509_STORE_CTX_set_error$FUNC, false
-    );
-    static final FunctionDescriptor X509_STORE_CTX_get_error_depth$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS
-    );
-    static final MethodHandle X509_STORE_CTX_get_error_depth$MH = RuntimeHelper.downcallHandle(
-        "X509_STORE_CTX_get_error_depth",
-        constants$7.X509_STORE_CTX_get_error_depth$FUNC, false
-    );
-    static final FunctionDescriptor X509_STORE_CTX_get_current_cert$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle X509_STORE_CTX_get_current_cert$MH = RuntimeHelper.downcallHandle(
-        "X509_STORE_CTX_get_current_cert",
-        constants$7.X509_STORE_CTX_get_current_cert$FUNC, false
-    );
-}
-
-

==================================================
constants$9.java
deleted file mode 100644
index 7ba9984054..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$8.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$8 {
-
-    static final FunctionDescriptor X509_STORE_CTX_get0_current_issuer$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle X509_STORE_CTX_get0_current_issuer$MH = RuntimeHelper.downcallHandle(
-        "X509_STORE_CTX_get0_current_issuer",
-        constants$8.X509_STORE_CTX_get0_current_issuer$FUNC, false
-    );
-    static final FunctionDescriptor d2i_X509_bio$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle d2i_X509_bio$MH = RuntimeHelper.downcallHandle(
-        "d2i_X509_bio",
-        constants$8.d2i_X509_bio$FUNC, false
-    );
-    static final FunctionDescriptor X509_free$FUNC = FunctionDescriptor.ofVoid(
-        ADDRESS
-    );
-    static final MethodHandle X509_free$MH = RuntimeHelper.downcallHandle(
-        "X509_free",
-        constants$8.X509_free$FUNC, false
-    );
-    static final FunctionDescriptor d2i_X509$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        JAVA_LONG
-    );
-    static final MethodHandle d2i_X509$MH = RuntimeHelper.downcallHandle(
-        "d2i_X509",
-        constants$8.d2i_X509$FUNC, false
-    );
-    static final FunctionDescriptor i2d_X509$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle i2d_X509$MH = RuntimeHelper.downcallHandle(
-        "i2d_X509",
-        constants$8.i2d_X509$FUNC, false
-    );
-    static final FunctionDescriptor X509_get_ext_by_NID$FUNC = FunctionDescriptor.of(JAVA_INT,
-        ADDRESS,
-        JAVA_INT,
-        JAVA_INT
-    );
-    static final MethodHandle X509_get_ext_by_NID$MH = RuntimeHelper.downcallHandle(
-        "X509_get_ext_by_NID",
-        constants$8.X509_get_ext_by_NID$FUNC, false
-    );
-}
-
-

==================================================
openssl_h.java
deleted file mode 100644
index dbf002eeff..0000000000
--- a/modules/openssl-panama-foreign/src/main/java/org/apache/tomcat/util/openssl/constants$9.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Generated by jextract
-
-package org.apache.tomcat.util.openssl;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.VarHandle;
-import java.nio.ByteOrder;
-import jdk.incubator.foreign.*;
-import static jdk.incubator.foreign.ValueLayout.*;
-class constants$9 {
-
-    static final FunctionDescriptor X509_get_ext$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        JAVA_INT
-    );
-    static final MethodHandle X509_get_ext$MH = RuntimeHelper.downcallHandle(
-        "X509_get_ext",
-        constants$9.X509_get_ext$FUNC, false
-    );
-    static final FunctionDescriptor X509_EXTENSION_get_data$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle X509_EXTENSION_get_data$MH = RuntimeHelper.downcallHandle(
-        "X509_EXTENSION_get_data",
-        constants$9.X509_EXTENSION_get_data$FUNC, false
-    );
-    static final FunctionDescriptor PEM_read_bio_X509_AUX$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle PEM_read_bio_X509_AUX$MH = RuntimeHelper.downcallHandle(
-        "PEM_read_bio_X509_AUX",
-        constants$9.PEM_read_bio_X509_AUX$FUNC, false
-    );
-    static final FunctionDescriptor PEM_read_bio_ECPKParameters$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle PEM_read_bio_ECPKParameters$MH = RuntimeHelper.downcallHandle(
-        "PEM_read_bio_ECPKParameters",
-        constants$9.PEM_read_bio_ECPKParameters$FUNC, false
-    );
-    static final FunctionDescriptor PEM_read_bio_DHparams$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle PEM_read_bio_DHparams$MH = RuntimeHelper.downcallHandle(
-        "PEM_read_bio_DHparams",
-        constants$9.PEM_read_bio_DHparams$FUNC, false
-    );
-    static final FunctionDescriptor PEM_read_bio_PrivateKey$FUNC = FunctionDescriptor.of(ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS,
-        ADDRESS
-    );
-    static final MethodHandle PEM_read_bio_PrivateKey$MH = RuntimeHelper.downcallHandle(
-        "PEM_read_bio_PrivateKey",
-        constants$9.PEM_read_bio_PrivateKey$FUNC, false
-    );
-}
-
-

==================================================
