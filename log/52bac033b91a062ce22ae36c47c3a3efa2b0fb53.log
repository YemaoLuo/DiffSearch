52bac033b91a062ce22ae36c47c3a3efa2b0fb53
==================================================
Code cleanup (format). No functional change.
==================================================
Mark Thomas
==================================================
Tue Jan 24 09:57:35 2023 +0000
==================================================
AsyncFileHandler.java
Code cleanup (format). No functional change.


==================================================
ClassLoaderLogManager.java
index 03af375e29..7f8b065d61 100644
--- a/java/org/apache/juli/AsyncFileHandler.java
+++ b/java/org/apache/juli/AsyncFileHandler.java
@@ -26,42 +26,37 @@ import java.util.logging.LogRecord;
 
 /**
  * A {@link FileHandler} implementation that uses a queue of log entries.
- *
- * <p>Configuration properties are inherited from the {@link FileHandler}
- * class. This class does not add its own configuration properties for the
- * logging configuration, but relies on the following system properties
- * instead:</p>
- *
+ * <p>
+ * Configuration properties are inherited from the {@link FileHandler} class. This class does not add its own
+ * configuration properties for the logging configuration, but relies on the following system properties instead:
+ * </p>
  * <ul>
- *   <li><code>org.apache.juli.AsyncOverflowDropType</code>
- *    Default value: <code>1</code></li>
- *   <li><code>org.apache.juli.AsyncMaxRecordCount</code>
- *    Default value: <code>10000</code></li>
+ * <li><code>org.apache.juli.AsyncOverflowDropType</code> Default value: <code>1</code></li>
+ * <li><code>org.apache.juli.AsyncMaxRecordCount</code> Default value: <code>10000</code></li>
  * </ul>
- *
- * <p>See the System Properties page in the configuration reference of Tomcat.</p>
+ * <p>
+ * See the System Properties page in the configuration reference of Tomcat.
+ * </p>
  */
 public class AsyncFileHandler extends FileHandler {
 
     static final String THREAD_PREFIX = "AsyncFileHandlerWriter-";
 
-    public static final int OVERFLOW_DROP_LAST    = 1;
-    public static final int OVERFLOW_DROP_FIRST   = 2;
-    public static final int OVERFLOW_DROP_FLUSH   = 3;
+    public static final int OVERFLOW_DROP_LAST = 1;
+    public static final int OVERFLOW_DROP_FIRST = 2;
+    public static final int OVERFLOW_DROP_FLUSH = 3;
     public static final int OVERFLOW_DROP_CURRENT = 4;
 
     public static final int DEFAULT_OVERFLOW_DROP_TYPE = 1;
-    public static final int DEFAULT_MAX_RECORDS        = 10000;
+    public static final int DEFAULT_MAX_RECORDS = 10000;
 
     public static final int OVERFLOW_DROP_TYPE = Integer.parseInt(
-            System.getProperty("org.apache.juli.AsyncOverflowDropType",
-                               Integer.toString(DEFAULT_OVERFLOW_DROP_TYPE)));
-    public static final int MAX_RECORDS = Integer.parseInt(
-            System.getProperty("org.apache.juli.AsyncMaxRecordCount",
-                               Integer.toString(DEFAULT_MAX_RECORDS)));
+            System.getProperty("org.apache.juli.AsyncOverflowDropType", Integer.toString(DEFAULT_OVERFLOW_DROP_TYPE)));
+    public static final int MAX_RECORDS = Integer
+            .parseInt(System.getProperty("org.apache.juli.AsyncMaxRecordCount", Integer.toString(DEFAULT_MAX_RECORDS)));
 
-    private static final LoggerExecutorService LOGGER_SERVICE =
-            new LoggerExecutorService(OVERFLOW_DROP_TYPE, MAX_RECORDS);
+    private static final LoggerExecutorService LOGGER_SERVICE = new LoggerExecutorService(OVERFLOW_DROP_TYPE,
+            MAX_RECORDS);
 
     private final Object closeLock = new Object();
     protected volatile boolean closed = false;
@@ -129,9 +124,8 @@ public class AsyncFileHandler extends FileHandler {
             @Override
             public void run() {
                 /*
-                 * During Tomcat shutdown, the Handlers are closed before the
-                 * executor queue is flushed therefore the closed flag is
-                 * ignored if the executor is shutting down.
+                 * During Tomcat shutdown, the Handlers are closed before the executor queue is flushed therefore the
+                 * closed flag is ignored if the executor is shutting down.
                  */
                 if (!closed || loggerService.isTerminating()) {
                     publishInternal(record);
@@ -150,11 +144,9 @@ public class AsyncFileHandler extends FileHandler {
         private static final ThreadFactory THREAD_FACTORY = new ThreadFactory(THREAD_PREFIX);
 
         /*
-         * Implementation note: Use of this count could be extended to
-         * start/stop the LoggerExecutorService but that would require careful
-         * locking as the current size of the queue also needs to be taken into
-         * account and there are lost of edge cases when rapidly starting and
-         * stopping handlers.
+         * Implementation note: Use of this count could be extended to start/stop the LoggerExecutorService but that
+         * would require careful locking as the current size of the queue also needs to be taken into account and there
+         * are lost of edge cases when rapidly starting and stopping handlers.
          */
         private final AtomicInteger handlerCount = new AtomicInteger();
 

==================================================
DateFormatCache.java
index 77e7a81720..701fd01168 100644
--- a/java/org/apache/juli/ClassLoaderLogManager.java
+++ b/java/org/apache/juli/ClassLoaderLogManager.java
@@ -37,18 +37,15 @@ import java.util.logging.Logger;
 
 
 /**
- * Per classloader LogManager implementation.
- *
- * For light debugging, set the system property
- * <code>org.apache.juli.ClassLoaderLogManager.debug=true</code>.
- * Short configuration information will be sent to <code>System.err</code>.
+ * Per classloader LogManager implementation. For light debugging, set the system property
+ * <code>org.apache.juli.ClassLoaderLogManager.debug=true</code>. Short configuration information will be sent to
+ * <code>System.err</code>.
  */
 public class ClassLoaderLogManager extends LogManager {
 
     private static ThreadLocal<Boolean> addingLocalRootLogger = ThreadLocal.withInitial(() -> Boolean.FALSE);
 
-    public static final String DEBUG_PROPERTY =
-            ClassLoaderLogManager.class.getName() + ".debug";
+    public static final String DEBUG_PROPERTY = ClassLoaderLogManager.class.getName() + ".debug";
 
     private final class Cleaner extends Thread {
 
@@ -78,26 +75,22 @@ public class ClassLoaderLogManager extends LogManager {
 
 
     /**
-     * Map containing the classloader information, keyed per classloader. A
-     * weak hashmap is used to ensure no classloader reference is leaked from
-     * application redeployment.
+     * Map containing the classloader information, keyed per classloader. A weak hashmap is used to ensure no
+     * classloader reference is leaked from application redeployment.
      */
-    protected final Map<ClassLoader, ClassLoaderLogInfo> classLoaderLoggers =
-            new WeakHashMap<>(); // Guarded by this
+    protected final Map<ClassLoader, ClassLoaderLogInfo> classLoaderLoggers = new WeakHashMap<>(); // Guarded by this
 
 
     /**
-     * This prefix is used to allow using prefixes for the properties names
-     * of handlers and their subcomponents.
+     * This prefix is used to allow using prefixes for the properties names of handlers and their subcomponents.
      */
     protected final ThreadLocal<String> prefix = new ThreadLocal<>();
 
 
     /**
-     * Determines if the shutdown hook is used to perform any necessary
-     * clean-up such as flushing buffered handlers on JVM shutdown. Defaults to
-     * <code>true</code> but may be set to false if another component ensures
-     * that {@link #shutdown()} is called.
+     * Determines if the shutdown hook is used to perform any necessary clean-up such as flushing buffered handlers on
+     * JVM shutdown. Defaults to <code>true</code> but may be set to false if another component ensures that
+     * {@link #shutdown()} is called.
      */
     protected volatile boolean useShutdownHook = true;
 
@@ -201,10 +194,8 @@ public class ClassLoaderLogManager extends LogManager {
 
 
     /**
-     * Get the logger associated with the specified name inside
-     * the classloader local configuration. If this returns null,
-     * and the call originated for Logger.getLogger, a new
-     * logger with the specified name will be instantiated and
+     * Get the logger associated with the specified name inside the classloader local configuration. If this returns
+     * null, and the call originated for Logger.getLogger, a new logger with the specified name will be instantiated and
      * added using addLogger.
      *
      * @param name The name of the logger to retrieve
@@ -217,8 +208,7 @@ public class ClassLoaderLogManager extends LogManager {
 
 
     /**
-     * Get an enumeration of the logger names currently defined in the
-     * classloader local configuration.
+     * Get an enumeration of the logger names currently defined in the classloader local configuration.
      */
     @Override
     public synchronized Enumeration<String> getLoggerNames() {
@@ -228,8 +218,7 @@ public class ClassLoaderLogManager extends LogManager {
 
 
     /**
-     * Get the value of the specified property in the classloader local
-     * configuration.
+     * Get the value of the specified property in the classloader local configuration.
      *
      * @param name The property name
      */
@@ -306,8 +295,7 @@ public class ClassLoaderLogManager extends LogManager {
     @Override
     public void reset() throws SecurityException {
         Thread thread = Thread.currentThread();
-        if (thread.getClass().getName().startsWith(
-                "java.util.logging.LogManager$")) {
+        if (thread.getClass().getName().startsWith("java.util.logging.LogManager$")) {
             // Ignore the call from java.util.logging.LogManager.Cleaner,
             // because we have our own shutdown hook
             return;
@@ -363,12 +351,11 @@ public class ClassLoaderLogManager extends LogManager {
 
 
     /**
-     * Retrieve the configuration associated with the specified classloader. If
-     * it does not exist, it will be created. If no class loader is specified,
-     * the class loader used to load this class is used.
+     * Retrieve the configuration associated with the specified classloader. If it does not exist, it will be created.
+     * If no class loader is specified, the class loader used to load this class is used.
+     *
+     * @param classLoader The class loader for which we will retrieve or build the configuration
      *
-     * @param classLoader The class loader for which we will retrieve or build
-     *                    the configuration
      * @return the log configuration
      */
     protected synchronized ClassLoaderLogInfo getClassLoaderInfo(ClassLoader classLoader) {
@@ -393,31 +380,27 @@ public class ClassLoaderLogManager extends LogManager {
      * Read configuration for the specified classloader.
      *
      * @param classLoader The classloader
+     *
      * @throws IOException Error reading configuration
      */
-    protected synchronized void readConfiguration(ClassLoader classLoader)
-        throws IOException {
+    protected synchronized void readConfiguration(ClassLoader classLoader) throws IOException {
 
         InputStream is = null;
         // Special case for URL classloaders which are used in containers:
         // only look in the local repositories to avoid redefining loggers 20 times
         if (classLoader instanceof URLClassLoader) {
-            URL logConfig = ((URLClassLoader)classLoader).findResource("logging.properties");
-
-            if(null != logConfig) {
-                if(Boolean.getBoolean(DEBUG_PROPERTY)) {
-                    System.err.println(getClass().getName()
-                                       + ".readConfiguration(): "
-                                       + "Found logging.properties at "
-                                       + logConfig);
+            URL logConfig = ((URLClassLoader) classLoader).findResource("logging.properties");
+
+            if (null != logConfig) {
+                if (Boolean.getBoolean(DEBUG_PROPERTY)) {
+                    System.err.println(getClass().getName() + ".readConfiguration(): " +
+                            "Found logging.properties at " + logConfig);
                 }
 
                 is = classLoader.getResourceAsStream("logging.properties");
             } else {
-                if(Boolean.getBoolean(DEBUG_PROPERTY)) {
-                    System.err.println(getClass().getName()
-                                       + ".readConfiguration(): "
-                                       + "Found no logging.properties");
+                if (Boolean.getBoolean(DEBUG_PROPERTY)) {
+                    System.err.println(getClass().getName() + ".readConfiguration(): " + "Found no logging.properties");
                 }
             }
         }
@@ -433,8 +416,7 @@ public class ClassLoaderLogManager extends LogManager {
             }
             // Try the default JVM configuration
             if (is == null) {
-                File defaultFile = new File(new File(System.getProperty("java.home"), "conf"),
-                    "logging.properties");
+                File defaultFile = new File(new File(System.getProperty("java.home"), "conf"), "logging.properties");
                 try {
                     is = new FileInputStream(defaultFile);
                 } catch (IOException e) {
@@ -457,8 +439,7 @@ public class ClassLoaderLogManager extends LogManager {
                 localRootLogger.setParent(info.rootNode.logger);
             }
         }
-        ClassLoaderLogInfo info =
-            new ClassLoaderLogInfo(new LogNode(null, localRootLogger));
+        ClassLoaderLogInfo info = new ClassLoaderLogInfo(new LogNode(null, localRootLogger));
         classLoaderLoggers.put(classLoader, info);
 
         if (is != null) {
@@ -482,12 +463,12 @@ public class ClassLoaderLogManager extends LogManager {
     /**
      * Load specified configuration.
      *
-     * @param is InputStream to the properties file
+     * @param is          InputStream to the properties file
      * @param classLoader for which the configuration will be loaded
+     *
      * @throws IOException If something wrong happens during loading
      */
-    protected synchronized void readConfiguration(InputStream is, ClassLoader classLoader)
-        throws IOException {
+    protected synchronized void readConfiguration(InputStream is, ClassLoader classLoader) throws IOException {
 
         ClassLoaderLogInfo info = classLoaderLoggers.get(classLoader);
 
@@ -529,8 +510,7 @@ public class ClassLoaderLogManager extends LogManager {
                 }
                 try {
                     this.prefix.set(prefix);
-                    Handler handler = (Handler) classLoader.loadClass(
-                            handlerClassName).getConstructor().newInstance();
+                    Handler handler = (Handler) classLoader.loadClass(handlerClassName).getConstructor().newInstance();
                     // The specification strongly implies all configuration should be done
                     // during the creation of the handler object.
                     // This includes setting level, filter, formatter and encoding.
@@ -555,6 +535,7 @@ public class ClassLoaderLogManager extends LogManager {
      * System property replacement in the given string.
      *
      * @param str The original string
+     *
      * @return the modified string
      */
     protected String replace(String str) {
@@ -610,15 +591,13 @@ public class ClassLoaderLogManager extends LogManager {
 
 
     /**
-     * Obtain the class loader to use to lookup loggers, obtain configuration
-     * etc. The search order is:
+     * Obtain the class loader to use to lookup loggers, obtain configuration etc. The search order is:
      * <ol>
      * <li>Thread.currentThread().getContextClassLoader()</li>
      * <li>The class laoder of this class</li>
      * </ol>
      *
-     * @return The class loader to use to lookup loggers, obtain configuration
-     *         etc.
+     * @return The class loader to use to lookup loggers, obtain configuration etc.
      */
     static ClassLoader getClassLoader() {
         ClassLoader result = Thread.currentThread().getContextClassLoader();
@@ -715,8 +694,7 @@ public class ClassLoaderLogManager extends LogManager {
 
 
     /**
-     * This class is needed to instantiate the root of each per classloader
-     * hierarchy.
+     * This class is needed to instantiate the root of each per classloader hierarchy.
      */
     protected static class RootLogger extends Logger {
         public RootLogger() {

==================================================
FileHandler.java
index 517795530d..2016c113e6 100644
--- a/java/org/apache/juli/DateFormatCache.java
+++ b/java/org/apache/juli/DateFormatCache.java
@@ -23,21 +23,24 @@ import java.util.Locale;
 import java.util.TimeZone;
 
 /**
- * <p>Cache structure for SimpleDateFormat formatted timestamps based on
- * seconds.</p>
- *
- * <p>Millisecond formatting using S is not supported. You should add the
- * millisecond information after getting back the second formatting.</p>
- *
- * <p>The cache consists of entries for a consecutive range of
- * seconds. The length of the range is configurable. It is
- * implemented based on a cyclic buffer. New entries shift the range.</p>
- *
- * <p>The cache is not threadsafe. It can be used without synchronization
- * via thread local instances, or with synchronization as a global cache.</p>
- *
- * <p>The cache can be created with a parent cache to build a cache hierarchy.
- * Access to the parent cache is threadsafe.</p>
+ * <p>
+ * Cache structure for SimpleDateFormat formatted timestamps based on seconds.
+ * </p>
+ * <p>
+ * Millisecond formatting using S is not supported. You should add the millisecond information after getting back the
+ * second formatting.
+ * </p>
+ * <p>
+ * The cache consists of entries for a consecutive range of seconds. The length of the range is configurable. It is
+ * implemented based on a cyclic buffer. New entries shift the range.
+ * </p>
+ * <p>
+ * The cache is not threadsafe. It can be used without synchronization via thread local instances, or with
+ * synchronization as a global cache.
+ * </p>
+ * <p>
+ * The cache can be created with a parent cache to build a cache hierarchy. Access to the parent cache is threadsafe.
+ * </p>
  */
 public class DateFormatCache {
 
@@ -52,10 +55,8 @@ public class DateFormatCache {
     private final Cache cache;
 
     /**
-     * Replace the millisecond formatting character 'S' by
-     * some dummy characters in order to make the resulting
-     * formatted time stamps cacheable. Our consumer might
-     * choose to replace the dummy chars with the actual
+     * Replace the millisecond formatting character 'S' by some dummy characters in order to make the resulting
+     * formatted time stamps cacheable. Our consumer might choose to replace the dummy chars with the actual
      * milliseconds because that's relatively cheap.
      */
     private String tidyFormat(String format) {
@@ -82,7 +83,7 @@ public class DateFormatCache {
         this.format = tidyFormat(format);
         Cache parentCache = null;
         if (parent != null) {
-            synchronized(parent) {
+            synchronized (parent) {
                 parentCache = parent.cache;
             }
         }
@@ -129,26 +130,27 @@ public class DateFormatCache {
 
             long seconds = time / 1000;
 
-            /* First step: if we have seen this timestamp
-               during the previous call, return the previous value. */
+            /*
+             * First step: if we have seen this timestamp during the previous call, return the previous value.
+             */
             if (seconds == previousSeconds) {
                 return previousFormat;
             }
 
             /* Second step: Try to locate in cache */
             previousSeconds = seconds;
-            int index = (offset + (int)(seconds - first)) % cacheSize;
+            int index = (offset + (int) (seconds - first)) % cacheSize;
             if (index < 0) {
                 index += cacheSize;
             }
             if (seconds >= first && seconds <= last) {
                 if (cache[index] != null) {
-                    /* Found, so remember for next call and return.*/
+                    /* Found, so remember for next call and return. */
                     previousFormat = cache[index];
                     return previousFormat;
                 }
 
-            /* Third step: not found in cache, adjust cache and add item */
+                /* Third step: not found in cache, adjust cache and add item */
             } else if (seconds >= last + cacheSize || seconds <= first - cacheSize) {
                 first = seconds;
                 last = first + cacheSize - 1;
@@ -173,10 +175,11 @@ public class DateFormatCache {
                 offset = index;
             }
 
-            /* Last step: format new timestamp either using
-             * parent cache or locally. */
+            /*
+             * Last step: format new timestamp either using parent cache or locally.
+             */
             if (parent != null) {
-                synchronized(parent) {
+                synchronized (parent) {
                     previousFormat = parent.getFormat(time);
                 }
             } else {

==================================================
JdkLoggerFormatter.java
index 2fe8b22893..24796d8077 100644
--- a/java/org/apache/juli/FileHandler.java
+++ b/java/org/apache/juli/FileHandler.java
@@ -47,46 +47,35 @@ import java.util.logging.LogRecord;
 import java.util.regex.Pattern;
 
 /**
- * Implementation of <b>Handler</b> that appends log messages to a file
- * named {prefix}{date}{suffix} in a configured directory.
- *
- * <p>The following configuration properties are available:</p>
- *
+ * Implementation of <b>Handler</b> that appends log messages to a file named {prefix}{date}{suffix} in a configured
+ * directory.
+ * <p>
+ * The following configuration properties are available:
+ * </p>
  * <ul>
- *   <li><code>directory</code> - The directory where to create the log file.
- *    If the path is not absolute, it is relative to the current working
- *    directory of the application. The Apache Tomcat configuration files usually
- *    specify an absolute path for this property,
- *    <code>${catalina.base}/logs</code>
- *    Default value: <code>logs</code></li>
- *   <li><code>rotatable</code> - If <code>true</code>, the log file will be
- *    rotated on the first write past midnight and the filename will be
- *    <code>{prefix}{date}{suffix}</code>, where date is yyyy-MM-dd. If <code>false</code>,
- *    the file will not be rotated and the filename will be <code>{prefix}{suffix}</code>.
- *    Default value: <code>true</code></li>
- *   <li><code>prefix</code> - The leading part of the log file name.
- *    Default value: <code>juli.</code></li>
- *   <li><code>suffix</code> - The trailing part of the log file name. Default value: <code>.log</code></li>
- *   <li><code>bufferSize</code> - Configures buffering. The value of <code>0</code>
- *    uses system default buffering (typically an 8K buffer will be used). A
- *    value of <code>&lt;0</code> forces a writer flush upon each log write. A
- *    value <code>&gt;0</code> uses a BufferedOutputStream with the defined
- *    value but note that the system default buffering will also be
- *    applied. Default value: <code>-1</code></li>
- *   <li><code>encoding</code> - Character set used by the log file. Default value:
- *    empty string, which means to use the system default character set.</li>
- *   <li><code>level</code> - The level threshold for this Handler. See the
- *    <code>java.util.logging.Level</code> class for the possible levels.
- *    Default value: <code>ALL</code></li>
- *   <li><code>filter</code> - The <code>java.util.logging.Filter</code>
- *    implementation class name for this Handler. Default value: unset</li>
- *   <li><code>formatter</code> - The <code>java.util.logging.Formatter</code>
- *    implementation class name for this Handler. Default value:
- *    <code>org.apache.juli.OneLineFormatter</code></li>
- *   <li><code>maxDays</code> - The maximum number of days to keep the log
- *    files. If the specified value is <code>&lt;=0</code> then the log files
- *    will be kept on the file system forever, otherwise they will be kept the
- *    specified maximum days. Default value: <code>-1</code>.</li>
+ * <li><code>directory</code> - The directory where to create the log file. If the path is not absolute, it is relative
+ * to the current working directory of the application. The Apache Tomcat configuration files usually specify an
+ * absolute path for this property, <code>${catalina.base}/logs</code> Default value: <code>logs</code></li>
+ * <li><code>rotatable</code> - If <code>true</code>, the log file will be rotated on the first write past midnight and
+ * the filename will be <code>{prefix}{date}{suffix}</code>, where date is yyyy-MM-dd. If <code>false</code>, the file
+ * will not be rotated and the filename will be <code>{prefix}{suffix}</code>. Default value: <code>true</code></li>
+ * <li><code>prefix</code> - The leading part of the log file name. Default value: <code>juli.</code></li>
+ * <li><code>suffix</code> - The trailing part of the log file name. Default value: <code>.log</code></li>
+ * <li><code>bufferSize</code> - Configures buffering. The value of <code>0</code> uses system default buffering
+ * (typically an 8K buffer will be used). A value of <code>&lt;0</code> forces a writer flush upon each log write. A
+ * value <code>&gt;0</code> uses a BufferedOutputStream with the defined value but note that the system default
+ * buffering will also be applied. Default value: <code>-1</code></li>
+ * <li><code>encoding</code> - Character set used by the log file. Default value: empty string, which means to use the
+ * system default character set.</li>
+ * <li><code>level</code> - The level threshold for this Handler. See the <code>java.util.logging.Level</code> class for
+ * the possible levels. Default value: <code>ALL</code></li>
+ * <li><code>filter</code> - The <code>java.util.logging.Filter</code> implementation class name for this Handler.
+ * Default value: unset</li>
+ * <li><code>formatter</code> - The <code>java.util.logging.Formatter</code> implementation class name for this Handler.
+ * Default value: <code>org.apache.juli.OneLineFormatter</code></li>
+ * <li><code>maxDays</code> - The maximum number of days to keep the log files. If the specified value is
+ * <code>&lt;=0</code> then the log files will be kept on the file system forever, otherwise they will be kept the
+ * specified maximum days. Default value: <code>-1</code>.</li>
  * </ul>
  */
 public class FileHandler extends Handler {
@@ -96,8 +85,8 @@ public class FileHandler extends Handler {
     public static final int DEFAULT_BUFFER_SIZE = -1;
 
 
-    private static final ExecutorService DELETE_FILES_SERVICE =
-            Executors.newSingleThreadExecutor(new ThreadFactory("FileHandlerLogFilesCleaner-"));
+    private static final ExecutorService DELETE_FILES_SERVICE = Executors
+            .newSingleThreadExecutor(new ThreadFactory("FileHandlerLogFilesCleaner-"));
 
     // ------------------------------------------------------------ Constructor
 
@@ -117,8 +106,8 @@ public class FileHandler extends Handler {
     }
 
 
-    public FileHandler(String directory, String prefix, String suffix, Integer maxDays,
-            Boolean rotatable, Integer bufferSize) {
+    public FileHandler(String directory, String prefix, String suffix, Integer maxDays, Boolean rotatable,
+            Integer bufferSize) {
         this.directory = directory;
         this.prefix = prefix;
         this.suffix = suffix;
@@ -134,8 +123,7 @@ public class FileHandler extends Handler {
 
 
     /**
-     * The as-of date for the currently open log file, or null if there is no
-     * open log file.
+     * The as-of date for the currently open log file, or null if there is no open log file.
      */
     private volatile String date = null;
 
@@ -189,8 +177,7 @@ public class FileHandler extends Handler {
 
 
     /**
-     * Represents a file name pattern of type {prefix}{date}{suffix}.
-     * The date is YYYY-MM-DD
+     * Represents a file name pattern of type {prefix}{date}{suffix}. The date is YYYY-MM-DD
      */
     private Pattern pattern;
 
@@ -201,7 +188,7 @@ public class FileHandler extends Handler {
     /**
      * Format and publish a <code>LogRecord</code>.
      *
-     * @param  record  description of the log event
+     * @param record description of the log event
      */
     @Override
     public void publish(LogRecord record) {
@@ -257,8 +244,8 @@ public class FileHandler extends Handler {
                         writer.flush();
                     }
                 } else {
-                    reportError("FileHandler is closed or not yet initialized, unable to log ["
-                            + result + "]", null, ErrorManager.WRITE_FAILURE);
+                    reportError("FileHandler is closed or not yet initialized, unable to log [" + result + "]", null,
+                            ErrorManager.WRITE_FAILURE);
                 }
             } catch (Exception e) {
                 reportError(null, e, ErrorManager.WRITE_FAILURE);
@@ -326,7 +313,7 @@ public class FileHandler extends Handler {
      */
     private void configure() {
 
-        String className = this.getClass().getName(); //allow classes to override
+        String className = this.getClass().getName(); // allow classes to override
 
         ClassLoader cl = ClassLoaderLogManager.getClassLoader();
 
@@ -345,17 +332,15 @@ public class FileHandler extends Handler {
         }
 
         // https://bz.apache.org/bugzilla/show_bug.cgi?id=61232
-        boolean shouldCheckForRedundantSeparator =
-                !rotatable.booleanValue() && !prefix.isEmpty() && !suffix.isEmpty();
+        boolean shouldCheckForRedundantSeparator = !rotatable.booleanValue() && !prefix.isEmpty() && !suffix.isEmpty();
         // assuming separator is just one char, if there are use cases with
         // more, the notion of separator might be introduced
-        if (shouldCheckForRedundantSeparator &&
-                (prefix.charAt(prefix.length() - 1) == suffix.charAt(0))) {
+        if (shouldCheckForRedundantSeparator && (prefix.charAt(prefix.length() - 1) == suffix.charAt(0))) {
             suffix = suffix.substring(1);
         }
 
-        pattern = Pattern.compile("^(" + Pattern.quote(prefix) + ")\\d{4}-\\d{1,2}-\\d{1,2}("
-                + Pattern.quote(suffix) + ")$");
+        pattern = Pattern
+                .compile("^(" + Pattern.quote(prefix) + ")\\d{4}-\\d{1,2}-\\d{1,2}(" + Pattern.quote(suffix) + ")$");
 
         if (maxDays == null) {
             String sMaxDays = getProperty(className + ".maxDays", String.valueOf(DEFAULT_MAX_DAYS));
@@ -367,8 +352,7 @@ public class FileHandler extends Handler {
         }
 
         if (bufferSize == null) {
-            String sBufferSize = getProperty(className + ".bufferSize",
-                    String.valueOf(DEFAULT_BUFFER_SIZE));
+            String sBufferSize = getProperty(className + ".bufferSize", String.valueOf(DEFAULT_BUFFER_SIZE));
             try {
                 bufferSize = Integer.valueOf(sBufferSize);
             } catch (NumberFormatException ignore) {
@@ -403,8 +387,7 @@ public class FileHandler extends Handler {
         String formatterName = getProperty(className + ".formatter", null);
         if (formatterName != null) {
             try {
-                setFormatter((Formatter) cl.loadClass(
-                        formatterName).getConstructor().newInstance());
+                setFormatter((Formatter) cl.loadClass(formatterName).getConstructor().newInstance());
             } catch (Exception e) {
                 // Ignore and fallback to defaults
                 setFormatter(new OneLineFormatter());
@@ -451,8 +434,7 @@ public class FileHandler extends Handler {
         FileOutputStream fos = null;
         OutputStream os = null;
         try {
-            File pathname = new File(dir.getAbsoluteFile(), prefix
-                    + (rotatable.booleanValue() ? date : "") + suffix);
+            File pathname = new File(dir.getAbsoluteFile(), prefix + (rotatable.booleanValue() ? date : "") + suffix);
             File parent = pathname.getParentFile();
             if (!parent.mkdirs() && !parent.isDirectory()) {
                 reportError("Unable to create [" + parent + "]", null, ErrorManager.OPEN_FAILURE);
@@ -463,8 +445,7 @@ public class FileHandler extends Handler {
             fos = new FileOutputStream(pathname, true);
             os = bufferSize.intValue() > 0 ? new BufferedOutputStream(fos, bufferSize.intValue()) : fos;
             writer = new PrintWriter(
-                    (encoding != null) ? new OutputStreamWriter(os, encoding)
-                                       : new OutputStreamWriter(os), false);
+                    (encoding != null) ? new OutputStreamWriter(os, encoding) : new OutputStreamWriter(os), false);
             writer.write(getFormatter().getHead(this));
         } catch (Exception e) {
             reportError(null, e, ErrorManager.OPEN_FAILURE);

==================================================
OneLineFormatter.java
index d38b7d561c..80489b90b6 100644
--- a/java/org/apache/juli/JdkLoggerFormatter.java
+++ b/java/org/apache/juli/JdkLoggerFormatter.java
@@ -20,43 +20,40 @@ import java.util.logging.Formatter;
 import java.util.logging.LogRecord;
 
 /**
- * A more compact formatter.
+ * A more compact formatter. Equivalent log4j config:
  *
- * Equivalent log4j config:
- *   <pre>
+ * <pre>
  *  log4j.rootCategory=WARN, A1
  *  log4j.appender.A1=org.apache.log4j.ConsoleAppender
  *  log4j.appender.A1.layout=org.apache.log4j.PatternLayout
  *  log4j.appender.A1.Target=System.err
  *  log4j.appender.A1.layout.ConversionPattern=%r %-15.15c{2} %-1.1p %m %n
- *  </pre>
- *
- * Example:
- *  1130122891846 Http11BaseProtocol I Initializing Coyote HTTP/1.1 on http-8800
+ * </pre>
  *
+ * Example: 1130122891846 Http11BaseProtocol I Initializing Coyote HTTP/1.1 on http-8800
  *
  * @author Costin Manolache
  */
 public class JdkLoggerFormatter extends Formatter {
 
     // values from JDK Level
-    public static final int LOG_LEVEL_TRACE  = 400;
-    public static final int LOG_LEVEL_DEBUG  = 500;
-    public static final int LOG_LEVEL_INFO   = 800;
-    public static final int LOG_LEVEL_WARN   = 900;
-    public static final int LOG_LEVEL_ERROR  = 1000;
-    public static final int LOG_LEVEL_FATAL  = 1000;
+    public static final int LOG_LEVEL_TRACE = 400;
+    public static final int LOG_LEVEL_DEBUG = 500;
+    public static final int LOG_LEVEL_INFO = 800;
+    public static final int LOG_LEVEL_WARN = 900;
+    public static final int LOG_LEVEL_ERROR = 1000;
+    public static final int LOG_LEVEL_FATAL = 1000;
 
     @Override
     public String format(LogRecord record) {
-        Throwable t=record.getThrown();
-        int level=record.getLevel().intValue();
-        String name=record.getLoggerName();
-        long time=record.getMillis();
-        String message=formatMessage(record);
+        Throwable t = record.getThrown();
+        int level = record.getLevel().intValue();
+        String name = record.getLoggerName();
+        long time = record.getMillis();
+        String message = formatMessage(record);
 
 
-        if( name.indexOf('.') >= 0 ) {
+        if (name.indexOf('.') >= 0) {
             name = name.substring(name.lastIndexOf('.') + 1);
         }
 
@@ -66,18 +63,31 @@ public class JdkLoggerFormatter extends Formatter {
         buf.append(time);
 
         // pad to 8 to make it more readable
-        for( int i=0; i<8-buf.length(); i++ ) { buf.append(' '); }
+        for (int i = 0; i < 8 - buf.length(); i++) {
+            buf.append(' ');
+        }
 
-        //      Append a readable representation of the log level.
-        switch(level) {
-         case LOG_LEVEL_TRACE: buf.append(" T "); break;
-         case LOG_LEVEL_DEBUG: buf.append(" D "); break;
-         case LOG_LEVEL_INFO:  buf.append(" I ");  break;
-         case LOG_LEVEL_WARN:  buf.append(" W ");  break;
-         case LOG_LEVEL_ERROR: buf.append(" E "); break;
-         //case : buf.append(" F "); break;
-         default: buf.append("   ");
-         }
+        // Append a readable representation of the log level.
+        switch (level) {
+            case LOG_LEVEL_TRACE:
+                buf.append(" T ");
+                break;
+            case LOG_LEVEL_DEBUG:
+                buf.append(" D ");
+                break;
+            case LOG_LEVEL_INFO:
+                buf.append(" I ");
+                break;
+            case LOG_LEVEL_WARN:
+                buf.append(" W ");
+                break;
+            case LOG_LEVEL_ERROR:
+                buf.append(" E ");
+                break;
+            // case : buf.append(" F "); break;
+            default:
+                buf.append("   ");
+        }
 
 
         // Append the name of the log instance if so configured
@@ -85,17 +95,19 @@ public class JdkLoggerFormatter extends Formatter {
         buf.append(' ');
 
         // pad to 20 chars
-        for( int i=0; i<8-buf.length(); i++ ) { buf.append(' '); }
+        for (int i = 0; i < 8 - buf.length(); i++) {
+            buf.append(' ');
+        }
 
         // Append the message
         buf.append(message);
 
         // Append stack trace if not null
-        if(t != null) {
+        if (t != null) {
             buf.append(System.lineSeparator());
 
-            java.io.StringWriter sw= new java.io.StringWriter(1024);
-            java.io.PrintWriter pw= new java.io.PrintWriter(sw);
+            java.io.StringWriter sw = new java.io.StringWriter(1024);
+            java.io.PrintWriter pw = new java.io.PrintWriter(sw);
             t.printStackTrace(pw);
             pw.close();
             buf.append(sw.toString());

==================================================
VerbatimFormatter.java
index 5550b67778..85004ffe5e 100644
--- a/java/org/apache/juli/OneLineFormatter.java
+++ b/java/org/apache/juli/OneLineFormatter.java
@@ -30,9 +30,8 @@ import java.util.logging.LogManager;
 import java.util.logging.LogRecord;
 
 /**
- * Provides same information as default log format but on a single line to make
- * it easier to grep the logs. The only exception is stacktraces which are
- * always preceded by whitespace to make it simple to skip them.
+ * Provides same information as default log format but on a single line to make it easier to grep the logs. The only
+ * exception is stacktraces which are always preceded by whitespace to make it simple to skip them.
  */
 /*
  * Date processing based on AccessLogValve.
@@ -42,8 +41,8 @@ public class OneLineFormatter extends Formatter {
     private static final Object threadMxBeanLock = new Object();
     private static volatile ThreadMXBean threadMxBean = null;
     private static final int THREAD_NAME_CACHE_SIZE = 10000;
-    private static final ThreadLocal<ThreadNameCache> threadNameCache =
-            ThreadLocal.withInitial(() -> new ThreadNameCache(THREAD_NAME_CACHE_SIZE));
+    private static final ThreadLocal<ThreadNameCache> threadNameCache = ThreadLocal
+            .withInitial(() -> new ThreadNameCache(THREAD_NAME_CACHE_SIZE));
 
     /* Timestamp format */
     private static final String DEFAULT_TIME_FORMAT = "dd-MMM-yyyy HH:mm:ss.SSS";
@@ -67,8 +66,7 @@ public class OneLineFormatter extends Formatter {
 
 
     public OneLineFormatter() {
-        String timeFormat = LogManager.getLogManager().getProperty(
-                OneLineFormatter.class.getName() + ".timeFormat");
+        String timeFormat = LogManager.getLogManager().getProperty(OneLineFormatter.class.getName() + ".timeFormat");
         if (timeFormat == null) {
             timeFormat = DEFAULT_TIME_FORMAT;
         }
@@ -79,14 +77,13 @@ public class OneLineFormatter extends Formatter {
     /**
      * Specify the time format to use for time stamps in log messages.
      *
-     * @param timeFormat The format to use using the
-     *                   {@link java.text.SimpleDateFormat} syntax
+     * @param timeFormat The format to use using the {@link java.text.SimpleDateFormat} syntax
      */
     public void setTimeFormat(final String timeFormat) {
         final String cachedTimeFormat;
 
         if (timeFormat.endsWith(".SSS")) {
-            cachedTimeFormat = timeFormat.substring(0,  timeFormat.length() - 4);
+            cachedTimeFormat = timeFormat.substring(0, timeFormat.length() - 4);
             millisHandling = MillisHandling.APPEND;
         } else if (timeFormat.contains("SSS")) {
             millisHandling = MillisHandling.REPLACE_SSS;
@@ -102,9 +99,9 @@ public class OneLineFormatter extends Formatter {
             cachedTimeFormat = timeFormat;
         }
 
-        final DateFormatCache globalDateCache =
-                new DateFormatCache(globalCacheSize, cachedTimeFormat, null);
-        localDateCache = ThreadLocal.withInitial(() -> new DateFormatCache(localCacheSize, cachedTimeFormat, globalDateCache));
+        final DateFormatCache globalDateCache = new DateFormatCache(globalCacheSize, cachedTimeFormat, null);
+        localDateCache = ThreadLocal
+                .withInitial(() -> new DateFormatCache(localCacheSize, cachedTimeFormat, globalDateCache));
     }
 
 
@@ -214,7 +211,7 @@ public class OneLineFormatter extends Formatter {
      * LogRecord has threadID but no thread name.
      */
     private static String getThreadName(long logRecordThreadId) {
-        Map<Long,String> cache = threadNameCache.get();
+        Map<Long, String> cache = threadNameCache.get();
         String result = cache.get(Long.valueOf(logRecordThreadId));
 
         if (result != null) {
@@ -241,7 +238,7 @@ public class OneLineFormatter extends Formatter {
     }
 
 
-    private static class ThreadNameCache extends LinkedHashMap<Long,String> {
+    private static class ThreadNameCache extends LinkedHashMap<Long, String> {
 
         private static final long serialVersionUID = 1L;
 
@@ -259,8 +256,8 @@ public class OneLineFormatter extends Formatter {
 
 
     /*
-     * Minimal implementation to indent the printing of stack traces. This
-     * implementation depends on Throwable using WrappedPrintWriter.
+     * Minimal implementation to indent the printing of stack traces. This implementation depends on Throwable using
+     * WrappedPrintWriter.
      */
     private static class IndentingPrintWriter extends PrintWriter {
 
@@ -277,10 +274,6 @@ public class OneLineFormatter extends Formatter {
 
 
     private static enum MillisHandling {
-        NONE,
-        APPEND,
-        REPLACE_S,
-        REPLACE_SS,
-        REPLACE_SSS,
+        NONE, APPEND, REPLACE_S, REPLACE_SS, REPLACE_SSS,
     }
 }

==================================================
WebappProperties.java
index d460971e7a..1c90a0ff1e 100644
--- a/java/org/apache/juli/VerbatimFormatter.java
+++ b/java/org/apache/juli/VerbatimFormatter.java
@@ -20,11 +20,9 @@ import java.util.logging.Formatter;
 import java.util.logging.LogRecord;
 
 /**
- * Outputs the just the log message with no additional elements. Stack traces
- * are not logged. Log messages are separated by
- * <code>System.lineSeparator()</code>. This is intended for use
- * by access logs and the like that need complete control over the output
- * format.
+ * Outputs the just the log message with no additional elements. Stack traces are not logged. Log messages are separated
+ * by <code>System.lineSeparator()</code>. This is intended for use by access logs and the like that need complete
+ * control over the output format.
  */
 public class VerbatimFormatter extends Formatter {
 

==================================================
