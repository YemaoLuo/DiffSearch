74b87addf3fb555cff18e2385debc62be377a03b
==================================================
Port some code clean-up from Pool2 trunk.
==================================================
Mark Emlyn
==================================================
Tue Sep 23 13:18:22 2014 +0000
==================================================
BaseKeyedPooledObjectFactory.java
Port some code clean-up from Pool2 trunk.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1627007 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbandonedConfig.java
index 17644c6040..7f7810ece0 100644
--- a/java/org/apache/tomcat/dbcp/pool2/BaseKeyedPooledObjectFactory.java
+++ b/java/org/apache/tomcat/dbcp/pool2/BaseKeyedPooledObjectFactory.java
@@ -76,7 +76,7 @@ public abstract class BaseKeyedPooledObjectFactory<K,V>
     /**
      * Ensures that the instance is safe to be returned by the pool.
      * <p>
-     * The default implementation always returns <tt>true</tt>.
+     * The default implementation always returns {@code true}.
      *
      * @param key the key used when selecting the object
      * @param p a {@code PooledObject} wrapping the the instance to be validated

==================================================
LinkedBlockingDeque.java
index 97afe06530..154717d3e2 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/AbandonedConfig.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/AbandonedConfig.java
@@ -44,7 +44,7 @@ public class AbandonedConfig {
      * @return true if abandoned objects are to be removed by borrowObject
      */
     public boolean getRemoveAbandonedOnBorrow() {
-        return (this.removeAbandonedOnBorrow);
+        return this.removeAbandonedOnBorrow;
     }
 
     /**
@@ -81,7 +81,7 @@ public class AbandonedConfig {
      * @return true if abandoned objects are to be removed by the evictor
      */
     public boolean getRemoveAbandonedOnMaintenance() {
-        return (this.removeAbandonedOnMaintenance);
+        return this.removeAbandonedOnMaintenance;
     }
 
     /**
@@ -114,7 +114,7 @@ public class AbandonedConfig {
      * @return the abandoned object timeout in seconds
      */
     public int getRemoveAbandonedTimeout() {
-        return (this.removeAbandonedTimeout);
+        return this.removeAbandonedTimeout;
     }
 
     /**
@@ -152,7 +152,7 @@ public class AbandonedConfig {
      *
      */
     public boolean getLogAbandoned() {
-        return (this.logAbandoned);
+        return this.logAbandoned;
     }
 
     /**

==================================================
SoftReferenceObjectPool.java
index edf5885b70..c9c9330c3a 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/LinkedBlockingDeque.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/LinkedBlockingDeque.java
@@ -130,17 +130,17 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * Invariant: (first == null && last == null) ||
      *            (first.prev == null && first.item != null)
      */
-    private transient Node<E> first;
+    private transient Node<E> first; // @GuardedBy("lock")
 
     /**
      * Pointer to last node.
      * Invariant: (first == null && last == null) ||
      *            (last.next == null && last.item != null)
      */
-    private transient Node<E> last;
+    private transient Node<E> last; // @GuardedBy("lock")
 
     /** Number of items in the deque */
-    private transient int count;
+    private transient int count; // @GuardedBy("lock")
 
     /** Maximum number of items in the deque */
     private final int capacity;
@@ -192,7 +192,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @throws IllegalArgumentException if {@code capacity} is less than 1
      */
     public LinkedBlockingDeque(int capacity, boolean fairness) {
-        if (capacity <= 0) throw new IllegalArgumentException();
+        if (capacity <= 0) {
+            throw new IllegalArgumentException();
+        }
         this.capacity = capacity;
         lock = new InterruptibleReentrantLock(fairness);
         notEmpty = lock.newCondition();
@@ -214,10 +216,12 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
         lock.lock(); // Never contended, but necessary for visibility
         try {
             for (E e : c) {
-                if (e == null)
+                if (e == null) {
                     throw new NullPointerException();
-                if (!linkLast(e))
+                }
+                if (!linkLast(e)) {
                     throw new IllegalStateException("Deque full");
+                }
             }
         } finally {
             lock.unlock();
@@ -236,15 +240,17 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      */
     private boolean linkFirst(E e) {
         // assert lock.isHeldByCurrentThread();
-        if (count >= capacity)
+        if (count >= capacity) {
             return false;
+        }
         Node<E> f = first;
         Node<E> x = new Node<>(e, null, f);
         first = x;
-        if (last == null)
+        if (last == null) {
             last = x;
-        else
+        } else {
             f.prev = x;
+        }
         ++count;
         notEmpty.signal();
         return true;
@@ -259,15 +265,17 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      */
     private boolean linkLast(E e) {
         // assert lock.isHeldByCurrentThread();
-        if (count >= capacity)
+        if (count >= capacity) {
             return false;
+        }
         Node<E> l = last;
         Node<E> x = new Node<>(e, l, null);
         last = x;
-        if (first == null)
+        if (first == null) {
             first = x;
-        else
+        } else {
             l.next = x;
+        }
         ++count;
         notEmpty.signal();
         return true;
@@ -281,17 +289,19 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
     private E unlinkFirst() {
         // assert lock.isHeldByCurrentThread();
         Node<E> f = first;
-        if (f == null)
+        if (f == null) {
             return null;
+        }
         Node<E> n = f.next;
         E item = f.item;
         f.item = null;
         f.next = f; // help GC
         first = n;
-        if (n == null)
+        if (n == null) {
             last = null;
-        else
+        } else {
             n.prev = null;
+        }
         --count;
         notFull.signal();
         return item;
@@ -305,17 +315,19 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
     private E unlinkLast() {
         // assert lock.isHeldByCurrentThread();
         Node<E> l = last;
-        if (l == null)
+        if (l == null) {
             return null;
+        }
         Node<E> p = l.prev;
         E item = l.item;
         l.item = null;
         l.prev = l; // help GC
         last = p;
-        if (p == null)
+        if (p == null) {
             first = null;
-        else
+        } else {
             p.next = null;
+        }
         --count;
         notFull.signal();
         return item;
@@ -352,8 +364,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      */
     @Override
     public void addFirst(E e) {
-        if (!offerFirst(e))
+        if (!offerFirst(e)) {
             throw new IllegalStateException("Deque full");
+        }
     }
 
     /**
@@ -361,8 +374,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      */
     @Override
     public void addLast(E e) {
-        if (!offerLast(e))
+        if (!offerLast(e)) {
             throw new IllegalStateException("Deque full");
+        }
     }
 
     /**
@@ -370,7 +384,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      */
     @Override
     public boolean offerFirst(E e) {
-        if (e == null) throw new NullPointerException();
+        if (e == null) {
+            throw new NullPointerException();
+        }
         lock.lock();
         try {
             return linkFirst(e);
@@ -384,7 +400,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      */
     @Override
     public boolean offerLast(E e) {
-        if (e == null) throw new NullPointerException();
+        if (e == null) {
+            throw new NullPointerException();
+        }
         lock.lock();
         try {
             return linkLast(e);
@@ -403,11 +421,14 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @throws InterruptedException
      */
     public void putFirst(E e) throws InterruptedException {
-        if (e == null) throw new NullPointerException();
+        if (e == null) {
+            throw new NullPointerException();
+        }
         lock.lock();
         try {
-            while (!linkFirst(e))
+            while (!linkFirst(e)) {
                 notFull.await();
+            }
         } finally {
             lock.unlock();
         }
@@ -423,11 +444,14 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @throws InterruptedException
      */
     public void putLast(E e) throws InterruptedException {
-        if (e == null) throw new NullPointerException();
+        if (e == null) {
+            throw new NullPointerException();
+        }
         lock.lock();
         try {
-            while (!linkLast(e))
+            while (!linkLast(e)) {
                 notFull.await();
+            }
         } finally {
             lock.unlock();
         }
@@ -448,13 +472,16 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      */
     public boolean offerFirst(E e, long timeout, TimeUnit unit)
         throws InterruptedException {
-        if (e == null) throw new NullPointerException();
+        if (e == null) {
+            throw new NullPointerException();
+        }
         long nanos = unit.toNanos(timeout);
         lock.lockInterruptibly();
         try {
             while (!linkFirst(e)) {
-                if (nanos <= 0)
+                if (nanos <= 0) {
                     return false;
+                }
                 nanos = notFull.awaitNanos(nanos);
             }
             return true;
@@ -478,13 +505,16 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      */
     public boolean offerLast(E e, long timeout, TimeUnit unit)
         throws InterruptedException {
-        if (e == null) throw new NullPointerException();
+        if (e == null) {
+            throw new NullPointerException();
+        }
         long nanos = unit.toNanos(timeout);
         lock.lockInterruptibly();
         try {
             while (!linkLast(e)) {
-                if (nanos <= 0)
+                if (nanos <= 0) {
                     return false;
+                }
                 nanos = notFull.awaitNanos(nanos);
             }
             return true;
@@ -499,7 +529,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
     @Override
     public E removeFirst() {
         E x = pollFirst();
-        if (x == null) throw new NoSuchElementException();
+        if (x == null) {
+            throw new NoSuchElementException();
+        }
         return x;
     }
 
@@ -509,7 +541,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
     @Override
     public E removeLast() {
         E x = pollLast();
-        if (x == null) throw new NoSuchElementException();
+        if (x == null) {
+            throw new NoSuchElementException();
+        }
         return x;
     }
 
@@ -544,8 +578,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
         lock.lock();
         try {
             E x;
-            while ( (x = unlinkFirst()) == null)
+            while ( (x = unlinkFirst()) == null) {
                 notEmpty.await();
+            }
             return x;
         } finally {
             lock.unlock();
@@ -563,8 +598,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
         lock.lock();
         try {
             E x;
-            while ( (x = unlinkLast()) == null)
+            while ( (x = unlinkLast()) == null) {
                 notEmpty.await();
+            }
             return x;
         } finally {
             lock.unlock();
@@ -588,8 +624,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
         try {
             E x;
             while ( (x = unlinkFirst()) == null) {
-                if (nanos <= 0)
+                if (nanos <= 0) {
                     return null;
+                }
                 nanos = notEmpty.awaitNanos(nanos);
             }
             return x;
@@ -615,8 +652,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
         try {
             E x;
             while ( (x = unlinkLast()) == null) {
-                if (nanos <= 0)
+                if (nanos <= 0) {
                     return null;
+                }
                 nanos = notEmpty.awaitNanos(nanos);
             }
             return x;
@@ -631,7 +669,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
     @Override
     public E getFirst() {
         E x = peekFirst();
-        if (x == null) throw new NoSuchElementException();
+        if (x == null) {
+            throw new NoSuchElementException();
+        }
         return x;
     }
 
@@ -641,7 +681,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
     @Override
     public E getLast() {
         E x = peekLast();
-        if (x == null) throw new NoSuchElementException();
+        if (x == null) {
+            throw new NoSuchElementException();
+        }
         return x;
     }
 
@@ -649,7 +691,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
     public E peekFirst() {
         lock.lock();
         try {
-            return (first == null) ? null : first.item;
+            return first == null ? null : first.item;
         } finally {
             lock.unlock();
         }
@@ -659,7 +701,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
     public E peekLast() {
         lock.lock();
         try {
-            return (last == null) ? null : last.item;
+            return last == null ? null : last.item;
         } finally {
             lock.unlock();
         }
@@ -667,7 +709,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
 
     @Override
     public boolean removeFirstOccurrence(Object o) {
-        if (o == null) return false;
+        if (o == null) {
+            return false;
+        }
         lock.lock();
         try {
             for (Node<E> p = first; p != null; p = p.next) {
@@ -684,7 +728,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
 
     @Override
     public boolean removeLastOccurrence(Object o) {
-        if (o == null) return false;
+        if (o == null) {
+            return false;
+        }
         lock.lock();
         try {
             for (Node<E> p = last; p != null; p = p.prev) {
@@ -874,10 +920,12 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @throws IllegalArgumentException
      */
     public int drainTo(Collection<? super E> c, int maxElements) {
-        if (c == null)
+        if (c == null) {
             throw new NullPointerException();
-        if (c == this)
+        }
+        if (c == this) {
             throw new IllegalArgumentException();
+        }
         lock.lock();
         try {
             int n = Math.min(maxElements, count);
@@ -955,12 +1003,16 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      */
     @Override
     public boolean contains(Object o) {
-        if (o == null) return false;
+        if (o == null) {
+            return false;
+        }
         lock.lock();
         try {
-            for (Node<E> p = first; p != null; p = p.next)
-                if (o.equals(p.item))
+            for (Node<E> p = first; p != null; p = p.next) {
+                if (o.equals(p.item)) {
                     return true;
+                }
+            }
             return false;
         } finally {
             lock.unlock();
@@ -1027,8 +1079,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
         try {
             Object[] a = new Object[count];
             int k = 0;
-            for (Node<E> p = first; p != null; p = p.next)
+            for (Node<E> p = first; p != null; p = p.next) {
                 a[k++] = p.item;
+            }
             return a;
         } finally {
             lock.unlock();
@@ -1048,8 +1101,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
                     (a.getClass().getComponentType(), count);
             }
             int k = 0;
-            for (Node<E> p = first; p != null; p = p.next)
+            for (Node<E> p = first; p != null; p = p.next) {
                 a[k++] = (T)p.item;
+            }
             if (a.length > k) {
                 a[k] = null;
             }
@@ -1165,7 +1219,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
             lock.lock();
             try {
                 next = firstNode();
-                nextItem = (next == null) ? null : next.item;
+                nextItem = next == null ? null : next.item;
             } finally {
                 lock.unlock();
             }
@@ -1184,11 +1238,12 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
                 } else {
                     // Skip over removed nodes.
                     // May be necessary if multiple interior Nodes are removed.
-                    while (s != null && s.item == null)
+                    while (s != null && s.item == null) {
                         s = nextNode(s);
+                    }
                     next = s;
                 }
-                nextItem = (next == null) ? null : next.item;
+                nextItem = next == null ? null : next.item;
             } finally {
                 lock.unlock();
             }
@@ -1201,8 +1256,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
 
         @Override
         public E next() {
-            if (next == null)
+            if (next == null) {
                 throw new NoSuchElementException();
+            }
             lastRet = next;
             E x = nextItem;
             advance();
@@ -1212,13 +1268,15 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
         @Override
         public void remove() {
             Node<E> n = lastRet;
-            if (n == null)
+            if (n == null) {
                 throw new IllegalStateException();
+            }
             lastRet = null;
             lock.lock();
             try {
-                if (n.item != null)
+                if (n.item != null) {
                     unlink(n);
+                }
             } finally {
                 lock.unlock();
             }
@@ -1255,8 +1313,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
             // Write out capacity and any hidden stuff
             s.defaultWriteObject();
             // Write out all elements in the proper order.
-            for (Node<E> p = first; p != null; p = p.next)
+            for (Node<E> p = first; p != null; p = p.next) {
                 s.writeObject(p.item);
+            }
             // Use trailing null as sentinel
             s.writeObject(null);
         } finally {
@@ -1279,8 +1338,9 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
         for (;;) {
             @SuppressWarnings("unchecked")
             E item = (E)s.readObject();
-            if (item == null)
+            if (item == null) {
                 break;
+            }
             add(item);
         }
     }

==================================================
