f551c2681057c527e53af9d67d29a8bac90ee70f
==================================================
Still prepping for cluster integration. 
==================================================
Filip Hanik
==================================================
Tue Sep 5 17:24:10 2006 +0000
==================================================
ClusterRuleSet.java
index 671e8eeced..6d3d9cd716 100644
--- a/conf/server.xml
+++ b/conf/server.xml
@@ -188,130 +188,45 @@
        unpackWARs="true" autoDeploy="true"
        xmlValidation="false" xmlNamespaceAware="false">
 
-        <!-- Defines a cluster for this node,
-             By defining this element, means that every manager will be changed.
-             So when running a cluster, only make sure that you have webapps in there
-             that need to be clustered and remove the other ones.
-             A cluster has the following parameters:
-
-             className = the fully qualified name of the cluster class
-
-             clusterName = a descriptive name for your cluster, can be anything
-
-             mcastAddr = the multicast address, has to be the same for all the nodes
-
-             mcastPort = the multicast port, has to be the same for all the nodes
-             
-             mcastBindAddress = bind the multicast socket to a specific address
-             
-             mcastTTL = the multicast TTL if you want to limit your broadcast
-             
-             mcastSoTimeout = the multicast readtimeout 
-
-             mcastFrequency = the number of milliseconds in between sending a "I'm alive" heartbeat
-
-             mcastDropTime = the number a milliseconds before a node is considered "dead" if no heartbeat is received
-
-             tcpThreadCount = the number of threads to handle incoming replication requests, optimal would be the same amount of threads as nodes 
-
-             tcpListenAddress = the listen address (bind address) for TCP cluster request on this host, 
-                                in case of multiple ethernet cards.
-                                auto means that address becomes
-                                InetAddress.getLocalHost().getHostAddress()
-
-             tcpListenPort = the tcp listen port
-
-             tcpSelectorTimeout = the timeout (ms) for the Selector.select() method in case the OS
-                                  has a wakup bug in java.nio. Set to 0 for no timeout
-
-             printToScreen = true means that managers will also print to std.out
-
-             expireSessionsOnShutdown = true means that 
-
-             useDirtyFlag = true means that we only replicate a session after setAttribute,removeAttribute has been called.
-                            false means to replicate the session after each request.
-                            false means that replication would work for the following piece of code: (only for SimpleTcpReplicationManager)
-                            <%
-                            HashMap map = (HashMap)session.getAttribute("map");
-                            map.put("key","value");
-                            %>
-             replicationMode = can be either 'pooled', 'synchronous' or 'asynchronous'.
-                               * Pooled means that the replication happens using several sockets in a synchronous way. Ie, the data gets replicated, then the request return. This is the same as the 'synchronous' setting except it uses a pool of sockets, hence it is multithreaded. This is the fastest and safest configuration. To use this, also increase the nr of tcp threads that you have dealing with replication.
-                               * Synchronous means that the thread that executes the request, is also the
-                               thread the replicates the data to the other nodes, and will not return until all
-                               nodes have received the information.
-                               * Asynchronous means that there is a specific 'sender' thread for each cluster node,
-                               so the request thread will queue the replication request into a "smart" queue,
-                               and then return to the client.
-                               The "smart" queue is a queue where when a session is added to the queue, and the same session
-                               already exists in the queue from a previous request, that session will be replaced
-                               in the queue instead of replicating two requests. This almost never happens, unless there is a 
-                               large network delay.
-        -->             
-        <!--
-            When configuring for clustering, you also add in a valve to catch all the requests
-            coming in, at the end of the request, the session may or may not be replicated.
-            A session is replicated if and only if all the conditions are met:
-            1. useDirtyFlag is true or setAttribute or removeAttribute has been called AND
-            2. a session exists (has been created)
-            3. the request is not trapped by the "filter" attribute
-
-            The filter attribute is to filter out requests that could not modify the session,
-            hence we don't replicate the session after the end of this request.
-            The filter is negative, ie, anything you put in the filter, you mean to filter out,
-            ie, no replication will be done on requests that match one of the filters.
-            The filter attribute is delimited by ;, so you can't escape out ; even if you wanted to.
-
-            filter=".*\.gif;.*\.js;" means that we will not replicate the session after requests with the URI
-            ending with .gif and .js are intercepted.
-            
-            The deployer element can be used to deploy apps cluster wide.
-            Currently the deployment only deploys/undeploys to working members in the cluster
-            so no WARs are copied upons startup of a broken node.
-            The deployer watches a directory (watchDir) for WAR files when watchEnabled="true"
-            When a new war file is added the war gets deployed to the local instance,
-            and then deployed to the other instances in the cluster.
-            When a war file is deleted from the watchDir the war is undeployed locally 
-            and cluster wide
+        <!-- Place holder for brief cluster documentation, the rest will be online
         -->
         
         <!--
-        <Cluster className="org.apache.catalina.cluster.tcp.SimpleTcpCluster"
-                 managerClassName="org.apache.catalina.cluster.session.DeltaManager"
+        <Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"
+	         managerClassName="org.apache.catalina.cluster.session.DeltaManager"
                  expireSessionsOnShutdown="false"
                  useDirtyFlag="true"
                  notifyListenersOnReplication="true">
-
-            <Membership 
-                className="org.apache.catalina.cluster.mcast.McastService"
-                mcastAddr="228.0.0.4"
-                mcastPort="45564"
-                mcastFrequency="500"
-                mcastDropTime="3000"/>
-
-            <Receiver 
-                className="org.apache.catalina.cluster.tcp.ReplicationListener"
-                tcpListenAddress="auto"
-                tcpListenPort="4001"
-                tcpSelectorTimeout="100"
-                tcpThreadCount="6"/>
-
-            <Sender
-                className="org.apache.catalina.cluster.tcp.ReplicationTransmitter"
-                replicationMode="pooled"
-                ackTimeout="15000"
-                waitForAck="true"/>
-
-            <Valve className="org.apache.catalina.cluster.tcp.ReplicationValve"
-                   filter=".*\.gif;.*\.js;.*\.jpg;.*\.png;.*\.htm;.*\.html;.*\.css;.*\.txt;"/>
-                   
-            <Deployer className="org.apache.catalina.cluster.deploy.FarmWarDeployer"
-                      tempDir="/tmp/war-temp/"
-                      deployDir="/tmp/war-deploy/"
-                      watchDir="/tmp/war-listen/"
-                      watchEnabled="false"/>
-                      
-            <ClusterListener className="org.apache.catalina.cluster.session.ClusterSessionListener"/>
+          <Channel className="org.apache.catalina.tribes.group.GroupChannel">
+            <Membership className="org.apache.catalina.tribes.membership.McastService"
+                        mcastAddr="228.0.0.4"
+                        mcastPort="45564"
+                        mcastFrequency="500"
+                        mcastDropTime="3000"/>
+            <Receiver className="org.apache.catalina.tribes.transport.nio.NioReceiver"
+                      tcpListenAddress="auto"
+                      tcpListenPort="auto"
+                      tcpSelectorTimeout="100"
+                      tcpThreadCount="6"/>
+
+            <Sender className="org.apache.catalina.tribes.transport.ReplicationTransmitter">
+              <Transport className="org.apache.catalina.tribes.transport.nio.PooledParallelSender"/>
+            </Sender>
+            <Interceptor className="org.apache.catalina.tribes.group.interceptors.TcpFailureDetector"/>
+            <Interceptor className="org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor"/>
+            <Interceptor className="org.apache.catalina.tribes.group.interceptors.ThroughputInterceptor"/>
+	  </Channel>
+
+          <Valve className="org.apache.catalina.ha.tcp.ReplicationValve"
+                 filter=".*\.gif;.*\.js;.*\.jpg;.*\.png;.*\.htm;.*\.html;.*\.css;.*\.txt;"/>
+
+          <Deployer className="org.apache.catalina.ha.deploy.FarmWarDeployer"
+                    tempDir="/tmp/war-temp/"
+                    deployDir="/tmp/war-deploy/"
+                    watchDir="/tmp/war-listen/"
+                    watchEnabled="false"/>
+
+          <ClusterListener className="org.apache.catalina.ha.session.ClusterSessionListener"/>
         </Cluster>
         -->        
 

==================================================
