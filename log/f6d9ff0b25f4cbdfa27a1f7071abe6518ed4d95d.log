f6d9ff0b25f4cbdfa27a1f7071abe6518ed4d95d
==================================================
Fix the Javadoc warnings
==================================================
Mark Thomas
==================================================
Mon Mar 23 13:05:36 2015 +0000
==================================================
HPackHuffman.java
Fix the Javadoc warnings

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1668623 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Hpack.java
index c0043f3efb..38ff6243fa 100644
--- a/java/org/apache/coyote/http2/HPackHuffman.java
+++ b/java/org/apache/coyote/http2/HPackHuffman.java
@@ -364,14 +364,18 @@ public class HPackHuffman {
     }
 
     /**
-     * Decodes a huffman encoded string into the target StringBuilder. There must be enough space left in the buffer
-     * for this method to succeed.
+     * Decodes a huffman encoded string into the target StringBuilder. There
+     * must be enough space left in the buffer for this method to succeed.
      *
      * @param data   The byte buffer
-     * @param length The data length
+     * @param length The length of data from the buffer to decode
      * @param target The target for the decompressed data
+     *
+     * @throws HpackException If the Huffman encoded value in HPACK headers did
+     *                        not end with EOS padding
      */
-    public static void decode(ByteBuffer data, int length, StringBuilder target) throws HpackException {
+    public static void decode(ByteBuffer data, int length, StringBuilder target)
+            throws HpackException {
         assert data.remaining() >= length;
         int treePos = 0;
         boolean eosBits = true;
@@ -404,14 +408,16 @@ public class HPackHuffman {
             }
         }
         if (!eosBits) {
-            throw new HpackException(sm.getString("hpackhuffman.huffmanEncodedHpackValueDidNotEndWithEOS"));
+            throw new HpackException(sm.getString(
+                    "hpackhuffman.huffmanEncodedHpackValueDidNotEndWithEOS"));
         }
     }
 
 
     /**
-     * Encodes the given string into the buffer. If there is not enough space in the buffer, or the encoded
-     * version is bigger than the original it will return false and not modify the buffers position
+     * Encodes the given string into the buffer. If there is not enough space in
+     * the buffer, or the encoded version is bigger than the original it will
+     * return false and not modify the buffers position.
      *
      * @param buffer   The buffer to encode into
      * @param toEncode The string to encode

==================================================
HpackDecoder.java
index bbedc08687..ca4ce2896f 100644
--- a/java/org/apache/coyote/http2/Hpack.java
+++ b/java/org/apache/coyote/http2/Hpack.java
@@ -159,7 +159,8 @@ final class Hpack {
             int m = 0;
             do {
                 if(count++ > MAX_INTEGER_OCTETS) {
-                    throw new HpackException(sm.getString("hpack.integerEncodedOverTooManyOctets", MAX_INTEGER_OCTETS));
+                    throw new HpackException(sm.getString("hpack.integerEncodedOverTooManyOctets",
+                            Integer.valueOf(MAX_INTEGER_OCTETS)));
                 }
                 if (source.remaining() == 0) {
                     //we have run out of data

==================================================
HpackEncoder.java
index 0f2978334b..c9925a6be4 100644
--- a/java/org/apache/coyote/http2/HpackDecoder.java
+++ b/java/org/apache/coyote/http2/HpackDecoder.java
@@ -73,11 +73,13 @@ public class HpackDecoder {
     }
 
     /**
-     * Decodes the provided frame data. If this method leaves data in the buffer then
-     * this buffer should be compacted so this data is preserved, unless there is no
-     * more data in which case this should be considered a protocol error.
+     * Decodes the provided frame data. If this method leaves data in the buffer
+     * then this buffer should be compacted so this data is preserved, unless
+     * there is no more data in which case this should be considered a protocol error.
      *
      * @param buffer The buffer
+     *
+     * @throws HpackException If the packed data is not valid
      */
     public void decode(ByteBuffer buffer) throws HpackException {
         while (buffer.hasRemaining()) {
@@ -91,7 +93,8 @@ public class HpackDecoder {
                     buffer.position(originalPos);
                     return;
                 } else if(index == 0) {
-                    throw new HpackException(sm.getString("hpackdecoder.zeroNotValidHeaderTableIndex"));
+                    throw new HpackException(
+                            sm.getString("hpackdecoder.zeroNotValidHeaderTableIndex"));
                 }
                 handleIndex(index);
             } else if ((b & 0b01000000) != 0) {

==================================================
HpackException.java
index 0c950aad04..4df3b2de85 100644
--- a/java/org/apache/coyote/http2/HpackEncoder.java
+++ b/java/org/apache/coyote/http2/HpackEncoder.java
@@ -110,8 +110,10 @@ public class HpackEncoder {
     /**
      * Encodes the headers into a buffer.
      *
-     * @param headers
-     * @param target
+     * @param headers The headers to encode
+     * @param target  The buffer to which to write the encoded headers
+     *
+     * @return The state of the encoding process
      */
     public State encode(MimeHeaders headers, ByteBuffer target) {
         int it = headersIterator;
@@ -233,7 +235,7 @@ public class HpackEncoder {
         DynamicTableEntry d = new DynamicTableEntry(headerName, val, -pos);
         List<TableEntry> existing = dynamicTable.get(headerName);
         if (existing == null) {
-            dynamicTable.put(headerName, existing = new ArrayList<TableEntry>(1));
+            dynamicTable.put(headerName, existing = new ArrayList<>(1));
         }
         existing.add(d);
         evictionQueue.add(d);

==================================================
