3716f923f826ca10385b4d56851f50e4086a358c
==================================================
Converted the tests to JUnit 4.
==================================================
Konstantin Kolinko
==================================================
Mon Jul 25 15:22:30 2011 +0000
==================================================
Benchmarks.java
Converted the tests to JUnit 4.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1150747 13f79535-47bb-0310-9956-ffa450edef68



==================================================
TestRemoteIpValve.java
index 9cc787c45f..12ed6f1032 100644
--- a/test/org/apache/catalina/valves/Benchmarks.java
+++ b/test/org/apache/catalina/valves/Benchmarks.java
@@ -20,7 +20,7 @@ package org.apache.catalina.valves;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 
-import junit.framework.TestCase;
+import org.junit.Test;
 
 /**
  * Some simple micro-benchmarks to help determine best approach for thread
@@ -28,7 +28,8 @@ import junit.framework.TestCase;
  * JUnit tests to make the simple to execute but does not used Test* as the
  * class name to avoid being included in the automated unit tests.
  */
-public class Benchmarks extends TestCase {
+public class Benchmarks {
+    @Test
     public void testAccessLogGetDate() throws Exception {
         // Is it better to use a sync or a thread local here?
         BenchmarkTest benchmark = new BenchmarkTest();
@@ -171,6 +172,7 @@ public class Benchmarks extends TestCase {
         }
     }
 
+    @Test
     public void testAccessLogTimeDateElement() throws Exception {
         // Is it better to use a sync or a thread local here?
         BenchmarkTest benchmark = new BenchmarkTest();

==================================================
TestGzipOutputFilter.java
index 13812533fe..01fb8a22d6 100644
--- a/test/org/apache/catalina/valves/TestRemoteIpValve.java
+++ b/test/org/apache/catalina/valves/TestRemoteIpValve.java
@@ -24,7 +24,13 @@ import java.util.List;
 
 import javax.servlet.ServletException;
 
-import junit.framework.TestCase;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Test;
 
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
@@ -32,7 +38,7 @@ import org.apache.catalina.connector.Response;
 /**
  * {@link RemoteIpValve} Tests
  */
-public class TestRemoteIpValve extends TestCase {
+public class TestRemoteIpValve {
     
     static class RemoteAddrAndHostTrackerValve extends ValveBase {
         private String remoteAddr;
@@ -78,23 +84,27 @@ public class TestRemoteIpValve extends TestCase {
         }
     }
 
+    @Test
     public void testListToCommaDelimitedString() {
         List<String> elements = Arrays.asList("element1", "element2", "element3");
         String actual = RemoteIpValve.listToCommaDelimitedString(elements);
         assertEquals("element1, element2, element3", actual);
     }
     
+    @Test
     public void testListToCommaDelimitedStringEmptyList() {
         List<String> elements = new ArrayList<String>();
         String actual = RemoteIpValve.listToCommaDelimitedString(elements);
         assertEquals("", actual);
     }
     
+    @Test
     public void testCommaDelimitedListToStringArrayNullList() {
         String actual = RemoteIpValve.listToCommaDelimitedString(null);
         assertEquals("", actual);
     }
     
+    @Test
     public void testInvokeAllowedRemoteAddrWithNullRemoteIpHeader() throws Exception {
         // PREPARE
         RemoteIpValve remoteIpValve = new RemoteIpValve();
@@ -134,6 +144,7 @@ public class TestRemoteIpValve extends TestCase {
         
     }
     
+    @Test
     public void testInvokeAllProxiesAreTrusted() throws Exception {
         
         // PREPARE
@@ -174,6 +185,7 @@ public class TestRemoteIpValve extends TestCase {
         assertEquals("postInvoke remoteAddr", "remote-host-original-value", actualPostInvokeRemoteHost);
     }
     
+    @Test
     public void testInvokeAllProxiesAreTrustedOrInternal() throws Exception {
         
         // PREPARE
@@ -215,6 +227,7 @@ public class TestRemoteIpValve extends TestCase {
         assertEquals("postInvoke remoteAddr", "remote-host-original-value", actualPostInvokeRemoteHost);
     }
     
+    @Test
     public void testInvokeAllProxiesAreInternal() throws Exception {
         
         // PREPARE
@@ -255,6 +268,7 @@ public class TestRemoteIpValve extends TestCase {
         assertEquals("postInvoke remoteAddr", "remote-host-original-value", actualPostInvokeRemoteHost);
     }
     
+    @Test
     public void testInvokeAllProxiesAreTrustedAndRemoteAddrMatchRegexp() throws Exception {
         
         // PREPARE
@@ -297,6 +311,7 @@ public class TestRemoteIpValve extends TestCase {
         assertEquals("postInvoke remoteAddr", "remote-host-original-value", actualPostInvokeRemoteHost);
     }
     
+    @Test
     public void testInvokeXforwardedProtoSaysHttpsForIncomingHttpRequest() throws Exception {
         
         // PREPARE
@@ -349,10 +364,10 @@ public class TestRemoteIpValve extends TestCase {
         assertEquals("x-forwarded-proto says https", 443, actualServerPort);
         
         boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure();
-        assertEquals("x-forwarded-proto says https", true, actualSecure);
+        assertTrue("x-forwarded-proto says https", actualSecure);
 
         boolean actualPostInvokeSecure = request.isSecure();
-        assertEquals("postInvoke secure", false, actualPostInvokeSecure);
+        assertFalse("postInvoke secure", actualPostInvokeSecure);
 
         int actualPostInvokeServerPort = request.getServerPort();
         assertEquals("postInvoke serverPort", 8080, actualPostInvokeServerPort);
@@ -361,6 +376,7 @@ public class TestRemoteIpValve extends TestCase {
         assertEquals("postInvoke scheme", "http", actualPostInvokeScheme);
     }
     
+    @Test
     public void testInvokeXforwardedProtoIsNullForIncomingHttpRequest() throws Exception {
         
         // PREPARE
@@ -413,10 +429,10 @@ public class TestRemoteIpValve extends TestCase {
         assertEquals("x-forwarded-proto is null", 8080, actualServerPort);
         
         boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure();
-        assertEquals("x-forwarded-proto is null", false, actualSecure);
+        assertFalse("x-forwarded-proto is null", actualSecure);
 
         boolean actualPostInvokeSecure = request.isSecure();
-        assertEquals("postInvoke secure", false, actualPostInvokeSecure);
+        assertFalse("postInvoke secure", actualPostInvokeSecure);
 
         int actualPostInvokeServerPort = request.getServerPort();
         assertEquals("postInvoke serverPort", 8080, actualPostInvokeServerPort);
@@ -425,6 +441,7 @@ public class TestRemoteIpValve extends TestCase {
         assertEquals("postInvoke scheme", "http", actualPostInvokeScheme);
     }
     
+    @Test
     public void testInvokeXforwardedProtoSaysHttpForIncomingHttpsRequest() throws Exception {
         
         // PREPARE
@@ -477,10 +494,10 @@ public class TestRemoteIpValve extends TestCase {
         assertEquals("x-forwarded-proto says http", 80, actualServerPort);
         
         boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure();
-        assertEquals("x-forwarded-proto says http", false, actualSecure);
+        assertFalse("x-forwarded-proto says http", actualSecure);
 
         boolean actualPostInvokeSecure = request.isSecure();
-        assertEquals("postInvoke secure", true, actualPostInvokeSecure);
+        assertTrue("postInvoke secure", actualPostInvokeSecure);
 
         int actualPostInvokeServerPort = request.getServerPort();
         assertEquals("postInvoke serverPort", 8443, actualPostInvokeServerPort);
@@ -489,6 +506,7 @@ public class TestRemoteIpValve extends TestCase {
         assertEquals("postInvoke scheme", "https", actualPostInvokeScheme);
     }
     
+    @Test
     public void testInvokeXforwardedProtoIsNullForIncomingHttpsRequest() throws Exception {
         
         // PREPARE
@@ -541,10 +559,10 @@ public class TestRemoteIpValve extends TestCase {
         assertEquals("x-forwarded-proto is null", 8443, actualServerPort);
         
         boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure();
-        assertEquals("x-forwarded-proto is null", true, actualSecure);
+        assertTrue("x-forwarded-proto is null", actualSecure);
 
         boolean actualPostInvokeSecure = request.isSecure();
-        assertEquals("postInvoke secure", true, actualPostInvokeSecure);
+        assertTrue("postInvoke secure", actualPostInvokeSecure);
 
         int actualPostInvokeServerPort = request.getServerPort();
         assertEquals("postInvoke serverPort", 8443, actualPostInvokeServerPort);
@@ -553,6 +571,7 @@ public class TestRemoteIpValve extends TestCase {
         assertEquals("postInvoke scheme", "https", actualPostInvokeScheme);
     }
     
+    @Test
     public void testInvokeNotAllowedRemoteAddr() throws Exception {
         // PREPARE
         RemoteIpValve remoteIpValve = new RemoteIpValve();
@@ -592,6 +611,7 @@ public class TestRemoteIpValve extends TestCase {
         assertEquals("postInvoke remoteAddr", "not-allowed-internal-proxy-host", actualPostInvokeRemoteHost);
     }
     
+    @Test
     public void testInvokeUntrustedProxyInTheChain() throws Exception {
         // PREPARE
         RemoteIpValve remoteIpValve = new RemoteIpValve();
@@ -632,6 +652,7 @@ public class TestRemoteIpValve extends TestCase {
         assertEquals("postInvoke remoteAddr", "remote-host-original-value", actualPostInvokeRemoteHost);
     }
     
+    @Test
     public void testCommaDelimitedListToStringArray() {
         String[] actual = RemoteIpValve.commaDelimitedListToStringArray("element1, element2, element3");
         String[] expected = new String[] {
@@ -640,6 +661,7 @@ public class TestRemoteIpValve extends TestCase {
         assertArrayEquals(expected, actual);
     }
     
+    @Test
     public void testCommaDelimitedListToStringArrayMixedSpaceChars() {
         String[] actual = RemoteIpValve.commaDelimitedListToStringArray("element1  , element2,\t element3");
         String[] expected = new String[] {

==================================================
TestClassLoaderLogManager.java
index 71f4312451..40d2136cb8 100644
--- a/test/org/apache/coyote/http11/TestGzipOutputFilter.java
+++ b/test/org/apache/coyote/http11/TestGzipOutputFilter.java
@@ -20,7 +20,9 @@ package org.apache.coyote.http11;
 import java.io.ByteArrayOutputStream;
 import java.util.zip.GZIPOutputStream;
 
-import junit.framework.TestCase;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Test;
 
 import org.apache.coyote.Response;
 import org.apache.coyote.http11.filters.GzipOutputFilter;
@@ -30,7 +32,7 @@ import org.apache.tomcat.util.buf.ByteChunk;
  * Test case to demonstrate the interaction between gzip and flushing in the
  * output filter.
  */
-public class TestGzipOutputFilter extends TestCase {
+public class TestGzipOutputFilter {
 
     /**
      * Test the interaction betwen gzip and flushing. The idea is to: 1. create
@@ -46,6 +48,7 @@ public class TestGzipOutputFilter extends TestCase {
      * 
      * @throws Exception
      */
+    @Test
     public void testFlushingWithGzip() throws Exception {
         // set up response, InternalOutputBuffer, and ByteArrayOutputStream
         Response res = new Response();

==================================================
TestDirContextURLStreamHandlerFactory.java
index 3ecf3e854e..9a204b5c51 100644
--- a/test/org/apache/juli/TestClassLoaderLogManager.java
+++ b/test/org/apache/juli/TestClassLoaderLogManager.java
@@ -17,13 +17,16 @@
 
 package org.apache.juli;
 
-import junit.framework.TestCase;
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
 
 /**
  * Test cases for {@link ClassLoaderLogManager}.
  */
-public class TestClassLoaderLogManager extends TestCase {
+public class TestClassLoaderLogManager {
 
+    @Test
     public void testReplace() {
         ClassLoaderLogManager logManager = new ClassLoaderLogManager();
         assertEquals("", logManager.replace(""));

==================================================
TestByteChunk.java
index eda3f964c2..49e41c37cd 100644
--- a/test/org/apache/naming/resources/TestDirContextURLStreamHandlerFactory.java
+++ b/test/org/apache/naming/resources/TestDirContextURLStreamHandlerFactory.java
@@ -21,10 +21,14 @@ import java.net.URL;
 import java.net.URLStreamHandler;
 import java.net.URLStreamHandlerFactory;
 
-import junit.framework.TestCase;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 
-public class TestDirContextURLStreamHandlerFactory extends TestCase {
+import org.junit.Test;
 
+public class TestDirContextURLStreamHandlerFactory {
+
+    @Test
     public void testUserSuppliedFactory() throws Exception {
         
         URL url = null;

==================================================
TestCookies.java
index 88874253b5..3110fe5075 100644
--- a/test/org/apache/tomcat/util/buf/TestByteChunk.java
+++ b/test/org/apache/tomcat/util/buf/TestByteChunk.java
@@ -20,13 +20,17 @@ package org.apache.tomcat.util.buf;
 import java.io.UnsupportedEncodingException;
 import java.util.Arrays;
 
-import junit.framework.TestCase;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Test;
 
 /**
  * Test cases for {@link ByteChunk}.
  */
-public class TestByteChunk extends TestCase {
+public class TestByteChunk {
 
+    @Test
     public void testConvertToBytes() throws UnsupportedEncodingException {
         String string = "HTTP/1.1 100 Continue\r\n";
         byte[] bytes = ByteChunk.convertToBytes(string);
@@ -43,6 +47,7 @@ public class TestByteChunk extends TestCase {
      * any chars outside of the range. {@code ByteChunk.findByte()} works for
      * any ISO-8859-1 chars.
      */
+    @Test
     public void testFindByte() throws UnsupportedEncodingException {
         // 0xa0 = 160 = &nbsp; character
         byte[] bytes = "Hello\u00a0world".getBytes("ISO-8859-1");
@@ -68,6 +73,7 @@ public class TestByteChunk extends TestCase {
         assertEquals(-1, ByteChunk.indexOf(bytes, 5, 5, 'w'));
     }
 
+    @Test
     public void testIndexOf_Char() throws UnsupportedEncodingException {
         byte[] bytes = "Hello\u00a0world".getBytes("ISO-8859-1");
         final int len = bytes.length;
@@ -89,6 +95,7 @@ public class TestByteChunk extends TestCase {
         assertEquals(-1, bc.indexOf('d', 0));
     }
 
+    @Test
     public void testIndexOf_String() throws UnsupportedEncodingException {
         byte[] bytes = "Hello\u00a0world".getBytes("ISO-8859-1");
         final int len = bytes.length;
@@ -113,6 +120,7 @@ public class TestByteChunk extends TestCase {
         assertEquals(-1, bc.indexOf("d", 0, 1, 0));
     }
 
+    @Test
     public void testFindBytes() throws UnsupportedEncodingException {
         byte[] bytes = "Hello\u00a0world".getBytes("ISO-8859-1");
         final int len = bytes.length;
@@ -129,6 +137,7 @@ public class TestByteChunk extends TestCase {
         assertEquals(-1, ByteChunk.findBytes(bytes, 2, 5, new byte[] { 'w' }));
     }
 
+    @Test
     public void testFindNotBytes() throws UnsupportedEncodingException {
         byte[] bytes = "Hello\u00a0world".getBytes("ISO-8859-1");
         final int len = bytes.length;

==================================================
TestMapper.java
index 07b70e8a92..34b2f8bc78 100644
--- a/test/org/apache/tomcat/util/http/TestCookies.java
+++ b/test/org/apache/tomcat/util/http/TestCookies.java
@@ -17,10 +17,11 @@
 
 package org.apache.tomcat.util.http; 
 
-import junit.framework.TestCase;
+import org.junit.Test;
 
-public class TestCookies extends TestCase {
+public class TestCookies {
 
+    @Test
     public void testCookies() throws Exception {
         test("foo=bar; a=b", "foo", "bar", "a", "b");
         test("foo=bar;a=b", "foo", "bar", "a", "b");
@@ -99,7 +100,7 @@ public class TestCookies extends TestCase {
         test("$Version=0;foo=bar", 0);
     }
 
-
+    @Test
     public void testNameOnlyCookies() throws Exception {
         // Bug 49000
         test("fred=1; jim=2; bob", "fred", "1", "jim", "2");

==================================================
TestStringManager.java
index 1bf3c82594..afb0e562a6 100644
--- a/test/org/apache/tomcat/util/http/mapper/TestMapper.java
+++ b/test/org/apache/tomcat/util/http/mapper/TestMapper.java
@@ -16,16 +16,20 @@
  */
 package org.apache.tomcat.util.http.mapper;
 
-import junit.framework.TestCase;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Before;
+import org.junit.Test;
 
 import org.apache.tomcat.util.buf.MessageBytes;
 
-public class TestMapper extends TestCase {
+public class TestMapper {
 
     private Mapper mapper;
 
-    @Override
-    protected void setUp() throws Exception {
+    @Before
+    public void setUp() throws Exception {
         mapper = new Mapper();
 
         mapper.addHost("sjbjdvwsbvhrb", new String[0], "blah1");
@@ -77,8 +81,8 @@ public class TestMapper extends TestCase {
         mapper.addWrapper("iowejoiejfoiew", "/foo/bar/bla", "0", "/bobou/*",
                 "wrapper7", false, false);
     }
-    
 
+    @Test
     public void testAddHost() throws Exception {
         // Check we have the right number (add 16 but one is a duplicate)
         assertEquals(15, mapper.hosts.length);
@@ -95,8 +99,8 @@ public class TestMapper extends TestCase {
             assertTrue(previous.compareTo(current) < 0);
         }
     }
-    
-    
+
+    @Test
     public void testMap() throws Exception {
         MappingData mappingData = new MappingData();
         MessageBytes host = MessageBytes.newInstance();
@@ -129,8 +133,8 @@ public class TestMapper extends TestCase {
         assertEquals("/foo", mappingData.pathInfo.toString());
         assertTrue(mappingData.redirectPath.isNull());
     }
-    
-    
+
+    @Test
     public void testPerformance() throws Exception {
         MappingData mappingData = new MappingData();
         MessageBytes host = MessageBytes.newInstance();

==================================================
DedicatedThreadExecutorTest.java
index 00ea9b323f..dffb9a903e 100644
--- a/test/org/apache/tomcat/util/res/TestStringManager.java
+++ b/test/org/apache/tomcat/util/res/TestStringManager.java
@@ -17,13 +17,16 @@
 
 package org.apache.tomcat.util.res;
 
-import junit.framework.TestCase;
+import static org.junit.Assert.assertTrue;
 
-public class TestStringManager extends TestCase {
+import org.junit.Test;
+
+public class TestStringManager {
 
     private static final StringManager sm =
         StringManager.getManager("org.apache.naming");
 
+    @Test
     public void testNullKey() {
         boolean iaeThrown = false;
         
@@ -32,9 +35,10 @@ public class TestStringManager extends TestCase {
         } catch (IllegalArgumentException iae) {
             iaeThrown = true;
         }
-        assertEquals("IAE not thrown on null key", true, iaeThrown);
+        assertTrue("IAE not thrown on null key", iaeThrown);
     }
-    
+
+    @Test
     public void testBug46933() {
         // Check null args are OK
         sm.getString("namingContext.nameNotBound");

==================================================
TestLimitLatch.java
index ae1627abaf..8d13ccfad4 100644
--- a/test/org/apache/tomcat/util/threads/DedicatedThreadExecutorTest.java
+++ b/test/org/apache/tomcat/util/threads/DedicatedThreadExecutorTest.java
@@ -18,11 +18,17 @@ package org.apache.tomcat.util.threads;
 
 import java.util.concurrent.Callable;
 
-import junit.framework.TestCase;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertSame;
 
-public class DedicatedThreadExecutorTest extends TestCase {
+import org.junit.Test;
+
+public class DedicatedThreadExecutorTest {
     private Thread dedicatedThread;
 
+    @Test
     public void testExecute() {
         final Thread testingThread = Thread.currentThread();
         DedicatedThreadExecutor executor = new DedicatedThreadExecutor();
@@ -30,8 +36,7 @@ public class DedicatedThreadExecutorTest extends TestCase {
             @Override
             public Long call() throws Exception {
                 dedicatedThread = Thread.currentThread();
-                DedicatedThreadExecutorTest.assertNotSame(testingThread,
-                    dedicatedThread);
+                assertNotSame(testingThread, dedicatedThread);
                 return Long.valueOf(123);
             }
         });
@@ -41,8 +46,7 @@ public class DedicatedThreadExecutorTest extends TestCase {
         executor.execute(new Callable<Void>() {
             @Override
             public Void call() throws Exception {
-                DedicatedThreadExecutorTest.assertSame(dedicatedThread,
-                    Thread.currentThread());
+                assertSame(dedicatedThread, Thread.currentThread());
                 return null;
             }
         });
@@ -51,6 +55,7 @@ public class DedicatedThreadExecutorTest extends TestCase {
         assertFalse(dedicatedThread.isAlive());
     }
 
+    @Test
     public void testExecuteInOwnThread() {
         final Thread testingThread = Thread.currentThread();
         Long result =
@@ -58,8 +63,7 @@ public class DedicatedThreadExecutorTest extends TestCase {
                 @Override
                 public Long call() throws Exception {
                     dedicatedThread = Thread.currentThread();
-                    DedicatedThreadExecutorTest.assertNotSame(testingThread,
-                        dedicatedThread);
+                    assertNotSame(testingThread, dedicatedThread);
                     return Long.valueOf(456);
                 }
             });

==================================================
