b557e7adaf4362c8de70e7e30e0daeac3afe64f4
==================================================
Fix BZ 64192. Data corruption with HTTP/2 + asyncIO + TLS
==================================================
Mark Thomas
==================================================
Wed Mar 4 14:28:34 2020 +0000
==================================================
SocketBufferHandler.java
Fix BZ 64192. Data corruption with HTTP/2 + asyncIO + TLS

https://bz.apache.org/bugzilla/show_bug.cgi?id=64192
Correctly handle the case when data needs to be returned to the read
buffer when the read buffer is non-empty.


==================================================
SocketWrapperBase.java
index 89fa86e5b8..d066240e3a 100644
--- a/java/org/apache/tomcat/util/net/SocketBufferHandler.java
+++ b/java/org/apache/tomcat/util/net/SocketBufferHandler.java
@@ -16,6 +16,7 @@
  */
 package org.apache.tomcat.util.net;
 
+import java.nio.BufferOverflowException;
 import java.nio.ByteBuffer;
 
 import org.apache.tomcat.util.buf.ByteBufferUtils;
@@ -93,6 +94,55 @@ public class SocketBufferHandler {
     }
 
 
+    public void unReadReadBuffer(ByteBuffer returnedData) {
+        if (isReadBufferEmpty()) {
+            configureReadBufferForWrite();
+            readBuffer.put(returnedData);
+        } else {
+            int bytesReturned = returnedData.remaining();
+            if (readBufferConfiguredForWrite) {
+                // Writes always start at position zero
+                if ((readBuffer.position() + bytesReturned) > readBuffer.capacity()) {
+                    throw new BufferOverflowException();
+                } else {
+                    // Move the bytes up to make space for the returned data
+                    for (int i = 0; i < readBuffer.position(); i++) {
+                        readBuffer.put(i + bytesReturned, readBuffer.get(i));
+                    }
+                    // Insert the bytes returned
+                    for (int i = 0; i < bytesReturned; i++) {
+                        readBuffer.put(i, returnedData.get());
+                    }
+                    // Update the position
+                    readBuffer.position(readBuffer.position() + bytesReturned);
+                }
+            } else {
+                // Reads will start at zero but may have progressed
+                int shiftRequired = bytesReturned - readBuffer.position();
+                if (shiftRequired > 0) {
+                    if ((readBuffer.capacity() - readBuffer.limit()) < shiftRequired) {
+                        throw new BufferOverflowException();
+                    }
+                    // Move the bytes up to make space for the returned data
+                    int oldLimit = readBuffer.limit();
+                    readBuffer.limit(oldLimit + shiftRequired);
+                    for (int i = readBuffer.position(); i < oldLimit; i++) {
+                        readBuffer.put(i + shiftRequired, readBuffer.get(i));
+                    }
+                } else {
+                    shiftRequired = 0;
+                }
+                // Insert the returned bytes
+                int insertOffset = readBuffer.position() + shiftRequired - bytesReturned;
+                for (int i = insertOffset; i < bytesReturned + insertOffset; i++) {
+                    readBuffer.put(i, returnedData.get());
+                }
+                readBuffer.position(insertOffset);
+            }
+        }
+    }
+
+
     public void configureWriteBufferForWrite() {
         setWriteBufferConfiguredForWrite(true);
     }

==================================================
TestSocketBufferHandler.java
index 0658ea6030..a5c69c2298 100644
--- a/java/org/apache/tomcat/util/net/SocketWrapperBase.java
+++ b/java/org/apache/tomcat/util/net/SocketWrapperBase.java
@@ -374,8 +374,7 @@ public abstract class SocketWrapperBase<E> {
      */
     public void unRead(ByteBuffer returnedInput) {
         if (returnedInput != null) {
-            socketBufferHandler.configureReadBufferForWrite();
-            socketBufferHandler.getReadBuffer().put(returnedInput);
+            socketBufferHandler.unReadReadBuffer(returnedInput);
         }
     }
 

==================================================
