50d59a8271aef4791735446aab6da4dd8b90721f
==================================================
EL 3.0
==================================================
Mark Emlyn
==================================================
Wed Jul 3 18:56:14 2013 +0000
==================================================
BeanELResolver.java
EL 3.0
Implement new class
Refactor common code to Util class

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1499513 13f79535-47bb-0310-9956-ffa450edef68



==================================================
StaticFieldELResolver.java
index 8f9267c7f1..a286368891 100644
--- a/java/javax/el/LocalStrings.properties
+++ b/java/javax/el/LocalStrings.properties
@@ -30,4 +30,8 @@ importHandler.invalidClass=The class [{0}] must be public, non-abstract and not
 importHandler.invalidClassName=Name of class to import [{0}] must include a package
 importHandler.invalidClassNameForStatic=The class [{0}] specified for static import [{1}] is not valid
 importHandler.invalidStaticName=Name of static method or field to import [{0}] must include a class
-importHandler.staticNotFound=The static import [{0}] could not be found in class [{1}] for import [{2}]
\ No newline at end of file
+importHandler.staticNotFound=The static import [{0}] could not be found in class [{1}] for import [{2}]
+
+staticFieldELResolver.methodNotFound=No matching public static method named [{0}] found on class [{1}]
+staticFieldELResolver.notFound=No public static field named [{0}] was found on class [{1}]
+staticFieldELResolver.notWriteable=Writing to static fields (in this case field [{0}] on class [{1}]) is not permitted
\ No newline at end of file

==================================================
Util.java
new file mode 100644
index 0000000000..f5f1d4821f
--- /dev/null
+++ b/java/javax/el/StaticFieldELResolver.java
@@ -0,0 +1,231 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.el;
+
+import java.beans.FeatureDescriptor;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.Iterator;
+
+/**
+ * @since EL 3.0
+ */
+public class StaticFieldELResolver {
+
+    public Object getValue(ELContext context, Object base, Object property) {
+
+        if (context == null) {
+            throw new NullPointerException();
+        }
+
+        if (base instanceof ELClass && property instanceof String) {
+            context.setPropertyResolved(true);
+
+            Class<?> clazz = ((ELClass) base).getKlass();
+            String name = (String) property;
+            Exception exception = null;
+            try {
+                Field field = clazz.getField(name);
+                int modifiers = field.getModifiers();
+                if (Modifier.isStatic(modifiers) &&
+                        Modifier.isPublic(modifiers)) {
+                    return field.get(null);
+                }
+            } catch (IllegalArgumentException | IllegalAccessException
+                    | NoSuchFieldException | SecurityException e) {
+                exception = e;
+            }
+            String msg = Util.message(context, "staticFieldELResolver.notFound",
+                    name, clazz.getName());
+            if (exception == null) {
+                throw new PropertyNotFoundException(msg);
+            } else {
+                throw new PropertyNotFoundException(msg, exception);
+            }
+        }
+        return null;
+    }
+
+
+    /**
+     *
+     * @param context
+     * @param base
+     * @param property
+     * @param value
+     */
+    public void setValue(ELContext context, Object base, Object property,
+            Object value) {
+
+        if (context == null) {
+            throw new NullPointerException();
+        }
+
+        if (base instanceof ELClass && property instanceof String) {
+            Class<?> clazz = ((ELClass) base).getKlass();
+            String name = (String) property;
+
+            throw new PropertyNotWritableException(Util.message(context,
+                    "staticFieldELResolver.notWriteable", name,
+                    clazz.getName()));
+        }
+    }
+
+
+    public Object invoke(ELContext context, Object base, Object method,
+            Class<?>[] paramTypes, Object[] params) {
+
+        if (context == null) {
+            throw new NullPointerException();
+        }
+
+        if (base instanceof ELClass && method instanceof String) {
+            context.setPropertyResolved(true);
+
+            Class<?> clazz = ((ELClass) base).getKlass();
+            String methodName = (String) method;
+
+            if ("<init>".equals(methodName)) {
+                Constructor<?> match =
+                        Util.findConstructor(base, paramTypes, params);
+
+                int modifiers = match.getModifiers();
+                if (!Modifier.isStatic(modifiers)) {
+                    throw new MethodNotFoundException(Util.message(context,
+                            "staticFieldELResolver.methodNotFound", methodName,
+                            clazz.getName()));
+                }
+
+                Object[] parameters = Util.buildParameters(
+                        match.getParameterTypes(), match.isVarArgs(), params);
+
+                Object result = null;
+
+                try {
+                    result = match.newInstance(parameters);
+                } catch (IllegalArgumentException | IllegalAccessException |
+                        InstantiationException e) {
+                    throw new ELException(e);
+                } catch (InvocationTargetException e) {
+                    Throwable cause = e.getCause();
+                    Util.handleThrowable(cause);
+                    throw new ELException(cause);
+                }
+                return result;
+
+            } else {
+                Method match =
+                        Util.findMethod(base, methodName, paramTypes, params);
+
+                int modifiers = match.getModifiers();
+                if (!Modifier.isStatic(modifiers)) {
+                    throw new MethodNotFoundException(Util.message(context,
+                            "staticFieldELResolver.methodNotFound", methodName,
+                            clazz.getName()));
+                }
+
+                Object[] parameters = Util.buildParameters(
+                        match.getParameterTypes(), match.isVarArgs(), params);
+
+                Object result = null;
+                try {
+                    result = match.invoke(base, parameters);
+                } catch (IllegalArgumentException | IllegalAccessException e) {
+                    throw new ELException(e);
+                } catch (InvocationTargetException e) {
+                    Throwable cause = e.getCause();
+                    Util.handleThrowable(cause);
+                    throw new ELException(cause);
+                }
+                return result;
+            }
+        }
+        return null;
+    }
+
+    public Class<?> getType(ELContext context, Object base, Object property) {
+        if (context == null) {
+            throw new NullPointerException();
+        }
+
+        if (base instanceof ELClass && property instanceof String) {
+            context.setPropertyResolved(true);
+
+            Class<?> clazz = ((ELClass) base).getKlass();
+            String name = (String) property;
+            Exception exception = null;
+            try {
+                Field field = clazz.getField(name);
+                int modifiers = field.getModifiers();
+                if (Modifier.isStatic(modifiers) &&
+                        Modifier.isPublic(modifiers)) {
+                    return field.getType();
+                }
+            } catch (IllegalArgumentException | NoSuchFieldException |
+                    SecurityException e) {
+                exception = e;
+            }
+            String msg = Util.message(context, "staticFieldELResolver.notFound",
+                    name, clazz.getName());
+            if (exception == null) {
+                throw new PropertyNotFoundException(msg);
+            } else {
+                throw new PropertyNotFoundException(msg, exception);
+            }
+        }
+        return null;
+    }
+
+
+    public boolean isReadOnly(ELContext context, Object base, Object property) {
+        if (context == null) {
+            throw new NullPointerException();
+        }
+
+        if (base instanceof ELClass && property instanceof String) {
+            context.setPropertyResolved(true);
+
+            return true;
+        }
+        return false;
+    }
+
+
+    /**
+     * Always returns <code>null</code>.
+     *
+     * @param context
+     * @param base
+     */
+    public Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext context,
+            Object base) {
+        return null;
+    }
+
+    /**
+     * Always returns <code>String.class</code>.
+     *
+     * @param context
+     * @param base
+     */
+    public Class<?> getCommonPropertyType(ELContext context, Object base) {
+        return String.class;
+    }
+}

==================================================
