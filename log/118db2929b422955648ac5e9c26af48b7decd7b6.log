118db2929b422955648ac5e9c26af48b7decd7b6
==================================================
Remove deprecated and (now) unused XML parser.
==================================================
Mark Thomas
==================================================
Sun Dec 18 09:39:18 2016 +0000
==================================================
ASCIIReader.java
Remove deprecated and (now) unused XML parser.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1774869 13f79535-47bb-0310-9956-ffa450edef68



==================================================
EncodingMap.java
deleted file mode 100644
index add0d1fe0f..0000000000
--- a/java/org/apache/jasper/xmlparser/ASCIIReader.java
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.jasper.xmlparser;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-
-import org.apache.jasper.compiler.Localizer;
-
-/**
- * A simple ASCII byte reader. This is an optimized reader for reading
- * byte streams that only contain 7-bit ASCII characters.
- *
- * @author Andy Clark, IBM
- *
- * @deprecated Will be removed in Tomcat 9.0.x onwards
- */
-@Deprecated
-public class ASCIIReader extends Reader {
-
-    //
-    // Data
-    //
-
-    /** Input stream. */
-    private final InputStream fInputStream;
-
-    /** Byte buffer. */
-    private final byte[] fBuffer;
-
-    //
-    // Constructors
-    //
-
-    /**
-     * Constructs an ASCII reader from the specified input stream
-     * and buffer size.
-     *
-     * @param inputStream The input stream.
-     * @param size        The initial buffer size.
-     */
-    public ASCIIReader(InputStream inputStream, int size) {
-        fInputStream = inputStream;
-        fBuffer = new byte[size];
-    }
-
-    //
-    // Reader methods
-    //
-
-    /**
-     * Read a single character.  This method will block until a character is
-     * available, an I/O error occurs, or the end of the stream is reached.
-     *
-     * <p> Subclasses that intend to support efficient single-character input
-     * should override this method.
-     *
-     * @return     The character read, as an integer in the range 0 to 127
-     *             (<tt>0x00-0x7f</tt>), or -1 if the end of the stream has
-     *             been reached
-     *
-     * @exception  IOException  If an I/O error occurs
-     */
-    @Override
-    public int read() throws IOException {
-        int b0 = fInputStream.read();
-        if (b0 > 0x80) {
-            throw new IOException(Localizer.getMessage("jsp.error.xml.invalidASCII",
-                                                       Integer.toString(b0)));
-        }
-        return b0;
-    } // read():int
-
-    /**
-     * Read characters into a portion of an array.  This method will block
-     * until some input is available, an I/O error occurs, or the end of the
-     * stream is reached.
-     *
-     * @param      ch     Destination buffer
-     * @param      offset Offset at which to start storing characters
-     * @param      length Maximum number of characters to read
-     *
-     * @return     The number of characters read, or -1 if the end of the
-     *             stream has been reached
-     *
-     * @exception  IOException  If an I/O error occurs
-     */
-    @Override
-    public int read(char ch[], int offset, int length) throws IOException {
-        if (length > fBuffer.length) {
-            length = fBuffer.length;
-        }
-        int count = fInputStream.read(fBuffer, 0, length);
-        for (int i = 0; i < count; i++) {
-            int b0 = (0xff & fBuffer[i]); // Convert to unsigned
-            if (b0 > 0x80) {
-                throw new IOException(Localizer.getMessage("jsp.error.xml.invalidASCII",
-                                                           Integer.toString(b0)));
-            }
-            ch[offset + i] = (char)b0;
-        }
-        return count;
-    } // read(char[],int,int)
-
-    /**
-     * Skip characters.  This method will block until some characters are
-     * available, an I/O error occurs, or the end of the stream is reached.
-     *
-     * @param  n  The number of characters to skip
-     *
-     * @return    The number of characters actually skipped
-     *
-     * @exception  IOException  If an I/O error occurs
-     */
-    @Override
-    public long skip(long n) throws IOException {
-        return fInputStream.skip(n);
-    } // skip(long):long
-
-    /**
-     * Tell whether this stream is ready to be read.
-     *
-     * @return True if the next read() is guaranteed not to block for input,
-     * false otherwise.  Note that returning false does not guarantee that the
-     * next read will block.
-     *
-     * @exception  IOException  If an I/O error occurs
-     */
-    @Override
-    public boolean ready() throws IOException {
-        return false;
-    } // ready()
-
-    /**
-     * Tell whether this stream supports the mark() operation.
-     */
-    @Override
-    public boolean markSupported() {
-        return fInputStream.markSupported();
-    } // markSupported()
-
-    /**
-     * Mark the present position in the stream.  Subsequent calls to reset()
-     * will attempt to reposition the stream to this point.  Not all
-     * character-input streams support the mark() operation.
-     *
-     * @param  readAheadLimit  Limit on the number of characters that may be
-     *                         read while still preserving the mark.  After
-     *                         reading this many characters, attempting to
-     *                         reset the stream may fail.
-     *
-     * @exception  IOException  If the stream does not support mark(),
-     *                          or if some other I/O error occurs
-     */
-    @Override
-    public void mark(int readAheadLimit) throws IOException {
-        fInputStream.mark(readAheadLimit);
-    } // mark(int)
-
-    /**
-     * Reset the stream.  If the stream has been marked, then attempt to
-     * reposition it at the mark.  If the stream has not been marked, then
-     * attempt to reset it in some way appropriate to the particular stream,
-     * for example by repositioning it to its starting point.  Not all
-     * character-input streams support the reset() operation, and some support
-     * reset() without supporting mark().
-     *
-     * @exception  IOException  If the stream has not been marked,
-     *                          or if the mark has been invalidated,
-     *                          or if the stream does not support reset(),
-     *                          or if some other I/O error occurs
-     */
-    @Override
-    public void reset() throws IOException {
-        fInputStream.reset();
-    } // reset()
-
-    /**
-     * Close the stream.  Once a stream has been closed, further read(),
-     * ready(), mark(), or reset() invocations will throw an IOException.
-     * Closing a previously-closed stream, however, has no effect.
-     *
-     * @exception  IOException  If an I/O error occurs
-     */
-     @Override
-    public void close() throws IOException {
-         fInputStream.close();
-     } // close()
-
-} // class ASCIIReader

==================================================
SymbolTable.java
deleted file mode 100644
index 0474b4634c..0000000000
--- a/java/org/apache/jasper/xmlparser/EncodingMap.java
+++ /dev/null
@@ -1,890 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation and was
- * originally based on software copyright (c) 1999, International
- * Business Machines, Inc., http://www.apache.org.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- */
-
-package org.apache.jasper.xmlparser;
-
-import java.util.Hashtable;
-
-/**
- * EncodingMap is a convenience class which handles conversions between
- * IANA encoding names and Java encoding names, and vice versa. The
- * encoding names used in XML instance documents <strong>must</strong>
- * be the IANA encoding names specified or one of the aliases for those names
- * which IANA defines.
- * <TABLE WIDTH="100%">
- *  <caption>Mapping of IANA encoding names and Java encoding names</caption>
- *  <TR>
- *      <TD>
- *          <P><B>Common Name</B>
- *      </TD>
- *      <TD>
- *          <P><B>Use this name in XML files</B>
- *      </TD>
- *      <TD>
- *          <P><B>Name Type</B>
- *      </TD>
- *      <TD>
- *          <P><B>Xerces converts to this Java Encoder Name</B>
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>8 bit Unicode</TD>
- *      <TD>
- *          <P>UTF-8
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>UTF8
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>ISO Latin 1</TD>
- *      <TD>
- *          <P>ISO-8859-1
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>ISO-8859-1
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>ISO Latin 2</TD>
- *      <TD>
- *          <P>ISO-8859-2
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>ISO-8859-2
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>ISO Latin 3</TD>
- *      <TD>
- *          <P>ISO-8859-3
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>ISO-8859-3
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>ISO Latin 4</TD>
- *      <TD>
- *          <P>ISO-8859-4
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>ISO-8859-4
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>ISO Latin Cyrillic</TD>
- *      <TD>
- *          <P>ISO-8859-5
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>ISO-8859-5
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>ISO Latin Arabic</TD>
- *      <TD>
- *          <P>ISO-8859-6
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>ISO-8859-6
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>ISO Latin Greek</TD>
- *      <TD>
- *          <P>ISO-8859-7
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>ISO-8859-7
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>ISO Latin Hebrew</TD>
- *      <TD>
- *          <P>ISO-8859-8
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>ISO-8859-8
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>ISO Latin 5</TD>
- *      <TD>
- *          <P>ISO-8859-9
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>ISO-8859-9
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: US</TD>
- *      <TD>
- *          <P>ebcdic-cp-us
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp037
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Canada</TD>
- *      <TD>
- *          <P>ebcdic-cp-ca
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp037
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Netherlands</TD>
- *      <TD>
- *          <P>ebcdic-cp-nl
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp037
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Denmark</TD>
- *      <TD>
- *          <P>ebcdic-cp-dk
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp277
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Norway</TD>
- *      <TD>
- *          <P>ebcdic-cp-no
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp277
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Finland</TD>
- *      <TD>
- *          <P>ebcdic-cp-fi
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp278
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Sweden</TD>
- *      <TD>
- *          <P>ebcdic-cp-se
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp278
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Italy</TD>
- *      <TD>
- *          <P>ebcdic-cp-it
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp280
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Spain, Latin America</TD>
- *      <TD>
- *          <P>ebcdic-cp-es
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp284
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Great Britain</TD>
- *      <TD>
- *          <P>ebcdic-cp-gb
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp285
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: France</TD>
- *      <TD>
- *          <P>ebcdic-cp-fr
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp297
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Arabic</TD>
- *      <TD>
- *          <P>ebcdic-cp-ar1
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp420
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Hebrew</TD>
- *      <TD>
- *          <P>ebcdic-cp-he
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp424
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Switzerland</TD>
- *      <TD>
- *          <P>ebcdic-cp-ch
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp500
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Roece</TD>
- *      <TD>
- *          <P>ebcdic-cp-roece
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp870
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Yugoslavia</TD>
- *      <TD>
- *          <P>ebcdic-cp-yu
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp870
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Iceland</TD>
- *      <TD>
- *          <P>ebcdic-cp-is
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp871
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>EBCDIC: Urdu</TD>
- *      <TD>
- *          <P>ebcdic-cp-ar2
- *      </TD>
- *      <TD>
- *          <P>IANA
- *      </TD>
- *      <TD>
- *          <P>cp918
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>Chinese for PRC, mixed 1/2 byte</TD>
- *      <TD>
- *          <P>gb2312
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>GB2312
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>Extended Unix Code, packed for Japanese</TD>
- *      <TD>
- *          <P>euc-jp
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>eucjis
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>Japanese: iso-2022-jp</TD>
- *      <TD>
- *          <P>iso-2020-jp
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>JIS
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>Japanese: Shift JIS</TD>
- *      <TD>
- *          <P>Shift_JIS
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>SJIS
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>Chinese: Big5</TD>
- *      <TD>
- *          <P>Big5
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>Big5
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>Extended Unix Code, packed for Korean</TD>
- *      <TD>
- *          <P>euc-kr
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>iso2022kr
- *      </TD>
- *  </TR>
- *  <TR>
- *      <TD>Cyrillic</TD>
- *      <TD>
- *          <P>koi8-r
- *      </TD>
- *      <TD>
- *          <P>MIME
- *      </TD>
- *      <TD>
- *          <P>koi8-r
- *      </TD>
- *  </TR>
- * </TABLE>
- *
- * @author TAMURA Kent, IBM
- * @author Andy Clark, IBM
- *
- * @deprecated Will be removed in Tomcat 9.0.x onwards
- */
-@Deprecated
-public class EncodingMap {
-
-    //
-    // Data
-    //
-
-    /** fIANA2JavaMap */
-    private static final Hashtable<String,String> fIANA2JavaMap =
-            new Hashtable<>();
-
-    //
-    // Static initialization
-    //
-
-    static {
-
-        // add IANA to Java encoding mappings.
-        fIANA2JavaMap.put("BIG5",            "Big5");
-        fIANA2JavaMap.put("CSBIG5",            "Big5");
-        fIANA2JavaMap.put("CP037",    "CP037");
-        fIANA2JavaMap.put("IBM037",    "CP037");
-        fIANA2JavaMap.put("CSIBM037",    "CP037");
-        fIANA2JavaMap.put("EBCDIC-CP-US",    "CP037");
-        fIANA2JavaMap.put("EBCDIC-CP-CA",    "CP037");
-        fIANA2JavaMap.put("EBCDIC-CP-NL",    "CP037");
-        fIANA2JavaMap.put("EBCDIC-CP-WT",    "CP037");
-        fIANA2JavaMap.put("IBM273",    "CP273");
-        fIANA2JavaMap.put("CP273",    "CP273");
-        fIANA2JavaMap.put("CSIBM273",    "CP273");
-        fIANA2JavaMap.put("IBM277",    "CP277");
-        fIANA2JavaMap.put("CP277",    "CP277");
-        fIANA2JavaMap.put("CSIBM277",    "CP277");
-        fIANA2JavaMap.put("EBCDIC-CP-DK",    "CP277");
-        fIANA2JavaMap.put("EBCDIC-CP-NO",    "CP277");
-        fIANA2JavaMap.put("IBM278",    "CP278");
-        fIANA2JavaMap.put("CP278",    "CP278");
-        fIANA2JavaMap.put("CSIBM278",    "CP278");
-        fIANA2JavaMap.put("EBCDIC-CP-FI",    "CP278");
-        fIANA2JavaMap.put("EBCDIC-CP-SE",    "CP278");
-        fIANA2JavaMap.put("IBM280",    "CP280");
-        fIANA2JavaMap.put("CP280",    "CP280");
-        fIANA2JavaMap.put("CSIBM280",    "CP280");
-        fIANA2JavaMap.put("EBCDIC-CP-IT",    "CP280");
-        fIANA2JavaMap.put("IBM284",    "CP284");
-        fIANA2JavaMap.put("CP284",    "CP284");
-        fIANA2JavaMap.put("CSIBM284",    "CP284");
-        fIANA2JavaMap.put("EBCDIC-CP-ES",    "CP284");
-        fIANA2JavaMap.put("EBCDIC-CP-GB",    "CP285");
-        fIANA2JavaMap.put("IBM285",    "CP285");
-        fIANA2JavaMap.put("CP285",    "CP285");
-        fIANA2JavaMap.put("CSIBM285",    "CP285");
-        fIANA2JavaMap.put("EBCDIC-JP-KANA",    "CP290");
-        fIANA2JavaMap.put("IBM290",    "CP290");
-        fIANA2JavaMap.put("CP290",    "CP290");
-        fIANA2JavaMap.put("CSIBM290",    "CP290");
-        fIANA2JavaMap.put("EBCDIC-CP-FR",    "CP297");
-        fIANA2JavaMap.put("IBM297",    "CP297");
-        fIANA2JavaMap.put("CP297",    "CP297");
-        fIANA2JavaMap.put("CSIBM297",    "CP297");
-        fIANA2JavaMap.put("EBCDIC-CP-AR1",   "CP420");
-        fIANA2JavaMap.put("IBM420",    "CP420");
-        fIANA2JavaMap.put("CP420",    "CP420");
-        fIANA2JavaMap.put("CSIBM420",    "CP420");
-        fIANA2JavaMap.put("EBCDIC-CP-HE",    "CP424");
-        fIANA2JavaMap.put("IBM424",    "CP424");
-        fIANA2JavaMap.put("CP424",    "CP424");
-        fIANA2JavaMap.put("CSIBM424",    "CP424");
-        fIANA2JavaMap.put("IBM437",    "CP437");
-        fIANA2JavaMap.put("437",    "CP437");
-        fIANA2JavaMap.put("CP437",    "CP437");
-        fIANA2JavaMap.put("CSPC8CODEPAGE437",    "CP437");
-        fIANA2JavaMap.put("EBCDIC-CP-CH",    "CP500");
-        fIANA2JavaMap.put("IBM500",    "CP500");
-        fIANA2JavaMap.put("CP500",    "CP500");
-        fIANA2JavaMap.put("CSIBM500",    "CP500");
-        fIANA2JavaMap.put("EBCDIC-CP-CH",    "CP500");
-        fIANA2JavaMap.put("EBCDIC-CP-BE",    "CP500");
-        fIANA2JavaMap.put("IBM775",    "CP775");
-        fIANA2JavaMap.put("CP775",    "CP775");
-        fIANA2JavaMap.put("CSPC775BALTIC",    "CP775");
-        fIANA2JavaMap.put("IBM850",    "CP850");
-        fIANA2JavaMap.put("850",    "CP850");
-        fIANA2JavaMap.put("CP850",    "CP850");
-        fIANA2JavaMap.put("CSPC850MULTILINGUAL",    "CP850");
-        fIANA2JavaMap.put("IBM852",    "CP852");
-        fIANA2JavaMap.put("852",    "CP852");
-        fIANA2JavaMap.put("CP852",    "CP852");
-        fIANA2JavaMap.put("CSPCP852",    "CP852");
-        fIANA2JavaMap.put("IBM855",    "CP855");
-        fIANA2JavaMap.put("855",    "CP855");
-        fIANA2JavaMap.put("CP855",    "CP855");
-        fIANA2JavaMap.put("CSIBM855",    "CP855");
-        fIANA2JavaMap.put("IBM857",    "CP857");
-        fIANA2JavaMap.put("857",    "CP857");
-        fIANA2JavaMap.put("CP857",    "CP857");
-        fIANA2JavaMap.put("CSIBM857",    "CP857");
-        fIANA2JavaMap.put("IBM00858",    "CP858");
-        fIANA2JavaMap.put("CP00858",    "CP858");
-        fIANA2JavaMap.put("CCSID00858",    "CP858");
-        fIANA2JavaMap.put("IBM860",    "CP860");
-        fIANA2JavaMap.put("860",    "CP860");
-        fIANA2JavaMap.put("CP860",    "CP860");
-        fIANA2JavaMap.put("CSIBM860",    "CP860");
-        fIANA2JavaMap.put("IBM861",    "CP861");
-        fIANA2JavaMap.put("861",    "CP861");
-        fIANA2JavaMap.put("CP861",    "CP861");
-        fIANA2JavaMap.put("CP-IS",    "CP861");
-        fIANA2JavaMap.put("CSIBM861",    "CP861");
-        fIANA2JavaMap.put("IBM862",    "CP862");
-        fIANA2JavaMap.put("862",    "CP862");
-        fIANA2JavaMap.put("CP862",    "CP862");
-        fIANA2JavaMap.put("CSPC862LATINHEBREW",    "CP862");
-        fIANA2JavaMap.put("IBM863",    "CP863");
-        fIANA2JavaMap.put("863",    "CP863");
-        fIANA2JavaMap.put("CP863",    "CP863");
-        fIANA2JavaMap.put("CSIBM863",    "CP863");
-        fIANA2JavaMap.put("IBM864",    "CP864");
-        fIANA2JavaMap.put("CP864",    "CP864");
-        fIANA2JavaMap.put("CSIBM864",    "CP864");
-        fIANA2JavaMap.put("IBM865",    "CP865");
-        fIANA2JavaMap.put("865",    "CP865");
-        fIANA2JavaMap.put("CP865",    "CP865");
-        fIANA2JavaMap.put("CSIBM865",    "CP865");
-        fIANA2JavaMap.put("IBM866",    "CP866");
-        fIANA2JavaMap.put("866",    "CP866");
-        fIANA2JavaMap.put("CP866",    "CP866");
-        fIANA2JavaMap.put("CSIBM866",    "CP866");
-        fIANA2JavaMap.put("IBM868",    "CP868");
-        fIANA2JavaMap.put("CP868",    "CP868");
-        fIANA2JavaMap.put("CSIBM868",    "CP868");
-        fIANA2JavaMap.put("CP-AR",        "CP868");
-        fIANA2JavaMap.put("IBM869",    "CP869");
-        fIANA2JavaMap.put("CP869",    "CP869");
-        fIANA2JavaMap.put("CSIBM869",    "CP869");
-        fIANA2JavaMap.put("CP-GR",        "CP869");
-        fIANA2JavaMap.put("IBM870",    "CP870");
-        fIANA2JavaMap.put("CP870",    "CP870");
-        fIANA2JavaMap.put("CSIBM870",    "CP870");
-        fIANA2JavaMap.put("EBCDIC-CP-ROECE", "CP870");
-        fIANA2JavaMap.put("EBCDIC-CP-YU",    "CP870");
-        fIANA2JavaMap.put("IBM871",    "CP871");
-        fIANA2JavaMap.put("CP871",    "CP871");
-        fIANA2JavaMap.put("CSIBM871",    "CP871");
-        fIANA2JavaMap.put("EBCDIC-CP-IS",    "CP871");
-        fIANA2JavaMap.put("IBM918",    "CP918");
-        fIANA2JavaMap.put("CP918",    "CP918");
-        fIANA2JavaMap.put("CSIBM918",    "CP918");
-        fIANA2JavaMap.put("EBCDIC-CP-AR2",   "CP918");
-        fIANA2JavaMap.put("IBM00924",    "CP924");
-        fIANA2JavaMap.put("CP00924",    "CP924");
-        fIANA2JavaMap.put("CCSID00924",    "CP924");
-        // is this an error???
-        fIANA2JavaMap.put("EBCDIC-LATIN9--EURO",    "CP924");
-        fIANA2JavaMap.put("IBM1026",    "CP1026");
-        fIANA2JavaMap.put("CP1026",    "CP1026");
-        fIANA2JavaMap.put("CSIBM1026",    "CP1026");
-        fIANA2JavaMap.put("IBM01140",    "Cp1140");
-        fIANA2JavaMap.put("CP01140",    "Cp1140");
-        fIANA2JavaMap.put("CCSID01140",    "Cp1140");
-        fIANA2JavaMap.put("IBM01141",    "Cp1141");
-        fIANA2JavaMap.put("CP01141",    "Cp1141");
-        fIANA2JavaMap.put("CCSID01141",    "Cp1141");
-        fIANA2JavaMap.put("IBM01142",    "Cp1142");
-        fIANA2JavaMap.put("CP01142",    "Cp1142");
-        fIANA2JavaMap.put("CCSID01142",    "Cp1142");
-        fIANA2JavaMap.put("IBM01143",    "Cp1143");
-        fIANA2JavaMap.put("CP01143",    "Cp1143");
-        fIANA2JavaMap.put("CCSID01143",    "Cp1143");
-        fIANA2JavaMap.put("IBM01144",    "Cp1144");
-        fIANA2JavaMap.put("CP01144",    "Cp1144");
-        fIANA2JavaMap.put("CCSID01144",    "Cp1144");
-        fIANA2JavaMap.put("IBM01145",    "Cp1145");
-        fIANA2JavaMap.put("CP01145",    "Cp1145");
-        fIANA2JavaMap.put("CCSID01145",    "Cp1145");
-        fIANA2JavaMap.put("IBM01146",    "Cp1146");
-        fIANA2JavaMap.put("CP01146",    "Cp1146");
-        fIANA2JavaMap.put("CCSID01146",    "Cp1146");
-        fIANA2JavaMap.put("IBM01147",    "Cp1147");
-        fIANA2JavaMap.put("CP01147",    "Cp1147");
-        fIANA2JavaMap.put("CCSID01147",    "Cp1147");
-        fIANA2JavaMap.put("IBM01148",    "Cp1148");
-        fIANA2JavaMap.put("CP01148",    "Cp1148");
-        fIANA2JavaMap.put("CCSID01148",    "Cp1148");
-        fIANA2JavaMap.put("IBM01149",    "Cp1149");
-        fIANA2JavaMap.put("CP01149",    "Cp1149");
-        fIANA2JavaMap.put("CCSID01149",    "Cp1149");
-        fIANA2JavaMap.put("EUC-JP",          "EUCJIS");
-        fIANA2JavaMap.put("CSEUCPKDFMTJAPANESE",          "EUCJIS");
-        fIANA2JavaMap.put("EXTENDED_UNIX_CODE_PACKED_FORMAT_FOR_JAPANESE",          "EUCJIS");
-        fIANA2JavaMap.put("EUC-KR",          "KSC5601");
-        fIANA2JavaMap.put("CSEUCKR",          "KSC5601");
-        fIANA2JavaMap.put("KS_C_5601-1987",          "KS_C_5601-1987");
-        fIANA2JavaMap.put("ISO-IR-149",          "KS_C_5601-1987");
-        fIANA2JavaMap.put("KS_C_5601-1989",          "KS_C_5601-1987");
-        fIANA2JavaMap.put("KSC_5601",          "KS_C_5601-1987");
-        fIANA2JavaMap.put("KOREAN",          "KS_C_5601-1987");
-        fIANA2JavaMap.put("CSKSC56011987",          "KS_C_5601-1987");
-        fIANA2JavaMap.put("GB2312",          "GB2312");
-        fIANA2JavaMap.put("CSGB2312",          "GB2312");
-        fIANA2JavaMap.put("ISO-2022-JP",     "JIS");
-        fIANA2JavaMap.put("CSISO2022JP",     "JIS");
-        fIANA2JavaMap.put("ISO-2022-KR",     "ISO2022KR");
-        fIANA2JavaMap.put("CSISO2022KR",     "ISO2022KR");
-        fIANA2JavaMap.put("ISO-2022-CN",     "ISO2022CN");
-
-        fIANA2JavaMap.put("X0201",  "JIS0201");
-        fIANA2JavaMap.put("CSISO13JISC6220JP", "JIS0201");
-        fIANA2JavaMap.put("X0208",  "JIS0208");
-        fIANA2JavaMap.put("ISO-IR-87",  "JIS0208");
-        fIANA2JavaMap.put("X0208dbiJIS_X0208-1983",  "JIS0208");
-        fIANA2JavaMap.put("CSISO87JISX0208",  "JIS0208");
-        fIANA2JavaMap.put("X0212",  "JIS0212");
-        fIANA2JavaMap.put("ISO-IR-159",  "JIS0212");
-        fIANA2JavaMap.put("CSISO159JISX02121990",  "JIS0212");
-        fIANA2JavaMap.put("GB18030",       "GB18030");
-        fIANA2JavaMap.put("GBK",       "GBK");
-        fIANA2JavaMap.put("CP936",       "GBK");
-        fIANA2JavaMap.put("MS936",       "GBK");
-        fIANA2JavaMap.put("WINDOWS-936",       "GBK");
-        fIANA2JavaMap.put("SHIFT_JIS",       "SJIS");
-        fIANA2JavaMap.put("CSSHIFTJIS",       "SJIS");
-        fIANA2JavaMap.put("MS_KANJI",       "SJIS");
-        fIANA2JavaMap.put("WINDOWS-31J",       "MS932");
-        fIANA2JavaMap.put("CSWINDOWS31J",       "MS932");
-
-        // Add support for Cp1252 and its friends
-        fIANA2JavaMap.put("WINDOWS-1250",   "Cp1250");
-        fIANA2JavaMap.put("WINDOWS-1251",   "Cp1251");
-        fIANA2JavaMap.put("WINDOWS-1252",   "Cp1252");
-        fIANA2JavaMap.put("WINDOWS-1253",   "Cp1253");
-        fIANA2JavaMap.put("WINDOWS-1254",   "Cp1254");
-        fIANA2JavaMap.put("WINDOWS-1255",   "Cp1255");
-        fIANA2JavaMap.put("WINDOWS-1256",   "Cp1256");
-        fIANA2JavaMap.put("WINDOWS-1257",   "Cp1257");
-        fIANA2JavaMap.put("WINDOWS-1258",   "Cp1258");
-        fIANA2JavaMap.put("TIS-620",   "TIS620");
-
-        fIANA2JavaMap.put("ISO-8859-1",      "ISO8859_1");
-        fIANA2JavaMap.put("ISO-IR-100",      "ISO8859_1");
-        fIANA2JavaMap.put("ISO_8859-1",      "ISO8859_1");
-        fIANA2JavaMap.put("LATIN1",      "ISO8859_1");
-        fIANA2JavaMap.put("CSISOLATIN1",      "ISO8859_1");
-        fIANA2JavaMap.put("L1",      "ISO8859_1");
-        fIANA2JavaMap.put("IBM819",      "ISO8859_1");
-        fIANA2JavaMap.put("CP819",      "ISO8859_1");
-
-        fIANA2JavaMap.put("ISO-8859-2",      "ISO8859_2");
-        fIANA2JavaMap.put("ISO-IR-101",      "ISO8859_2");
-        fIANA2JavaMap.put("ISO_8859-2",      "ISO8859_2");
-        fIANA2JavaMap.put("LATIN2",      "ISO8859_2");
-        fIANA2JavaMap.put("CSISOLATIN2",      "ISO8859_2");
-        fIANA2JavaMap.put("L2",      "ISO8859_2");
-
-        fIANA2JavaMap.put("ISO-8859-3",      "ISO8859_3");
-        fIANA2JavaMap.put("ISO-IR-109",      "ISO8859_3");
-        fIANA2JavaMap.put("ISO_8859-3",      "ISO8859_3");
-        fIANA2JavaMap.put("LATIN3",      "ISO8859_3");
-        fIANA2JavaMap.put("CSISOLATIN3",      "ISO8859_3");
-        fIANA2JavaMap.put("L3",      "ISO8859_3");
-
-        fIANA2JavaMap.put("ISO-8859-4",      "ISO8859_4");
-        fIANA2JavaMap.put("ISO-IR-110",      "ISO8859_4");
-        fIANA2JavaMap.put("ISO_8859-4",      "ISO8859_4");
-        fIANA2JavaMap.put("LATIN4",      "ISO8859_4");
-        fIANA2JavaMap.put("CSISOLATIN4",      "ISO8859_4");
-        fIANA2JavaMap.put("L4",      "ISO8859_4");
-
-        fIANA2JavaMap.put("ISO-8859-5",      "ISO8859_5");
-        fIANA2JavaMap.put("ISO-IR-144",      "ISO8859_5");
-        fIANA2JavaMap.put("ISO_8859-5",      "ISO8859_5");
-        fIANA2JavaMap.put("CYRILLIC",      "ISO8859_5");
-        fIANA2JavaMap.put("CSISOLATINCYRILLIC",      "ISO8859_5");
-
-        fIANA2JavaMap.put("ISO-8859-6",      "ISO8859_6");
-        fIANA2JavaMap.put("ISO-IR-127",      "ISO8859_6");
-        fIANA2JavaMap.put("ISO_8859-6",      "ISO8859_6");
-        fIANA2JavaMap.put("ECMA-114",      "ISO8859_6");
-        fIANA2JavaMap.put("ASMO-708",      "ISO8859_6");
-        fIANA2JavaMap.put("ARABIC",      "ISO8859_6");
-        fIANA2JavaMap.put("CSISOLATINARABIC",      "ISO8859_6");
-
-        fIANA2JavaMap.put("ISO-8859-7",      "ISO8859_7");
-        fIANA2JavaMap.put("ISO-IR-126",      "ISO8859_7");
-        fIANA2JavaMap.put("ISO_8859-7",      "ISO8859_7");
-        fIANA2JavaMap.put("ELOT_928",      "ISO8859_7");
-        fIANA2JavaMap.put("ECMA-118",      "ISO8859_7");
-        fIANA2JavaMap.put("GREEK",      "ISO8859_7");
-        fIANA2JavaMap.put("CSISOLATINGREEK",      "ISO8859_7");
-        fIANA2JavaMap.put("GREEK8",      "ISO8859_7");
-
-        fIANA2JavaMap.put("ISO-8859-8",      "ISO8859_8");
-        fIANA2JavaMap.put("ISO-8859-8-I",      "ISO8859_8"); // added since this encoding only differs w.r.t. presentation
-        fIANA2JavaMap.put("ISO-IR-138",      "ISO8859_8");
-        fIANA2JavaMap.put("ISO_8859-8",      "ISO8859_8");
-        fIANA2JavaMap.put("HEBREW",      "ISO8859_8");
-        fIANA2JavaMap.put("CSISOLATINHEBREW",      "ISO8859_8");
-
-        fIANA2JavaMap.put("ISO-8859-9",      "ISO8859_9");
-        fIANA2JavaMap.put("ISO-IR-148",      "ISO8859_9");
-        fIANA2JavaMap.put("ISO_8859-9",      "ISO8859_9");
-        fIANA2JavaMap.put("LATIN5",      "ISO8859_9");
-        fIANA2JavaMap.put("CSISOLATIN5",      "ISO8859_9");
-        fIANA2JavaMap.put("L5",      "ISO8859_9");
-
-        fIANA2JavaMap.put("ISO-8859-13",      "ISO8859_13");
-
-        fIANA2JavaMap.put("ISO-8859-15",      "ISO8859_15_FDIS");
-        fIANA2JavaMap.put("ISO_8859-15",      "ISO8859_15_FDIS");
-        fIANA2JavaMap.put("LATIN-9",          "ISO8859_15_FDIS");
-
-        fIANA2JavaMap.put("KOI8-R",          "KOI8_R");
-        fIANA2JavaMap.put("CSKOI8R",          "KOI8_R");
-        fIANA2JavaMap.put("US-ASCII",        "ASCII");
-        fIANA2JavaMap.put("ISO-IR-6",        "ASCII");
-        fIANA2JavaMap.put("ANSI_X3.4-1968",        "ASCII");
-        fIANA2JavaMap.put("ANSI_X3.4-1986",        "ASCII");
-        fIANA2JavaMap.put("ISO_646.IRV:1991",        "ASCII");
-        fIANA2JavaMap.put("ASCII",        "ASCII");
-        fIANA2JavaMap.put("CSASCII",        "ASCII");
-        fIANA2JavaMap.put("ISO646-US",        "ASCII");
-        fIANA2JavaMap.put("US",        "ASCII");
-        fIANA2JavaMap.put("IBM367",        "ASCII");
-        fIANA2JavaMap.put("CP367",        "ASCII");
-        fIANA2JavaMap.put("UTF-8",           "UTF8");
-        fIANA2JavaMap.put("UTF-16",           "UTF-16");
-        fIANA2JavaMap.put("UTF-16BE",           "UnicodeBig");
-        fIANA2JavaMap.put("UTF-16LE",           "UnicodeLittle");
-
-        // support for 1047, as proposed to be added to the
-        // IANA registry in
-        // http://lists.w3.org/Archives/Public/ietf-charset/2002JulSep/0049.html
-        fIANA2JavaMap.put("IBM-1047",    "Cp1047");
-        fIANA2JavaMap.put("IBM1047",    "Cp1047");
-        fIANA2JavaMap.put("CP1047",    "Cp1047");
-
-        // Adding new aliases as proposed in
-        // http://lists.w3.org/Archives/Public/ietf-charset/2002JulSep/0058.html
-        fIANA2JavaMap.put("IBM-37",    "CP037");
-        fIANA2JavaMap.put("IBM-273",    "CP273");
-        fIANA2JavaMap.put("IBM-277",    "CP277");
-        fIANA2JavaMap.put("IBM-278",    "CP278");
-        fIANA2JavaMap.put("IBM-280",    "CP280");
-        fIANA2JavaMap.put("IBM-284",    "CP284");
-        fIANA2JavaMap.put("IBM-285",    "CP285");
-        fIANA2JavaMap.put("IBM-290",    "CP290");
-        fIANA2JavaMap.put("IBM-297",    "CP297");
-        fIANA2JavaMap.put("IBM-420",    "CP420");
-        fIANA2JavaMap.put("IBM-424",    "CP424");
-        fIANA2JavaMap.put("IBM-437",    "CP437");
-        fIANA2JavaMap.put("IBM-500",    "CP500");
-        fIANA2JavaMap.put("IBM-775",    "CP775");
-        fIANA2JavaMap.put("IBM-850",    "CP850");
-        fIANA2JavaMap.put("IBM-852",    "CP852");
-        fIANA2JavaMap.put("IBM-855",    "CP855");
-        fIANA2JavaMap.put("IBM-857",    "CP857");
-        fIANA2JavaMap.put("IBM-858",    "CP858");
-        fIANA2JavaMap.put("IBM-860",    "CP860");
-        fIANA2JavaMap.put("IBM-861",    "CP861");
-        fIANA2JavaMap.put("IBM-862",    "CP862");
-        fIANA2JavaMap.put("IBM-863",    "CP863");
-        fIANA2JavaMap.put("IBM-864",    "CP864");
-        fIANA2JavaMap.put("IBM-865",    "CP865");
-        fIANA2JavaMap.put("IBM-866",    "CP866");
-        fIANA2JavaMap.put("IBM-868",    "CP868");
-        fIANA2JavaMap.put("IBM-869",    "CP869");
-        fIANA2JavaMap.put("IBM-870",    "CP870");
-        fIANA2JavaMap.put("IBM-871",    "CP871");
-        fIANA2JavaMap.put("IBM-918",    "CP918");
-        fIANA2JavaMap.put("IBM-924",    "CP924");
-        fIANA2JavaMap.put("IBM-1026",    "CP1026");
-        fIANA2JavaMap.put("IBM-1140",    "Cp1140");
-        fIANA2JavaMap.put("IBM-1141",    "Cp1141");
-        fIANA2JavaMap.put("IBM-1142",    "Cp1142");
-        fIANA2JavaMap.put("IBM-1143",    "Cp1143");
-        fIANA2JavaMap.put("IBM-1144",    "Cp1144");
-        fIANA2JavaMap.put("IBM-1145",    "Cp1145");
-        fIANA2JavaMap.put("IBM-1146",    "Cp1146");
-        fIANA2JavaMap.put("IBM-1147",    "Cp1147");
-        fIANA2JavaMap.put("IBM-1148",    "Cp1148");
-        fIANA2JavaMap.put("IBM-1149",    "Cp1149");
-        fIANA2JavaMap.put("IBM-819",      "ISO8859_1");
-        fIANA2JavaMap.put("IBM-367",        "ASCII");
-
-        // REVISIT:
-        //   j:CNS11643 -> EUC-TW?
-        //   ISO-2022-CN? ISO-2022-CN-EXT?
-    }
-
-    //
-    // Constructors
-    //
-
-    /**
-     * Default constructor.
-     */
-    public EncodingMap() {}
-
-    //
-    // Public static methods
-    //
-
-    /**
-     * Returns the Java encoding name for the specified IANA encoding name.
-     *
-     * @param ianaEncoding The IANA encoding name.
-     * @return the Java encoding
-     */
-    public static String getIANA2JavaMapping(String ianaEncoding) {
-        return fIANA2JavaMap.get(ianaEncoding);
-    }
-}

==================================================
UCSReader.java
deleted file mode 100644
index c43d488091..0000000000
--- a/java/org/apache/jasper/xmlparser/SymbolTable.java
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation and was
- * originally based on software copyright (c) 1999, International
- * Business Machines, Inc., http://www.apache.org.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- */
-
-package org.apache.jasper.xmlparser;
-
-/**
- * This class is a symbol table implementation that guarantees that
- * strings used as identifiers are unique references. Multiple calls
- * to <code>addSymbol</code> will always return the same string
- * reference.
- * <p>
- * The symbol table performs the same task as <code>String.intern()</code>
- * with the following differences:
- * <ul>
- *  <li>
- *   A new string object does not need to be created in order to
- *   retrieve a unique reference. Symbols can be added by using
- *   a series of characters in a character array.
- *  </li>
- *  <li>
- *   Users of the symbol table can provide their own symbol hashing
- *   implementation. For example, a simple string hashing algorithm
- *   may fail to produce a balanced set of hashcodes for symbols
- *   that are <em>mostly</em> unique. Strings with similar leading
- *   characters are especially prone to this poor hashing behavior.
- *  </li>
- * </ul>
- *
- * @author Andy Clark
- *
- * @deprecated Will be removed in Tomcat 9.0.x onwards
- */
-@Deprecated
-public class SymbolTable {
-
-    //
-    // Constants
-    //
-
-    /**
-     * Default table size.
-     */
-    private static final int TABLE_SIZE = 101;
-
-    //
-    // Data
-    //
-
-    /**
-     * Buckets.
-     */
-    private final Entry[] fBuckets;
-
-    // actual table size
-    private final int fTableSize;
-
-    //
-    // Constructors
-    //
-
-    /**
-     * Constructs a symbol table with a default number of buckets.
-     */
-    public SymbolTable() {
-        this(TABLE_SIZE);
-    }
-
-    /**
-     * Constructs a symbol table with a specified number of buckets.
-     * @param tableSize The table size (default is 101)
-     */
-    public SymbolTable(int tableSize) {
-        fTableSize = tableSize;
-        fBuckets = new Entry[fTableSize];
-    }
-
-    //
-    // Public methods
-    //
-
-    /**
-     * Adds the specified symbol to the symbol table and returns a
-     * reference to the unique symbol. If the symbol already exists,
-     * the previous symbol reference is returned instead, in order
-     * guarantee that symbol references remain unique.
-     *
-     * @param buffer The buffer containing the new symbol.
-     * @param offset The offset into the buffer of the new symbol.
-     * @param length The length of the new symbol in the buffer.
-     * @return the symbol added
-     */
-    public String addSymbol(char[] buffer, int offset, int length) {
-
-        // search for identical symbol
-        int bucket = hash(buffer, offset, length) % fTableSize;
-        OUTER: for (Entry entry = fBuckets[bucket]; entry != null; entry = entry.next) {
-            if (length == entry.characters.length) {
-                for (int i = 0; i < length; i++) {
-                    if (buffer[offset + i] != entry.characters[i]) {
-                        continue OUTER;
-                    }
-                }
-                return entry.symbol;
-            }
-        }
-
-        // add new entry
-        Entry entry = new Entry(buffer, offset, length, fBuckets[bucket]);
-        fBuckets[bucket] = entry;
-        return entry.symbol;
-
-    } // addSymbol(char[],int,int):String
-
-    /**
-     * Returns a hashcode value for the specified symbol information.
-     * The value returned by this method must be identical to the value
-     * returned by the <code>hash(String)</code> method when called
-     * with the string object created from the symbol information.
-     *
-     * @param buffer The character buffer containing the symbol.
-     * @param offset The offset into the character buffer of the start
-     *               of the symbol.
-     * @param length The length of the symbol.
-     * @return the hash value
-     */
-    public int hash(char[] buffer, int offset, int length) {
-
-        int code = 0;
-        for (int i = 0; i < length; i++) {
-            code = code * 37 + buffer[offset + i];
-        }
-        return code & 0x7FFFFFF;
-
-    } // hash(char[],int,int):int
-
-    //
-    // Classes
-    //
-
-    /**
-     * This class is a symbol table entry. Each entry acts as a node
-     * in a linked list.
-     */
-    private static final class Entry {
-
-        /**
-         * Symbol.
-         */
-        private final String symbol;
-
-        /**
-         * Symbol characters. This information is duplicated here for
-         * comparison performance.
-         */
-        private final char[] characters;
-
-        /**
-         * The next entry.
-         */
-        private final Entry next;
-
-        /*
-         * Constructs a new entry from the specified symbol information and
-         * next entry reference.
-         */
-        public Entry(char[] ch, int offset, int length, Entry next) {
-            characters = new char[length];
-            System.arraycopy(ch, offset, characters, 0, length);
-            symbol = new String(characters).intern();
-            this.next = next;
-        }
-    }
-}
\ No newline at end of file

==================================================
UTF8Reader.java
deleted file mode 100644
index cdc3255a9e..0000000000
--- a/java/org/apache/jasper/xmlparser/UCSReader.java
+++ /dev/null
@@ -1,312 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.jasper.xmlparser;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-
-/**
- * Reader for UCS-2 and UCS-4 encodings.
- * (i.e., encodings from ISO-10646-UCS-(2|4)).
- *
- * @author Neil Graham, IBM
- *
- * @deprecated Will be removed in Tomcat 9.0.x onwards
- */
-@Deprecated
-public class UCSReader extends Reader {
-
-    private final Log log = LogFactory.getLog(UCSReader.class);
-
-    //
-    // Constants
-    //
-
-    /** Default byte buffer size (8192, larger than that of ASCIIReader
-     * since it's reasonable to surmise that the average UCS-4-encoded
-     * file should be 4 times as large as the average ASCII-encoded file).
-     */
-    private static final int DEFAULT_BUFFER_SIZE = 8192;
-
-    public static final short UCS2LE = 1;
-    public static final short UCS2BE = 2;
-    public static final short UCS4LE = 4;
-    public static final short UCS4BE = 8;
-
-    //
-    // Data
-    //
-
-    /** Input stream. */
-    private final InputStream fInputStream;
-
-    /** Byte buffer. */
-    private final byte[] fBuffer;
-
-    // what kind of data we're dealing with
-    private final short fEncoding;
-
-    //
-    // Constructors
-    //
-
-    /**
-     * Constructs an ASCII reader from the specified input stream
-     * using the default buffer size.  The Endian-ness and whether this is
-     * UCS-2 or UCS-4 needs also to be known in advance.
-     *
-     * @param inputStream The input stream.
-     * @param encoding One of UCS2LE, UCS2BE, UCS4LE or UCS4BE.
-     */
-    public UCSReader(InputStream inputStream, short encoding) {
-        this(inputStream, DEFAULT_BUFFER_SIZE, encoding);
-    } // <init>(InputStream, short)
-
-    /**
-     * Constructs an ASCII reader from the specified input stream
-     * and buffer size.  The Endian-ness and whether this is
-     * UCS-2 or UCS-4 needs also to be known in advance.
-     *
-     * @param inputStream The input stream.
-     * @param size        The initial buffer size.
-     * @param encoding One of UCS2LE, UCS2BE, UCS4LE or UCS4BE.
-     */
-    public UCSReader(InputStream inputStream, int size, short encoding) {
-        fInputStream = inputStream;
-        fBuffer = new byte[size];
-        fEncoding = encoding;
-    } // <init>(InputStream,int,short)
-
-    //
-    // Reader methods
-    //
-
-    /**
-     * Read a single character.  This method will block until a character is
-     * available, an I/O error occurs, or the end of the stream is reached.
-     *
-     * <p> Subclasses that intend to support efficient single-character input
-     * should override this method.
-     *
-     * @return     The character read, as an integer in the range 0 to 127
-     *             (<tt>0x00-0x7f</tt>), or -1 if the end of the stream has
-     *             been reached
-     *
-     * @exception  IOException  If an I/O error occurs
-     */
-    @Override
-    public int read() throws IOException {
-        int b0 = fInputStream.read() & 0xff;
-        if (b0 == 0xff)
-            return -1;
-        int b1 = fInputStream.read() & 0xff;
-        if (b1 == 0xff)
-            return -1;
-        if(fEncoding >=4) {
-            int b2 = fInputStream.read() & 0xff;
-            if (b2 == 0xff)
-                return -1;
-            int b3 = fInputStream.read() & 0xff;
-            if (b3 == 0xff)
-                return -1;
-            if (log.isDebugEnabled())
-                log.debug("b0 is " + (b0 & 0xff) + " b1 " + (b1 & 0xff) + " b2 " + (b2 & 0xff) + " b3 " + (b3 & 0xff));
-            if (fEncoding == UCS4BE)
-                return (b0<<24)+(b1<<16)+(b2<<8)+b3;
-            else
-                return (b3<<24)+(b2<<16)+(b1<<8)+b0;
-        } else { // UCS-2
-            if (fEncoding == UCS2BE)
-                return (b0<<8)+b1;
-            else
-                return (b1<<8)+b0;
-        }
-    } // read():int
-
-    /**
-     * Read characters into a portion of an array.  This method will block
-     * until some input is available, an I/O error occurs, or the end of the
-     * stream is reached.
-     *
-     * @param      ch     Destination buffer
-     * @param      offset Offset at which to start storing characters
-     * @param      length Maximum number of characters to read
-     *
-     * @return     The number of characters read, or -1 if the end of the
-     *             stream has been reached
-     *
-     * @exception  IOException  If an I/O error occurs
-     */
-    @Override
-    public int read(char ch[], int offset, int length) throws IOException {
-        int byteLength = length << ((fEncoding >= 4)?2:1);
-        if (byteLength > fBuffer.length) {
-            byteLength = fBuffer.length;
-        }
-        int count = fInputStream.read(fBuffer, 0, byteLength);
-        if(count == -1) return -1;
-        // try and make count be a multiple of the number of bytes we're looking for
-        if(fEncoding >= 4) { // BigEndian
-            // this looks ugly, but it avoids an if at any rate...
-            int numToRead = (4 - (count & 3) & 3);
-            for(int i=0; i<numToRead; i++) {
-                int charRead = fInputStream.read();
-                if(charRead == -1) { // end of input; something likely went wrong!A  Pad buffer with nulls.
-                    for (int j = i;j<numToRead; j++)
-                        fBuffer[count+j] = 0;
-                    break;
-                } else {
-                    fBuffer[count+i] = (byte)charRead;
-                }
-            }
-            count += numToRead;
-        } else {
-            int numToRead = count & 1;
-            if(numToRead != 0) {
-                count++;
-                int charRead = fInputStream.read();
-                if(charRead == -1) { // end of input; something likely went wrong!A  Pad buffer with nulls.
-                    fBuffer[count] = 0;
-                } else {
-                    fBuffer[count] = (byte)charRead;
-                }
-            }
-        }
-
-        // now count is a multiple of the right number of bytes
-        int numChars = count >> ((fEncoding >= 4)?2:1);
-        int curPos = 0;
-        for (int i = 0; i < numChars; i++) {
-            int b0 = fBuffer[curPos++] & 0xff;
-            int b1 = fBuffer[curPos++] & 0xff;
-            if(fEncoding >=4) {
-                int b2 = fBuffer[curPos++] & 0xff;
-                int b3 = fBuffer[curPos++] & 0xff;
-                if (fEncoding == UCS4BE)
-                    ch[offset+i] = (char)((b0<<24)+(b1<<16)+(b2<<8)+b3);
-                else
-                    ch[offset+i] = (char)((b3<<24)+(b2<<16)+(b1<<8)+b0);
-            } else { // UCS-2
-                if (fEncoding == UCS2BE)
-                    ch[offset+i] = (char)((b0<<8)+b1);
-                else
-                    ch[offset+i] = (char)((b1<<8)+b0);
-            }
-        }
-        return numChars;
-    } // read(char[],int,int)
-
-    /**
-     * Skip characters.  This method will block until some characters are
-     * available, an I/O error occurs, or the end of the stream is reached.
-     *
-     * @param  n  The number of characters to skip
-     *
-     * @return    The number of characters actually skipped
-     *
-     * @exception  IOException  If an I/O error occurs
-     */
-    @Override
-    public long skip(long n) throws IOException {
-        // charWidth will represent the number of bits to move
-        // n leftward to get num of bytes to skip, and then move the result rightward
-        // to get num of chars effectively skipped.
-        // The trick with &'ing, as with elsewhere in this dcode, is
-        // intended to avoid an expensive use of / that might not be optimized
-        // away.
-        int charWidth = (fEncoding >=4)?2:1;
-        long bytesSkipped = fInputStream.skip(n<<charWidth);
-        if((bytesSkipped & (charWidth | 1)) == 0) return bytesSkipped >> charWidth;
-        return (bytesSkipped >> charWidth) + 1;
-    } // skip(long):long
-
-    /**
-     * Tell whether this stream is ready to be read.
-     *
-     * @return True if the next read() is guaranteed not to block for input,
-     * false otherwise.  Note that returning false does not guarantee that the
-     * next read will block.
-     *
-     * @exception  IOException  If an I/O error occurs
-     */
-    @Override
-    public boolean ready() throws IOException {
-        return false;
-    } // ready()
-
-    /**
-     * Tell whether this stream supports the mark() operation.
-     */
-    @Override
-    public boolean markSupported() {
-        return fInputStream.markSupported();
-    } // markSupported()
-
-    /**
-     * Mark the present position in the stream.  Subsequent calls to reset()
-     * will attempt to reposition the stream to this point.  Not all
-     * character-input streams support the mark() operation.
-     *
-     * @param  readAheadLimit  Limit on the number of characters that may be
-     *                         read while still preserving the mark.  After
-     *                         reading this many characters, attempting to
-     *                         reset the stream may fail.
-     *
-     * @exception  IOException  If the stream does not support mark(),
-     *                          or if some other I/O error occurs
-     */
-    @Override
-    public void mark(int readAheadLimit) throws IOException {
-        fInputStream.mark(readAheadLimit);
-    } // mark(int)
-
-    /**
-     * Reset the stream.  If the stream has been marked, then attempt to
-     * reposition it at the mark.  If the stream has not been marked, then
-     * attempt to reset it in some way appropriate to the particular stream,
-     * for example by repositioning it to its starting point.  Not all
-     * character-input streams support the reset() operation, and some support
-     * reset() without supporting mark().
-     *
-     * @exception  IOException  If the stream has not been marked,
-     *                          or if the mark has been invalidated,
-     *                          or if the stream does not support reset(),
-     *                          or if some other I/O error occurs
-     */
-    @Override
-    public void reset() throws IOException {
-        fInputStream.reset();
-    } // reset()
-
-    /**
-     * Close the stream.  Once a stream has been closed, further read(),
-     * ready(), mark(), or reset() invocations will throw an IOException.
-     * Closing a previously-closed stream, however, has no effect.
-     *
-     * @exception  IOException  If an I/O error occurs
-     */
-     @Override
-    public void close() throws IOException {
-         fInputStream.close();
-     } // close()
-
-} // class UCSReader

==================================================
XMLChar.java
deleted file mode 100644
index 5eb7743cee..0000000000
--- a/java/org/apache/jasper/xmlparser/UTF8Reader.java
+++ /dev/null
@@ -1,639 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.jasper.xmlparser;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-import java.io.UTFDataFormatException;
-
-import org.apache.jasper.compiler.Localizer;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-
-/**
- * @author Andy Clark, IBM
- *
- * @deprecated Will be removed in Tomcat 9.0.x onwards
- */
-@Deprecated
-public class UTF8Reader
-    extends Reader {
-
-    private final Log log = LogFactory.getLog(UTF8Reader.class);
-
-    // debugging
-
-    /** Debug read. */
-    private static final boolean DEBUG_READ = false;
-
-    //
-    // Data
-    //
-
-    /** Input stream. */
-    private final InputStream fInputStream;
-
-    /** Byte buffer. */
-    private final byte[] fBuffer;
-
-    /** Offset into buffer. */
-    private int fOffset;
-
-    /** Surrogate character. */
-    private int fSurrogate = -1;
-
-    //
-    // Constructors
-    //
-
-    /**
-     * Constructs a UTF-8 reader from the specified input stream,
-     * buffer size and MessageFormatter.
-     *
-     * @param inputStream The input stream.
-     * @param size        The initial buffer size.
-     */
-    public UTF8Reader(InputStream inputStream, int size) {
-        fInputStream = inputStream;
-        fBuffer = new byte[size];
-    }
-
-    //
-    // Reader methods
-    //
-
-    /**
-     * Read a single character.  This method will block until a character is
-     * available, an I/O error occurs, or the end of the stream is reached.
-     *
-     * <p> Subclasses that intend to support efficient single-character input
-     * should override this method.
-     *
-     * @return     The character read, as an integer in the range 0 to 16383
-     *             (<tt>0x00-0xffff</tt>), or -1 if the end of the stream has
-     *             been reached
-     *
-     * @exception  IOException  If an I/O error occurs
-     */
-    @Override
-    public int read() throws IOException {
-
-        // decode character
-        int c = fSurrogate;
-        if (fSurrogate == -1) {
-            // NOTE: We use the index into the buffer if there are remaining
-            //       bytes from the last block read. -Ac
-            int index = 0;
-
-            // get first byte
-            int b0 = index == fOffset
-                   ? fInputStream.read() : fBuffer[index++] & 0x00FF;
-            if (b0 == -1) {
-                return -1;
-            }
-
-            // UTF-8:   [0xxx xxxx]
-            // Unicode: [0000 0000] [0xxx xxxx]
-            if (b0 < 0x80) {
-                c = (char)b0;
-            }
-
-            // UTF-8:   [110y yyyy] [10xx xxxx]
-            // Unicode: [0000 0yyy] [yyxx xxxx]
-            else if ((b0 & 0xE0) == 0xC0) {
-                int b1 = index == fOffset
-                       ? fInputStream.read() : fBuffer[index++] & 0x00FF;
-                if (b1 == -1) {
-                    expectedByte(2, 2);
-                }
-                if ((b1 & 0xC0) != 0x80) {
-                    invalidByte(2, 2);
-                }
-                c = ((b0 << 6) & 0x07C0) | (b1 & 0x003F);
-            }
-
-            // UTF-8:   [1110 zzzz] [10yy yyyy] [10xx xxxx]
-            // Unicode: [zzzz yyyy] [yyxx xxxx]
-            else if ((b0 & 0xF0) == 0xE0) {
-                int b1 = index == fOffset
-                       ? fInputStream.read() : fBuffer[index++] & 0x00FF;
-                if (b1 == -1) {
-                    expectedByte(2, 3);
-                }
-                if ((b1 & 0xC0) != 0x80) {
-                    invalidByte(2, 3);
-                }
-                int b2 = index == fOffset
-                       ? fInputStream.read() : fBuffer[index++] & 0x00FF;
-                if (b2 == -1) {
-                    expectedByte(3, 3);
-                }
-                if ((b2 & 0xC0) != 0x80) {
-                    invalidByte(3, 3);
-                }
-                c = ((b0 << 12) & 0xF000) | ((b1 << 6) & 0x0FC0) |
-                    (b2 & 0x003F);
-            }
-
-            // UTF-8:   [1111 0uuu] [10uu zzzz] [10yy yyyy] [10xx xxxx]*
-            // Unicode: [1101 10ww] [wwzz zzyy] (high surrogate)
-            //          [1101 11yy] [yyxx xxxx] (low surrogate)
-            //          * uuuuu = wwww + 1
-            else if ((b0 & 0xF8) == 0xF0) {
-                int b1 = index == fOffset
-                       ? fInputStream.read() : fBuffer[index++] & 0x00FF;
-                if (b1 == -1) {
-                    expectedByte(2, 4);
-                }
-                if ((b1 & 0xC0) != 0x80) {
-                    invalidByte(2, 3);
-                }
-                int b2 = index == fOffset
-                       ? fInputStream.read() : fBuffer[index++] & 0x00FF;
-                if (b2 == -1) {
-                    expectedByte(3, 4);
-                }
-                if ((b2 & 0xC0) != 0x80) {
-                    invalidByte(3, 3);
-                }
-                int b3 = index == fOffset
-                       ? fInputStream.read() : fBuffer[index++] & 0x00FF;
-                if (b3 == -1) {
-                    expectedByte(4, 4);
-                }
-                if ((b3 & 0xC0) != 0x80) {
-                    invalidByte(4, 4);
-                }
-                int uuuuu = ((b0 << 2) & 0x001C) | ((b1 >> 4) & 0x0003);
-                if (uuuuu > 0x10) {
-                    invalidSurrogate(uuuuu);
-                }
-                int wwww = uuuuu - 1;
-                int hs = 0xD800 |
-                         ((wwww << 6) & 0x03C0) | ((b1 << 2) & 0x003C) |
-                         ((b2 >> 4) & 0x0003);
-                int ls = 0xDC00 | ((b2 << 6) & 0x03C0) | (b3 & 0x003F);
-                c = hs;
-                fSurrogate = ls;
-            }
-
-            // error
-            else {
-                invalidByte(1, 1);
-            }
-        }
-
-        // use surrogate
-        else {
-            fSurrogate = -1;
-        }
-
-        // return character
-        if (DEBUG_READ) {
-            if (log.isDebugEnabled())
-                log.debug("read(): 0x"+Integer.toHexString(c));
-        }
-        return c;
-
-    } // read():int
-
-    /**
-     * Read characters into a portion of an array.  This method will block
-     * until some input is available, an I/O error occurs, or the end of the
-     * stream is reached.
-     *
-     * @param      ch     Destination buffer
-     * @param      offset Offset at which to start storing characters
-     * @param      length Maximum number of characters to read
-     *
-     * @return     The number of characters read, or -1 if the end of the
-     *             stream has been reached
-     *
-     * @exception  IOException  If an I/O error occurs
-     */
-    @Override
-    public int read(char ch[], int offset, int length) throws IOException {
-
-        // handle surrogate
-        int out = offset;
-        if (fSurrogate != -1) {
-            ch[offset + 1] = (char)fSurrogate;
-            fSurrogate = -1;
-            length--;
-            out++;
-        }
-
-        // read bytes
-        int count = 0;
-        if (fOffset == 0) {
-            // adjust length to read
-            if (length > fBuffer.length) {
-                length = fBuffer.length;
-            }
-
-            // perform read operation
-            count = fInputStream.read(fBuffer, 0, length);
-            if (count == -1) {
-                return -1;
-            }
-            count += out - offset;
-        }
-
-        // skip read; last character was in error
-        // NOTE: Having an offset value other than zero means that there was
-        //       an error in the last character read. In this case, we have
-        //       skipped the read so we don't consume any bytes past the
-        //       error. By signaling the error on the next block read we
-        //       allow the method to return the most valid characters that
-        //       it can on the previous block read. -Ac
-        else {
-            count = fOffset;
-            fOffset = 0;
-        }
-
-        // convert bytes to characters
-        final int total = count;
-        for (int in = 0; in < total; in++) {
-            int b0 = fBuffer[in] & 0x00FF;
-
-            // UTF-8:   [0xxx xxxx]
-            // Unicode: [0000 0000] [0xxx xxxx]
-            if (b0 < 0x80) {
-                ch[out++] = (char)b0;
-                continue;
-            }
-
-            // UTF-8:   [110y yyyy] [10xx xxxx]
-            // Unicode: [0000 0yyy] [yyxx xxxx]
-            if ((b0 & 0xE0) == 0xC0) {
-                int b1 = -1;
-                if (++in < total) {
-                    b1 = fBuffer[in] & 0x00FF;
-                }
-                else {
-                    b1 = fInputStream.read();
-                    if (b1 == -1) {
-                        if (out > offset) {
-                            fBuffer[0] = (byte)b0;
-                            fOffset = 1;
-                            return out - offset;
-                        }
-                        expectedByte(2, 2);
-                    }
-                    count++;
-                }
-                if ((b1 & 0xC0) != 0x80) {
-                    if (out > offset) {
-                        fBuffer[0] = (byte)b0;
-                        fBuffer[1] = (byte)b1;
-                        fOffset = 2;
-                        return out - offset;
-                    }
-                    invalidByte(2, 2);
-                }
-                int c = ((b0 << 6) & 0x07C0) | (b1 & 0x003F);
-                ch[out++] = (char)c;
-                count -= 1;
-                continue;
-            }
-
-            // UTF-8:   [1110 zzzz] [10yy yyyy] [10xx xxxx]
-            // Unicode: [zzzz yyyy] [yyxx xxxx]
-            if ((b0 & 0xF0) == 0xE0) {
-                int b1 = -1;
-                if (++in < total) {
-                    b1 = fBuffer[in] & 0x00FF;
-                }
-                else {
-                    b1 = fInputStream.read();
-                    if (b1 == -1) {
-                        if (out > offset) {
-                            fBuffer[0] = (byte)b0;
-                            fOffset = 1;
-                            return out - offset;
-                        }
-                        expectedByte(2, 3);
-                    }
-                    count++;
-                }
-                if ((b1 & 0xC0) != 0x80) {
-                    if (out > offset) {
-                        fBuffer[0] = (byte)b0;
-                        fBuffer[1] = (byte)b1;
-                        fOffset = 2;
-                        return out - offset;
-                    }
-                    invalidByte(2, 3);
-                }
-                int b2 = -1;
-                if (++in < total) {
-                    b2 = fBuffer[in] & 0x00FF;
-                }
-                else {
-                    b2 = fInputStream.read();
-                    if (b2 == -1) {
-                        if (out > offset) {
-                            fBuffer[0] = (byte)b0;
-                            fBuffer[1] = (byte)b1;
-                            fOffset = 2;
-                            return out - offset;
-                        }
-                        expectedByte(3, 3);
-                    }
-                    count++;
-                }
-                if ((b2 & 0xC0) != 0x80) {
-                    if (out > offset) {
-                        fBuffer[0] = (byte)b0;
-                        fBuffer[1] = (byte)b1;
-                        fBuffer[2] = (byte)b2;
-                        fOffset = 3;
-                        return out - offset;
-                    }
-                    invalidByte(3, 3);
-                }
-                int c = ((b0 << 12) & 0xF000) | ((b1 << 6) & 0x0FC0) |
-                        (b2 & 0x003F);
-                ch[out++] = (char)c;
-                count -= 2;
-                continue;
-            }
-
-            // UTF-8:   [1111 0uuu] [10uu zzzz] [10yy yyyy] [10xx xxxx]*
-            // Unicode: [1101 10ww] [wwzz zzyy] (high surrogate)
-            //          [1101 11yy] [yyxx xxxx] (low surrogate)
-            //          * uuuuu = wwww + 1
-            if ((b0 & 0xF8) == 0xF0) {
-                int b1 = -1;
-                if (++in < total) {
-                    b1 = fBuffer[in] & 0x00FF;
-                }
-                else {
-                    b1 = fInputStream.read();
-                    if (b1 == -1) {
-                        if (out > offset) {
-                            fBuffer[0] = (byte)b0;
-                            fOffset = 1;
-                            return out - offset;
-                        }
-                        expectedByte(2, 4);
-                    }
-                    count++;
-                }
-                if ((b1 & 0xC0) != 0x80) {
-                    if (out > offset) {
-                        fBuffer[0] = (byte)b0;
-                        fBuffer[1] = (byte)b1;
-                        fOffset = 2;
-                        return out - offset;
-                    }
-                    invalidByte(2, 4);
-                }
-                int b2 = -1;
-                if (++in < total) {
-                    b2 = fBuffer[in] & 0x00FF;
-                }
-                else {
-                    b2 = fInputStream.read();
-                    if (b2 == -1) {
-                        if (out > offset) {
-                            fBuffer[0] = (byte)b0;
-                            fBuffer[1] = (byte)b1;
-                            fOffset = 2;
-                            return out - offset;
-                        }
-                        expectedByte(3, 4);
-                    }
-                    count++;
-                }
-                if ((b2 & 0xC0) != 0x80) {
-                    if (out > offset) {
-                        fBuffer[0] = (byte)b0;
-                        fBuffer[1] = (byte)b1;
-                        fBuffer[2] = (byte)b2;
-                        fOffset = 3;
-                        return out - offset;
-                    }
-                    invalidByte(3, 4);
-                }
-                int b3 = -1;
-                if (++in < total) {
-                    b3 = fBuffer[in] & 0x00FF;
-                }
-                else {
-                    b3 = fInputStream.read();
-                    if (b3 == -1) {
-                        if (out > offset) {
-                            fBuffer[0] = (byte)b0;
-                            fBuffer[1] = (byte)b1;
-                            fBuffer[2] = (byte)b2;
-                            fOffset = 3;
-                            return out - offset;
-                        }
-                        expectedByte(4, 4);
-                    }
-                    count++;
-                }
-                if ((b3 & 0xC0) != 0x80) {
-                    if (out > offset) {
-                        fBuffer[0] = (byte)b0;
-                        fBuffer[1] = (byte)b1;
-                        fBuffer[2] = (byte)b2;
-                        fBuffer[3] = (byte)b3;
-                        fOffset = 4;
-                        return out - offset;
-                    }
-                    invalidByte(4, 4);
-                }
-
-                // decode bytes into surrogate characters
-                int uuuuu = ((b0 << 2) & 0x001C) | ((b1 >> 4) & 0x0003);
-                if (uuuuu > 0x10) {
-                    invalidSurrogate(uuuuu);
-                }
-                int wwww = uuuuu - 1;
-                int zzzz = b1 & 0x000F;
-                int yyyyyy = b2 & 0x003F;
-                int xxxxxx = b3 & 0x003F;
-                int hs = 0xD800 | ((wwww << 6) & 0x03C0) | (zzzz << 2) | (yyyyyy >> 4);
-                int ls = 0xDC00 | ((yyyyyy << 6) & 0x03C0) | xxxxxx;
-
-                // set characters
-                ch[out++] = (char)hs;
-                ch[out++] = (char)ls;
-                count -= 2;
-                continue;
-            }
-
-            // error
-            if (out > offset) {
-                fBuffer[0] = (byte)b0;
-                fOffset = 1;
-                return out - offset;
-            }
-            invalidByte(1, 1);
-        }
-
-        // return number of characters converted
-        if (DEBUG_READ) {
-            if (log.isDebugEnabled())
-                log.debug("read(char[],"+offset+','+length+"): count="+count);
-        }
-        return count;
-
-    } // read(char[],int,int)
-
-    /**
-     * Skip characters.  This method will block until some characters are
-     * available, an I/O error occurs, or the end of the stream is reached.
-     *
-     * @param  n  The number of characters to skip
-     *
-     * @return    The number of characters actually skipped
-     *
-     * @exception  IOException  If an I/O error occurs
-     */
-    @Override
-    public long skip(long n) throws IOException {
-
-        long remaining = n;
-        final char[] ch = new char[fBuffer.length];
-        do {
-            int length = ch.length < remaining ? ch.length : (int)remaining;
-            int count = read(ch, 0, length);
-            if (count > 0) {
-                remaining -= count;
-            }
-            else {
-                break;
-            }
-        } while (remaining > 0);
-
-        long skipped = n - remaining;
-        return skipped;
-
-    } // skip(long):long
-
-    /**
-     * Tell whether this stream is ready to be read.
-     *
-     * @return True if the next read() is guaranteed not to block for input,
-     * false otherwise.  Note that returning false does not guarantee that the
-     * next read will block.
-     *
-     * @exception  IOException  If an I/O error occurs
-     */
-    @Override
-    public boolean ready() throws IOException {
-        return false;
-    } // ready()
-
-    /**
-     * Tell whether this stream supports the mark() operation.
-     */
-    @Override
-    public boolean markSupported() {
-        return false;
-    } // markSupported()
-
-    /**
-     * Mark the present position in the stream.  Subsequent calls to reset()
-     * will attempt to reposition the stream to this point.  Not all
-     * character-input streams support the mark() operation.
-     *
-     * @param  readAheadLimit  Limit on the number of characters that may be
-     *                         read while still preserving the mark.  After
-     *                         reading this many characters, attempting to
-     *                         reset the stream may fail.
-     *
-     * @exception  IOException  If the stream does not support mark(),
-     *                          or if some other I/O error occurs
-     */
-    @Override
-    public void mark(int readAheadLimit) throws IOException {
-        throw new IOException(
-                Localizer.getMessage("jsp.error.xml.operationNotSupported",
-                                     "mark()", "UTF-8"));
-    }
-
-    /**
-     * Reset the stream.  If the stream has been marked, then attempt to
-     * reposition it at the mark.  If the stream has not been marked, then
-     * attempt to reset it in some way appropriate to the particular stream,
-     * for example by repositioning it to its starting point.  Not all
-     * character-input streams support the reset() operation, and some support
-     * reset() without supporting mark().
-     *
-     * @exception  IOException  If the stream has not been marked,
-     *                          or if the mark has been invalidated,
-     *                          or if the stream does not support reset(),
-     *                          or if some other I/O error occurs
-     */
-    @Override
-    public void reset() throws IOException {
-        fOffset = 0;
-        fSurrogate = -1;
-    } // reset()
-
-    /**
-     * Close the stream.  Once a stream has been closed, further read(),
-     * ready(), mark(), or reset() invocations will throw an IOException.
-     * Closing a previously-closed stream, however, has no effect.
-     *
-     * @exception  IOException  If an I/O error occurs
-     */
-    @Override
-    public void close() throws IOException {
-        fInputStream.close();
-    } // close()
-
-    //
-    // Private methods
-    //
-
-    /** Throws an exception for expected byte. */
-    private void expectedByte(int position, int count)
-        throws UTFDataFormatException {
-
-        throw new UTFDataFormatException(
-                Localizer.getMessage("jsp.error.xml.expectedByte",
-                                     Integer.toString(position),
-                                     Integer.toString(count)));
-
-    }
-
-    /** Throws an exception for invalid byte. */
-    private void invalidByte(int position, int count)
-        throws UTFDataFormatException {
-
-        throw new UTFDataFormatException(
-                Localizer.getMessage("jsp.error.xml.invalidByte",
-                                     Integer.toString(position),
-                                     Integer.toString(count)));
-    }
-
-    /** Throws an exception for invalid surrogate bits. */
-    private void invalidSurrogate(int uuuuu) throws UTFDataFormatException {
-
-        throw new UTFDataFormatException(
-                Localizer.getMessage("jsp.error.xml.invalidHighSurrogate",
-                                     Integer.toHexString(uuuuu)));
-    }
-
-} // class UTF8Reader

==================================================
XMLEncodingDetector.java
deleted file mode 100644
index 0f1e6ea0f9..0000000000
--- a/java/org/apache/jasper/xmlparser/XMLChar.java
+++ /dev/null
@@ -1,857 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation and was
- * originally based on software copyright (c) 1999, International
- * Business Machines, Inc., http://www.apache.org.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- */
-
-package org.apache.jasper.xmlparser;
-
-import java.util.Arrays;
-
-/**
- * This class defines the basic XML character properties. The data
- * in this class can be used to verify that a character is a valid
- * XML character or if the character is a space, name start, or name
- * character.
- * <p>
- * A series of convenience methods are supplied to ease the burden
- * of the developer. Because inlining the checks can improve per
- * character performance, the tables of character properties are
- * public. Using the character as an index into the <code>CHARS</code>
- * array and applying the appropriate mask flag (e.g.
- * <code>MASK_VALID</code>), yields the same results as calling the
- * convenience methods. There is one exception: check the comments
- * for the <code>isValid</code> method for details.
- *
- * @author Glenn Marcy, IBM
- * @author Andy Clark, IBM
- * @author Eric Ye, IBM
- * @author Arnaud  Le Hors, IBM
- * @author Michael Glavassevich, IBM
- * @author Rahul Srivastava, Sun Microsystems Inc.
- *
- * @deprecated Will be removed in Tomcat 9.0.x onwards
- */
-@Deprecated
-public class XMLChar {
-
-    //
-    // Constants
-    //
-
-    /** Character flags. */
-    private static final byte[] CHARS = new byte[1 << 16];
-
-    /** Valid character mask. */
-    private static final int MASK_VALID = 0x01;
-
-    /** Space character mask. */
-    private static final int MASK_SPACE = 0x02;
-
-    /** Name start character mask. */
-    private static final int MASK_NAME_START = 0x04;
-
-    /** Name character mask. */
-    private static final int MASK_NAME = 0x08;
-
-    /**
-     * Content character mask. Special characters are those that can
-     * be considered the start of markup, such as '&lt;' and '&amp;'.
-     * The various newline characters are considered special as well.
-     * All other valid XML characters can be considered content.
-     * <p>
-     * This is an optimization for the inner loop of character scanning.
-     */
-    private static final int MASK_CONTENT = 0x20;
-
-    //
-    // Static initialization
-    //
-
-    static {
-
-        // Initializing the Character Flag Array
-        // Code generated by: XMLCharGenerator.
-
-        CHARS[9] = 35;
-        CHARS[10] = 19;
-        CHARS[13] = 19;
-        CHARS[32] = 51;
-        CHARS[33] = 49;
-        CHARS[34] = 33;
-        Arrays.fill(CHARS, 35, 38, (byte) 49 ); // Fill 3 of value (byte) 49
-        CHARS[38] = 1;
-        Arrays.fill(CHARS, 39, 45, (byte) 49 ); // Fill 6 of value (byte) 49
-        Arrays.fill(CHARS, 45, 47, (byte) -71 ); // Fill 2 of value (byte) -71
-        CHARS[47] = 49;
-        Arrays.fill(CHARS, 48, 58, (byte) -71 ); // Fill 10 of value (byte) -71
-        CHARS[58] = 61;
-        CHARS[59] = 49;
-        CHARS[60] = 1;
-        CHARS[61] = 49;
-        CHARS[62] = 33;
-        Arrays.fill(CHARS, 63, 65, (byte) 49 ); // Fill 2 of value (byte) 49
-        Arrays.fill(CHARS, 65, 91, (byte) -3 ); // Fill 26 of value (byte) -3
-        Arrays.fill(CHARS, 91, 93, (byte) 33 ); // Fill 2 of value (byte) 33
-        CHARS[93] = 1;
-        CHARS[94] = 33;
-        CHARS[95] = -3;
-        CHARS[96] = 33;
-        Arrays.fill(CHARS, 97, 123, (byte) -3 ); // Fill 26 of value (byte) -3
-        Arrays.fill(CHARS, 123, 183, (byte) 33 ); // Fill 60 of value (byte) 33
-        CHARS[183] = -87;
-        Arrays.fill(CHARS, 184, 192, (byte) 33 ); // Fill 8 of value (byte) 33
-        Arrays.fill(CHARS, 192, 215, (byte) -19 ); // Fill 23 of value (byte) -19
-        CHARS[215] = 33;
-        Arrays.fill(CHARS, 216, 247, (byte) -19 ); // Fill 31 of value (byte) -19
-        CHARS[247] = 33;
-        Arrays.fill(CHARS, 248, 306, (byte) -19 ); // Fill 58 of value (byte) -19
-        Arrays.fill(CHARS, 306, 308, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 308, 319, (byte) -19 ); // Fill 11 of value (byte) -19
-        Arrays.fill(CHARS, 319, 321, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 321, 329, (byte) -19 ); // Fill 8 of value (byte) -19
-        CHARS[329] = 33;
-        Arrays.fill(CHARS, 330, 383, (byte) -19 ); // Fill 53 of value (byte) -19
-        CHARS[383] = 33;
-        Arrays.fill(CHARS, 384, 452, (byte) -19 ); // Fill 68 of value (byte) -19
-        Arrays.fill(CHARS, 452, 461, (byte) 33 ); // Fill 9 of value (byte) 33
-        Arrays.fill(CHARS, 461, 497, (byte) -19 ); // Fill 36 of value (byte) -19
-        Arrays.fill(CHARS, 497, 500, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 500, 502, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 502, 506, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 506, 536, (byte) -19 ); // Fill 30 of value (byte) -19
-        Arrays.fill(CHARS, 536, 592, (byte) 33 ); // Fill 56 of value (byte) 33
-        Arrays.fill(CHARS, 592, 681, (byte) -19 ); // Fill 89 of value (byte) -19
-        Arrays.fill(CHARS, 681, 699, (byte) 33 ); // Fill 18 of value (byte) 33
-        Arrays.fill(CHARS, 699, 706, (byte) -19 ); // Fill 7 of value (byte) -19
-        Arrays.fill(CHARS, 706, 720, (byte) 33 ); // Fill 14 of value (byte) 33
-        Arrays.fill(CHARS, 720, 722, (byte) -87 ); // Fill 2 of value (byte) -87
-        Arrays.fill(CHARS, 722, 768, (byte) 33 ); // Fill 46 of value (byte) 33
-        Arrays.fill(CHARS, 768, 838, (byte) -87 ); // Fill 70 of value (byte) -87
-        Arrays.fill(CHARS, 838, 864, (byte) 33 ); // Fill 26 of value (byte) 33
-        Arrays.fill(CHARS, 864, 866, (byte) -87 ); // Fill 2 of value (byte) -87
-        Arrays.fill(CHARS, 866, 902, (byte) 33 ); // Fill 36 of value (byte) 33
-        CHARS[902] = -19;
-        CHARS[903] = -87;
-        Arrays.fill(CHARS, 904, 907, (byte) -19 ); // Fill 3 of value (byte) -19
-        CHARS[907] = 33;
-        CHARS[908] = -19;
-        CHARS[909] = 33;
-        Arrays.fill(CHARS, 910, 930, (byte) -19 ); // Fill 20 of value (byte) -19
-        CHARS[930] = 33;
-        Arrays.fill(CHARS, 931, 975, (byte) -19 ); // Fill 44 of value (byte) -19
-        CHARS[975] = 33;
-        Arrays.fill(CHARS, 976, 983, (byte) -19 ); // Fill 7 of value (byte) -19
-        Arrays.fill(CHARS, 983, 986, (byte) 33 ); // Fill 3 of value (byte) 33
-        CHARS[986] = -19;
-        CHARS[987] = 33;
-        CHARS[988] = -19;
-        CHARS[989] = 33;
-        CHARS[990] = -19;
-        CHARS[991] = 33;
-        CHARS[992] = -19;
-        CHARS[993] = 33;
-        Arrays.fill(CHARS, 994, 1012, (byte) -19 ); // Fill 18 of value (byte) -19
-        Arrays.fill(CHARS, 1012, 1025, (byte) 33 ); // Fill 13 of value (byte) 33
-        Arrays.fill(CHARS, 1025, 1037, (byte) -19 ); // Fill 12 of value (byte) -19
-        CHARS[1037] = 33;
-        Arrays.fill(CHARS, 1038, 1104, (byte) -19 ); // Fill 66 of value (byte) -19
-        CHARS[1104] = 33;
-        Arrays.fill(CHARS, 1105, 1117, (byte) -19 ); // Fill 12 of value (byte) -19
-        CHARS[1117] = 33;
-        Arrays.fill(CHARS, 1118, 1154, (byte) -19 ); // Fill 36 of value (byte) -19
-        CHARS[1154] = 33;
-        Arrays.fill(CHARS, 1155, 1159, (byte) -87 ); // Fill 4 of value (byte) -87
-        Arrays.fill(CHARS, 1159, 1168, (byte) 33 ); // Fill 9 of value (byte) 33
-        Arrays.fill(CHARS, 1168, 1221, (byte) -19 ); // Fill 53 of value (byte) -19
-        Arrays.fill(CHARS, 1221, 1223, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 1223, 1225, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 1225, 1227, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 1227, 1229, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 1229, 1232, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 1232, 1260, (byte) -19 ); // Fill 28 of value (byte) -19
-        Arrays.fill(CHARS, 1260, 1262, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 1262, 1270, (byte) -19 ); // Fill 8 of value (byte) -19
-        Arrays.fill(CHARS, 1270, 1272, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 1272, 1274, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 1274, 1329, (byte) 33 ); // Fill 55 of value (byte) 33
-        Arrays.fill(CHARS, 1329, 1367, (byte) -19 ); // Fill 38 of value (byte) -19
-        Arrays.fill(CHARS, 1367, 1369, (byte) 33 ); // Fill 2 of value (byte) 33
-        CHARS[1369] = -19;
-        Arrays.fill(CHARS, 1370, 1377, (byte) 33 ); // Fill 7 of value (byte) 33
-        Arrays.fill(CHARS, 1377, 1415, (byte) -19 ); // Fill 38 of value (byte) -19
-        Arrays.fill(CHARS, 1415, 1425, (byte) 33 ); // Fill 10 of value (byte) 33
-        Arrays.fill(CHARS, 1425, 1442, (byte) -87 ); // Fill 17 of value (byte) -87
-        CHARS[1442] = 33;
-        Arrays.fill(CHARS, 1443, 1466, (byte) -87 ); // Fill 23 of value (byte) -87
-        CHARS[1466] = 33;
-        Arrays.fill(CHARS, 1467, 1470, (byte) -87 ); // Fill 3 of value (byte) -87
-        CHARS[1470] = 33;
-        CHARS[1471] = -87;
-        CHARS[1472] = 33;
-        Arrays.fill(CHARS, 1473, 1475, (byte) -87 ); // Fill 2 of value (byte) -87
-        CHARS[1475] = 33;
-        CHARS[1476] = -87;
-        Arrays.fill(CHARS, 1477, 1488, (byte) 33 ); // Fill 11 of value (byte) 33
-        Arrays.fill(CHARS, 1488, 1515, (byte) -19 ); // Fill 27 of value (byte) -19
-        Arrays.fill(CHARS, 1515, 1520, (byte) 33 ); // Fill 5 of value (byte) 33
-        Arrays.fill(CHARS, 1520, 1523, (byte) -19 ); // Fill 3 of value (byte) -19
-        Arrays.fill(CHARS, 1523, 1569, (byte) 33 ); // Fill 46 of value (byte) 33
-        Arrays.fill(CHARS, 1569, 1595, (byte) -19 ); // Fill 26 of value (byte) -19
-        Arrays.fill(CHARS, 1595, 1600, (byte) 33 ); // Fill 5 of value (byte) 33
-        CHARS[1600] = -87;
-        Arrays.fill(CHARS, 1601, 1611, (byte) -19 ); // Fill 10 of value (byte) -19
-        Arrays.fill(CHARS, 1611, 1619, (byte) -87 ); // Fill 8 of value (byte) -87
-        Arrays.fill(CHARS, 1619, 1632, (byte) 33 ); // Fill 13 of value (byte) 33
-        Arrays.fill(CHARS, 1632, 1642, (byte) -87 ); // Fill 10 of value (byte) -87
-        Arrays.fill(CHARS, 1642, 1648, (byte) 33 ); // Fill 6 of value (byte) 33
-        CHARS[1648] = -87;
-        Arrays.fill(CHARS, 1649, 1720, (byte) -19 ); // Fill 71 of value (byte) -19
-        Arrays.fill(CHARS, 1720, 1722, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 1722, 1727, (byte) -19 ); // Fill 5 of value (byte) -19
-        CHARS[1727] = 33;
-        Arrays.fill(CHARS, 1728, 1743, (byte) -19 ); // Fill 15 of value (byte) -19
-        CHARS[1743] = 33;
-        Arrays.fill(CHARS, 1744, 1748, (byte) -19 ); // Fill 4 of value (byte) -19
-        CHARS[1748] = 33;
-        CHARS[1749] = -19;
-        Arrays.fill(CHARS, 1750, 1765, (byte) -87 ); // Fill 15 of value (byte) -87
-        Arrays.fill(CHARS, 1765, 1767, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 1767, 1769, (byte) -87 ); // Fill 2 of value (byte) -87
-        CHARS[1769] = 33;
-        Arrays.fill(CHARS, 1770, 1774, (byte) -87 ); // Fill 4 of value (byte) -87
-        Arrays.fill(CHARS, 1774, 1776, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 1776, 1786, (byte) -87 ); // Fill 10 of value (byte) -87
-        Arrays.fill(CHARS, 1786, 2305, (byte) 33 ); // Fill 519 of value (byte) 33
-        Arrays.fill(CHARS, 2305, 2308, (byte) -87 ); // Fill 3 of value (byte) -87
-        CHARS[2308] = 33;
-        Arrays.fill(CHARS, 2309, 2362, (byte) -19 ); // Fill 53 of value (byte) -19
-        Arrays.fill(CHARS, 2362, 2364, (byte) 33 ); // Fill 2 of value (byte) 33
-        CHARS[2364] = -87;
-        CHARS[2365] = -19;
-        Arrays.fill(CHARS, 2366, 2382, (byte) -87 ); // Fill 16 of value (byte) -87
-        Arrays.fill(CHARS, 2382, 2385, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 2385, 2389, (byte) -87 ); // Fill 4 of value (byte) -87
-        Arrays.fill(CHARS, 2389, 2392, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 2392, 2402, (byte) -19 ); // Fill 10 of value (byte) -19
-        Arrays.fill(CHARS, 2402, 2404, (byte) -87 ); // Fill 2 of value (byte) -87
-        Arrays.fill(CHARS, 2404, 2406, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 2406, 2416, (byte) -87 ); // Fill 10 of value (byte) -87
-        Arrays.fill(CHARS, 2416, 2433, (byte) 33 ); // Fill 17 of value (byte) 33
-        Arrays.fill(CHARS, 2433, 2436, (byte) -87 ); // Fill 3 of value (byte) -87
-        CHARS[2436] = 33;
-        Arrays.fill(CHARS, 2437, 2445, (byte) -19 ); // Fill 8 of value (byte) -19
-        Arrays.fill(CHARS, 2445, 2447, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 2447, 2449, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 2449, 2451, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 2451, 2473, (byte) -19 ); // Fill 22 of value (byte) -19
-        CHARS[2473] = 33;
-        Arrays.fill(CHARS, 2474, 2481, (byte) -19 ); // Fill 7 of value (byte) -19
-        CHARS[2481] = 33;
-        CHARS[2482] = -19;
-        Arrays.fill(CHARS, 2483, 2486, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 2486, 2490, (byte) -19 ); // Fill 4 of value (byte) -19
-        Arrays.fill(CHARS, 2490, 2492, (byte) 33 ); // Fill 2 of value (byte) 33
-        CHARS[2492] = -87;
-        CHARS[2493] = 33;
-        Arrays.fill(CHARS, 2494, 2501, (byte) -87 ); // Fill 7 of value (byte) -87
-        Arrays.fill(CHARS, 2501, 2503, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 2503, 2505, (byte) -87 ); // Fill 2 of value (byte) -87
-        Arrays.fill(CHARS, 2505, 2507, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 2507, 2510, (byte) -87 ); // Fill 3 of value (byte) -87
-        Arrays.fill(CHARS, 2510, 2519, (byte) 33 ); // Fill 9 of value (byte) 33
-        CHARS[2519] = -87;
-        Arrays.fill(CHARS, 2520, 2524, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 2524, 2526, (byte) -19 ); // Fill 2 of value (byte) -19
-        CHARS[2526] = 33;
-        Arrays.fill(CHARS, 2527, 2530, (byte) -19 ); // Fill 3 of value (byte) -19
-        Arrays.fill(CHARS, 2530, 2532, (byte) -87 ); // Fill 2 of value (byte) -87
-        Arrays.fill(CHARS, 2532, 2534, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 2534, 2544, (byte) -87 ); // Fill 10 of value (byte) -87
-        Arrays.fill(CHARS, 2544, 2546, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 2546, 2562, (byte) 33 ); // Fill 16 of value (byte) 33
-        CHARS[2562] = -87;
-        Arrays.fill(CHARS, 2563, 2565, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 2565, 2571, (byte) -19 ); // Fill 6 of value (byte) -19
-        Arrays.fill(CHARS, 2571, 2575, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 2575, 2577, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 2577, 2579, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 2579, 2601, (byte) -19 ); // Fill 22 of value (byte) -19
-        CHARS[2601] = 33;
-        Arrays.fill(CHARS, 2602, 2609, (byte) -19 ); // Fill 7 of value (byte) -19
-        CHARS[2609] = 33;
-        Arrays.fill(CHARS, 2610, 2612, (byte) -19 ); // Fill 2 of value (byte) -19
-        CHARS[2612] = 33;
-        Arrays.fill(CHARS, 2613, 2615, (byte) -19 ); // Fill 2 of value (byte) -19
-        CHARS[2615] = 33;
-        Arrays.fill(CHARS, 2616, 2618, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 2618, 2620, (byte) 33 ); // Fill 2 of value (byte) 33
-        CHARS[2620] = -87;
-        CHARS[2621] = 33;
-        Arrays.fill(CHARS, 2622, 2627, (byte) -87 ); // Fill 5 of value (byte) -87
-        Arrays.fill(CHARS, 2627, 2631, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 2631, 2633, (byte) -87 ); // Fill 2 of value (byte) -87
-        Arrays.fill(CHARS, 2633, 2635, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 2635, 2638, (byte) -87 ); // Fill 3 of value (byte) -87
-        Arrays.fill(CHARS, 2638, 2649, (byte) 33 ); // Fill 11 of value (byte) 33
-        Arrays.fill(CHARS, 2649, 2653, (byte) -19 ); // Fill 4 of value (byte) -19
-        CHARS[2653] = 33;
-        CHARS[2654] = -19;
-        Arrays.fill(CHARS, 2655, 2662, (byte) 33 ); // Fill 7 of value (byte) 33
-        Arrays.fill(CHARS, 2662, 2674, (byte) -87 ); // Fill 12 of value (byte) -87
-        Arrays.fill(CHARS, 2674, 2677, (byte) -19 ); // Fill 3 of value (byte) -19
-        Arrays.fill(CHARS, 2677, 2689, (byte) 33 ); // Fill 12 of value (byte) 33
-        Arrays.fill(CHARS, 2689, 2692, (byte) -87 ); // Fill 3 of value (byte) -87
-        CHARS[2692] = 33;
-        Arrays.fill(CHARS, 2693, 2700, (byte) -19 ); // Fill 7 of value (byte) -19
-        CHARS[2700] = 33;
-        CHARS[2701] = -19;
-        CHARS[2702] = 33;
-        Arrays.fill(CHARS, 2703, 2706, (byte) -19 ); // Fill 3 of value (byte) -19
-        CHARS[2706] = 33;
-        Arrays.fill(CHARS, 2707, 2729, (byte) -19 ); // Fill 22 of value (byte) -19
-        CHARS[2729] = 33;
-        Arrays.fill(CHARS, 2730, 2737, (byte) -19 ); // Fill 7 of value (byte) -19
-        CHARS[2737] = 33;
-        Arrays.fill(CHARS, 2738, 2740, (byte) -19 ); // Fill 2 of value (byte) -19
-        CHARS[2740] = 33;
-        Arrays.fill(CHARS, 2741, 2746, (byte) -19 ); // Fill 5 of value (byte) -19
-        Arrays.fill(CHARS, 2746, 2748, (byte) 33 ); // Fill 2 of value (byte) 33
-        CHARS[2748] = -87;
-        CHARS[2749] = -19;
-        Arrays.fill(CHARS, 2750, 2758, (byte) -87 ); // Fill 8 of value (byte) -87
-        CHARS[2758] = 33;
-        Arrays.fill(CHARS, 2759, 2762, (byte) -87 ); // Fill 3 of value (byte) -87
-        CHARS[2762] = 33;
-        Arrays.fill(CHARS, 2763, 2766, (byte) -87 ); // Fill 3 of value (byte) -87
-        Arrays.fill(CHARS, 2766, 2784, (byte) 33 ); // Fill 18 of value (byte) 33
-        CHARS[2784] = -19;
-        Arrays.fill(CHARS, 2785, 2790, (byte) 33 ); // Fill 5 of value (byte) 33
-        Arrays.fill(CHARS, 2790, 2800, (byte) -87 ); // Fill 10 of value (byte) -87
-        Arrays.fill(CHARS, 2800, 2817, (byte) 33 ); // Fill 17 of value (byte) 33
-        Arrays.fill(CHARS, 2817, 2820, (byte) -87 ); // Fill 3 of value (byte) -87
-        CHARS[2820] = 33;
-        Arrays.fill(CHARS, 2821, 2829, (byte) -19 ); // Fill 8 of value (byte) -19
-        Arrays.fill(CHARS, 2829, 2831, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 2831, 2833, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 2833, 2835, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 2835, 2857, (byte) -19 ); // Fill 22 of value (byte) -19
-        CHARS[2857] = 33;
-        Arrays.fill(CHARS, 2858, 2865, (byte) -19 ); // Fill 7 of value (byte) -19
-        CHARS[2865] = 33;
-        Arrays.fill(CHARS, 2866, 2868, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 2868, 2870, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 2870, 2874, (byte) -19 ); // Fill 4 of value (byte) -19
-        Arrays.fill(CHARS, 2874, 2876, (byte) 33 ); // Fill 2 of value (byte) 33
-        CHARS[2876] = -87;
-        CHARS[2877] = -19;
-        Arrays.fill(CHARS, 2878, 2884, (byte) -87 ); // Fill 6 of value (byte) -87
-        Arrays.fill(CHARS, 2884, 2887, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 2887, 2889, (byte) -87 ); // Fill 2 of value (byte) -87
-        Arrays.fill(CHARS, 2889, 2891, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 2891, 2894, (byte) -87 ); // Fill 3 of value (byte) -87
-        Arrays.fill(CHARS, 2894, 2902, (byte) 33 ); // Fill 8 of value (byte) 33
-        Arrays.fill(CHARS, 2902, 2904, (byte) -87 ); // Fill 2 of value (byte) -87
-        Arrays.fill(CHARS, 2904, 2908, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 2908, 2910, (byte) -19 ); // Fill 2 of value (byte) -19
-        CHARS[2910] = 33;
-        Arrays.fill(CHARS, 2911, 2914, (byte) -19 ); // Fill 3 of value (byte) -19
-        Arrays.fill(CHARS, 2914, 2918, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 2918, 2928, (byte) -87 ); // Fill 10 of value (byte) -87
-        Arrays.fill(CHARS, 2928, 2946, (byte) 33 ); // Fill 18 of value (byte) 33
-        Arrays.fill(CHARS, 2946, 2948, (byte) -87 ); // Fill 2 of value (byte) -87
-        CHARS[2948] = 33;
-        Arrays.fill(CHARS, 2949, 2955, (byte) -19 ); // Fill 6 of value (byte) -19
-        Arrays.fill(CHARS, 2955, 2958, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 2958, 2961, (byte) -19 ); // Fill 3 of value (byte) -19
-        CHARS[2961] = 33;
-        Arrays.fill(CHARS, 2962, 2966, (byte) -19 ); // Fill 4 of value (byte) -19
-        Arrays.fill(CHARS, 2966, 2969, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 2969, 2971, (byte) -19 ); // Fill 2 of value (byte) -19
-        CHARS[2971] = 33;
-        CHARS[2972] = -19;
-        CHARS[2973] = 33;
-        Arrays.fill(CHARS, 2974, 2976, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 2976, 2979, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 2979, 2981, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 2981, 2984, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 2984, 2987, (byte) -19 ); // Fill 3 of value (byte) -19
-        Arrays.fill(CHARS, 2987, 2990, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 2990, 2998, (byte) -19 ); // Fill 8 of value (byte) -19
-        CHARS[2998] = 33;
-        Arrays.fill(CHARS, 2999, 3002, (byte) -19 ); // Fill 3 of value (byte) -19
-        Arrays.fill(CHARS, 3002, 3006, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 3006, 3011, (byte) -87 ); // Fill 5 of value (byte) -87
-        Arrays.fill(CHARS, 3011, 3014, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 3014, 3017, (byte) -87 ); // Fill 3 of value (byte) -87
-        CHARS[3017] = 33;
-        Arrays.fill(CHARS, 3018, 3022, (byte) -87 ); // Fill 4 of value (byte) -87
-        Arrays.fill(CHARS, 3022, 3031, (byte) 33 ); // Fill 9 of value (byte) 33
-        CHARS[3031] = -87;
-        Arrays.fill(CHARS, 3032, 3047, (byte) 33 ); // Fill 15 of value (byte) 33
-        Arrays.fill(CHARS, 3047, 3056, (byte) -87 ); // Fill 9 of value (byte) -87
-        Arrays.fill(CHARS, 3056, 3073, (byte) 33 ); // Fill 17 of value (byte) 33
-        Arrays.fill(CHARS, 3073, 3076, (byte) -87 ); // Fill 3 of value (byte) -87
-        CHARS[3076] = 33;
-        Arrays.fill(CHARS, 3077, 3085, (byte) -19 ); // Fill 8 of value (byte) -19
-        CHARS[3085] = 33;
-        Arrays.fill(CHARS, 3086, 3089, (byte) -19 ); // Fill 3 of value (byte) -19
-        CHARS[3089] = 33;
-        Arrays.fill(CHARS, 3090, 3113, (byte) -19 ); // Fill 23 of value (byte) -19
-        CHARS[3113] = 33;
-        Arrays.fill(CHARS, 3114, 3124, (byte) -19 ); // Fill 10 of value (byte) -19
-        CHARS[3124] = 33;
-        Arrays.fill(CHARS, 3125, 3130, (byte) -19 ); // Fill 5 of value (byte) -19
-        Arrays.fill(CHARS, 3130, 3134, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 3134, 3141, (byte) -87 ); // Fill 7 of value (byte) -87
-        CHARS[3141] = 33;
-        Arrays.fill(CHARS, 3142, 3145, (byte) -87 ); // Fill 3 of value (byte) -87
-        CHARS[3145] = 33;
-        Arrays.fill(CHARS, 3146, 3150, (byte) -87 ); // Fill 4 of value (byte) -87
-        Arrays.fill(CHARS, 3150, 3157, (byte) 33 ); // Fill 7 of value (byte) 33
-        Arrays.fill(CHARS, 3157, 3159, (byte) -87 ); // Fill 2 of value (byte) -87
-        Arrays.fill(CHARS, 3159, 3168, (byte) 33 ); // Fill 9 of value (byte) 33
-        Arrays.fill(CHARS, 3168, 3170, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 3170, 3174, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 3174, 3184, (byte) -87 ); // Fill 10 of value (byte) -87
-        Arrays.fill(CHARS, 3184, 3202, (byte) 33 ); // Fill 18 of value (byte) 33
-        Arrays.fill(CHARS, 3202, 3204, (byte) -87 ); // Fill 2 of value (byte) -87
-        CHARS[3204] = 33;
-        Arrays.fill(CHARS, 3205, 3213, (byte) -19 ); // Fill 8 of value (byte) -19
-        CHARS[3213] = 33;
-        Arrays.fill(CHARS, 3214, 3217, (byte) -19 ); // Fill 3 of value (byte) -19
-        CHARS[3217] = 33;
-        Arrays.fill(CHARS, 3218, 3241, (byte) -19 ); // Fill 23 of value (byte) -19
-        CHARS[3241] = 33;
-        Arrays.fill(CHARS, 3242, 3252, (byte) -19 ); // Fill 10 of value (byte) -19
-        CHARS[3252] = 33;
-        Arrays.fill(CHARS, 3253, 3258, (byte) -19 ); // Fill 5 of value (byte) -19
-        Arrays.fill(CHARS, 3258, 3262, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 3262, 3269, (byte) -87 ); // Fill 7 of value (byte) -87
-        CHARS[3269] = 33;
-        Arrays.fill(CHARS, 3270, 3273, (byte) -87 ); // Fill 3 of value (byte) -87
-        CHARS[3273] = 33;
-        Arrays.fill(CHARS, 3274, 3278, (byte) -87 ); // Fill 4 of value (byte) -87
-        Arrays.fill(CHARS, 3278, 3285, (byte) 33 ); // Fill 7 of value (byte) 33
-        Arrays.fill(CHARS, 3285, 3287, (byte) -87 ); // Fill 2 of value (byte) -87
-        Arrays.fill(CHARS, 3287, 3294, (byte) 33 ); // Fill 7 of value (byte) 33
-        CHARS[3294] = -19;
-        CHARS[3295] = 33;
-        Arrays.fill(CHARS, 3296, 3298, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 3298, 3302, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 3302, 3312, (byte) -87 ); // Fill 10 of value (byte) -87
-        Arrays.fill(CHARS, 3312, 3330, (byte) 33 ); // Fill 18 of value (byte) 33
-        Arrays.fill(CHARS, 3330, 3332, (byte) -87 ); // Fill 2 of value (byte) -87
-        CHARS[3332] = 33;
-        Arrays.fill(CHARS, 3333, 3341, (byte) -19 ); // Fill 8 of value (byte) -19
-        CHARS[3341] = 33;
-        Arrays.fill(CHARS, 3342, 3345, (byte) -19 ); // Fill 3 of value (byte) -19
-        CHARS[3345] = 33;
-        Arrays.fill(CHARS, 3346, 3369, (byte) -19 ); // Fill 23 of value (byte) -19
-        CHARS[3369] = 33;
-        Arrays.fill(CHARS, 3370, 3386, (byte) -19 ); // Fill 16 of value (byte) -19
-        Arrays.fill(CHARS, 3386, 3390, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 3390, 3396, (byte) -87 ); // Fill 6 of value (byte) -87
-        Arrays.fill(CHARS, 3396, 3398, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 3398, 3401, (byte) -87 ); // Fill 3 of value (byte) -87
-        CHARS[3401] = 33;
-        Arrays.fill(CHARS, 3402, 3406, (byte) -87 ); // Fill 4 of value (byte) -87
-        Arrays.fill(CHARS, 3406, 3415, (byte) 33 ); // Fill 9 of value (byte) 33
-        CHARS[3415] = -87;
-        Arrays.fill(CHARS, 3416, 3424, (byte) 33 ); // Fill 8 of value (byte) 33
-        Arrays.fill(CHARS, 3424, 3426, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 3426, 3430, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 3430, 3440, (byte) -87 ); // Fill 10 of value (byte) -87
-        Arrays.fill(CHARS, 3440, 3585, (byte) 33 ); // Fill 145 of value (byte) 33
-        Arrays.fill(CHARS, 3585, 3631, (byte) -19 ); // Fill 46 of value (byte) -19
-        CHARS[3631] = 33;
-        CHARS[3632] = -19;
-        CHARS[3633] = -87;
-        Arrays.fill(CHARS, 3634, 3636, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 3636, 3643, (byte) -87 ); // Fill 7 of value (byte) -87
-        Arrays.fill(CHARS, 3643, 3648, (byte) 33 ); // Fill 5 of value (byte) 33
-        Arrays.fill(CHARS, 3648, 3654, (byte) -19 ); // Fill 6 of value (byte) -19
-        Arrays.fill(CHARS, 3654, 3663, (byte) -87 ); // Fill 9 of value (byte) -87
-        CHARS[3663] = 33;
-        Arrays.fill(CHARS, 3664, 3674, (byte) -87 ); // Fill 10 of value (byte) -87
-        Arrays.fill(CHARS, 3674, 3713, (byte) 33 ); // Fill 39 of value (byte) 33
-        Arrays.fill(CHARS, 3713, 3715, (byte) -19 ); // Fill 2 of value (byte) -19
-        CHARS[3715] = 33;
-        CHARS[3716] = -19;
-        Arrays.fill(CHARS, 3717, 3719, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 3719, 3721, (byte) -19 ); // Fill 2 of value (byte) -19
-        CHARS[3721] = 33;
-        CHARS[3722] = -19;
-        Arrays.fill(CHARS, 3723, 3725, (byte) 33 ); // Fill 2 of value (byte) 33
-        CHARS[3725] = -19;
-        Arrays.fill(CHARS, 3726, 3732, (byte) 33 ); // Fill 6 of value (byte) 33
-        Arrays.fill(CHARS, 3732, 3736, (byte) -19 ); // Fill 4 of value (byte) -19
-        CHARS[3736] = 33;
-        Arrays.fill(CHARS, 3737, 3744, (byte) -19 ); // Fill 7 of value (byte) -19
-        CHARS[3744] = 33;
-        Arrays.fill(CHARS, 3745, 3748, (byte) -19 ); // Fill 3 of value (byte) -19
-        CHARS[3748] = 33;
-        CHARS[3749] = -19;
-        CHARS[3750] = 33;
-        CHARS[3751] = -19;
-        Arrays.fill(CHARS, 3752, 3754, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 3754, 3756, (byte) -19 ); // Fill 2 of value (byte) -19
-        CHARS[3756] = 33;
-        Arrays.fill(CHARS, 3757, 3759, (byte) -19 ); // Fill 2 of value (byte) -19
-        CHARS[3759] = 33;
-        CHARS[3760] = -19;
-        CHARS[3761] = -87;
-        Arrays.fill(CHARS, 3762, 3764, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 3764, 3770, (byte) -87 ); // Fill 6 of value (byte) -87
-        CHARS[3770] = 33;
-        Arrays.fill(CHARS, 3771, 3773, (byte) -87 ); // Fill 2 of value (byte) -87
-        CHARS[3773] = -19;
-        Arrays.fill(CHARS, 3774, 3776, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 3776, 3781, (byte) -19 ); // Fill 5 of value (byte) -19
-        CHARS[3781] = 33;
-        CHARS[3782] = -87;
-        CHARS[3783] = 33;
-        Arrays.fill(CHARS, 3784, 3790, (byte) -87 ); // Fill 6 of value (byte) -87
-        Arrays.fill(CHARS, 3790, 3792, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 3792, 3802, (byte) -87 ); // Fill 10 of value (byte) -87
-        Arrays.fill(CHARS, 3802, 3864, (byte) 33 ); // Fill 62 of value (byte) 33
-        Arrays.fill(CHARS, 3864, 3866, (byte) -87 ); // Fill 2 of value (byte) -87
-        Arrays.fill(CHARS, 3866, 3872, (byte) 33 ); // Fill 6 of value (byte) 33
-        Arrays.fill(CHARS, 3872, 3882, (byte) -87 ); // Fill 10 of value (byte) -87
-        Arrays.fill(CHARS, 3882, 3893, (byte) 33 ); // Fill 11 of value (byte) 33
-        CHARS[3893] = -87;
-        CHARS[3894] = 33;
-        CHARS[3895] = -87;
-        CHARS[3896] = 33;
-        CHARS[3897] = -87;
-        Arrays.fill(CHARS, 3898, 3902, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 3902, 3904, (byte) -87 ); // Fill 2 of value (byte) -87
-        Arrays.fill(CHARS, 3904, 3912, (byte) -19 ); // Fill 8 of value (byte) -19
-        CHARS[3912] = 33;
-        Arrays.fill(CHARS, 3913, 3946, (byte) -19 ); // Fill 33 of value (byte) -19
-        Arrays.fill(CHARS, 3946, 3953, (byte) 33 ); // Fill 7 of value (byte) 33
-        Arrays.fill(CHARS, 3953, 3973, (byte) -87 ); // Fill 20 of value (byte) -87
-        CHARS[3973] = 33;
-        Arrays.fill(CHARS, 3974, 3980, (byte) -87 ); // Fill 6 of value (byte) -87
-        Arrays.fill(CHARS, 3980, 3984, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 3984, 3990, (byte) -87 ); // Fill 6 of value (byte) -87
-        CHARS[3990] = 33;
-        CHARS[3991] = -87;
-        CHARS[3992] = 33;
-        Arrays.fill(CHARS, 3993, 4014, (byte) -87 ); // Fill 21 of value (byte) -87
-        Arrays.fill(CHARS, 4014, 4017, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 4017, 4024, (byte) -87 ); // Fill 7 of value (byte) -87
-        CHARS[4024] = 33;
-        CHARS[4025] = -87;
-        Arrays.fill(CHARS, 4026, 4256, (byte) 33 ); // Fill 230 of value (byte) 33
-        Arrays.fill(CHARS, 4256, 4294, (byte) -19 ); // Fill 38 of value (byte) -19
-        Arrays.fill(CHARS, 4294, 4304, (byte) 33 ); // Fill 10 of value (byte) 33
-        Arrays.fill(CHARS, 4304, 4343, (byte) -19 ); // Fill 39 of value (byte) -19
-        Arrays.fill(CHARS, 4343, 4352, (byte) 33 ); // Fill 9 of value (byte) 33
-        CHARS[4352] = -19;
-        CHARS[4353] = 33;
-        Arrays.fill(CHARS, 4354, 4356, (byte) -19 ); // Fill 2 of value (byte) -19
-        CHARS[4356] = 33;
-        Arrays.fill(CHARS, 4357, 4360, (byte) -19 ); // Fill 3 of value (byte) -19
-        CHARS[4360] = 33;
-        CHARS[4361] = -19;
-        CHARS[4362] = 33;
-        Arrays.fill(CHARS, 4363, 4365, (byte) -19 ); // Fill 2 of value (byte) -19
-        CHARS[4365] = 33;
-        Arrays.fill(CHARS, 4366, 4371, (byte) -19 ); // Fill 5 of value (byte) -19
-        Arrays.fill(CHARS, 4371, 4412, (byte) 33 ); // Fill 41 of value (byte) 33
-        CHARS[4412] = -19;
-        CHARS[4413] = 33;
-        CHARS[4414] = -19;
-        CHARS[4415] = 33;
-        CHARS[4416] = -19;
-        Arrays.fill(CHARS, 4417, 4428, (byte) 33 ); // Fill 11 of value (byte) 33
-        CHARS[4428] = -19;
-        CHARS[4429] = 33;
-        CHARS[4430] = -19;
-        CHARS[4431] = 33;
-        CHARS[4432] = -19;
-        Arrays.fill(CHARS, 4433, 4436, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 4436, 4438, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 4438, 4441, (byte) 33 ); // Fill 3 of value (byte) 33
-        CHARS[4441] = -19;
-        Arrays.fill(CHARS, 4442, 4447, (byte) 33 ); // Fill 5 of value (byte) 33
-        Arrays.fill(CHARS, 4447, 4450, (byte) -19 ); // Fill 3 of value (byte) -19
-        CHARS[4450] = 33;
-        CHARS[4451] = -19;
-        CHARS[4452] = 33;
-        CHARS[4453] = -19;
-        CHARS[4454] = 33;
-        CHARS[4455] = -19;
-        CHARS[4456] = 33;
-        CHARS[4457] = -19;
-        Arrays.fill(CHARS, 4458, 4461, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 4461, 4463, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 4463, 4466, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 4466, 4468, (byte) -19 ); // Fill 2 of value (byte) -19
-        CHARS[4468] = 33;
-        CHARS[4469] = -19;
-        Arrays.fill(CHARS, 4470, 4510, (byte) 33 ); // Fill 40 of value (byte) 33
-        CHARS[4510] = -19;
-        Arrays.fill(CHARS, 4511, 4520, (byte) 33 ); // Fill 9 of value (byte) 33
-        CHARS[4520] = -19;
-        Arrays.fill(CHARS, 4521, 4523, (byte) 33 ); // Fill 2 of value (byte) 33
-        CHARS[4523] = -19;
-        Arrays.fill(CHARS, 4524, 4526, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 4526, 4528, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 4528, 4535, (byte) 33 ); // Fill 7 of value (byte) 33
-        Arrays.fill(CHARS, 4535, 4537, (byte) -19 ); // Fill 2 of value (byte) -19
-        CHARS[4537] = 33;
-        CHARS[4538] = -19;
-        CHARS[4539] = 33;
-        Arrays.fill(CHARS, 4540, 4547, (byte) -19 ); // Fill 7 of value (byte) -19
-        Arrays.fill(CHARS, 4547, 4587, (byte) 33 ); // Fill 40 of value (byte) 33
-        CHARS[4587] = -19;
-        Arrays.fill(CHARS, 4588, 4592, (byte) 33 ); // Fill 4 of value (byte) 33
-        CHARS[4592] = -19;
-        Arrays.fill(CHARS, 4593, 4601, (byte) 33 ); // Fill 8 of value (byte) 33
-        CHARS[4601] = -19;
-        Arrays.fill(CHARS, 4602, 7680, (byte) 33 ); // Fill 3078 of value (byte) 33
-        Arrays.fill(CHARS, 7680, 7836, (byte) -19 ); // Fill 156 of value (byte) -19
-        Arrays.fill(CHARS, 7836, 7840, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 7840, 7930, (byte) -19 ); // Fill 90 of value (byte) -19
-        Arrays.fill(CHARS, 7930, 7936, (byte) 33 ); // Fill 6 of value (byte) 33
-        Arrays.fill(CHARS, 7936, 7958, (byte) -19 ); // Fill 22 of value (byte) -19
-        Arrays.fill(CHARS, 7958, 7960, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 7960, 7966, (byte) -19 ); // Fill 6 of value (byte) -19
-        Arrays.fill(CHARS, 7966, 7968, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 7968, 8006, (byte) -19 ); // Fill 38 of value (byte) -19
-        Arrays.fill(CHARS, 8006, 8008, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 8008, 8014, (byte) -19 ); // Fill 6 of value (byte) -19
-        Arrays.fill(CHARS, 8014, 8016, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 8016, 8024, (byte) -19 ); // Fill 8 of value (byte) -19
-        CHARS[8024] = 33;
-        CHARS[8025] = -19;
-        CHARS[8026] = 33;
-        CHARS[8027] = -19;
-        CHARS[8028] = 33;
-        CHARS[8029] = -19;
-        CHARS[8030] = 33;
-        Arrays.fill(CHARS, 8031, 8062, (byte) -19 ); // Fill 31 of value (byte) -19
-        Arrays.fill(CHARS, 8062, 8064, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 8064, 8117, (byte) -19 ); // Fill 53 of value (byte) -19
-        CHARS[8117] = 33;
-        Arrays.fill(CHARS, 8118, 8125, (byte) -19 ); // Fill 7 of value (byte) -19
-        CHARS[8125] = 33;
-        CHARS[8126] = -19;
-        Arrays.fill(CHARS, 8127, 8130, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 8130, 8133, (byte) -19 ); // Fill 3 of value (byte) -19
-        CHARS[8133] = 33;
-        Arrays.fill(CHARS, 8134, 8141, (byte) -19 ); // Fill 7 of value (byte) -19
-        Arrays.fill(CHARS, 8141, 8144, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 8144, 8148, (byte) -19 ); // Fill 4 of value (byte) -19
-        Arrays.fill(CHARS, 8148, 8150, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 8150, 8156, (byte) -19 ); // Fill 6 of value (byte) -19
-        Arrays.fill(CHARS, 8156, 8160, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 8160, 8173, (byte) -19 ); // Fill 13 of value (byte) -19
-        Arrays.fill(CHARS, 8173, 8178, (byte) 33 ); // Fill 5 of value (byte) 33
-        Arrays.fill(CHARS, 8178, 8181, (byte) -19 ); // Fill 3 of value (byte) -19
-        CHARS[8181] = 33;
-        Arrays.fill(CHARS, 8182, 8189, (byte) -19 ); // Fill 7 of value (byte) -19
-        Arrays.fill(CHARS, 8189, 8400, (byte) 33 ); // Fill 211 of value (byte) 33
-        Arrays.fill(CHARS, 8400, 8413, (byte) -87 ); // Fill 13 of value (byte) -87
-        Arrays.fill(CHARS, 8413, 8417, (byte) 33 ); // Fill 4 of value (byte) 33
-        CHARS[8417] = -87;
-        Arrays.fill(CHARS, 8418, 8486, (byte) 33 ); // Fill 68 of value (byte) 33
-        CHARS[8486] = -19;
-        Arrays.fill(CHARS, 8487, 8490, (byte) 33 ); // Fill 3 of value (byte) 33
-        Arrays.fill(CHARS, 8490, 8492, (byte) -19 ); // Fill 2 of value (byte) -19
-        Arrays.fill(CHARS, 8492, 8494, (byte) 33 ); // Fill 2 of value (byte) 33
-        CHARS[8494] = -19;
-        Arrays.fill(CHARS, 8495, 8576, (byte) 33 ); // Fill 81 of value (byte) 33
-        Arrays.fill(CHARS, 8576, 8579, (byte) -19 ); // Fill 3 of value (byte) -19
-        Arrays.fill(CHARS, 8579, 12293, (byte) 33 ); // Fill 3714 of value (byte) 33
-        CHARS[12293] = -87;
-        CHARS[12294] = 33;
-        CHARS[12295] = -19;
-        Arrays.fill(CHARS, 12296, 12321, (byte) 33 ); // Fill 25 of value (byte) 33
-        Arrays.fill(CHARS, 12321, 12330, (byte) -19 ); // Fill 9 of value (byte) -19
-        Arrays.fill(CHARS, 12330, 12336, (byte) -87 ); // Fill 6 of value (byte) -87
-        CHARS[12336] = 33;
-        Arrays.fill(CHARS, 12337, 12342, (byte) -87 ); // Fill 5 of value (byte) -87
-        Arrays.fill(CHARS, 12342, 12353, (byte) 33 ); // Fill 11 of value (byte) 33
-        Arrays.fill(CHARS, 12353, 12437, (byte) -19 ); // Fill 84 of value (byte) -19
-        Arrays.fill(CHARS, 12437, 12441, (byte) 33 ); // Fill 4 of value (byte) 33
-        Arrays.fill(CHARS, 12441, 12443, (byte) -87 ); // Fill 2 of value (byte) -87
-        Arrays.fill(CHARS, 12443, 12445, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 12445, 12447, (byte) -87 ); // Fill 2 of value (byte) -87
-        Arrays.fill(CHARS, 12447, 12449, (byte) 33 ); // Fill 2 of value (byte) 33
-        Arrays.fill(CHARS, 12449, 12539, (byte) -19 ); // Fill 90 of value (byte) -19
-        CHARS[12539] = 33;
-        Arrays.fill(CHARS, 12540, 12543, (byte) -87 ); // Fill 3 of value (byte) -87
-        Arrays.fill(CHARS, 12543, 12549, (byte) 33 ); // Fill 6 of value (byte) 33
-        Arrays.fill(CHARS, 12549, 12589, (byte) -19 ); // Fill 40 of value (byte) -19
-        Arrays.fill(CHARS, 12589, 19968, (byte) 33 ); // Fill 7379 of value (byte) 33
-        Arrays.fill(CHARS, 19968, 40870, (byte) -19 ); // Fill 20902 of value (byte) -19
-        Arrays.fill(CHARS, 40870, 44032, (byte) 33 ); // Fill 3162 of value (byte) 33
-        Arrays.fill(CHARS, 44032, 55204, (byte) -19 ); // Fill 11172 of value (byte) -19
-        Arrays.fill(CHARS, 55204, 55296, (byte) 33 ); // Fill 92 of value (byte) 33
-        Arrays.fill(CHARS, 57344, 65534, (byte) 33 ); // Fill 8190 of value (byte) 33
-
-    } // <clinit>()
-
-    //
-    // Public static methods
-    //
-
-    /**
-     * Returns the supplemental character corresponding to the given
-     * surrogates.
-     *
-     * @param h The high surrogate.
-     * @param l The low surrogate.
-     * @return the supplemental character
-     */
-    public static int supplemental(char h, char l) {
-        return (h - 0xD800) * 0x400 + (l - 0xDC00) + 0x10000;
-    }
-
-    /**
-     * Returns whether the given character is a high surrogate
-     *
-     * @param c The character to check.
-     * @return <code>true</code> if the character is a surrogate
-     */
-    public static boolean isHighSurrogate(int c) {
-        return (0xD800 <= c && c <= 0xDBFF);
-    }
-
-    /**
-     * Returns whether the given character is a low surrogate
-     *
-     * @param c The character to check.
-     * @return <code>true</code> if the character is a surrogate
-     */
-    public static boolean isLowSurrogate(int c) {
-        return (0xDC00 <= c && c <= 0xDFFF);
-    }
-
-
-    /**
-     * Returns true if the specified character is valid. This method
-     * also checks the surrogate character range from 0x10000 to 0x10FFFF.
-     * <p>
-     * If the program chooses to apply the mask directly to the
-     * <code>CHARS</code> array, then they are responsible for checking
-     * the surrogate character range.
-     *
-     * @param c The character to check.
-     * @return <code>true</code> if the character is valid
-     */
-    public static boolean isValid(int c) {
-        return (c < 0x10000 && (CHARS[c] & MASK_VALID) != 0) ||
-               (0x10000 <= c && c <= 0x10FFFF);
-    } // isValid(int):boolean
-
-    /**
-     * Returns true if the specified character is invalid.
-     *
-     * @param c The character to check.
-     * @return <code>true</code> if the character is invalid
-     */
-    public static boolean isInvalid(int c) {
-        return !isValid(c);
-    } // isInvalid(int):boolean
-
-    /**
-     * Returns true if the specified character can be considered content.
-     *
-     * @param c The character to check.
-     * @return <code>true</code> if the character is content
-     */
-    public static boolean isContent(int c) {
-        return (c < 0x10000 && (CHARS[c] & MASK_CONTENT) != 0) ||
-               (0x10000 <= c && c <= 0x10FFFF);
-    } // isContent(int):boolean
-
-    /**
-     * Returns true if the specified character is a space character
-     * as defined by production [3] in the XML 1.0 specification.
-     *
-     * @param c The character to check.
-     * @return <code>true</code> if the character is space
-     */
-    public static boolean isSpace(int c) {
-        return c <= 0x20 && (CHARS[c] & MASK_SPACE) != 0;
-    } // isSpace(int):boolean
-
-    /**
-     * Returns true if the specified character is a valid name start
-     * character as defined by production [5] in the XML 1.0
-     * specification.
-     *
-     * @param c The character to check.
-     * @return <code>true</code> if the character is a valid start name
-     */
-    public static boolean isNameStart(int c) {
-        return c < 0x10000 && (CHARS[c] & MASK_NAME_START) != 0;
-    } // isNameStart(int):boolean
-
-    /**
-     * Returns true if the specified character is a valid name
-     * character as defined by production [4] in the XML 1.0
-     * specification.
-     *
-     * @param c The character to check.
-     * @return <code>true</code> if the character is valid in a name
-     */
-    public static boolean isName(int c) {
-        return c < 0x10000 && (CHARS[c] & MASK_NAME) != 0;
-    } // isName(int):boolean
-
-    // encodings
-
-    /**
-     * Returns true if the encoding name is a valid IANA encoding.
-     * This method does not verify that there is a decoder available
-     * for this encoding, only that the characters are valid for an
-     * IANA encoding name.
-     *
-     * @param ianaEncoding The IANA encoding name.
-     * @return <code>true</code> if the character is valid encoding
-     */
-    public static boolean isValidIANAEncoding(String ianaEncoding) {
-        if (ianaEncoding != null) {
-            int length = ianaEncoding.length();
-            if (length > 0) {
-                char c = ianaEncoding.charAt(0);
-                if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
-                    for (int i = 1; i < length; i++) {
-                        c = ianaEncoding.charAt(i);
-                        if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') &&
-                            (c < '0' || c > '9') && c != '.' && c != '_' &&
-                            c != '-') {
-                            return false;
-                        }
-                    }
-                    return true;
-                }
-            }
-        }
-        return false;
-    } // isValidIANAEncoding(String):boolean
-} // class XMLChar

==================================================
XMLString.java
deleted file mode 100644
index 8a1a613f5e..0000000000
--- a/java/org/apache/jasper/xmlparser/XMLEncodingDetector.java
+++ /dev/null
@@ -1,1605 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation and was
- * originally based on software copyright (c) 1999, International
- * Business Machines, Inc., http://www.apache.org.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- */
-package org.apache.jasper.xmlparser;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.util.Locale;
-
-import org.apache.jasper.JasperException;
-import org.apache.jasper.JspCompilationContext;
-import org.apache.jasper.compiler.ErrorDispatcher;
-import org.apache.jasper.compiler.JspUtil;
-import org.apache.jasper.compiler.Localizer;
-import org.apache.tomcat.Jar;
-
-/**
- * @deprecated Will be removed in Tomcat 9.0.x onwards
- */
-@Deprecated
-public class XMLEncodingDetector {
-
-    private InputStream stream;
-    private String encoding;
-    private boolean isEncodingSetInProlog;
-    private boolean isBomPresent;
-    private int skip;
-    private Boolean isBigEndian;
-    private Reader reader;
-
-    // org.apache.xerces.impl.XMLEntityManager fields
-    private static final int DEFAULT_BUFFER_SIZE = 2048;
-    private static final int DEFAULT_XMLDECL_BUFFER_SIZE = 64;
-    private final SymbolTable fSymbolTable;
-    private final XMLEncodingDetector fCurrentEntity;
-    private int fBufferSize = DEFAULT_BUFFER_SIZE;
-
-    // org.apache.xerces.impl.XMLEntityManager.ScannedEntity fields
-    private char[] ch = new char[DEFAULT_BUFFER_SIZE];
-    private int position;
-    private int count;
-
-    // org.apache.xerces.impl.XMLScanner fields
-    private final XMLString fString = new XMLString();
-    private final XMLStringBuffer fStringBuffer = new XMLStringBuffer();
-    private final XMLStringBuffer fStringBuffer2 = new XMLStringBuffer();
-    private static final String fVersionSymbol = "version";
-    private static final String fEncodingSymbol = "encoding";
-    private static final String fStandaloneSymbol = "standalone";
-
-    // org.apache.xerces.impl.XMLDocumentFragmentScannerImpl fields
-    private final String[] fStrings = new String[3];
-
-    private ErrorDispatcher err;
-
-    /**
-     * Constructor
-     */
-    public XMLEncodingDetector() {
-        fSymbolTable = new SymbolTable();
-        fCurrentEntity = this;
-    }
-
-    /**
-     * Autodetects the encoding of the XML document supplied by the given
-     * input stream.
-     *
-     * Encoding autodetection is done according to the XML 1.0 specification,
-     * Appendix F.1: Detection Without External Encoding Information.
-     * @param fname The file name
-     * @param jar The containing jar
-     * @param ctxt The compilation context
-     * @param err The error dispatcher
-     * @return Two-element array, where the first element (of type
-     * java.lang.String) contains the name of the (auto)detected encoding, and
-     * the second element (of type java.lang.Boolean) specifies whether the
-     * encoding was specified using the 'encoding' attribute of an XML prolog
-     * (TRUE) or autodetected (FALSE).
-     * @throws IOException Error reading resource
-     * @throws JasperException Other error, usually a bad encoding
-     */
-    public static Object[] getEncoding(String fname, Jar jar,
-                                       JspCompilationContext ctxt,
-                                       ErrorDispatcher err)
-        throws IOException, JasperException
-    {
-        InputStream inStream = JspUtil.getInputStream(fname, jar, ctxt);
-        XMLEncodingDetector detector = new XMLEncodingDetector();
-        Object[] ret = detector.getEncoding(inStream, err);
-        inStream.close();
-
-        return ret;
-    }
-
-    private Object[] getEncoding(InputStream in, ErrorDispatcher err)
-        throws IOException, JasperException
-    {
-        this.stream = in;
-        this.err=err;
-        createInitialReader();
-        scanXMLDecl();
-
-        return new Object[] { this.encoding,
-                              Boolean.valueOf(this.isEncodingSetInProlog),
-                              Boolean.valueOf(this.isBomPresent),
-                              Integer.valueOf(this.skip) };
-    }
-
-    // stub method
-    void endEntity() {
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLEntityManager.startEntity()
-    private void createInitialReader() throws IOException, JasperException {
-
-        // wrap this stream in RewindableInputStream
-        stream = new RewindableInputStream(stream);
-
-        // perform auto-detect of encoding if necessary
-        if (encoding == null) {
-            // read first four bytes and determine encoding
-            final byte[] b4 = new byte[4];
-            int count = 0;
-            for (; count<4; count++ ) {
-                b4[count] = (byte)stream.read();
-            }
-            if (count == 4) {
-                Object [] encodingDesc = getEncodingName(b4, count);
-                encoding = (String)(encodingDesc[0]);
-                isBigEndian = (Boolean)(encodingDesc[1]);
-
-                if (encodingDesc.length > 3) {
-                    isBomPresent = ((Boolean)(encodingDesc[2])).booleanValue();
-                    skip = ((Integer)(encodingDesc[3])).intValue();
-                } else {
-                    isBomPresent = true;
-                    skip = ((Integer)(encodingDesc[2])).intValue();
-                }
-
-                stream.reset();
-                // Special case UTF-8 files with BOM created by Microsoft
-                // tools. It's more efficient to consume the BOM than make
-                // the reader perform extra checks. -Ac
-                if (encoding.equals("UTF-8")) {
-                    int b0 = b4[0] & 0xFF;
-                    int b1 = b4[1] & 0xFF;
-                    int b2 = b4[2] & 0xFF;
-                    if (b0 == 0xEF && b1 == 0xBB && b2 == 0xBF) {
-                        // ignore first three bytes...
-                        long skipped = stream.skip(3);
-                        if (skipped != 3) {
-                            throw new IOException(Localizer.getMessage(
-                                    "xmlParser.skipBomFail"));
-                        }
-                    }
-                }
-                reader = createReader(stream, encoding, isBigEndian);
-            } else {
-                reader = createReader(stream, encoding, isBigEndian);
-            }
-        }
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLEntityManager.createReader
-    /**
-     * Creates a reader capable of reading the given input stream in
-     * the specified encoding.
-     *
-     * @param inputStream  The input stream.
-     * @param encoding     The encoding name that the input stream is
-     *                     encoded using. If the user has specified that
-     *                     Java encoding names are allowed, then the
-     *                     encoding name may be a Java encoding name;
-     *                     otherwise, it is an ianaEncoding name.
-     * @param isBigEndian   For encodings (like uCS-4), whose names cannot
-     *                      specify a byte order, this tells whether the order
-     *                      is bigEndian. null means unknown or not relevant.
-     *
-     * @return Returns a reader.
-     * @throws IOException Error reading resource
-     * @throws JasperException Other error, usually a bad encoding
-     */
-    private Reader createReader(InputStream inputStream, String encoding,
-                                Boolean isBigEndian)
-                throws IOException, JasperException {
-
-        // normalize encoding name
-        if (encoding == null) {
-            encoding = "UTF-8";
-        }
-
-        // try to use an optimized reader
-        String ENCODING = encoding.toUpperCase(Locale.ENGLISH);
-        if (ENCODING.equals("UTF-8")) {
-            return new UTF8Reader(inputStream, fBufferSize);
-        }
-        if (ENCODING.equals("US-ASCII")) {
-            return new ASCIIReader(inputStream, fBufferSize);
-        }
-        if (ENCODING.equals("ISO-10646-UCS-4")) {
-            if (isBigEndian != null) {
-                boolean isBE = isBigEndian.booleanValue();
-                if (isBE) {
-                    return new UCSReader(inputStream, UCSReader.UCS4BE);
-                } else {
-                    return new UCSReader(inputStream, UCSReader.UCS4LE);
-                }
-            } else {
-                err.jspError("jsp.error.xml.encodingByteOrderUnsupported",
-                             encoding);
-            }
-        }
-        if (ENCODING.equals("ISO-10646-UCS-2")) {
-            if (isBigEndian != null) { // sould never happen with this encoding...
-                boolean isBE = isBigEndian.booleanValue();
-                if (isBE) {
-                    return new UCSReader(inputStream, UCSReader.UCS2BE);
-                } else {
-                    return new UCSReader(inputStream, UCSReader.UCS2LE);
-                }
-            } else {
-                err.jspError("jsp.error.xml.encodingByteOrderUnsupported",
-                             encoding);
-            }
-        }
-
-        // check for valid name
-        boolean validIANA = XMLChar.isValidIANAEncoding(encoding);
-        if (!validIANA) {
-            err.jspError("jsp.error.xml.encodingDeclInvalid", encoding);
-            // NOTE: AndyH suggested that, on failure, we use ISO Latin 1
-            //       because every byte is a valid ISO Latin 1 character.
-            //       It may not translate correctly but if we failed on
-            //       the encoding anyway, then we're expecting the content
-            //       of the document to be bad. This will just prevent an
-            //       invalid UTF-8 sequence to be detected. This is only
-            //       important when continue-after-fatal-error is turned
-            //       on. -Ac
-            encoding = "ISO-8859-1";
-        }
-
-        // try to use a Java reader
-        String javaEncoding = EncodingMap.getIANA2JavaMapping(ENCODING);
-        if (javaEncoding == null) {
-            err.jspError("jsp.error.xml.encodingDeclInvalid", encoding);
-            // see comment above.
-            javaEncoding = "ISO8859_1";
-        }
-        return new InputStreamReader(inputStream, javaEncoding);
-
-    } // createReader(InputStream,String, Boolean): Reader
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLEntityManager.getEncodingName
-    /**
-     * Returns the IANA encoding name that is auto-detected from
-     * the bytes specified, with the endian-ness of that encoding where
-     * appropriate.
-     *
-     * @param b4    The first four bytes of the input.
-     * @param count The number of bytes actually read.
-     * @return a 2-element array:  the first element, an IANA-encoding string,
-     *  the second element a Boolean which is true iff the document is big
-     *  endian, false if it's little-endian, and null if the distinction isn't
-     *  relevant.
-     */
-    private Object[] getEncodingName(byte[] b4, int count) {
-
-        if (count < 2) {
-            return new Object[]{"UTF-8", null, Boolean.FALSE, Integer.valueOf(0)};
-        }
-
-        // UTF-16, with BOM
-        int b0 = b4[0] & 0xFF;
-        int b1 = b4[1] & 0xFF;
-        if (b0 == 0xFE && b1 == 0xFF) {
-            // UTF-16, big-endian
-            return new Object [] {"UTF-16BE", Boolean.TRUE, Integer.valueOf(2)};
-        }
-        if (b0 == 0xFF && b1 == 0xFE) {
-            // UTF-16, little-endian
-            return new Object [] {"UTF-16LE", Boolean.FALSE, Integer.valueOf(2)};
-        }
-
-        // default to UTF-8 if we don't have enough bytes to make a
-        // good determination of the encoding
-        if (count < 3) {
-            return new Object [] {"UTF-8", null, Boolean.FALSE, Integer.valueOf(0)};
-        }
-
-        // UTF-8 with a BOM
-        int b2 = b4[2] & 0xFF;
-        if (b0 == 0xEF && b1 == 0xBB && b2 == 0xBF) {
-            return new Object [] {"UTF-8", null, Integer.valueOf(3)};
-        }
-
-        // default to UTF-8 if we don't have enough bytes to make a
-        // good determination of the encoding
-        if (count < 4) {
-            return new Object [] {"UTF-8", null, Integer.valueOf(0)};
-        }
-
-        // other encodings
-        int b3 = b4[3] & 0xFF;
-        if (b0 == 0x00 && b1 == 0x00 && b2 == 0x00 && b3 == 0x3C) {
-            // UCS-4, big endian (1234)
-            return new Object [] {"ISO-10646-UCS-4", Boolean.TRUE, Integer.valueOf(4)};
-        }
-        if (b0 == 0x3C && b1 == 0x00 && b2 == 0x00 && b3 == 0x00) {
-            // UCS-4, little endian (4321)
-            return new Object [] {"ISO-10646-UCS-4", Boolean.FALSE, Integer.valueOf(4)};
-        }
-        if (b0 == 0x00 && b1 == 0x00 && b2 == 0x3C && b3 == 0x00) {
-            // UCS-4, unusual octet order (2143)
-            // REVISIT: What should this be?
-            return new Object [] {"ISO-10646-UCS-4", null, Integer.valueOf(4)};
-        }
-        if (b0 == 0x00 && b1 == 0x3C && b2 == 0x00 && b3 == 0x00) {
-            // UCS-4, unusual octect order (3412)
-            // REVISIT: What should this be?
-            return new Object [] {"ISO-10646-UCS-4", null, Integer.valueOf(4)};
-        }
-        if (b0 == 0x00 && b1 == 0x3C && b2 == 0x00 && b3 == 0x3F) {
-            // UTF-16, big-endian, no BOM
-            // (or could turn out to be UCS-2...
-            // REVISIT: What should this be?
-            return new Object [] {"UTF-16BE", Boolean.TRUE, Integer.valueOf(4)};
-        }
-        if (b0 == 0x3C && b1 == 0x00 && b2 == 0x3F && b3 == 0x00) {
-            // UTF-16, little-endian, no BOM
-            // (or could turn out to be UCS-2...
-            return new Object [] {"UTF-16LE", Boolean.FALSE, Integer.valueOf(4)};
-        }
-        if (b0 == 0x4C && b1 == 0x6F && b2 == 0xA7 && b3 == 0x94) {
-            // EBCDIC
-            // a la xerces1, return CP037 instead of EBCDIC here
-            return new Object [] {"CP037", null, Integer.valueOf(4)};
-        }
-
-        // default encoding
-        return new Object [] {"UTF-8", null, Boolean.FALSE, Integer.valueOf(0)};
-
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLEntityManager.EntityScanner.isExternal
-    /**
-     * @return <code>true</code> if the current entity being scanned is external.
-     */
-    public boolean isExternal() {
-        return true;
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLEntityManager.EntityScanner.peekChar
-    /**
-     * Returns the next character on the input.
-     * <p>
-     * <strong>Note:</strong> The character is <em>not</em> consumed.
-     * @return the next char
-     * @throws IOException  Thrown if i/o error occurs.
-     * @throws EOFException Thrown on end of file.
-     */
-    public int peekChar() throws IOException {
-
-        // load more characters, if needed
-        if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
-        }
-
-        // peek at character
-        int c = fCurrentEntity.ch[fCurrentEntity.position];
-
-        // return peeked character
-        if (fCurrentEntity.isExternal()) {
-            return c != '\r' ? c : '\n';
-        }
-        else {
-            return c;
-        }
-
-    } // peekChar():int
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLEntityManager.EntityScanner.scanChar
-    /**
-     * Returns the next character on the input.
-     * <p>
-     * <strong>Note:</strong> The character is consumed.
-     * @return the next char
-     * @throws IOException  Thrown if i/o error occurs.
-     * @throws EOFException Thrown on end of file.
-     */
-    public int scanChar() throws IOException {
-
-        // load more characters, if needed
-        if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
-        }
-
-        // scan character
-        int c = fCurrentEntity.ch[fCurrentEntity.position++];
-        boolean external = false;
-        if (c == '\n' ||
-            (c == '\r' && (external = fCurrentEntity.isExternal()))) {
-            if (fCurrentEntity.position == fCurrentEntity.count) {
-                fCurrentEntity.ch[0] = (char)c;
-                load(1, false);
-            }
-            if (c == '\r' && external) {
-                if (fCurrentEntity.ch[fCurrentEntity.position++] != '\n') {
-                    fCurrentEntity.position--;
-                }
-                c = '\n';
-            }
-        }
-
-        // return character that was scanned
-        return c;
-
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLEntityManager.EntityScanner.scanName
-    /**
-     * Returns a string matching the Name production appearing immediately
-     * on the input as a symbol, or null if no Name string is present.
-     * <p>
-     * <strong>Note:</strong> The Name characters are consumed.
-     * <p>
-     * <strong>Note:</strong> The string returned must be a symbol. The
-     * SymbolTable can be used for this purpose.
-     * @return the name
-     * @throws IOException  Thrown if i/o error occurs.
-     * @throws EOFException Thrown on end of file.
-     *
-     * @see SymbolTable
-     * @see XMLChar#isName
-     * @see XMLChar#isNameStart
-     */
-    public String scanName() throws IOException {
-
-        // load more characters, if needed
-        if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
-        }
-
-        // scan name
-        int offset = fCurrentEntity.position;
-        if (XMLChar.isNameStart(fCurrentEntity.ch[offset])) {
-            if (++fCurrentEntity.position == fCurrentEntity.count) {
-                fCurrentEntity.ch[0] = fCurrentEntity.ch[offset];
-                offset = 0;
-                if (load(1, false)) {
-                    String symbol = fSymbolTable.addSymbol(fCurrentEntity.ch,
-                                                           0, 1);
-                    return symbol;
-                }
-            }
-            while (XMLChar.isName(fCurrentEntity.ch[fCurrentEntity.position])) {
-                if (++fCurrentEntity.position == fCurrentEntity.count) {
-                    int length = fCurrentEntity.position - offset;
-                    if (length == fBufferSize) {
-                        // bad luck we have to resize our buffer
-                        char[] tmp = new char[fBufferSize * 2];
-                        System.arraycopy(fCurrentEntity.ch, offset,
-                                         tmp, 0, length);
-                        fCurrentEntity.ch = tmp;
-                        fBufferSize *= 2;
-                    } else {
-                        System.arraycopy(fCurrentEntity.ch, offset,
-                                         fCurrentEntity.ch, 0, length);
-                    }
-                    offset = 0;
-                    if (load(length, false)) {
-                        break;
-                    }
-                }
-            }
-        }
-        int length = fCurrentEntity.position - offset;
-
-        // return name
-        String symbol = null;
-        if (length > 0) {
-            symbol = fSymbolTable.addSymbol(fCurrentEntity.ch, offset, length);
-        }
-        return symbol;
-
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLEntityManager.EntityScanner.scanLiteral
-    /**
-     * Scans a range of attribute value data, setting the fields of the
-     * XMLString structure, appropriately.
-     * <p>
-     * <strong>Note:</strong> The characters are consumed.
-     * <p>
-     * <strong>Note:</strong> This method does not guarantee to return
-     * the longest run of attribute value data. This method may return
-     * before the quote character due to reaching the end of the input
-     * buffer or any other reason.
-     * <p>
-     * <strong>Note:</strong> The fields contained in the XMLString
-     * structure are not guaranteed to remain valid upon subsequent calls
-     * to the entity scanner. Therefore, the caller is responsible for
-     * immediately using the returned character data or making a copy of
-     * the character data.
-     *
-     * @param quote   The quote character that signifies the end of the
-     *                attribute value data.
-     * @param content The content structure to fill.
-     *
-     * @return Returns the next character on the input, if known. This
-     *         value may be -1 but this does <em>note</em> designate
-     *         end of file.
-     *
-     * @throws IOException  Thrown if i/o error occurs.
-     * @throws EOFException Thrown on end of file.
-     */
-    public int scanLiteral(int quote, XMLString content)
-        throws IOException {
-
-        // load more characters, if needed
-        if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
-        } else if (fCurrentEntity.position == fCurrentEntity.count - 1) {
-            fCurrentEntity.ch[0] = fCurrentEntity.ch[fCurrentEntity.count - 1];
-            load(1, false);
-            fCurrentEntity.position = 0;
-        }
-
-        // normalize newlines
-        int offset = fCurrentEntity.position;
-        int c = fCurrentEntity.ch[offset];
-        int newlines = 0;
-        boolean external = fCurrentEntity.isExternal();
-        if (c == '\n' || (c == '\r' && external)) {
-            do {
-                c = fCurrentEntity.ch[fCurrentEntity.position++];
-                if (c == '\r' && external) {
-                    newlines++;
-                    if (fCurrentEntity.position == fCurrentEntity.count) {
-                        offset = 0;
-                        fCurrentEntity.position = newlines;
-                        if (load(newlines, false)) {
-                            break;
-                        }
-                    }
-                    if (fCurrentEntity.ch[fCurrentEntity.position] == '\n') {
-                        fCurrentEntity.position++;
-                        offset++;
-                    }
-                    /*** NEWLINE NORMALIZATION ***/
-                    else {
-                        newlines++;
-                    }
-                    /***/
-                }
-                else if (c == '\n') {
-                    newlines++;
-                    if (fCurrentEntity.position == fCurrentEntity.count) {
-                        offset = 0;
-                        fCurrentEntity.position = newlines;
-                        if (load(newlines, false)) {
-                            break;
-                        }
-                    }
-                    /*** NEWLINE NORMALIZATION ***
-                         if (fCurrentEntity.ch[fCurrentEntity.position] == '\r'
-                         && external) {
-                         fCurrentEntity.position++;
-                         offset++;
-                         }
-                         /***/
-                }
-                else {
-                    fCurrentEntity.position--;
-                    break;
-                }
-            } while (fCurrentEntity.position < fCurrentEntity.count - 1);
-            for (int i = offset; i < fCurrentEntity.position; i++) {
-                fCurrentEntity.ch[i] = '\n';
-            }
-            int length = fCurrentEntity.position - offset;
-            if (fCurrentEntity.position == fCurrentEntity.count - 1) {
-                content.setValues(fCurrentEntity.ch, offset, length);
-                return -1;
-            }
-        }
-
-        // scan literal value
-        while (fCurrentEntity.position < fCurrentEntity.count) {
-            c = fCurrentEntity.ch[fCurrentEntity.position++];
-            if (c == quote || c == '%' || !XMLChar.isContent(c)) {
-                fCurrentEntity.position--;
-                break;
-            }
-        }
-        int length = fCurrentEntity.position - offset;
-        content.setValues(fCurrentEntity.ch, offset, length);
-
-        // return next character
-        if (fCurrentEntity.position != fCurrentEntity.count) {
-            c = fCurrentEntity.ch[fCurrentEntity.position];
-        }
-        else {
-            c = -1;
-        }
-        return c;
-
-    }
-
-    /**
-     * Scans a range of character data up to the specified delimiter,
-     * setting the fields of the XMLString structure, appropriately.
-     * <p>
-     * <strong>Note:</strong> The characters are consumed.
-     * <p>
-     * <strong>Note:</strong> This assumes that the internal buffer is
-     * at least the same size, or bigger, than the length of the delimiter
-     * and that the delimiter contains at least one character.
-     * <p>
-     * <strong>Note:</strong> This method does not guarantee to return
-     * the longest run of character data. This method may return before
-     * the delimiter due to reaching the end of the input buffer or any
-     * other reason.
-     * <p>
-     * <strong>Note:</strong> The fields contained in the XMLString
-     * structure are not guaranteed to remain valid upon subsequent calls
-     * to the entity scanner. Therefore, the caller is responsible for
-     * immediately using the returned character data or making a copy of
-     * the character data.
-     *
-     * @param delimiter The string that signifies the end of the character
-     *                  data to be scanned.
-     * @param buffer    The data structure to fill.
-     *
-     * @return <code>true</code> if there is more data to scan,
-     *  <code>false</code> otherwise.
-     *
-     * @throws IOException  Thrown if i/o error occurs.
-     * @throws EOFException Thrown on end of file.
-     */
-    public boolean scanData(String delimiter, XMLStringBuffer buffer)
-        throws IOException {
-
-        boolean done = false;
-        int delimLen = delimiter.length();
-        char charAt0 = delimiter.charAt(0);
-        boolean external = fCurrentEntity.isExternal();
-        do {
-
-            // load more characters, if needed
-
-            if (fCurrentEntity.position == fCurrentEntity.count) {
-                load(0, true);
-            }
-            else if (fCurrentEntity.position >= fCurrentEntity.count - delimLen) {
-                System.arraycopy(fCurrentEntity.ch, fCurrentEntity.position,
-                                 fCurrentEntity.ch, 0, fCurrentEntity.count - fCurrentEntity.position);
-                load(fCurrentEntity.count - fCurrentEntity.position, false);
-                fCurrentEntity.position = 0;
-            }
-            if (fCurrentEntity.position >= fCurrentEntity.count - delimLen) {
-                // something must be wrong with the input: e.g., file ends an
-                // unterminated comment
-                int length = fCurrentEntity.count - fCurrentEntity.position;
-                buffer.append (fCurrentEntity.ch, fCurrentEntity.position,
-                               length);
-                fCurrentEntity.position = fCurrentEntity.count;
-                load(0,true);
-                return false;
-            }
-
-            // normalize newlines
-            int offset = fCurrentEntity.position;
-            int c = fCurrentEntity.ch[offset];
-            int newlines = 0;
-            if (c == '\n' || (c == '\r' && external)) {
-                do {
-                    c = fCurrentEntity.ch[fCurrentEntity.position++];
-                    if (c == '\r' && external) {
-                        newlines++;
-                        if (fCurrentEntity.position == fCurrentEntity.count) {
-                            offset = 0;
-                            fCurrentEntity.position = newlines;
-                            if (load(newlines, false)) {
-                                break;
-                            }
-                        }
-                        if (fCurrentEntity.ch[fCurrentEntity.position] == '\n') {
-                            fCurrentEntity.position++;
-                            offset++;
-                        }
-                        /*** NEWLINE NORMALIZATION ***/
-                        else {
-                            newlines++;
-                        }
-                    }
-                    else if (c == '\n') {
-                        newlines++;
-                        if (fCurrentEntity.position == fCurrentEntity.count) {
-                            offset = 0;
-                            fCurrentEntity.position = newlines;
-                            fCurrentEntity.count = newlines;
-                            if (load(newlines, false)) {
-                                break;
-                            }
-                        }
-                    }
-                    else {
-                        fCurrentEntity.position--;
-                        break;
-                    }
-                } while (fCurrentEntity.position < fCurrentEntity.count - 1);
-                for (int i = offset; i < fCurrentEntity.position; i++) {
-                    fCurrentEntity.ch[i] = '\n';
-                }
-                int length = fCurrentEntity.position - offset;
-                if (fCurrentEntity.position == fCurrentEntity.count - 1) {
-                    buffer.append(fCurrentEntity.ch, offset, length);
-                    return true;
-                }
-            }
-
-            // iterate over buffer looking for delimiter
-        OUTER: while (fCurrentEntity.position < fCurrentEntity.count) {
-            c = fCurrentEntity.ch[fCurrentEntity.position++];
-            if (c == charAt0) {
-                // looks like we just hit the delimiter
-                int delimOffset = fCurrentEntity.position - 1;
-                for (int i = 1; i < delimLen; i++) {
-                    if (fCurrentEntity.position == fCurrentEntity.count) {
-                        fCurrentEntity.position -= i;
-                        break OUTER;
-                    }
-                    c = fCurrentEntity.ch[fCurrentEntity.position++];
-                    if (delimiter.charAt(i) != c) {
-                        fCurrentEntity.position--;
-                        break;
-                    }
-                }
-                if (fCurrentEntity.position == delimOffset + delimLen) {
-                    done = true;
-                    break;
-                }
-            }
-            else if (c == '\n' || (external && c == '\r')) {
-                fCurrentEntity.position--;
-                break;
-            }
-            else if (XMLChar.isInvalid(c)) {
-                fCurrentEntity.position--;
-                int length = fCurrentEntity.position - offset;
-                buffer.append(fCurrentEntity.ch, offset, length);
-                return true;
-            }
-        }
-            int length = fCurrentEntity.position - offset;
-            if (done) {
-                length -= delimLen;
-            }
-            buffer.append (fCurrentEntity.ch, offset, length);
-
-            // return true if string was skipped
-        } while (!done);
-        return !done;
-
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLEntityManager.EntityScanner.skipChar
-    /**
-     * Skips a character appearing immediately on the input.
-     * <p>
-     * <strong>Note:</strong> The character is consumed only if it matches
-     * the specified character.
-     *
-     * @param c The character to skip.
-     *
-     * @return <code>true</code> if the character was skipped.
-     *
-     * @throws IOException  Thrown if i/o error occurs.
-     * @throws EOFException Thrown on end of file.
-     */
-    public boolean skipChar(int c) throws IOException {
-
-        // load more characters, if needed
-        if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
-        }
-
-        // skip character
-        int cc = fCurrentEntity.ch[fCurrentEntity.position];
-        if (cc == c) {
-            fCurrentEntity.position++;
-            return true;
-        } else if (c == '\n' && cc == '\r' && fCurrentEntity.isExternal()) {
-            // handle newlines
-            if (fCurrentEntity.position == fCurrentEntity.count) {
-                fCurrentEntity.ch[0] = (char)cc;
-                load(1, false);
-            }
-            fCurrentEntity.position++;
-            if (fCurrentEntity.ch[fCurrentEntity.position] == '\n') {
-                fCurrentEntity.position++;
-            }
-            return true;
-        }
-
-        // character was not skipped
-        return false;
-
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLEntityManager.EntityScanner.skipSpaces
-    /**
-     * Skips space characters appearing immediately on the input.
-     * <p>
-     * <strong>Note:</strong> The characters are consumed only if they are
-     * space characters.
-     *
-     * @return <code>true</code> if at least one space character was skipped.
-     *
-     * @throws IOException  Thrown if i/o error occurs.
-     * @throws EOFException Thrown on end of file.
-     *
-     * @see XMLChar#isSpace
-     */
-    public boolean skipSpaces() throws IOException {
-
-        // load more characters, if needed
-        if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
-        }
-
-        // skip spaces
-        int c = fCurrentEntity.ch[fCurrentEntity.position];
-        if (XMLChar.isSpace(c)) {
-            boolean external = fCurrentEntity.isExternal();
-            do {
-                boolean entityChanged = false;
-                // handle newlines
-                if (c == '\n' || (external && c == '\r')) {
-                    if (fCurrentEntity.position == fCurrentEntity.count - 1) {
-                        fCurrentEntity.ch[0] = (char)c;
-                        entityChanged = load(1, true);
-                        if (!entityChanged)
-                                // the load change the position to be 1,
-                                // need to restore it when entity not changed
-                            fCurrentEntity.position = 0;
-                    }
-                    if (c == '\r' && external) {
-                        // REVISIT: Does this need to be updated to fix the
-                        //          #x0D ^#x0A newline normalization problem? -Ac
-                        if (fCurrentEntity.ch[++fCurrentEntity.position] != '\n') {
-                            fCurrentEntity.position--;
-                        }
-                    }
-                    /*** NEWLINE NORMALIZATION ***
-                         else {
-                         if (fCurrentEntity.ch[fCurrentEntity.position + 1] == '\r'
-                         && external) {
-                         fCurrentEntity.position++;
-                         }
-                         }
-                         /***/
-                }
-                // load more characters, if needed
-                if (!entityChanged)
-                    fCurrentEntity.position++;
-                if (fCurrentEntity.position == fCurrentEntity.count) {
-                    load(0, true);
-                }
-            } while (XMLChar.isSpace(c = fCurrentEntity.ch[fCurrentEntity.position]));
-            return true;
-        }
-
-        // no spaces were found
-        return false;
-
-    }
-
-    /**
-     * Skips the specified string appearing immediately on the input.
-     * <p>
-     * <strong>Note:</strong> The characters are consumed only if they are
-     * space characters.
-     *
-     * @param s The string to skip.
-     *
-     * @return <code>true</code> if the string was skipped.
-     *
-     * @throws IOException  Thrown if i/o error occurs.
-     * @throws EOFException Thrown on end of file.
-     */
-    public boolean skipString(String s) throws IOException {
-
-        // load more characters, if needed
-        if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
-        }
-
-        // skip string
-        final int length = s.length();
-        for (int i = 0; i < length; i++) {
-            char c = fCurrentEntity.ch[fCurrentEntity.position++];
-            if (c != s.charAt(i)) {
-                fCurrentEntity.position -= i + 1;
-                return false;
-            }
-            if (i < length - 1 && fCurrentEntity.position == fCurrentEntity.count) {
-                System.arraycopy(fCurrentEntity.ch, fCurrentEntity.count - i - 1, fCurrentEntity.ch, 0, i + 1);
-                // REVISIT: Can a string to be skipped cross an
-                //          entity boundary? -Ac
-                if (load(i + 1, false)) {
-                    fCurrentEntity.position -= i + 1;
-                    return false;
-                }
-            }
-        }
-        return true;
-
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLEntityManager.EntityScanner.load
-    /**
-     * Loads a chunk of text.
-     *
-     * @param offset       The offset into the character buffer to
-     *                     read the next batch of characters.
-     * @param changeEntity True if the load should change entities
-     *                     at the end of the entity, otherwise leave
-     *                     the current entity in place and the entity
-     *                     boundary will be signaled by the return
-     *                     value.
-     *
-     * @return <code>true</code> if the entity changed as a result of this
-     *         load operation.
-     * @throws IOException Error reading data
-     */
-    final boolean load(int offset, boolean changeEntity)
-        throws IOException {
-
-        // read characters
-        int count = fCurrentEntity.reader.read(fCurrentEntity.ch, offset,
-                DEFAULT_XMLDECL_BUFFER_SIZE);
-
-        // reset count and position
-        boolean entityChanged = false;
-        if (count != -1) {
-            if (count != 0) {
-                fCurrentEntity.count = count + offset;
-                fCurrentEntity.position = offset;
-            }
-        }
-
-        // end of this entity
-        else {
-            fCurrentEntity.count = offset;
-            fCurrentEntity.position = offset;
-            entityChanged = true;
-            if (changeEntity) {
-                endEntity();
-                if (fCurrentEntity == null) {
-                    throw new EOFException();
-                }
-                // handle the trailing edges
-                if (fCurrentEntity.position == fCurrentEntity.count) {
-                    load(0, false);
-                }
-            }
-        }
-
-        return entityChanged;
-
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLEntityManager.RewindableInputStream
-    /**
-     * This class wraps the byte inputstreams we're presented with.
-     * We need it because java.io.InputStreams don't provide
-     * functionality to reread processed bytes, and they have a habit
-     * of reading more than one character when you call their read()
-     * methods.  This means that, once we discover the true (declared)
-     * encoding of a document, we can neither backtrack to read the
-     * whole doc again nor start reading where we are with a new
-     * reader.
-     *
-     * This class allows rewinding an inputStream by allowing a mark
-     * to be set, and the stream reset to that position.  <strong>The
-     * class assumes that it needs to read one character per
-     * invocation when it's read() method is invoked, but uses the
-     * underlying InputStream's read(char[], offset length) method--it
-     * won't buffer data read this way!</strong>
-     *
-     * @author Neil Graham, IBM
-     * @author Glenn Marcy, IBM
-     */
-    private static final class RewindableInputStream extends InputStream {
-
-        private InputStream fInputStream;
-        private byte[] fData;
-        private int fEndOffset;
-        private int fOffset;
-        private int fLength;
-        private int fMark;
-
-        public RewindableInputStream(InputStream is) {
-            fData = new byte[DEFAULT_XMLDECL_BUFFER_SIZE];
-            fInputStream = is;
-            fEndOffset = -1;
-            fOffset = 0;
-            fLength = 0;
-            fMark = 0;
-        }
-
-        @Override
-        public int read() throws IOException {
-            int b = 0;
-            if (fOffset < fLength) {
-                return fData[fOffset++] & 0xff;
-            }
-            if (fOffset == fEndOffset) {
-                return -1;
-            }
-            if (fOffset == fData.length) {
-                byte[] newData = new byte[fOffset << 1];
-                System.arraycopy(fData, 0, newData, 0, fOffset);
-                fData = newData;
-            }
-            b = fInputStream.read();
-            if (b == -1) {
-                fEndOffset = fOffset;
-                return -1;
-            }
-            fData[fLength++] = (byte)b;
-            fOffset++;
-            return b & 0xff;
-        }
-
-        @Override
-        public int read(byte[] b, int off, int len) throws IOException {
-            int bytesLeft = fLength - fOffset;
-            if (bytesLeft == 0) {
-                if (fOffset == fEndOffset) {
-                    return -1;
-                }
-                // better get some more for the voracious reader...
-                int returnedVal = read();
-                if (returnedVal == -1) {
-                    fEndOffset = fOffset;
-                    return -1;
-                }
-                b[off] = (byte)returnedVal;
-                return 1;
-            }
-            if (len < bytesLeft) {
-                if (len <= 0) {
-                    return 0;
-                }
-            }
-            else {
-                len = bytesLeft;
-            }
-            if (b != null) {
-                System.arraycopy(fData, fOffset, b, off, len);
-            }
-            fOffset += len;
-            return len;
-        }
-
-        @Override
-        public long skip(long n)
-            throws IOException
-        {
-            int bytesLeft;
-            if (n <= 0) {
-                return 0;
-            }
-            bytesLeft = fLength - fOffset;
-            if (bytesLeft == 0) {
-                if (fOffset == fEndOffset) {
-                    return 0;
-                }
-                return fInputStream.skip(n);
-            }
-            if (n <= bytesLeft) {
-                fOffset += n;
-                return n;
-            }
-            fOffset += bytesLeft;
-            if (fOffset == fEndOffset) {
-                return bytesLeft;
-            }
-            n -= bytesLeft;
-            /*
-             * In a manner of speaking, when this class isn't permitting more
-             * than one byte at a time to be read, it is "blocking".  The
-             * available() method should indicate how much can be read without
-             * blocking, so while we're in this mode, it should only indicate
-             * that bytes in its buffer are available; otherwise, the result of
-             * available() on the underlying InputStream is appropriate.
-             */
-            return fInputStream.skip(n) + bytesLeft;
-        }
-
-        @Override
-        public int available() throws IOException {
-            int bytesLeft = fLength - fOffset;
-            if (bytesLeft == 0) {
-                if (fOffset == fEndOffset) {
-                    return -1;
-                }
-                return 0;
-            }
-            return bytesLeft;
-        }
-
-        @Override
-        public synchronized void mark(int howMuch) {
-            fMark = fOffset;
-        }
-
-        @Override
-        public synchronized void reset() {
-            fOffset = fMark;
-        }
-
-        @Override
-        public boolean markSupported() {
-            return true;
-        }
-
-        @Override
-        public void close() throws IOException {
-            if (fInputStream != null) {
-                fInputStream.close();
-                fInputStream = null;
-            }
-        }
-    } // end of RewindableInputStream class
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLDocumentScannerImpl.dispatch
-    private void scanXMLDecl() throws IOException, JasperException {
-
-        if (skipString("<?xml")) {
-            // NOTE: special case where document starts with a PI
-            //       whose name starts with "xml" (e.g. "xmlfoo")
-            if (XMLChar.isName(peekChar())) {
-                fStringBuffer.clear();
-                fStringBuffer.append("xml");
-                while (XMLChar.isName(peekChar())) {
-                    fStringBuffer.append((char)scanChar());
-                }
-                String target = fSymbolTable.addSymbol(fStringBuffer.ch,
-                                                       fStringBuffer.offset,
-                                                       fStringBuffer.length);
-                scanPIData(target, fString);
-            }
-
-            // standard XML declaration
-            else {
-                scanXMLDeclOrTextDecl(false);
-            }
-        }
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanXMLDeclOrTextDecl
-    /**
-     * Scans an XML or text declaration.
-     * <p>
-     * <pre>
-     * [23] XMLDecl ::= '&lt;?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
-     * [24] VersionInfo ::= S 'version' Eq (' VersionNum ' | " VersionNum ")
-     * [80] EncodingDecl ::= S 'encoding' Eq ('"' EncName '"' |  "'" EncName "'" )
-     * [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
-     * [32] SDDecl ::= S 'standalone' Eq (("'" ('yes' | 'no') "'")
-     *                 | ('"' ('yes' | 'no') '"'))
-     *
-     * [77] TextDecl ::= '&lt;?xml' VersionInfo? EncodingDecl S? '?>'
-     * </pre>
-     *
-     * @param scanningTextDecl True if a text declaration is to
-     *                         be scanned instead of an XML
-     *                         declaration.
-     * @throws IOException Error reading data
-     * @throws JasperException Other error
-     */
-    private void scanXMLDeclOrTextDecl(boolean scanningTextDecl)
-        throws IOException, JasperException {
-
-        // scan decl
-        scanXMLDeclOrTextDecl(scanningTextDecl, fStrings);
-
-        // pseudo-attribute values
-        String encodingPseudoAttr = fStrings[1];
-
-        // set encoding on reader
-        if (encodingPseudoAttr != null) {
-            isEncodingSetInProlog = true;
-            encoding = encodingPseudoAttr;
-        }
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLScanner.scanXMLDeclOrTextDecl
-    /**
-     * Scans an XML or text declaration.
-     * <p>
-     * <pre>
-     * [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
-     * [24] VersionInfo ::= S 'version' Eq (' VersionNum ' | " VersionNum ")
-     * [80] EncodingDecl ::= S 'encoding' Eq ('"' EncName '"' |  "'" EncName "'" )
-     * [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
-     * [32] SDDecl ::= S 'standalone' Eq (("'" ('yes' | 'no') "'")
-     *                 | ('"' ('yes' | 'no') '"'))
-     *
-     * [77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'
-     * </pre>
-     *
-     * <strong>Note:</strong> This method uses fString, anything in it
-     * at the time of calling is lost.
-     * @param scanningTextDecl True if a text declaration is to
-     *                         be scanned instead of an XML
-     *                         declaration.
-     * @param pseudoAttributeValues An array of size 3 to return the version,
-     *                         encoding and standalone pseudo attribute values
-     *                         (in that order).
-     *
-     * @throws IOException Error reading data
-     * @throws JasperException Other error
-     */
-    private void scanXMLDeclOrTextDecl(boolean scanningTextDecl,
-                                       String[] pseudoAttributeValues)
-                throws IOException, JasperException {
-
-        // pseudo-attribute values
-        String version = null;
-        String encoding = null;
-        String standalone = null;
-
-        // scan pseudo-attributes
-        final int STATE_VERSION = 0;
-        final int STATE_ENCODING = 1;
-        final int STATE_STANDALONE = 2;
-        final int STATE_DONE = 3;
-        int state = STATE_VERSION;
-
-        boolean dataFoundForTarget = false;
-        boolean sawSpace = skipSpaces();
-        while (peekChar() != '?') {
-            dataFoundForTarget = true;
-            String name = scanPseudoAttribute(scanningTextDecl, fString);
-            switch (state) {
-                case STATE_VERSION: {
-                    if (name == fVersionSymbol) {
-                        if (!sawSpace) {
-                            reportFatalError(scanningTextDecl
-                                       ? "jsp.error.xml.spaceRequiredBeforeVersionInTextDecl"
-                                       : "jsp.error.xml.spaceRequiredBeforeVersionInXMLDecl",
-                                             null);
-                        }
-                        version = fString.toString();
-                        state = STATE_ENCODING;
-                        if (!version.equals("1.0")) {
-                            // REVISIT: XML REC says we should throw an error
-                            // in such cases.
-                            // some may object the throwing of fatalError.
-                            err.jspError("jsp.error.xml.versionNotSupported",
-                                         version);
-                        }
-                    } else if (name == fEncodingSymbol) {
-                        if (!scanningTextDecl) {
-                            err.jspError("jsp.error.xml.versionInfoRequired");
-                        }
-                        if (!sawSpace) {
-                            reportFatalError(scanningTextDecl
-                                      ? "jsp.error.xml.spaceRequiredBeforeEncodingInTextDecl"
-                                      : "jsp.error.xml.spaceRequiredBeforeEncodingInXMLDecl",
-                                             null);
-                        }
-                        encoding = fString.toString();
-                        state = scanningTextDecl ? STATE_DONE : STATE_STANDALONE;
-                    } else {
-                        if (scanningTextDecl) {
-                            err.jspError("jsp.error.xml.encodingDeclRequired");
-                        }
-                        else {
-                            err.jspError("jsp.error.xml.versionInfoRequired");
-                        }
-                    }
-                    break;
-                }
-                case STATE_ENCODING: {
-                    if (name == fEncodingSymbol) {
-                        if (!sawSpace) {
-                            reportFatalError(scanningTextDecl
-                                      ? "jsp.error.xml.spaceRequiredBeforeEncodingInTextDecl"
-                                      : "jsp.error.xml.spaceRequiredBeforeEncodingInXMLDecl",
-                                             null);
-                        }
-                        encoding = fString.toString();
-                        state = scanningTextDecl ? STATE_DONE : STATE_STANDALONE;
-                        // TODO: check encoding name; set encoding on
-                        //       entity scanner
-                    } else if (!scanningTextDecl && name == fStandaloneSymbol) {
-                        if (!sawSpace) {
-                            err.jspError("jsp.error.xml.spaceRequiredBeforeStandalone");
-                        }
-                        standalone = fString.toString();
-                        state = STATE_DONE;
-                        if (!standalone.equals("yes") && !standalone.equals("no")) {
-                            err.jspError("jsp.error.xml.sdDeclInvalid");
-                        }
-                    } else {
-                        err.jspError("jsp.error.xml.encodingDeclRequired");
-                    }
-                    break;
-                }
-                case STATE_STANDALONE: {
-                    if (name == fStandaloneSymbol) {
-                        if (!sawSpace) {
-                            err.jspError("jsp.error.xml.spaceRequiredBeforeStandalone");
-                        }
-                        standalone = fString.toString();
-                        state = STATE_DONE;
-                        if (!standalone.equals("yes") && !standalone.equals("no")) {
-                            err.jspError("jsp.error.xml.sdDeclInvalid");
-                        }
-                    } else {
-                        err.jspError("jsp.error.xml.encodingDeclRequired");
-                    }
-                    break;
-                }
-                default: {
-                    err.jspError("jsp.error.xml.noMorePseudoAttributes");
-                }
-            }
-            sawSpace = skipSpaces();
-        }
-        // REVISIT: should we remove this error reporting?
-        if (scanningTextDecl && state != STATE_DONE) {
-            err.jspError("jsp.error.xml.morePseudoAttributes");
-        }
-
-        // If there is no data in the xml or text decl then we fail to report
-        // error for version or encoding info above.
-        if (scanningTextDecl) {
-            if (!dataFoundForTarget && encoding == null) {
-                err.jspError("jsp.error.xml.encodingDeclRequired");
-            }
-        } else {
-            if (!dataFoundForTarget && version == null) {
-                err.jspError("jsp.error.xml.versionInfoRequired");
-            }
-        }
-
-        // end
-        if (!skipChar('?')) {
-            err.jspError("jsp.error.xml.xmlDeclUnterminated");
-        }
-        if (!skipChar('>')) {
-            err.jspError("jsp.error.xml.xmlDeclUnterminated");
-
-        }
-
-        // fill in return array
-        pseudoAttributeValues[0] = version;
-        pseudoAttributeValues[1] = encoding;
-        pseudoAttributeValues[2] = standalone;
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLScanner.scanPseudoAttribute
-    /**
-     * Scans a pseudo attribute.
-     *
-     * <strong>Note:</strong> This method uses fStringBuffer2, anything in it
-     * at the time of calling is lost.
-     * @param scanningTextDecl True if scanning this pseudo-attribute for a
-     *                         TextDecl; false if scanning XMLDecl. This
-     *                         flag is needed to report the correct type of
-     *                         error.
-     * @param value            The string to fill in with the attribute
-     *                         value.
-     *
-     * @return The name of the attribute
-     * @throws IOException Error reading data
-     * @throws JasperException Other error
-     */
-    public String scanPseudoAttribute(boolean scanningTextDecl,
-                                      XMLString value)
-                throws IOException, JasperException {
-
-        String name = scanName();
-        if (name == null) {
-            err.jspError("jsp.error.xml.pseudoAttrNameExpected");
-        }
-        skipSpaces();
-        if (!skipChar('=')) {
-            reportFatalError(scanningTextDecl ?
-                             "jsp.error.xml.eqRequiredInTextDecl"
-                             : "jsp.error.xml.eqRequiredInXMLDecl",
-                             name);
-        }
-        skipSpaces();
-        int quote = peekChar();
-        if (quote != '\'' && quote != '"') {
-            reportFatalError(scanningTextDecl ?
-                             "jsp.error.xml.quoteRequiredInTextDecl"
-                             : "jsp.error.xml.quoteRequiredInXMLDecl" ,
-                             name);
-        }
-        scanChar();
-        int c = scanLiteral(quote, value);
-        if (c != quote) {
-            fStringBuffer2.clear();
-            do {
-                fStringBuffer2.append(value);
-                if (c != -1) {
-                    if (c == '&' || c == '%' || c == '<' || c == ']') {
-                        fStringBuffer2.append((char)scanChar());
-                    }
-                    else if (XMLChar.isHighSurrogate(c)) {
-                        scanSurrogates(fStringBuffer2);
-                    }
-                    else if (XMLChar.isInvalid(c)) {
-                        String key = scanningTextDecl
-                            ? "jsp.error.xml.invalidCharInTextDecl"
-                            : "jsp.error.xml.invalidCharInXMLDecl";
-                        reportFatalError(key, Integer.toString(c, 16));
-                        scanChar();
-                    }
-                }
-                c = scanLiteral(quote, value);
-            } while (c != quote);
-            fStringBuffer2.append(value);
-            value.setValues(fStringBuffer2);
-        }
-        if (!skipChar(quote)) {
-            reportFatalError(scanningTextDecl ?
-                             "jsp.error.xml.closeQuoteMissingInTextDecl"
-                             : "jsp.error.xml.closeQuoteMissingInXMLDecl",
-                             name);
-        }
-
-        // return
-        return name;
-
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLScanner.scanPIData
-    /**
-     * Scans a processing data. This is needed to handle the situation
-     * where a document starts with a processing instruction whose
-     * target name <em>starts with</em> "xml". (e.g. xmlfoo)
-     *
-     * <strong>Note:</strong> This method uses fStringBuffer, anything in it
-     * at the time of calling is lost.
-     *
-     * @param target The PI target
-     * @param data The string to fill in with the data
-     * @throws IOException Error reading data
-     * @throws JasperException Other error
-     */
-    private void scanPIData(String target, XMLString data)
-        throws IOException, JasperException {
-
-        // check target
-        if (target.length() == 3) {
-            char c0 = Character.toLowerCase(target.charAt(0));
-            char c1 = Character.toLowerCase(target.charAt(1));
-            char c2 = Character.toLowerCase(target.charAt(2));
-            if (c0 == 'x' && c1 == 'm' && c2 == 'l') {
-                err.jspError("jsp.error.xml.reservedPITarget");
-            }
-        }
-
-        // spaces
-        if (!skipSpaces()) {
-            if (skipString("?>")) {
-                // we found the end, there is no data
-                data.clear();
-                return;
-            }
-            else {
-                // if there is data there should be some space
-                err.jspError("jsp.error.xml.spaceRequiredInPI");
-            }
-        }
-
-        fStringBuffer.clear();
-        // data
-        if (scanData("?>", fStringBuffer)) {
-            do {
-                int c = peekChar();
-                if (c != -1) {
-                    if (XMLChar.isHighSurrogate(c)) {
-                        scanSurrogates(fStringBuffer);
-                    } else if (XMLChar.isInvalid(c)) {
-                        err.jspError("jsp.error.xml.invalidCharInPI",
-                                     Integer.toHexString(c));
-                        scanChar();
-                    }
-                }
-            } while (scanData("?>", fStringBuffer));
-        }
-        data.setValues(fStringBuffer);
-
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLScanner.scanSurrogates
-    /**
-     * Scans surrogates and append them to the specified buffer.
-     * <p>
-     * <strong>Note:</strong> This assumes the current char has already been
-     * identified as a high surrogate.
-     *
-     * @param buf The StringBuffer to append the read surrogates to.
-     * @return <code>true</code> if it succeeded.
-     * @throws IOException Error reading data
-     * @throws JasperException Other error
-     */
-    private boolean scanSurrogates(XMLStringBuffer buf)
-        throws IOException, JasperException {
-
-        int high = scanChar();
-        int low = peekChar();
-        if (!XMLChar.isLowSurrogate(low)) {
-            err.jspError("jsp.error.xml.invalidCharInContent",
-                         Integer.toString(high, 16));
-            return false;
-        }
-        scanChar();
-
-        // convert surrogates to supplemental character
-        int c = XMLChar.supplemental((char)high, (char)low);
-
-        // supplemental character must be a valid XML character
-        if (!XMLChar.isValid(c)) {
-            err.jspError("jsp.error.xml.invalidCharInContent",
-                         Integer.toString(c, 16));
-            return false;
-        }
-
-        // fill in the buffer
-        buf.append((char)high);
-        buf.append((char)low);
-
-        return true;
-
-    }
-
-    // Adapted from:
-    // org.apache.xerces.impl.XMLScanner.reportFatalError
-    /**
-     * Convenience function used in all XML scanners.
-     * @param msgId The message key
-     * @param arg The argument
-     * @throws JasperException The created exception
-     */
-    private void reportFatalError(String msgId, String arg)
-                throws JasperException {
-        err.jspError(msgId, arg);
-    }
-
-}
-
-

==================================================
XMLStringBuffer.java
deleted file mode 100644
index ee22890eed..0000000000
--- a/java/org/apache/jasper/xmlparser/XMLString.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation and was
- * originally based on software copyright (c) 1999, International
- * Business Machines, Inc., http://www.apache.org.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- */
-
-package org.apache.jasper.xmlparser;
-
-/**
- * This class is used as a structure to pass text contained in the underlying
- * character buffer of the scanner. The offset and length fields allow the
- * buffer to be re-used without creating new character arrays.
- * <p>
- * <strong>Note:</strong> Methods that are passed an XMLString structure
- * should consider the contents read-only and not make any modifications
- * to the contents of the buffer. The method receiving this structure
- * should also not modify the offset and length if this structure (or
- * the values of this structure) are passed to another method.
- * <p>
- * <strong>Note:</strong> Methods that are passed an XMLString structure
- * are required to copy the information out of the buffer if it is to be
- * saved for use beyond the scope of the method. The contents of the
- * structure are volatile and the contents of the character buffer cannot
- * be assured once the method that is passed this structure returns.
- * Therefore, methods passed this structure should not save any reference
- * to the structure or the character array contained in the structure.
- *
- * @author Eric Ye, IBM
- * @author Andy Clark, IBM
- *
- * @deprecated Will be removed in Tomcat 9.0.x onwards
- */
-@Deprecated
-public class XMLString {
-
-    //
-    // Data
-    //
-
-    /**
-     * The character array.
-     */
-    public char[] ch;
-
-    /**
-     * The offset into the character array.
-     */
-    public int offset;
-
-    /**
-     * The length of characters from the offset.
-     */
-    public int length;
-
-    //
-    // Constructors
-    //
-
-    /**
-     * Default constructor.
-     */
-    public XMLString() {
-    } // <init>()
-
-    //
-    // Public methods
-    //
-
-    /**
-     * Initializes the contents of the XMLString structure with the
-     * specified values.
-     *
-     * @param ch     The character array.
-     * @param offset The offset into the character array.
-     * @param length The length of characters from the offset.
-     */
-    public void setValues(char[] ch, int offset, int length) {
-        this.ch = ch;
-        this.offset = offset;
-        this.length = length;
-    } // setValues(char[],int,int)
-
-    /**
-     * Initializes the contents of the XMLString structure with copies
-     * of the given string structure.
-     * <p>
-     * <strong>Note:</strong> This does not copy the character array;
-     * only the reference to the array is copied.
-     *
-     * @param s The string
-     */
-    public void setValues(XMLString s) {
-        setValues(s.ch, s.offset, s.length);
-    } // setValues(XMLString)
-
-    /**
-     * Resets all of the values to their defaults.
-     */
-    public void clear() {
-        this.ch = null;
-        this.offset = 0;
-        this.length = -1;
-    } // clear()
-
-
-    /**
-     * Returns true if the contents of this XMLString structure and
-     * the specified string are equal.
-     *
-     * @param s The string to compare.
-     * @return <code>true</code> if equal
-     */
-    public boolean equals(String s) {
-        if (s == null) {
-            return false;
-        }
-        if ( length != s.length() ) {
-            return false;
-        }
-
-        // is this faster than call s.toCharArray first and compare the
-        // two arrays directly, which will possibly involve creating a
-        // new char array object.
-        for (int i=0; i<length; i++) {
-            if (ch[offset+i] != s.charAt(i)) {
-                return false;
-            }
-        }
-
-        return true;
-    } // equals(String):boolean
-
-    //
-    // Object methods
-    //
-
-    @Override
-    public String toString() {
-        return length > 0 ? new String(ch, offset, length) : "";
-    } // toString():String
-
-} // class XMLString

==================================================
