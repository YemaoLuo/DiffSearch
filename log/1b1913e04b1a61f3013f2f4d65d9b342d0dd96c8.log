1b1913e04b1a61f3013f2f4d65d9b342d0dd96c8
==================================================
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=53367
==================================================
Filip Hanik
==================================================
Thu Jul 24 13:42:38 2014 +0000
==================================================
FairBlockingQueue.java
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=53367
Properly handle interrupts in the FairBlockingQueue

https://issues.apache.org/bugzilla/show_bug.cgi?id=53367

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1613123 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Bug53367.java
index 9e553b348f..dd63c6948f 100644
--- a/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java
+++ b/modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java
@@ -133,9 +133,9 @@ public class FairBlockingQueue<E> implements BlockingQueue<E> {
     public E poll(long timeout, TimeUnit unit) throws InterruptedException {
         E result = null;
         final ReentrantLock lock = this.lock;
+        //acquire the global lock until we know what to do
+        lock.lock();
         try {
-            //acquire the global lock until we know what to do
-            lock.lock();
             //check to see if we have objects
             result = items.poll();
             if (result==null && timeout>0) {
@@ -145,15 +145,36 @@ public class FairBlockingQueue<E> implements BlockingQueue<E> {
                 waiters.addLast(c);
                 //unlock the global lock
                 lock.unlock();
-                //wait for the specified timeout
-                if (!c.await(timeout, unit)) {
-                    //if we timed out, remove ourselves from the waitlist
+                boolean didtimeout = false;
+                InterruptedException interruptedException = null;
+                try {
+                    //wait for the specified timeout
+                    didtimeout = !c.await(timeout, unit);
+                } catch (InterruptedException ix) {
+                    interruptedException = ix;
+                }
+                if (didtimeout) {
+                    //if we timed out, or got interrupted
+                    // remove ourselves from the waitlist
                     lock.lock();
-                    waiters.remove(c);
-                    lock.unlock();
+                    try {
+                        waiters.remove(c);
+                    } finally {
+                        lock.unlock();
+                    }
                 }
                 //return the item we received, can be null if we timed out
                 result = c.getItem();
+                if (null!=interruptedException) {
+                    //we got interrupted
+                    if ( null!=result) {
+                        //we got a result - clear the interrupt status
+                        //don't propagate cause we have removed a connection from pool
+                        Thread.interrupted();
+                    } else {
+                        throw interruptedException;
+                    }
+                } 
             } else {
                 //we have an object, release
                 lock.unlock();
@@ -173,20 +194,20 @@ public class FairBlockingQueue<E> implements BlockingQueue<E> {
     public Future<E> pollAsync() {
         Future<E> result = null;
         final ReentrantLock lock = this.lock;
+        //grab the global lock
+        lock.lock();
         try {
-            //grab the global lock
-            lock.lock();
             //check to see if we have objects in the queue
             E item = items.poll();
             if (item==null) {
                 //queue is empty, add ourselves as waiters
-                ExchangeCountDownLatch<E> c = new ExchangeCountDownLatch<>(1);
+                ExchangeCountDownLatch<E> c = new ExchangeCountDownLatch<E>(1);
                 waiters.addLast(c);
                 //return a future that will wait for the object
-                result = new ItemFuture<>(c);
+                result = new ItemFuture<E>(c);
             } else {
                 //return a future with the item
-                result = new ItemFuture<>(item);
+                result = new ItemFuture<E>(item);
             }
         } finally {
             lock.unlock();

==================================================
