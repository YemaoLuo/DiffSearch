fb2d54a74db5e4024ddc1db0f00ff97a23297eab
==================================================
Complete alignment of request attribute actions.
==================================================
Mark Thomas
==================================================
Fri Aug 12 07:46:37 2016 +0000
==================================================
AjpProcessor.java
Complete alignment of request attribute actions.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1756094 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http11Processor.java
index b9ad487823..693d8dfba9 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -423,44 +423,37 @@ public class AjpProcessor extends AbstractProcessor {
 
         // Request attribute support
         case REQ_HOST_ADDR_ATTRIBUTE: {
-            // NO-OP
-            // Automatically populated during prepareRequest()
+            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
+                request.remoteAddr().setString(socketWrapper.getRemoteAddr());
+            }
             break;
         }
         case REQ_HOST_ATTRIBUTE: {
-            // Get remote host name using a DNS resolution
-            if (request.remoteHost().isNull()) {
-                try {
-                    request.remoteHost().setString(InetAddress.getByName
-                            (request.remoteAddr().toString()).getHostName());
-                } catch (IOException iex) {
-                    // Ignore
-                }
-            }
+            populateRequestAttributeRemoteHost();
             break;
         }
         case REQ_LOCALPORT_ATTRIBUTE: {
-            // NO-OP
-            // Automatically populated during prepareRequest()
+            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
+                request.setLocalPort(socketWrapper.getLocalPort());
+            }
             break;
         }
         case REQ_LOCAL_ADDR_ATTRIBUTE: {
-            // Automatically populated during prepareRequest() when using
-            // modern AJP forwarder, otherwise copy from local name
-            if (request.localAddr().isNull()) {
-                request.localAddr().setString(request.localName().toString());
+            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
+                request.localAddr().setString(socketWrapper.getLocalAddr());
             }
             break;
         }
         case REQ_LOCAL_NAME_ATTRIBUTE: {
-            // NO-OP
-            // Automatically populated during prepareRequest()
+            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
+                request.localName().setString(socketWrapper.getLocalName());
+            }
             break;
         }
         case REQ_REMOTEPORT_ATTRIBUTE: {
-            // NO-OP
-            // Automatically populated during prepareRequest() when using
-            // modern AJP forwarder, otherwise not available
+            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
+                request.setRemotePort(socketWrapper.getRemotePort());
+            }
             break;
         }
 
@@ -1484,6 +1477,26 @@ public class AjpProcessor extends AbstractProcessor {
     }
     
     
+    private boolean getPopulateRequestAttributesFromSocket() {
+        // NO-OPs the attribute requests since they are pre-populated when
+        // parsing the first AJP message.
+        return false;
+    }
+
+    
+    private void populateRequestAttributeRemoteHost() {
+        // Get remote host name using a DNS resolution
+        if (request.remoteHost().isNull()) {
+            try {
+                request.remoteHost().setString(InetAddress.getByName
+                        (request.remoteAddr().toString()).getHostName());
+            } catch (IOException iex) {
+                // Ignore
+            }
+        }
+    }
+    
+    
     /**
      * Read at least the specified amount of bytes, and place them
      * in the input buffer. Note that if any data is available to read then this

==================================================
StreamProcessor.java
index c4c1b1e376..f583c22f06 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -716,37 +716,35 @@ public class Http11Processor extends AbstractProcessor {
 
         // Request attribute support
         case REQ_HOST_ADDR_ATTRIBUTE: {
-            if (socketWrapper != null) {
+            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
                 request.remoteAddr().setString(socketWrapper.getRemoteAddr());
             }
             break;
         }
         case REQ_HOST_ATTRIBUTE: {
-            if (socketWrapper != null) {
-                request.remoteHost().setString(socketWrapper.getRemoteHost());
-            }
+            populateRequestAttributeRemoteHost();
             break;
         }
         case REQ_LOCALPORT_ATTRIBUTE: {
-            if (socketWrapper != null) {
+            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
                 request.setLocalPort(socketWrapper.getLocalPort());
             }
             break;
         }
         case REQ_LOCAL_ADDR_ATTRIBUTE: {
-            if (socketWrapper != null) {
+            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
                 request.localAddr().setString(socketWrapper.getLocalAddr());
             }
             break;
         }
         case REQ_LOCAL_NAME_ATTRIBUTE: {
-            if (socketWrapper != null) {
+            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
                 request.localName().setString(socketWrapper.getLocalName());
             }
             break;
         }
         case REQ_REMOTEPORT_ATTRIBUTE: {
-            if (socketWrapper != null) {
+            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
                 request.setRemotePort(socketWrapper.getRemotePort());
             }
             break;
@@ -1815,6 +1813,18 @@ public class Http11Processor extends AbstractProcessor {
     }
     
     
+    private boolean getPopulateRequestAttributesFromSocket() {
+        return true;
+    }
+    
+    
+    private void populateRequestAttributeRemoteHost() {
+        if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
+            request.remoteHost().setString(socketWrapper.getRemoteHost());
+        }
+    }
+    
+    
     /**
      * Checks to see if the keep-alive loop should be broken, performing any
      * processing (e.g. sendfile handling) that may have an impact on whether

==================================================
