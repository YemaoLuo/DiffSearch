c1bbb10e73a110bafbf311017540dcdb4f53ec58
==================================================
Remove java.io based sender and receiver
==================================================
remm remm@apache.org
==================================================
Wed Apr 29 17:03:41 2020 +0200
==================================================
BioReceiver.java
Remove java.io based sender and receiver

It's unlikely they are still used as they were not the default
configuration.


==================================================
BioReplicationTask.java
deleted file mode 100644
index 3214ab58bb..0000000000
--- a/java/org/apache/catalina/tribes/transport/bio/BioReceiver.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.tribes.transport.bio;
-
-import java.io.IOException;
-import java.net.ServerSocket;
-import java.net.Socket;
-
-import org.apache.catalina.tribes.io.ObjectReader;
-import org.apache.catalina.tribes.transport.AbstractRxTask;
-import org.apache.catalina.tribes.transport.ReceiverBase;
-import org.apache.catalina.tribes.transport.RxTaskPool;
-import org.apache.catalina.tribes.util.StringManager;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-
-public class BioReceiver extends ReceiverBase implements Runnable {
-
-    private static final Log log = LogFactory.getLog(BioReceiver.class);
-
-    protected static final StringManager sm = StringManager.getManager(BioReceiver.class);
-
-    protected ServerSocket serverSocket;
-
-    public BioReceiver() {
-        // NO-OP
-    }
-
-    @Override
-    public void start() throws IOException {
-        super.start();
-        try {
-            setPool(new RxTaskPool(getMaxThreads(),getMinThreads(),this));
-        } catch (Exception x) {
-            log.fatal(sm.getString("bioReceiver.threadpool.fail"), x);
-            if ( x instanceof IOException ) throw (IOException)x;
-            else throw new IOException(x.getMessage());
-        }
-        try {
-            getBind();
-            bind();
-            String channelName = "";
-            if (getChannel().getName() != null) channelName = "[" + getChannel().getName() + "]";
-            Thread t = new Thread(this, "BioReceiver" + channelName);
-            t.setDaemon(true);
-            t.start();
-        } catch (Exception x) {
-            log.fatal(sm.getString("bioReceiver.start.fail"), x);
-            if ( x instanceof IOException ) throw (IOException)x;
-            else throw new IOException(x.getMessage());
-        }
-    }
-
-    @Override
-    public AbstractRxTask createRxTask() {
-        return getReplicationThread();
-    }
-
-    protected BioReplicationTask getReplicationThread() {
-        BioReplicationTask result = new BioReplicationTask(this);
-        result.setOptions(getWorkerThreadOptions());
-        result.setUseBufferPool(this.getUseBufferPool());
-        return result;
-    }
-
-    @Override
-    public void stop() {
-        setListen(false);
-        try {
-            this.serverSocket.close();
-        } catch (Exception x) {
-            if (log.isDebugEnabled()) {
-                log.debug(sm.getString("bioReceiver.socket.closeFailed"), x);
-            }
-        }
-        super.stop();
-    }
-
-
-    protected void bind() throws IOException {
-        // allocate an unbound server socket channel
-        serverSocket = new ServerSocket();
-        // set the port the server channel will listen to
-        //serverSocket.bind(new InetSocketAddress(getBind(), getTcpListenPort()));
-        bind(serverSocket,getPort(),getAutoBind());
-    }
-
-
-    @Override
-    public void run() {
-        try {
-            listen();
-        } catch (Exception x) {
-            log.error(sm.getString("bioReceiver.run.fail"), x);
-        }
-    }
-
-    public void listen() throws Exception {
-        if (doListen()) {
-            log.warn(sm.getString("bioReceiver.already.started"));
-            return;
-        }
-        setListen(true);
-
-        while ( doListen() ) {
-            Socket socket = null;
-            if ( getTaskPool().available() < 1 ) {
-                if ( log.isWarnEnabled() )
-                    log.warn(sm.getString("bioReceiver.threads.busy"));
-            }
-            BioReplicationTask task = (BioReplicationTask)getTaskPool().getRxTask();
-            if ( task == null ) continue; //should never happen
-            try {
-                socket = serverSocket.accept();
-            }catch ( Exception x ) {
-                if ( doListen() ) throw x;
-            }
-            if ( !doListen() ) {
-                task.serviceSocket(null,null);
-                getExecutor().execute(task);
-                task.close();
-                break; //regular shutdown
-            }
-            if ( socket == null ) continue;
-            socket.setReceiveBufferSize(getRxBufSize());
-            socket.setSendBufferSize(getTxBufSize());
-            socket.setTcpNoDelay(getTcpNoDelay());
-            socket.setKeepAlive(getSoKeepAlive());
-            socket.setOOBInline(getOoBInline());
-            socket.setReuseAddress(getSoReuseAddress());
-            socket.setSoLinger(getSoLingerOn(),getSoLingerTime());
-            socket.setSoTimeout(getTimeout());
-            ObjectReader reader = new ObjectReader(socket);
-            task.serviceSocket(socket,reader);
-            getExecutor().execute(task);
-        }//while
-    }
-
-
-}
\ No newline at end of file

==================================================
BioSender.java
deleted file mode 100644
index d35ee657eb..0000000000
--- a/java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java
+++ /dev/null
@@ -1,189 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport.bio;
-
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Socket;
-
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.io.BufferPool;
-import org.apache.catalina.tribes.io.ChannelData;
-import org.apache.catalina.tribes.io.ListenCallback;
-import org.apache.catalina.tribes.io.ObjectReader;
-import org.apache.catalina.tribes.transport.AbstractRxTask;
-import org.apache.catalina.tribes.transport.Constants;
-import org.apache.catalina.tribes.util.StringManager;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-
-/**
- * A worker thread class which can drain channels and echo-back the input. Each
- * instance is constructed with a reference to the owning thread pool object.
- * When started, the thread loops forever waiting to be awakened to service the
- * channel associated with a SelectionKey object. The worker is tasked by
- * calling its serviceChannel() method with a SelectionKey object. The
- * serviceChannel() method stores the key reference in the thread object then
- * calls notify() to wake it up. When the channel has been drained, the worker
- * thread returns itself to its parent pool.
- */
-public class BioReplicationTask extends AbstractRxTask {
-
-    private static final Log log = LogFactory.getLog(BioReplicationTask.class);
-
-    protected static final StringManager sm = StringManager.getManager(BioReplicationTask.class);
-
-    protected Socket socket;
-    protected ObjectReader reader;
-
-    public BioReplicationTask (ListenCallback callback) {
-        super(callback);
-    }
-
-    // loop forever waiting for work to do
-    @Override
-    public synchronized void run()
-    {
-        if ( socket == null ) return;
-        try {
-            drainSocket();
-        } catch ( Exception x ) {
-            log.error(sm.getString("bioReplicationTask.unable.service"), x);
-        }finally {
-            try {
-                socket.close();
-            }catch (Exception e) {
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("bioReplicationTask.socket.closeFailed"), e);
-                }
-            }
-            try {
-                reader.close();
-            }catch (Exception e) {
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("bioReplicationTask.reader.closeFailed"), e);
-                }
-            }
-            reader = null;
-            socket = null;
-        }
-        // done, ready for more, return to pool
-        if ( getTaskPool() != null ) getTaskPool().returnWorker (this);
-    }
-
-
-    public synchronized void serviceSocket(Socket socket, ObjectReader reader) {
-        this.socket = socket;
-        this.reader = reader;
-    }
-
-    protected void execute(ObjectReader reader) throws Exception{
-        int pkgcnt = reader.count();
-
-        if ( pkgcnt > 0 ) {
-            ChannelMessage[] msgs = reader.execute();
-            for ( int i=0; i<msgs.length; i++ ) {
-                /**
-                 * Use send ack here if you want to ack the request to the remote
-                 * server before completing the request
-                 * This is considered an asynchronous request
-                 */
-                if (ChannelData.sendAckAsync(msgs[i].getOptions())) sendAck(Constants.ACK_COMMAND);
-                try {
-                    //process the message
-                    getCallback().messageDataReceived(msgs[i]);
-                    /**
-                     * Use send ack here if you want the request to complete on this
-                     * server before sending the ack to the remote server
-                     * This is considered a synchronized request
-                     */
-                    if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(Constants.ACK_COMMAND);
-                }catch  ( Exception x ) {
-                    if (ChannelData.sendAckSync(msgs[i].getOptions())) sendAck(Constants.FAIL_ACK_COMMAND);
-                    log.error(sm.getString("bioReplicationTask.messageDataReceived.error"),x);
-                }
-                if ( getUseBufferPool() ) {
-                    BufferPool.getBufferPool().returnBuffer(msgs[i].getMessage());
-                    msgs[i].setMessage(null);
-                }
-            }
-        }
-
-
-    }
-
-    /**
-     * The actual code which drains the channel associated with
-     * the given key.  This method assumes the key has been
-     * modified prior to invocation to turn off selection
-     * interest in OP_READ.  When this method completes it
-     * re-enables OP_READ and calls wakeup() on the selector
-     * so the selector will resume watching this channel.
-     * @throws Exception IO exception or execute exception
-     */
-    protected void drainSocket() throws Exception {
-        InputStream in = socket.getInputStream();
-        // loop while data available, channel is non-blocking
-        byte[] buf = new byte[1024];
-        int length = in.read(buf);
-        while ( length >= 0 ) {
-            int count = reader.append(buf,0,length,true);
-            if ( count > 0 ) execute(reader);
-            length = in.read(buf);
-        }
-    }
-
-
-    /**
-     * Send a reply-acknowledgment (6,2,3)
-     * @param command The command to write
-     */
-    protected void sendAck(byte[] command) {
-        try {
-            OutputStream out = socket.getOutputStream();
-            out.write(command);
-            out.flush();
-            if (log.isTraceEnabled()) {
-                log.trace("ACK sent to " + socket.getPort());
-            }
-        } catch ( java.io.IOException x ) {
-            log.warn(sm.getString("bioReplicationTask.unable.sendAck", x.getMessage()));
-        }
-    }
-
-    @Override
-    public void close() {
-        try {
-            socket.close();
-        }catch (Exception e) {
-            if (log.isDebugEnabled()) {
-                log.debug(sm.getString("bioReplicationTask.socket.closeFailed"), e);
-            }
-        }
-        try {
-            reader.close();
-        }catch (Exception e) {
-            if (log.isDebugEnabled()) {
-                log.debug(sm.getString("bioReplicationTask.reader.closeFailed"), e);
-            }
-        }
-        reader = null;
-        socket = null;
-        super.close();
-    }
-}

==================================================
MultipointBioSender.java
deleted file mode 100644
index 1d4044957d..0000000000
--- a/java/org/apache/catalina/tribes/transport/bio/LocalStrings_ru.properties
+++ /dev/null
@@ -1,16 +0,0 @@
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-bioSender.send.again=Послать данные ещё раз в [{0}:{1,number,integer}]

==================================================
PooledMultiSender.java
deleted file mode 100644
index 5edd1e1707..0000000000
--- a/java/org/apache/catalina/tribes/transport/bio/MultipointBioSender.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.catalina.tribes.transport.bio;
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.catalina.tribes.Channel;
-import org.apache.catalina.tribes.ChannelException;
-import org.apache.catalina.tribes.ChannelMessage;
-import org.apache.catalina.tribes.Member;
-import org.apache.catalina.tribes.io.ChannelData;
-import org.apache.catalina.tribes.io.XByteBuffer;
-import org.apache.catalina.tribes.transport.AbstractSender;
-import org.apache.catalina.tribes.transport.MultiPointSender;
-
-public class MultipointBioSender extends AbstractSender implements MultiPointSender {
-    public MultipointBioSender() {
-        // NO-OP
-    }
-
-    protected final HashMap<Member, BioSender> bioSenders = new HashMap<>();
-
-    @Override
-    public synchronized void sendMessage(Member[] destination, ChannelMessage msg) throws ChannelException {
-        byte[] data = XByteBuffer.createDataPackage((ChannelData)msg);
-        BioSender[] senders = setupForSend(destination);
-        ChannelException cx = null;
-        for ( int i=0; i<senders.length; i++ ) {
-            try {
-                senders[i].sendMessage(data,(msg.getOptions()&Channel.SEND_OPTIONS_USE_ACK)==Channel.SEND_OPTIONS_USE_ACK);
-            } catch (Exception x) {
-                if (cx == null) cx = new ChannelException(x);
-                cx.addFaultyMember(destination[i],x);
-            }
-        }
-        if (cx!=null ) throw cx;
-    }
-
-
-
-    protected BioSender[] setupForSend(Member[] destination) throws ChannelException {
-        ChannelException cx = null;
-        BioSender[] result = new BioSender[destination.length];
-        for ( int i=0; i<destination.length; i++ ) {
-            try {
-                BioSender sender = bioSenders.get(destination[i]);
-                if (sender == null) {
-                    sender = new BioSender();
-                    AbstractSender.transferProperties(this,sender);
-                    sender.setDestination(destination[i]);
-                    bioSenders.put(destination[i], sender);
-                }
-                result[i] = sender;
-                if (!result[i].isConnected() ) result[i].connect();
-                result[i].keepalive();
-            }catch (Exception x ) {
-                if ( cx== null ) cx = new ChannelException(x);
-                cx.addFaultyMember(destination[i],x);
-            }
-        }
-        if ( cx!=null ) throw cx;
-        else return result;
-    }
-
-    @Override
-    public void connect() throws IOException {
-        //do nothing, we connect on demand
-        setConnected(true);
-    }
-
-
-    private synchronized void close() throws ChannelException  {
-        ChannelException x = null;
-        Object[] members = bioSenders.keySet().toArray();
-        for (int i=0; i<members.length; i++ ) {
-            Member mbr = (Member)members[i];
-            try {
-                BioSender sender = bioSenders.get(mbr);
-                sender.disconnect();
-            }catch ( Exception e ) {
-                if ( x == null ) x = new ChannelException(e);
-                x.addFaultyMember(mbr,e);
-            }
-            bioSenders.remove(mbr);
-        }
-        if ( x != null ) throw x;
-    }
-
-    @Override
-    public void add(Member member) {
-        // NO-OP
-        // Members are defined by the array of members specified in the call to
-        // sendMessage()
-    }
-
-    @Override
-    public void remove(Member member) {
-        //disconnect senders
-        BioSender sender = bioSenders.remove(member);
-        if ( sender != null ) sender.disconnect();
-    }
-
-
-    @Override
-    public synchronized void disconnect() {
-        try {
-            close();
-        } catch (Exception x) {
-            // Ignore
-        }
-        setConnected(false);
-    }
-
-    @Override
-    protected void finalize() throws Throwable {
-        try {
-            disconnect();
-        } catch (Exception e) {
-            // Ignore
-        }
-        super.finalize();
-    }
-
-
-    @Override
-    public boolean keepalive() {
-        boolean result = false;
-        @SuppressWarnings("unchecked")
-        Map.Entry<Member,BioSender>[] entries = bioSenders.entrySet().toArray(new Map.Entry[0]);
-        for ( int i=0; i<entries.length; i++ ) {
-            BioSender sender = entries[i].getValue();
-            if ( sender.keepalive() ) {
-                bioSenders.remove(entries[i].getKey());
-            }
-        }
-        return result;
-    }
-
-}
\ No newline at end of file

==================================================
