a034980b16d1d00bdcc53ab5c398409dd7b9af34
==================================================
Update auto generated files as a result of ELParser.jjt change
==================================================
Mark Emlyn
==================================================
Thu Sep 18 19:53:24 2008 +0000
==================================================
ELParser.java
Update auto generated files as a result of ELParser.jjt change
I have not re-instated the AL2 header in the auto-generated files. On reflection I don't think it makes sense for auto-generated files and the file they are generated from has the AL2 header. It also makes re-generating the files simpler.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@696782 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ELParserConstants.java
index 8e0130d97e..f1ac4bd313 100644
--- a/java/org/apache/el/parser/ELParser.java
+++ b/java/org/apache/el/parser/ELParser.java
@@ -1,19 +1,3 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 /* Generated By:JJTree&JavaCC: Do not edit this line. ELParser.java */
 package org.apache.el.parser;
 import java.io.StringReader;
@@ -22,9 +6,9 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
   protected JJTELParserState jjtree = new JJTELParserState();public static Node parse(String ref) throws ELException
     {
         try {
-                return (new ELParser(new StringReader(ref))).CompositeExpression();
+            return (new ELParser(new StringReader(ref))).CompositeExpression();
         } catch (ParseException pe) {
-                throw new ELException(pe.getMessage());
+            throw new ELException(pe.getMessage());
         }
     }
 
@@ -68,27 +52,27 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
         }
       }
       jj_consume_token(0);
-                                                                                    jjtree.closeNodeScope(jjtn000, true);
-                                                                                    jjtc000 = false;
-                                                                                    {if (true) return jjtn000;}
+                                                                                jjtree.closeNodeScope(jjtn000, true);
+                                                                                jjtc000 = false;
+                                                                                {if (true) return jjtn000;}
     } catch (Throwable jjte000) {
-          if (jjtc000) {
-            jjtree.clearNodeScope(jjtn000);
-            jjtc000 = false;
-          } else {
-            jjtree.popNode();
-          }
-          if (jjte000 instanceof RuntimeException) {
-            {if (true) throw (RuntimeException)jjte000;}
-          }
-          if (jjte000 instanceof ParseException) {
-            {if (true) throw (ParseException)jjte000;}
-          }
-          {if (true) throw (Error)jjte000;}
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
     } finally {
-          if (jjtc000) {
-            jjtree.closeNodeScope(jjtn000, true);
-          }
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+      }
     }
     throw new Error("Missing return statement in function");
   }
@@ -104,13 +88,13 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
                                                 jjtree.openNodeScope(jjtn000);Token t = null;
     try {
       t = jj_consume_token(LITERAL_EXPRESSION);
-                                 jjtree.closeNodeScope(jjtn000, true);
-                                 jjtc000 = false;
-                                 jjtn000.setImage(t.image);
+                             jjtree.closeNodeScope(jjtn000, true);
+                             jjtc000 = false;
+                             jjtn000.setImage(t.image);
     } finally {
-          if (jjtc000) {
-            jjtree.closeNodeScope(jjtn000, true);
-          }
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+      }
     }
   }
 
@@ -128,23 +112,23 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
       Expression();
       jj_consume_token(END_EXPRESSION);
     } catch (Throwable jjte000) {
-          if (jjtc000) {
-            jjtree.clearNodeScope(jjtn000);
-            jjtc000 = false;
-          } else {
-            jjtree.popNode();
-          }
-          if (jjte000 instanceof RuntimeException) {
-            {if (true) throw (RuntimeException)jjte000;}
-          }
-          if (jjte000 instanceof ParseException) {
-            {if (true) throw (ParseException)jjte000;}
-          }
-          {if (true) throw (Error)jjte000;}
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
     } finally {
-          if (jjtc000) {
-            jjtree.closeNodeScope(jjtn000, true);
-          }
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+      }
     }
   }
 
@@ -162,23 +146,23 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
       Expression();
       jj_consume_token(END_EXPRESSION);
     } catch (Throwable jjte000) {
-          if (jjtc000) {
-            jjtree.clearNodeScope(jjtn000);
-            jjtc000 = false;
-          } else {
-            jjtree.popNode();
-          }
-          if (jjte000 instanceof RuntimeException) {
-            {if (true) throw (RuntimeException)jjte000;}
-          }
-          if (jjte000 instanceof ParseException) {
-            {if (true) throw (ParseException)jjte000;}
-          }
-          {if (true) throw (Error)jjte000;}
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
     } finally {
-          if (jjtc000) {
-            jjtree.closeNodeScope(jjtn000, true);
-          }
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+      }
     }
   }
 
@@ -198,40 +182,37 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
     Or();
     label_2:
     while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case QUESTIONMARK:
+      if (jj_2_1(3)) {
         ;
-        break;
-      default:
-        jj_la1[2] = jj_gen;
+      } else {
         break label_2;
       }
       jj_consume_token(QUESTIONMARK);
       Choice();
       jj_consume_token(COLON);
-                                                AstChoice jjtn001 = new AstChoice(JJTCHOICE);
-                                                boolean jjtc001 = true;
-                                                jjtree.openNodeScope(jjtn001);
+                                                         AstChoice jjtn001 = new AstChoice(JJTCHOICE);
+                                                         boolean jjtc001 = true;
+                                                         jjtree.openNodeScope(jjtn001);
       try {
         Choice();
       } catch (Throwable jjte001) {
-                                                if (jjtc001) {
-                                                  jjtree.clearNodeScope(jjtn001);
-                                                  jjtc001 = false;
-                                                } else {
-                                                  jjtree.popNode();
-                                                }
-                                                if (jjte001 instanceof RuntimeException) {
-                                                  {if (true) throw (RuntimeException)jjte001;}
-                                                }
-                                                if (jjte001 instanceof ParseException) {
-                                                  {if (true) throw (ParseException)jjte001;}
-                                                }
-                                                {if (true) throw (Error)jjte001;}
+                                                         if (jjtc001) {
+                                                           jjtree.clearNodeScope(jjtn001);
+                                                           jjtc001 = false;
+                                                         } else {
+                                                           jjtree.popNode();
+                                                         }
+                                                         if (jjte001 instanceof RuntimeException) {
+                                                           {if (true) throw (RuntimeException)jjte001;}
+                                                         }
+                                                         if (jjte001 instanceof ParseException) {
+                                                           {if (true) throw (ParseException)jjte001;}
+                                                         }
+                                                         {if (true) throw (Error)jjte001;}
       } finally {
-                                                if (jjtc001) {
-                                                  jjtree.closeNodeScope(jjtn001,  3);
-                                                }
+                                                         if (jjtc001) {
+                                                           jjtree.closeNodeScope(jjtn001,  3);
+                                                         }
       }
     }
   }
@@ -250,7 +231,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
         ;
         break;
       default:
-        jj_la1[3] = jj_gen;
+        jj_la1[2] = jj_gen;
         break label_3;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -261,33 +242,33 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
         jj_consume_token(OR1);
         break;
       default:
-        jj_la1[4] = jj_gen;
+        jj_la1[3] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
-                               AstOr jjtn001 = new AstOr(JJTOR);
-                               boolean jjtc001 = true;
-                               jjtree.openNodeScope(jjtn001);
+                           AstOr jjtn001 = new AstOr(JJTOR);
+                           boolean jjtc001 = true;
+                           jjtree.openNodeScope(jjtn001);
       try {
         And();
       } catch (Throwable jjte001) {
-                               if (jjtc001) {
-                                 jjtree.clearNodeScope(jjtn001);
-                                 jjtc001 = false;
-                               } else {
-                                 jjtree.popNode();
-                               }
-                               if (jjte001 instanceof RuntimeException) {
-                                 {if (true) throw (RuntimeException)jjte001;}
-                               }
-                               if (jjte001 instanceof ParseException) {
-                                 {if (true) throw (ParseException)jjte001;}
-                               }
-                               {if (true) throw (Error)jjte001;}
+                           if (jjtc001) {
+                             jjtree.clearNodeScope(jjtn001);
+                             jjtc001 = false;
+                           } else {
+                             jjtree.popNode();
+                           }
+                           if (jjte001 instanceof RuntimeException) {
+                             {if (true) throw (RuntimeException)jjte001;}
+                           }
+                           if (jjte001 instanceof ParseException) {
+                             {if (true) throw (ParseException)jjte001;}
+                           }
+                           {if (true) throw (Error)jjte001;}
       } finally {
-                               if (jjtc001) {
-                                 jjtree.closeNodeScope(jjtn001,  2);
-                               }
+                           if (jjtc001) {
+                             jjtree.closeNodeScope(jjtn001,  2);
+                           }
       }
     }
   }
@@ -306,7 +287,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
         ;
         break;
       default:
-        jj_la1[5] = jj_gen;
+        jj_la1[4] = jj_gen;
         break label_4;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -317,33 +298,33 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
         jj_consume_token(AND1);
         break;
       default:
-        jj_la1[6] = jj_gen;
+        jj_la1[5] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
-                                      AstAnd jjtn001 = new AstAnd(JJTAND);
-                                      boolean jjtc001 = true;
-                                      jjtree.openNodeScope(jjtn001);
+                                  AstAnd jjtn001 = new AstAnd(JJTAND);
+                                  boolean jjtc001 = true;
+                                  jjtree.openNodeScope(jjtn001);
       try {
         Equality();
       } catch (Throwable jjte001) {
-                                      if (jjtc001) {
-                                        jjtree.clearNodeScope(jjtn001);
-                                        jjtc001 = false;
-                                      } else {
-                                        jjtree.popNode();
-                                      }
-                                      if (jjte001 instanceof RuntimeException) {
-                                        {if (true) throw (RuntimeException)jjte001;}
-                                      }
-                                      if (jjte001 instanceof ParseException) {
-                                        {if (true) throw (ParseException)jjte001;}
-                                      }
-                                      {if (true) throw (Error)jjte001;}
+                                  if (jjtc001) {
+                                    jjtree.clearNodeScope(jjtn001);
+                                    jjtc001 = false;
+                                  } else {
+                                    jjtree.popNode();
+                                  }
+                                  if (jjte001 instanceof RuntimeException) {
+                                    {if (true) throw (RuntimeException)jjte001;}
+                                  }
+                                  if (jjte001 instanceof ParseException) {
+                                    {if (true) throw (ParseException)jjte001;}
+                                  }
+                                  {if (true) throw (Error)jjte001;}
       } finally {
-                                      if (jjtc001) {
-                                        jjtree.closeNodeScope(jjtn001,  2);
-                                      }
+                                  if (jjtc001) {
+                                    jjtree.closeNodeScope(jjtn001,  2);
+                                  }
       }
     }
   }
@@ -364,7 +345,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
         ;
         break;
       default:
-        jj_la1[7] = jj_gen;
+        jj_la1[6] = jj_gen;
         break label_5;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -378,33 +359,33 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
           jj_consume_token(EQ1);
           break;
         default:
-          jj_la1[8] = jj_gen;
+          jj_la1[7] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
-                                 AstEqual jjtn001 = new AstEqual(JJTEQUAL);
-                                 boolean jjtc001 = true;
-                                 jjtree.openNodeScope(jjtn001);
+                         AstEqual jjtn001 = new AstEqual(JJTEQUAL);
+                         boolean jjtc001 = true;
+                         jjtree.openNodeScope(jjtn001);
         try {
           Compare();
         } catch (Throwable jjte001) {
-                                 if (jjtc001) {
-                                   jjtree.clearNodeScope(jjtn001);
-                                   jjtc001 = false;
-                                 } else {
-                                   jjtree.popNode();
-                                 }
-                                 if (jjte001 instanceof RuntimeException) {
-                                   {if (true) throw (RuntimeException)jjte001;}
-                                 }
-                                 if (jjte001 instanceof ParseException) {
-                                   {if (true) throw (ParseException)jjte001;}
-                                 }
-                                 {if (true) throw (Error)jjte001;}
+                         if (jjtc001) {
+                           jjtree.clearNodeScope(jjtn001);
+                           jjtc001 = false;
+                         } else {
+                           jjtree.popNode();
+                         }
+                         if (jjte001 instanceof RuntimeException) {
+                           {if (true) throw (RuntimeException)jjte001;}
+                         }
+                         if (jjte001 instanceof ParseException) {
+                           {if (true) throw (ParseException)jjte001;}
+                         }
+                         {if (true) throw (Error)jjte001;}
         } finally {
-                                 if (jjtc001) {
-                                   jjtree.closeNodeScope(jjtn001,  2);
-                                 }
+                         if (jjtc001) {
+                           jjtree.closeNodeScope(jjtn001,  2);
+                         }
         }
         break;
       case NE0:
@@ -417,37 +398,37 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
           jj_consume_token(NE1);
           break;
         default:
-          jj_la1[9] = jj_gen;
+          jj_la1[8] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
-                                 AstNotEqual jjtn002 = new AstNotEqual(JJTNOTEQUAL);
-                                 boolean jjtc002 = true;
-                                 jjtree.openNodeScope(jjtn002);
+                         AstNotEqual jjtn002 = new AstNotEqual(JJTNOTEQUAL);
+                         boolean jjtc002 = true;
+                         jjtree.openNodeScope(jjtn002);
         try {
           Compare();
         } catch (Throwable jjte002) {
-                                 if (jjtc002) {
-                                   jjtree.clearNodeScope(jjtn002);
-                                   jjtc002 = false;
-                                 } else {
-                                   jjtree.popNode();
-                                 }
-                                 if (jjte002 instanceof RuntimeException) {
-                                   {if (true) throw (RuntimeException)jjte002;}
-                                 }
-                                 if (jjte002 instanceof ParseException) {
-                                   {if (true) throw (ParseException)jjte002;}
-                                 }
-                                 {if (true) throw (Error)jjte002;}
+                         if (jjtc002) {
+                           jjtree.clearNodeScope(jjtn002);
+                           jjtc002 = false;
+                         } else {
+                           jjtree.popNode();
+                         }
+                         if (jjte002 instanceof RuntimeException) {
+                           {if (true) throw (RuntimeException)jjte002;}
+                         }
+                         if (jjte002 instanceof ParseException) {
+                           {if (true) throw (ParseException)jjte002;}
+                         }
+                         {if (true) throw (Error)jjte002;}
         } finally {
-                                 if (jjtc002) {
-                                   jjtree.closeNodeScope(jjtn002,  2);
-                                 }
+                         if (jjtc002) {
+                           jjtree.closeNodeScope(jjtn002,  2);
+                         }
         }
         break;
       default:
-        jj_la1[10] = jj_gen;
+        jj_la1[9] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -474,7 +455,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
         ;
         break;
       default:
-        jj_la1[11] = jj_gen;
+        jj_la1[10] = jj_gen;
         break label_6;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -488,33 +469,33 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
           jj_consume_token(LT1);
           break;
         default:
-          jj_la1[12] = jj_gen;
+          jj_la1[11] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
-                                 AstLessThan jjtn001 = new AstLessThan(JJTLESSTHAN);
-                                 boolean jjtc001 = true;
-                                 jjtree.openNodeScope(jjtn001);
+                         AstLessThan jjtn001 = new AstLessThan(JJTLESSTHAN);
+                         boolean jjtc001 = true;
+                         jjtree.openNodeScope(jjtn001);
         try {
           Math();
         } catch (Throwable jjte001) {
-                                 if (jjtc001) {
-                                   jjtree.clearNodeScope(jjtn001);
-                                   jjtc001 = false;
-                                 } else {
-                                   jjtree.popNode();
-                                 }
-                                 if (jjte001 instanceof RuntimeException) {
-                                   {if (true) throw (RuntimeException)jjte001;}
-                                 }
-                                 if (jjte001 instanceof ParseException) {
-                                   {if (true) throw (ParseException)jjte001;}
-                                 }
-                                 {if (true) throw (Error)jjte001;}
+                         if (jjtc001) {
+                           jjtree.clearNodeScope(jjtn001);
+                           jjtc001 = false;
+                         } else {
+                           jjtree.popNode();
+                         }
+                         if (jjte001 instanceof RuntimeException) {
+                           {if (true) throw (RuntimeException)jjte001;}
+                         }
+                         if (jjte001 instanceof ParseException) {
+                           {if (true) throw (ParseException)jjte001;}
+                         }
+                         {if (true) throw (Error)jjte001;}
         } finally {
-                                 if (jjtc001) {
-                                   jjtree.closeNodeScope(jjtn001,  2);
-                                 }
+                         if (jjtc001) {
+                           jjtree.closeNodeScope(jjtn001,  2);
+                         }
         }
         break;
       case GT0:
@@ -527,33 +508,33 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
           jj_consume_token(GT1);
           break;
         default:
-          jj_la1[13] = jj_gen;
+          jj_la1[12] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
-                                 AstGreaterThan jjtn002 = new AstGreaterThan(JJTGREATERTHAN);
-                                 boolean jjtc002 = true;
-                                 jjtree.openNodeScope(jjtn002);
+                         AstGreaterThan jjtn002 = new AstGreaterThan(JJTGREATERTHAN);
+                         boolean jjtc002 = true;
+                         jjtree.openNodeScope(jjtn002);
         try {
           Math();
         } catch (Throwable jjte002) {
-                                 if (jjtc002) {
-                                   jjtree.clearNodeScope(jjtn002);
-                                   jjtc002 = false;
-                                 } else {
-                                   jjtree.popNode();
-                                 }
-                                 if (jjte002 instanceof RuntimeException) {
-                                   {if (true) throw (RuntimeException)jjte002;}
-                                 }
-                                 if (jjte002 instanceof ParseException) {
-                                   {if (true) throw (ParseException)jjte002;}
-                                 }
-                                 {if (true) throw (Error)jjte002;}
+                         if (jjtc002) {
+                           jjtree.clearNodeScope(jjtn002);
+                           jjtc002 = false;
+                         } else {
+                           jjtree.popNode();
+                         }
+                         if (jjte002 instanceof RuntimeException) {
+                           {if (true) throw (RuntimeException)jjte002;}
+                         }
+                         if (jjte002 instanceof ParseException) {
+                           {if (true) throw (ParseException)jjte002;}
+                         }
+                         {if (true) throw (Error)jjte002;}
         } finally {
-                                 if (jjtc002) {
-                                   jjtree.closeNodeScope(jjtn002,  2);
-                                 }
+                         if (jjtc002) {
+                           jjtree.closeNodeScope(jjtn002,  2);
+                         }
         }
         break;
       case LE0:
@@ -566,33 +547,33 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
           jj_consume_token(LE1);
           break;
         default:
-          jj_la1[14] = jj_gen;
+          jj_la1[13] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
-                                 AstLessThanEqual jjtn003 = new AstLessThanEqual(JJTLESSTHANEQUAL);
-                                 boolean jjtc003 = true;
-                                 jjtree.openNodeScope(jjtn003);
+                         AstLessThanEqual jjtn003 = new AstLessThanEqual(JJTLESSTHANEQUAL);
+                         boolean jjtc003 = true;
+                         jjtree.openNodeScope(jjtn003);
         try {
           Math();
         } catch (Throwable jjte003) {
-                                 if (jjtc003) {
-                                   jjtree.clearNodeScope(jjtn003);
-                                   jjtc003 = false;
-                                 } else {
-                                   jjtree.popNode();
-                                 }
-                                 if (jjte003 instanceof RuntimeException) {
-                                   {if (true) throw (RuntimeException)jjte003;}
-                                 }
-                                 if (jjte003 instanceof ParseException) {
-                                   {if (true) throw (ParseException)jjte003;}
-                                 }
-                                 {if (true) throw (Error)jjte003;}
+                         if (jjtc003) {
+                           jjtree.clearNodeScope(jjtn003);
+                           jjtc003 = false;
+                         } else {
+                           jjtree.popNode();
+                         }
+                         if (jjte003 instanceof RuntimeException) {
+                           {if (true) throw (RuntimeException)jjte003;}
+                         }
+                         if (jjte003 instanceof ParseException) {
+                           {if (true) throw (ParseException)jjte003;}
+                         }
+                         {if (true) throw (Error)jjte003;}
         } finally {
-                                 if (jjtc003) {
-                                   jjtree.closeNodeScope(jjtn003,  2);
-                                 }
+                         if (jjtc003) {
+                           jjtree.closeNodeScope(jjtn003,  2);
+                         }
         }
         break;
       case GE0:
@@ -605,37 +586,37 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
           jj_consume_token(GE1);
           break;
         default:
-          jj_la1[15] = jj_gen;
+          jj_la1[14] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
-                                 AstGreaterThanEqual jjtn004 = new AstGreaterThanEqual(JJTGREATERTHANEQUAL);
-                                 boolean jjtc004 = true;
-                                 jjtree.openNodeScope(jjtn004);
+                         AstGreaterThanEqual jjtn004 = new AstGreaterThanEqual(JJTGREATERTHANEQUAL);
+                         boolean jjtc004 = true;
+                         jjtree.openNodeScope(jjtn004);
         try {
           Math();
         } catch (Throwable jjte004) {
-                                 if (jjtc004) {
-                                   jjtree.clearNodeScope(jjtn004);
-                                   jjtc004 = false;
-                                 } else {
-                                   jjtree.popNode();
-                                 }
-                                 if (jjte004 instanceof RuntimeException) {
-                                   {if (true) throw (RuntimeException)jjte004;}
-                                 }
-                                 if (jjte004 instanceof ParseException) {
-                                   {if (true) throw (ParseException)jjte004;}
-                                 }
-                                 {if (true) throw (Error)jjte004;}
+                         if (jjtc004) {
+                           jjtree.clearNodeScope(jjtn004);
+                           jjtc004 = false;
+                         } else {
+                           jjtree.popNode();
+                         }
+                         if (jjte004 instanceof RuntimeException) {
+                           {if (true) throw (RuntimeException)jjte004;}
+                         }
+                         if (jjte004 instanceof ParseException) {
+                           {if (true) throw (ParseException)jjte004;}
+                         }
+                         {if (true) throw (Error)jjte004;}
         } finally {
-                                 if (jjtc004) {
-                                   jjtree.closeNodeScope(jjtn004,  2);
-                                 }
+                         if (jjtc004) {
+                           jjtree.closeNodeScope(jjtn004,  2);
+                         }
         }
         break;
       default:
-        jj_la1[16] = jj_gen;
+        jj_la1[15] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -656,66 +637,66 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
         ;
         break;
       default:
-        jj_la1[17] = jj_gen;
+        jj_la1[16] = jj_gen;
         break label_7;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case PLUS:
         jj_consume_token(PLUS);
-                          AstPlus jjtn001 = new AstPlus(JJTPLUS);
-                          boolean jjtc001 = true;
-                          jjtree.openNodeScope(jjtn001);
+                  AstPlus jjtn001 = new AstPlus(JJTPLUS);
+                  boolean jjtc001 = true;
+                  jjtree.openNodeScope(jjtn001);
         try {
           Multiplication();
         } catch (Throwable jjte001) {
-                          if (jjtc001) {
-                            jjtree.clearNodeScope(jjtn001);
-                            jjtc001 = false;
-                          } else {
-                            jjtree.popNode();
-                          }
-                          if (jjte001 instanceof RuntimeException) {
-                            {if (true) throw (RuntimeException)jjte001;}
-                          }
-                          if (jjte001 instanceof ParseException) {
-                            {if (true) throw (ParseException)jjte001;}
-                          }
-                          {if (true) throw (Error)jjte001;}
+                  if (jjtc001) {
+                    jjtree.clearNodeScope(jjtn001);
+                    jjtc001 = false;
+                  } else {
+                    jjtree.popNode();
+                  }
+                  if (jjte001 instanceof RuntimeException) {
+                    {if (true) throw (RuntimeException)jjte001;}
+                  }
+                  if (jjte001 instanceof ParseException) {
+                    {if (true) throw (ParseException)jjte001;}
+                  }
+                  {if (true) throw (Error)jjte001;}
         } finally {
-                          if (jjtc001) {
-                            jjtree.closeNodeScope(jjtn001,  2);
-                          }
+                  if (jjtc001) {
+                    jjtree.closeNodeScope(jjtn001,  2);
+                  }
         }
         break;
       case MINUS:
         jj_consume_token(MINUS);
-                           AstMinus jjtn002 = new AstMinus(JJTMINUS);
-                           boolean jjtc002 = true;
-                           jjtree.openNodeScope(jjtn002);
+                   AstMinus jjtn002 = new AstMinus(JJTMINUS);
+                   boolean jjtc002 = true;
+                   jjtree.openNodeScope(jjtn002);
         try {
           Multiplication();
         } catch (Throwable jjte002) {
-                           if (jjtc002) {
-                             jjtree.clearNodeScope(jjtn002);
-                             jjtc002 = false;
-                           } else {
-                             jjtree.popNode();
-                           }
-                           if (jjte002 instanceof RuntimeException) {
-                             {if (true) throw (RuntimeException)jjte002;}
-                           }
-                           if (jjte002 instanceof ParseException) {
-                             {if (true) throw (ParseException)jjte002;}
-                           }
-                           {if (true) throw (Error)jjte002;}
+                   if (jjtc002) {
+                     jjtree.clearNodeScope(jjtn002);
+                     jjtc002 = false;
+                   } else {
+                     jjtree.popNode();
+                   }
+                   if (jjte002 instanceof RuntimeException) {
+                     {if (true) throw (RuntimeException)jjte002;}
+                   }
+                   if (jjte002 instanceof ParseException) {
+                     {if (true) throw (ParseException)jjte002;}
+                   }
+                   {if (true) throw (Error)jjte002;}
         } finally {
-                           if (jjtc002) {
-                             jjtree.closeNodeScope(jjtn002,  2);
-                           }
+                   if (jjtc002) {
+                     jjtree.closeNodeScope(jjtn002,  2);
+                   }
         }
         break;
       default:
-        jj_la1[18] = jj_gen;
+        jj_la1[17] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -739,35 +720,35 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
         ;
         break;
       default:
-        jj_la1[19] = jj_gen;
+        jj_la1[18] = jj_gen;
         break label_8;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case MULT:
         jj_consume_token(MULT);
-                          AstMult jjtn001 = new AstMult(JJTMULT);
-                          boolean jjtc001 = true;
-                          jjtree.openNodeScope(jjtn001);
+                  AstMult jjtn001 = new AstMult(JJTMULT);
+                  boolean jjtc001 = true;
+                  jjtree.openNodeScope(jjtn001);
         try {
           Unary();
         } catch (Throwable jjte001) {
-                          if (jjtc001) {
-                            jjtree.clearNodeScope(jjtn001);
-                            jjtc001 = false;
-                          } else {
-                            jjtree.popNode();
-                          }
-                          if (jjte001 instanceof RuntimeException) {
-                            {if (true) throw (RuntimeException)jjte001;}
-                          }
-                          if (jjte001 instanceof ParseException) {
-                            {if (true) throw (ParseException)jjte001;}
-                          }
-                          {if (true) throw (Error)jjte001;}
+                  if (jjtc001) {
+                    jjtree.clearNodeScope(jjtn001);
+                    jjtc001 = false;
+                  } else {
+                    jjtree.popNode();
+                  }
+                  if (jjte001 instanceof RuntimeException) {
+                    {if (true) throw (RuntimeException)jjte001;}
+                  }
+                  if (jjte001 instanceof ParseException) {
+                    {if (true) throw (ParseException)jjte001;}
+                  }
+                  {if (true) throw (Error)jjte001;}
         } finally {
-                          if (jjtc001) {
-                            jjtree.closeNodeScope(jjtn001,  2);
-                          }
+                  if (jjtc001) {
+                    jjtree.closeNodeScope(jjtn001,  2);
+                  }
         }
         break;
       case DIV0:
@@ -780,33 +761,33 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
           jj_consume_token(DIV1);
           break;
         default:
-          jj_la1[20] = jj_gen;
+          jj_la1[19] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
-                                   AstDiv jjtn002 = new AstDiv(JJTDIV);
-                                   boolean jjtc002 = true;
-                                   jjtree.openNodeScope(jjtn002);
+                           AstDiv jjtn002 = new AstDiv(JJTDIV);
+                           boolean jjtc002 = true;
+                           jjtree.openNodeScope(jjtn002);
         try {
           Unary();
         } catch (Throwable jjte002) {
-                                   if (jjtc002) {
-                                     jjtree.clearNodeScope(jjtn002);
-                                     jjtc002 = false;
-                                   } else {
-                                     jjtree.popNode();
-                                   }
-                                   if (jjte002 instanceof RuntimeException) {
-                                     {if (true) throw (RuntimeException)jjte002;}
-                                   }
-                                   if (jjte002 instanceof ParseException) {
-                                     {if (true) throw (ParseException)jjte002;}
-                                   }
-                                   {if (true) throw (Error)jjte002;}
+                           if (jjtc002) {
+                             jjtree.clearNodeScope(jjtn002);
+                             jjtc002 = false;
+                           } else {
+                             jjtree.popNode();
+                           }
+                           if (jjte002 instanceof RuntimeException) {
+                             {if (true) throw (RuntimeException)jjte002;}
+                           }
+                           if (jjte002 instanceof ParseException) {
+                             {if (true) throw (ParseException)jjte002;}
+                           }
+                           {if (true) throw (Error)jjte002;}
         } finally {
-                                   if (jjtc002) {
-                                     jjtree.closeNodeScope(jjtn002,  2);
-                                   }
+                           if (jjtc002) {
+                             jjtree.closeNodeScope(jjtn002,  2);
+                           }
         }
         break;
       case MOD0:
@@ -819,37 +800,37 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
           jj_consume_token(MOD1);
           break;
         default:
-          jj_la1[21] = jj_gen;
+          jj_la1[20] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
-                                   AstMod jjtn003 = new AstMod(JJTMOD);
-                                   boolean jjtc003 = true;
-                                   jjtree.openNodeScope(jjtn003);
+                           AstMod jjtn003 = new AstMod(JJTMOD);
+                           boolean jjtc003 = true;
+                           jjtree.openNodeScope(jjtn003);
         try {
           Unary();
         } catch (Throwable jjte003) {
-                                   if (jjtc003) {
-                                     jjtree.clearNodeScope(jjtn003);
-                                     jjtc003 = false;
-                                   } else {
-                                     jjtree.popNode();
-                                   }
-                                   if (jjte003 instanceof RuntimeException) {
-                                     {if (true) throw (RuntimeException)jjte003;}
-                                   }
-                                   if (jjte003 instanceof ParseException) {
-                                     {if (true) throw (ParseException)jjte003;}
-                                   }
-                                   {if (true) throw (Error)jjte003;}
+                           if (jjtc003) {
+                             jjtree.clearNodeScope(jjtn003);
+                             jjtc003 = false;
+                           } else {
+                             jjtree.popNode();
+                           }
+                           if (jjte003 instanceof RuntimeException) {
+                             {if (true) throw (RuntimeException)jjte003;}
+                           }
+                           if (jjte003 instanceof ParseException) {
+                             {if (true) throw (ParseException)jjte003;}
+                           }
+                           {if (true) throw (Error)jjte003;}
         } finally {
-                                   if (jjtc003) {
-                                     jjtree.closeNodeScope(jjtn003,  2);
-                                   }
+                           if (jjtc003) {
+                             jjtree.closeNodeScope(jjtn003,  2);
+                           }
         }
         break;
       default:
-        jj_la1[22] = jj_gen;
+        jj_la1[21] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -864,29 +845,29 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case MINUS:
       jj_consume_token(MINUS);
-                          AstNegative jjtn001 = new AstNegative(JJTNEGATIVE);
-                          boolean jjtc001 = true;
-                          jjtree.openNodeScope(jjtn001);
+                  AstNegative jjtn001 = new AstNegative(JJTNEGATIVE);
+                  boolean jjtc001 = true;
+                  jjtree.openNodeScope(jjtn001);
       try {
         Unary();
       } catch (Throwable jjte001) {
-                          if (jjtc001) {
-                            jjtree.clearNodeScope(jjtn001);
-                            jjtc001 = false;
-                          } else {
-                            jjtree.popNode();
-                          }
-                          if (jjte001 instanceof RuntimeException) {
-                            {if (true) throw (RuntimeException)jjte001;}
-                          }
-                          if (jjte001 instanceof ParseException) {
-                            {if (true) throw (ParseException)jjte001;}
-                          }
-                          {if (true) throw (Error)jjte001;}
+                  if (jjtc001) {
+                    jjtree.clearNodeScope(jjtn001);
+                    jjtc001 = false;
+                  } else {
+                    jjtree.popNode();
+                  }
+                  if (jjte001 instanceof RuntimeException) {
+                    {if (true) throw (RuntimeException)jjte001;}
+                  }
+                  if (jjte001 instanceof ParseException) {
+                    {if (true) throw (ParseException)jjte001;}
+                  }
+                  {if (true) throw (Error)jjte001;}
       } finally {
-                          if (jjtc001) {
-                            jjtree.closeNodeScope(jjtn001, true);
-                          }
+                  if (jjtc001) {
+                    jjtree.closeNodeScope(jjtn001, true);
+                  }
       }
       break;
     case NOT0:
@@ -899,60 +880,60 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
         jj_consume_token(NOT1);
         break;
       default:
-        jj_la1[23] = jj_gen;
+        jj_la1[22] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
-                                  AstNot jjtn002 = new AstNot(JJTNOT);
-                                  boolean jjtc002 = true;
-                                  jjtree.openNodeScope(jjtn002);
+                          AstNot jjtn002 = new AstNot(JJTNOT);
+                          boolean jjtc002 = true;
+                          jjtree.openNodeScope(jjtn002);
       try {
         Unary();
       } catch (Throwable jjte002) {
-                                  if (jjtc002) {
-                                    jjtree.clearNodeScope(jjtn002);
-                                    jjtc002 = false;
-                                  } else {
-                                    jjtree.popNode();
-                                  }
-                                  if (jjte002 instanceof RuntimeException) {
-                                    {if (true) throw (RuntimeException)jjte002;}
-                                  }
-                                  if (jjte002 instanceof ParseException) {
-                                    {if (true) throw (ParseException)jjte002;}
-                                  }
-                                  {if (true) throw (Error)jjte002;}
+                          if (jjtc002) {
+                            jjtree.clearNodeScope(jjtn002);
+                            jjtc002 = false;
+                          } else {
+                            jjtree.popNode();
+                          }
+                          if (jjte002 instanceof RuntimeException) {
+                            {if (true) throw (RuntimeException)jjte002;}
+                          }
+                          if (jjte002 instanceof ParseException) {
+                            {if (true) throw (ParseException)jjte002;}
+                          }
+                          {if (true) throw (Error)jjte002;}
       } finally {
-                                  if (jjtc002) {
-                                    jjtree.closeNodeScope(jjtn002, true);
-                                  }
+                          if (jjtc002) {
+                            jjtree.closeNodeScope(jjtn002, true);
+                          }
       }
       break;
     case EMPTY:
       jj_consume_token(EMPTY);
-                          AstEmpty jjtn003 = new AstEmpty(JJTEMPTY);
-                          boolean jjtc003 = true;
-                          jjtree.openNodeScope(jjtn003);
+                  AstEmpty jjtn003 = new AstEmpty(JJTEMPTY);
+                  boolean jjtc003 = true;
+                  jjtree.openNodeScope(jjtn003);
       try {
         Unary();
       } catch (Throwable jjte003) {
-                          if (jjtc003) {
-                            jjtree.clearNodeScope(jjtn003);
-                            jjtc003 = false;
-                          } else {
-                            jjtree.popNode();
-                          }
-                          if (jjte003 instanceof RuntimeException) {
-                            {if (true) throw (RuntimeException)jjte003;}
-                          }
-                          if (jjte003 instanceof ParseException) {
-                            {if (true) throw (ParseException)jjte003;}
-                          }
-                          {if (true) throw (Error)jjte003;}
+                  if (jjtc003) {
+                    jjtree.clearNodeScope(jjtn003);
+                    jjtc003 = false;
+                  } else {
+                    jjtree.popNode();
+                  }
+                  if (jjte003 instanceof RuntimeException) {
+                    {if (true) throw (RuntimeException)jjte003;}
+                  }
+                  if (jjte003 instanceof ParseException) {
+                    {if (true) throw (ParseException)jjte003;}
+                  }
+                  {if (true) throw (Error)jjte003;}
       } finally {
-                          if (jjtc003) {
-                            jjtree.closeNodeScope(jjtn003, true);
-                          }
+                  if (jjtc003) {
+                    jjtree.closeNodeScope(jjtn003, true);
+                  }
       }
       break;
     case INTEGER_LITERAL:
@@ -966,7 +947,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
       Value();
       break;
     default:
-      jj_la1[24] = jj_gen;
+      jj_la1[23] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -977,9 +958,9 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
  * Defines Prefix plus zero or more Suffixes
  */
   final public void Value() throws ParseException {
-          AstValue jjtn001 = new AstValue(JJTVALUE);
-          boolean jjtc001 = true;
-          jjtree.openNodeScope(jjtn001);
+      AstValue jjtn001 = new AstValue(JJTVALUE);
+      boolean jjtc001 = true;
+      jjtree.openNodeScope(jjtn001);
     try {
       ValuePrefix();
       label_9:
@@ -990,29 +971,29 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
           ;
           break;
         default:
-          jj_la1[25] = jj_gen;
+          jj_la1[24] = jj_gen;
           break label_9;
         }
         ValueSuffix();
       }
     } catch (Throwable jjte001) {
-          if (jjtc001) {
-            jjtree.clearNodeScope(jjtn001);
-            jjtc001 = false;
-          } else {
-            jjtree.popNode();
-          }
-          if (jjte001 instanceof RuntimeException) {
-            {if (true) throw (RuntimeException)jjte001;}
-          }
-          if (jjte001 instanceof ParseException) {
-            {if (true) throw (ParseException)jjte001;}
-          }
-          {if (true) throw (Error)jjte001;}
+      if (jjtc001) {
+        jjtree.clearNodeScope(jjtn001);
+        jjtc001 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte001 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte001;}
+      }
+      if (jjte001 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte001;}
+      }
+      {if (true) throw (Error)jjte001;}
     } finally {
-          if (jjtc001) {
-            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
-          }
+      if (jjtc001) {
+        jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
+      }
     }
   }
 
@@ -1035,7 +1016,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
       NonLiteral();
       break;
     default:
-      jj_la1[26] = jj_gen;
+      jj_la1[25] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -1054,7 +1035,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
       BracketSuffix();
       break;
     default:
-      jj_la1[27] = jj_gen;
+      jj_la1[26] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -1072,13 +1053,13 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
     try {
       jj_consume_token(DOT);
       t = jj_consume_token(IDENTIFIER);
-                               jjtree.closeNodeScope(jjtn000, true);
-                               jjtc000 = false;
-                               jjtn000.setImage(t.image);
+                           jjtree.closeNodeScope(jjtn000, true);
+                           jjtc000 = false;
+                           jjtn000.setImage(t.image);
     } finally {
-          if (jjtc000) {
-            jjtree.closeNodeScope(jjtn000, true);
-          }
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+      }
     }
   }
 
@@ -1096,23 +1077,23 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
       Expression();
       jj_consume_token(RBRACK);
     } catch (Throwable jjte000) {
-          if (jjtc000) {
-            jjtree.clearNodeScope(jjtn000);
-            jjtc000 = false;
-          } else {
-            jjtree.popNode();
-          }
-          if (jjte000 instanceof RuntimeException) {
-            {if (true) throw (RuntimeException)jjte000;}
-          }
-          if (jjte000 instanceof ParseException) {
-            {if (true) throw (ParseException)jjte000;}
-          }
-          {if (true) throw (Error)jjte000;}
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
     } finally {
-          if (jjtc000) {
-            jjtree.closeNodeScope(jjtn000, true);
-          }
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+      }
     }
   }
 
@@ -1128,8 +1109,8 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
       jj_consume_token(RPAREN);
       break;
     default:
-      jj_la1[28] = jj_gen;
-      if (jj_2_1(2147483647)) {
+      jj_la1[27] = jj_gen;
+      if (jj_2_2(2147483647)) {
         Function();
       } else {
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -1137,7 +1118,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
           Identifier();
           break;
         default:
-          jj_la1[29] = jj_gen;
+          jj_la1[28] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
@@ -1156,13 +1137,13 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
                                   jjtree.openNodeScope(jjtn000);Token t = null;
     try {
       t = jj_consume_token(IDENTIFIER);
-                         jjtree.closeNodeScope(jjtn000, true);
-                         jjtc000 = false;
-                         jjtn000.setImage(t.image);
+                     jjtree.closeNodeScope(jjtn000, true);
+                     jjtc000 = false;
+                     jjtn000.setImage(t.image);
     } finally {
-          if (jjtc000) {
-            jjtree.closeNodeScope(jjtn000, true);
-          }
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+      }
     }
   }
 
@@ -1172,27 +1153,24 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
  */
   final public void Function() throws ParseException {
  /*@bgen(jjtree) Function */
-        AstFunction jjtn000 = new AstFunction(JJTFUNCTION);
-        boolean jjtc000 = true;
-        jjtree.openNodeScope(jjtn000);Token t0 = null;
-        Token t1 = null;
+    AstFunction jjtn000 = new AstFunction(JJTFUNCTION);
+    boolean jjtc000 = true;
+    jjtree.openNodeScope(jjtn000);Token t0 = null;
+    Token t1 = null;
     try {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case IDENTIFIER:
+      if (jj_2_3(2)) {
         t0 = jj_consume_token(IDENTIFIER);
         jj_consume_token(COLON);
-        break;
-      default:
-        jj_la1[30] = jj_gen;
+      } else {
         ;
       }
       t1 = jj_consume_token(IDENTIFIER);
-                if (t0 != null) {
-                        jjtn000.setPrefix(t0.image);
-                        jjtn000.setLocalName(t1.image);
-                } else {
-                        jjtn000.setLocalName(t1.image);
-                }
+        if (t0 != null) {
+            jjtn000.setPrefix(t0.image);
+            jjtn000.setLocalName(t1.image);
+        } else {
+            jjtn000.setLocalName(t1.image);
+        }
       jj_consume_token(LPAREN);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case INTEGER_LITERAL:
@@ -1215,7 +1193,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
             ;
             break;
           default:
-            jj_la1[31] = jj_gen;
+            jj_la1[29] = jj_gen;
             break label_10;
           }
           jj_consume_token(COMMA);
@@ -1223,28 +1201,28 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
         }
         break;
       default:
-        jj_la1[32] = jj_gen;
+        jj_la1[30] = jj_gen;
         ;
       }
       jj_consume_token(RPAREN);
     } catch (Throwable jjte000) {
-          if (jjtc000) {
-            jjtree.clearNodeScope(jjtn000);
-            jjtc000 = false;
-          } else {
-            jjtree.popNode();
-          }
-          if (jjte000 instanceof RuntimeException) {
-            {if (true) throw (RuntimeException)jjte000;}
-          }
-          if (jjte000 instanceof ParseException) {
-            {if (true) throw (ParseException)jjte000;}
-          }
-          {if (true) throw (Error)jjte000;}
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
     } finally {
-          if (jjtc000) {
-            jjtree.closeNodeScope(jjtn000, true);
-          }
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+      }
     }
   }
 
@@ -1271,7 +1249,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
       Null();
       break;
     default:
-      jj_la1[33] = jj_gen;
+      jj_la1[31] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -1284,31 +1262,31 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
   final public void Boolean() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case TRUE:
-          AstTrue jjtn001 = new AstTrue(JJTTRUE);
-          boolean jjtc001 = true;
-          jjtree.openNodeScope(jjtn001);
+      AstTrue jjtn001 = new AstTrue(JJTTRUE);
+      boolean jjtc001 = true;
+      jjtree.openNodeScope(jjtn001);
       try {
         jj_consume_token(TRUE);
       } finally {
-          if (jjtc001) {
-            jjtree.closeNodeScope(jjtn001, true);
-          }
+      if (jjtc001) {
+        jjtree.closeNodeScope(jjtn001, true);
+      }
       }
       break;
     case FALSE:
-            AstFalse jjtn002 = new AstFalse(JJTFALSE);
-            boolean jjtc002 = true;
-            jjtree.openNodeScope(jjtn002);
+        AstFalse jjtn002 = new AstFalse(JJTFALSE);
+        boolean jjtc002 = true;
+        jjtree.openNodeScope(jjtn002);
       try {
         jj_consume_token(FALSE);
       } finally {
-            if (jjtc002) {
-              jjtree.closeNodeScope(jjtn002, true);
-            }
+        if (jjtc002) {
+          jjtree.closeNodeScope(jjtn002, true);
+        }
       }
       break;
     default:
-      jj_la1[34] = jj_gen;
+      jj_la1[32] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -1325,13 +1303,13 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
                                         jjtree.openNodeScope(jjtn000);Token t = null;
     try {
       t = jj_consume_token(FLOATING_POINT_LITERAL);
-                                     jjtree.closeNodeScope(jjtn000, true);
-                                     jjtc000 = false;
-                                     jjtn000.setImage(t.image);
+                                 jjtree.closeNodeScope(jjtn000, true);
+                                 jjtc000 = false;
+                                 jjtn000.setImage(t.image);
     } finally {
-          if (jjtc000) {
-            jjtree.closeNodeScope(jjtn000, true);
-          }
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+      }
     }
   }
 
@@ -1346,13 +1324,13 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
                             jjtree.openNodeScope(jjtn000);Token t = null;
     try {
       t = jj_consume_token(INTEGER_LITERAL);
-                              jjtree.closeNodeScope(jjtn000, true);
-                              jjtc000 = false;
-                              jjtn000.setImage(t.image);
+                          jjtree.closeNodeScope(jjtn000, true);
+                          jjtc000 = false;
+                          jjtn000.setImage(t.image);
     } finally {
-          if (jjtc000) {
-            jjtree.closeNodeScope(jjtn000, true);
-          }
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+      }
     }
   }
 
@@ -1367,13 +1345,13 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
                           jjtree.openNodeScope(jjtn000);Token t = null;
     try {
       t = jj_consume_token(STRING_LITERAL);
-                             jjtree.closeNodeScope(jjtn000, true);
-                             jjtc000 = false;
-                             jjtn000.setImage(t.image);
+                         jjtree.closeNodeScope(jjtn000, true);
+                         jjtc000 = false;
+                         jjtn000.setImage(t.image);
     } finally {
-          if (jjtc000) {
-            jjtree.closeNodeScope(jjtn000, true);
-          }
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+      }
     }
   }
 
@@ -1389,76 +1367,584 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
     try {
       jj_consume_token(NULL);
     } finally {
-          if (jjtc000) {
-            jjtree.closeNodeScope(jjtn000, true);
-          }
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+      }
     }
   }
 
-  final private boolean jj_2_1(int xla) {
+  private boolean jj_2_1(int xla) {
     jj_la = xla; jj_lastpos = jj_scanpos = token;
     try { return !jj_3_1(); }
     catch(LookaheadSuccess ls) { return true; }
     finally { jj_save(0, xla); }
   }
 
-  final private boolean jj_3R_11() {
+  private boolean jj_2_2(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_2(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(1, xla); }
+  }
+
+  private boolean jj_2_3(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_3(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(2, xla); }
+  }
+
+  private boolean jj_3R_24() {
+    if (jj_3R_30()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_31()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_12() {
     if (jj_scan_token(IDENTIFIER)) return true;
     if (jj_scan_token(COLON)) return true;
     return false;
   }
 
-  final private boolean jj_3_1() {
+  private boolean jj_3_2() {
     Token xsp;
     xsp = jj_scanpos;
-    if (jj_3R_11()) jj_scanpos = xsp;
+    if (jj_3R_12()) jj_scanpos = xsp;
     if (jj_scan_token(IDENTIFIER)) return true;
     if (jj_scan_token(LPAREN)) return true;
     return false;
   }
 
-  public ELParserTokenManager token_source;
-  SimpleCharStream jj_input_stream;
-  public Token token, jj_nt;
-  private int jj_ntk;
-  private Token jj_scanpos, jj_lastpos;
-  private int jj_la;
-  public boolean lookingAhead = false;
-  private boolean jj_semLA;
-  private int jj_gen;
-  final private int[] jj_la1 = new int[35];
-  static private int[] jj_la1_0;
-  static private int[] jj_la1_1;
-  static {
-      jj_la1_0();
-      jj_la1_1();
-   }
-   private static void jj_la1_0() {
-      jj_la1_0 = new int[] {0xe,0xe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfe000000,0x18000000,0x6000000,0x80000000,0x60000000,0xfe000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9d600,0x240000,0x9d600,0x240000,0x80000,0x0,0x0,0x1000000,0x9d600,0x1d600,0xc000,};
-   }
-   private static void jj_la1_1() {
-      jj_la1_1 = new int[] {0x0,0x0,0x10000,0x600,0x600,0x180,0x180,0x1e,0x6,0x18,0x1e,0x1,0x0,0x0,0x1,0x0,0x1,0xc000,0xc000,0x1e2000,0x60000,0x180000,0x1e2000,0x60,0x208860,0x0,0x200000,0x0,0x0,0x200000,0x200000,0x0,0x208860,0x0,0x0,};
-   }
-  final private JJCalls[] jj_2_rtns = new JJCalls[1];
-  private boolean jj_rescan = false;
-  private int jj_gc = 0;
+  private boolean jj_3R_33() {
+    if (jj_scan_token(MINUS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_68() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_25() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_32()) {
+    jj_scanpos = xsp;
+    if (jj_3R_33()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_32() {
+    if (jj_scan_token(PLUS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_58() {
+    if (jj_3R_68()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_20() {
+    if (jj_3R_24()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_25()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_57() {
+    if (jj_3R_67()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_56() {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_66()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_48() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_56()) {
+    jj_scanpos = xsp;
+    if (jj_3R_57()) {
+    jj_scanpos = xsp;
+    if (jj_3R_58()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_29() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(29)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(30)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_65() {
+    if (jj_scan_token(NULL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_28() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(31)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(32)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_27() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(25)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(26)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_21() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_26()) {
+    jj_scanpos = xsp;
+    if (jj_3R_27()) {
+    jj_scanpos = xsp;
+    if (jj_3R_28()) {
+    jj_scanpos = xsp;
+    if (jj_3R_29()) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_26() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(27)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(28)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_60() {
+    if (jj_scan_token(LBRACK)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_64() {
+    if (jj_scan_token(STRING_LITERAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_50() {
+    if (jj_3R_60()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_18() {
+    if (jj_3R_20()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_21()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_59() {
+    if (jj_scan_token(DOT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_23() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(35)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(36)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_63() {
+    if (jj_scan_token(INTEGER_LITERAL)) return true;
+    return false;
+  }
 
+  private boolean jj_3R_22() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(33)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(34)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_19() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_22()) {
+    jj_scanpos = xsp;
+    if (jj_3R_23()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_17() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(39)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(40)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_49() {
+    if (jj_3R_59()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_46() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_49()) {
+    jj_scanpos = xsp;
+    if (jj_3R_50()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_16() {
+    if (jj_3R_18()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_19()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_62() {
+    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_43() {
+    if (jj_3R_46()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_45() {
+    if (jj_3R_48()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_70() {
+    if (jj_scan_token(FALSE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_44() {
+    if (jj_3R_47()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_14() {
+    if (jj_3R_16()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_17()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_42() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_44()) {
+    jj_scanpos = xsp;
+    if (jj_3R_45()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_15() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(41)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(42)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_69() {
+    if (jj_scan_token(TRUE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_61() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_69()) {
+    jj_scanpos = xsp;
+    if (jj_3R_70()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_13() {
+    if (jj_3R_14()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_15()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_41() {
+    if (jj_3R_42()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_43()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_55() {
+    if (jj_3R_65()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_54() {
+    if (jj_3R_64()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_53() {
+    if (jj_3R_63()) return true;
+    return false;
+  }
+
+  private boolean jj_3_1() {
+    if (jj_scan_token(QUESTIONMARK)) return true;
+    if (jj_3R_11()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_52() {
+    if (jj_3R_62()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_37() {
+    if (jj_3R_41()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_51() {
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_47() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_51()) {
+    jj_scanpos = xsp;
+    if (jj_3R_52()) {
+    jj_scanpos = xsp;
+    if (jj_3R_53()) {
+    jj_scanpos = xsp;
+    if (jj_3R_54()) {
+    jj_scanpos = xsp;
+    if (jj_3R_55()) return true;
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_36() {
+    if (jj_scan_token(EMPTY)) return true;
+    if (jj_3R_30()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_11() {
+    if (jj_3R_13()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_1()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_35() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(37)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(38)) return true;
+    }
+    if (jj_3R_30()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_30() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_34()) {
+    jj_scanpos = xsp;
+    if (jj_3R_35()) {
+    jj_scanpos = xsp;
+    if (jj_3R_36()) {
+    jj_scanpos = xsp;
+    if (jj_3R_37()) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_34() {
+    if (jj_scan_token(MINUS)) return true;
+    if (jj_3R_30()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_66() {
+    if (jj_3R_11()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_40() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(51)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(52)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_39() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(49)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(50)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3_3() {
+    if (jj_scan_token(IDENTIFIER)) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_67() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_3()) jj_scanpos = xsp;
+    if (jj_scan_token(IDENTIFIER)) return true;
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_31() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_38()) {
+    jj_scanpos = xsp;
+    if (jj_3R_39()) {
+    jj_scanpos = xsp;
+    if (jj_3R_40()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_38() {
+    if (jj_scan_token(MULT)) return true;
+    return false;
+  }
+
+  /** Generated Token Manager. */
+  public ELParserTokenManager token_source;
+  SimpleCharStream jj_input_stream;
+  /** Current token. */
+  public Token token;
+  /** Next token. */
+  public Token jj_nt;
+  private int jj_ntk;
+  private Token jj_scanpos, jj_lastpos;
+  private int jj_la;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[33];
+  static private int[] jj_la1_0;
+  static private int[] jj_la1_1;
+  static {
+      jj_la1_init_0();
+      jj_la1_init_1();
+   }
+   private static void jj_la1_init_0() {
+      jj_la1_0 = new int[] {0xe,0xe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfe000000,0x18000000,0x6000000,0x80000000,0x60000000,0xfe000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9d600,0x240000,0x9d600,0x240000,0x80000,0x0,0x1000000,0x9d600,0x1d600,0xc000,};
+   }
+   private static void jj_la1_init_1() {
+      jj_la1_1 = new int[] {0x0,0x0,0x600,0x600,0x180,0x180,0x1e,0x6,0x18,0x1e,0x1,0x0,0x0,0x1,0x0,0x1,0xc000,0xc000,0x1e2000,0x60000,0x180000,0x1e2000,0x60,0x208860,0x0,0x200000,0x0,0x0,0x200000,0x0,0x208860,0x0,0x0,};
+   }
+  final private JJCalls[] jj_2_rtns = new JJCalls[3];
+  private boolean jj_rescan = false;
+  private int jj_gc = 0;
+
+  /** Constructor with InputStream. */
   public ELParser(java.io.InputStream stream) {
      this(stream, null);
   }
+  /** Constructor with InputStream and supplied encoding */
   public ELParser(java.io.InputStream stream, String encoding) {
     try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
     token_source = new ELParserTokenManager(jj_input_stream);
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
+  /** Reinitialise. */
   public void ReInit(java.io.InputStream stream) {
      ReInit(stream, null);
   }
+  /** Reinitialise. */
   public void ReInit(java.io.InputStream stream, String encoding) {
     try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
     token_source.ReInit(jj_input_stream);
@@ -1466,20 +1952,22 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
     jj_ntk = -1;
     jjtree.reset();
     jj_gen = 0;
-    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
+  /** Constructor. */
   public ELParser(java.io.Reader stream) {
     jj_input_stream = new SimpleCharStream(stream, 1, 1);
     token_source = new ELParserTokenManager(jj_input_stream);
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
+  /** Reinitialise. */
   public void ReInit(java.io.Reader stream) {
     jj_input_stream.ReInit(stream, 1, 1);
     token_source.ReInit(jj_input_stream);
@@ -1487,30 +1975,32 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
     jj_ntk = -1;
     jjtree.reset();
     jj_gen = 0;
-    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
+  /** Constructor with generated Token Manager. */
   public ELParser(ELParserTokenManager tm) {
     token_source = tm;
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
+  /** Reinitialise. */
   public void ReInit(ELParserTokenManager tm) {
     token_source = tm;
     token = new Token();
     jj_ntk = -1;
     jjtree.reset();
     jj_gen = 0;
-    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
-  final private Token jj_consume_token(int kind) throws ParseException {
+  private Token jj_consume_token(int kind) throws ParseException {
     Token oldToken;
     if ((oldToken = token).next != null) token = token.next;
     else token = token.next = token_source.getNextToken();
@@ -1536,7 +2026,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
 
   static private final class LookaheadSuccess extends java.lang.Error { }
   final private LookaheadSuccess jj_ls = new LookaheadSuccess();
-  final private boolean jj_scan_token(int kind) {
+  private boolean jj_scan_token(int kind) {
     if (jj_scanpos == jj_lastpos) {
       jj_la--;
       if (jj_scanpos.next == null) {
@@ -1557,6 +2047,8 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
     return false;
   }
 
+
+/** Get the next Token. */
   final public Token getNextToken() {
     if (token.next != null) token = token.next;
     else token = token.next = token_source.getNextToken();
@@ -1565,8 +2057,9 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
     return token;
   }
 
+/** Get the specific Token. */
   final public Token getToken(int index) {
-    Token t = lookingAhead ? jj_scanpos : token;
+    Token t = token;
     for (int i = 0; i < index; i++) {
       if (t.next != null) t = t.next;
       else t = t.next = token_source.getNextToken();
@@ -1574,14 +2067,14 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
     return t;
   }
 
-  final private int jj_ntk() {
+  private int jj_ntk() {
     if ((jj_nt=token.next) == null)
       return (jj_ntk = (token.next=token_source.getNextToken()).kind);
     else
       return (jj_ntk = jj_nt.kind);
   }
 
-  private java.util.Vector jj_expentries = new java.util.Vector();
+  private java.util.List jj_expentries = new java.util.ArrayList();
   private int[] jj_expentry;
   private int jj_kind = -1;
   private int[] jj_lasttokens = new int[100];
@@ -1596,36 +2089,31 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
       for (int i = 0; i < jj_endpos; i++) {
         jj_expentry[i] = jj_lasttokens[i];
       }
-      boolean exists = false;
-      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
-        int[] oldentry = (int[])(e.nextElement());
+      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
+        int[] oldentry = (int[])(it.next());
         if (oldentry.length == jj_expentry.length) {
-          exists = true;
           for (int i = 0; i < jj_expentry.length; i++) {
             if (oldentry[i] != jj_expentry[i]) {
-              exists = false;
-              break;
+              continue jj_entries_loop;
             }
           }
-          if (exists) break;
+          jj_expentries.add(jj_expentry);
+          break jj_entries_loop;
         }
       }
-      if (!exists) jj_expentries.addElement(jj_expentry);
       if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
     }
   }
 
+  /** Generate ParseException. */
   public ParseException generateParseException() {
-    jj_expentries.removeAllElements();
+    jj_expentries.clear();
     boolean[] la1tokens = new boolean[59];
-    for (int i = 0; i < 59; i++) {
-      la1tokens[i] = false;
-    }
     if (jj_kind >= 0) {
       la1tokens[jj_kind] = true;
       jj_kind = -1;
     }
-    for (int i = 0; i < 35; i++) {
+    for (int i = 0; i < 33; i++) {
       if (jj_la1[i] == jj_gen) {
         for (int j = 0; j < 32; j++) {
           if ((jj_la1_0[i] & (1<<j)) != 0) {
@@ -1641,7 +2129,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
       if (la1tokens[i]) {
         jj_expentry = new int[1];
         jj_expentry[0] = i;
-        jj_expentries.addElement(jj_expentry);
+        jj_expentries.add(jj_expentry);
       }
     }
     jj_endpos = 0;
@@ -1649,20 +2137,22 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
     jj_add_error_token(0, 0);
     int[][] exptokseq = new int[jj_expentries.size()][];
     for (int i = 0; i < jj_expentries.size(); i++) {
-      exptokseq[i] = (int[])jj_expentries.elementAt(i);
+      exptokseq[i] = (int[])jj_expentries.get(i);
     }
     return new ParseException(token, exptokseq, tokenImage);
   }
 
+  /** Enable tracing. */
   final public void enable_tracing() {
   }
 
+  /** Disable tracing. */
   final public void disable_tracing() {
   }
 
-  final private void jj_rescan_token() {
+  private void jj_rescan_token() {
     jj_rescan = true;
-    for (int i = 0; i < 1; i++) {
+    for (int i = 0; i < 3; i++) {
     try {
       JJCalls p = jj_2_rtns[i];
       do {
@@ -1670,6 +2160,8 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
           jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
           switch (i) {
             case 0: jj_3_1(); break;
+            case 1: jj_3_2(); break;
+            case 2: jj_3_3(); break;
           }
         }
         p = p.next;
@@ -1679,7 +2171,7 @@ public class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParser
     jj_rescan = false;
   }
 
-  final private void jj_save(int index, int xla) {
+  private void jj_save(int index, int xla) {
     JJCalls p = jj_2_rtns[index];
     while (p.gen > jj_gen) {
       if (p.next == null) { p = p.next = new JJCalls(); break; }

==================================================
ELParserTokenManager.java
index 6d42eb53ef..7fcbf1a651 100644
--- a/java/org/apache/el/parser/ELParserConstants.java
+++ b/java/org/apache/el/parser/ELParserConstants.java
@@ -1,82 +1,128 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 /* Generated By:JJTree&JavaCC: Do not edit this line. ELParserConstants.java */
 package org.apache.el.parser;
 
+
+/**
+ * Token literal values and constants.
+ * Generated by org.javacc.parser.OtherFilesGen#start()
+ */
 public interface ELParserConstants {
 
+  /** End of File. */
   int EOF = 0;
+  /** RegularExpression Id. */
   int LITERAL_EXPRESSION = 1;
+  /** RegularExpression Id. */
   int START_DYNAMIC_EXPRESSION = 2;
+  /** RegularExpression Id. */
   int START_DEFERRED_EXPRESSION = 3;
+  /** RegularExpression Id. */
   int INTEGER_LITERAL = 9;
+  /** RegularExpression Id. */
   int FLOATING_POINT_LITERAL = 10;
+  /** RegularExpression Id. */
   int EXPONENT = 11;
+  /** RegularExpression Id. */
   int STRING_LITERAL = 12;
+  /** RegularExpression Id. */
   int BADLY_ESCAPED_STRING_LITERAL = 13;
+  /** RegularExpression Id. */
   int TRUE = 14;
+  /** RegularExpression Id. */
   int FALSE = 15;
+  /** RegularExpression Id. */
   int NULL = 16;
+  /** RegularExpression Id. */
   int END_EXPRESSION = 17;
+  /** RegularExpression Id. */
   int DOT = 18;
+  /** RegularExpression Id. */
   int LPAREN = 19;
+  /** RegularExpression Id. */
   int RPAREN = 20;
+  /** RegularExpression Id. */
   int LBRACK = 21;
+  /** RegularExpression Id. */
   int RBRACK = 22;
+  /** RegularExpression Id. */
   int COLON = 23;
+  /** RegularExpression Id. */
   int COMMA = 24;
+  /** RegularExpression Id. */
   int GT0 = 25;
+  /** RegularExpression Id. */
   int GT1 = 26;
+  /** RegularExpression Id. */
   int LT0 = 27;
+  /** RegularExpression Id. */
   int LT1 = 28;
+  /** RegularExpression Id. */
   int GE0 = 29;
+  /** RegularExpression Id. */
   int GE1 = 30;
+  /** RegularExpression Id. */
   int LE0 = 31;
+  /** RegularExpression Id. */
   int LE1 = 32;
+  /** RegularExpression Id. */
   int EQ0 = 33;
+  /** RegularExpression Id. */
   int EQ1 = 34;
+  /** RegularExpression Id. */
   int NE0 = 35;
+  /** RegularExpression Id. */
   int NE1 = 36;
+  /** RegularExpression Id. */
   int NOT0 = 37;
+  /** RegularExpression Id. */
   int NOT1 = 38;
+  /** RegularExpression Id. */
   int AND0 = 39;
+  /** RegularExpression Id. */
   int AND1 = 40;
+  /** RegularExpression Id. */
   int OR0 = 41;
+  /** RegularExpression Id. */
   int OR1 = 42;
+  /** RegularExpression Id. */
   int EMPTY = 43;
+  /** RegularExpression Id. */
   int INSTANCEOF = 44;
+  /** RegularExpression Id. */
   int MULT = 45;
+  /** RegularExpression Id. */
   int PLUS = 46;
+  /** RegularExpression Id. */
   int MINUS = 47;
+  /** RegularExpression Id. */
   int QUESTIONMARK = 48;
+  /** RegularExpression Id. */
   int DIV0 = 49;
+  /** RegularExpression Id. */
   int DIV1 = 50;
+  /** RegularExpression Id. */
   int MOD0 = 51;
+  /** RegularExpression Id. */
   int MOD1 = 52;
+  /** RegularExpression Id. */
   int IDENTIFIER = 53;
+  /** RegularExpression Id. */
   int FUNCTIONSUFFIX = 54;
+  /** RegularExpression Id. */
   int IMPL_OBJ_START = 55;
+  /** RegularExpression Id. */
   int LETTER = 56;
+  /** RegularExpression Id. */
   int DIGIT = 57;
+  /** RegularExpression Id. */
   int ILLEGAL_CHARACTER = 58;
 
+  /** Lexical state. */
   int DEFAULT = 0;
+  /** Lexical state. */
   int IN_EXPRESSION = 1;
 
+  /** Literal token values. */
   String[] tokenImage = {
     "<EOF>",
     "<LITERAL_EXPRESSION>",

==================================================
ELParserTreeConstants.java
index 228e438f7b..ab863de478 100644
--- a/java/org/apache/el/parser/ELParserTokenManager.java
+++ b/java/org/apache/el/parser/ELParserTokenManager.java
@@ -1,27 +1,15 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 /* Generated By:JJTree&JavaCC: Do not edit this line. ELParserTokenManager.java */
 package org.apache.el.parser;
 import java.io.StringReader;
 import javax.el.ELException;
 
+/** Token Manager. */
 public class ELParserTokenManager implements ELParserConstants
 {
+
+  /** Debug output. */
   public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
   public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
 private final int jjStopStringLiteralDfa_0(int pos, long active0)
 {
@@ -49,21 +37,13 @@ private final int jjStartNfa_0(int pos, long active0)
 {
    return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
 }
-private final int jjStopAtPos(int pos, int kind)
+private int jjStopAtPos(int pos, int kind)
 {
    jjmatchedKind = kind;
    jjmatchedPos = pos;
    return pos + 1;
 }
-private final int jjStartNfaWithStates_0(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_0(state, pos + 1);
-}
-private final int jjMoveStringLiteralDfa0_0()
+private int jjMoveStringLiteralDfa0_0()
 {
    switch(curChar)
    {
@@ -77,7 +57,7 @@ private final int jjMoveStringLiteralDfa0_0()
          return jjMoveNfa_0(7, 0);
    }
 }
-private final int jjMoveStringLiteralDfa1_0(long active0)
+private int jjMoveStringLiteralDfa1_0(long active0)
 {
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) {
@@ -97,35 +77,13 @@ private final int jjMoveStringLiteralDfa1_0(long active0)
    }
    return jjStartNfa_0(0, active0);
 }
-private final void jjCheckNAdd(int state)
-{
-   if (jjrounds[state] != jjround)
-   {
-      jjstateSet[jjnewStateCnt++] = state;
-      jjrounds[state] = jjround;
-   }
-}
-private final void jjAddStates(int start, int end)
+private int jjStartNfaWithStates_0(int pos, int kind, int state)
 {
-   do {
-      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
-   } while (start++ != end);
-}
-private final void jjCheckNAddTwoStates(int state1, int state2)
-{
-   jjCheckNAdd(state1);
-   jjCheckNAdd(state2);
-}
-private final void jjCheckNAddStates(int start, int end)
-{
-   do {
-      jjCheckNAdd(jjnextStates[start]);
-   } while (start++ != end);
-}
-private final void jjCheckNAddStates(int start)
-{
-   jjCheckNAdd(jjnextStates[start]);
-   jjCheckNAdd(jjnextStates[start + 1]);
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_0(state, pos + 1);
 }
 static final long[] jjbitVec0 = {
    0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
@@ -133,14 +91,13 @@ static final long[] jjbitVec0 = {
 static final long[] jjbitVec2 = {
    0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
 };
-private final int jjMoveNfa_0(int startState, int curPos)
+private int jjMoveNfa_0(int startState, int curPos)
 {
-   int[] nextStates;
    int startsAt = 0;
    jjnewStateCnt = 8;
    int i = 1;
    jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
+   int kind = 0x7fffffff;
    for (;;)
    {
       if (++jjround == 0x7fffffff)
@@ -148,7 +105,7 @@ private final int jjMoveNfa_0(int startState, int curPos)
       if (curChar < 64)
       {
          long l = 1L << curChar;
-         MatchLoop: do
+         do
          {
             switch(jjstateSet[--i])
             {
@@ -212,7 +169,7 @@ private final int jjMoveNfa_0(int startState, int curPos)
       else if (curChar < 128)
       {
          long l = 1L << (curChar & 077);
-         MatchLoop: do
+         do
          {
             switch(jjstateSet[--i])
             {
@@ -263,7 +220,7 @@ private final int jjMoveNfa_0(int startState, int curPos)
          long l1 = 1L << (hiByte & 077);
          int i2 = (curChar & 0xff) >> 6;
          long l2 = 1L << (curChar & 077);
-         MatchLoop: do
+         do
          {
             switch(jjstateSet[--i])
             {
@@ -387,15 +344,7 @@ private final int jjStartNfa_1(int pos, long active0)
 {
    return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
 }
-private final int jjStartNfaWithStates_1(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_1(state, pos + 1);
-}
-private final int jjMoveStringLiteralDfa0_1()
+private int jjMoveStringLiteralDfa0_1()
 {
    switch(curChar)
    {
@@ -468,7 +417,7 @@ private final int jjMoveStringLiteralDfa0_1()
          return jjMoveNfa_1(0, 0);
    }
 }
-private final int jjMoveStringLiteralDfa1_1(long active0)
+private int jjMoveStringLiteralDfa1_1(long active0)
 {
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) {
@@ -534,10 +483,10 @@ private final int jjMoveStringLiteralDfa1_1(long active0)
    }
    return jjStartNfa_1(0, active0);
 }
-private final int jjMoveStringLiteralDfa2_1(long old0, long active0)
+private int jjMoveStringLiteralDfa2_1(long old0, long active0)
 {
    if (((active0 &= old0)) == 0L)
-      return jjStartNfa_1(0, old0); 
+      return jjStartNfa_1(0, old0);
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) {
       jjStopStringLiteralDfa_1(1, active0);
@@ -572,10 +521,10 @@ private final int jjMoveStringLiteralDfa2_1(long old0, long active0)
    }
    return jjStartNfa_1(1, active0);
 }
-private final int jjMoveStringLiteralDfa3_1(long old0, long active0)
+private int jjMoveStringLiteralDfa3_1(long old0, long active0)
 {
    if (((active0 &= old0)) == 0L)
-      return jjStartNfa_1(1, old0); 
+      return jjStartNfa_1(1, old0);
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) {
       jjStopStringLiteralDfa_1(2, active0);
@@ -600,10 +549,10 @@ private final int jjMoveStringLiteralDfa3_1(long old0, long active0)
    }
    return jjStartNfa_1(2, active0);
 }
-private final int jjMoveStringLiteralDfa4_1(long old0, long active0)
+private int jjMoveStringLiteralDfa4_1(long old0, long active0)
 {
    if (((active0 &= old0)) == 0L)
-      return jjStartNfa_1(2, old0); 
+      return jjStartNfa_1(2, old0);
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) {
       jjStopStringLiteralDfa_1(3, active0);
@@ -626,10 +575,10 @@ private final int jjMoveStringLiteralDfa4_1(long old0, long active0)
    }
    return jjStartNfa_1(3, active0);
 }
-private final int jjMoveStringLiteralDfa5_1(long old0, long active0)
+private int jjMoveStringLiteralDfa5_1(long old0, long active0)
 {
    if (((active0 &= old0)) == 0L)
-      return jjStartNfa_1(3, old0); 
+      return jjStartNfa_1(3, old0);
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) {
       jjStopStringLiteralDfa_1(4, active0);
@@ -644,10 +593,10 @@ private final int jjMoveStringLiteralDfa5_1(long old0, long active0)
    }
    return jjStartNfa_1(4, active0);
 }
-private final int jjMoveStringLiteralDfa6_1(long old0, long active0)
+private int jjMoveStringLiteralDfa6_1(long old0, long active0)
 {
    if (((active0 &= old0)) == 0L)
-      return jjStartNfa_1(4, old0); 
+      return jjStartNfa_1(4, old0);
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) {
       jjStopStringLiteralDfa_1(5, active0);
@@ -662,10 +611,10 @@ private final int jjMoveStringLiteralDfa6_1(long old0, long active0)
    }
    return jjStartNfa_1(5, active0);
 }
-private final int jjMoveStringLiteralDfa7_1(long old0, long active0)
+private int jjMoveStringLiteralDfa7_1(long old0, long active0)
 {
    if (((active0 &= old0)) == 0L)
-      return jjStartNfa_1(5, old0); 
+      return jjStartNfa_1(5, old0);
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) {
       jjStopStringLiteralDfa_1(6, active0);
@@ -680,10 +629,10 @@ private final int jjMoveStringLiteralDfa7_1(long old0, long active0)
    }
    return jjStartNfa_1(6, active0);
 }
-private final int jjMoveStringLiteralDfa8_1(long old0, long active0)
+private int jjMoveStringLiteralDfa8_1(long old0, long active0)
 {
    if (((active0 &= old0)) == 0L)
-      return jjStartNfa_1(6, old0); 
+      return jjStartNfa_1(6, old0);
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) {
       jjStopStringLiteralDfa_1(7, active0);
@@ -698,10 +647,10 @@ private final int jjMoveStringLiteralDfa8_1(long old0, long active0)
    }
    return jjStartNfa_1(7, active0);
 }
-private final int jjMoveStringLiteralDfa9_1(long old0, long active0)
+private int jjMoveStringLiteralDfa9_1(long old0, long active0)
 {
    if (((active0 &= old0)) == 0L)
-      return jjStartNfa_1(7, old0); 
+      return jjStartNfa_1(7, old0);
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) {
       jjStopStringLiteralDfa_1(8, active0);
@@ -718,6 +667,14 @@ private final int jjMoveStringLiteralDfa9_1(long old0, long active0)
    }
    return jjStartNfa_1(8, active0);
 }
+private int jjStartNfaWithStates_1(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_1(state, pos + 1);
+}
 static final long[] jjbitVec3 = {
    0x1ff00000fffffffeL, 0xffffffffffffc000L, 0xffffffffL, 0x600000000000000L
 };
@@ -736,14 +693,13 @@ static final long[] jjbitVec7 = {
 static final long[] jjbitVec8 = {
    0x3fffffffffffL, 0x0L, 0x0L, 0x0L
 };
-private final int jjMoveNfa_1(int startState, int curPos)
+private int jjMoveNfa_1(int startState, int curPos)
 {
-   int[] nextStates;
    int startsAt = 0;
    jjnewStateCnt = 36;
    int i = 1;
    jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
+   int kind = 0x7fffffff;
    for (;;)
    {
       if (++jjround == 0x7fffffff)
@@ -751,7 +707,7 @@ private final int jjMoveNfa_1(int startState, int curPos)
       if (curChar < 64)
       {
          long l = 1L << curChar;
-         MatchLoop: do
+         do
          {
             switch(jjstateSet[--i])
             {
@@ -941,7 +897,7 @@ private final int jjMoveNfa_1(int startState, int curPos)
       else if (curChar < 128)
       {
          long l = 1L << (curChar & 077);
-         MatchLoop: do
+         do
          {
             switch(jjstateSet[--i])
             {
@@ -1048,7 +1004,7 @@ private final int jjMoveNfa_1(int startState, int curPos)
          long l1 = 1L << (hiByte & 077);
          int i2 = (curChar & 0xff) >> 6;
          long l2 = 1L << (curChar & 077);
-         MatchLoop: do
+         do
          {
             switch(jjstateSet[--i])
             {
@@ -1136,7 +1092,7 @@ private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, lo
    {
       case 0:
          return ((jjbitVec2[i2] & l2) != 0L);
-      default : 
+      default :
          if ((jjbitVec0[i1] & l1) != 0L)
             return true;
          return false;
@@ -1156,12 +1112,14 @@ private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, lo
          return ((jjbitVec7[i2] & l2) != 0L);
       case 61:
          return ((jjbitVec8[i2] & l2) != 0L);
-      default : 
+      default :
          if ((jjbitVec3[i1] & l1) != 0L)
             return true;
          return false;
    }
 }
+
+/** Token literal values. */
 public static final String[] jjstrLiteralImages = {
 "", null, "\44\173", "\43\173", null, null, null, null, null, null, null, null, 
 null, null, "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\175", 
@@ -1170,10 +1128,14 @@ null, null, "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\17
 "\156\145", "\41", "\156\157\164", "\46\46", "\141\156\144", "\174\174", "\157\162", 
 "\145\155\160\164\171", "\151\156\163\164\141\156\143\145\157\146", "\52", "\53", "\55", "\77", "\57", 
 "\144\151\166", "\45", "\155\157\144", null, null, null, null, null, null, };
+
+/** Lexer state names. */
 public static final String[] lexStateNames = {
-   "DEFAULT", 
-   "IN_EXPRESSION", 
+   "DEFAULT",
+   "IN_EXPRESSION",
 };
+
+/** Lex State array. */
 public static final int[] jjnewLexState = {
    -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, 
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
@@ -1189,15 +1151,20 @@ protected SimpleCharStream input_stream;
 private final int[] jjrounds = new int[36];
 private final int[] jjstateSet = new int[72];
 protected char curChar;
+/** Constructor. */
 public ELParserTokenManager(SimpleCharStream stream){
    if (SimpleCharStream.staticFlag)
       throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
    input_stream = stream;
 }
+
+/** Constructor. */
 public ELParserTokenManager(SimpleCharStream stream, int lexState){
    this(stream);
    SwitchTo(lexState);
 }
+
+/** Reinitialise parser. */
 public void ReInit(SimpleCharStream stream)
 {
    jjmatchedPos = jjnewStateCnt = 0;
@@ -1205,18 +1172,22 @@ public void ReInit(SimpleCharStream stream)
    input_stream = stream;
    ReInitRounds();
 }
-private final void ReInitRounds()
+private void ReInitRounds()
 {
    int i;
    jjround = 0x80000001;
    for (i = 36; i-- > 0;)
       jjrounds[i] = 0x80000000;
 }
+
+/** Reinitialise parser. */
 public void ReInit(SimpleCharStream stream, int lexState)
 {
    ReInit(stream);
    SwitchTo(lexState);
 }
+
+/** Switch to specified lex state. */
 public void SwitchTo(int lexState)
 {
    if (lexState >= 2 || lexState < 0)
@@ -1227,14 +1198,25 @@ public void SwitchTo(int lexState)
 
 protected Token jjFillToken()
 {
-   Token t = Token.newToken(jjmatchedKind);
-   t.kind = jjmatchedKind;
+   final Token t;
+   final String curTokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
    String im = jjstrLiteralImages[jjmatchedKind];
-   t.image = (im == null) ? input_stream.GetImage() : im;
-   t.beginLine = input_stream.getBeginLine();
-   t.beginColumn = input_stream.getBeginColumn();
-   t.endLine = input_stream.getEndLine();
-   t.endColumn = input_stream.getEndColumn();
+   curTokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = Token.newToken(jjmatchedKind, curTokenImage);
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
    return t;
 }
 
@@ -1245,22 +1227,21 @@ int jjround;
 int jjmatchedPos;
 int jjmatchedKind;
 
+/** Get the next Token. */
 public Token getNextToken() 
 {
-  int kind;
-  Token specialToken = null;
   Token matchedToken;
   int curPos = 0;
 
   EOFLoop :
   for (;;)
-  {   
-   try   
-   {     
+  {
+   try
+   {
       curChar = input_stream.BeginToken();
-   }     
+   }
    catch(java.io.IOException e)
-   {        
+   {
       jjmatchedKind = 0;
       matchedToken = jjFillToken();
       return matchedToken;
@@ -1329,4 +1310,31 @@ public Token getNextToken()
   }
 }
 
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
 }

==================================================
JJTELParserState.java
index b0402fd7a6..5d911df6d8 100644
--- a/java/org/apache/el/parser/ELParserTreeConstants.java
+++ b/java/org/apache/el/parser/ELParserTreeConstants.java
@@ -1,21 +1,4 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/* Generated By:JJTree: Do not edit this line. ./ELParserTreeConstants.java */
-
+/* Generated By:JavaCC: Do not edit this line. ELParserTreeConstants.java Version 4.1 */
 package org.apache.el.parser;
 
 public interface ELParserTreeConstants
@@ -91,3 +74,4 @@ public interface ELParserTreeConstants
     "Null",
   };
 }
+/* JavaCC - OriginalChecksum=3f8a43fb30bdf082a70de7eb7b15fdf1 (do not edit this line) */

==================================================
ParseException.java
index f28d402148..267ead9a35 100644
--- a/java/org/apache/el/parser/JJTELParserState.java
+++ b/java/org/apache/el/parser/JJTELParserState.java
@@ -1,34 +1,17 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/* Generated By:JJTree: Do not edit this line. /tomc/web.align/webtier-alignment/prototype/el-ri/src/com/sun/el/parser/JJTELParserState.java */
-
+/* Generated By:JavaCC: Do not edit this line. JJTELParserState.java Version 4.1 */
 package org.apache.el.parser;
 
-class JJTELParserState {
-  private java.util.Stack nodes;
-  private java.util.Stack marks;
+public class JJTELParserState {
+  private java.util.List nodes;
+  private java.util.List marks;
 
-  private int sp;		// number of nodes on stack
-  private int mk;		// current mark
+  private int sp;        // number of nodes on stack
+  private int mk;        // current mark
   private boolean node_created;
 
-  JJTELParserState() {
-    nodes = new java.util.Stack();
-    marks = new java.util.Stack();
+  public JJTELParserState() {
+    nodes = new java.util.ArrayList();
+    marks = new java.util.ArrayList();
     sp = 0;
     mk = 0;
   }
@@ -36,62 +19,62 @@ class JJTELParserState {
   /* Determines whether the current node was actually closed and
      pushed.  This should only be called in the final user action of a
      node scope.  */
-  boolean nodeCreated() {
+  public boolean nodeCreated() {
     return node_created;
   }
 
   /* Call this to reinitialize the node stack.  It is called
      automatically by the parser's ReInit() method. */
-  void reset() {
-    nodes.removeAllElements();
-    marks.removeAllElements();
+  public void reset() {
+    nodes.clear();
+    marks.clear();
     sp = 0;
     mk = 0;
   }
 
   /* Returns the root node of the AST.  It only makes sense to call
      this after a successful parse. */
-  Node rootNode() {
-    return (Node)nodes.elementAt(0);
+  public Node rootNode() {
+    return (Node)nodes.get(0);
   }
 
   /* Pushes a node on to the stack. */
-  void pushNode(Node n) {
-    nodes.push(n);
+  public void pushNode(Node n) {
+    nodes.add(n);
     ++sp;
   }
 
   /* Returns the node on the top of the stack, and remove it from the
      stack.  */
-  Node popNode() {
+  public Node popNode() {
     if (--sp < mk) {
-      mk = ((Integer)marks.pop()).intValue();
+      mk = ((Integer)marks.remove(marks.size()-1)).intValue();
     }
-    return (Node)nodes.pop();
+    return (Node)nodes.remove(nodes.size()-1);
   }
 
   /* Returns the node currently on the top of the stack. */
-  Node peekNode() {
-    return (Node)nodes.peek();
+  public Node peekNode() {
+    return (Node)nodes.get(nodes.size()-1);
   }
 
   /* Returns the number of children on the stack in the current node
      scope. */
-  int nodeArity() {
+  public int nodeArity() {
     return sp - mk;
   }
 
 
-  void clearNodeScope(Node n) {
+  public void clearNodeScope(Node n) {
     while (sp > mk) {
       popNode();
     }
-    mk = ((Integer)marks.pop()).intValue();
+    mk = ((Integer)marks.remove(marks.size()-1)).intValue();
   }
 
 
-  void openNodeScope(Node n) {
-    marks.push(new Integer(mk));
+  public void openNodeScope(Node n) {
+    marks.add(new Integer(mk));
     mk = sp;
     n.jjtOpen();
   }
@@ -101,8 +84,8 @@ class JJTELParserState {
      children.  That number of nodes are popped from the stack and
      made the children of the definite node.  Then the definite node
      is pushed on to the stack. */
-  void closeNodeScope(Node n, int num) {
-    mk = ((Integer)marks.pop()).intValue();
+  public void closeNodeScope(Node n, int num) {
+    mk = ((Integer)marks.remove(marks.size()-1)).intValue();
     while (num-- > 0) {
       Node c = popNode();
       c.jjtSetParent(n);
@@ -116,24 +99,25 @@ class JJTELParserState {
 
   /* A conditional node is constructed if its condition is true.  All
      the nodes that have been pushed since the node was opened are
-     made children of the the conditional node, which is then pushed
+     made children of the conditional node, which is then pushed
      on to the stack.  If the condition is false the node is not
      constructed and they are left on the stack. */
-  void closeNodeScope(Node n, boolean condition) {
+  public void closeNodeScope(Node n, boolean condition) {
     if (condition) {
       int a = nodeArity();
-      mk = ((Integer)marks.pop()).intValue();
+      mk = ((Integer)marks.remove(marks.size()-1)).intValue();
       while (a-- > 0) {
-	Node c = popNode();
-	c.jjtSetParent(n);
-	n.jjtAddChild(c, a);
+        Node c = popNode();
+        c.jjtSetParent(n);
+        n.jjtAddChild(c, a);
       }
       n.jjtClose();
       pushNode(n);
       node_created = true;
     } else {
-      mk = ((Integer)marks.pop()).intValue();
+      mk = ((Integer)marks.remove(marks.size()-1)).intValue();
       node_created = false;
     }
   }
 }
+/* JavaCC - OriginalChecksum=9497b88da93266c314e4e50d08492496 (do not edit this line) */

==================================================
SimpleCharStream.java
index 278b3276a7..b86bdf1cc6 100644
--- a/java/org/apache/el/parser/ParseException.java
+++ b/java/org/apache/el/parser/ParseException.java
@@ -1,20 +1,5 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 4.1 */
+/* JavaCCOptions:KEEP_LINE_COL=null */
 package org.apache.el.parser;
 
 /**
@@ -67,6 +52,7 @@ public class ParseException extends Exception {
     specialConstructor = false;
   }
 
+  /** Constructor with message. */
   public ParseException(String message) {
     super(message);
     specialConstructor = false;
@@ -121,7 +107,7 @@ public class ParseException extends Exception {
         maxSize = expectedTokenSequences[i].length;
       }
       for (int j = 0; j < expectedTokenSequences[i].length; j++) {
-        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(" ");
+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
       }
       if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
         expected.append("...");
@@ -136,8 +122,11 @@ public class ParseException extends Exception {
         retval += tokenImage[0];
         break;
       }
+      retval += " " + tokenImage[tok.kind];
+      retval += " \"";
       retval += add_escapes(tok.image);
-      tok = tok.next; 
+      retval += " \"";
+      tok = tok.next;
     }
     retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
     retval += "." + eol;
@@ -154,7 +143,7 @@ public class ParseException extends Exception {
    * The end of line string for this machine.
    */
   protected String eol = System.getProperty("line.separator", "\n");
- 
+
   /**
    * Used to convert raw characters to their escaped version
    * when these raw version cannot be used as part of an ASCII
@@ -206,3 +195,4 @@ public class ParseException extends Exception {
    }
 
 }
+/* JavaCC - OriginalChecksum=a147e4edaa2a39e08e6f250c30247549 (do not edit this line) */

==================================================
Token.java
index 755337c5a0..13205e7894 100644
--- a/java/org/apache/el/parser/SimpleCharStream.java
+++ b/java/org/apache/el/parser/SimpleCharStream.java
@@ -1,20 +1,5 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.0 */
+/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.1 */
+/* JavaCCOptions:STATIC=false */
 package org.apache.el.parser;
 
 /**
@@ -24,10 +9,12 @@ package org.apache.el.parser;
 
 public class SimpleCharStream
 {
+/** Whether parser is static. */
   public static final boolean staticFlag = false;
   int bufsize;
   int available;
   int tokenBegin;
+/** Position in buffer. */
   public int bufpos = -1;
   protected int bufline[];
   protected int bufcolumn[];
@@ -144,6 +131,7 @@ public class SimpleCharStream
      }
   }
 
+/** Start. */
   public char BeginToken() throws java.io.IOException
   {
      tokenBegin = -1;
@@ -193,6 +181,7 @@ public class SimpleCharStream
      bufcolumn[bufpos] = column;
   }
 
+/** Read a character. */
   public char readChar() throws java.io.IOException
   {
      if (inBuf > 0)
@@ -211,11 +200,11 @@ public class SimpleCharStream
      char c = buffer[bufpos];
 
      UpdateLineColumn(c);
-     return (c);
+     return c;
   }
 
   /**
-   * @deprecated 
+   * @deprecated
    * @see #getEndColumn
    */
 
@@ -224,7 +213,7 @@ public class SimpleCharStream
   }
 
   /**
-   * @deprecated 
+   * @deprecated
    * @see #getEndLine
    */
 
@@ -232,22 +221,27 @@ public class SimpleCharStream
      return bufline[bufpos];
   }
 
+  /** Get token end column number. */
   public int getEndColumn() {
      return bufcolumn[bufpos];
   }
 
+  /** Get token end line number. */
   public int getEndLine() {
      return bufline[bufpos];
   }
 
+  /** Get token beginning column number. */
   public int getBeginColumn() {
      return bufcolumn[tokenBegin];
   }
 
+  /** Get token beginning line number. */
   public int getBeginLine() {
      return bufline[tokenBegin];
   }
 
+/** Backup a number of characters. */
   public void backup(int amount) {
 
     inBuf += amount;
@@ -255,6 +249,7 @@ public class SimpleCharStream
        bufpos += bufsize;
   }
 
+  /** Constructor. */
   public SimpleCharStream(java.io.Reader dstream, int startline,
   int startcolumn, int buffersize)
   {
@@ -268,16 +263,20 @@ public class SimpleCharStream
     bufcolumn = new int[buffersize];
   }
 
+  /** Constructor. */
   public SimpleCharStream(java.io.Reader dstream, int startline,
                           int startcolumn)
   {
      this(dstream, startline, startcolumn, 4096);
   }
 
+  /** Constructor. */
   public SimpleCharStream(java.io.Reader dstream)
   {
      this(dstream, 1, 1, 4096);
   }
+
+  /** Reinitialise. */
   public void ReInit(java.io.Reader dstream, int startline,
   int startcolumn, int buffersize)
   {
@@ -297,81 +296,96 @@ public class SimpleCharStream
     bufpos = -1;
   }
 
+  /** Reinitialise. */
   public void ReInit(java.io.Reader dstream, int startline,
                      int startcolumn)
   {
      ReInit(dstream, startline, startcolumn, 4096);
   }
 
+  /** Reinitialise. */
   public void ReInit(java.io.Reader dstream)
   {
      ReInit(dstream, 1, 1, 4096);
   }
+  /** Constructor. */
   public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
   int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
   {
      this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
   }
 
+  /** Constructor. */
   public SimpleCharStream(java.io.InputStream dstream, int startline,
   int startcolumn, int buffersize)
   {
      this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
   }
 
+  /** Constructor. */
   public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
                           int startcolumn) throws java.io.UnsupportedEncodingException
   {
      this(dstream, encoding, startline, startcolumn, 4096);
   }
 
+  /** Constructor. */
   public SimpleCharStream(java.io.InputStream dstream, int startline,
                           int startcolumn)
   {
      this(dstream, startline, startcolumn, 4096);
   }
 
+  /** Constructor. */
   public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
   {
      this(dstream, encoding, 1, 1, 4096);
   }
 
+  /** Constructor. */
   public SimpleCharStream(java.io.InputStream dstream)
   {
      this(dstream, 1, 1, 4096);
   }
 
+  /** Reinitialise. */
   public void ReInit(java.io.InputStream dstream, String encoding, int startline,
                           int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
   {
      ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
   }
 
+  /** Reinitialise. */
   public void ReInit(java.io.InputStream dstream, int startline,
                           int startcolumn, int buffersize)
   {
      ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
   }
 
+  /** Reinitialise. */
   public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
   {
      ReInit(dstream, encoding, 1, 1, 4096);
   }
 
+  /** Reinitialise. */
   public void ReInit(java.io.InputStream dstream)
   {
      ReInit(dstream, 1, 1, 4096);
   }
+  /** Reinitialise. */
   public void ReInit(java.io.InputStream dstream, String encoding, int startline,
                      int startcolumn) throws java.io.UnsupportedEncodingException
   {
      ReInit(dstream, encoding, startline, startcolumn, 4096);
   }
+  /** Reinitialise. */
   public void ReInit(java.io.InputStream dstream, int startline,
                      int startcolumn)
   {
      ReInit(dstream, startline, startcolumn, 4096);
   }
+  /** Get token literal value. */
   public String GetImage()
   {
      if (bufpos >= tokenBegin)
@@ -381,6 +395,7 @@ public class SimpleCharStream
                               new String(buffer, 0, bufpos + 1);
   }
 
+  /** Get the suffix. */
   public char[] GetSuffix(int len)
   {
      char[] ret = new char[len];
@@ -397,6 +412,7 @@ public class SimpleCharStream
      return ret;
   }
 
+  /** Reset buffer when finished. */
   public void Done()
   {
      buffer = null;
@@ -432,7 +448,7 @@ public class SimpleCharStream
         bufcolumn[j] = newCol + columnDiff;
         columnDiff = nextColDiff;
         i++;
-     } 
+     }
 
      if (i < len)
      {
@@ -453,3 +469,4 @@ public class SimpleCharStream
   }
 
 }
+/* JavaCC - OriginalChecksum=07e88967db3720fcfc378bbb17e7f640 (do not edit this line) */

==================================================
TokenMgrError.java
index 2c532a6de7..001732d9d8 100644
--- a/java/org/apache/el/parser/Token.java
+++ b/java/org/apache/el/parser/Token.java
@@ -1,20 +1,5 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/* Generated By:JavaCC: Do not edit this line. Token.java Version 3.0 */
+/* Generated By:JavaCC: Do not edit this line. Token.java Version 4.1 */
+/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null */
 package org.apache.el.parser;
 
 /**
@@ -30,12 +15,14 @@ public class Token {
    */
   public int kind;
 
-  /**
-   * beginLine and beginColumn describe the position of the first character
-   * of this token; endLine and endColumn describe the position of the
-   * last character of this token.
-   */
-  public int beginLine, beginColumn, endLine, endColumn;
+  /** The line number of the first character of this Token. */
+  public int beginLine;
+  /** The column number of the first character of this Token. */
+  public int beginColumn;
+  /** The line number of the last character of this Token. */
+  public int endLine;
+  /** The column number of the last character of this Token. */
+  public int endColumn;
 
   /**
    * The string image of the token.
@@ -66,6 +53,40 @@ public class Token {
    */
   public Token specialToken;
 
+  /**
+   * An optional attribute value of the Token.
+   * Tokens which are not used as syntactic sugar will often contain
+   * meaningful values that will be used later on by the compiler or
+   * interpreter. This attribute value is often different from the image.
+   * Any subclass of Token that actually wants to return a non-null value can
+   * override this method as appropriate.
+   */
+  public Object getValue() {
+    return null;
+  }
+
+  /**
+   * No-argument constructor
+   */
+  public Token() {}
+
+  /**
+   * Constructs a new token for the specified Image.
+   */
+  public Token(int kind)
+  {
+     this(kind, null);
+  }
+
+  /**
+   * Constructs a new token for the specified Image and Kind.
+   */
+  public Token(int kind, String image)
+  {
+     this.kind = kind;
+     this.image = image;
+  }
+
   /**
    * Returns the image.
    */
@@ -79,19 +100,25 @@ public class Token {
    * can create and return subclass objects based on the value of ofKind.
    * Simply add the cases to the switch for all those special cases.
    * For example, if you have a subclass of Token called IDToken that
-   * you want to create if ofKind is ID, simlpy add something like :
+   * you want to create if ofKind is ID, simply add something like :
    *
-   *    case MyParserConstants.ID : return new IDToken();
+   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
    *
    * to the following switch statement. Then you can cast matchedToken
-   * variable to the appropriate type and use it in your lexical actions.
+   * variable to the appropriate type and use sit in your lexical actions.
    */
-  public static final Token newToken(int ofKind)
+  public static Token newToken(int ofKind, String image)
   {
      switch(ofKind)
      {
-       default : return new Token();
+       default : return new Token(ofKind, image);
      }
   }
 
+  public static Token newToken(int ofKind)
+  {
+     return newToken(ofKind, null);
+  }
+
 }
+/* JavaCC - OriginalChecksum=384f0c8d72f06824f8ad2f5b33eb5e59 (do not edit this line) */

==================================================
