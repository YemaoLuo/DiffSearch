8a04a0b5e496373dfcac421c09e84048adb82f84
==================================================
Pull up remaining actions and remove actionInternal() method that is no longer required.
==================================================
Mark Emlyn
==================================================
Tue Sep 3 10:15:21 2013 +0000
==================================================
AbstractAjpProcessor.java
Pull up remaining actions and remove actionInternal() method that is no longer required.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1519634 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AjpAprProcessor.java
index 75cdb37590..cc1e21fe64 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
@@ -471,29 +471,51 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
 
         } else if (actionCode == ActionCode.ASYNC_START) {
             asyncStateMachine.asyncStart((AsyncContextCallback) param);
+
+        } else if (actionCode == ActionCode.ASYNC_COMPLETE) {
+            socketWrapper.clearDispatches();
+            if (asyncStateMachine.asyncComplete()) {
+                endpoint.processSocketAsync(socketWrapper, SocketStatus.OPEN_READ);
+            }
+
+        } else if (actionCode == ActionCode.ASYNC_DISPATCH) {
+            if (asyncStateMachine.asyncDispatch()) {
+                endpoint.processSocketAsync(socketWrapper, SocketStatus.OPEN_READ);
+            }
+
         } else if (actionCode == ActionCode.ASYNC_DISPATCHED) {
             asyncStateMachine.asyncDispatched();
+
         } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {
             if (param == null) return;
             long timeout = ((Long)param).longValue();
             socketWrapper.setTimeout(timeout);
+
         } else if (actionCode == ActionCode.ASYNC_TIMEOUT) {
             AtomicBoolean result = (AtomicBoolean) param;
             result.set(asyncStateMachine.asyncTimeout());
+
         } else if (actionCode == ActionCode.ASYNC_RUN) {
             asyncStateMachine.asyncRun((Runnable) param);
+
         } else if (actionCode == ActionCode.ASYNC_ERROR) {
             asyncStateMachine.asyncError();
+
         } else if (actionCode == ActionCode.ASYNC_IS_STARTED) {
             ((AtomicBoolean) param).set(asyncStateMachine.isAsyncStarted());
+
         } else if (actionCode == ActionCode.ASYNC_IS_DISPATCHING) {
             ((AtomicBoolean) param).set(asyncStateMachine.isAsyncDispatching());
+
         } else if (actionCode == ActionCode.ASYNC_IS_ASYNC) {
             ((AtomicBoolean) param).set(asyncStateMachine.isAsync());
+
         } else if (actionCode == ActionCode.ASYNC_IS_TIMINGOUT) {
             ((AtomicBoolean) param).set(asyncStateMachine.isAsyncTimingOut());
+
         } else if (actionCode == ActionCode.ASYNC_IS_ERROR) {
             ((AtomicBoolean) param).set(asyncStateMachine.isAsyncError());
+
         } else if (actionCode == ActionCode.UPGRADE) {
             // HTTP connections only. Unsupported for AJP.
             throw new UnsupportedOperationException(
@@ -546,9 +568,6 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
 
         } else if (actionCode == ActionCode.DISPATCH_WRITE) {
             socketWrapper.addDispatch(DispatchType.NON_BLOCKING_WRITE);
-
-        }  else {
-            actionInternal(actionCode, param);
         }
     }
 
@@ -808,9 +827,6 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
 
     // ------------------------------------------------------ Protected Methods
 
-    // Methods called by action()
-    protected abstract void actionInternal(ActionCode actionCode, Object param);
-
     // Methods called by asyncDispatch
     /**
      * Provides a mechanism for those connector implementations (currently only

==================================================
AjpNioProcessor.java
index 188b247dbc..c742045ffc 100644
--- a/java/org/apache/coyote/ajp/AjpAprProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpAprProcessor.java
@@ -21,12 +21,10 @@ import java.nio.ByteBuffer;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
 
-import org.apache.coyote.ActionCode;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.jni.Socket;
 import org.apache.tomcat.util.net.AprEndpoint;
-import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapper;
 
 /**
@@ -74,29 +72,6 @@ public class AjpAprProcessor extends AbstractAjpProcessor<Long> {
     protected final ByteBuffer outputBuffer;
 
 
-    /**
-     * Send an action to the connector.
-     *
-     * @param actionCode Type of the action
-     * @param param Action parameter
-     */
-    @Override
-    protected void actionInternal(ActionCode actionCode, Object param) {
-
-        if (actionCode == ActionCode.ASYNC_COMPLETE) {
-            socketWrapper.clearDispatches();
-            if (asyncStateMachine.asyncComplete()) {
-                endpoint.processSocketAsync(socketWrapper, SocketStatus.OPEN_READ);
-            }
-
-        } else if (actionCode == ActionCode.ASYNC_DISPATCH) {
-            if (asyncStateMachine.asyncDispatch()) {
-                endpoint.processSocketAsync(socketWrapper, SocketStatus.OPEN_READ);
-            }
-        }
-    }
-
-
     @Override
     protected void resetTimeouts() {
         // NO-OP. The AJP APR/native connector only uses the timeout value on

==================================================
AjpProcessor.java
index 874a328677..c0fe378451 100644
--- a/java/org/apache/coyote/ajp/AjpNioProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpNioProcessor.java
@@ -21,13 +21,11 @@ import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.channels.Selector;
 
-import org.apache.coyote.ActionCode;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.net.NioChannel;
 import org.apache.tomcat.util.net.NioEndpoint;
 import org.apache.tomcat.util.net.NioSelectorPool;
-import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapper;
 
 /**
@@ -58,29 +56,6 @@ public class AjpNioProcessor extends AbstractAjpProcessor<NioChannel> {
     protected final NioSelectorPool pool;
 
 
-    /**
-     * Send an action to the connector.
-     *
-     * @param actionCode Type of the action
-     * @param param Action parameter
-     */
-    @Override
-    protected void actionInternal(ActionCode actionCode, Object param) {
-
-        if (actionCode == ActionCode.ASYNC_COMPLETE) {
-            socketWrapper.clearDispatches();
-            if (asyncStateMachine.asyncComplete()) {
-                endpoint.processSocketAsync(socketWrapper, SocketStatus.OPEN_READ);
-            }
-
-        } else if (actionCode == ActionCode.ASYNC_DISPATCH) {
-            if (asyncStateMachine.asyncDispatch()) {
-                endpoint.processSocketAsync(socketWrapper, SocketStatus.OPEN_READ);
-            }
-        }
-    }
-
-
     @Override
     protected void resetTimeouts() {
         // The NIO connector uses the timeout configured on the wrapper in the

==================================================
