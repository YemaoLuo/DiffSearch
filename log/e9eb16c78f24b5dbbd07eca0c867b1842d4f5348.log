e9eb16c78f24b5dbbd07eca0c867b1842d4f5348
==================================================
Trailing whitespace removal from /modules/tomcat-lite
==================================================
Mark Emlyn
==================================================
Sat Oct 22 21:30:59 2011 +0000
==================================================
LiteProtocolHandler.java
index b0fcbbd0b8..2034732dd3 100644
--- a/modules/tomcat-lite/ivy.xml
+++ b/modules/tomcat-lite/ivy.xml
@@ -15,9 +15,9 @@
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
-   under the License.    
+   under the License.
 -->
-<ivy-module version="2.0" 
+<ivy-module version="2.0"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="http://ant.apache.org/ivy/schemas/ivy.xsd">
     <info
@@ -27,6 +27,6 @@
 	</info>
 	
 	<dependencies>
-	  
+	
 	</dependencies>
 </ivy-module>

==================================================
BaseMapper.java
index 541ac19668..c7817d435d 100644
--- a/modules/tomcat-lite/java/org/apache/coyote/lite/LiteProtocolHandler.java
+++ b/modules/tomcat-lite/java/org/apache/coyote/lite/LiteProtocolHandler.java
@@ -37,27 +37,27 @@ import org.apache.tomcat.util.modeler.Registry;
 
 /**
  * Work in progress - use the refactored http as a coyote connector.
- * Just basic requests work right now - need to implement all the 
+ * Just basic requests work right now - need to implement all the
  * methods of coyote.
- * 
- * 
+ *
+ *
  * @author Costin Manolache
  */
 public class LiteProtocolHandler implements ProtocolHandler {
 
     Adapter adapter;
     Map<String, Object> attributes = new HashMap<String, Object>();
-    
-    
+
+
     HttpConnector httpConnServer;
     int port = 8999;
-    
+
     // Tomcat JMX integration
     Registry registry;
-    
+
     public LiteProtocolHandler() {
     }
-    
+
     @Override
     public void destroy() throws Exception {
     }
@@ -99,9 +99,9 @@ public class LiteProtocolHandler implements ProtocolHandler {
         while (io != null) {
             bind("IOConnector-" + (ioLevel++) + "-" + base, io);
             if (io instanceof SocketConnector) {
-                bind("NioThread-" + base, 
+                bind("NioThread-" + base,
                         ((SocketConnector) io).getSelector());
-                
+
             }
             io = io.getNet();
         }
@@ -126,9 +126,9 @@ public class LiteProtocolHandler implements ProtocolHandler {
             public void targetRemoved(RemoteServer host) {
                 unbind("AsyncHttp-" + base + "-" + host.target);
             }
-            
+
         });
-        
+
         httpConnServer.setOnCreate(new HttpChannelEvents() {
             @Override
             public void onCreate(HttpChannel data, HttpConnector extraData)
@@ -141,11 +141,11 @@ public class LiteProtocolHandler implements ProtocolHandler {
                 unbind("AsyncHttp-" + base + "-" + data.getId());
             }
         });
-        
+
         // TODO: process attributes via registry !!
-        
+
     }
-    
+
     private void bind(String name, Object o) {
         try {
             registry.registerComponent(o, "TomcatLite:name=" + name, null);
@@ -169,19 +169,19 @@ public class LiteProtocolHandler implements ProtocolHandler {
     @Override
     public void setAdapter(Adapter adapter) {
         this.adapter = adapter;
-        
+
     }
-    
+
     @Override
     public void setAttribute(String name, Object value) {
         attributes.put(name, value);
     }
-    
+
     @Override
     public void start() throws Exception {
         httpConnServer.start();
     }
-    
+
     public void setPort(int port) {
         this.port = port;
     }
@@ -190,7 +190,7 @@ public class LiteProtocolHandler implements ProtocolHandler {
      * Wrap old tomcat buffer to lite buffer.
      */
     private void wrap(MessageBytes dest, CBuffer buffer) {
-        dest.setChars(buffer.array(), buffer.position(), 
+        dest.setChars(buffer.array(), buffer.position(),
                 buffer.length());
     }
 
@@ -201,7 +201,7 @@ public class LiteProtocolHandler implements ProtocolHandler {
         // TODO: reuse, per req
         RequestData rc = new RequestData();
         rc.init(httpReq, httpRes);
-        
+
         try {
             adapter.service(rc.req, rc.res);
         } catch (Exception e) {
@@ -209,8 +209,8 @@ public class LiteProtocolHandler implements ProtocolHandler {
             e.printStackTrace();
         }
     }
-    
-    /** 
+
+    /**
      * ActionHook implementation, include coyote request/response objects.
      */
     public class RequestData implements ActionHook {
@@ -231,14 +231,14 @@ public class LiteProtocolHandler implements ProtocolHandler {
         Response res = new Response();
         HttpResponse httpRes;
         HttpRequest httpReq;
-        
+
         InputBuffer inputBuffer = new InputBuffer() {
             @Override
             public int doRead(ByteChunk bchunk, Request request)
                     throws IOException {
                 httpReq.getBody().waitData(httpReq.getHttpChannel().getIOTimeout());
-                int rd = 
-                    httpReq.getBody().read(bchunk.getBytes(), 
+                int rd =
+                    httpReq.getBody().read(bchunk.getBytes(),
                         bchunk.getStart(), bchunk.getBytes().length);
                 if (rd > 0) {
                     bchunk.setEnd(bchunk.getEnd() + rd);
@@ -246,7 +246,7 @@ public class LiteProtocolHandler implements ProtocolHandler {
                 return rd;
             }
         };
-        
+
         public RequestData() {
             req.setInputBuffer(inputBuffer);
             res.setOutputBuffer(outputBuffer);
@@ -254,27 +254,27 @@ public class LiteProtocolHandler implements ProtocolHandler {
             res.setRequest(req);
             res.setHook(this);
         }
-        
+
         public void init(HttpRequest httpReq, HttpResponse httpRes) {
             this.httpRes = httpRes;
             this.httpReq = httpReq;
-            // TODO: turn http request into a coyote request - copy all fields, 
+            // TODO: turn http request into a coyote request - copy all fields,
             // add hooks where needed.
-            
+
             wrap(req.decodedURI(), httpReq.decodedURI());
             wrap(req.method(), httpReq.method());
             wrap(req.protocol(), httpReq.protocol());
             wrap(req.requestURI(), httpReq.requestURI());
             wrap(req.queryString(), httpReq.queryString());
-           
+
             req.setServerPort(httpReq.getServerPort());
             req.serverName().setString(req.localName().toString());
-            
+
             MultiMap mimeHeaders = httpReq.getMimeHeaders();
             MimeHeaders coyoteHeaders = req.getMimeHeaders();
             for (int i = 0; i < mimeHeaders.size(); i++ ) {
                 Entry entry = mimeHeaders.getEntry(i);
-                MessageBytes val = 
+                MessageBytes val =
                     coyoteHeaders.addValue(entry.getName().toString());
                 val.setString(entry.getValue().toString());
             }
@@ -289,7 +289,7 @@ public class LiteProtocolHandler implements ProtocolHandler {
         public void action(ActionCode actionCode, Object param) {
 
             if (actionCode == ActionCode.ACTION_POST_REQUEST) {
-                commit(); // make sure it's sent - on errors 
+                commit(); // make sure it's sent - on errors
             } else if (actionCode == ActionCode.ACTION_COMMIT) {
                 commit();
             } else if (actionCode == ActionCode.ACTION_ACK) {
@@ -341,7 +341,7 @@ public class LiteProtocolHandler implements ProtocolHandler {
 
                 Object sslAtt = httpReq.getHttpChannel().getNet().getAttribute(SslProvider.ATT_SSL_CIPHER);
                 req.setAttribute("javax.servlet.request.cipher_suite", sslAtt);
-                
+
                 sslAtt = httpReq.getHttpChannel().getNet().getAttribute(SslProvider.ATT_SSL_KEY_SIZE);
                 req.setAttribute("javax.servlet.request.key_size", sslAtt);
 
@@ -386,7 +386,7 @@ public class LiteProtocolHandler implements ProtocolHandler {
         private void commit() {
             if (res.isCommitted())
                 return;
-            
+
             // TODO: copy headers, fields
             httpRes.setStatus(res.getStatus());
             httpRes.setMessage(res.getMessage());
@@ -414,7 +414,7 @@ public class LiteProtocolHandler implements ProtocolHandler {
             if (lang != null) {
                 httpRes.setHeader("Content-Language", lang);
             }
-            
+
             try {
                 httpReq.send();
             } catch (IOException e) {

==================================================
CompressFilter.java
index 129b4dceb8..6b2075b96e 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/BaseMapper.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/BaseMapper.java
@@ -29,7 +29,7 @@ import org.apache.tomcat.lite.io.BBucket;
 /**
  * Mapper, which implements the servlet API mapping rules (which are derived
  * from the HTTP rules).
- * 
+ *
  * This class doesn't use JNDI.
  */
 public class BaseMapper {
@@ -39,18 +39,18 @@ public class BaseMapper {
 
     // TODO:
     /**
-     * Mapping should be done on bytes - as received from net, before 
+     * Mapping should be done on bytes - as received from net, before
      * translation to chars. This would allow setting the default charset
-     * for the context - or even executing the servlet and letting it specify 
+     * for the context - or even executing the servlet and letting it specify
      * the charset to use for further decoding.
-     * 
+     *
      */
     public static interface Mapper {
         public void map(BBucket host, BBucket url, MappingData md);
     }
 
-    
-    /** 
+
+    /**
      * Like BaseMapper, for a Context.
      */
     public static class ServiceMapper extends BaseMapper {
@@ -117,10 +117,10 @@ public class BaseMapper {
      * Array containing the virtual hosts definitions.
      */
     Host[] hosts = new Host[0];
-    
-    /** 
-     * If no other host is found. 
-     * For single-host servers ( most common ) this is the only one 
+
+    /**
+     * If no other host is found.
+     * For single-host servers ( most common ) this is the only one
      * used.
      */
     Host defaultHost = new Host();
@@ -139,7 +139,7 @@ public class BaseMapper {
         Host newHost = new Host();
         newHost.name = name;
         newHost.contextList = new ContextList();
-        
+
         if (insertMap(hosts, newHosts, newHost)) {
             hosts = newHosts;
         }
@@ -187,7 +187,7 @@ public class BaseMapper {
             return;
         }
         Host realHost = hosts[pos];
-        
+
         Host[] newHosts = new Host[hosts.length + 1];
         Host newHost = new Host();
         newHost.name = alias;
@@ -201,14 +201,14 @@ public class BaseMapper {
     private Host getHost(String host) {
         return getHost(CBuffer.newInstance().append(host));
     }
-    
+
     private Host getHost(CBuffer host) {
-        if (hosts == null || hosts.length <= 1 || host == null 
+        if (hosts == null || hosts.length <= 1 || host == null
                 || host.length() == 0 || host.equals("")) {
             return defaultHost;
         } else {
             Host[] hosts = this.hosts;
-            // TODO: if hosts.length == 1 or defaultHost ? 
+            // TODO: if hosts.length == 1 or defaultHost ?
             int pos = findIgnoreCase(hosts, host);
             if ((pos != -1) && (host.equalsIgnoreCase(hosts[pos].name))) {
                 return hosts[pos];
@@ -236,18 +236,18 @@ public class BaseMapper {
      * @param context Context object
      * @param welcomeResources Welcome files defined for this context
      * @param resources Static resources of the context
-     * @param ctxService 
+     * @param ctxService
      */
     public BaseMapper.Context addContext(String hostName, String path, Object context,
-            String[] welcomeResources, FileConnector resources, 
+            String[] welcomeResources, FileConnector resources,
             HttpChannel.HttpService ctxService) {
 
         if (path == null) {
             path = "/";
         }
-        
+
         Host host = getOrCreateHost(hostName);
-        
+
         int slashCount = slashCount(path);
         synchronized (host) {
             BaseMapper.Context[] contexts = host.contextList.contexts;
@@ -408,7 +408,7 @@ public class BaseMapper {
      * @param contextPath Context path this wrapper belongs to
      * @param path Wrapper mapping
      */
-    public void removeWrapper(String hostName, String contextPath, 
+    public void removeWrapper(String hostName, String contextPath,
                               String path) {
         Host host = getHost(hostName);
         BaseMapper.Context[] contexts = host.contextList.contexts;
@@ -478,7 +478,7 @@ public class BaseMapper {
                     MappingData mappingData)
         throws Exception {
 
-        internalMap(host.length() == 0 ? null : 
+        internalMap(host.length() == 0 ? null :
             host, uri, mappingData);
     }
 
@@ -498,7 +498,7 @@ public class BaseMapper {
         int nesting = 0;
 
         // Virtual host mapping
-        Host mappedHost = getHost(host); 
+        Host mappedHost = getHost(host);
         contexts = mappedHost.contextList.contexts;
         nesting = mappedHost.contextList.nesting;
 
@@ -506,7 +506,7 @@ public class BaseMapper {
         if (contexts.length == 0) {
             return;
         }
-        
+
         if (mappingData.context == null) {
             if (nesting < 1 || contexts.length == 1 && "".equals(contexts[0].name)) {
                 // if 1 context (default) -> fast return
@@ -533,7 +533,7 @@ public class BaseMapper {
                     boolean found = false;
                     CBuffer tmp = mappingData.tmpPrefix;
                     tmp.wrap(uri, 0, uri.length());
-                    
+
                     while (pos >= 0) {
                         if (tmp.startsWith(contexts[pos].name)) {
                             length = contexts[pos].name.length();
@@ -563,7 +563,7 @@ public class BaseMapper {
                     }
                 }
             }
-            
+
             if (context != null) {
                 mappingData.context = context.object;
                 mappingData.contextPath.set(context.name);
@@ -582,20 +582,20 @@ public class BaseMapper {
      * Wrapper mapping, using servlet rules.
      */
     protected final void internalMapWrapper(
-            BaseMapper.Context context, 
+            BaseMapper.Context context,
             CBuffer url,
             MappingData mappingData)
                 throws Exception {
 
         boolean noServletPath = false;
         if (url.length() < context.name.length()) {
-            throw new IOException("Invalid mapping " + context.name + " " + 
+            throw new IOException("Invalid mapping " + context.name + " " +
                     url);
         }
 
         try {
             // Set the servlet path.
-            mappingData.tmpServletPath.set(url, 
+            mappingData.tmpServletPath.set(url,
                     context.name.length(),
                     url.length() - context.name.length());
 
@@ -607,16 +607,16 @@ public class BaseMapper {
                 }
             }
 
-            mapAfterContext(context, url, mappingData.tmpServletPath, mappingData, 
+            mapAfterContext(context, url, mappingData.tmpServletPath, mappingData,
                     noServletPath);
         } catch (ArrayIndexOutOfBoundsException ex) {
             System.err.println(1);
         }
     }
 
-    void mapAfterContext(BaseMapper.Context context, 
-            CBuffer url, CBuffer urlNoContext, 
-            MappingData mappingData, boolean noServletPath) 
+    void mapAfterContext(BaseMapper.Context context,
+            CBuffer url, CBuffer urlNoContext,
+            MappingData mappingData, boolean noServletPath)
         throws Exception {
 
 
@@ -629,10 +629,10 @@ public class BaseMapper {
         BaseMapper.ServiceMapping[] wildcardWrappers = context.wildcardWrappers;
         if (mappingData.getServiceObject() == null) {
 
-            internalMapWildcardWrapper(wildcardWrappers, context.nesting, 
+            internalMapWildcardWrapper(wildcardWrappers, context.nesting,
                                        urlNoContext, mappingData);
-            
-            if (mappingData.getServiceObject() != null 
+
+            if (mappingData.getServiceObject() != null
                     && mappingData.service.jspWildCard) {
                 if (urlNoContext.lastChar() == '/') {
                     /*
@@ -642,7 +642,7 @@ public class BaseMapper {
                      * Force the context's welcome files, which are interpreted
                      * as JSP files (since they match the url-pattern), to be
                      * considered. See Bugzilla 27664.
-                     */ 
+                     */
                     mappingData.service = null;
                     checkJspWelcomeFiles = true;
                 } else {
@@ -675,7 +675,7 @@ public class BaseMapper {
             if (checkWelcomeFiles) {
                 for (int i = 0; (i < context.welcomeResources.length)
                          && (mappingData.getServiceObject() == null); i++) {
-                    
+
                     CBuffer wpath = mappingData.tmpWelcome;
                     wpath.set(urlNoContext);
                     wpath.append(context.welcomeResources[i]);
@@ -686,7 +686,7 @@ public class BaseMapper {
                     // Rule 4b -- Welcome resources processing for prefix match
                     if (mappingData.getServiceObject() == null) {
                         internalMapWildcardWrapper
-                            (wildcardWrappers, context.nesting, 
+                            (wildcardWrappers, context.nesting,
                              urlNoContext, mappingData);
                     }
 
@@ -695,14 +695,14 @@ public class BaseMapper {
                     if (mappingData.getServiceObject() == null
                         && context.resources != null) {
                         String pathStr = urlNoContext.toString();
-                        
+
                         mapWelcomResource(context, urlNoContext, mappingData,
                                 extensionWrappers, pathStr);
-                        
+
                     }
                 }
             }
-                                        
+
         }
 
 
@@ -716,25 +716,25 @@ public class BaseMapper {
             // Redirection to a folder
             if (context.resources != null && urlNoContext.lastChar() != '/') {
                 String pathStr = urlNoContext.toString();
-                mapDefaultServlet(context, urlNoContext, mappingData, 
+                mapDefaultServlet(context, urlNoContext, mappingData,
                         url,
                         pathStr);
             }
         }
     }
 
-    /** 
+    /**
      * Filesystem-dependent method:
-     *  if pathStr corresponds to a directory, we'll need to redirect with / 
-     *  at end. 
+     *  if pathStr corresponds to a directory, we'll need to redirect with /
+     *  at end.
      */
-    protected void mapDefaultServlet(BaseMapper.Context context, 
+    protected void mapDefaultServlet(BaseMapper.Context context,
             CBuffer path,
-            MappingData mappingData, 
+            MappingData mappingData,
             CBuffer url,
             String pathStr) throws IOException {
-        
-        if (context.resources != null 
+
+        if (context.resources != null
                 && context.resources.isDirectory(pathStr)) {
             mappingData.redirectPath.set(url);
             mappingData.redirectPath.append("/");
@@ -746,13 +746,13 @@ public class BaseMapper {
 
 
     /**
-     * Filesystem dependent method: 
-     *  check if a resource exists in filesystem. 
+     * Filesystem dependent method:
+     *  check if a resource exists in filesystem.
      */
     protected void mapWelcomResource(BaseMapper.Context context, CBuffer path,
                                MappingData mappingData,
                                BaseMapper.ServiceMapping[] extensionWrappers, String pathStr) {
-        
+
         if (context.resources != null &&
                 context.resources.isFile(pathStr)) {
             internalMapExtensionWrapper(extensionWrappers,
@@ -786,15 +786,15 @@ public class BaseMapper {
      * Prefix mapping. ( /foo/* )
      */
     private final void internalMapWildcardWrapper
-        (BaseMapper.ServiceMapping[] wrappers, int nesting, CBuffer path, 
+        (BaseMapper.ServiceMapping[] wrappers, int nesting, CBuffer path,
          MappingData mappingData) {
 
         int lastSlash = -1;
         int length = -1;
-        
+
         CBuffer tmp = mappingData.tmpPrefix;
         tmp.wrap(path, 0, path.length());
-        
+
         int pos = find(wrappers, tmp);
         if (pos != -1) {
             boolean found = false;
@@ -810,7 +810,7 @@ public class BaseMapper {
                     }
                 }
                 if (lastSlash == -1) {
-                    lastSlash = tmp.nthSlash(nesting + 1); 
+                    lastSlash = tmp.nthSlash(nesting + 1);
                 } else {
                     lastSlash = tmp.lastIndexOf('/');
                 }
@@ -819,7 +819,7 @@ public class BaseMapper {
             }
             if (found) {
                 mappingData.wrapperPath.set(wrappers[pos].name);
-                
+
                 if (path.length() > length) {
                     mappingData.pathInfo.set
                         (path, length, path.length() - length);
@@ -830,21 +830,21 @@ public class BaseMapper {
             }
         }
     }
-    
+
 
     /**
      * Extension mappings.
      */
     protected final void internalMapExtensionWrapper
         (BaseMapper.ServiceMapping[] wrappers, CBuffer path, MappingData mappingData) {
-        
+
         int dot = path.getExtension(mappingData.ext, '/', '.');
         if (dot >= 0) {
             int pos = find(wrappers, mappingData.ext);
-                
+
             if ((pos != -1)
                     && (mappingData.ext.equals(wrappers[pos].name))) {
-                    
+
                 mappingData.wrapperPath.set(path);
                 mappingData.requestPath.set(path);
 
@@ -868,10 +868,10 @@ public class BaseMapper {
         if (b == -1) {
             return -1;
         }
-        
+
         if (name.compare(map[0].name) < 0 ) {
             return -1;
-        }         
+        }
         if (b == 0) {
             return 0;
         }
@@ -904,7 +904,7 @@ public class BaseMapper {
      * This will return the index for the closest inferior or equal item in the
      * given array.
      */
-    private static final int findIgnoreCase(BaseMapper.Mapping[] map, 
+    private static final int findIgnoreCase(BaseMapper.Mapping[] map,
             CBuffer name) {
         int a = 0;
         int b = map.length - 1;
@@ -915,7 +915,7 @@ public class BaseMapper {
         }
         if (name.compareIgnoreCase(map[0].name) < 0 ) {
             return -1;
-        }         
+        }
         if (b == 0) {
             return 0;
         }
@@ -958,10 +958,10 @@ public class BaseMapper {
         if (b == -1) {
             return -1;
         }
-        
+
         if (name.compareTo(map[0].name) < 0) {
             return -1;
-        } 
+        }
         if (b == 0) {
             return 0;
         }
@@ -1062,21 +1062,21 @@ public class BaseMapper {
 
 
     public static final class Context extends BaseMapper.Mapping {
-    
+
         Context(BaseMapper mapper) {
             this.mapper = mapper;
         }
         public BaseMapper mapper;
         public String[] welcomeResources = new String[0];
         public FileConnector resources = null;
-        
+
         public BaseMapper.ServiceMapping defaultWrapper = null;
-        
+
         public BaseMapper.ServiceMapping[] exactWrappers = new BaseMapper.ServiceMapping[0];
         public BaseMapper.ServiceMapping[] wildcardWrappers = new BaseMapper.ServiceMapping[0];
         public BaseMapper.ServiceMapping[] extensionWrappers = new BaseMapper.ServiceMapping[0];
         public int nesting = 0;
-    
+
         public void addWrapper(String path, HttpService service) {
             mapper.addWrapper(this, path, service);
         }
@@ -1086,17 +1086,17 @@ public class BaseMapper {
 
     public static class ServiceMapping extends BaseMapper.Mapping {
         public boolean jspWildCard = false;
-        // If set, the service will run in the selector thread ( should 
+        // If set, the service will run in the selector thread ( should
         // be non-blocking )
         public boolean selectorThread = false;
-        
+
     }
 
 
-    protected static abstract class Mapping {    
+    protected static abstract class Mapping {
         public String name = null;
         public Object object = null;
-    
+
         public String toString() {
             if (name == null || "".equals(name)) {
                 return "DEFAULT";

==================================================
ContentType.java
index d78c55e59f..ecf5851006 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/CompressFilter.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/CompressFilter.java
@@ -17,29 +17,29 @@ public class CompressFilter {
     // 1CMF 1FLG [4DICTID] DATA 4ADLER
     // CMF:  CINFO + CM (compression method). == x8
     // 78 == deflate with 32k window, i.e. max window
-    
+
     // FLG: 2bit level, 1 bit FDICT, 5 bit FCHECK
     // Cx, Dx - no dict; Fx, Ex - dict ( for BEST_COMPRESSION )
-    
+
     // Overhead: 6 bytes without dict, 10 with dict
     // data is encoded in blocks - there is a 'block end' marker and
     // 'last block'.
-    
+
     // Flush: http://www.bolet.org/~pornin/deflate-flush.html
-    // inflater needs about 9 bits 
+    // inflater needs about 9 bits
     // Z_SYNC_FLUSH: send empty block, 00 00 FF FF - seems recomended
     // PPP can skip this - there is a record format on top
     // Z_PARTIAL_FLUSH: standard for SSH
 
     ZStream cStream;
     ZStream dStream;
-    
+
     byte[] dict;
     long dictId;
-    
+
     public CompressFilter() {
     }
-    
+
     public void recycle() {
         if (cStream == null) {
             return;
@@ -49,7 +49,7 @@ public class CompressFilter {
         dStream.free();
         dStream = null;
     }
-    
+
     public void init() {
         if (cStream != null) {
             return;
@@ -59,12 +59,12 @@ public class CompressFilter {
         // BEST_COMRESSION results in 256Kb per Deflate
         // 15 == default = 32k window
         cStream.deflateInit(JZlib.Z_BEST_SPEED, 10);
-        
+
         dStream = new ZStream();
         dStream.inflateInit();
 
     }
-    
+
     CompressFilter setDictionary(byte[] dict, long id) {
         init();
         this.dict = dict;
@@ -76,7 +76,7 @@ public class CompressFilter {
     void compress(IOBuffer in, IOBuffer out) throws IOException {
         init();
         BBucket bb = in.popFirst();
-        
+
         while (bb != null) {
             // TODO: only the last one needs flush
 
@@ -84,12 +84,12 @@ public class CompressFilter {
             compress(bb, out, false);
             bb = in.popFirst();
         }
-        
+
         if (in.isClosedAndEmpty()) {
             compressEnd(out);
         }
     }
-    
+
     void compress(BBucket bb, IOBuffer out, boolean last) throws IOException {
         // TODO: only the last one needs flush
 
@@ -115,7 +115,7 @@ public class CompressFilter {
                 break;
             }
         }
-        
+
         if (last) {
             compressEnd(out);
         }
@@ -125,12 +125,12 @@ public class CompressFilter {
         while (true) {
             ByteBuffer outB = out.getWriteBuffer();
             cStream.next_out = outB.array();
-        
+
             cStream.next_out_index = outB.position();
             cStream.avail_out = outB.remaining();
             cStream.deflate(JZlib.Z_FINISH);
             cStream.deflateEnd();
-            
+
             outB.position(cStream.next_out_index);
             out.releaseWriteBuffer(1);
             if (cStream.avail_out > 0) {
@@ -142,11 +142,11 @@ public class CompressFilter {
     void decompress(IOBuffer in, IOBuffer out) throws IOException {
         decompress(in, out, in.available());
     }
-    
+
     void decompress(IOBuffer in, IOBuffer out, int len) throws IOException {
         init();
         BBucket bb = in.peekFirst();
-        
+
         while (bb != null && len > 0) {
             dStream.next_in = bb.array();
             dStream.next_in_index = bb.position();
@@ -155,11 +155,11 @@ public class CompressFilter {
 
             while (true) {
                 ByteBuffer outB = out.getWriteBuffer();
-                
+
                 dStream.next_out = outB.array();
                 dStream.next_out_index = outB.position();
                 dStream.avail_out = outB.remaining();
-                
+
                 int err = dStream.inflate(JZlib.Z_SYNC_FLUSH);
                 if (err == JZlib.Z_NEED_DICT && dict != null) {
                     // dStream.adler has the dict id - not sure how to check
@@ -190,12 +190,12 @@ public class CompressFilter {
                     break;
                 }
             }
-            
-            in.advance(rd); // consummed 
+
+            in.advance(rd); // consummed
             len -= rd;
             bb = in.peekFirst();
         }
-        
+
         if (in.isClosedAndEmpty()) {
             // Shouldn't happen - input was not properly closed..
             // This should throw an exception, inflateEnd will check the CRC
@@ -205,13 +205,13 @@ public class CompressFilter {
             out.close();
         }
     }
-    
+
     private void check(int err, ZStream stream) throws IOException {
         if (err != JZlib.Z_OK) {
             throw new IOException(err + " " + stream.msg);
         }
     }
-    
+
     boolean isCompressed(HttpMessage http) {
         return false;
     }
@@ -219,7 +219,7 @@ public class CompressFilter {
     boolean needsCompression(HttpMessage in, HttpMessage out) {
         return false;
     }
-    
-    
+
+
 }
 

==================================================
DefaultHttpConnector.java
index c98276cfa0..31c6b9c65d 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/ContentType.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/ContentType.java
@@ -20,7 +20,7 @@ package org.apache.tomcat.lite.http;
 
 /**
  * Usefull methods for Content-Type processing
- * 
+ *
  * @author James Duncan Davidson [duncan@eng.sun.com]
  * @author James Todd [gonzo@eng.sun.com]
  * @author Jason Hunter [jch@eng.sun.com]

==================================================
Dispatcher.java
index d798d8b773..e43b4fdab1 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/DefaultHttpConnector.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/DefaultHttpConnector.java
@@ -12,12 +12,12 @@ public class DefaultHttpConnector {
 
     public synchronized static HttpConnector get() {
         if (DefaultHttpConnector.socketConnector == null) {
-            socketConnector = 
+            socketConnector =
                 new SocketConnector();
         }
         return new HttpConnector(socketConnector);
     }
-    
+
     private static SocketConnector socketConnector;
 
 }

==================================================
Http11Connection.java
index e47f5df4ac..51537e6ff0 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/Dispatcher.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/Dispatcher.java
@@ -31,9 +31,9 @@ import org.apache.tomcat.lite.io.FileConnector;
  * - decide if the request should be run in the selector thread
  * or in a thread pool
  * - finalizes the request ( close / flush )
- * - detects if the request is complete or set callbacks 
+ * - detects if the request is complete or set callbacks
  * for receive/flush/done.
- *  
+ *
  */
 public class Dispatcher implements HttpService {
 
@@ -45,15 +45,15 @@ public class Dispatcher implements HttpService {
     public Dispatcher() {
         init();
     }
-    
+
     protected void init() {
-        mapper = new BaseMapper();        
+        mapper = new BaseMapper();
     }
 
     public void runService(HttpChannel ch) {
         runService(ch, true);
     }
-    
+
     public void runService(HttpChannel ch, boolean recycle) {
         MappingData mapRes = ch.getRequest().getMappingData();
         HttpService h = (HttpService) mapRes.getServiceObject();
@@ -73,38 +73,38 @@ public class Dispatcher implements HttpService {
             t.printStackTrace();
         }
     }
-    
+
     @Override
     public void service(HttpRequest httpReq, HttpResponse httpRes) throws IOException {
         service(httpReq, httpRes, false, true);
     }
 
-    /** 
+    /**
      * Process the request/response in the current thread, without
      * release ( recycle ) at the end.
-     * 
+     *
      * For use by tests and/or in-memory running of servlets.
-     * 
-     * If no connection is associated with the request - the 
+     *
+     * If no connection is associated with the request - the
      * output will remain in the out buffer.
      */
     public void run(HttpRequest httpReq, HttpResponse httpRes) throws IOException {
         service(httpReq, httpRes, true, false);
     }
 
-    
-    public void service(HttpRequest httpReq, HttpResponse httpRes, boolean noThread, boolean recycle) 
+
+    public void service(HttpRequest httpReq, HttpResponse httpRes, boolean noThread, boolean recycle)
             throws IOException {
         long t0 = System.currentTimeMillis();
         HttpChannel http = httpReq.getHttpChannel();
-        
+
         http.setCompletedCallback(doneCallback);
-        
+
         try {
           // compute decodedURI - not done by connector
             MappingData mapRes = httpReq.getMappingData();
             mapRes.recycle();
-          
+
             mapper.map(httpReq.serverName(),
                   httpReq.decodedURI(), mapRes);
 
@@ -112,24 +112,24 @@ public class Dispatcher implements HttpService {
 
           if (h != null) {
               if (debug) {
-                  log.info(">>>>>>>> START: " + http.getRequest().method() + " " + 
-                      http.getRequest().decodedURI() + " " + 
+                  log.info(">>>>>>>> START: " + http.getRequest().method() + " " +
+                      http.getRequest().decodedURI() + " " +
                       h.getClass().getSimpleName());
               }
-              
+
               if (mapRes.service.selectorThread || noThread) {
                   runService(http, recycle);
               } else {
                   tp.execute(httpReq.getHttpChannel().dispatcherRunnable);
               }
-              
+
           } else {
               httpRes.setStatus(404);
               http.complete();
           }
-          
+
         } catch (IOException ex) {
-            if ("Broken pipe".equals(ex.getMessage())) { 
+            if ("Broken pipe".equals(ex.getMessage())) {
                 log.warning("Connection interrupted while writting");
             }
             throw ex;
@@ -144,26 +144,26 @@ public class Dispatcher implements HttpService {
         @Override
         public void handle(HttpChannel client, Object extraData) throws IOException {
             if (debug) {
-                log.info("<<<<<<<< DONE: " + client.getRequest().method() + " " + 
-                        client.getRequest().decodedURI() + " " + 
-                        client.getResponse().getStatus() + " "  
+                log.info("<<<<<<<< DONE: " + client.getRequest().method() + " " +
+                        client.getRequest().decodedURI() + " " +
+                        client.getResponse().getStatus() + " "
                         );
             }
         }
     };
-    
+
     public BaseMapper.Context addContext(String hostname, String ctxPath,
             Object ctx, String[] welcomeResources, FileConnector resources,
             HttpService ctxService) {
-        return mapper.addContext(hostname, ctxPath, ctx, welcomeResources, resources, 
+        return mapper.addContext(hostname, ctxPath, ctx, welcomeResources, resources,
                 ctxService);
     }
 
     public BaseMapper.Context addContext(String ctxPath) {
-        return mapper.addContext(null, ctxPath, null, null, null, 
+        return mapper.addContext(null, ctxPath, null, null, null,
                 null);
     }
-    
+
     public void map(CBuffer hostMB, CBuffer urlMB, MappingData md) {
         try {
             mapper.map(hostMB, urlMB, md);
@@ -187,10 +187,10 @@ public class Dispatcher implements HttpService {
             HttpService service) {
         mapper.addWrapper(ctx, path, service);
     }
-    
-    
+
+
     public void setDefaultService(HttpService service) {
-        BaseMapper.Context mCtx = 
+        BaseMapper.Context mCtx =
             mapper.addContext(null, "/", null, null, null, null);
         mapper.addWrapper(mCtx, "/", service);
     }

==================================================
HttpChannel.java
index 4b26ee9522..335333b1f0 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/Http11Connection.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/Http11Connection.java
@@ -21,43 +21,43 @@ import org.apache.tomcat.lite.io.IOBuffer;
 import org.apache.tomcat.lite.io.IOChannel;
 import org.apache.tomcat.lite.io.IOConnector;
 
-public class Http11Connection extends HttpConnection 
+public class Http11Connection extends HttpConnection
         implements IOConnector.ConnectedCallback {
     public static final String CHUNKED = "chunked";
-    
-    public static final String CLOSE = "close"; 
-    
+
+    public static final String CLOSE = "close";
+
     public static final String KEEPALIVE_S = "keep-alive";
 
     public static final String CONNECTION = "connection";
-    
+
     public static final String TRANSFERENCODING = "transfer-encoding";
-    
+
 
     protected static Logger log = Logger.getLogger("Http11Connection");
     static final byte COLON = (byte) ':';
 
-    // super.net is the socket 
-    
+    // super.net is the socket
+
     boolean debug;
-    BBuffer line = BBuffer.wrapper(); 
+    BBuffer line = BBuffer.wrapper();
     boolean endSent = false;
-    
+
     BodyState receiveBodyState = new BodyState();
     BodyState sendBodyState = new BodyState();
-    
+
     BBuffer headW = BBuffer.wrapper();
-    
+
     boolean headersReceived = false;
     boolean bodyReceived = false;
 
-    /** 
-     * Close connection when done writting, no content-length/chunked, 
+    /**
+     * Close connection when done writting, no content-length/chunked,
      * or no keep-alive ( http/1.0 ) or error.
-     * 
+     *
      * ServerMode: set if HTTP/0.9 &1.0 || !keep-alive
      * ClientMode: not currently used
-     */    
+     */
     boolean keepAlive = true;
 
     protected boolean http11 = true;
@@ -70,7 +70,7 @@ public class Http11Connection extends HttpConnection
 
     // dataReceived and endSendReceive
     private Object readLock = new Object();
-    
+
     public Http11Connection(HttpConnector httpConnector) {
         this.httpConnector = httpConnector;
         if (httpConnector != null) {
@@ -94,12 +94,12 @@ public class Http11Connection extends HttpConnection
         headersReceived = false;
         bodyReceived = false;
     }
-    
+
     public Http11Connection serverMode() {
         serverMode = true;
         return this;
     }
-       
+
     private boolean readHead() throws IOException {
         while (true) {
             int read;
@@ -113,10 +113,10 @@ public class Http11Connection extends HttpConnection
                     return false; // need more
                 }
                 // we have at least 4 bytes
-                if (headRecvBuf.get(0) == 0x80 && 
+                if (headRecvBuf.get(0) == 0x80 &&
                         headRecvBuf.get(1) == 0x01) {
                     // SPDY signature ( experimental )
-                    switchedProtocol = new SpdyConnection(httpConnector, 
+                    switchedProtocol = new SpdyConnection(httpConnector,
                             remoteHost);
                     if (serverMode) {
                         switchedProtocol.serverMode = true;
@@ -126,9 +126,9 @@ public class Http11Connection extends HttpConnection
                     switchedProtocol.setSink(net);
                     return false;
                 }
-                
+
             }
-            
+
             // we know we have one
             read = net.getIn().readLine(headRecvBuf);
             // Remove starting empty lines.
@@ -145,14 +145,14 @@ public class Http11Connection extends HttpConnection
                 return closeInHead();
             }
         }
-        
-        
+
+
         return true;
     }
-    
+
     private boolean closeInHead() throws IOException {
         if (debug) {
-            trace("CLOSE while reading HEAD");    
+            trace("CLOSE while reading HEAD");
         }
         // too early - we don't have the head
         abort("Close in head");
@@ -187,13 +187,13 @@ public class Http11Connection extends HttpConnection
         if (!checkKeepAliveClient()) {
             return; // we were in client keep alive mode
         }
-        // endSendReceived uses same lock - it will call this 
+        // endSendReceived uses same lock - it will call this
         // to check outstanding bytes
         synchronized (readLock) {
             if (bodyReceived) {
                 return; // leave data in net buffer, for next req
             }
-            
+
             if (!headersReceived) {
                 if (!readHead()) {
                     return;
@@ -216,19 +216,19 @@ public class Http11Connection extends HttpConnection
                 if (switchedProtocol != null) {
                     return;
                 }
-                
+
                 if (serverMode && activeHttp.httpReq.decodedUri.remaining() == 0) {
                     abort(activeHttp, "Invalid url");
                 }
 
                 headersReceived = true;
-                // Send header callbacks - we process any incoming data 
+                // Send header callbacks - we process any incoming data
                 // first, so callbacks have more info
                 trace("Send headers received callback " + activeHttp.httpService);
                 activeHttp.handleHeadersReceived(activeHttp.inMessage);
             }
 
-            // any remaining data will be processed as part of the 
+            // any remaining data will be processed as part of the
             // body - or left in the channel until endSendReceive()
 
             if (!bodyReceived) {
@@ -250,13 +250,13 @@ public class Http11Connection extends HttpConnection
                 // If not already closed.
                 closeStreamOnEnd("closed after body");
             }
-        
+
         }
     }
 
     /**
-     * We got data while in client keep alive ( no activeHttp ) 
-     * 
+     * We got data while in client keep alive ( no activeHttp )
+     *
      * @return false if there is an error
      */
     private boolean checkKeepAliveClient() throws IOException {
@@ -270,7 +270,7 @@ public class Http11Connection extends HttpConnection
             if (net.getIn().available() == 0) {
                 return true;
             }
-            log.warning("Unexpected message from server in client keep alive " 
+            log.warning("Unexpected message from server in client keep alive "
                     + net.getIn() + ": " + net.getIn().readAll(null));
             if (net.isOpen()) {
                 net.close();
@@ -279,12 +279,12 @@ public class Http11Connection extends HttpConnection
         }
         return true;
     }
-    
+
     private void processProtocol(CBuffer protocolMB) throws IOException {
         http11 = false;
         http09 = false;
         http10 = false;
-        
+
         if (protocolMB.equals(HttpChannel.HTTP_11)) {
             http11 = true;
         } else if (protocolMB.equals(HttpChannel.HTTP_10)) {
@@ -292,7 +292,7 @@ public class Http11Connection extends HttpConnection
         } else if (protocolMB.equals("")) {
             http09 = true;
         } else {
-            http11 = true; // hopefully will be backward compat 
+            http11 = true; // hopefully will be backward compat
         }
     }
 
@@ -349,13 +349,13 @@ public class Http11Connection extends HttpConnection
             handleReceived(net); // will attempt to read next req
         }
     }
-    
+
     private void trace(String s) {
         if(debug) {
             log.info(this.toString() + " " + activeHttp + " " + s);
         }
     }
-    
+
     private boolean isDone(BodyState bodys, IOBuffer body) {
         if (bodys.noBody) {
             return true;
@@ -369,12 +369,12 @@ public class Http11Connection extends HttpConnection
         }
         return false;
     }
-    
+
     void parseMessage(HttpChannel http, BBuffer headB) throws IOException {
         //Parse the response
         line.recycle();
         headB.readLine(line);
-        
+
         HttpMessageBytes msgBytes;
 
         if (serverMode) {
@@ -385,19 +385,19 @@ public class Http11Connection extends HttpConnection
                     msgBytes.protocol());
         } else {
             msgBytes = http.httpRes.getMsgBytes();
-            parseResponseLine(line, msgBytes.protocol(), 
+            parseResponseLine(line, msgBytes.protocol(),
                     msgBytes.status(), msgBytes.message());
         }
-        
+
         parseHeaders(http, msgBytes, headB);
 
         http.inMessage.state = HttpMessage.State.BODY_DATA;
-        
+
         http.inMessage.processReceivedHeaders();
-        
+
         // TODO: hook to allow specific charsets ( can be done later )
         processProtocol(http.inMessage.protocol());
-        
+
         if (serverMode) {
             // requested connection:close/keepAlive and proto
             updateKeepAlive(http.getRequest().getMimeHeaders(), true);
@@ -405,9 +405,9 @@ public class Http11Connection extends HttpConnection
             processExpectation(http);
 
             processContentDelimitation(receiveBodyState, http.getRequest());
-            // Spec: 
-            // The presence of a message-body in a request is signaled by the 
-            // inclusion of a Content-Length or Transfer-Encoding header field in 
+            // Spec:
+            // The presence of a message-body in a request is signaled by the
+            // inclusion of a Content-Length or Transfer-Encoding header field in
             // the request's message-headers
             // Server should read - but ignore ..
             receiveBodyState.noBody = !receiveBodyState.isContentDelimited();
@@ -415,29 +415,29 @@ public class Http11Connection extends HttpConnection
             updateCloseOnEnd(receiveBodyState, http, http.receiveBody);
 
             /*
-             * The presence of a message-body in a request is signaled by the 
-             * inclusion of a Content-Length or Transfer-Encoding header field in 
-             * the request's message-headers. A message-body MUST NOT be included 
-             * in a request if the specification of the request method 
-             * (section 5.1.1) does not allow sending an entity-body in requests. 
+             * The presence of a message-body in a request is signaled by the
+             * inclusion of a Content-Length or Transfer-Encoding header field in
+             * the request's message-headers. A message-body MUST NOT be included
+             * in a request if the specification of the request method
+             * (section 5.1.1) does not allow sending an entity-body in requests.
              * A server SHOULD read and forward a message-body on any request; if the request method does not include defined semantics for an entity-body, then the message-body SHOULD be ignored when handling the request.
              */
             if (!receiveBodyState.isContentDelimited()) {
                 // No body
                 http.getIn().close();
-            } 
+            }
 
         } else {
             receiveBodyState.noBody = !http.getResponse().hasBody();
-            
+
             updateKeepAlive(http.getResponse().getMimeHeaders(), false);
-            
+
             if (statusDropsConnection(http.getResponse().getStatus())) {
                 closeStreamOnEnd("response status drops connection");
             }
             IOBuffer body = http.receiveBody;
             processContentDelimitation(receiveBodyState, http.getResponse());
-            
+
             if (isDone(receiveBodyState, body)) {
                 body.close();
             }
@@ -446,9 +446,9 @@ public class Http11Connection extends HttpConnection
                 closeStreamOnEnd("not content delimited");
             }
         }
-    
+
     }
-    
+
     private void processExpectation(HttpChannel http) throws IOException {
         http.expectation = false;
         MultiMap headers = http.getRequest().getMimeHeaders();
@@ -458,7 +458,7 @@ public class Http11Connection extends HttpConnection
                 && (expect.indexOf("100-continue") != -1)) {
             http.expectation = true;
 
-            // TODO: configure, use the callback or the servlet 'read'. 
+            // TODO: configure, use the callback or the servlet 'read'.
             net.getOut().append("HTTP/1.1 100 Continue\r\n\r\n");
             net.startSending();
         }
@@ -466,17 +466,17 @@ public class Http11Connection extends HttpConnection
 
 
     /**
-     * Updates chunked, contentLength, remaining - based 
+     * Updates chunked, contentLength, remaining - based
      * on headers
      */
-    private void processContentDelimitation(BodyState bodys, 
+    private void processContentDelimitation(BodyState bodys,
             HttpMessage httpMsg) {
 
         bodys.contentLength = httpMsg.getContentLength();
         if (bodys.contentLength >= 0) {
             bodys.remaining = bodys.contentLength;
-        }        
-        
+        }
+
         // TODO: multiple transfer encoding headers, only process the last
         String transferEncodingValue = httpMsg.getHeader(TRANSFERENCODING);
         if (transferEncodingValue != null) {
@@ -499,7 +499,7 @@ public class Http11Connection extends HttpConnection
                 httpMsg.chunked = true;
             } else {
                 System.err.println("TODO: ABORT 501");
-                //return 501; // Currently only chunked is supported for 
+                //return 501; // Currently only chunked is supported for
                 // transfer encoding.
             }
         }
@@ -507,18 +507,18 @@ public class Http11Connection extends HttpConnection
         if (bodys.chunked) {
             bodys.remaining = 0;
         }
-    }    
-        
+    }
+
     /**
-     * Read the request line. This function is meant to be used during the 
-     * HTTP request header parsing. Do NOT attempt to read the request body 
+     * Read the request line. This function is meant to be used during the
+     * HTTP request header parsing. Do NOT attempt to read the request body
      * using it.
      *
      * @throws IOException If an exception occurs during the underlying socket
      * read operations, or if the given buffer is not big enough to accomodate
      * the whole line.
      */
-    boolean parseRequestLine(BBuffer line, 
+    boolean parseRequestLine(BBuffer line,
             BBuffer methodMB, BBuffer requestURIMB,
             BBuffer queryMB,
             BBuffer protoMB)
@@ -526,7 +526,7 @@ public class Http11Connection extends HttpConnection
 
         line.readToSpace(methodMB);
         line.skipSpace();
-        
+
         line.readToDelimOrSpace(HttpChannel.QUESTION, requestURIMB);
         if (line.remaining() > 0 && line.get(0) == HttpChannel.QUESTION) {
             // Has query
@@ -539,7 +539,7 @@ public class Http11Connection extends HttpConnection
         line.skipSpace();
 
         line.readToSpace(protoMB);
-        
+
         // proto is optional ( for 0.9 )
         return requestURIMB.remaining() > 0;
     }
@@ -554,30 +554,30 @@ public class Http11Connection extends HttpConnection
         line.readToSpace(statusCode);
         line.skipSpace();
         line.wrapTo(status);
-        
+
         // message may be empty
         return statusCode.remaining() > 0;
     }
 
     List<String> connectionHeaders = new ArrayList<String>();
-    
+
     private void parseHeaders(HttpChannel http, HttpMessageBytes msgBytes,
-            BBuffer head) 
+            BBuffer head)
                 throws IOException {
-        
+
         head.readLine(line);
-        
+
         int idx = 0;
-        
+
         BBuffer upgrade = null;
-        
+
         while(line.remaining() > 0) {
             // not empty..
             idx = msgBytes.addHeader();
             BBuffer nameBuf = msgBytes.getHeaderName(idx);
             BBuffer valBuf = msgBytes.getHeaderValue(idx);
             parseHeader(http, head, line, nameBuf, valBuf);
-            
+
             // TODO: process 'interesting' headers here.
             if (nameBuf.equalsIgnoreCase("connection")) {
                 // TODO: save and remove if not recognized
@@ -586,29 +586,29 @@ public class Http11Connection extends HttpConnection
                 upgrade = valBuf;
             }
         }
-        
+
         if (upgrade != null) {
             if (upgrade.equalsIgnoreCase("WebSocket")) {
-                
+
             } else if (upgrade.equalsIgnoreCase("SPDY/1.0")) {
-                
+
             }
         }
-        
-        // TODO: process connection headers 
+
+        // TODO: process connection headers
     }
 
     /**
-     * Parse one header. 
+     * Parse one header.
      * Line must be populated. On return line will be populated
      * with the next header:
-     * 
+     *
      * @param line current header line, not empty.
      */
-    int parseHeader(HttpChannel http, BBuffer head, 
+    int parseHeader(HttpChannel http, BBuffer head,
             BBuffer line, BBuffer name, BBuffer value)
           throws IOException {
-        
+
         int newPos = line.readToDelimOrSpace(COLON, name);
         line.skipSpace();
         if (line.readByte() != COLON) {
@@ -616,7 +616,7 @@ public class Http11Connection extends HttpConnection
         }
         line.skipSpace();
         line.read(value); // remaining of the line
-        
+
         while (true) {
             head.readLine(line);
             if (line.remaining() == 0) {
@@ -635,34 +635,34 @@ public class Http11Connection extends HttpConnection
         http.normalizeHeader(value);
         return 1;
     }
-    
+
     private int receiveDone(HttpChannel http, IOBuffer body, boolean frameError) throws IOException {
         // Content-length case, we're done reading
         body.close();
-        
+
         http.error = frameError;
         if (frameError) {
             closeStreamOnEnd("frame error");
         }
 
-        return DONE;        
+        return DONE;
     }
 
-    /** 
+    /**
      * Called when raw body data is received.
      * Callback should not consume past the end of the body.
-     * @param rawReceiveBuffers 
-     *  
+     * @param rawReceiveBuffers
+     *
      */
-    private void rawDataReceived(HttpChannel http, IOBuffer body, 
+    private void rawDataReceived(HttpChannel http, IOBuffer body,
             IOBuffer rawReceiveBuffers) throws IOException {
         // TODO: Make sure we don't process more than we need ( eat next req ).
         // If we read too much: leave it in readBuf, the finalzation code
         // should skip KeepAlive and start processing it.
-        // we need to read at least something - to detect -1 ( we could 
+        // we need to read at least something - to detect -1 ( we could
         // suspend right away, but seems safer
         BodyState bodys = receiveBodyState;
-        
+
         while (http.inMessage.state == HttpMessage.State.BODY_DATA) {
             if (receiveBodyState.noBody) {
                 receiveDone(http, body, false);
@@ -674,20 +674,20 @@ public class Http11Connection extends HttpConnection
                         receiveDone(http, body, false);
                     } else {
                         // End of input - other side closed, no more data
-                        //log.info("CLOSE while reading " + this);    
+                        //log.info("CLOSE while reading " + this);
                         // they're not supposed to close !
                         receiveDone(http, body, true);
                     }
                 } else {
                     receiveDone(http, body, false); // ok
                 }
-                // input connection closed ? 
+                // input connection closed ?
                 closeStreamOnEnd("Closed input");
                 return;
             }
             BBucket rawBuf = rawReceiveBuffers.peekFirst();
             if (rawBuf == null) {
-                return;  // need more data                 
+                return;  // need more data
             }
 
             if (!bodys.isContentDelimited()) {
@@ -700,7 +700,7 @@ public class Http11Connection extends HttpConnection
                     }
                 }
             } else {
-                
+
                 if (bodys.contentLength >= 0 && bodys.remaining == 0) {
                     receiveDone(http, body, false);
                     return;
@@ -729,9 +729,9 @@ public class Http11Connection extends HttpConnection
 
                 rawBuf = (BBucket) rawReceiveBuffers.peekFirst();
                 if (rawBuf == null) {
-                    return;  // need more data                 
+                    return;  // need more data
                 }
-                
+
 
                 if (bodys.remaining < rawBuf.remaining()) {
                     // To buffer has more data than we need.
@@ -759,8 +759,8 @@ public class Http11Connection extends HttpConnection
         body.queue(bb);
     }
 
-    
-    protected void sendRequest(HttpChannel http) 
+
+    protected void sendRequest(HttpChannel http)
             throws IOException {
         if (switchedProtocol != null) {
             switchedProtocol.sendRequest(http);
@@ -779,13 +779,13 @@ public class Http11Connection extends HttpConnection
             }
             CBuffer hostH = http.getRequest().getMimeHeaders().addValue("Host");
             if (target.endsWith(":80")) {
-                hostH.set(target.substring(0, target.length() - 3));                
+                hostH.set(target.substring(0, target.length() - 3));
             } else {
-                hostH.set(target);                
+                hostH.set(target);
             }
         }
-        
-        processContentDelimitation(sendBodyState, 
+
+        processContentDelimitation(sendBodyState,
                 http.getRequest());
 
 
@@ -794,13 +794,13 @@ public class Http11Connection extends HttpConnection
             // TODO: add the others
             sendBodyState.noBody = true;
         }
-        
-        // 1.0: The presence of an entity body in a request is signaled by 
-        // the inclusion of a Content-Length header field in the request 
-        // message headers. HTTP/1.0 requests containing an entity body 
+
+        // 1.0: The presence of an entity body in a request is signaled by
+        // the inclusion of a Content-Length header field in the request
+        // message headers. HTTP/1.0 requests containing an entity body
         // must include a valid Content-Length header field.
         if (http10 && !sendBodyState.isContentDelimited()) {
-            // Will not close connection - just flush and mark the body 
+            // Will not close connection - just flush and mark the body
             // as sent
             sendBodyState.noBody = true;
         }
@@ -810,7 +810,7 @@ public class Http11Connection extends HttpConnection
             http.getRequest().getMimeHeaders().remove(TRANSFERENCODING);
             http.getOut().close();
         } else {
-            long contentLength = 
+            long contentLength =
                 http.getRequest().getContentLength();
             if (contentLength < 0) {
                 http.getRequest().getMimeHeaders().addValue("Transfer-Encoding").
@@ -831,7 +831,7 @@ public class Http11Connection extends HttpConnection
             }
 
 
-            // TODO: add any body and flush. More body can be added later - 
+            // TODO: add any body and flush. More body can be added later -
             // including 'end'.
 
             http.startSending();
@@ -841,8 +841,8 @@ public class Http11Connection extends HttpConnection
         }
 
     }
-    
-    
+
+
     /**
      * Determine if we must drop the connection because of the HTTP status
      * code.  Use the same list of codes as Apache/httpd.
@@ -857,8 +857,8 @@ public class Http11Connection extends HttpConnection
         status == 503 /* SC_SERVICE_UNAVAILABLE */ ||
         status == 501 /* SC_NOT_IMPLEMENTED */;
     }
-    
-    protected void sendResponseHeaders(HttpChannel http) 
+
+    protected void sendResponseHeaders(HttpChannel http)
             throws IOException {
         if (switchedProtocol != null) {
             switchedProtocol.sendResponseHeaders(http);
@@ -872,10 +872,10 @@ public class Http11Connection extends HttpConnection
         IOBuffer sendBody = http.sendBody;
         HttpResponse res = http.getResponse();
         if (res.isCommitted()) {
-            return; 
+            return;
         }
         res.setCommitted(true);
-        
+
         sendBodyState.noBody = !res.hasBody();
 
         if (statusDropsConnection(res.getStatus())) {
@@ -902,7 +902,7 @@ public class Http11Connection extends HttpConnection
             int cl = res.getContentLength();
 
             if (http10) {
-                if (cl < 0 && !sendBodyState.noBody && 
+                if (cl < 0 && !sendBodyState.noBody &&
                         sendBody.isAppendClosed()) {
                     // We can generate content-lenght
                     cl = sendBody.available();
@@ -910,8 +910,8 @@ public class Http11Connection extends HttpConnection
                 }
                 if (cl < 0 && !sendBodyState.noBody) {
                     closeStreamOnEnd("HTTP/1.0 without content length");
-                } else { 
-                    headers.setValue(CONNECTION).set(KEEPALIVE_S);                
+                } else {
+                    headers.setValue(CONNECTION).set(KEEPALIVE_S);
                 }
             } else { // http11
                 if (!sendBodyState.noBody) {
@@ -922,40 +922,40 @@ public class Http11Connection extends HttpConnection
             }
         } else {
             headers.setValue(CONNECTION).set(CLOSE);
-            // since we close the connection - don't bother with 
+            // since we close the connection - don't bother with
             // transfer encoding
             headers.remove(TRANSFERENCODING);
         }
-        
+
         // Update our internal state based on headers we just set.
         processContentDelimitation(sendBodyState, res);
         updateCloseOnEnd(sendBodyState, http, sendBody);
-                
-    
+
+
         if (http.debug) {
             http.trace("Send response headers " + net);
         }
         if (net != null) {
             serialize(res, net.getOut());
         }
-        
+
         if (http.outMessage.state == HttpMessage.State.HEAD) {
             http.outMessage.state = HttpMessage.State.BODY_DATA;
         }
-        
+
         if (isDone(sendBodyState, sendBody)) {
             http.getOut().close();
         }
 
         if (net != null) {
             net.startSending();
-        }        
+        }
     }
 
     private void abort(String t) throws IOException {
         abort(activeHttp, t);
     }
-    
+
     private void updateCloseOnEnd(BodyState bodys, HttpChannel http, IOBuffer body) {
         if (!bodys.isContentDelimited() && !bodys.noBody) {
             closeStreamOnEnd("not content delimited");
@@ -992,7 +992,7 @@ public class Http11Connection extends HttpConnection
             closeStreamOnEnd("http 0.9");
             return;
         }
-        
+
         // TODO: also need to remove headers matching connection
         // ( like 'upgrade')
 
@@ -1010,7 +1010,7 @@ public class Http11Connection extends HttpConnection
             }
             // we have connection: keepalive, good
         } else {
-            // no connection header - for 1.1 default is keepAlive, 
+            // no connection header - for 1.1 default is keepAlive,
             // for 10 it's close
             if (http10) {
                 closeStreamOnEnd("http1.0 no connection header");
@@ -1026,7 +1026,7 @@ public class Http11Connection extends HttpConnection
         }
 
     }
-    
+
     @Override
     public void startSending(HttpChannel http) throws IOException {
         if (switchedProtocol != null) {
@@ -1047,7 +1047,7 @@ public class Http11Connection extends HttpConnection
         }
 
     }
-    
+
     protected void outClosed(HttpChannel http) throws IOException {
         if (switchedProtocol != null) {
             switchedProtocol.outClosed(http);
@@ -1055,14 +1055,14 @@ public class Http11Connection extends HttpConnection
         }
         // TODO: move it ?
         if (sendBodyState.isContentDelimited() && !http.error) {
-            if (!sendBodyState.chunked && 
+            if (!sendBodyState.chunked &&
                     sendBodyState.remaining - http.getOut().available() > 0) {
                 http.abort("CLOSE CALLED WITHOUT FULL LEN");
             }
         }
-        
+
     }
-    
+
     @Override
     public void handleFlushed(IOChannel net) throws IOException {
         if (switchedProtocol != null) {
@@ -1080,23 +1080,23 @@ public class Http11Connection extends HttpConnection
 
 
     private void flushToNext(IOBuffer body, IOBuffer out) throws IOException {
-        
+
         synchronized (this) {
-            // TODO: better head support 
+            // TODO: better head support
             if (sendBodyState.noBody) {
                 for (int i = 0; i < body.getBufferCount(); i++) {
                     Object bc = body.peekBucket(i);
                     if (bc instanceof BBucket) {
                         ((BBucket) bc).release();
                     }
-                }                    
+                }
                 body.clear();
                 return;
             }
-            
+
             // TODO: only send < remainingWrite, if buffer
             // keeps changing after startWrite() is called (shouldn't)
-            
+
             if (sendBodyState.chunked) {
                 sendChunked(sendBodyState, body, out);
             } else if (sendBodyState.contentLength >= 0) {
@@ -1107,7 +1107,7 @@ public class Http11Connection extends HttpConnection
             }
         }
     }
-    
+
     private void sendCloseDelimited(IOBuffer body, IOBuffer out) throws IOException {
         // Close delimitation
         while (true) {
@@ -1121,8 +1121,8 @@ public class Http11Connection extends HttpConnection
             out.close(); // no content-delimitation
         }
     }
-    
-    /** 
+
+    /**
      * Convert the request to bytes, ready to send.
      */
     public static void serialize(HttpRequest req, IOBuffer rawSendBuffers2) throws IOException {
@@ -1139,17 +1139,17 @@ public class Http11Connection extends HttpConnection
         rawSendBuffers2.append(BBuffer.SP);
         rawSendBuffers2.append(req.protocol());
         rawSendBuffers2.append(BBuffer.CRLF_BYTES);
-        
+
         serializeHeaders(req.getMimeHeaders(), rawSendBuffers2);
     }
 
-    /** 
+    /**
      * Convert the response to bytes, ready to send.
      */
     public static void serialize(HttpResponse res, IOBuffer rawSendBuffers2) throws IOException {
-        
+
         rawSendBuffers2.append(res.protocol()).append(' ');
-        String status = Integer.toString(res.getStatus());   
+        String status = Integer.toString(res.getStatus());
         rawSendBuffers2.append(status).append(' ');
         if (res.getMessageBuffer().length() > 0) {
             rawSendBuffers2.append(res.getMessage());
@@ -1176,7 +1176,7 @@ public class Http11Connection extends HttpConnection
         }
         rawSendBuffers2.append(BBuffer.CRLF_BYTES);
     }
-    
+
 
     private boolean sendContentLen(BodyState bodys, IOBuffer body, IOBuffer out) throws IOException {
         while (true) {
@@ -1194,7 +1194,7 @@ public class Http11Connection extends HttpConnection
                 log.severe("write more than Content-Length");
                 len = (int) bodys.remaining;
                 // data between position and limit
-                bucket = body.popLen((int) bodys.remaining); 
+                bucket = body.popLen((int) bodys.remaining);
                 out.queue(bucket);
                 while (bucket != null) {
                     bucket = body.popFirst();
@@ -1202,7 +1202,7 @@ public class Http11Connection extends HttpConnection
                         bucket.release();
                     }
                 }
-                
+
                 // forced close
                 //close();
                 bodys.remaining = 0;
@@ -1219,12 +1219,12 @@ public class Http11Connection extends HttpConnection
         }
         return false;
     }
-    
+
     private boolean sendChunked(BodyState bodys, IOBuffer body, IOBuffer out) throws IOException {
         int len = body.available();
 
         if (len > 0) {
-            ByteBuffer sendChunkBuffer = chunk.prepareChunkHeader(len); 
+            ByteBuffer sendChunkBuffer = chunk.prepareChunkHeader(len);
             bodys.remaining = len;
             out.queue(sendChunkBuffer);
             while (bodys.remaining > 0) {
@@ -1257,17 +1257,17 @@ public class Http11Connection extends HttpConnection
 
     static class ChunkState {
         static byte[] END_CHUNK_BYTES = {
-            (byte) '\r', (byte) '\n', 
-            (byte) '0', 
-            (byte) '\r', (byte) '\n', 
+            (byte) '\r', (byte) '\n',
+            (byte) '0',
+            (byte) '\r', (byte) '\n',
             (byte) '\r', (byte) '\n'};
-            
+
 
         int partialChunkLen;
         boolean readDigit = false;
         boolean trailer = false;
         protected boolean needChunkCrlf = false;
-        
+
         // Buffer used for chunk length conversion.
         protected byte[] sendChunkLength = new byte[10];
 
@@ -1276,9 +1276,9 @@ public class Http11Connection extends HttpConnection
 
         public ChunkState() {
             sendChunkLength[8] = (byte) '\r';
-            sendChunkLength[9] = (byte) '\n';            
+            sendChunkLength[9] = (byte) '\n';
         }
-        
+
         void recycle() {
             partialChunkLen = 0;
             readDigit = false;
@@ -1286,13 +1286,13 @@ public class Http11Connection extends HttpConnection
             needChunkCrlf = false;
             endSendBuffer.recycle();
         }
-        
+
         /**
          * Parse the header of a chunk.
-         * A chunk header can look like 
+         * A chunk header can look like
          * A10CRLF
          * F23;chunk-extension to be ignoredCRLF
-         * The letters before CRLF but after the trailer mark, must be valid hex digits, 
+         * The letters before CRLF but after the trailer mark, must be valid hex digits,
          * we should not parse F23IAMGONNAMESSTHISUP34CRLF as a valid header
          * according to spec
          */
@@ -1361,7 +1361,7 @@ public class Http11Connection extends HttpConnection
             readDigit = false;
             return result;
         }
-        
+
 
         ByteBuffer prepareChunkHeader(int current) {
             int pos = 7; // 8, 9 are CRLF
@@ -1384,12 +1384,12 @@ public class Http11Connection extends HttpConnection
         }
 
         public BBuffer endChunk() {
-            if (! needChunkCrlf) { 
-                endSendBuffer.setBytes(END_CHUNK_BYTES, 2, 
+            if (! needChunkCrlf) {
+                endSendBuffer.setBytes(END_CHUNK_BYTES, 2,
                         END_CHUNK_BYTES.length - 2); // CRLF
             } else { // 0
-                endSendBuffer.setBytes(END_CHUNK_BYTES, 0, 
-                        END_CHUNK_BYTES.length);                
+                endSendBuffer.setBytes(END_CHUNK_BYTES, 0,
+                        END_CHUNK_BYTES.length);
             }
             return endSendBuffer;
         }
@@ -1407,7 +1407,7 @@ public class Http11Connection extends HttpConnection
 
         public void recycle() {
             chunked = false;
-            remaining = 0; 
+            remaining = 0;
             contentLength = -1;
             noBody = false;
         }
@@ -1426,12 +1426,12 @@ public class Http11Connection extends HttpConnection
         (keepAlive() ? " KA " : "") +
         (headersReceived ? " HEAD " : "") +
         (bodyReceived ? " BODY " : "")
-        ;  
+        ;
     }
 
     @Override
     public void handleConnected(IOChannel net) throws IOException {
-        HttpChannel httpCh = activeHttp; 
+        HttpChannel httpCh = activeHttp;
 
         if (!net.isOpen()) {
             httpCh.abort(net.lastException());
@@ -1441,8 +1441,8 @@ public class Http11Connection extends HttpConnection
         boolean ssl = httpCh.getRequest().isSecure();
         if (ssl) {
             String[] hostPort = httpCh.getTarget().split(":");
-            
-            IOChannel ch1 = httpConnector.sslProvider.channel(net, 
+
+            IOChannel ch1 = httpConnector.sslProvider.channel(net,
                     hostPort[0], Integer.parseInt(hostPort[1]));
             //net.setHead(ch1);
             net = ch1;
@@ -1450,9 +1450,9 @@ public class Http11Connection extends HttpConnection
         if (httpConnector.debugHttp) {
             net = DumpChannel.wrap("Http-Client-", net);
         }
-        
+
         setSink(net);
-        
+
         sendRequest(httpCh);
     }
 

==================================================
HttpClient.java
index 07ed719a22..cb4b2ada8d 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpChannel.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpChannel.java
@@ -29,13 +29,13 @@ import org.apache.tomcat.lite.io.IOConnector;
 
 /**
  * HTTP async client and server, based on tomcat NIO/APR connectors
- * 
- * 'Input', 'read', 'Recv' refers to information we get from the remote side - 
+ *
+ * 'Input', 'read', 'Recv' refers to information we get from the remote side -
  * the request body for server-mode or response body for client.
- * 
- * 'Output', 'write', 'Send' is for info we send - the post in client mode 
+ *
+ * 'Output', 'write', 'Send' is for info we send - the post in client mode
  * and the response body for server mode.
- * 
+ *
  * @author Costin Manolache
  */
 public class HttpChannel extends IOChannel {
@@ -47,85 +47,85 @@ public class HttpChannel extends IOChannel {
     public static final String CONTENT_LENGTH= "Content-Length";
 
     public static final String HTTP_10 = "HTTP/1.0";
-    
+
     public static final String HTTP_11 = "HTTP/1.1";
-    
+
     /**
      * SEMI_COLON.
      */
     public static final byte SEMI_COLON = (byte) ';';
-    
+
     public static final byte QUESTION = (byte) '?';
-    
-    
+
+
     protected static Logger log = Logger.getLogger("HttpChannel");
 
-    
+
     boolean debug = false;
-    
-    // ---- Callbacks and locks 
-    
+
+    // ---- Callbacks and locks
+
     FutureCallbacks<HttpChannel> doneLock = new FutureCallbacks<HttpChannel>();
-    FutureCallbacks<HttpChannel> headersReceivedLock = 
+    FutureCallbacks<HttpChannel> headersReceivedLock =
             new FutureCallbacks<HttpChannel>();
     /**
      * Called when the incoming headers have been received.
      * ( response for client mode, request for server mode )
-     * @throws IOException 
+     * @throws IOException
      */
     protected HttpService httpService;
-    /** 
+    /**
      * Called when:
      *  - body sent
      *  - body received
-     *  - release() called - either service() done or client done with the 
-     *  buffers. 
-     *  
+     *  - release() called - either service() done or client done with the
+     *  buffers.
+     *
      *  After this callback:
      *  - socket closed if closeOnEndSend, or put in keep-alive
      *  - AsyncHttp.recycle()
      *  - returned to the pool.
      */
     private RequestCompleted doneAllCallback;
-    protected boolean sendReceiveDone = false; 
-    
-    // Will be signalled (open) when the buffer is empty. 
+    protected boolean sendReceiveDone = false;
+
+    // Will be signalled (open) when the buffer is empty.
     FutureCallbacks<IOChannel> flushLock = new FutureCallbacks<IOChannel>();
-    
+
     FutureCallbacks<HttpChannel> doneFuture;
     boolean doneCallbackCalled = false;
 
 
-    // ---------- 
-    
+    // ----------
+
     // Set if Exect: 100-continue was set on reqest.
     // If this is the case - body won't be sent until
     // server responds ( client ) and server will only
-    // read body after ack() - or skip to next request 
+    // read body after ack() - or skip to next request
     // without swallowing the body.
     protected boolean expectation = false;
-    
+
     /** Ready for recycle, if send/receive are done */
     protected boolean release = false;
-    
-    // ----------- 
-    
+
+    // -----------
+
     protected boolean headersDone = false;
     protected boolean error = false;
     protected boolean abortDone = false;
-    
-    
+
+
     protected int ser; // id - for jmx registration and logs
     protected int channelId;
 
-    /** 
+    /**
      * Null after endSendReceive and before sending the request
      */
     HttpConnection conn;
 
     HttpConnector httpConnector;
 
-    // Different ways to point to request response (server/client) 
+    // Different ways to point to request response (server/client)
     HttpRequest httpReq;
     HttpResponse httpRes;
     HttpMessage inMessage;
@@ -141,16 +141,16 @@ public class HttpChannel extends IOChannel {
             }
             super.close();
             outClosed();
-        }        
+        }
     };
-    
 
-    // Server side only 
+
+    // Server side only
     protected String serverHeader = "TomcatLite";
-    
-    long ioTimeout = 30 * 60000; // 30 min seems high enough 
 
-        
+    long ioTimeout = 30 * 60000; // 30 min seems high enough
+
+
     public HttpChannel() {
         ser = serCnt.incrementAndGet();
         httpReq = new HttpRequest(this);
@@ -158,19 +158,19 @@ public class HttpChannel extends IOChannel {
         init();
         serverMode(false);
     }
-    
-    /** 
-     * Close the connection, return to pool. Called if a 
+
+    /**
+     * Close the connection, return to pool. Called if a
      * framing error happens, or if we want to force the connection
      * to close, without waiting for all data to be sent/received.
-     * @param t 
-     * 
+     * @param t
+     *
      * @throws IOException
      */
     public void abort(Throwable t) {
         abort(t.toString());
     }
-    
+
     public void abort(String t)  {
         synchronized (this) {
             if (abortDone) {
@@ -193,7 +193,7 @@ public class HttpChannel extends IOChannel {
             log.severe("Exception in abort " + ex);
         }
     }
-    
+
     /**
      * If release was called - throw exception, you shouldn't use
      * the object again.
@@ -202,9 +202,9 @@ public class HttpChannel extends IOChannel {
     private void checkRelease() throws IOException {
         if (release && sendReceiveDone) {
             throw new IOException("Object released");
-        }        
+        }
     }
-    
+
     public IOChannel getSink() {
         if (conn == null) {
             return null;
@@ -212,15 +212,15 @@ public class HttpChannel extends IOChannel {
         return conn.getSink();
     }
 
-    
+
     /**
      * Called when the request is done. Need to send remaining byte.
-     * 
+     *
      */
     public void complete() throws IOException {
         checkRelease();
         if (!getOut().isAppendClosed()) {
-            getOut().close();            
+            getOut().close();
         }
         if (!getIn().isAppendClosed()) {
             getIn().close();
@@ -228,7 +228,7 @@ public class HttpChannel extends IOChannel {
 
         startSending();
    }
-    
+
     public int doRead(BBuffer chunk)
             throws IOException {
         checkRelease();
@@ -243,13 +243,13 @@ public class HttpChannel extends IOChannel {
             } else {
                 System.err.println("Spurious waitData signal, no data");
             }
-        } 
+        }
         chunk.append(next.array(), next.position(), next.remaining());
         int read =  next.remaining();
         next.release();
         return read;
     }
-    
+
     public HttpConnector getConnector() {
         return httpConnector;
     }
@@ -257,9 +257,9 @@ public class HttpChannel extends IOChannel {
     public boolean getError() {
         return error;
     }
-    
-    // ---------------- Writting ------------------------------- 
-    
+
+    // ---------------- Writting -------------------------------
+
     public String getId() {
         return Integer.toString(ser);
     }
@@ -267,8 +267,8 @@ public class HttpChannel extends IOChannel {
     public IOBuffer getIn() {
         return receiveBody;
     }
-    
-    
+
+
     public long getIOTimeout() {
         return ioTimeout;
     }
@@ -280,8 +280,8 @@ public class HttpChannel extends IOChannel {
         }
         return conn.getSink();
     }
-    
-    
+
+
     public IOBuffer getOut() {
         return sendBody;
     }
@@ -289,23 +289,23 @@ public class HttpChannel extends IOChannel {
     public HttpRequest getRequest() {
         return httpReq;
     }
-    
-    
+
+
     public HttpResponse getResponse() {
         return httpRes;
     }
-    
-      
+
+
     public String getState() {
         return
-            conn + 
-            "RCV=[" + inMessage.state.toString() + " " + 
-            receiveBody.toString()  
-            + "] SND=[" + outMessage.state.toString() 
+            conn +
+            "RCV=[" + inMessage.state.toString() + " " +
+            receiveBody.toString()
+            + "] SND=[" + outMessage.state.toString()
             + " " + sendBody.toString() + "]";
     }
 
-    
+
     public String getStatus() {
         return getResponse().getStatus() + " " + getResponse().getMessage();
     }
@@ -313,16 +313,16 @@ public class HttpChannel extends IOChannel {
 
     public String getTarget() {
         if (target == null) {
-            return ":0"; // server mode ? 
+            return ":0"; // server mode ?
         }
         return target.toString();
     }
 
 
     /**
-     * Called from IO thread, after the request body 
+     * Called from IO thread, after the request body
      * is completed ( or if there is no req body )
-     * @throws IOException 
+     * @throws IOException
      */
     protected void handleEndReceive() throws IOException {
         if (inMessage.state == HttpMessage.State.DONE) {
@@ -340,54 +340,54 @@ public class HttpChannel extends IOChannel {
     /*
      * Called when sending, receiving and processing is done.
      * Can be called:
-     *  - from IO thread, if this is a result of a read/write event that 
+     *  - from IO thread, if this is a result of a read/write event that
      *  finished the send/recev pair.
      *  - from an arbitrary thread, if read was complete and the last write
      *  was a success and done in that thread ( write is not bound to IO thr)
-     * 
+     *
      */
     protected void handleEndSendReceive() throws IOException {
         // make sure the callback was called ( needed for abort )
         handleHeadersReceived(inMessage);
-        
+
         this.doneLock.signal(this);
         synchronized (this) {
             if (doneCallbackCalled) {
                 return;
             }
-            if (outMessage.state != HttpMessage.State.DONE || 
+            if (outMessage.state != HttpMessage.State.DONE ||
                     inMessage.state != HttpMessage.State.DONE) {
                 return;
             }
             doneCallbackCalled = true;
         }
-        
+
         getIn().close();
-        
+
         if (doneAllCallback != null) {
             doneAllCallback.handle(this, error ? new Throwable() : null);
         }
-        
+
         if (conn != null) {
             conn.endSendReceive(this);
         }
-        
+
         conn = null;
-        
+
         if (debug) {
-            trace("END_SEND_RECEIVE" 
+            trace("END_SEND_RECEIVE"
                     + (release ? " REL" : ""));
         }
-            
+
         synchronized(this) {
             sendReceiveDone = true;
             maybeRelease();
         }
     }
-    
-    /** 
+
+    /**
      * called from IO thread OR servlet thread when last block has been sent.
-     * If not using the socket ( net.getOut().flushCallback ) - this must 
+     * If not using the socket ( net.getOut().flushCallback ) - this must
      * be called explicitely after flushing the body.
      */
     void handleEndSent() throws IOException {
@@ -401,14 +401,14 @@ public class HttpChannel extends IOChannel {
         outMessage.state = HttpMessage.State.DONE;
 
         getOut().close();
-        
+
         // Make sure the send/receive callback is called once
         if (debug) {
             trace("END_SEND");
         }
         handleEndSendReceive();
     }
-    
+
     // ----- End Selector thread callbacks ----
     public void handleError(String type) {
         System.err.println("Error " + type + " " + outMessage.state);
@@ -427,49 +427,49 @@ public class HttpChannel extends IOChannel {
                 }
             }
         }
-    }   
+    }
 
 
     private void init() {
         headersDone = false;
         sendReceiveDone = false;
-        
+
         receiveBody.recycle();
         sendBody.recycle();
         expectation = false;
-        
+
         error = false;
         abortDone = false;
-       
-        
+
+
         getRequest().recycle();
         getResponse().recycle();
         target = null;
-        
+
         doneLock.recycle();
         headersReceivedLock.recycle();
         flushLock.recycle();
-        
+
         doneCallbackCalled = false;
         // Will be set again after pool
         setHttpService(null);
         doneAllCallback = null;
         release = false;
     }
-    
+
     public boolean isDone() {
         return outMessage.state == HttpMessage.State.DONE && inMessage.state == HttpMessage.State.DONE;
     }
-    
+
     /**
      * Called when all done:
      *  - service finished ( endService was called )
      *  - output written
      *  - input read
-     *  
-     * or by abort(). 
-     *  
-     * @throws IOException 
+     *
+     * or by abort().
+     *
+     * @throws IOException
      */
     private void maybeRelease() throws IOException {
         synchronized (this) {
@@ -488,20 +488,20 @@ public class HttpChannel extends IOChannel {
 
 
     /*
-    The field-content does not include any leading or trailing LWS: 
-    linear white space occurring before the first non-whitespace 
+    The field-content does not include any leading or trailing LWS:
+    linear white space occurring before the first non-whitespace
     character of the field-value or after the last non-whitespace
-     character of the field-value. Such leading or trailing LWS MAY 
-     be removed without changing the semantics of the field value. 
-     Any LWS that occurs between field-content MAY be replaced with 
-     a single Http11Parser.SP before interpreting the field value or forwarding 
+     character of the field-value. Such leading or trailing LWS MAY
+     be removed without changing the semantics of the field value.
+     Any LWS that occurs between field-content MAY be replaced with
+     a single Http11Parser.SP before interpreting the field value or forwarding
      the message downstream.
      */
     int normalizeHeader(BBuffer value) {
         byte[] buf = value.array();
         int cstart = value.position();
         int end = value.limit();
-        
+
         int realPos = cstart;
         int lastChar = cstart;
         byte chr = 0;
@@ -527,32 +527,32 @@ public class HttpChannel extends IOChannel {
             }
         }
         realPos = lastChar;
-        
+
         // so buffer is clean
         for (int i = realPos; i < end; i++) {
             buf[i] = BBuffer.SP;
         }
         value.setEnd(realPos);
         return realPos;
-    }  
-    
-    
+    }
+
+
     protected void recycle() {
-        if (debug) { 
+        if (debug) {
             trace("RECYCLE");
         }
         init();
     }
 
-    /** 
-     * Finalize sending and receiving. 
+    /**
+     * Finalize sending and receiving.
      * Indicates client is no longer interested, some IO may still be in flight.
      * If in a POST and you're not interested in the body - it may be
      * better to call abort().
-     *  
+     *
      * MUST be called to allow connection reuse and pooling.
-     * 
-     * @throws IOException 
+     *
+     * @throws IOException
      */
     public void release() throws IOException {
         synchronized(this) {
@@ -569,22 +569,22 @@ public class HttpChannel extends IOChannel {
     public void send() throws IOException {
         checkRelease();
         if (httpReq == inMessage) {
-            conn.sendResponseHeaders(this);   
+            conn.sendResponseHeaders(this);
         } else {
             if (getRequest().isCommitted()) {
                 return;
             }
             getRequest().setCommitted(true);
-            
+
             outMessage.state = HttpMessage.State.HEAD;
-            
+
             getConnector().connectAndSend(this);
         }
     }
-    
+
     /** Called when the outgoing stream is closed:
      * - by an explicit call to close()
-     * - when all content has been sent. 
+     * - when all content has been sent.
      */
     protected void outClosed() throws IOException {
         if (conn != null) {
@@ -608,8 +608,8 @@ public class HttpChannel extends IOChannel {
         }
         return this;
     }
-    
-    public void setCompletedCallback(RequestCompleted doneAllCallback) 
+
+    public void setCompletedCallback(RequestCompleted doneAllCallback)
             throws IOException {
         this.doneAllCallback = doneAllCallback;
         synchronized (this) {
@@ -638,18 +638,18 @@ public class HttpChannel extends IOChannel {
         ioTimeout = timeout;
     }
 
-    
+
     public void setTarget(String host) {
         this.target = host;
     }
-    
+
     public void startSending() throws IOException {
         checkRelease();
         if (conn != null) {
             conn.startSending(this);
         }
     }
-    
+
     public String toString() {
         StringBuffer sb = new StringBuffer();
         sb.append("id=").append(ser)
@@ -657,14 +657,14 @@ public class HttpChannel extends IOChannel {
             .append(")");
         return sb.toString();
     }
-    
+
 
     void trace(String msg) {
         if(debug) {
             log.info(this.toString() + " " + msg + " done=" + doneCallbackCalled);
         }
     }
- 
+
     @Override
     public void waitFlush(long timeMs) throws IOException {
         if (getOut().getBufferCount() == 0) {
@@ -672,19 +672,19 @@ public class HttpChannel extends IOChannel {
         }
         flushLock.waitSignal(timeMs);
     }
- 
+
     public HttpChannel setConnection(HttpConnection conn) {
         this.conn = conn;
         return this;
     }
-    
+
     /**
      * Normalize URI.
      * <p>
      * This method normalizes "\", "//", "/./" and "/../". This method will
      * return false when trying to go above the root, or if the URI contains
      * a null byte.
-     * 
+     *
      * @param uriMB URI to be normalized, will be modified
      */
     public static boolean normalize(BBuffer uriBC) {
@@ -701,7 +701,7 @@ public class HttpChannel extends IOChannel {
             // TODO: http://.... URLs
             return true;
         }
-        
+
         int pos = 0;
         int index = 0;
 
@@ -733,8 +733,8 @@ public class HttpChannel extends IOChannel {
         // Note: It is possible to extend the URI by 1 without any side effect
         // as the next character is a non-significant WS.
         if (((end - start) >= 2) && (b[end - 1] == (byte) '.')) {
-            if ((b[end - 2] == (byte) '/') 
-                    || ((b[end - 2] == (byte) '.') 
+            if ((b[end - 2] == (byte) '/')
+                    || ((b[end - 2] == (byte) '.')
                             && (b[end - 3] == (byte) '/'))) {
                 b[end] = (byte) '/';
                 end++;
@@ -750,7 +750,7 @@ public class HttpChannel extends IOChannel {
             index = uriBC.indexOf("/./", 0, 3, index);
             if (index < 0)
                 break;
-            copyBytes(b, start + index, start + index + 2, 
+            copyBytes(b, start + index, start + index + 2,
                     end - start - index - 2);
             end = end - 2;
             uriBC.setEnd(end);
@@ -786,7 +786,7 @@ public class HttpChannel extends IOChannel {
     }
 
     /**
-     * Copy an array of bytes to a different position. Used during 
+     * Copy an array of bytes to a different position. Used during
      * normalization.
      */
     private static void copyBytes(byte[] b, int dest, int src, int len) {
@@ -794,26 +794,26 @@ public class HttpChannel extends IOChannel {
             b[pos + dest] = b[pos + src];
         }
     }
-    
-    
+
+
     /**
-     * This method will be called when the http headers have been received - 
-     * the body may or may not be available. 
-     * 
-     * In server mode this is equivalent with a servlet request. 
+     * This method will be called when the http headers have been received -
+     * the body may or may not be available.
+     *
+     * In server mode this is equivalent with a servlet request.
      * This is also called for http client, when the response headers
-     * are received. 
-     *  
+     * are received.
+     *
      * TODO: rename it to HttMessageReceived or something similar.
      */
     public static interface HttpService {
         void service(HttpRequest httpReq, HttpResponse httpRes) throws IOException;
     }
-    
-    /** 
+
+    /**
      * Called when both request and response bodies have been sent/
      * received. After this call the HttpChannel will be disconnected
-     * from the http connection, which can be used for other requests. 
+     * from the http connection, which can be used for other requests.
      */
     public static interface RequestCompleted {
         void handle(HttpChannel data, Object extraData) throws IOException;
@@ -825,6 +825,6 @@ public class HttpChannel extends IOChannel {
             getConnector().getDispatcher().runService(HttpChannel.this);
         }
     };
-    
+
 
 }
\ No newline at end of file

==================================================
HttpConnectionPool.java
index 61d60f59d6..d53796230e 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpClient.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpClient.java
@@ -6,13 +6,13 @@ import org.apache.tomcat.lite.io.SocketConnector;
 import org.apache.tomcat.lite.io.SslProvider;
 import org.apache.tomcat.lite.io.jsse.JsseSslProvider;
 
-/** 
+/**
  * Entry point for http client code.
  *
- * ( initial version after removing 'integration', will add settings, 
+ * ( initial version after removing 'integration', will add settings,
  * defaults, helpers )
  */
-public class HttpClient { 
+public class HttpClient {
     static SslProvider sslConC = new JsseSslProvider();
 
     public synchronized static HttpConnector newClient() {

==================================================
HttpConnector.java
index 447935475d..ab568302be 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpConnectionPool.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpConnectionPool.java
@@ -20,52 +20,52 @@ import org.apache.tomcat.lite.io.IOConnector;
 
 /**
  * - Holds references to all active and kept-alive connections.
- * - makes decisions on accepting more connections, closing old 
+ * - makes decisions on accepting more connections, closing old
  * connections, etc
- * 
+ *
  */
 public class HttpConnectionPool {
-    // TODO: add timeouts, limits per host/total, expire old entries 
-   
+    // TODO: add timeouts, limits per host/total, expire old entries
+
     public static interface HttpConnectionPoolEvents {
         public void newTarget(RemoteServer host);
 
         public void targetRemoved(RemoteServer host);
-        
+
         public void newConnection(RemoteServer host, HttpConnection con);
         public void closedConnection(RemoteServer host, HttpConnection con);
     }
-    
-    /** 
+
+    /**
      * Connections for one remote host.
      * This should't be restricted by IP:port or even hostname,
-     * for example if a server has multiple IPs or LB replicas - any would work.   
+     * for example if a server has multiple IPs or LB replicas - any would work.
      */
     public static class RemoteServer {
         // all access sync on RemoteServer
         private SpdyConnection spdy;
-        
+
         // all access sync on RemoteServer
-        private ArrayList<Http11Connection> connections 
+        private ArrayList<Http11Connection> connections
             = new ArrayList<Http11Connection>();
-        
+
         Queue<HttpChannel> pending = new LinkedList<HttpChannel>();
-        
-        
+
+
         // TODO: setter, default from connector
         private int maxConnections = 20;
-        
+
         AtomicInteger activeRequests = new AtomicInteger();
         AtomicInteger totalRequests = new AtomicInteger();
         private volatile long lastActivity;
 
         public String target;
-        
-        public synchronized List<HttpConnector.HttpConnection> getConnections() 
+
+        public synchronized List<HttpConnector.HttpConnection> getConnections()
         {
             return new ArrayList<HttpConnection>(connections);
         }
-        
+
         public synchronized Collection<HttpChannel> getActives() {
             ArrayList<HttpChannel> actives = new ArrayList();
             for (Http11Connection con: connections) {
@@ -76,7 +76,7 @@ public class HttpConnectionPool {
             if (spdy != null) {
                 actives.addAll(spdy.getActives());
             }
-            
+
             return actives;
         }
 
@@ -86,14 +86,14 @@ public class HttpConnectionPool {
     }
 
     private HttpConnectionPoolEvents poolEvents;
-    
+
     private static Logger log = Logger.getLogger("HttpConnector");
 
-    // visible for debugging - will be made private, with accessor 
+    // visible for debugging - will be made private, with accessor
     /**
      * Map from client names to socket pools.
      */
-    public Map<CharSequence, HttpConnectionPool.RemoteServer> hosts = new HashMap<CharSequence, 
+    public Map<CharSequence, HttpConnectionPool.RemoteServer> hosts = new HashMap<CharSequence,
         HttpConnectionPool.RemoteServer>();
 
     // Statistics
@@ -103,12 +103,12 @@ public class HttpConnectionPool {
     public AtomicInteger hits = new AtomicInteger();
     public AtomicInteger misses = new AtomicInteger();
     public AtomicInteger queued = new AtomicInteger();
-    
+
     public AtomicInteger activeRequests = new AtomicInteger();
-    
+
     private static boolean debug = false;
     HttpConnector httpConnector;
-    
+
     public HttpConnectionPool(HttpConnector httpConnector) {
         this.httpConnector = httpConnector;
     }
@@ -128,7 +128,7 @@ public class HttpConnectionPool {
     public Set<CharSequence> getKeepAliveTargets() {
         return hosts.keySet();
     }
-    
+
     public List<RemoteServer> getServers() {
         return new ArrayList<RemoteServer>(hosts.values());
     }
@@ -136,7 +136,7 @@ public class HttpConnectionPool {
     public void setEvents(HttpConnectionPoolEvents events) {
         this.poolEvents = events;
     }
-    /** 
+    /**
      * Stop all cached connections.
      */
     public void clear() throws IOException {
@@ -161,16 +161,16 @@ public class HttpConnectionPool {
                         }
                     }
                     if (hostActive != rs.activeRequests.get()) {
-                        log.warning("Active missmatch " + rs.target + " " + 
-                                hostActive + " " 
+                        log.warning("Active missmatch " + rs.target + " " +
+                                hostActive + " "
                                 + rs.activeRequests.get());
-                        rs.activeRequests.set(hostActive);                        
+                        rs.activeRequests.set(hostActive);
                     }
                     active += hostActive;
                 }
             }
             if (active != this.activeRequests.get()) {
-                log.warning("Active missmatch " + active + " " 
+                log.warning("Active missmatch " + active + " "
                         + activeRequests.get());
                 activeRequests.set(active);
             }
@@ -179,28 +179,28 @@ public class HttpConnectionPool {
 
     /**
      * Stop all active and cached connections
-     * @throws IOException 
+     * @throws IOException
      */
     public void abort() throws IOException {
         // TODO
         clear();
         hosts.clear();
     }
-    
-    /** 
+
+    /**
      * @param key host:port, or some other key if multiple hosts:ips
-     * are connected to equivalent servers ( LB ) 
-     * @param httpCh 
-     * @throws IOException 
+     * are connected to equivalent servers ( LB )
+     * @param httpCh
+     * @throws IOException
      */
-    public void send(HttpChannel httpCh) 
+    public void send(HttpChannel httpCh)
             throws IOException {
         String target = httpCh.getTarget();
         HttpConnection con = null;
-        // TODO: check ssl on connection - now if a second request 
+        // TODO: check ssl on connection - now if a second request
         // is received on a ssl connection - we just send it
         boolean ssl = httpCh.getRequest().isSecure();
-        
+
         HttpConnectionPool.RemoteServer remoteServer = null;
         synchronized (hosts) {
             remoteServer = hosts.get(target);
@@ -210,20 +210,20 @@ public class HttpConnectionPool {
                 hosts.put(target, remoteServer);
             }
         }
-        
+
         // TODO: remove old servers and connections
 
         // Temp magic - until a better negotiation is defined
-        boolean forceSpdy = "SPDY/1.0".equals(httpCh.getRequest().getProtocol()); 
+        boolean forceSpdy = "SPDY/1.0".equals(httpCh.getRequest().getProtocol());
         if (forceSpdy) {
             // switch back the protocol
             httpCh.getRequest().setProtocol("HTTP/1.1");
         }
-        
+
         activeRequests.incrementAndGet();
         remoteServer.activeRequests.incrementAndGet();
-        
-        // if we already have a spdy connection or explicitely 
+
+        // if we already have a spdy connection or explicitely
         // requested.
         if (forceSpdy || remoteServer.spdy != null) {
             synchronized (remoteServer) {
@@ -233,8 +233,8 @@ public class HttpConnectionPool {
                 }
                 con = remoteServer.spdy;
             }
-            
-            // Will be queued - multiple threads may try to send 
+
+            // Will be queued - multiple threads may try to send
             // at the same time, and we need to queue anyways.
             con.sendRequest(httpCh);
         } else {
@@ -244,7 +244,7 @@ public class HttpConnectionPool {
                     hcon = (Http11Connection) remoteServer.connections.get(i);
                     if (hcon != null && hcon.activeHttp == null) {
                         hcon.beforeRequest(); // recycle
-                        
+
                         hcon.activeHttp = httpCh;
                         con = hcon;
                         break;
@@ -271,7 +271,7 @@ public class HttpConnectionPool {
 
             // we got a connection - make sure we're connected
             http11ConnectOrSend(httpCh, target, con, ssl);
-        }        
+        }
     }
 
     private void http11ConnectOrSend(HttpChannel httpCh, String target,
@@ -289,12 +289,12 @@ public class HttpConnectionPool {
             if (debug) {
                 log.info("HTTP_CONNECT: Start connection " + target + " " + this);
             }
-            httpConnect(httpCh, target, ssl, 
+            httpConnect(httpCh, target, ssl,
                     (Http11Connection) con);
         }
     }
 
-    void httpConnect(HttpChannel httpCh, String target, 
+    void httpConnect(HttpChannel httpCh, String target,
             boolean ssl, IOConnector.ConnectedCallback cb)
             throws IOException {
         if (debug) {
@@ -311,7 +311,7 @@ public class HttpConnectionPool {
                 cb);
     }
 
-    public void afterRequest(HttpChannel http, HttpConnection con, 
+    public void afterRequest(HttpChannel http, HttpConnection con,
             boolean keepAlive)
                 throws IOException {
         activeRequests.decrementAndGet();
@@ -325,16 +325,16 @@ public class HttpConnectionPool {
             afterClientRequest(con);
         }
     }
-    
-    private void afterClientRequest(HttpConnection con) 
+
+    private void afterClientRequest(HttpConnection con)
             throws IOException {
         RemoteServer remoteServer = con.remoteHost;
         HttpChannel req = null;
-        
+
         // If we have pending requests ( because too many active limit ), pick
-        // one and send it. 
+        // one and send it.
         synchronized (remoteServer) {
-            // If closed - we can remove the object - or 
+            // If closed - we can remove the object - or
             // let a background thread do it, in case it's needed
             // again.
             if (remoteServer.pending.size() == 0) {
@@ -347,14 +347,14 @@ public class HttpConnectionPool {
                 log.info("After request: send pending " + remoteServer.pending.size());
             }
         }
-        
-        http11ConnectOrSend(req, con.getTarget().toString(), 
+
+        http11ConnectOrSend(req, con.getTarget().toString(),
                 con, req.getRequest().isSecure());
     }
 
     RemoteServer serverPool = new RemoteServer();
-    
-    public void afterServerRequest(HttpConnection con, boolean keepAlive) 
+
+    public void afterServerRequest(HttpConnection con, boolean keepAlive)
             throws IOException {
         con.activeHttp = null;
         if (!keepAlive) {
@@ -363,8 +363,8 @@ public class HttpConnectionPool {
                 serverPool.connections.remove(con);
             }
         }
-    }   
-    
+    }
+
     public HttpConnection accepted(IOChannel accepted) {
         Http11Connection con = new Http11Connection(httpConnector);
         con.remoteHost = serverPool;
@@ -374,7 +374,7 @@ public class HttpConnectionPool {
         return con;
     }
 
-    
+
     // Called by handleClosed
     void stopKeepAlive(IOChannel schannel) {
         CharSequence target = schannel.getTarget();
@@ -386,7 +386,7 @@ public class HttpConnectionPool {
             }
         }
         synchronized (remoteServer) {
-            if (remoteServer.connections.remove(schannel)) {      
+            if (remoteServer.connections.remove(schannel)) {
                 waitingSockets.decrementAndGet();
                 if (remoteServer.connections.size() == 0) {
                     hosts.remove(target);

==================================================
HttpMessage.java
index 722dda2287..0b4708d4f7 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpConnector.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpConnector.java
@@ -21,56 +21,56 @@ import org.apache.tomcat.lite.io.IOConnector.DataReceivedCallback;
 
 /**
  * Manages HttpChannels and associated socket pool.
- * 
- * 
+ *
+ *
  * @author Costin Manolache
  */
 public class HttpConnector {
-    
+
     public static interface HttpChannelEvents {
         /** HttpChannel object created. It'll be used many times.
-         * @throws IOException 
+         * @throws IOException
          */
         public void onCreate(HttpChannel ch, HttpConnector con) throws IOException;
-        
-        /** 
+
+        /**
          * HttpChannel object no longer needed, out of pool.
-         * @throws IOException 
+         * @throws IOException
          */
         public void onDestroy(HttpChannel ch, HttpConnector con) throws IOException;
     }
-    
+
     private static Logger log = Logger.getLogger("HttpConnector");
-    
-    /** 
+
+    /**
      * Cache HttpChannel/request/buffers
      */
     private int maxHttpPoolSize = 50;
-    
-    /** 
-     * Max number of connections to keep alive. 
+
+    /**
+     * Max number of connections to keep alive.
      * Each connection holds a header buffer and the socket.
      * ( we could skip the header buffer )
      */
     private int maxSocketPoolSize = 500; // 10000;
-    
+
     private int keepAliveTimeMs = 300000;
-    
+
     private List<HttpChannel> httpChannelPool = new ArrayList<HttpChannel>();
 
     protected IOConnector ioConnector;
-    
+
     // for https connections
     protected SslProvider sslProvider;
-    
+
     boolean debugHttp = false;
     boolean debug = false;
-    
+
     boolean clientKeepAlive = true;
     boolean serverKeepAlive = true;
 
     HttpChannelEvents httpEvents;
-    
+
     public AtomicInteger inUse = new AtomicInteger();
     public AtomicInteger newHttpChannel = new AtomicInteger();
     public AtomicInteger totalHttpChannel = new AtomicInteger();
@@ -79,7 +79,7 @@ public class HttpConnector {
     public AtomicInteger reusedChannels = new AtomicInteger();
 
     public HttpConnectionPool cpool = new HttpConnectionPool(this);
-        
+
     // Host + context mapper.
     Dispatcher dispatcher;
     protected HttpService defaultService;
@@ -88,11 +88,11 @@ public class HttpConnector {
     private Timer timer;
 
     boolean compression = true;
-    
+
     boolean serverSSL = false;
 
     private static Timer defaultTimer = new Timer(true);
-    
+
     public HttpConnector(IOConnector ioConnector) {
         this.ioConnector = ioConnector;
         dispatcher = new Dispatcher();
@@ -108,20 +108,20 @@ public class HttpConnector {
     protected HttpConnector() {
         this(null);
     }
-    
+
     public Dispatcher getDispatcher() {
         return dispatcher;
     }
-    
+
     public HttpConnectionPool getConnectionPool() {
         return cpool;
     }
-    
+
     public HttpConnector withIOConnector(IOConnector selectors) {
         ioConnector = selectors;
         return this;
     }
-    
+
     public void setDebug(boolean b) {
         this.debug = b;
     }
@@ -129,22 +129,22 @@ public class HttpConnector {
     public void setDebugHttp(boolean b) {
         this.debugHttp  = b;
     }
-    
+
     public HttpConnector withSsl(SslProvider ssl) {
         sslProvider = ssl;
         return this;
     }
-    
+
     HttpConnector setServerSsl(boolean b) {
         serverSSL = b;
         return this;
     }
-    
+
     public SslProvider getSslProvider() {
         return sslProvider;
     }
-    
-    /** 
+
+    /**
      * Allow or disable compression for this connector.
      * Compression is enabled by default.
      */
@@ -160,7 +160,7 @@ public class HttpConnector {
     public void setServerKeepAlive(boolean b) {
         this.serverKeepAlive = b;
     }
-    
+
     public boolean isDebug() {
         return debug;
     }
@@ -180,7 +180,7 @@ public class HttpConnector {
     public int getMaxHttpPoolSize() {
         return maxHttpPoolSize;
     }
-    
+
     public void setMaxHttpPoolSize(int maxHttpPoolSize) {
         this.maxHttpPoolSize = maxHttpPoolSize;
     }
@@ -188,12 +188,12 @@ public class HttpConnector {
     public void setOnCreate(HttpChannelEvents callback) {
         httpEvents = callback;
     }
-    
+
     /**
      *  Override to create customized client/server connections.
-     * 
+     *
      * @return
-     * @throws IOException 
+     * @throws IOException
      */
     protected HttpChannel create() throws IOException {
         HttpChannel res = new HttpChannel();
@@ -213,7 +213,7 @@ public class HttpConnector {
         http.setTarget(host + ":" + port);
         return http;
     }
-    
+
     public HttpChannel getServer() {
         try {
             return get(true);
@@ -228,25 +228,25 @@ public class HttpConnector {
         HttpChannel http = get(false);
         http.setTarget(host + ":" + port);
         return http.getRequest();
-        
+
     }
 
     public HttpRequest request(CharSequence urlString) throws IOException {
         return get(urlString).getRequest();
     }
-    
+
     /**
-     * Get an existing AsyncHttp object. Since it uses many buffers and 
-     * objects - it's more efficient to pool it. 
-     * 
+     * Get an existing AsyncHttp object. Since it uses many buffers and
+     * objects - it's more efficient to pool it.
+     *
      * release will return the object to the pool.
-     * @throws IOException 
+     * @throws IOException
      */
     public HttpChannel get(CharSequence urlString) throws IOException {
         URL url = new URL(urlString.toString());
         String host = url.getHost();
         int port = url.getPort();
-        boolean secure = "http".equals(url.getAuthority()); 
+        boolean secure = "http".equals(url.getAuthority());
         if (port == -1) {
             port = secure ? 443: 80;
         }
@@ -258,7 +258,7 @@ public class HttpConnector {
         http.getRequest().requestURI().set(path);
         return http;
     }
-    
+
     protected HttpChannel get(boolean server) throws IOException {
         HttpChannel processor = null;
         synchronized (httpChannelPool) {
@@ -283,11 +283,11 @@ public class HttpConnector {
         if (debug) {
             log.info((reuse ? "REUSE ": "Create ") +
                     (server? " S" : "")
-                    + " id=" + processor.ser + 
+                    + " id=" + processor.ser +
                     " " + processor +
                     " size=" + httpChannelPool.size());
         }
-        
+
         processor.setConnector(this);
         inUse.incrementAndGet();
         return processor;
@@ -298,11 +298,11 @@ public class HttpConnector {
         recycledChannels.incrementAndGet();
         int size = 0;
         boolean pool = false;
-        
+
         http.recycle();
         http.setConnection(null);
         http.setConnector(null);
-        
+
         // No more data - release the object
         synchronized (httpChannelPool) {
             size = httpChannelPool.size();
@@ -313,7 +313,7 @@ public class HttpConnector {
                 pool = true;
             }
         }
-        
+
         if (!pool && httpEvents != null) {
             httpEvents.onDestroy(http, this);
         }
@@ -323,40 +323,40 @@ public class HttpConnector {
                     http + " size=" + size);
         }
     }
-    
-    
+
+
     public IOConnector getIOConnector() {
         return ioConnector;
     }
-    
-    
+
+
     public void setHttpService(HttpService s) {
         defaultService = s;
     }
-    
+
     public void start() throws IOException {
         if (ioConnector != null) {
-            ioConnector.acceptor(new AcceptorCallback(), 
+            ioConnector.acceptor(new AcceptorCallback(),
                     Integer.toString(port), null);
         }
     }
-    
-    /** 
-     * 
-     * TODO: only clean our state and sockets we listen on. 
-     *  
+
+    /**
+     *
+     * TODO: only clean our state and sockets we listen on.
+     *
      */
     public void stop() {
         if (ioConnector != null) {
             ioConnector.stop();
         }
     }
-    
+
     protected void connectAndSend(HttpChannel httpCh) throws IOException {
         cpool.send(httpCh);
 
     }
-    
+
     private class AcceptorCallback implements IOConnector.ConnectedCallback {
         @Override
         public void handleConnected(IOChannel accepted) throws IOException {
@@ -368,10 +368,10 @@ public class HttpConnector {
         // TODO: reuse
         HttpConnection shttp = cpool.accepted(accepted);
         shttp.serverMode = true;
-        
+
         IOChannel head = accepted;
         IOChannel ch;
-        
+
         String id = null;
         if (debugHttp) {
             id = port + "-" + accepted.getFirst().getAttribute(IOChannel.ATT_REMOTE_PORT);
@@ -384,14 +384,14 @@ public class HttpConnector {
             ch = sslProvider.serverChannel(head);
             head.setHead(ch);
             head = ch;
-            
+
             if (debugHttp) {
                 head = DumpChannel.wrap("CLEAR-" + id, head);
             }
         }
-        
+
         shttp.setSink(head);
-        
+
         // Will read any data in the channel, notify data available up
         accepted.handleReceived(accepted);
         return shttp;
@@ -401,10 +401,10 @@ public class HttpConnector {
         this.port = port2;
         return this;
     }
-    
+
     /**
-     * Actual HTTP/1.1 wire protocol. 
-     *  
+     * Actual HTTP/1.1 wire protocol.
+     *
      */
     public static abstract class HttpConnection extends IOChannel
         implements DataReceivedCallback
@@ -414,9 +414,9 @@ public class HttpConnector {
 
         protected BBuffer headRecvBuf = BBuffer.allocate(8192);
         protected CompressFilter compress = new CompressFilter();
-        
+
         protected boolean secure = false;
-        
+
         protected HttpConnectionPool.RemoteServer remoteHost;
         // If set, the connection is in use ( active )
         // null == keep alive. Changes synchronized on remoteHost
@@ -432,9 +432,9 @@ public class HttpConnector {
         protected HttpChannel checkHttpChannel() throws IOException {
             return null;
         }
-        
-        /** 
-         * Called before a new request is sent, on a channel that is 
+
+        /**
+         * Called before a new request is sent, on a channel that is
          * reused.
          */
         public void beforeRequest() {
@@ -449,22 +449,22 @@ public class HttpConnector {
         }
 
 
-        /** 
+        /**
          * Incoming data.
          */
         public abstract void dataReceived(IOBuffer iob) throws IOException;
-        
-        /** 
+
+        /**
          * Framing error, client interrupt, etc.
          */
         public void abort(HttpChannel http, String t) throws IOException {
         }
-        
-        protected void sendRequest(HttpChannel http) 
+
+        protected void sendRequest(HttpChannel http)
             throws IOException {
         }
-        
-        protected void sendResponseHeaders(HttpChannel http) 
+
+        protected void sendResponseHeaders(HttpChannel http)
             throws IOException {
         }
 
@@ -484,31 +484,31 @@ public class HttpConnector {
         @Override
         public void startSending() throws IOException {
         }
-        
+
         /** Called when the outgoing stream is closed:
          * - by an explicit call to close()
-         * - when all content has been sent. 
+         * - when all content has been sent.
          */
         protected void outClosed(HttpChannel http) throws IOException {
         }
 
         /**
-         * Called by HttpChannel when both input and output are fully 
+         * Called by HttpChannel when both input and output are fully
          * sent/received. When this happens the request is no longer associated
-         * with the Connection, and the connection can be re-used. 
-         * 
+         * with the Connection, and the connection can be re-used.
+         *
          * The channel can still be used to access the retrieved data that may
          * still be buffered until HttpChannel.release() is called.
-         * 
+         *
          * This method will be called only once, for both succesful and aborted
-         * requests. 
+         * requests.
          */
         protected abstract void endSendReceive(HttpChannel httpChannel) throws IOException;
 
         public void withExtraBuffer(BBuffer received) {
             return;
         }
-        
+
     }
 
 }

==================================================
HttpRequest.java
index cfeac7e0b8..5d30e6317b 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpMessage.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpMessage.java
@@ -31,11 +31,11 @@ import org.apache.tomcat.lite.io.UrlEncoding;
 
 /**
  * Basic Http request or response message.
- * 
+ *
  * Because the HttpChannel can be used for both client and
- * server, and to make proxy and other code simpler - the request 
+ * server, and to make proxy and other code simpler - the request
  * and response are represented by the same class.
- * 
+ *
  * @author Costin Manolache
  */
 public abstract class HttpMessage {
@@ -55,12 +55,12 @@ public abstract class HttpMessage {
         BBuffer proto = BBuffer.wrapper();
 
         BBuffer query = BBuffer.wrapper();
-        
+
         List<BBuffer> headerNames = new ArrayList<BBuffer>();
         List<BBuffer> headerValues  = new ArrayList<BBuffer>();
-        
+
         int headerCount;
-        
+
         public BBuffer status() {
             return head1;
         }
@@ -84,16 +84,16 @@ public abstract class HttpMessage {
         public BBuffer message() {
             return head2;
         }
-        
+
         public int addHeader() {
             if (headerCount >= headerNames.size()) {
                 // make space for the new header.
                 headerNames.add(BBuffer.wrapper());
-                headerValues.add(BBuffer.wrapper());                
+                headerValues.add(BBuffer.wrapper());
             }
             return headerCount++;
         }
-        
+
         public BBuffer getHeaderName(int i) {
             if (i >= headerNames.size()) {
                 return null;
@@ -124,18 +124,18 @@ public abstract class HttpMessage {
     protected static final TimeZone GMT_ZONE = TimeZone.getTimeZone("GMT");
 
     private HttpMessageBytes msgBytes = new HttpMessageBytes();
-    
+
     protected HttpMessage.State state = HttpMessage.State.HEAD;
-    
-    protected HttpChannel httpCh; 
-    
+
+    protected HttpChannel httpCh;
+
     protected MultiMap headers = new MultiMap().insensitive();
 
     protected CBuffer protoMB;
-    
-    // Cookies 
+
+    // Cookies
     protected boolean cookiesParsed = false;
-    
+
     // TODO: cookies parsed when headers are added !
     protected ArrayList<ServerCookie> cookies;
     protected ArrayList<ServerCookie> cookiesCache;
@@ -147,17 +147,17 @@ public abstract class HttpMessage {
     BufferedIOReader bufferedReader;
     HttpWriter writer;
     IOWriter conv;
-    
+
     IOOutputStream out;
-    private IOInputStream in; 
-        
+    private IOInputStream in;
+
     boolean commited;
-    
+
     protected IOBuffer body;
 
     long contentLength = -2;
     boolean chunked;
-    
+
     /**
      * The set of SimpleDateFormat formats to use in getDateHeader().
      *
@@ -166,26 +166,26 @@ public abstract class HttpMessage {
      */
     protected SimpleDateFormat formats[] = null;
 
-    
+
     BBuffer clBuffer = BBuffer.allocate(64);
-    
+
     public HttpMessage(HttpChannel httpCh) {
         this.httpCh = httpCh;
-        
+
         out = new IOOutputStream(httpCh.getOut(), httpCh);
         conv = new IOWriter(httpCh);
         writer = new HttpWriter(this, out, conv);
 
         in = new IOInputStream(httpCh, httpCh.getIOTimeout());
-        
+
         reader = new IOReader(httpCh.getIn());
         bufferedReader = new BufferedIOReader(reader);
-        
-        cookies = new ArrayList<ServerCookie>();    
-        cookiesCache = new ArrayList<ServerCookie>();    
-        protoMB = CBuffer.newInstance();        
+
+        cookies = new ArrayList<ServerCookie>();
+        cookiesCache = new ArrayList<ServerCookie>();
+        protoMB = CBuffer.newInstance();
     }
-    
+
     public void addHeader(String name, String value) {
         getMimeHeaders().addValue(name).set(value);
     }
@@ -206,7 +206,7 @@ public abstract class HttpMessage {
     public MultiMap getMimeHeaders() {
         return headers;
     }
-    
+
     /**
      * Return the value of the specified date header, if any; otherwise
      * return -1.
@@ -231,7 +231,7 @@ public abstract class HttpMessage {
             formats[1].setTimeZone(GMT_ZONE);
             formats[2].setTimeZone(GMT_ZONE);
         }
-        
+
         // Attempt to convert the date header in a variety of formats
         long result = FastHttpDateFormat.parseDate(value, formats);
         if (result != (-1L)) {
@@ -241,7 +241,7 @@ public abstract class HttpMessage {
 
     }
 
-    
+
     public Collection<String> getHeaderNames() {
 
         MultiMap headers = getMimeHeaders();
@@ -252,7 +252,7 @@ public abstract class HttpMessage {
         }
         return result;
     }
-    
+
     public boolean containsHeader(String name) {
         return headers.getHeader(name) != null;
     }
@@ -262,27 +262,27 @@ public abstract class HttpMessage {
         clBuffer.setLong(len);
         setCLHeader();
     }
-    
+
     public void setContentLength(int len) {
         contentLength = len;
         clBuffer.setLong(len);
         setCLHeader();
-    } 
-    
+    }
+
     private void setCLHeader() {
         MultiMap.Entry clB = headers.setEntry("content-length");
-        clB.valueB = clBuffer; 
+        clB.valueB = clBuffer;
     }
 
     public long getContentLengthLong() {
         if (contentLength == -2) {
             CBuffer clB = headers.getHeader("content-length");
-            contentLength = (clB == null) ? 
+            contentLength = (clB == null) ?
                     -1 : clB.getLong();
         }
         return contentLength;
     }
-    
+
     public int getContentLength() {
         long length = getContentLengthLong();
 
@@ -291,7 +291,7 @@ public abstract class HttpMessage {
         }
         return -1;
     }
-    
+
     public String getContentType() {
         CBuffer contentTypeMB = headers.getHeader("content-type");
         if (contentTypeMB == null) {
@@ -299,7 +299,7 @@ public abstract class HttpMessage {
         }
         return contentTypeMB.toString();
     }
-    
+
     public void setContentType(String contentType) {
         CBuffer clB = getMimeHeaders().getHeader("content-type");
         if (clB == null) {
@@ -311,7 +311,7 @@ public abstract class HttpMessage {
 
     /**
      * Get the character encoding used for this request.
-     * Need a field because it can be overriden. Used to construct the 
+     * Need a field because it can be overriden. Used to construct the
      * Reader.
      */
     public String getCharacterEncoding() {
@@ -321,19 +321,19 @@ public abstract class HttpMessage {
         charEncoding = ContentType.getCharsetFromContentType(getContentType());
         return charEncoding;
     }
-    
+
     private static final String DEFAULT_ENCODING = "ISO-8859-1";
-    
+
     public String getEncoding() {
         String charEncoding = getCharacterEncoding();
         if (charEncoding == null) {
-            return DEFAULT_ENCODING; 
+            return DEFAULT_ENCODING;
         } else {
             return charEncoding;
         }
     }
 
-    public void setCharacterEncoding(String enc) 
+    public void setCharacterEncoding(String enc)
             throws UnsupportedEncodingException {
         this.charEncoding = enc;
     }
@@ -349,32 +349,32 @@ public abstract class HttpMessage {
         cookies.clear();
         charEncoding = null;
         bufferedReader.recycle();
-        
+
         writer.recycle();
         conv.recycle();
-        
+
         contentLength = -2;
         chunked = false;
         clBuffer.recycle();
         state = State.HEAD;
         cookiesParsed = false;
         getMsgBytes().recycle();
-        
+
     }
-    
-    
+
+
     public String getProtocol() {
         return protoMB.toString();
     }
-    
+
     public void setProtocol(String proto) {
         protoMB.set(proto);
     }
-    
+
     public CBuffer protocol() {
         return protoMB;
     }
-    
+
     public ServerCookie getCookie(String name) {
         for (ServerCookie sc: getServerCookies()) {
             if (sc.getName().equalsIgnoreCase(name)) {
@@ -383,7 +383,7 @@ public abstract class HttpMessage {
         }
         return null;
     }
-    
+
     public List<ServerCookie> getServerCookies() {
         if (!cookiesParsed) {
             cookiesParsed = true;
@@ -391,11 +391,11 @@ public abstract class HttpMessage {
         }
         return cookies;
     }
-    
+
     public UrlEncoding getURLDecoder() {
         return urlDecoder;
     }
-    
+
     public boolean isCommitted() {
         return commited;
     }
@@ -403,36 +403,36 @@ public abstract class HttpMessage {
     public void setCommitted(boolean b) {
         commited = b;
     }
-    
+
     public HttpChannel getHttpChannel() {
         return httpCh;
     }
-    
+
     public IOBuffer getBody() {
         return body;
     }
-    
+
     void setBody(IOBuffer body) {
         this.body = body;
     }
-    
+
     public void flush() throws IOException {
         httpCh.startSending();
     }
-    
-    // not servlet input stream 
+
+    // not servlet input stream
     public IOInputStream getBodyInputStream() {
         return in;
     }
-    
+
     public InputStream getInputStream() {
         return in;
     }
-    
+
     public IOOutputStream getOutputStream() {
         return out;
     }
-    
+
     public IOOutputStream getBodyOutputStream() {
         return out;
     }
@@ -441,18 +441,18 @@ public abstract class HttpMessage {
         reader.setEncoding(getCharacterEncoding());
         return reader;
     }
-    
+
     public BBuffer readAll(BBuffer chunk, long to) throws IOException {
         return httpCh.readAll(chunk, to);
     }
-    
+
     public BBuffer readAll() throws IOException {
         return httpCh.readAll(null, httpCh.ioTimeout);
     }
-    
-    /** 
+
+    /**
      * We're done with this object, it can be recycled.
-     * Any use after this should throw exception or affect an 
+     * Any use after this should throw exception or affect an
      *  unrelated request.
      */
     public void release() throws IOException {
@@ -462,13 +462,13 @@ public abstract class HttpMessage {
     public void setCompletedCallback(RequestCompleted doneAllCallback) throws IOException {
         httpCh.setCompletedCallback(doneAllCallback);
     }
-    
+
     public void setReadTimeout(long to) {
         reader.setTimeout(to);
     }
-    
-    /** 
-     * Returns a buffered reader. 
+
+    /**
+     * Returns a buffered reader.
      */
     public BufferedReader getReader() throws IOException {
         reader.setEncoding(getCharacterEncoding());
@@ -478,31 +478,31 @@ public abstract class HttpMessage {
     public PrintWriter getWriter() {
         return new PrintWriter(getBodyWriter());
     }
-    
+
     public HttpWriter getBodyWriter() {
         conv.setEncoding(getCharacterEncoding());
         return writer;
     }
-    
-    
+
+
     protected void processMimeHeaders() {
         for (int idx = 0; idx < getMsgBytes().headerCount; idx++) {
             BBuffer nameBuf = getMsgBytes().getHeaderName(idx);
             BBuffer valBuf = getMsgBytes().getHeaderValue(idx);
-            
+
             MultiMap.Entry header = headers.addEntry(nameBuf);
             header.valueB = valBuf;
         }
     }
 
-    
+
     protected abstract void processReceivedHeaders() throws IOException;
-    
+
     public abstract boolean hasBody();
 
     public HttpMessageBytes getMsgBytes() {
         // TODO: serialize if not set
         return msgBytes;
     }
-    
+
 }

==================================================
HttpResponse.java
index 3ec8477b0a..be934dd8c8 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpRequest.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpRequest.java
@@ -21,12 +21,12 @@ import org.apache.tomcat.lite.io.UrlEncoding;
 public class HttpRequest extends HttpMessage {
     public static final String DEFAULT_CHARACTER_ENCODING="ISO-8859-1";
 
-    protected CBuffer schemeMB;    
+    protected CBuffer schemeMB;
     protected CBuffer methodMB;
     protected CBuffer remoteAddrMB;
     protected CBuffer remoteHostMB;
     protected int remotePort;
-    
+
     protected CBuffer localNameMB;
     protected CBuffer localAddrMB;
     protected int localPort = -1;
@@ -34,19 +34,19 @@ public class HttpRequest extends HttpMessage {
     // Host: header, or default:80
     protected CBuffer serverNameMB;
     protected int serverPort = -1;
-    
-    
+
+
     // ==== Derived fields, computed after request is received ===
-    
+
     protected CBuffer requestURI;
     protected CBuffer queryMB;
-    
+
     protected BBuffer decodedUri = BBuffer.allocate();
     protected CBuffer decodedUriMB;
-    
+
     // Decoded query
     protected MultiMap parameters;
-    
+
     boolean parametersParsed = false;
 
     protected IOWriter charEncoder = new IOWriter(null);
@@ -57,13 +57,13 @@ public class HttpRequest extends HttpMessage {
     // will not be recycled
     public Object nativeRequest;
     public Object wrapperRequest;
-    
+
     boolean ssl = false;
-    
+
     boolean async = false;
 
     CBuffer requestURL = CBuffer.newInstance();
-    
+
     private Map<String, Object> attributes = new HashMap<String, Object>();
 
     /**
@@ -78,22 +78,22 @@ public class HttpRequest extends HttpMessage {
         requestURI = CBuffer.newInstance();
         queryMB = CBuffer.newInstance();
         serverNameMB = CBuffer.newInstance();
-        
+
         parameters = new MultiMap();
-        
-        schemeMB = 
+
+        schemeMB =
             CBuffer.newInstance();
         methodMB = CBuffer.newInstance();
         initRemote();
     }
-   
+
     protected void initRemote() {
         remoteAddrMB = CBuffer.newInstance();
         localNameMB = CBuffer.newInstance();
         remoteHostMB = CBuffer.newInstance();
         localAddrMB = CBuffer.newInstance();
     }
-    
+
     public void recycle() {
         super.recycle();
         schemeMB.recycle();
@@ -102,7 +102,7 @@ public class HttpRequest extends HttpMessage {
         requestURL.recycle();
         queryMB.recycle();
         decodedUriMB.recycle();
-        
+
         parameters.recycle();
         remoteAddrMB.recycle();
         remoteHostMB.recycle();
@@ -111,18 +111,18 @@ public class HttpRequest extends HttpMessage {
         async = false;
         asyncTimeout = -1;
         charEncoder.recycle();
-        
+
         localPort = -1;
         remotePort = -1;
         localAddrMB.recycle();
         localNameMB.recycle();
-        
+
         serverPort = -1;
         serverNameMB.recycle();
         decodedUri.recycle();
         decodedQuery.recycle();
     }
-    
+
     public Object getAttribute(String name) {
         return attributes.get(name);
     }
@@ -135,7 +135,7 @@ public class HttpRequest extends HttpMessage {
         }
     }
     // getAttributeNames not supported
-    
+
     public Map<String, Object> attributes() {
         return attributes;
     }
@@ -144,19 +144,19 @@ public class HttpRequest extends HttpMessage {
     public CBuffer method() {
         return methodMB;
     }
-    
+
     public String getMethod() {
         return methodMB.toString();
     }
-    
+
     public void setMethod(String method) {
         methodMB.set(method);
     }
-    
+
     public CBuffer scheme() {
         return schemeMB;
     }
-    
+
     public String getScheme() {
         String scheme = schemeMB.toString();
         if (scheme == null) {
@@ -164,15 +164,15 @@ public class HttpRequest extends HttpMessage {
         }
         return scheme;
     }
-    
+
     public void setScheme(String s) {
         schemeMB.set(s);
     }
-    
+
     public MappingData getMappingData() {
         return (mappingData);
     }
-    
+
     /**
      * Return the portion of the request URI used to select the Context
      * of the Request.
@@ -196,28 +196,28 @@ public class HttpRequest extends HttpMessage {
     public String getServletPath() {
         return (getMappingData().wrapperPath.toString());
     }
-    
-    /** 
-     * Parse query parameters - but not POST body. 
-     * 
-     * If you don't call this method, getParameters() will 
-     * also read the body for POST with x-www-url-encoded 
-     * mime type. 
+
+    /**
+     * Parse query parameters - but not POST body.
+     *
+     * If you don't call this method, getParameters() will
+     * also read the body for POST with x-www-url-encoded
+     * mime type.
      */
     public void parseQueryParameters() {
         parseQuery();
     }
 
     /**
-     * Explicitely parse the body, adding the parameters to 
+     * Explicitely parse the body, adding the parameters to
      * those from the query ( if already parsed ).
-     * 
+     *
      * By default servlet mode ( both query and body ) is used.
      */
     public void parsePostParameters() {
         parseBody();
     }
-    
+
     MultiMap getParameters() {
         if (!parametersParsed) {
             parseQuery();
@@ -225,13 +225,13 @@ public class HttpRequest extends HttpMessage {
         }
         return parameters;
     }
-    
+
     public Enumeration<String> getParameterNames() {
         return getParameters().names();
     }
-    
-    /** 
-     * Expensive, creates a copy on each call. 
+
+    /**
+     * Expensive, creates a copy on each call.
      * @param name
      * @return
      */
@@ -246,10 +246,10 @@ public class HttpRequest extends HttpMessage {
         }
         return values;
     }
-    
+
     // Inefficient - we convert from a different representation.
     public Map<String, String[]> getParameterMap() {
-        // we could allow 'locking' - I don't think this is 
+        // we could allow 'locking' - I don't think this is
         // a very useful optimization
         Map<String, String[]> map = new HashMap();
         for (int i = 0; i < getParameters().size(); i++) {
@@ -269,7 +269,7 @@ public class HttpRequest extends HttpMessage {
         }
         return map;
     }
-    
+
     public String getParameter(String name) {
         CharSequence value = getParameters().get(name);
         if (value == null) {
@@ -277,11 +277,11 @@ public class HttpRequest extends HttpMessage {
         }
         return value.toString();
     }
-    
+
     public void setParameter(String name, String value) {
         getParameters().set(name, value);
     }
-    
+
     public void addParameter(String name, String values) {
         getParameters().add(name, values);
     }
@@ -309,13 +309,13 @@ public class HttpRequest extends HttpMessage {
             }
         }
     }
-    
+
     public void setURI(CharSequence encoded) {
         decodedUriMB.recycle();
         decodedUriMB.append(encoded);
         // TODO: generate % encoding ( reverse of decodeRequest )
     }
-    
+
     public CBuffer decodedURI() {
         return decodedUriMB;
     }
@@ -323,11 +323,11 @@ public class HttpRequest extends HttpMessage {
     public CBuffer requestURI() {
         return requestURI;
     }
-    
+
     public CBuffer requestURL() {
         CBuffer url = requestURL;
         url.recycle();
-        
+
         String scheme = getScheme();
         int port = getServerPort();
         if (port < 0)
@@ -348,7 +348,7 @@ public class HttpRequest extends HttpMessage {
 
     }
 
-    /** 
+    /**
      * Not decoded - %xx as in original.
      * @return
      */
@@ -368,7 +368,7 @@ public class HttpRequest extends HttpMessage {
         return header;
     }
 
-    /** 
+    /**
      * Set the Host header of the request.
      * @param target
      */
@@ -376,7 +376,7 @@ public class HttpRequest extends HttpMessage {
         serverNameMB.recycle();
         getOrAdd("Host").set(target);
     }
-    
+
     // XXX
     public CBuffer serverName() {
         if (serverNameMB.length() == 0) {
@@ -388,16 +388,16 @@ public class HttpRequest extends HttpMessage {
     public String getServerName() {
         return serverName().toString();
     }
-    
+
     public void setServerName(String name)  {
         serverName().set(name);
     }
-    
+
     public int getServerPort() {
         serverName();
         return serverPort;
     }
-    
+
     public void setServerPort(int serverPort ) {
         this.serverPort=serverPort;
     }
@@ -406,7 +406,7 @@ public class HttpRequest extends HttpMessage {
         if (remoteAddrMB.length() == 0) {
             HttpChannel asyncHttp = getHttpChannel();
             IOChannel iochannel = asyncHttp.getNet().getFirst();
-            remoteAddrMB.set((String) 
+            remoteAddrMB.set((String)
                     iochannel.getAttribute(IOChannel.ATT_REMOTE_ADDRESS));
         }
         return remoteAddrMB;
@@ -416,7 +416,7 @@ public class HttpRequest extends HttpMessage {
         if (remoteHostMB.length() == 0) {
             HttpChannel asyncHttp = getHttpChannel();
             IOChannel iochannel = asyncHttp.getNet().getFirst();
-            remoteHostMB.set((String) 
+            remoteHostMB.set((String)
                     iochannel.getAttribute(IOChannel.ATT_REMOTE_HOSTNAME));
         }
         return remoteHostMB;
@@ -424,12 +424,12 @@ public class HttpRequest extends HttpMessage {
 
     public CBuffer localName() {
         return localNameMB;
-    }    
+    }
 
     public CBuffer localAddr() {
         return localAddrMB;
     }
-    
+
     public int getRemotePort(){
         if (remotePort == -1) {
             HttpChannel asyncHttp = getHttpChannel();
@@ -438,11 +438,11 @@ public class HttpRequest extends HttpMessage {
         }
         return remotePort;
     }
-        
+
     public void setRemotePort(int port){
         this.remotePort = port;
     }
-    
+
     public int getLocalPort(){
         if (localPort == -1) {
             HttpChannel asyncHttp = getHttpChannel();
@@ -451,11 +451,11 @@ public class HttpRequest extends HttpMessage {
         }
         return localPort;
     }
-        
+
     public void setLocalPort(int port){
         this.localPort = port;
     }
-    
+
     public HttpResponse waitResponse() throws IOException {
         return waitResponse(httpCh.ioTimeout);
     }
@@ -467,7 +467,7 @@ public class HttpRequest extends HttpMessage {
 
         httpCh.send();
     }
-    
+
     public void send(HttpService headersCallback) throws IOException {
         send(headersCallback, httpCh.ioTimeout);
     }
@@ -475,20 +475,20 @@ public class HttpRequest extends HttpMessage {
     public void send() throws IOException {
         send(null, httpCh.ioTimeout);
     }
-    
+
     public HttpResponse waitResponse(long timeout) throws IOException {
         // TODO: close out if post
         httpCh.send();
-        
+
         httpCh.headersReceivedLock.waitSignal(timeout);
-        
+
         return httpCh.getResponse();
     }
 
     /**
      * Parse host.
-     * @param serverNameMB2 
-     * @throws IOException 
+     * @param serverNameMB2
+     * @throws IOException
      */
     boolean parseHost()  {
         MultiMap.Entry hostHF = getMimeHeaders().getEntry("Host");
@@ -507,9 +507,9 @@ public class HttpRequest extends HttpMessage {
         byte[] valueB = valueBC.array();
         int valueL = valueBC.getLength();
         int valueS = valueBC.getStart();
-        
+
         int colonPos = valueBC.indexOf(':', 0);
-        
+
         serverNameMB.recycle();
 
         boolean ipv6 = (valueB[valueS] == '[');
@@ -525,7 +525,7 @@ public class HttpRequest extends HttpMessage {
             serverNameMB.append(b);
             if (b == ']') {
                 bracketClosed = true;
-            } 
+            }
         }
 
         if (colonPos < 0) {
@@ -551,7 +551,7 @@ public class HttpRequest extends HttpMessage {
         }
         return true;
     }
-    
+
     // TODO: this is from coyote - MUST be rewritten !!!
     // - cleaner
     // - chunked encoding for body
@@ -560,11 +560,11 @@ public class HttpRequest extends HttpMessage {
      * Post data buffer.
      */
     public final static int CACHED_POST_LEN = 8192;
-    
+
     public  byte[] postData = null;
 
     private long asyncTimeout = -1;
-    
+
     /**
      * Parse request parameters.
      */
@@ -595,7 +595,7 @@ public class HttpRequest extends HttpMessage {
 
     // Copy - will be modified by decoding
     BBuffer decodedQuery = BBuffer.allocate(1024);
-    
+
     CBuffer tmpNameC = CBuffer.newInstance();
     BBuffer tmpName = BBuffer.wrapper();
     BBuffer tmpValue = BBuffer.wrapper();
@@ -603,23 +603,23 @@ public class HttpRequest extends HttpMessage {
     CBuffer tmpNameCB = CBuffer.newInstance();
     CBuffer tmpValueCB = CBuffer.newInstance();
 
-    /** 
+    /**
      * Process the query string into parameters
      */
     public void handleQueryParameters() {
         if( queryMB.length() == 0) {
             return;
         }
-        
+
         decodedQuery.recycle();
         decodedQuery.append(getMsgBytes().query());
         // TODO: option 'useBodyEncodingForUri' - versus UTF or ASCII
         String queryStringEncoding = getEncoding();
         processParameters( decodedQuery, queryStringEncoding );
     }
-    
+
     public void processParameters( BBuffer bc, String encoding ) {
-        if( bc.isNull()) 
+        if( bc.isNull())
             return;
         if (bc.remaining() ==0) {
             return;
@@ -627,8 +627,8 @@ public class HttpRequest extends HttpMessage {
         processParameters( bc.array(), bc.getOffset(),
                            bc.getLength(), encoding);
     }
-    
-    public void processParameters( byte bytes[], int start, int len, 
+
+    public void processParameters( byte bytes[], int start, int len,
             String enc ) {
         int end=start+len;
         int pos=start;
@@ -649,7 +649,7 @@ public class HttpRequest extends HttpMessage {
                 valStart=nameEnd;
                 valEnd=nameEnd;
             }
-            if( nameEnd== -1 ) 
+            if( nameEnd== -1 )
                 nameEnd=end;
 
             if( ! noEq ) {
@@ -664,13 +664,13 @@ public class HttpRequest extends HttpMessage {
                 // No name eg ...&=xx&... will trigger this
                 continue;
             }
-            
+
             // TODO: use CBuffer, recycle
             tmpName.setBytes( bytes, nameStart, nameEnd-nameStart );
             tmpValue.setBytes( bytes, valStart, valEnd-valStart );
-            
+
             try {
-                parameters.add(urlDecode(tmpName, enc), 
+                parameters.add(urlDecode(tmpName, enc),
                         urlDecode(tmpValue, enc));
             } catch (IOException e) {
                 // ignored
@@ -678,7 +678,7 @@ public class HttpRequest extends HttpMessage {
         } while( pos<end );
     }
 
-//    public void processParameters(char bytes[], int start, int len, 
+//    public void processParameters(char bytes[], int start, int len,
 //            String enc ) {
 //        int end=start+len;
 //        int pos=start;
@@ -699,7 +699,7 @@ public class HttpRequest extends HttpMessage {
 //                valStart=nameEnd;
 //                valEnd=nameEnd;
 //            }
-//            if( nameEnd== -1 ) 
+//            if( nameEnd== -1 )
 //                nameEnd=end;
 //
 //            if( ! noEq ) {
@@ -714,37 +714,37 @@ public class HttpRequest extends HttpMessage {
 //                // No name eg ...&=xx&... will trigger this
 //                continue;
 //            }
-//            
+//
 //            // TODO: use CBuffer, recycle
 //            tmpNameCB.recycle();
 //            tmpValueCB.recycle();
-//            
+//
 //            tmpNameCB.wrap( bytes, nameStart, nameEnd );
 //            tmpValueCB.wrap( bytes, valStart, valEnd );
-//            
+//
 //            //CharChunk name = new CharChunk();
 //            //CharChunk value = new CharChunk();
 //            // TODO:
 //            try {
-//                parameters.add(urlDecode(tmpName, enc), 
+//                parameters.add(urlDecode(tmpName, enc),
 //                        urlDecode(tmpValue, enc));
 //            } catch (IOException e) {
 //                // ignored
 //            }
 //        } while( pos<end );
 //    }
-    
+
     private String urlDecode(BBuffer bc, String enc)
             throws IOException {
         // Replace %xx
         urlDecoder.urlDecode(bc, true);
-        
+
         String result = null;
         if (enc != null) {
             result = bc.toString(enc);
         } else {
             // Ascii
-            
+
             CBuffer cc = tmpNameC;
             cc.recycle();
             int length = bc.getLength();
@@ -760,7 +760,7 @@ public class HttpRequest extends HttpMessage {
     private void processParameters( byte bytes[], int start, int len ) {
         processParameters(bytes, start, len, getEncoding());
     }
-    
+
     protected void parseBody() {
 
         parametersParsed = true;
@@ -770,7 +770,7 @@ public class HttpRequest extends HttpMessage {
 //      return;
         if (!getMethod().equalsIgnoreCase("POST"))
             return;
-        
+
         String contentType = getContentType();
         if (contentType == null)
             contentType = "";
@@ -823,10 +823,10 @@ public class HttpRequest extends HttpMessage {
         return len;
 
     }
-    
-    // Async support - a subset of servlet spec, the fancy stuff is in the 
+
+    // Async support - a subset of servlet spec, the fancy stuff is in the
     // facade.
-    
+
     public boolean isAsyncStarted() {
         return async;
     }
@@ -838,8 +838,8 @@ public class HttpRequest extends HttpMessage {
     public void setAsyncTimeout(long timeout) {
         this.asyncTimeout  = timeout;
     }
-    
-    /** 
+
+    /**
      * Server mode, request just received.
      */
     protected void processReceivedHeaders() throws IOException {
@@ -849,57 +849,57 @@ public class HttpRequest extends HttpMessage {
         }
         if (url.get(0) == 'h') {
             int firstSlash = url.indexOf('/', 0);
-            schemeMB.appendAscii(url.array(), 
+            schemeMB.appendAscii(url.array(),
                     url.getStart(), firstSlash + 2);
-            if (!schemeMB.equals("http://") && 
+            if (!schemeMB.equals("http://") &&
                     !schemeMB.equals("https://")) {
                 httpCh.getResponse().setStatus(400);
-                httpCh.abort("Error normalizing url " + 
+                httpCh.abort("Error normalizing url " +
                         getMsgBytes().url());
-                return;                                
+                return;
             }
-            
+
             int urlStart = url.indexOf('/', firstSlash + 2);
             serverNameMB.recycle();
-            serverNameMB.appendAscii(url.array(), 
+            serverNameMB.appendAscii(url.array(),
                     url.getStart() + firstSlash + 2, urlStart - firstSlash - 2);
-            
+
             url.position(url.getStart() + urlStart);
         }
         if (!httpCh.normalize(getMsgBytes().url())) {
             httpCh.getResponse().setStatus(400);
-            httpCh.abort("Error normalizing url " + 
+            httpCh.abort("Error normalizing url " +
                     getMsgBytes().url());
-            return;                
+            return;
         }
-        
-        method().set(getMsgBytes().method()); 
+
+        method().set(getMsgBytes().method());
         requestURI().set(getMsgBytes().url());
         queryString().set(getMsgBytes().query());
         protocol().set(getMsgBytes().protocol());
-        
+
         processMimeHeaders();
 
         // URL decode and normalize
         decodedUri.append(getMsgBytes().url());
-        
-        getURLDecoder().urlDecode(decodedUri, false); 
-        
+
+        getURLDecoder().urlDecode(decodedUri, false);
+
         // Need to normalize again - %decoding may decode /
         if (!httpCh.normalize(decodedUri)) {
             httpCh.getResponse().setStatus(400);
             httpCh.abort("Invalid decoded uri " + decodedUri);
-            return;                
+            return;
         }
         decodedURI().set(decodedUri);
 
         // default response protocol
-        httpCh.getResponse().protocol().set(getMsgBytes().protocol());            
+        httpCh.getResponse().protocol().set(getMsgBytes().protocol());
     }
 
-    
+
     public boolean hasBody() {
-        return chunked || contentLength >= 0; 
+        return chunked || contentLength >= 0;
     }
 
     /**
@@ -925,7 +925,7 @@ public class HttpRequest extends HttpMessage {
             String name = serverName().toString();
             int port = getServerPort();
 
-            cb.append(scheme);                
+            cb.append(scheme);
             cb.append("://", 0, 3);
             cb.append(name);
             if ((scheme.equals("http") && port != 80)
@@ -951,8 +951,8 @@ public class HttpRequest extends HttpMessage {
             cb.append(location);
         }
 
-    }    
-    
+    }
+
     /**
      * Determine if a URI string has a <code>scheme</code> component.
      */
@@ -977,7 +977,7 @@ public class HttpRequest extends HttpMessage {
         return Character.isLetterOrDigit(c) ||
             c == '+' || c == '-' || c == '.';
     }
-    
+
     public IOWriter getCharEncoder() {
         return charEncoder;
     }
@@ -985,11 +985,11 @@ public class HttpRequest extends HttpMessage {
     public IOReader getCharDecoder() {
         return charDecoder;
     }
-    
+
     public UrlEncoding getUrlEncoding() {
         return urlEncoding;
     }
-    
+
     public BBuffer toBytes(CBuffer cb, BBuffer bb) {
         if (bb == null) {
             bb = BBuffer.allocate(cb.length());
@@ -1007,11 +1007,11 @@ public class HttpRequest extends HttpMessage {
             return "Invalid request";
         }
     }
-    
+
     public boolean isSecure() {
         return ssl;
     }
-    
+
     public HttpRequest setSecure(boolean ssl) {
         this.ssl = ssl;
         return this;

==================================================
HttpServer.java
index 39f2ffa579..d616c1c4aa 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpResponse.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpResponse.java
@@ -10,7 +10,7 @@ import org.apache.tomcat.lite.io.BBuffer;
 import org.apache.tomcat.lite.io.CBuffer;
 
 public class HttpResponse extends HttpMessage {
-    
+
     /*
      * Server status codes; see RFC 2068.
      */
@@ -21,7 +21,7 @@ public class HttpResponse extends HttpMessage {
 
     public static final int SC_CONTINUE = 100;
 
-    
+
     /**
      * Status code (101) indicating the server is switching protocols
      * according to Upgrade header.
@@ -76,14 +76,14 @@ public class HttpResponse extends HttpMessage {
      */
 
     public static final int SC_PARTIAL_CONTENT = 206;
-    
+
     /**
      * Used by Webdav.
      */
     public static final int SC_MULTI_STATUS = 207;
     // This one collides with HTTP 1.1
     // "207 Partial Update OK"
-    
+
     /**
      * Status code (300) indicating that the requested resource
      * corresponds to any one of a set of representations, each with
@@ -144,9 +144,9 @@ public class HttpResponse extends HttpMessage {
     public static final int SC_USE_PROXY = 305;
 
      /**
-     * Status code (307) indicating that the requested resource 
+     * Status code (307) indicating that the requested resource
      * resides temporarily under a different URI. The temporary URI
-     * <em>SHOULD</em> be given by the <code><em>Location</em></code> 
+     * <em>SHOULD</em> be given by the <code><em>Location</em></code>
      * field in the response.
      */
 
@@ -343,7 +343,7 @@ public class HttpResponse extends HttpMessage {
     public Object nativeResponse;
 
     protected CBuffer message = CBuffer.newInstance();
-    
+
     int status = -1;
 
     HttpResponse(HttpChannel httpCh) {
@@ -355,33 +355,33 @@ public class HttpResponse extends HttpMessage {
         message.recycle();
         status = -1;
     }
-    
+
     public void setMessage(String s) {
         message.set(filter(s));
     }
-    
+
     public String getMessage() {
         return message.toString();
     }
-    
+
     public CBuffer getMessageBuffer() {
         return message;
     }
-    
+
     byte[] S_200 = new byte[] { '2', '0', '0' };
-    
+
     public void setStatus(int i) {
         status = i;
     }
-    
+
     public void sendError(int status) {
         this.status = status;
     }
-    
+
     public void sendError(int status, String msg) {
         message.set(msg);
     }
-    
+
     public int getStatus() {
         if (status >= 0) {
             return status;
@@ -402,10 +402,10 @@ public class HttpResponse extends HttpMessage {
     public HttpRequest getRequest() {
         return getHttpChannel().getRequest();
     }
-    
+
     // Http client mode.
     protected void processReceivedHeaders() throws IOException {
-        protocol().set(getMsgBytes().protocol());                
+        protocol().set(getMsgBytes().protocol());
         message.set(getMsgBytes().message());
         processMimeHeaders();
         // TODO: if protocol == 1.0 and we requested 1.1, downgrade getHttpChannel().pro
@@ -417,11 +417,11 @@ public class HttpResponse extends HttpMessage {
     }
 
     /**
-     * All responses to the HEAD request method MUST NOT include a 
+     * All responses to the HEAD request method MUST NOT include a
      * message-body, even though the presence of entity- header fields might
      *  lead one to believe they do. All 1xx (informational), 204 (no content)
-     *  , and 304 (not modified) responses MUST NOT include a message-body. All 
-     *  other responses do include a message-body, although it MAY be of zero 
+     *  , and 304 (not modified) responses MUST NOT include a message-body. All
+     *  other responses do include a message-body, although it MAY be of zero
      *  length.
      */
     public boolean hasBody() {
@@ -432,13 +432,13 @@ public class HttpResponse extends HttpMessage {
             return false;
         }
         // what about (status == 205) ?
-        if ((status == 204) 
+        if ((status == 204)
                 || (status == 304)) {
             return false;
         }
         return true;
     }
-    
+
     /** Get the status string associated with a status code.
      *  No I18N - return the messages defined in the HTTP spec.
      *  ( the user isn't supposed to see them, this is the last
@@ -468,11 +468,11 @@ public class HttpResponse extends HttpMessage {
         }
         return bb;
     }
-    
+
     public static String getStatusText(int code) {
         return getMessage(code).toString();
     }
-    
+
     static BBucket st_unknown = BBuffer.wrapper("No Message");
     static BBucket st_200 = BBuffer.wrapper("OK");
     static BBucket st_302= BBuffer.wrapper("Moved Temporarily");
@@ -483,7 +483,7 @@ public class HttpResponse extends HttpMessage {
     private static void addStatus(int stat, String msg) {
         stats.put(stat, BBuffer.wrapper(msg));
     }
-    
+
     static {
         addStatus(100, "Continue");
         addStatus(101, "Switching Protocols");
@@ -532,9 +532,9 @@ public class HttpResponse extends HttpMessage {
         addStatus(507, "Insufficient Storage");
         addStatus(SC_LOCKED, "Locked");
 
-        
+
     }
-    
+
     /**
      * Filter the specified message string for characters that are sensitive
      * in HTML.  This avoids potential attacks caused by including JavaScript
@@ -552,7 +552,7 @@ public class HttpResponse extends HttpMessage {
                 message.indexOf('"') < 0) {
             return message;
         }
-        
+
         char content[] = new char[message.length()];
         message.getChars(0, message.length(), content, 0);
 
@@ -577,5 +577,5 @@ public class HttpResponse extends HttpMessage {
         }
         return (result.toString());
     }
-    
+
 }

==================================================
HttpWriter.java
index e8182d982b..799e4c42e1 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpServer.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpServer.java
@@ -7,11 +7,11 @@ import org.apache.tomcat.lite.io.SslProvider;
 import org.apache.tomcat.lite.io.jsse.JsseSslProvider;
 
 /**
- * Main entry point for HTTP server code. 
- * 
- * ( initial draft - will replace statics, add helpers, etc ) 
+ * Main entry point for HTTP server code.
+ *
+ * ( initial draft - will replace statics, add helpers, etc )
  */
-public class HttpServer { 
+public class HttpServer {
     static SslProvider sslConC = new JsseSslProvider();
 
     public synchronized static HttpConnector newServer(int port) {
@@ -24,10 +24,10 @@ public class HttpServer {
         //      SslConnector.setEnabledCiphers(new String[] {
         //              "TLS_RSA_WITH_3DES_EDE_CBC_SHA"
         //      });
-        // -cipher DES-CBC3-SHA 
-      
+        // -cipher DES-CBC3-SHA
+
         SslProvider sslCon = new JsseSslProvider();
-        
+
         return new HttpConnector(new SocketConnector()).
             withSsl(sslCon).setPort(port).setServerSsl(true);
     }

==================================================
MappingData.java
index 2d8f91abd1..b18e0aced2 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpWriter.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpWriter.java
@@ -10,14 +10,14 @@ import org.apache.tomcat.lite.io.IOWriter;
 
 /**
  * Implement character translation and buffering.
- * 
- * The actual buffering happens in the IOBuffer - we translate the 
- * chars as soon as we get them. 
- * 
+ *
+ * The actual buffering happens in the IOBuffer - we translate the
+ * chars as soon as we get them.
+ *
  * For servlet compat you can set a buffer size and a flush() will happen
- * when the number of chars have been written. Note that writes at a lower 
- * layer can be done and are not counted. 
- * 
+ * when the number of chars have been written. Note that writes at a lower
+ * layer can be done and are not counted.
+ *
  * @author Costin Manolache
  */
 public class HttpWriter extends Writer {
@@ -34,7 +34,7 @@ public class HttpWriter extends Writer {
     protected IOOutputStream bb;
 
     int bufferSize = DEFAULT_BUFFER_SIZE;
-    
+
     /**
      * Number of chars written.
      */
@@ -47,7 +47,7 @@ public class HttpWriter extends Writer {
     protected boolean closed = false;
 
     /**
-     * Encoding to use. 
+     * Encoding to use.
      * TODO: isn't it redundant ? enc, gotEnc, conv plus the enc in the bb
      */
     protected String enc;
@@ -60,7 +60,7 @@ public class HttpWriter extends Writer {
 
 
     /**
-     * List of encoders. The writer is reused - the encoder mapping 
+     * List of encoders. The writer is reused - the encoder mapping
      * avoids creating expensive objects. In future it'll contain nio.Charsets
      */
     //protected Map<String, C2BConverter> encoders = new HashMap();
@@ -82,7 +82,7 @@ public class HttpWriter extends Writer {
 
     /**
      * Default constructor. Allocate the buffer with the default buffer size.
-     * @param out 
+     * @param out
      */
     public HttpWriter(HttpMessage message, IOOutputStream out,
             IOWriter conv) {
@@ -96,7 +96,7 @@ public class HttpWriter extends Writer {
 
     /**
      * Is the response output suspended ?
-     * 
+     *
      * @return suspended flag value
      */
     public boolean isSuspended() {
@@ -106,7 +106,7 @@ public class HttpWriter extends Writer {
 
     /**
      * Set the suspended flag.
-     * 
+     *
      * @param suspended New suspended flag value
      */
     public void setSuspended(boolean suspended) {
@@ -122,14 +122,14 @@ public class HttpWriter extends Writer {
      */
     public void recycle() {
         wSinceFlush = 0;
-        bb.recycle(); 
+        bb.recycle();
         closed = false;
         suspended = false;
-        
+
 //        if (conv != null) {
 //            conv.recycle();
 //        }
-        
+
         gotEnc = false;
         enc = null;
     }
@@ -144,14 +144,14 @@ public class HttpWriter extends Writer {
 
         push();
         closed = true;
-        
+
         bb.close();
     }
 
 
     /**
      * Flush bytes or chars contained in the buffer.
-     * 
+     *
      * @throws IOException An underlying IOException occurred
      */
     public void flush()
@@ -170,7 +170,7 @@ public class HttpWriter extends Writer {
         if (suspended)
             return;
         getConv().push();
-        
+
     }
 
 
@@ -234,7 +234,7 @@ public class HttpWriter extends Writer {
         if (s==null)
             s="null";
         write(s, 0, s.length());
-    } 
+    }
 
     public void println() throws IOException {
         write("\n");
@@ -249,7 +249,7 @@ public class HttpWriter extends Writer {
         write(s);
     }
 
-    public void checkConverter() 
+    public void checkConverter()
             throws IOException {
 //        if (gotEnc) {
 //            return;
@@ -262,9 +262,9 @@ public class HttpWriter extends Writer {
 //        if (enc == null)
 //            enc = DEFAULT_ENCODING;
 //        conv = (C2BConverter) encoders.get(enc);
-//        
+//
 //        if (conv == null) {
-//            conv = C2BConverter.newConverter(message.getBodyOutputStream(), 
+//            conv = C2BConverter.newConverter(message.getBodyOutputStream(),
 //                    enc);
 //            encoders.put(enc, conv);
 //
@@ -286,7 +286,7 @@ public class HttpWriter extends Writer {
      *  Clear any data that was buffered.
      */
     public void reset() {
-        if (conv != null) { 
+        if (conv != null) {
             conv.recycle();
         }
         wSinceFlush = 0;

==================================================
MultiMap.java
index 67c0c135b0..1b8d939936 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/MappingData.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/MappingData.java
@@ -28,7 +28,7 @@ import org.apache.tomcat.lite.io.CBuffer;
 public class MappingData {
 
     public Object context = null; // ServletContextImpl
-    
+
     public BaseMapper.Context contextMap;
 
     public BaseMapper.ServiceMapping service = null;
@@ -43,7 +43,7 @@ public class MappingData {
     // Extension
     CBuffer ext = CBuffer.newInstance();
     CBuffer tmpPrefix = CBuffer.newInstance();
-    
+
     // Excluding context path, with a '/' added if needed
     CBuffer tmpServletPath = CBuffer.newInstance();
 
@@ -51,7 +51,7 @@ public class MappingData {
     CBuffer tmpWelcome = CBuffer.newInstance();
 
     public void recycle() {
-        service = null; 
+        service = null;
         context = null;
         pathInfo.recycle();
         requestPath.recycle();

==================================================
ServerCookie.java
index 97fca7cd6f..7b8fb143b6 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/MultiMap.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/MultiMap.java
@@ -29,32 +29,32 @@ import org.apache.tomcat.lite.io.CBucket;
 import org.apache.tomcat.lite.io.CBuffer;
 
 /**
- * Map used to represent headers and parameters ( could be used 
+ * Map used to represent headers and parameters ( could be used
  * for cookies too )
- * 
- * It'll avoid garbage collection, like original tomcat classes, 
+ *
+ * It'll avoid garbage collection, like original tomcat classes,
  * by converting to chars and strings late.
- * 
+ *
  * Not thread safe.
  */
 public class MultiMap {
 
     public static class Entry {
         // Wrappers from the head message bytes.
-        BBuffer nameB; 
+        BBuffer nameB;
         BBuffer valueB;
-        
+
         CBuffer key = CBuffer.newInstance();
         private CBuffer value = CBuffer.newInstance();
-        
-        /** 
+
+        /**
          * For the first entry with a given name: list of all
          * other entries, including this one, with same name.
-         * 
+         *
          * For second or more: empty list
          */
-        public List<Entry> values = new ArrayList<Entry>(); 
-    
+        public List<Entry> values = new ArrayList<Entry>();
+
         public void recycle() {
             key.recycle();
             value.recycle();
@@ -63,14 +63,14 @@ public class MultiMap {
             valueB = null;
             values.clear();
         }
-    
+
         public CBuffer getName() {
             if (key.length() == 0 && nameB != null) {
                 key.set(nameB);
             }
             return key;
         }
-    
+
         public CBuffer getValue() {
             if (value.length() == 0 && valueB != null) {
                 value.set(valueB);
@@ -78,13 +78,13 @@ public class MultiMap {
             return value;
         }
 
-        /** Important - used by values iterator, returns strings 
+        /** Important - used by values iterator, returns strings
          * from each entry
          */
         public String toString() {
             return getValue().toString();
         }
-        
+
     }
 
     // active entries
@@ -92,15 +92,15 @@ public class MultiMap {
 
     // The key will be converted to lower case
     boolean toLower = false;
-    
+
     // Some may be inactive - up to count.
     protected List<Entry> entries = new ArrayList<Entry>();
-    
+
     // 2 options: convert all header/param names to String
     // or use a temp CBuffer to map
-    Map<CBuffer, Entry> map = 
+    Map<CBuffer, Entry> map =
         new HashMap<CBuffer, Entry>();
-    
+
     public void recycle() {
         for (int i = 0; i < count; i++) {
             Entry entry = entries.get(i);
@@ -115,7 +115,7 @@ public class MultiMap {
     protected Entry newEntry()  {
         return new Entry();
     }
-    
+
     /**
      * Adds a partially constructed field entry.
      * Updates count - but will not affect the map.
@@ -131,7 +131,7 @@ public class MultiMap {
         count++;
         return entry;
     }
-    
+
 
     /** Create a new named header , return the CBuffer
      *  container for the new value
@@ -154,18 +154,18 @@ public class MultiMap {
        mh.nameB = name;
        if (toLower) {
            mh.getName().toLower();
-       }       
+       }
        updateMap(mh);
-       
+
        return mh;
    }
 
    private void updateMap(Entry mh) {
        Entry topEntry = map.get(mh.getName());
-       
+
        if (topEntry == null) {
            map.put(mh.getName(), mh);
-           mh.values.add(mh);            
+           mh.values.add(mh);
        } else {
            topEntry.values.add(mh);
        }
@@ -178,7 +178,7 @@ public class MultiMap {
         Entry entry = getEntry(ckey);
         if (entry != null) {
             map.remove(ckey);
-            
+
             for (int i = count - 1; i >= 0; i--) {
                 entry = entries.get(i);
                 if (entry.getName().equals(key)) {
@@ -187,12 +187,12 @@ public class MultiMap {
                     count--;
                 }
             }
-        }            
+        }
     }
 
     // --------------- Key-based access --------------
     CBuffer tmpKey = CBuffer.newInstance();
-    
+
     /**
      * Finds and returns a header field with the given name.  If no such
      * field exists, null is returned.  If more than one such field is
@@ -218,10 +218,10 @@ public class MultiMap {
         tmpKey.append(key);
         if (toLower) {
             tmpKey.toLower();
-        }        
+        }
         return tmpKey;
     }
-    
+
     public Entry getEntry(CharSequence key) {
         Entry entry = map.get(key(key));
         return entry;
@@ -235,13 +235,13 @@ public class MultiMap {
 
     public Enumeration<String> names() {
         return new IteratorEnumerator(map.keySet().iterator());
-    }    
+    }
 
     // ----------- Index access --------------
-    
+
     /**
      *  Number of entries ( including those with same key
-     * 
+     *
      * @return
      */
     public int size() {
@@ -278,7 +278,7 @@ public class MultiMap {
         Entry mh = addEntry(key);
         mh.value.append(value);
     }
-    
+
     /** Create a new named header , return the CBuffer
      * container for the new value
      */
@@ -295,7 +295,7 @@ public class MultiMap {
          remove(key);
          add(key, value);
      }
-     
+
      public CBuffer setValue( String name ) {
          remove(name);
          return addValue(name);
@@ -310,30 +310,30 @@ public class MultiMap {
          Entry entry = getEntry(key);
          return (entry == null) ? null : entry.value.toString();
      }
-     
-    
+
+
     // -------------- support classes ----------------
-    
+
     public static class IteratorEnumerator implements Enumeration<String> {
         private final Iterator keyI;
-    
+
         public IteratorEnumerator(Iterator iterator) {
             this.keyI = iterator;
         }
-    
-        
+
+
         public boolean hasMoreElements() {
             return keyI.hasNext();
         }
-    
-        
+
+
         public String nextElement() {
             return keyI.next().toString();
         }
 
     }
 
-    public static final Enumeration<String> EMPTY = 
+    public static final Enumeration<String> EMPTY =
         new Enumeration<String>() {
 
             @Override
@@ -345,7 +345,7 @@ public class MultiMap {
             public String nextElement() {
                 return null;
             }
-        
+
     };
 
     public MultiMap insensitive() {
@@ -353,5 +353,5 @@ public class MultiMap {
         return this;
     }
 
-    
+
 }

==================================================
SpdyConnection.java
index c80ef5de90..4cf66f2b79 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/ServerCookie.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/ServerCookie.java
@@ -40,18 +40,18 @@ import org.apache.tomcat.lite.io.CBuffer;
  *  and the facade will convert it to the external representation.
  */
 public class ServerCookie implements Serializable {
-    
+
     // Version 0 (Netscape) attributes
     private BBuffer name = BBuffer.allocate();
     private BBuffer value = BBuffer.allocate();
-    
+
     private CBuffer nameC = CBuffer.newInstance();
 
     // Expires - Not stored explicitly. Generated from Max-Age (see V1)
     private BBuffer path = BBuffer.allocate();
     private BBuffer domain = BBuffer.allocate();
     private boolean secure;
-    
+
     // Version 1 (RFC2109) attributes
     private BBuffer comment = BBuffer.allocate();
     private int maxAge = -1;
@@ -69,7 +69,7 @@ public class ServerCookie implements Serializable {
             return df;
         }
     };
-    
+
     private static final String ancientDate;
 
 
@@ -100,7 +100,7 @@ public class ServerCookie implements Serializable {
     public ServerCookie() {
     }
 
-    public void recycle() {        
+    public void recycle() {
         path.recycle();
         name.recycle();
         value.recycle();
@@ -163,7 +163,7 @@ public class ServerCookie implements Serializable {
         return "Cookie " + getName() + "=" + getValue() + " ; "
             + getVersion() + " " + getPath() + " " + getDomain();
     }
-    
+
     private static final String tspecials = ",; ";
     private static final String tspecials2 = "()<>@,;:\\\"/[]?={} \t";
     private static final String tspecials2NoSlash = "()<>@,;:\\\"[]?={} \t";
@@ -180,7 +180,7 @@ public class ServerCookie implements Serializable {
     public static boolean isToken(String value) {
         return isToken(value,null);
     }
-    
+
     public static boolean isToken(String value, String literals) {
         String tspecials = (literals==null?ServerCookie.tspecials:literals);
         if( value==null) return true;
@@ -228,7 +228,7 @@ public class ServerCookie implements Serializable {
 
     // -------------------- Cookie parsing tools
 
-    
+
     /**
      * Return the header name to set the cookie, based on cookie version.
      */
@@ -246,7 +246,7 @@ public class ServerCookie implements Serializable {
             // XXX RFC2965 not referenced in Servlet Spec
             // Set-Cookie2 is not supported by Netscape 4, 6, IE 3, 5
             // Set-Cookie2 is supported by Lynx and Opera
-            // Need to check on later IE and FF releases but for now... 
+            // Need to check on later IE and FF releases but for now...
             // RFC2109
             return "Set-Cookie";
             // return "Set-Cookie2";
@@ -273,7 +273,7 @@ public class ServerCookie implements Serializable {
         buf.append( name );
         buf.append("=");
         // Servlet implementation does not check anything else
-        
+
         version = maybeQuote2(version, buf, value,true);
 
         // Add version 1 specific information
@@ -287,7 +287,7 @@ public class ServerCookie implements Serializable {
                 maybeQuote2(version, buf, comment);
             }
         }
-        
+
         // Add domain information, if present
         if (domain!=null) {
             buf.append("; Domain=");
@@ -331,7 +331,7 @@ public class ServerCookie implements Serializable {
         if (isSecure) {
           buf.append ("; Secure");
         }
-        
+
         // HttpOnly
         if (isHttpOnly) {
             buf.append("; HttpOnly");
@@ -343,7 +343,7 @@ public class ServerCookie implements Serializable {
         if (value==null || value.length()==0) return false;
         return (value.charAt(0)=='\"' && value.charAt(value.length()-1)=='\"');
     }
-    
+
     /**
      * Quotes values using rules that vary depending on Cookie version.
      * @param version
@@ -361,7 +361,7 @@ public class ServerCookie implements Serializable {
     public static int maybeQuote2 (int version, StringBuffer buf, String value, String literals, boolean allowVersionSwitch) {
         if (value==null || value.length()==0) {
             buf.append("\"\"");
-        }else if (containsCTL(value,version)) 
+        }else if (containsCTL(value,version))
             throw new IllegalArgumentException("Control character in cookie value, consider BASE64 encoding your value");
         else if (alreadyQuoted(value)) {
             buf.append('"');
@@ -433,7 +433,7 @@ public class ServerCookie implements Serializable {
         int end = bc.getEnd();
         int dest = src;
         byte[] buffer = bc.array();
-        
+
         while (src < end) {
             if (buffer[src] == '\\' && src < end && buffer[src+1]  == '"') {
                 src++;
@@ -444,16 +444,16 @@ public class ServerCookie implements Serializable {
         }
         bc.setEnd(dest);
     }
-    
+
     /*
     List of Separator Characters (see isSeparator())
-    Excluding the '/' char violates the RFC, but 
+    Excluding the '/' char violates the RFC, but
     it looks like a lot of people put '/'
-    in unquoted values: '/': ; //47 
-    '\t':9 ' ':32 '\"':34 '\'':39 '(':40 ')':41 ',':44 ':':58 ';':59 '<':60 
+    in unquoted values: '/': ; //47
+    '\t':9 ' ':32 '\"':34 '\'':39 '(':40 ')':41 ',':44 ':':58 ';':59 '<':60
     '=':61 '>':62 '?':63 '@':64 '[':91 '\\':92 ']':93 '{':123 '}':125
     */
-    public static final char SEPARATORS[] = { '\t', ' ', '\"', '\'', '(', ')', ',', 
+    public static final char SEPARATORS[] = { '\t', ' ', '\"', '\'', '(', ')', ',',
         ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '{', '}' };
 
     protected static final boolean separators[] = new boolean[128];
@@ -471,7 +471,7 @@ public class ServerCookie implements Serializable {
     public  static void processCookies(List<ServerCookie> cookies,
             List<ServerCookie> cookiesCache,
             HttpMessage.HttpMessageBytes msgBytes ) {
-        
+
         // process each "cookie" header
         for (int i = 0; i < msgBytes.headerCount; i++) {
             if (msgBytes.getHeaderName(i).equalsIgnoreCase("Cookie")) {
@@ -483,12 +483,12 @@ public class ServerCookie implements Serializable {
                         bc.array(),
                         bc.getOffset(),
                         bc.getLength());
-                
+
             }
 
         }
     }
-    
+
     /**
      * Returns true if the byte is a separator character as
      * defined in RFC2619. Since this is called often, this
@@ -502,7 +502,7 @@ public class ServerCookie implements Serializable {
          else
              return false;
     }
-    
+
     /**
      * Returns true if the byte is a whitespace character as
      * defined in RFC2619
@@ -512,7 +512,7 @@ public class ServerCookie implements Serializable {
         // This switch statement is slightly slower
         // for my vm than the if statement.
         // Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_07-164)
-        /* 
+        /*
         switch (c) {
         case ' ':;
         case '\t':;
@@ -557,9 +557,9 @@ public class ServerCookie implements Serializable {
             isQuoted = false;
 
             // Skip whitespace and non-token characters (separators)
-            while (pos < end && 
-                   (isSeparator(bytes[pos]) || isWhiteSpace(bytes[pos]))) 
-                {pos++; } 
+            while (pos < end &&
+                   (isSeparator(bytes[pos]) || isWhiteSpace(bytes[pos])))
+                {pos++; }
 
             if (pos >= end)
                 return;
@@ -570,24 +570,24 @@ public class ServerCookie implements Serializable {
                 pos++;
             }
 
-            // Get the cookie name. This must be a token            
-            valueEnd = valueStart = nameStart = pos; 
+            // Get the cookie name. This must be a token
+            valueEnd = valueStart = nameStart = pos;
             pos = nameEnd = getTokenEndPosition(bytes,pos,end);
 
             // Skip whitespace
-            while (pos < end && isWhiteSpace(bytes[pos])) {pos++; } 
-         
+            while (pos < end && isWhiteSpace(bytes[pos])) {pos++; }
+
 
             // Check for an '=' -- This could also be a name-only
             // cookie at the end of the cookie header, so if we
             // are past the end of the header, but we have a name
             // skip to the name-only part.
-            if (pos < end && bytes[pos] == '=') {                
+            if (pos < end && bytes[pos] == '=') {
 
                 // Skip whitespace
                 do {
                     pos++;
-                } while (pos < end && isWhiteSpace(bytes[pos])); 
+                } while (pos < end && isWhiteSpace(bytes[pos]));
 
                 if (pos >= end)
                     return;
@@ -598,15 +598,15 @@ public class ServerCookie implements Serializable {
                 case '"': // Quoted Value
                     isQuoted = true;
                     valueStart=pos + 1; // strip "
-                    // getQuotedValue returns the position before 
+                    // getQuotedValue returns the position before
                     // at the last qoute. This must be dealt with
                     // when the bytes are copied into the cookie
-                    valueEnd=getQuotedValueEndPosition(bytes, 
+                    valueEnd=getQuotedValueEndPosition(bytes,
                                                        valueStart, end);
                     // We need pos to advance
-                    pos = valueEnd; 
-                    // Handles cases where the quoted value is 
-                    // unterminated and at the end of the header, 
+                    pos = valueEnd;
+                    // Handles cases where the quoted value is
+                    // unterminated and at the end of the header,
                     // e.g. [myname="value]
                     if (pos >= end)
                         return;
@@ -632,15 +632,15 @@ public class ServerCookie implements Serializable {
                         // The starting character of the cookie value was
                         // not valid.
                         //log("Invalid cookie. Value not a token or quoted value");
-                        while (pos < end && bytes[pos] != ';' && 
-                               bytes[pos] != ',') 
+                        while (pos < end && bytes[pos] != ';' &&
+                               bytes[pos] != ',')
                             {pos++; }
                         pos++;
-                        // Make sure no special avpairs can be attributed to 
+                        // Make sure no special avpairs can be attributed to
                         // the previous cookie by setting the current cookie
                         // to null
                         sc = null;
-                        continue;                        
+                        continue;
                     }
                 }
             } else {
@@ -649,21 +649,21 @@ public class ServerCookie implements Serializable {
                 pos = nameEnd;
 
             }
-          
+
             // We should have an avpair or name-only cookie at this
             // point. Perform some basic checks to make sure we are
             // in a good state.
-  
+
             // Skip whitespace
             while (pos < end && isWhiteSpace(bytes[pos])) {pos++; }
 
 
             // Make sure that after the cookie we have a separator. This
             // is only important if this is not the last cookie pair
-            while (pos < end && bytes[pos] != ';' && bytes[pos] != ',') { 
+            while (pos < end && bytes[pos] != ';' && bytes[pos] != ',') {
                 pos++;
             }
-            
+
             pos++;
 
             /*
@@ -672,10 +672,10 @@ public class ServerCookie implements Serializable {
                 // of having two ';' characters in a row.
                 // log("Cookie name/value does not conform to RFC 2965");
                 // Advance to next delimiter (ignoring everything else)
-                while (pos < end && bytes[pos] != ';' && bytes[pos] != ',') 
+                while (pos < end && bytes[pos] != ';' && bytes[pos] != ',')
                     { pos++; };
                 pos++;
-                // Make sure no special cookies can be attributed to 
+                // Make sure no special cookies can be attributed to
                 // the previous cookie by setting the current cookie
                 // to null
                 sc = null;
@@ -683,13 +683,13 @@ public class ServerCookie implements Serializable {
             }
             */
 
-            // All checks passed. Add the cookie, start with the 
+            // All checks passed. Add the cookie, start with the
             // special avpairs first
             if (isSpecial) {
                 isSpecial = false;
                 // $Version must be the first avpair in the cookie header
                 // (sc must be null)
-                if (equals( "Version", bytes, nameStart, nameEnd) && 
+                if (equals( "Version", bytes, nameStart, nameEnd) &&
                     sc == null) {
                     // Set version
                     if( bytes[valueStart] =='1' && valueEnd == (valueStart+1)) {
@@ -698,8 +698,8 @@ public class ServerCookie implements Serializable {
                         // unknown version (Versioning is not very strict)
                     }
                     continue;
-                } 
-                
+                }
+
                 // We need an active cookie for Path/Port/etc.
                 if (sc == null) {
                     continue;
@@ -711,14 +711,14 @@ public class ServerCookie implements Serializable {
                                            valueStart,
                                            valueEnd-valueStart);
                     continue;
-                } 
+                }
 
                 if (equals( "Path", bytes, nameStart, nameEnd)) {
                     sc.getPath().setBytes( bytes,
                                            valueStart,
                                            valueEnd-valueStart);
                     continue;
-                } 
+                }
 
 
                 if (equals( "Port", bytes, nameStart, nameEnd)) {
@@ -727,13 +727,13 @@ public class ServerCookie implements Serializable {
                     //                        valueStart,
                     //                        valueEnd-valueStart );
                     continue;
-                } 
+                }
 
                 // Unknown cookie, complain
                 //log("Unknown Special Cookie");
 
             } else { // Normal Cookie
-                // use a previous value from cache, if any (to avoid GC - tomcat 
+                // use a previous value from cache, if any (to avoid GC - tomcat
                 // legacy )
                 if (cookiesCache.size() > cookies.size()) {
                     sc = cookiesCache.get(cookies.size());
@@ -746,7 +746,7 @@ public class ServerCookie implements Serializable {
                 sc.setVersion( version );
                 sc.getName().append( bytes, nameStart,
                                        nameEnd-nameStart);
-                
+
                 if (valueStart != -1) { // Normal AVPair
                     sc.getValue().append( bytes, valueStart,
                             valueEnd-valueStart);
@@ -757,7 +757,7 @@ public class ServerCookie implements Serializable {
                     }
                 } else {
                     // Name Only
-                    sc.getValue().recycle(); 
+                    sc.getValue().recycle();
                 }
                 sc.nameC.recycle();
                 sc.nameC.append(sc.getName());
@@ -774,13 +774,13 @@ public class ServerCookie implements Serializable {
     private static final int getTokenEndPosition(byte bytes[], int off, int end){
         int pos = off;
         while (pos < end && !isSeparator(bytes[pos])) {pos++; }
-        
+
         if (pos > end)
             return end;
         return pos;
     }
 
-    /** 
+    /**
      * Given a starting position after an initial quote chracter, this gets
      * the position of the end quote. This escapes anything after a '\' char
      * JVK RFC 2616
@@ -789,7 +789,7 @@ public class ServerCookie implements Serializable {
         int pos = off;
         while (pos < end) {
             if (bytes[pos] == '"') {
-                return pos;                
+                return pos;
             } else if (bytes[pos] == '\\' && pos < (end - 1)) {
                 pos+=2;
             } else {
@@ -799,8 +799,8 @@ public class ServerCookie implements Serializable {
         // Error, we have reached the end of the header w/o a end quote
         return end;
     }
-    
-    
+
+
     public static boolean equals( String s, byte b[], int start, int end) {
         int blen = end-start;
         if (b == null || blen != s.length()) {
@@ -814,6 +814,6 @@ public class ServerCookie implements Serializable {
         }
         return true;
     }
-    
+
 }
 

==================================================
BBucket.java
index 770ca2ec3f..af4e200bf0 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/SpdyConnection.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/http/SpdyConnection.java
@@ -21,40 +21,40 @@ import org.apache.tomcat.lite.io.IOChannel;
 import org.apache.tomcat.lite.io.IOConnector;
 
 /*
- * TODO: expectations ? 
+ * TODO: expectations ?
  * Fix docs - order matters
  * Crashes in chrome
- * 
+ *
  * Test with unit tests or:
- *  google-chrome --use-flip=no-ssl 
- *    --user-data-dir=/home/$USER/.config/google-chrome/Test 
+ *  google-chrome --use-flip=no-ssl
+ *    --user-data-dir=/home/$USER/.config/google-chrome/Test
  *    http://localhost:8802/hello
  */
 
-public class SpdyConnection extends HttpConnector.HttpConnection 
+public class SpdyConnection extends HttpConnector.HttpConnection
         implements IOConnector.ConnectedCallback {
-    
-    
+
+
     /** Use compression for headers. Will magically turn to false
      * if the first request doesn't have x8xx ( i.e. compress header )
      */
     boolean headerCompression = true;
     boolean firstFrame = true;
-    
+
     public static long DICT_ID = 3751956914L;
-    private static String SPDY_DICT_S = 
+    private static String SPDY_DICT_S =
         "optionsgetheadpostputdeletetraceacceptaccept-charsetaccept-encodingaccept-" +
         "languageauthorizationexpectfromhostif-modified-sinceif-matchif-none-matchi" +
-        "f-rangeif-unmodifiedsincemax-forwardsproxy-authorizationrangerefererteuser" + 
-        "-agent10010120020120220320420520630030130230330430530630740040140240340440" + 
-        "5406407408409410411412413414415416417500501502503504505accept-rangesageeta" + 
-        "glocationproxy-authenticatepublicretry-afterservervarywarningwww-authentic" + 
-        "ateallowcontent-basecontent-encodingcache-controlconnectiondatetrailertran" + 
-        "sfer-encodingupgradeviawarningcontent-languagecontent-lengthcontent-locati" + 
-        "oncontent-md5content-rangecontent-typeetagexpireslast-modifiedset-cookieMo" + 
-        "ndayTuesdayWednesdayThursdayFridaySaturdaySundayJanFebMarAprMayJunJulAugSe" + 
-        "pOctNovDecchunkedtext/htmlimage/pngimage/jpgimage/gifapplication/xmlapplic" + 
-        "ation/xhtmltext/plainpublicmax-agecharset=iso-8859-1utf-8gzipdeflateHTTP/1" + 
+        "f-rangeif-unmodifiedsincemax-forwardsproxy-authorizationrangerefererteuser" +
+        "-agent10010120020120220320420520630030130230330430530630740040140240340440" +
+        "5406407408409410411412413414415416417500501502503504505accept-rangesageeta" +
+        "glocationproxy-authenticatepublicretry-afterservervarywarningwww-authentic" +
+        "ateallowcontent-basecontent-encodingcache-controlconnectiondatetrailertran" +
+        "sfer-encodingupgradeviawarningcontent-languagecontent-lengthcontent-locati" +
+        "oncontent-md5content-rangecontent-typeetagexpireslast-modifiedset-cookieMo" +
+        "ndayTuesdayWednesdayThursdayFridaySaturdaySundayJanFebMarAprMayJunJulAugSe" +
+        "pOctNovDecchunkedtext/htmlimage/pngimage/jpgimage/gifapplication/xmlapplic" +
+        "ation/xhtmltext/plainpublicmax-agecharset=iso-8859-1utf-8gzipdeflateHTTP/1" +
         ".1statusversionurl ";
     public static byte[] SPDY_DICT = SPDY_DICT_S.getBytes();
     // C code uses this - not in the spec
@@ -64,10 +64,10 @@ public class SpdyConnection extends HttpConnector.HttpConnection
 
 
     protected static Logger log = Logger.getLogger("SpdyConnection");
-    
+
     /**
      * @param spdyConnector
-     * @param remoteServer 
+     * @param remoteServer
      */
     SpdyConnection(HttpConnector spdyConnector, RemoteServer remoteServer) {
         this.httpConnector = spdyConnector;
@@ -76,7 +76,7 @@ public class SpdyConnection extends HttpConnector.HttpConnection
     }
 
     AtomicInteger streamErrors = new AtomicInteger();
-    
+
     AtomicInteger lastInStream = new AtomicInteger();
     AtomicInteger lastOutStream = new AtomicInteger();
 
@@ -91,13 +91,13 @@ public class SpdyConnection extends HttpConnector.HttpConnection
     BBuffer inFrameBuffer = BBuffer.allocate();
 
     BBuffer headW = BBuffer.wrapper();
-    
+
     CompressFilter headCompressIn = new CompressFilter()
         .setDictionary(SPDY_DICT, DICT_ID);
-    
+
     CompressFilter headCompressOut = new CompressFilter()
         .setDictionary(SPDY_DICT, DICT_ID);
-    
+
     IOBuffer headerCompressBuffer = new IOBuffer();
     IOBuffer headerDeCompressBuffer = new IOBuffer();
 
@@ -109,8 +109,8 @@ public class SpdyConnection extends HttpConnector.HttpConnection
     AtomicInteger outFrames = new AtomicInteger();
     AtomicInteger outDataFrames = new AtomicInteger();
     AtomicInteger outBytes = new AtomicInteger();
-    
-        
+
+
     volatile boolean connecting = false;
     volatile boolean connected = false;
 
@@ -120,7 +120,7 @@ public class SpdyConnection extends HttpConnector.HttpConnection
     public void withExtraBuffer(BBuffer received) {
         inFrameBuffer = received;
     }
-    
+
     @Override
     public void dataReceived(IOBuffer iob) throws IOException {
         // Only one thread doing receive at a time.
@@ -157,7 +157,7 @@ public class SpdyConnection extends HttpConnector.HttpConnection
 
     /**
      * Frame received. Must consume all data for the frame.
-     * 
+     *
      * @param iob
      * @throws IOException
      */
@@ -166,7 +166,7 @@ public class SpdyConnection extends HttpConnector.HttpConnection
         lastFrame = currentInFrame;
         inFrames.incrementAndGet();
         inBytes.addAndGet(currentInFrame.length + 8);
-        
+
         if (currentInFrame.c) {
             if (currentInFrame.type == SpdyConnection.Frame.TYPE_HELO) {
                 // receivedHello = currentInFrame;
@@ -184,7 +184,7 @@ public class SpdyConnection extends HttpConnector.HttpConnection
                 }
 
                 synchronized (channels) {
-                        channels.put(ch.channelId, ch);                    
+                        channels.put(ch.channelId, ch);
                 }
 
                 try {
@@ -218,9 +218,9 @@ public class SpdyConnection extends HttpConnector.HttpConnection
                 }
                 try {
                     SpdyConnection.readShort(iob);
-        
+
                     HttpMessageBytes resBytes = ch.getResponse().getMsgBytes();
-                
+
                     BBuffer head = processHeaders(iob, ch, resBytes);
                 } catch (Throwable t) {
                     log.log(Level.SEVERE, "Error parsing head", t);
@@ -271,14 +271,14 @@ public class SpdyConnection extends HttpConnector.HttpConnection
                 }
             }
             ch.sendHandleReceivedCallback();
-            
+
             if ((currentInFrame.flags & SpdyConnection.Frame.FLAG_HALF_CLOSE) != 0) {
                 ch.handleEndReceive();
             }
         }
         firstFrame = false;
     }
-    
+
     /**
      * On frame error.
      */
@@ -306,9 +306,9 @@ public class SpdyConnection extends HttpConnector.HttpConnection
             // 0x800 headers seems a bit too much - assume compressed.
             // I wish this was a flag...
             headerDeCompressBuffer.recycle();
-            // stream id ( 4 ) + unused ( 2 ) 
+            // stream id ( 4 ) + unused ( 2 )
             // nvCount is compressed in impl - spec is different
-            headCompressIn.decompress(iob, headerDeCompressBuffer, 
+            headCompressIn.decompress(iob, headerDeCompressBuffer,
                     currentInFrame.length - 6);
             headerDeCompressBuffer.copyAll(headRecvBuf);
             headerDeCompressBuffer.recycle();
@@ -324,7 +324,7 @@ public class SpdyConnection extends HttpConnector.HttpConnection
         }
         // Wrapper - so we don't change position in head
         headRecvBuf.wrapTo(headW);
-        
+
         BBuffer nameBuf = BBuffer.wrapper();
         BBuffer valBuf = BBuffer.wrapper();
 
@@ -378,15 +378,15 @@ public class SpdyConnection extends HttpConnector.HttpConnection
         BBuffer headBuf = BBuffer.allocate();
         SpdyConnection.appendShort(headBuf, mimeHeaders.size() + 3);
         serializeMime(mimeHeaders, headBuf);
-        
+
         // TODO: url - with host prefix , method
         // optimize...
         SpdyConnection.appendAsciiHead(headBuf, "version");
         SpdyConnection.appendAsciiHead(headBuf, "HTTP/1.1");
-        
+
         SpdyConnection.appendAsciiHead(headBuf, "method");
         SpdyConnection.appendAsciiHead(headBuf, http.getRequest().getMethod());
-        
+
         SpdyConnection.appendAsciiHead(headBuf, "url");
         // TODO: url
         SpdyConnection.appendAsciiHead(headBuf, http.getRequest().requestURL());
@@ -400,44 +400,44 @@ public class SpdyConnection extends HttpConnector.HttpConnection
 
         // Frame head - 8
         BBuffer out = BBuffer.allocate();
-        // Syn-reply 
-        out.putByte(0x80); 
-        out.putByte(0x01); 
-        out.putByte(0x00); 
+        // Syn-reply
+        out.putByte(0x80);
         out.putByte(0x01);
-        
+        out.putByte(0x00);
+        out.putByte(0x01);
+
         CBuffer method = http.getRequest().method();
         if (method.equals("GET") || method.equals("HEAD")) {
             http.getOut().close();
         }
-        
+
         if (http.getOut().isAppendClosed()) {
             out.putByte(0x01); // closed
         } else {
-            out.putByte(0x00); 
+            out.putByte(0x00);
         }
-        
-        // Length, channel id (4) + unused (2) - headBuf has header count 
+
+        // Length, channel id (4) + unused (2) - headBuf has header count
         // and headers
         SpdyConnection.append24(out, headBuf.remaining() + 6);
-        
+
         if (serverMode) {
             http.channelId = 2 * lastOutStream.incrementAndGet();
         } else {
-            http.channelId = 2 * lastOutStream.incrementAndGet() + 1;            
+            http.channelId = 2 * lastOutStream.incrementAndGet() + 1;
         }
         SpdyConnection.appendInt(out, http.channelId);
-        
+
         http.setConnection(this);
 
         synchronized (channels) {
-            channels.put(http.channelId, http);            
+            channels.put(http.channelId, http);
         }
-        
-        out.putByte(0x00); // no priority 
-        out.putByte(0x00); 
-        
-        sendFrame(out, headBuf); 
+
+        out.putByte(0x00); // no priority
+        out.putByte(0x00);
+
+        sendFrame(out, headBuf);
 
         if (http.outMessage.state == HttpMessage.State.HEAD) {
             http.outMessage.state = HttpMessage.State.BODY_DATA;
@@ -450,13 +450,13 @@ public class SpdyConnection extends HttpConnector.HttpConnection
         //sendData(http);
     }
 
-    
+
     public synchronized Collection<HttpChannel> getActives() {
         synchronized(channels) {
             return channels.values();
         }
     }
-    
+
     @Override
     protected synchronized void sendResponseHeaders(HttpChannel http) throws IOException {
         if (!serverMode) {
@@ -464,7 +464,7 @@ public class SpdyConnection extends HttpConnector.HttpConnection
         }
 
         if (http.getResponse().isCommitted()) {
-            return; 
+            return;
         }
         http.getResponse().setCommitted(true);
 
@@ -482,14 +482,14 @@ public class SpdyConnection extends HttpConnector.HttpConnection
         //SpdyConnection.appendInt(headers, http.channelId);
         //headers.putByte(0);
         //headers.putByte(0);
-        SpdyConnection.appendShort(headers, mimeHeaders.size() + 2);        
-        
+        SpdyConnection.appendShort(headers, mimeHeaders.size() + 2);
+
         // chrome will crash if we don't send the header
         serializeMime(mimeHeaders, headers);
 
         // Must be at the end
         SpdyConnection.appendAsciiHead(headers, "status");
-        SpdyConnection.appendAsciiHead(headers, 
+        SpdyConnection.appendAsciiHead(headers,
                 Integer.toString(http.getResponse().getStatus()));
 
         SpdyConnection.appendAsciiHead(headers, "version");
@@ -501,16 +501,16 @@ public class SpdyConnection extends HttpConnector.HttpConnection
             headerCompressBuffer.copyAll(headBuf);
             headerCompressBuffer.recycle();
         }
-        
+
         BBuffer frameHead = BBuffer.allocate();
-        // Syn-reply 
+        // Syn-reply
         frameHead.putByte(0x80); // Control
         frameHead.putByte(0x01); // version
         frameHead.putByte(0x00); // 00 02 - SYN_REPLY
         frameHead.putByte(0x02);
-        
+
         // It seems piggibacking data is not allowed
-        frameHead.putByte(0x00); 
+        frameHead.putByte(0x00);
 
         int len = headBuf.remaining() + 6;
         SpdyConnection.append24(frameHead, len);
@@ -522,17 +522,17 @@ public class SpdyConnection extends HttpConnector.HttpConnection
 
         sendFrame(frameHead, headBuf);
     }
-    
-    
+
+
     public void startSending(HttpChannel http) throws IOException {
         http.send(); // if needed
-        
+
         if (net != null) {
             sendData(http);
             net.startSending();
         }
     }
-    
+
     private void sendData(HttpChannel http) throws IOException {
         int avail = http.getOut().available();
         boolean closed = http.getOut().isAppendClosed();
@@ -548,7 +548,7 @@ public class SpdyConnection extends HttpConnector.HttpConnection
         }
     }
 
-    private BBuffer serializeMime(MultiMap mimeHeaders, BBuffer headBuf) 
+    private BBuffer serializeMime(MultiMap mimeHeaders, BBuffer headBuf)
             throws IOException {
 
         // TODO: duplicated headers not allowed
@@ -605,7 +605,7 @@ public class SpdyConnection extends HttpConnector.HttpConnection
             net.getOut().append(out2, avail);
         }
         net.startSending();
-        outDataFrames.incrementAndGet();        
+        outDataFrames.incrementAndGet();
     }
 
     static void appendInt(BBuffer headBuf, int length) throws IOException {
@@ -664,30 +664,30 @@ public class SpdyConnection extends HttpConnector.HttpConnection
 
     public static class Frame {
         int flags;
-    
+
         int length;
-    
+
         boolean c; // for control
-    
+
         int version;
-    
+
         int type;
-    
+
         int streamId; // for data
-    
+
         static int TYPE_HELO = 4;
-    
+
         static int TYPE_SYN_STREAM = 1;
 
         static int TYPE_SYN_REPLY = 2;
-    
+
         static int FLAG_HALF_CLOSE = 1;
-    
+
         public void parse(SpdyConnection spdyConnection,
                 BBuffer iob) throws IOException {
             int b0 = iob.read();
             if (b0 < 128) {
-                // data frame 
+                // data frame
                 c = false;
                 streamId = b0;
                 for (int i = 0; i < 3; i++) {
@@ -705,18 +705,18 @@ public class SpdyConnection extends HttpConnector.HttpConnection
                 b0 = iob.read();
                 type = ((b0 << 8) | iob.read());
             }
-    
+
             flags = iob.read();
             for (int i = 0; i < 3; i++) {
                 b0 = iob.read();
                 length = length << 8 | b0;
             }
-            
+
             iob.recycle();
         }
-    
+
     }
-    
+
     @Override
     protected void endSendReceive(HttpChannel http) throws IOException {
         synchronized (channels) {
@@ -727,31 +727,31 @@ public class SpdyConnection extends HttpConnector.HttpConnection
         }
         httpConnector.cpool.afterRequest(http, this, true);
     }
-    
-    /** 
+
+    /**
      * Framing error, client interrupt, etc.
      */
     public void abort(HttpChannel http, String t) throws IOException {
         // TODO: send interrupt signal
-        
+
     }
-    
-    
+
+
     private boolean checkConnection(HttpChannel http) throws IOException {
         synchronized(this) {
             if (net == null || !isOpen()) {
                 connected = false;
             }
-        
+
             if (!connected) {
                 if (!connecting) {
-                    // TODO: secure set at start ? 
+                    // TODO: secure set at start ?
                     connecting = true;
-                    httpConnector.cpool.httpConnect(http, 
-                            target.toString(), 
+                    httpConnector.cpool.httpConnect(http,
+                            target.toString(),
                             http.getRequest().isSecure(), this);
                 }
-                
+
                 synchronized (remoteHost) {
                     remoteHost.pending.add(http);
                     httpConnector.cpool.queued.incrementAndGet();
@@ -775,7 +775,7 @@ public class SpdyConnection extends HttpConnector.HttpConnection
                     httpCh = remoteHost.pending.remove();
                 }
                 httpCh.abort("Can't connect");
-            }            
+            }
         }
 
         synchronized (remoteHost) {
@@ -789,23 +789,23 @@ public class SpdyConnection extends HttpConnector.HttpConnection
                 }
                 String[] hostPort = httpCh.getTarget().split(":");
 
-                IOChannel ch1 = httpConnector.sslProvider.channel(net, 
+                IOChannel ch1 = httpConnector.sslProvider.channel(net,
                         hostPort[0], Integer.parseInt(hostPort[1]));
                 //net.setHead(ch1);
                 net = ch1;
             }
-        }        
+        }
         if (httpConnector.debugHttp) {
             net = DumpChannel.wrap("SPDY", net);
         }
-        
+
         setSink(net);
-        
+
         synchronized(this) {
             connecting = false;
             connected = true;
         }
- 
+
         while (true) {
             synchronized (remoteHost) {
                 if (remoteHost.pending.size() == 0) {

==================================================
BBuffer.java
index e68c62bc8a..560629bd05 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/BBucket.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/BBucket.java
@@ -6,33 +6,33 @@ import java.nio.ByteBuffer;
 
 
 
-/** 
+/**
  * Holds raw data. Similar interface with a ByteBuffer in 'channel write'
- * or 'read mode'. Data is between position and limit - there is no 
+ * or 'read mode'. Data is between position and limit - there is no
  * switching.
- * 
+ *
  * TODO: FileBucket, DirectBufferBucket, CharBucket, ...
- * 
+ *
  * @author Costin Manolache
  */
 public interface BBucket {
-    
+
     public void release();
 
     public byte[] array();
     public int position();
     public int remaining();
     public int limit();
-    
+
     public boolean hasRemaining();
-    
+
     public void position(int newStart);
 
-    /** 
-     * Return a byte buffer, with data between position and limit. 
-     * Changes in the ByteBuffer position will not be reflected 
+    /**
+     * Return a byte buffer, with data between position and limit.
+     * Changes in the ByteBuffer position will not be reflected
      * in the IOBucket.
-     * 
+     *
      * @return
      */
     public ByteBuffer getByteBuffer();

==================================================
BufferedIOReader.java
index f4053a056d..e3c20fa588 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/BBuffer.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/BBuffer.java
@@ -42,36 +42,36 @@ import java.nio.charset.Charset;
 /**
  * This class is used to represent a chunk of bytes, and utilities to manipulate
  * byte[].
- * 
+ *
  * The buffer can be modified and used for both input and output.
- * 
+ *
  * There are 2 modes: The chunk can be associated with a sink - ByteInputChannel
  * or ByteOutputChannel, which will be used when the buffer is empty ( on input
  * ) or filled ( on output ). For output, it can also grow. This operating mode
  * is selected by calling setLimit() or allocate(initial, limit) with limit !=
  * -1.
- * 
+ *
  * Various search and append method are defined - similar with String and
  * StringBuffer, but operating on bytes.
- * 
+ *
  * This is important because it allows processing the http headers directly on
  * the received bytes, without converting to chars and Strings until the strings
  * are needed. In addition, the charset is determined later, from headers or
  * user code.
- * 
- * 
+ *
+ *
  * @author dac@sun.com
  * @author James Todd [gonzo@sun.com]
  * @author Costin Manolache
  * @author Remy Maucherat
  */
-public class BBuffer implements Cloneable, Serializable, 
+public class BBuffer implements Cloneable, Serializable,
     BBucket {
-    
+
     /**
      * Default encoding used to convert to strings. It should be UTF8, but:
      * - the servlet API requires 8859_1 as default
-     * -  
+     * -
      */
     public static final String DEFAULT_CHARACTER_ENCODING = "ISO-8859-1";
 
@@ -108,10 +108,10 @@ public class BBuffer implements Cloneable, Serializable,
      * CR.
      */
     public static final byte CR = (byte) '\r';
-    
+
     //private int useCount;
-    
-    
+
+
     private static final boolean[] isDigit = new boolean[256];
 
     static Charset UTF8;
@@ -141,7 +141,7 @@ public class BBuffer implements Cloneable, Serializable,
     static {
         for (int d = '0'; d <= '9'; d++) {
             isDigit[d] = true;
-        }        
+        }
         UTF8 = Charset.forName("UTF-8");
     }
 
@@ -153,7 +153,7 @@ public class BBuffer implements Cloneable, Serializable,
         return new BBuffer().makeSpace(initial);
     }
 
-    
+
     public static BBuffer allocate(String msg) {
         BBuffer bc = allocate();
         byte[] data = msg.getBytes();
@@ -183,7 +183,7 @@ public class BBuffer implements Cloneable, Serializable,
         res.setBytes(b, off, len);
         return res;
     }
-    
+
     public static BBuffer wrapper(BBucket bb, int start, int len) {
         BBuffer res = new IOBucketWrap();
         res.setBytes(bb.array(), bb.position() + start, len);
@@ -216,7 +216,7 @@ public class BBuffer implements Cloneable, Serializable,
     // -------------------- Adding data to the buffer --------------------
     /**
      * Append a char, by casting it to byte. This IS NOT intended for unicode.
-     * 
+     *
      * @param c
      */
     public void append(char c) {
@@ -232,7 +232,7 @@ public class BBuffer implements Cloneable, Serializable,
     public byte[] array() {
         return buff;
     }
-    
+
     public int capacity() {
         return buff.length;
     }
@@ -285,7 +285,7 @@ public class BBuffer implements Cloneable, Serializable,
 
     /**
      * Compares the message bytes to the specified String object.
-     * 
+     *
      * @param s
      *            the String to compare
      * @return true if the comparison succeeded, false otherwise
@@ -307,10 +307,10 @@ public class BBuffer implements Cloneable, Serializable,
         }
         return true;
     }
-    
+
     /**
      * Compares the message bytes to the specified String object.
-     * 
+     *
      * @param s
      *            the String to compare
      * @return true if the comparison succeeded, false otherwise
@@ -337,7 +337,7 @@ public class BBuffer implements Cloneable, Serializable,
         return buff[start + off] & 0xFF;
     }
 
-    /** 
+    /**
      * Return a byte buffer. Changes in the ByteBuffer position will
      * not be reflected in the IOBucket
      * @return
@@ -360,7 +360,7 @@ public class BBuffer implements Cloneable, Serializable,
             return null;
         }
     }
-    
+
     public int getEnd() {
         return end;
     }
@@ -374,7 +374,7 @@ public class BBuffer implements Cloneable, Serializable,
     public int getLength() {
         return end - start;
     }
-    
+
     public long getLong() {
         return parseLong(buff, start, end - start);
     }
@@ -422,7 +422,7 @@ public class BBuffer implements Cloneable, Serializable,
 
     /**
      * Returns true if the message bytes starts with the specified string.
-     * 
+     *
      * @param s
      *            the string
      */
@@ -462,7 +462,7 @@ public class BBuffer implements Cloneable, Serializable,
 
     /**
      * Returns true if the message bytes starts with the specified string.
-     * 
+     *
      * @param c
      *            the character
      * @param starting
@@ -475,7 +475,7 @@ public class BBuffer implements Cloneable, Serializable,
 
     /**
      * Returns true if the message bytes starts with the specified string.
-     * 
+     *
      * @param s
      *            the string
      * @param pos
@@ -498,7 +498,7 @@ public class BBuffer implements Cloneable, Serializable,
     public int indexOf(String src) {
         return indexOf(src, 0, src.length(), 0);
     }
-    
+
     public int indexOf(String src, int srcOff, int srcLen, int myOff) {
         if ("".equals(src)) {
             return myOff;
@@ -552,7 +552,7 @@ public class BBuffer implements Cloneable, Serializable,
     }
 
     /**
-     * Make space for len chars. 
+     * Make space for len chars.
      * If len is small, allocate a reserve space too.
      */
     public BBuffer makeSpace(int count) {
@@ -594,7 +594,7 @@ public class BBuffer implements Cloneable, Serializable,
 
 //    /**
 //     * Find a character, no side effects.
-//     * 
+//     *
 //     * @return index of char if found, -1 if not
 //     */
 //    public static int findChars(byte buf[], int start, int end, byte c[]) {
@@ -612,7 +612,7 @@ public class BBuffer implements Cloneable, Serializable,
 
 //    /**
 //     * Find the first character != c
-//     * 
+//     *
 //     * @return index of char if found, -1 if not
 //     */
 //    public static int findNotChars(byte buf[], int start, int end, byte c[]) {
@@ -666,10 +666,10 @@ public class BBuffer implements Cloneable, Serializable,
         return res.remaining();
     }
 
-    /** 
+    /**
      * Read a chunk from is.
-     * 
-     * You don't need to use buffered input stream, we do the 
+     *
+     * You don't need to use buffered input stream, we do the
      * buffering.
      */
     public int read(InputStream is) throws IOException {
@@ -701,11 +701,11 @@ public class BBuffer implements Cloneable, Serializable,
 
 
     /**
-     *  Read a line - excluding the line terminator, which is consummed as 
+     *  Read a line - excluding the line terminator, which is consummed as
      *  well but not included in the response.
-     *  
+     *
      *  Line can end with CR, LF or CR/LF
-     * 
+     *
      * @param res
      * @return number of bytes read, or -1 if line ending not found in buffer.
      */
@@ -729,11 +729,11 @@ public class BBuffer implements Cloneable, Serializable,
         start = cstart;
         return -1;
     }
-    /** 
+    /**
      * Consume up to but not including delim.
-     * 
+     *
      */
-    public final int readToDelimOrSpace(byte delim, 
+    public final int readToDelimOrSpace(byte delim,
             BBuffer res) {
         int resStart = start;
         while (true) {
@@ -751,10 +751,10 @@ public class BBuffer implements Cloneable, Serializable,
     }
 
 
-    /** 
+    /**
      * Consume all up to the first space or \t, which will be the
      * first character in the buffer.
-     * 
+     *
      * Consumed data is wrapped in res.
      */
     public int readToSpace(BBuffer res) {
@@ -763,7 +763,7 @@ public class BBuffer implements Cloneable, Serializable,
           if (start >= end) {
               break;
           }
-          if (buff[start] == SP 
+          if (buff[start] == SP
                   || buff[start] == HT) {
               break;
           }
@@ -780,7 +780,7 @@ public class BBuffer implements Cloneable, Serializable,
         end = 0;
     }
     @Override
-    public void release() { 
+    public void release() {
 //        synchronized (this) {
 //            useCount--;
 //            if (useCount == -1) {
@@ -796,11 +796,11 @@ public class BBuffer implements Cloneable, Serializable,
     public void reset() {
         buff = null;
     }
-    
+
     // -------------------- Setup --------------------
     /**
      * Sets the message bytes to the specified subarray of bytes.
-     * 
+     *
      * @param b
      *            the ascii bytes
      * @param off
@@ -811,7 +811,7 @@ public class BBuffer implements Cloneable, Serializable,
     public void setBytes(byte[] b, int off, int len) {
         throw new RuntimeException("Can't setBytes on allocated buffer");
     }
-    
+
     public void wrap(BBucket b) {
         setBytes(b.array(), b.position(), b.remaining());
     }
@@ -819,13 +819,13 @@ public class BBuffer implements Cloneable, Serializable,
     public void wrap(ByteBuffer b) {
         setBytes(b.array(), b.position(), b.remaining());
     }
-    
+
     protected void setBytesInternal(byte[] b, int off, int len) {
         buff = b;
         start = off;
         end = start + len;
     }
-    
+
 //    public final void lowerCase() {
 //        while (start < end) {
 //            byte chr = buff[start];
@@ -839,7 +839,7 @@ public class BBuffer implements Cloneable, Serializable,
     public void setEnd(int i) {
         end = i;
     }
-    
+
     /**
      * The old code from MessageBytes, used for setContentLength
      * and setStatus.
@@ -879,14 +879,14 @@ public class BBuffer implements Cloneable, Serializable,
             end--;
         }
     }
-    
+
     public void setOffset(int off) {
         if (end < off)
             end = off;
         start = off;
     }
-    
-    
+
+
     public int skipEmptyLines() {
         int resStart = start;
         while (buff[start] == CR || buff[start] == LF) {
@@ -897,7 +897,7 @@ public class BBuffer implements Cloneable, Serializable,
         }
         return start - resStart;
     }
-    
+
     public int skipSpace() {
         int cstart = start;
         while (true) {
@@ -932,7 +932,7 @@ public class BBuffer implements Cloneable, Serializable,
         return len;
 
     }
-    
+
     public int substract(byte src[], int off, int len)  {
 
         if ((end - start) == 0) {
@@ -948,7 +948,7 @@ public class BBuffer implements Cloneable, Serializable,
         return n;
 
     }
-    
+
     public String toString() {
         return toString(DEFAULT_CHARACTER_ENCODING);
     }
@@ -959,23 +959,23 @@ public class BBuffer implements Cloneable, Serializable,
         } else if (end == start) {
             return "";
         }
-        
+
         String strValue = null;
         try {
             if (enc == null) {
                 enc = DEFAULT_CHARACTER_ENCODING;
             }
-            
+
             strValue = new String(buff, start, end - start, enc);
             /*
              * Does not improve the speed too much on most systems, it's safer
              * to use the "clasical" new String().
-             * 
+             *
              * Most overhead is in creating char[] and copying, the internal
              * implementation of new String() is very close to what we do. The
              * decoder is nice for large buffers and if we don't go to String (
              * so we can take advantage of reduced GC)
-             * 
+             *
              * // Method is commented out, in: return B2CConverter.decodeString(
              * enc );
              */
@@ -994,7 +994,7 @@ public class BBuffer implements Cloneable, Serializable,
     /**
      * Convert specified String to a byte array. This ONLY WORKS for ascii, UTF
      * chars will be truncated.
-     * 
+     *
      * @param value
      *            to convert to byte array
      * @return the byte array value
@@ -1006,10 +1006,10 @@ public class BBuffer implements Cloneable, Serializable,
         }
         return result;
     }
-    
+
     /**
      * Find a character, no side effects.
-     * 
+     *
      * @return index of char if found, -1 if not
      */
     public static int findChar(byte buf[], int start, int end, char c) {
@@ -1038,7 +1038,7 @@ public class BBuffer implements Cloneable, Serializable,
         int pos = bucket.position();
         int lastValid = bucket.limit();
         byte[] buf = bucket.array();
-        
+
         for (int i = pos; i < lastValid; i++) {
             byte chr = buf[i];
             if (chr == LF) {
@@ -1062,7 +1062,7 @@ public class BBuffer implements Cloneable, Serializable,
                         return true;
                     }
                 }
-                
+
             }
         }
         return false;
@@ -1133,7 +1133,7 @@ public class BBuffer implements Cloneable, Serializable,
 
         long n = c - '0';
         long m;
-        
+
         while (--len > 0) {
             if (!isDigit(c = b[off++])) {
                 throw new NumberFormatException();
@@ -1171,25 +1171,25 @@ public class BBuffer implements Cloneable, Serializable,
 
     /**
      * A slice of a bucket, holding reference to a parent bucket.
-     * 
+     *
      * This is used when a filter splits a bucket - the original
      * will be replaced with 1 or more slices. When all slices are
      * released, the parent will also be released.
-     * 
+     *
      * It is not possible to add data.
-     * 
+     *
      * @author Costin Manolache
      */
     static class IOBucketWrap extends BBuffer {
         //IOBucket parent;
-        
-        
+
+
         public BBuffer makeSpace(int count) {
             throw new RuntimeException("Attempting to change buffer " +
             		"on a wrapped BBuffer");
         }
 
-        public void release() { 
+        public void release() {
 //            if (parent != null) {
 //                parent.release();
 //            }
@@ -1200,5 +1200,5 @@ public class BBuffer implements Cloneable, Serializable,
         }
     }
 
-    
+
 }

==================================================
CBucket.java
index a0a00aedd6..35d339a0ed 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/BufferedIOReader.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/BufferedIOReader.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -25,7 +25,7 @@ import java.nio.CharBuffer;
 /**
  * Cut&pasted from Harmony buffered reader ( apache license ).
  * Changes:
- * - additional method to recycle to avoid re-allocating on 
+ * - additional method to recycle to avoid re-allocating on
  * each request.
  */
 public class BufferedIOReader extends BufferedReader {
@@ -45,9 +45,9 @@ public class BufferedIOReader extends BufferedReader {
     private int pos;
 
     public BufferedIOReader(IOReader realReader) {
-        // we're not using super - we override all methods, but need the 
-        // signature 
-        super(DUMMY_READER, 1); 
+        // we're not using super - we override all methods, but need the
+        // signature
+        super(DUMMY_READER, 1);
         this.in = realReader;
         buf = new char[8192];
     }
@@ -55,7 +55,7 @@ public class BufferedIOReader extends BufferedReader {
     public void recycle() {
         enc = null;
         closed = false;
-        
+
         if (in != null) {
             in.recycle();
         }
@@ -68,7 +68,7 @@ public class BufferedIOReader extends BufferedReader {
     private void checkClosed() throws IOException {
         if (closed) throw new IOException("closed");
     }
-    
+
     public int read(CharBuffer target) throws IOException {
         checkClosed();
         int len = target.remaining();
@@ -88,7 +88,7 @@ public class BufferedIOReader extends BufferedReader {
      * Closes this reader. This implementation closes the buffered source reader
      * and releases the buffer. Nothing is done if this reader has already been
      * closed.
-     * 
+     *
      * @throws IOException
      *             if an error occurs while closing this reader.
      */
@@ -230,7 +230,7 @@ public class BufferedIOReader extends BufferedReader {
      * represented by zero or more characters followed by {@code '\n'},
      * {@code '\r'}, {@code "\r\n"} or the end of the reader. The string does
      * not include the newline sequence.
-     * 
+     *
      * @return the contents of the line or {@code null} if no characters were
      *         read before the end of the reader has been reached.
      * @throws IOException
@@ -312,7 +312,7 @@ public class BufferedIOReader extends BufferedReader {
 
     }
 
-    
+
     @Override
     public boolean ready() throws IOException {
         synchronized (lock) {
@@ -364,7 +364,7 @@ public class BufferedIOReader extends BufferedReader {
             return amount;
         }
     }
-    
+
     private static Reader DUMMY_READER = new Reader() {
         @Override
         public void close() throws IOException {

==================================================
CBuffer.java
index aed8d971b9..688785ecd9 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/CBucket.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/CBucket.java
@@ -6,12 +6,12 @@ import java.io.Serializable;
 import java.nio.CharBuffer;
 
 /**
- * Wraps a char[]. 
- * 
+ * Wraps a char[].
+ *
  * Doesn't provide any mutation methods. Classes in this package
- * have access to the buffer, for conversions. 
- * 
- * 
+ * have access to the buffer, for conversions.
+ *
+ *
  * @author Costin Manolache
  */
 public class CBucket implements CharSequence, Comparable, Serializable {
@@ -23,7 +23,7 @@ public class CBucket implements CharSequence, Comparable, Serializable {
 
     // Reused.
     protected CharBuffer cb;
-    
+
     // cache
     protected String strValue;
     protected int hash;
@@ -31,7 +31,7 @@ public class CBucket implements CharSequence, Comparable, Serializable {
     public CBucket() {
     }
 
-    /** 
+    /**
      * Used by IOWriter for conversion. Will not modify the content.
      */
     CharBuffer getNioBuffer() {
@@ -43,7 +43,7 @@ public class CBucket implements CharSequence, Comparable, Serializable {
         }
         return cb;
     }
-    
+
     public void recycle() {
         start = 0;
         end = 0;
@@ -51,7 +51,7 @@ public class CBucket implements CharSequence, Comparable, Serializable {
         strValue = null;
         hash = 0;
     }
-    
+
     public String toString() {
         if (null == value) {
             return null;
@@ -65,7 +65,7 @@ public class CBucket implements CharSequence, Comparable, Serializable {
     }
 
     /**
-     * Same as String 
+     * Same as String
      */
     public int hashCode() {
         int h = hash;
@@ -80,7 +80,7 @@ public class CBucket implements CharSequence, Comparable, Serializable {
         }
         return h;
     }
-    
+
     public long getLong() {
         return parseLong(value, start, end - start);
     }
@@ -143,7 +143,7 @@ public class CBucket implements CharSequence, Comparable, Serializable {
 
     /**
      * Compares the message bytes to the specified String object.
-     * 
+     *
      * @param s
      *            the String to compare
      * @return true if the comparison succeeded, false otherwise
@@ -165,7 +165,7 @@ public class CBucket implements CharSequence, Comparable, Serializable {
 
     /**
      * Compares the message bytes to the specified String object.
-     * 
+     *
      * @param s
      *            the String to compare
      * @return true if the comparison succeeded, false otherwise
@@ -232,10 +232,10 @@ public class CBucket implements CharSequence, Comparable, Serializable {
         return true;
     }
 
-    
+
     /**
      * Returns true if the message bytes starts with the specified string.
-     * 
+     *
      * @param s
      *            the string
      */
@@ -256,7 +256,7 @@ public class CBucket implements CharSequence, Comparable, Serializable {
 
     /**
      * Returns true if the message bytes starts with the specified string.
-     * 
+     *
      * @param s
      *            the string
      */
@@ -278,12 +278,12 @@ public class CBucket implements CharSequence, Comparable, Serializable {
     public int indexOf(char c) {
         return indexOf(c, start);
     }
-    
+
     public int lastIndexOf(char c) {
         return lastIndexOf(c, 0, end - start);
     }
 
-    /** 
+    /**
      */
     public int lastIndexOf(char c, int off, int len) {
         char[] buf = value;
@@ -296,10 +296,10 @@ public class CBucket implements CharSequence, Comparable, Serializable {
         }
         return slash;
     }
-    
+
     /**
      * Returns true if the message bytes starts with the specified string.
-     * 
+     *
      * @param c
      *            the character
      */
@@ -321,7 +321,7 @@ public class CBucket implements CharSequence, Comparable, Serializable {
     public int indexOf(String src) {
         return indexOf(src, 0, src.length(), 0);
     }
-    
+
     public int indexOf(String src, int srcOff, int srcLen, int myOff) {
         char first = src.charAt(srcOff);
 
@@ -342,7 +342,7 @@ public class CBucket implements CharSequence, Comparable, Serializable {
         }
         return -1;
     }
-    
+
     public char lastChar() {
         return value[end - 1];
     }
@@ -350,7 +350,7 @@ public class CBucket implements CharSequence, Comparable, Serializable {
     public char charAt(int index) {
         return value[index + start];
     }
-    
+
     public void wrap(char[] buff, int start, int end) {
         if (value != null) {
             throw new RuntimeException("Can wrap only once");
@@ -359,13 +359,13 @@ public class CBucket implements CharSequence, Comparable, Serializable {
         this.start = start;
         this.end = end;
     }
-    
+
     public CharSequence subSequence(int sstart, int send) {
         CBucket seq = new CBucket();
         seq.wrap(this.value, start + sstart, start + send);
         return seq;
     }
-    
+
     public int length() {
         return end - start;
     }
@@ -387,13 +387,13 @@ public class CBucket implements CharSequence, Comparable, Serializable {
                 }
             }
             return len - destLen;
-            
+
         } else if (o instanceof CharSequence) {
             CharSequence dest = (CharSequence) o;
             int o1 = start, o2 = 0, result;
             int len = end - start;
             int destLen = dest.length();
-            int fin = (len < destLen ? 
+            int fin = (len < destLen ?
                     end : start + destLen);
             while (o1 < fin) {
                 if ((result = value[o1++] - dest.charAt(o2++)) != 0) {
@@ -401,7 +401,7 @@ public class CBucket implements CharSequence, Comparable, Serializable {
                 }
             }
             return len - destLen;
-            
+
         } else {
             throw new RuntimeException("CompareTo not supported " + o);
         }
@@ -462,7 +462,7 @@ public class CBucket implements CharSequence, Comparable, Serializable {
         }
         return result;
     }
-    
+
     public int getExtension(CBuffer ext, char slashC, char dotC) {
         int slash = lastIndexOf(slashC);
         if (slash < 0) {
@@ -483,17 +483,17 @@ public class CBucket implements CharSequence, Comparable, Serializable {
         char[] c = value;
         int pos = start;
         int count = 0;
-    
+
         while (pos < end) {
             if ((c[pos++] == '/') && ((++count) == n)) {
                 pos--;
                 break;
             }
         }
-    
+
         return pos - start;
     }
-    
+
 
     public boolean hasUpper() {
         for (int i = start; i < end; i++) {
@@ -504,5 +504,5 @@ public class CBucket implements CharSequence, Comparable, Serializable {
         }
         return false;
     }
-    
+
 }

==================================================
DumpChannel.java
index c66f85644a..86b42347d8 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/CBuffer.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/CBuffer.java
@@ -22,22 +22,22 @@ import java.nio.CharBuffer;
 
 
 /**
- * Similar with StringBuilder or StringBuffer, but with access to the 
+ * Similar with StringBuilder or StringBuffer, but with access to the
  * raw buffer - this avoids copying the data.
- * 
+ *
  * Utilities to manipluate char chunks. While String is the easiest way to
  * manipulate chars ( search, substrings, etc), it is known to not be the most
  * efficient solution - Strings are designed as imutable and secure objects.
- * 
+ *
  * @author dac@sun.com
  * @author James Todd [gonzo@sun.com]
  * @author Costin Manolache
  * @author Remy Maucherat
  */
-public class CBuffer extends CBucket implements Cloneable,   
+public class CBuffer extends CBucket implements Cloneable,
         Appendable {
 
-    
+
     /**
      * Creates a new, uninitialized CharChunk object.
      */
@@ -56,15 +56,15 @@ public class CBuffer extends CBucket implements Cloneable,
         start = 0;
         end = 0;
     }
-    
+
     /**
-     * Same as String 
+     * Same as String
      */
     public int hashCode() {
         int h = 0;
         int off = start;
         char val[] = value;
-        
+
         for (int i = start; i < end; i++) {
             h = 31*h + val[off++];
         }
@@ -93,18 +93,18 @@ public class CBuffer extends CBucket implements Cloneable,
         this.start = buff.start + off;
         this.end = this.start + srcEnd - off;
     }
-    
-    
+
+
     // ----------- Used for IOWriter / conversion ---------
-    
+
     public char[] array() {
         return value;
     }
-    
+
     public int position() {
         return start;
     }
-    
+
     CharBuffer getAppendCharBuffer() {
         makeSpace(16);
         if (cb == null || cb.array() != value) {
@@ -113,24 +113,24 @@ public class CBuffer extends CBucket implements Cloneable,
             cb.position(end);
             cb.limit(value.length);
         }
-        return cb;        
+        return cb;
     }
 
     void returnNioBuffer(CharBuffer c) {
         dirty();
         start = c.position();
     }
-    
+
     void returnAppendCharBuffer(CharBuffer c) {
         dirty();
         end = c.position();
     }
 
     // -------- Delete / replace ---------------
-    
-    /** 
+
+    /**
      * 'Delete' all chars after offset.
-     * 
+     *
      * @param offset
      */
     public void delete(int offset) {
@@ -148,7 +148,7 @@ public class CBuffer extends CBucket implements Cloneable,
     public CBuffer append(CharSequence csq, int astart, int aend)
             throws IOException {
         makeSpace(aend - astart);
-        
+
         for (int i = astart; i < aend; i++) {
             value[end++] = csq.charAt(i);
         }
@@ -232,8 +232,8 @@ public class CBuffer extends CBucket implements Cloneable,
         append(Integer.toString(i));
         return this;
     }
-    
-    
+
+
     public Appendable append(CharSequence cs) {
         if (cs instanceof CBuffer) {
             CBuffer src = (CBuffer) cs;
@@ -253,7 +253,7 @@ public class CBuffer extends CBucket implements Cloneable,
         return  this;
     }
 
-    
+
     public CBuffer append(BBucket bb) {
         byte[] bbuf = bb.array();
         int start = bb.position();
@@ -270,7 +270,7 @@ public class CBuffer extends CBucket implements Cloneable,
         end += len;
         return this;
     }
-    
+
 
     public void toAscii(BBuffer bb) {
         for (int i = start; i < end; i++) {
@@ -280,7 +280,7 @@ public class CBuffer extends CBucket implements Cloneable,
 
     /**
      *  Append and advance CharBuffer.
-     * 
+     *
      * @param c
      */
     public CBuffer put(CharBuffer c) {
@@ -291,7 +291,7 @@ public class CBuffer extends CBucket implements Cloneable,
 
     // ------------- 'set' methods ---------------
     // equivalent with clean + append
-    
+
     public CBuffer set(CBuffer csq, int off, int len) {
         recycle();
         append(csq.value, csq.start + off, csq.start + off + len);
@@ -303,7 +303,7 @@ public class CBuffer extends CBucket implements Cloneable,
         append(c, off, off + len);
         return this;
     }
-    
+
     public CBuffer set(BBucket bb) {
         recycle();
         byte[] bbuf = bb.array();
@@ -329,12 +329,12 @@ public class CBuffer extends CBucket implements Cloneable,
         append(csq);
         return this;
     }
-    
+
     private void dirty() {
         hash = 0;
         strValue = null;
     }
-    
+
     /**
      * Make space for len chars. If len is small, allocate a reserve space too.
      * Never grow bigger than limit.
@@ -378,10 +378,10 @@ public class CBuffer extends CBucket implements Cloneable,
                 if (BBuffer.isUpper(c)) {
                     value[i] = (char) BBuffer.toLower(c);
                 }
-                
+
             }
         }
     }
 
-    
+
 }

==================================================
FastHttpDateFormat.java
index 744cbe1912..31529fe5ce 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/DumpChannel.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/DumpChannel.java
@@ -12,29 +12,29 @@ import java.io.OutputStream;
  * For debug - will print all bytes that go trough the channel
  */
 public class DumpChannel extends IOChannel {
-    
+
     IOBuffer in = new IOBuffer(this);
     IOBuffer out = new IOBuffer(this);
     static final boolean dumpToFile = false;
     static int idCnt = 0;
-    
+
     DumpChannel(String id) {
         this.id = id + idCnt++;
     }
-    
+
     public static IOChannel wrap(String id, IOChannel net) throws IOException {
-        if (id == null) { 
+        if (id == null) {
             id = "";
         }
         DumpChannel dmp = new DumpChannel(id + idCnt++);
         net.setHead(dmp);
         return dmp;
     }
-    
+
     public String toString() {
         return "Dump-" + id + "-" + net.toString();
     }
-    
+
     @Override
     public void handleReceived(IOChannel ch) throws IOException {
         processInput(ch.getIn());
@@ -71,7 +71,7 @@ public class DumpChannel extends IOChannel {
                     out("OUT", first, true);
                     net.getOut().close();
                 }
-                
+
                 net.startSending();
                 return;
             }
@@ -80,22 +80,22 @@ public class DumpChannel extends IOChannel {
             net.getOut().queue(first);
         }
     }
-    
+
     static int did = 0;
-    
+
     protected void out(String dir, BBucket first, boolean closed) {
         // Dump
         if (first != null) {
-            String hd = Hex.getHexDump(first.array(), first.position(), 
+            String hd = Hex.getHexDump(first.array(), first.position(),
                     first.remaining(), true);
             System.err.println("\n" + dir + ": " + id + " " +
                     (closed ? "CLS" : "") +
-                    + first.remaining() + "\n" + 
+                    + first.remaining() + "\n" +
                     hd);
         } else {
             System.err.println("\n" + dir + ": " + id + " " +
                     (closed ? "CLS " : "") +
-                     "END\n"); 
+                     "END\n");
         }
         if (dumpToFile && first != null) {
             try {
@@ -104,10 +104,10 @@ public class DumpChannel extends IOChannel {
                 os.close();
             } catch (IOException e) {
                 e.printStackTrace();
-            } 
+            }
         }
     }
-    
+
     @Override
     public IOBuffer getIn() {
         return in;

==================================================
FileConnector.java
index 568176789a..f74b9b5340 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/FastHttpDateFormat.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/FastHttpDateFormat.java
@@ -27,7 +27,7 @@ import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * Utility class to generate HTTP dates.
- * 
+ *
  * @author Remy Maucherat
  */
 public final class FastHttpDateFormat {
@@ -36,14 +36,14 @@ public final class FastHttpDateFormat {
     // -------------------------------------------------------------- Variables
 
 
-    protected static final int CACHE_SIZE = 
+    protected static final int CACHE_SIZE =
         Integer.parseInt(System.getProperty("org.apache.tomcat.util.http.FastHttpDateFormat.CACHE_SIZE", "1000"));
 
-    
+
     /**
      * HTTP date format.
      */
-    protected static final SimpleDateFormat format = 
+    protected static final SimpleDateFormat format =
         new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
 
 
@@ -89,14 +89,14 @@ public final class FastHttpDateFormat {
     /**
      * Formatter cache.
      */
-    protected static final ConcurrentHashMap<Long, String> formatCache = 
+    protected static final ConcurrentHashMap<Long, String> formatCache =
         new ConcurrentHashMap<Long, String>(CACHE_SIZE);
 
 
     /**
      * Parser cache.
      */
-    protected static final ConcurrentHashMap<String, Long> parseCache = 
+    protected static final ConcurrentHashMap<String, Long> parseCache =
         new ConcurrentHashMap<String, Long>(CACHE_SIZE);
 
 
@@ -154,7 +154,7 @@ public final class FastHttpDateFormat {
     /**
      * Try to parse the given date as a HTTP date.
      */
-    public static final long parseDate(String value, 
+    public static final long parseDate(String value,
                                        DateFormat[] threadLocalformats) {
 
         Long cachedDate = parseCache.get(value);

==================================================
FileConnectorJavaIo.java
index 5fb452524f..f4dd93b620 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/FileConnector.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/FileConnector.java
@@ -4,12 +4,12 @@ package org.apache.tomcat.lite.io;
 
 
 /**
- * Initial abstraction for non-blocking File access and to 
- * support other abstraction. 
- * 
+ * Initial abstraction for non-blocking File access and to
+ * support other abstraction.
+ *
  * Tomcat uses JNDI - but that's blocking, does lots of data copy,
  * is complex.
- * 
+ *
  * Work in progress..
  */
 public abstract class FileConnector extends IOConnector {
@@ -18,9 +18,9 @@ public abstract class FileConnector extends IOConnector {
         String type;
         int mode;
         long size;
-        
+
     }
-    
+
     public abstract boolean isDirectory(String path);
 
     public abstract boolean isFile(String path);

==================================================
FutureCallbacks.java
index 2b6de3b306..082c025e1f 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/FileConnectorJavaIo.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/FileConnectorJavaIo.java
@@ -8,15 +8,15 @@ import java.io.IOException;
 
 /**
  * Catalina uses JNDI to abstract filesystem - this is both heavy and
- * a bit complex. 
- * 
- * This is also a bit complex - but hopefully we can implement it as 
+ * a bit complex.
+ *
+ * This is also a bit complex - but hopefully we can implement it as
  * non-blocking and without much copy.
- * 
+ *
  */
 public class FileConnectorJavaIo extends FileConnector {
     File base;
-    
+
     public FileConnectorJavaIo(File file) {
         this.base = file;
     }
@@ -34,11 +34,11 @@ public class FileConnectorJavaIo extends FileConnector {
     }
 
     @Override
-    public void acceptor(ConnectedCallback sc, 
-            CharSequence port, 
+    public void acceptor(ConnectedCallback sc,
+            CharSequence port,
             Object extra) throws IOException {
         // TODO: unix domain socket impl.
-        // Maybe: detect new files in the filesystem ? 
+        // Maybe: detect new files in the filesystem ?
     }
 
     @Override

==================================================
Hex.java
index fd3b4be4f7..782228c28d 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/FutureCallbacks.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/FutureCallbacks.java
@@ -15,37 +15,37 @@ import java.util.concurrent.locks.AbstractQueuedSynchronizer;
 
 /**
  * Support for blocking calls and callbacks.
- * 
- * Unlike FutureTask, it is possible to reuse this and hopefully 
- * easier to extends. Also has callbacks.  
- * 
+ *
+ * Unlike FutureTask, it is possible to reuse this and hopefully
+ * easier to extends. Also has callbacks.
+ *
  * @author Costin Manolache
  */
 public class FutureCallbacks<V> implements Future<V> {
 
-    // Other options: ReentrantLock uses AbstractQueueSynchronizer, 
+    // Other options: ReentrantLock uses AbstractQueueSynchronizer,
     // more complex. Same for CountDownLatch
     // FutureTask - uses Sync as well, ugly interface with
     // Callable, can't be recycled.
     // Mina: simple object lock, doesn't extend java.util.concurent.Future
-    
-    private Sync sync = new Sync(); 
+
+    private Sync sync = new Sync();
 
     private V value;
 
     public static interface Callback<V> {
         public void run(V param);
     }
-    
+
     private List<Callback<V>> callbacks = new ArrayList();
-    
+
     public FutureCallbacks() {
     }
 
-    /** 
+    /**
      * Unlocks the object if it was locked. Should be called
      * when the object is reused.
-     * 
+     *
      * Callbacks will not be invoked.
      */
     public void reset() {
@@ -58,23 +58,23 @@ public class FutureCallbacks<V> implements Future<V> {
         sync.releaseShared(0);
         sync.reset();
     }
-    
+
     /**
      * Unlocks object and calls the callbacks.
-     * @param v 
-     * 
+     * @param v
+     *
      * @throws IOException
      */
     public void signal(V v) throws IOException {
         sync.releaseShared(0);
         onSignal(v);
     }
-    
+
     protected boolean isSignaled() {
         return true;
     }
-    
-    /** 
+
+    /**
      * Override to call specific callbacks
      */
     protected void onSignal(V v) {
@@ -88,9 +88,9 @@ public class FutureCallbacks<V> implements Future<V> {
     /**
      * Set the response. Will cause the callback to be called and lock to be
      * released.
-     * 
+     *
      * @param value
-     * @throws IOException 
+     * @throws IOException
      */
     public void setValue(V value) throws IOException {
         synchronized (this) {
@@ -108,7 +108,7 @@ public class FutureCallbacks<V> implements Future<V> {
             throw new WrappedException(e1);
         } catch (ExecutionException e) {
             throw new WrappedException(e);
-        }                
+        }
     }
 
     @Override
@@ -143,12 +143,12 @@ public class FutureCallbacks<V> implements Future<V> {
     }
 
     private class Sync extends AbstractQueuedSynchronizer {
-        
+
         static final int DONE = 1;
         static final int BLOCKED = 0;
         Object result;
         Throwable t;
-        
+
         @Override
         protected int tryAcquireShared(int ignore) {
             return getState() == DONE ? 1 : -1;
@@ -157,15 +157,15 @@ public class FutureCallbacks<V> implements Future<V> {
         @Override
         protected boolean tryReleaseShared(int ignore) {
             setState(DONE);
-            return true; 
+            return true;
         }
 
         public void reset() {
             setState(BLOCKED);
         }
-        
+
         boolean isSignaled() {
             return getState() == DONE;
         }
-    }    
+    }
 }

==================================================
IOBuffer.java
index 832b81375a..78a5fe27db 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/Hex.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/Hex.java
@@ -58,9 +58,9 @@ public final class Hex {
     /**
      * Table for DEC to HEX byte translation.
      */
-    public static final byte[] HEX = 
-    { (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5', 
-      (byte) '6', (byte) '7', (byte) '8', (byte) '9', (byte) 'a', (byte) 'b', 
+    public static final byte[] HEX =
+    { (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5',
+      (byte) '6', (byte) '7', (byte) '8', (byte) '9', (byte) 'a', (byte) 'b',
       (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f' };
 
 
@@ -129,7 +129,7 @@ public final class Hex {
 
     }
 
-    
+
     /**
      * Convert 4 hex digits to an int, and return the number of converted
      * bytes.
@@ -141,7 +141,7 @@ public final class Hex {
      */
     public static int convert2Int( byte[] hex ) {
 	// Code from Ajp11, from Apache's JServ
-    
+
 	// assert b.length==4
 	// assert valid data
 	int len;
@@ -167,7 +167,7 @@ public final class Hex {
 
 
     /**
-     * Provide a mechanism for ensuring this class is loaded. 
+     * Provide a mechanism for ensuring this class is loaded.
      */
     public static void load() {
         // Nothing to do
@@ -192,13 +192,13 @@ public final class Hex {
     /**
      * <code>getHexValue</code> displays a formatted hex
      * representation of the passed byte array.  It also
-     * allows for only a specified offset and length of 
+     * allows for only a specified offset and length of
      * a particular array to be returned.
      *
      * @param bytes <code>byte[]</code> array to process.
      * @param pos offset to begin processing.
      * @param len number of bytes to process.
-     * @return <code>String</code> formatted hex representation of processed 
+     * @return <code>String</code> formatted hex representation of processed
      *         array.
      */
     public static String getHexDump(byte[] bytes, int pos, int len,
@@ -208,11 +208,11 @@ public final class Hex {
         for (int j = 0; j < len; j += 16) {
             hexLine(out, bytes, pos + j, pos + len, displayOffset);
         }
-     
+
         return out.toString();
     }
-    
-    private static void hexLine(StringBuffer out, 
+
+    private static void hexLine(StringBuffer out,
                                 byte[] bytes, int start, int end,
                                 boolean displayOffset) {
 
@@ -229,13 +229,13 @@ public final class Hex {
                 out.append(convertDigit((int) (bytes[i] >> 4)));
                 out.append(convertDigit(bytes[i] & 0x0F));
                 out.append(" ");
-            } else { 
+            } else {
                 out.append("   ");
             }
         }
-        
+
         out.append(" | ");
-        
+
         for (int i = start; i < start + 16 && i < end; i++) {
             if( ! Character.isISOControl( (char)bytes[i] )) {
                 out.append( new Character((char)bytes[i]) );
@@ -243,7 +243,7 @@ public final class Hex {
                 out.append( "." );
             }
         }
-        
+
         out.append("\n");
     }
 }

==================================================
IOChannel.java
index 70e7795433..04ac2688b4 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOBuffer.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOBuffer.java
@@ -10,26 +10,26 @@ import java.util.logging.Logger;
 
 
 // TODO: append() will trigger callbacks - do it explicitely !!!
-// TODO: queue() shouldn't modify the buffer 
+// TODO: queue() shouldn't modify the buffer
 
 
-/** 
+/**
  * A list of data buckets.
- * 
+ *
  * @author Costin Manolache
  */
 public class IOBuffer {
     static Logger log = Logger.getLogger("IOBrigade");
-    
+
     static int ALLOC_SIZE = 8192;
     long defaultTimeout = Long.MAX_VALUE;
-    
+
     private LinkedList<BBucket> buffers = new LinkedList<BBucket>();
-    
+
     // close() has been called for out,
     // or EOF/FIN received for in. It may still have data.
-    boolean closeQueued; 
-    
+    boolean closeQueued;
+
     // Will be signalled (open) when there is data in the buffer.
     // also used to sync on.
     FutureCallbacks<IOBuffer> hasDataLock = new FutureCallbacks<IOBuffer>() {
@@ -40,41 +40,41 @@ public class IOBuffer {
 
     // may be null
     protected IOChannel ch;
-    
+
     // Support for appending - needs improvements.
-    // appendable buffer is part of the buffer list if it has 
+    // appendable buffer is part of the buffer list if it has
     // data, and kept here if empty.
     BBuffer appendable;
     boolean appending = false;
     ByteBuffer writeBuffer;
-    
+
 
     public IOBuffer() {
     }
-    
+
     public IOBuffer(IOChannel ch) {
         this.ch = ch;
     }
-    
+
     public IOChannel getChannel() {
         return ch;
     }
-    
+
     // ===== Buffer access =====
-    
-    
+
+
     /**
      * Return first non-empty buffer.
-     * 
+     *
      * The append buffer is part of the buffer list, and is left alone and
      * empty.
-     * 
+     *
      * @return
      */
     public BBucket peekFirst() {
         synchronized (buffers) {
             BBucket o = (buffers.size() == 0) ? null : buffers.getFirst();
-            
+
             while (true) {
                 boolean empty = o == null || isEmpty(o);
                 if (o == null) {
@@ -84,20 +84,20 @@ public class IOBuffer {
                 // o != null
                 if (empty) {
                     buffers.removeFirst();
-                    o = (buffers.size() == 0) ? null : buffers.getFirst();                    
+                    o = (buffers.size() == 0) ? null : buffers.getFirst();
                 } else {
                     return o;
                 }
             }
         }
     }
-    
+
     public BBucket peekBucket(int idx) {
         synchronized (buffers) {
             return buffers.get(idx);
         }
     }
-    
+
 
     public void advance(int len) {
         while (len > 0) {
@@ -109,7 +109,7 @@ public class IOBuffer {
                 len -= first.remaining();
                 first.position(first.limit());
             } else {
-                first.position(first.position() + len);                
+                first.position(first.position() + len);
                 len = 0;
             }
         }
@@ -120,15 +120,15 @@ public class IOBuffer {
         byte[] bytes = s.getBytes("UTF8");
         queueInternal(BBuffer.wrapper(bytes, 0, bytes.length));
     }
-    
+
     public void queue(BBuffer bc) throws IOException {
         queueInternal(bc);
     }
-    
+
     public void queue(Object bb) throws IOException {
         queueInternal(bb);
     }
-    
+
     private void queueInternal(Object bb) throws IOException {
         if (closeQueued) {
             throw new IOException("Closed");
@@ -143,22 +143,22 @@ public class IOBuffer {
             //log.info("QUEUED: " + add.remaining() + " " + this);
             notifyDataAvailable(add);
         }
-        
+
     }
-    
+
     public int getBufferCount() {
         peekFirst();
         synchronized (buffers) {
             return buffers.size();
         }
     }
-    
+
     public void clear() {
         synchronized (buffers) {
             buffers.clear();
         }
     }
-    
+
     public void recycle() {
         closeQueued = false;
         clear();
@@ -168,7 +168,7 @@ public class IOBuffer {
         appending = false;
         appendable = null;
     }
-    
+
     // ===================
     /**
      * Closed for append. It may still have data.
@@ -178,8 +178,8 @@ public class IOBuffer {
         return closeQueued && 0 == getBufferCount();
     }
 
-    
-    /** 
+
+    /**
      * Mark as closed - but will not send data.
      */
     public void close() throws IOException {
@@ -189,16 +189,16 @@ public class IOBuffer {
         closeQueued = true;
         notifyDataAvailable(null);
     }
-    
-    
+
+
     private boolean isEmpty(BBucket o) {
-        if (o instanceof BBucket && 
+        if (o instanceof BBucket &&
                 ((BBucket) o).remaining() == 0) {
             return true;
-        }        
+        }
         return false;
     }
-    
+
     private BBucket wrap(Object src) {
         if (src instanceof byte[]) {
             return BBuffer.wrapper((byte[]) src, 0, ((byte[]) src).length);
@@ -206,26 +206,26 @@ public class IOBuffer {
         if (src instanceof ByteBuffer) {
             //return src;
             ByteBuffer bb = (ByteBuffer) src;
-            return BBuffer.wrapper(bb.array(), bb.position(), 
-                        bb.remaining());            
+            return BBuffer.wrapper(bb.array(), bb.position(),
+                        bb.remaining());
         }
         if (src instanceof byte[]) {
             byte[] bb = (byte[]) src;
-            return BBuffer.wrapper(bb, 0, bb.length); 
+            return BBuffer.wrapper(bb, 0, bb.length);
         }
         return (BBucket) src;
     }
-    
+
     protected void notifyDataAvailable(Object bb) throws IOException {
         synchronized (hasDataLock) {
             hasDataLock.signal(this); // or bb ?
         }
     }
-    
+
     public boolean hasData() {
-        return closeQueued || peekFirst() != null; 
+        return closeQueued || peekFirst() != null;
     }
-    
+
     public void waitData(long timeMs) throws IOException {
         if (timeMs == 0) {
             timeMs = defaultTimeout;
@@ -248,7 +248,7 @@ public class IOBuffer {
 
     /**
      * Non-blocking read.
-     * 
+     *
      * @return -1 if EOF, -2 if no data available, or 0..255 for normal read.
      */
     public int read() throws IOException {
@@ -263,7 +263,7 @@ public class IOBuffer {
         bucket.position(bucket.position() + 1);
         return res & 0xFF;
     }
-    
+
     public int peek() throws IOException {
         BBucket bucket = peekFirst();
         if (bucket == null) {
@@ -272,7 +272,7 @@ public class IOBuffer {
         int res = bucket.array()[bucket.position()];
         return res;
     }
-    
+
     public int find(char c) {
         int pos = 0;
         for (int i = 0; i < buffers.size(); i++) {
@@ -283,20 +283,20 @@ public class IOBuffer {
             int found= BBuffer.findChar(bucket.array(), bucket.position(),
                     bucket.limit(), c);
             if (found >= 0) {
-                return pos + found; 
+                return pos + found;
             }
             pos += bucket.remaining();
         }
         return -1;
     }
-    
+
     public int readLine(BBuffer bc) throws IOException {
         return readToDelim(bc, '\n');
     }
-    
+
     /**
-     * Copy up to and including "delim". 
-     * 
+     * Copy up to and including "delim".
+     *
      * @return number of bytes read, or -1 for end of stream.
      */
     int readToDelim(BBuffer bc, int delim) throws IOException {
@@ -314,7 +314,7 @@ public class IOBuffer {
                 bc.put(chr);
                 if (chr == delim) {
                     bucket.position(i + 1);
-                    len += (i - start + 1); 
+                    len += (i - start + 1);
                     return len;
                 }
             }
@@ -325,8 +325,8 @@ public class IOBuffer {
         }
         return len;
     }
-    
-    
+
+
     public int write(ByteBuffer bb) throws IOException {
         int len = bb.remaining();
         int pos = bb.position();
@@ -337,7 +337,7 @@ public class IOBuffer {
         bb.position(pos + len);
         return len;
     }
-    
+
     public int read(byte[] buf, int off, int len) throws IOException {
         if (isClosedAndEmpty()) {
             return -1;
@@ -349,7 +349,7 @@ public class IOBuffer {
                 return rd;
             }
             int toCopy = Math.min(len, bucket.remaining());
-            System.arraycopy(bucket.array(), bucket.position(), 
+            System.arraycopy(bucket.array(), bucket.position(),
                     buf, off + rd, toCopy);
             bucket.position(bucket.position() + toCopy);
             rd += toCopy;
@@ -358,7 +358,7 @@ public class IOBuffer {
                 return rd;
             }
         }
-        
+
     }
 
     public int read(BBuffer bb, int len) throws IOException {
@@ -370,7 +370,7 @@ public class IOBuffer {
         bb.limit(bb.limit() + rd);
         return rd;
     }
-    
+
     /**
      * Non-blocking read.
      */
@@ -397,9 +397,9 @@ public class IOBuffer {
             iob.position(iob.position() + space);
             iob.release();
             len += space;
-        }        
+        }
     }
-    
+
 
     public BBuffer readAll(BBuffer chunk) throws IOException {
         if (chunk == null) {
@@ -417,13 +417,13 @@ public class IOBuffer {
             chunk.append(iob.array(), iob.position(), iob.remaining());
             iob.position(iob.position() + iob.remaining());
             iob.release();
-    
+
         }
     }
 
     private BBuffer allocate() {
         int size = 0;
-        for (int i = 0; i < getBufferCount(); i++) { 
+        for (int i = 0; i < getBufferCount(); i++) {
             BBucket first = peekBucket(i);
             if (first != null) {
                 size += first.remaining();
@@ -431,12 +431,12 @@ public class IOBuffer {
         }
         return BBuffer.allocate(size);
     }
-    
+
     public BBuffer copyAll(BBuffer chunk) throws IOException {
         if (chunk == null) {
             chunk = allocate();
         }
-        for (int i = 0; i < getBufferCount(); i++) { 
+        for (int i = 0; i < getBufferCount(); i++) {
             BBucket iob = peekBucket(i);
             chunk.append(iob.array(), iob.position(), iob.remaining());
         }
@@ -462,20 +462,20 @@ public class IOBuffer {
     public IOBuffer append(byte[] data) throws IOException {
         return append(data, 0, data.length);
     }
-    
+
     public IOBuffer append(byte[] data, int start, int len) throws IOException {
         if (closeQueued) {
             throw new IOException("Closed");
         }
         ByteBuffer bb = getWriteBuffer();
-        
+
         int i = start;
         int end = start + len;
         while (i < end) {
-            int rem = Math.min(end - i, bb.remaining()); 
+            int rem = Math.min(end - i, bb.remaining());
             // to write
             bb.put(data, i, rem);
-            i += rem; 
+            i += rem;
             if (bb.remaining() < 8) {
                 releaseWriteBuffer(1);
                 bb = getWriteBuffer();
@@ -483,9 +483,9 @@ public class IOBuffer {
         }
 
         releaseWriteBuffer(1);
-        return this;        
+        return this;
     }
-    
+
     public IOBuffer append(int data) throws IOException {
         if (closeQueued) {
             throw new IOException("Closed");
@@ -493,14 +493,14 @@ public class IOBuffer {
         ByteBuffer bb = getWriteBuffer();
         bb.put((byte) data);
         releaseWriteBuffer(1);
-        return this;        
+        return this;
     }
-    
+
     public IOBuffer append(ByteBuffer cs) throws IOException {
-        return append(cs.array(), cs.position() + cs.arrayOffset(), 
+        return append(cs.array(), cs.position() + cs.arrayOffset(),
                 cs.remaining());
     }
-    
+
     /**
      *  Append a buffer. The buffer will not be modified.
      */
@@ -523,7 +523,7 @@ public class IOBuffer {
             append(o);
         }
 
-        return this;        
+        return this;
     }
 
     public IOBuffer append(IOBuffer cs, int len) throws IOException {
@@ -532,9 +532,9 @@ public class IOBuffer {
             append(o);
         }
 
-        return this;        
+        return this;
     }
-    
+
     public IOBuffer append(CharSequence cs) throws IOException {
         byte[] data = cs.toString().getBytes();
         append(data, 0, data.length);
@@ -545,11 +545,11 @@ public class IOBuffer {
         ByteBuffer bb = getWriteBuffer();
         bb.put((byte) c);
         releaseWriteBuffer(1);
-        return this;        
+        return this;
     }
-    
+
     /**
-     * All operations that iterate over buffers must be 
+     * All operations that iterate over buffers must be
      * sync
      * @return
      */
@@ -561,7 +561,7 @@ public class IOBuffer {
         }
         return a;
     }
-    
+
     public String toString() {
         return "IOB:{c:" + getBufferCount() +
           ", b:" + available() +
@@ -578,7 +578,7 @@ public class IOBuffer {
         o.position(o.position() + lenToConsume);
         return sb;
     }
-    
+
     public BBucket popFirst() {
         BBucket o = peekFirst(); // skip empty
         if (o == null) {
@@ -587,9 +587,9 @@ public class IOBuffer {
         if (o == appendable) {
             synchronized (buffers) {
                     // TODO: concurrency ???
-                    BBucket sb = 
+                    BBucket sb =
                         BBuffer.wrapper(appendable.array(),
-                                appendable.position(), 
+                                appendable.position(),
                                 appendable.limit() - appendable.position());
                     appendable.position(appendable.limit());
                     return sb;
@@ -599,22 +599,22 @@ public class IOBuffer {
         }
         return o;
     }
-    
+
 
     public ByteBuffer getWriteBuffer() throws IOException {
         synchronized (buffers) {
             if (closeQueued) {
                 throw new IOException("Closed");
             }
-            BBucket last = (buffers.size() == 0) ? 
+            BBucket last = (buffers.size() == 0) ?
                     null : buffers.getLast();
             if (last == null || last != appendable ||
                     last.array().length - last.limit() < 16) {
                 last = BBuffer.allocate(ALLOC_SIZE);
             }
             appending = true;
-            appendable = (BBuffer) last;            
-            
+            appendable = (BBuffer) last;
+
             if (writeBuffer == null || writeBuffer.array() != appendable.array()) {
                 writeBuffer = ByteBuffer.wrap(appendable.array());
             }
@@ -622,8 +622,8 @@ public class IOBuffer {
             writeBuffer.limit(appendable.array().length);
             return writeBuffer;
         }
-    }        
-    
+    }
+
     public void releaseWriteBuffer(int read) throws IOException {
         synchronized (buffers) {
             if (!appending) {
@@ -633,11 +633,11 @@ public class IOBuffer {
                 if (appendable.limit() != writeBuffer.position()) {
                     appendable.limit(writeBuffer.position());
                     // We have some more data.
-                    if (buffers.size() == 0 || 
+                    if (buffers.size() == 0 ||
                             buffers.getLast() != appendable) {
                         buffers.add(appendable);
                     }
-                    notifyDataAvailable(appendable);                
+                    notifyDataAvailable(appendable);
                 }
             }
             appending = false;
@@ -659,7 +659,7 @@ public class IOBuffer {
 //}
 
 //public final int readToDelimAndLowerCase(ByteBuffer bb,
-//                                         byte delim, 
+//                                         byte delim,
 //                                         boolean lower) {
 //  boolean space = false;
 //  byte chr = 0;
@@ -672,7 +672,7 @@ public class IOBuffer {
 //      space = true;
 //    }
 //    if (lower && (chr >= HttpParser.A) && (chr <= HttpParser.Z)) {
-//      bb.put(bb.position() - 1, 
+//      bb.put(bb.position() - 1,
 //          (byte) (chr - HttpParser.LC_OFFSET));
 //    }
 //  }

==================================================
IOConnector.java
index f3ccb4c671..a7db4dfa18 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOChannel.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOChannel.java
@@ -9,42 +9,42 @@ import java.nio.channels.ByteChannel;
 
 
 /**
- * Buffered, non-blocking ByteChannel.  
- * 
- * write() data will be added to the buffer. Call startSending() to 
- * flush. 
- * 
- *  
- * 
+ * Buffered, non-blocking ByteChannel.
+ *
+ * write() data will be added to the buffer. Call startSending() to
+ * flush.
+ *
+ *
+ *
  * - you can use it as a normal non-blocking ByteChannel.
  * - you can call getRead
- * 
+ *
  * Very different from MINA IoFilters, also much lower level.
- * 
- * 
+ *
+ *
  * @author Costin Manolache
  */
-public abstract class IOChannel implements ByteChannel, IOConnector.DataReceivedCallback, 
-        IOConnector.DataFlushedCallback {  
-    
+public abstract class IOChannel implements ByteChannel, IOConnector.DataReceivedCallback,
+        IOConnector.DataFlushedCallback {
+
     /**
      * If this channel wraps another channel - for example a socket.
      * Will be null if this is the 'root' channel - a socket, memory.
      */
     protected IOChannel net;
-    
-    /** 
+
+    /**
      * Set with another channel layered on top of the current channel.
      */
     protected IOChannel head;
-    
+
     protected String id;
-    
+
     /**
      * A string that can be parsed to extract the target.
      * host:port for normal sockets
      */
-    protected CharSequence target;    
+    protected CharSequence target;
 
     /**
      * Connector that created the channel.
@@ -55,16 +55,16 @@ public abstract class IOChannel implements ByteChannel, IOConnector.DataReceived
      * Callbacks. Will be moved if a new head is inserted.
      */
     protected IOConnector.ConnectedCallback connectedCallback;
-    
-    /** 
+
+    /**
      * Will be called if any data is received.
      * Will also be called on close. Close with lastException set indicates
      * an error condition.
      */
     protected IOConnector.DataReceivedCallback dataReceivedCallback;
-    
+
     /**
-     * Out data is buffered, then sent with startSending. 
+     * Out data is buffered, then sent with startSending.
      * This callback indicates the data has been sent. Can be used
      * to implement blocking flush.
      */
@@ -73,15 +73,15 @@ public abstract class IOChannel implements ByteChannel, IOConnector.DataReceived
     // Last activity timestamp.
     // TODO: update and use it ( placeholder )
     public long ts;
-    
+
     /**
-     * If an async exception happens. 
+     * If an async exception happens.
      */
     protected Throwable lastException;
-    
+
     protected IOChannel() {
     }
-    
+
     public void setConnectedCallback(IOConnector.ConnectedCallback connectedCallback) {
         this.connectedCallback = connectedCallback;
     }
@@ -92,7 +92,7 @@ public abstract class IOChannel implements ByteChannel, IOConnector.DataReceived
 
     /**
      * Callback called when the bottom ( OS ) channel has finished flushing.
-     * 
+     *
      * @param dataFlushedCallback
      */
     public void setDataFlushedCallback(IOConnector.DataFlushedCallback dataFlushedCallback) {
@@ -102,31 +102,31 @@ public abstract class IOChannel implements ByteChannel, IOConnector.DataReceived
     // Input
     public abstract IOBuffer getIn();
 
-    // Output 
+    // Output
     public abstract IOBuffer getOut();
-    
-    
-    /** 
+
+
+    /**
      * From downstream ( NET ). Pass it to the next channel.
      */
     public void handleReceived(IOChannel net) throws IOException {
         sendHandleReceivedCallback();
     }
-    
-    /** 
-     * Called from lower layer (NET) when the last flush is 
-     * done and all buffers have been sent to OS ( or 
+
+    /**
+     * Called from lower layer (NET) when the last flush is
+     * done and all buffers have been sent to OS ( or
      * intended recipient ).
-     * 
+     *
      * Will call the callback or next filter, may do additional
      * processing.
-     * 
+     *
      * @throws IOException
      */
     public void handleFlushed(IOChannel net) throws IOException {
         sendHandleFlushedCallback();
     }
-    
+
     private void sendHandleFlushedCallback() throws IOException {
         try {
             if (dataFlushedCallback != null) {
@@ -142,15 +142,15 @@ public abstract class IOChannel implements ByteChannel, IOConnector.DataReceived
             } else {
                 throw new WrappedException("Error in handleFlushed", t);
             }
-        } 
+        }
     }
-    
-    
+
+
     /**
      * Notify next channel or callback that data has been received.
      * Called after a lower channel gets more data ( in the IOThread
      * for example ).
-     * 
+     *
      * Also called when closed stream is detected. Can be called
      * to just force upper layers to check for data.
      */
@@ -174,24 +174,24 @@ public abstract class IOChannel implements ByteChannel, IOConnector.DataReceived
             } else {
                 throw new WrappedException(t);
             }
-        } 
+        }
     }
 
-    /** 
-     * Return last IO exception. 
-     * 
-     * The channel is async, exceptions can happen at any time. 
-     * The normal callback will be called ( connected, received ), it 
+    /**
+     * Return last IO exception.
+     *
+     * The channel is async, exceptions can happen at any time.
+     * The normal callback will be called ( connected, received ), it
      * should check if the channel is closed and the exception.
      */
     public Throwable lastException() {
         return lastException;
     }
-    
+
     public void close() throws IOException {
         shutdownOutput();
-        // Should it read the buffers ? 
-        
+        // Should it read the buffers ?
+
         if (getIn() == null || getIn().isAppendClosed()) {
             return;
         } else {
@@ -202,11 +202,11 @@ public abstract class IOChannel implements ByteChannel, IOConnector.DataReceived
     }
 
     public boolean isOpen() {
-        return getIn() != null && 
-        getOut() != null && 
+        return getIn() != null &&
+        getOut() != null &&
         !getIn().isAppendClosed() && !getOut().isAppendClosed();
     }
-    
+
     public void shutdownOutput() throws IOException {
         if (getOut() == null || getOut().isAppendClosed()) {
             return;
@@ -225,18 +225,18 @@ public abstract class IOChannel implements ByteChannel, IOConnector.DataReceived
     }
 
     // Chaining/filtering
-    
-    /** 
-     * Called to add an filter after the current channel, for 
+
+    /**
+     * Called to add an filter after the current channel, for
      * example set SSL on top of a socket channel.
-     * 
+     *
      * The 'next' channel will have the received/flushed callbacks
      * of the current channel. The current channel's callbacks will
      * be reset.
-     * 
+     *
      * "Head" is from STREAMS.
-     * 
-     * @throws IOException 
+     *
+     * @throws IOException
      */
     public IOChannel setHead(IOChannel head) throws IOException {
         this.head = head;
@@ -266,21 +266,21 @@ public abstract class IOChannel implements ByteChannel, IOConnector.DataReceived
             }
         }
     }
-    
+
     // Socket support
-    
+
     public void readInterest(boolean b) throws IOException {
         if (net != null) {
             net.readInterest(b);
         }
     }
-    
+
     // Helpers
 
     public int read(ByteBuffer bb) throws IOException {
         return getIn().read(bb);
     }
-    
+
     public int readNonBlocking(ByteBuffer bb) throws IOException {
         return getIn().read(bb);
     }
@@ -288,21 +288,21 @@ public abstract class IOChannel implements ByteChannel, IOConnector.DataReceived
     public void waitFlush(long timeMs) throws IOException {
         return;
     }
-    
+
     public int readBlocking(ByteBuffer bb, long timeMs) throws IOException {
         getIn().waitData(timeMs);
         return getIn().read(bb);
     }
-    
-    /** 
-     * Capture all output in a buffer. 
+
+    /**
+     * Capture all output in a buffer.
      */
-    public BBuffer readAll(BBuffer chunk, long to) 
+    public BBuffer readAll(BBuffer chunk, long to)
             throws IOException {
         if (chunk == null) {
             chunk = BBuffer.allocate();
         }
-        while (true) { 
+        while (true) {
             getIn().waitData(to);
             BBucket next = getIn().peekFirst();
             if (getIn().isClosedAndEmpty() && next == null) {
@@ -315,11 +315,11 @@ public abstract class IOChannel implements ByteChannel, IOConnector.DataReceived
             getIn().advance(next.remaining());
         }
     }
-    
+
     public int write(ByteBuffer bb) throws IOException {
         return getOut().write(bb);
     }
-    
+
     public void write(byte[] data) throws IOException {
         getOut().append(data, 0, data.length);
     }
@@ -327,29 +327,29 @@ public abstract class IOChannel implements ByteChannel, IOConnector.DataReceived
     public void write(String string) throws IOException {
         write(string.getBytes());
     }
-    
-    /** 
+
+    /**
      * Send data in out to the intended recipient.
      * This is not blocking.
      */
     public abstract void startSending() throws IOException;
 
-    
+
     public void setId(String id) {
         this.id = id;
     }
-    
+
     public String getId() {
         return id;
     }
-    
+
     public CharSequence getTarget() {
         if (net != null) {
             return net.getTarget();
         }
         return target;
     }
-    
+
     public void setTarget(CharSequence target) {
         this.target = target;
     }
@@ -360,12 +360,12 @@ public abstract class IOChannel implements ByteChannel, IOConnector.DataReceived
     public static final String ATT_LOCAL_PORT = "LocalPort";
     public static final String ATT_LOCAL_ADDRESS = "LocalAddress";
     public static final String ATT_REMOTE_ADDRESS = "RemoteAddress";
-    
+
     public Object getAttribute(String name) {
         if (net != null) {
             return net.getAttribute(name);
         }
-        return null;        
+        return null;
     }
-    
+
 }

==================================================
IOInputStream.java
index d8375f9ce9..43441462f9 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOConnector.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOConnector.java
@@ -8,23 +8,23 @@ import java.util.Timer;
 
 /**
  * Factory for IOChannels, with support for caching.
- * 
- * 
+ *
+ *
  * @author Costin Manolache
  */
 public abstract class IOConnector {
 
     public static interface DataReceivedCallback {
-        /** 
+        /**
          * Called when data or EOF has been received.
          */
         public void handleReceived(IOChannel ch) throws IOException;
     }
 
-    /** 
+    /**
      * Callback for accept and connect.
      *
-     * Will also be called if an error happens while connecting, in 
+     * Will also be called if an error happens while connecting, in
      * which case the connection will be closed.
      */
     public static interface ConnectedCallback {
@@ -36,28 +36,28 @@ public abstract class IOConnector {
     }
 
     protected Timer timer;
-    
+
     public Timer getTimer() {
         return timer;
     }
-    
+
     /**
      * If the connector is layered on top of a different connector,
-     * return the lower layer ( for example the socket connector) 
+     * return the lower layer ( for example the socket connector)
      */
     public IOConnector getNet() {
         return null;
     }
-    
-    public abstract void acceptor(IOConnector.ConnectedCallback sc, 
+
+    public abstract void acceptor(IOConnector.ConnectedCallback sc,
                          CharSequence port, Object extra)
-        throws IOException; 
-    
-    // TODO: failures ? 
+        throws IOException;
+
+    // TODO: failures ?
     // TODO: use String target or url
-    public abstract void connect(String host, int port, 
+    public abstract void connect(String host, int port,
             IOConnector.ConnectedCallback sc) throws IOException;
-    
+
     public void stop() {
         if (timer != null) {
             timer.cancel();

==================================================
IOOutputStream.java
index 3c167f1709..aebf5c573f 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOInputStream.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOInputStream.java
@@ -9,21 +9,21 @@ import java.io.InputStream;
 /**
  * Similar with ServletInputStream - adds readLine(byte[]..), using
  * a IOBuffer.
- * 
- * 
- * 
+ *
+ *
+ *
  * @author Costin Manolache
  */
 public class IOInputStream extends InputStream {
 
     IOBuffer bb;
     long timeout;
-    
+
     public IOInputStream(IOChannel httpCh, long to) {
         bb = httpCh.getIn();
         this.timeout = to;
     }
-    
+
     @Override
     public int read() throws IOException {
         // getReadableBucket/peekFirst returns a buffer with at least
@@ -35,10 +35,10 @@ public class IOInputStream extends InputStream {
         if (bb.isClosedAndEmpty()) {
             return -1;
         }
-        
+
         return bb.read();
     }
-    
+
     public int read(byte[] buf, int off, int len) throws IOException {
         if (bb.isClosedAndEmpty()) {
             return -1;

==================================================
IOReader.java
index 9b67b486c6..90a6e021f7 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOOutputStream.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOOutputStream.java
@@ -10,21 +10,21 @@ import java.text.MessageFormat;
 
 /**
  * Same methods with ServletOutputStream.
- * 
- * There is no restriction in using the Writer and InputStream at the 
- * same time - the servlet layer will impose it for compat. You can also use 
- * IOBuffer directly. 
- * 
+ *
+ * There is no restriction in using the Writer and InputStream at the
+ * same time - the servlet layer will impose it for compat. You can also use
+ * IOBuffer directly.
+ *
  * If you mix stream and writer:
  *  - call BufferWriter.push() to make sure all chars are sent down
- *  - the BufferOutputStream doesn't cache any data, all goes to the 
+ *  - the BufferOutputStream doesn't cache any data, all goes to the
  *   IOBuffer.
  *  - flush() on BufferOutputStream and BufferWriter will send the data
  *  to the network and block until it gets to the socket ( so it can
- *  throw exception ). 
+ *  throw exception ).
  *  - You can also use non-blocking flush methods in IOBuffer, and a
  *  callback  if you want to know when the write was completed.
- *    
+ *
  * @author Costin Manolache
  */
 public class IOOutputStream extends OutputStream {
@@ -32,9 +32,9 @@ public class IOOutputStream extends OutputStream {
     IOBuffer bb;
     IOChannel ch;
     int bufferSize = 8 * 1024;
-    
+
     int wSinceFlush = 0;
-    
+
     public IOOutputStream(IOBuffer out, IOChannel httpMessage) {
         this.bb = out;
         ch = httpMessage;
@@ -44,7 +44,7 @@ public class IOOutputStream extends OutputStream {
         wSinceFlush = 0;
         bufferSize = 8 * 1024;
     }
-    
+
     public void reset() {
         wSinceFlush = 0;
         bb.clear();
@@ -71,28 +71,28 @@ public class IOOutputStream extends OutputStream {
             flush();
         }
     }
-    
+
     @Override
     public void write(int b) throws IOException {
         bb.append((char) b);
         updateSize(1);
     }
-    
+
     @Override
     public void write(byte data[]) throws IOException {
       write(data, 0, data.length);
-    }    
+    }
 
     @Override
     public void write(byte data[], int start, int len) throws IOException {
         bb.append(data, start, len);
         updateSize(len);
-    }    
-    
+    }
+
     public void flush() throws IOException {
         if (ch != null) {
             ch.startSending();
-            
+
             ch.waitFlush(Long.MAX_VALUE);
         }
         wSinceFlush = 0;
@@ -102,13 +102,13 @@ public class IOOutputStream extends OutputStream {
         flush();
         bb.close();
     }
-    
+
 
     public void write(ByteBuffer source) throws IOException {
         write(source.array(), source.position(), source.remaining());
         source.position(source.limit());
     }
-    
+
     public void print(String s) throws IOException {
         if (s==null) s="null";
         int len = s.length();

==================================================
IOWriter.java
index 4d0fadedca..bbeacdc613 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOReader.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOReader.java
@@ -19,32 +19,32 @@ import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * Conversion from Bytes to Chars and support for decoding.
- * 
- * Replaces tomcat B2CConverter with NIO equivalent. B2CConverter was a hack 
- * (re)using an dummy InputStream backed by a ByteChunk. 
- * 
+ *
+ * Replaces tomcat B2CConverter with NIO equivalent. B2CConverter was a hack
+ * (re)using an dummy InputStream backed by a ByteChunk.
+ *
  * @author Costin Manolache
  */
 public class IOReader extends Reader {
-    
+
     IOBuffer iob;
     Map<String, CharsetDecoder> decoders = new HashMap<String, CharsetDecoder>();
     CharsetDecoder decoder;
-    
+
     private static boolean REUSE = true;
     String enc;
     private boolean closed;
     public static final String DEFAULT_ENCODING = "ISO-8859-1";
     long timeout = 0;
-    
+
     public IOReader(IOBuffer iob) {
         this.iob = iob;
     }
-    
+
     public void setTimeout(long to) {
         timeout = to;
     }
-    
+
     public void setEncoding(String charset) {
         enc = charset;
         if (enc == null) {
@@ -60,11 +60,11 @@ public class IOReader extends Reader {
             }
         }
     }
-    
+
     public String getEncoding() {
         return enc;
     }
-    
+
     public void recycle() {
         if (decoder != null) {
             decoder.reset();
@@ -72,11 +72,11 @@ public class IOReader extends Reader {
         closed = false;
         enc = null;
     }
-    
+
     private void checkClosed() throws IOException {
         if (closed) throw new IOException("closed");
     }
-    
+
     public boolean ready() {
         return iob.peekFirst() != null;
     }
@@ -97,14 +97,14 @@ public class IOReader extends Reader {
         else
             return cb[0];
     }
-    
+
     @Override
     public void close() throws IOException {
         closed = true;
         iob.close();
     }
-    
-    /** 
+
+    /**
      * Used if a bucket ends on a char boundary
      */
     BBuffer underFlowBuffer = BBuffer.allocate(10);
@@ -114,7 +114,7 @@ public class IOReader extends Reader {
      * Decode all bytes - for example a URL or header.
      */
     public void decodeAll(BBucket bb, CBuffer c) {
-        
+
         while (bb.hasRemaining()) {
             CharBuffer charBuffer = c.getAppendCharBuffer();
             CoderResult res = decode1(bb, charBuffer, true);
@@ -122,15 +122,15 @@ public class IOReader extends Reader {
             if (res != CoderResult.OVERFLOW) {
                 if (res == CoderResult.UNDERFLOW || bb.hasRemaining()) {
                     System.err.println("Ignored trailing bytes " + bb.remaining());
-                } 
+                }
                 return;
             }
         }
-        
+
     }
-    
-    /** 
-     * Do one decode pass.  
+
+    /**
+     * Do one decode pass.
      */
     public CoderResult decode1(BBucket bb, CharBuffer c, boolean eof) {
         ByteBuffer b = bb.getByteBuffer();
@@ -155,33 +155,33 @@ public class IOReader extends Reader {
                 		"10 bytes");
             }
         }
-        
+
         CoderResult res = decoder.decode(b, c, eof);
         bb.position(b.position());
-        
+
         if (res == CoderResult.UNDERFLOW && bb.hasRemaining()) {
             // b ends on a boundary
             underFlowBuffer.append(bb.array(), bb.position(), bb.remaining());
             bb.position(bb.limit());
-        } 
+        }
         return res;
     }
-    
+
     @Override
     public int read(char[] cbuf, int offset, int length) throws IOException {
         checkClosed();
         if (length == 0) {
             return 0;
         }
-        // we can either allocate a new CharBuffer or use a 
+        // we can either allocate a new CharBuffer or use a
         // static one and copy. Seems simpler this way - needs some
         // load test, but InputStreamReader seems to do the same.
         CharBuffer out = CharBuffer.wrap(cbuf, offset, length);
-        
+
         CoderResult result = CoderResult.UNDERFLOW;
 
         BBucket bucket = iob.peekFirst();
-        
+
         // Consume as much as possible without blocking
         while (result == CoderResult.UNDERFLOW) {
             // fill the buffer if needed
@@ -199,7 +199,7 @@ public class IOReader extends Reader {
                         break;
                     }
                 }
-                
+
                 if (bucket == null) {
                     // eof
                     break;
@@ -211,7 +211,7 @@ public class IOReader extends Reader {
 
         if (result == CoderResult.UNDERFLOW && iob.isClosedAndEmpty()) {
             // Flush out any remaining data
-            ByteBuffer bytes = bucket == null ? 
+            ByteBuffer bytes = bucket == null ?
                     underFlowBuffer.getByteBuffer() : bucket.getByteBuffer();
             result = decoder.decode(bytes, out, true);
             if (bucket == null) {

==================================================
MemoryIOConnector.java
index 2def8e8ba2..7d06cf16b9 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOWriter.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOWriter.java
@@ -15,32 +15,32 @@ import java.util.Map;
 
 /**
  * Converts chars to bytes, and associated encoding.
- * 
- * Replaces C2B from old tomcat. 
- * 
+ *
+ * Replaces C2B from old tomcat.
+ *
  * @author Costin Manolache
  */
 public class IOWriter extends Writer {
-    
+
     IOBuffer iob;
     Map<String, CharsetEncoder> encoders = new HashMap<String, CharsetEncoder>();
     CharsetEncoder encoder;
-    
+
     private static boolean REUSE = true;
     String enc;
     private boolean closed;
     IOChannel ioCh;
-    
+
     public IOWriter(IOChannel iob) {
         this.ioCh = iob;
         if (iob != null) {
             this.iob = iob.getOut();
         }
     }
-    
+
     public void setEncoding(String charset) {
         if (charset == null) {
-            charset = "UTF-8"; 
+            charset = "UTF-8";
         }
         enc = charset;
         encoder = getEncoder(charset);
@@ -53,10 +53,10 @@ public class IOWriter extends Writer {
             }
         }
     }
-    
+
     CharsetEncoder getEncoder(String charset) {
         if (charset == null) {
-            charset = "UTF-8"; 
+            charset = "UTF-8";
         }
         encoder = REUSE ? encoders.get(charset) : null;
         if (encoder == null) {
@@ -69,11 +69,11 @@ public class IOWriter extends Writer {
         }
         return encoder;
     }
-    
+
     public String getEncoding() {
         return enc;
     }
-    
+
     public void recycle() {
         if (encoder != null) {
             encoder.reset();
@@ -81,12 +81,12 @@ public class IOWriter extends Writer {
         closed = false;
         enc = null;
     }
-    
-    
+
+
     private void checkClosed() throws IOException {
         if (closed) throw new IOException("closed");
     }
-    
+
     @Override
     public void close() throws IOException {
         closed = true;
@@ -94,16 +94,16 @@ public class IOWriter extends Writer {
         ByteBuffer out = iob.getWriteBuffer();
         encoder.flush(out);
         iob.releaseWriteBuffer(1);
-        
+
         iob.close();
     }
-    
-    /** 
+
+    /**
      * Used if a bucket ends on a char boundary
      */
     CBuffer underFlowBuffer = CBuffer.newInstance();
 
-    public void encode1(CBuffer cc, 
+    public void encode1(CBuffer cc,
             BBuffer bb, CharsetEncoder encoder, boolean eof) {
         CharBuffer c = cc.getNioBuffer();
         ByteBuffer b = bb.getWriteByteBuffer(c.remaining() * 2);
@@ -112,41 +112,41 @@ public class IOWriter extends Writer {
         bb.limit(b.position());
     }
 
-    /** 
-     * 
+    /**
+     *
      * @param cc
      * @return
      */
-    public void encode1(CharBuffer c, 
+    public void encode1(CharBuffer c,
             ByteBuffer b, CharsetEncoder encoder, boolean eof) {
-        
+
         // TODO: buffer growth in caller
-        
+
         CoderResult res = encoder.encode(c, b, eof);
         if (res == CoderResult.OVERFLOW) {
-            // bb is full - next call will get a larger buffer ( it 
+            // bb is full - next call will get a larger buffer ( it
             // grows ) or maybe will be flushed.
         }
         if (res == CoderResult.UNDERFLOW && c.remaining() > 0 && !eof) {
             // TODO: if eof -> exception ?
             // cc has remaining chars - for example a surrogate start.
             underFlowBuffer.put(c);
-        } 
-        
+        }
+
     }
 
-    public void encodeAll(CBuffer cc, 
+    public void encodeAll(CBuffer cc,
             BBuffer bb, CharsetEncoder encoder, boolean eof) {
         while (cc.length() > 0) {
             encode1(cc, bb, encoder, eof);
         }
-    }    
+    }
 
-    public void encodeAll(CBuffer cc, 
+    public void encodeAll(CBuffer cc,
             BBuffer bb, String cs) {
         encodeAll(cc, bb, getEncoder(cs), true);
-    }    
-    
+    }
+
     @Override
     public void flush() throws IOException {
         if (ioCh != null) {
@@ -182,31 +182,31 @@ public class IOWriter extends Writer {
             return 4;
         }
 
-        
+
         return i;
     }
 
 
     /**
      * Just send the chars to the byte[], without flushing down.
-     * 
+     *
      * @throws IOException
      */
     public void push() throws IOException {
         // we don't cache here.
     }
-    
+
     @Override
     public void write(char[] cbuf, int off, int len) throws IOException {
         checkClosed();
         CharBuffer cb = CharBuffer.wrap(cbuf, off, len);
-        
+
         while (cb.remaining() > 0) {
             ByteBuffer wb = iob.getWriteBuffer();
             encode1(cb, wb, encoder, false);
             iob.releaseWriteBuffer(1);
         }
     }
-    
-    
+
+
 }

==================================================
NioChannel.java
index 5f6b50c01d..75fcc3b5a5 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/MemoryIOConnector.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/MemoryIOConnector.java
@@ -15,15 +15,15 @@ public class MemoryIOConnector extends IOConnector {
             }
         };
         IOBuffer netOut = new IOBuffer(this);
-        
+
         /**
          * All flushed output will be saved to 'out'.
          */
         public BBuffer out = BBuffer.allocate(4096);
-        
+
         public MemoryIOChannel() {
         }
-        
+
         public void startSending() throws IOException {
             //
             IOBuffer bb = netOut;
@@ -43,7 +43,7 @@ public class MemoryIOConnector extends IOConnector {
 
             handleFlushed(this);
         }
-        
+
         @Override
         public IOBuffer getIn() {
             return netIn;
@@ -52,23 +52,23 @@ public class MemoryIOConnector extends IOConnector {
         public IOBuffer getOut() {
             return netOut;
         }
-    } 
- 
+    }
+
     // TODO: in-process communication without sockets for testing
     ConnectedCallback acceptor;
     MemoryIOConnector server;
-    
+
     public MemoryIOConnector() {
         timer = new Timer(true);
     }
-    
+
     public MemoryIOConnector withServer(MemoryIOConnector server) {
         this.server = server;
         return server;
     }
-    
+
     @Override
-    public void acceptor(ConnectedCallback sc, CharSequence port, Object extra) 
+    public void acceptor(ConnectedCallback sc, CharSequence port, Object extra)
             throws IOException {
         this.acceptor = sc;
     }
@@ -84,5 +84,5 @@ public class MemoryIOConnector extends IOConnector {
         }
         sc.handleConnected(ch);
     }
-    
+
 }
\ No newline at end of file

==================================================
NioThread.java
index 559a9e5414..7cc1408658 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/NioChannel.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/NioChannel.java
@@ -7,45 +7,45 @@ import java.nio.channels.ByteChannel;
 import java.nio.channels.Channel;
 
 
-/** 
+/**
  * Wrapper around the real channel, with selector-specific info.
- * 
+ *
  * It is stored as an attachment in the selector.
  */
 public class NioChannel implements ByteChannel {
-    
+
     public static interface NioChannelCallback {
         public void handleConnected(NioChannel ch) throws IOException;
         public void handleClosed(NioChannel ch) throws IOException;
         public void handleReadable(NioChannel ch) throws IOException;
         public void handleWriteable(NioChannel ch) throws IOException;
-        
+
     }
-    
+
     NioChannel(NioThread sel) {
         this.sel = sel;
     }
 
     // APR long is wrapped in a ByteChannel as well - with few other longs.
     Channel channel;
-    
+
     // sync access.
     Object selKey;
 
     NioThread sel;
-    
-    /** 
+
+    /**
      * If != 0 - the callback will be notified closely after this time.
-     * Used for timeouts. 
+     * Used for timeouts.
      */
     long nextTimeEvent = 0;
-    
+
     // Callbacks
     Runnable timeEvent;
-    
+
     NioChannelCallback callback;
 
-    
+
     Throwable lastException;
 
     // True if the callback wants to be notified of read/write
@@ -54,23 +54,23 @@ public class NioChannel implements ByteChannel {
 
     // shutdownOutput has been called ?
     private boolean outClosed = false;
-    
+
     // read() returned -1 OR input buffer closed ( no longer interested )
     boolean inClosed = false;
-    
+
     // Saved to allow debug messages for bad interest/looping
     int lastReadResult;
     int zeroReads = 0;
     int lastWriteResult;
-    
+
     protected NioChannel() {
-        
+
     }
-    
+
     public NioThread getSelectorThread() {
         return sel;
     }
-    
+
     public String toString() {
         StringBuffer sb = new StringBuffer();
         sb.append("SelData/")
@@ -80,19 +80,19 @@ public class NioChannel implements ByteChannel {
         .append(inClosed ? "In-CLOSE/" : "")
         .append("/")
         .append(channel.toString());
-        
+
         return sb.toString();
     }
-    
+
     public Channel getChannel() {
         return channel;
     }
-    
+
     public boolean isOpen() {
         // in and out open
         return channel.isOpen() && !outClosed && !inClosed;
     }
-    
+
     public int read(ByteBuffer bb) throws IOException {
         return sel.readNonBlocking(this, bb);
     }
@@ -100,7 +100,7 @@ public class NioChannel implements ByteChannel {
     public int write(ByteBuffer bb) throws IOException {
         return sel.writeNonBlocking(this, bb);
     }
-    
+
     public void readInterest(boolean b) throws IOException {
         sel.readInterest(this, b);
     }
@@ -108,7 +108,7 @@ public class NioChannel implements ByteChannel {
     public void writeInterest() throws IOException {
         sel.writeInterest(this);
     }
- 
+
     public InetAddress getAddress(boolean remote) {
         return sel.getAddress(this, remote);
     }
@@ -116,7 +116,7 @@ public class NioChannel implements ByteChannel {
     public int getPort(boolean remote) {
         return sel.getPort(this, remote);
     }
-    
+
     /**
      * Run in selector thread.
      */
@@ -125,28 +125,28 @@ public class NioChannel implements ByteChannel {
     }
 
     /**
-     * Request a timer event. The thread will generate the events at 
+     * Request a timer event. The thread will generate the events at
      * a configurable interval - for example no more often than 0.5 sec.
      */
     public void setTimer(long timeMs, Runnable cb) {
         this.nextTimeEvent = timeMs;
         this.timeEvent = cb;
     }
-    
+
     /**
      *  shutdown out + in
      *  If there is still data in the input buffer - RST will be sent
      *  instead of FIN.
-     *  
-     * 
-     * The proper way to close a connection is to shutdownOutput() first, 
+     *
+     *
+     * The proper way to close a connection is to shutdownOutput() first,
      * wait until read() return -1, then call close().
-     * 
+     *
      * If read() returns -1, you need to finish sending, call shutdownOutput()
-     * than close. 
-     * If read() returns -1 and there is an error - call close() 
-     * directly. 
-     * 
+     * than close.
+     * If read() returns -1 and there is an error - call close()
+     * directly.
+     *
      */
     @Override
     public void close() throws IOException {
@@ -157,9 +157,9 @@ public class NioChannel implements ByteChannel {
     /**
      *  Send TCP close(FIN). HTTP uses this to transmit end of body. The other end
      *  detects this with a '-1' in read().
-     *  
+     *
      *  All other forms of close() are reported as exceptions in read().
-     * 
+     *
      * @throws IOException
      */
     public void shutdownOutput() throws IOException {
@@ -171,13 +171,13 @@ public class NioChannel implements ByteChannel {
                 } catch (IOException ex) {
                     // ignore
                 }
-            } 
+            }
             if (inClosed) {
                 sel.close(this, null);
             }
         }
     }
-    
+
     void inputClosed() throws IOException {
         synchronized (channel) {
             if (inClosed) {
@@ -193,6 +193,6 @@ public class NioChannel implements ByteChannel {
             }
         }
     }
-    
+
     boolean closeCalled = false;
 }
\ No newline at end of file

==================================================
SocketConnector.java
index 3b6e649252..9ec80becd9 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/NioThread.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/NioThread.java
@@ -46,13 +46,13 @@ import org.apache.tomcat.lite.io.NioChannel.NioChannelCallback;
 
 /**
  * Abstract NIO/APR to avoid some of the complexity and allow more code
- * sharing and experiments. 
+ * sharing and experiments.
  *
- * SelectorThread provides non-blocking methods for read/write and generates 
- * callbacks using SelectorCallback. It has no buffers of its own. 
+ * SelectorThread provides non-blocking methods for read/write and generates
+ * callbacks using SelectorCallback. It has no buffers of its own.
+ *
+ * This is non-blocking, non-buffering and uses callbacks.
  *
- * This is non-blocking, non-buffering and uses callbacks. 
- * 
  * @author Costin Manolache
  */
 public class NioThread implements Runnable {
@@ -78,12 +78,12 @@ public class NioThread implements Runnable {
   AtomicInteger opened = new AtomicInteger();
   AtomicInteger closed = new AtomicInteger();
   AtomicInteger loops = new AtomicInteger();
-  
+
   AtomicInteger callbackCount = new AtomicInteger();
   AtomicLong callbackTotalTime = new AtomicLong();
   long maxCallbackTime = 0;
 
-  // actives are also stored in the Selector. This is only updated in the main 
+  // actives are also stored in the Selector. This is only updated in the main
   // thread
   public ArrayList<NioChannel> active = new ArrayList<NioChannel>();
 
@@ -94,45 +94,45 @@ public class NioThread implements Runnable {
   long lastWakeup = System.currentTimeMillis(); // last time we woke
   long nextWakeup; // next scheduled wakeup
 
-  // Normally select will wait for the next time event - if it's 
+  // Normally select will wait for the next time event - if it's
   // too far in future, maxSleep will override it.
   private long maxSleep = 600000;
   long sleepTime = maxSleep;
 
-  // Never sleep less than minSleep. This defines the resulution for 
+  // Never sleep less than minSleep. This defines the resulution for
   // time events.
   private long minSleep = 100;
 
   boolean daemon = false;
-  
+
   // TODO: trace log - record all events with timestamps, replay
 
   public NioThread(String name, boolean daemon) {
       try {
           selectorThread = (name == null) ? new Thread(this) :
               new Thread(this, name);
-          
+
           selector = Selector.open();
           // TODO: start it on-demand, close it when not in use
           selectorThread.setDaemon(daemon);
           this.daemon = daemon;
-          
+
           selectorThread.start();
-          
+
       } catch(IOException e) {
           throw new RuntimeException(e);
-      }        
+      }
   }
-  
+
   /**
-   * Opened sockets, waiting for something ( close at least ) 
+   * Opened sockets, waiting for something ( close at least )
    */
   public int getOpen() {
       return opened.get();
   }
 
   /**
-   * Closed - we're done with them. 
+   * Closed - we're done with them.
    */
   public int getClosed() {
       return closed.get();
@@ -141,11 +141,11 @@ public class NioThread implements Runnable {
   public int getActive() {
       return active.size();
   }
-  
+
   public int getCallbacks() {
       return callbackCount.get();
   }
-  
+
   public long getMaxCallbackTime() {
       return maxCallbackTime;
   }
@@ -157,8 +157,8 @@ public class NioThread implements Runnable {
       }
       return callbackTotalTime.get() / cnt;
   }
-  
-  /** 
+
+  /**
    * How many times we looped
    */
   public int getLoops() {
@@ -173,7 +173,7 @@ public class NioThread implements Runnable {
       return System.currentTimeMillis() - lastWakeup;
   }
 
-  /** 
+  /**
    * Close all resources, stop accepting, stop the thread.
    * The actual stop will happen in background.
    */
@@ -194,7 +194,7 @@ public class NioThread implements Runnable {
           // if we want timeouts - set here.
           try {
               loops.incrementAndGet();
-              
+
               // Check if new requests were added
               processPending();
 
@@ -204,9 +204,9 @@ public class NioThread implements Runnable {
                   // We don't want to iterate on every I/O
                   updateSleepTimeAndProcessTimeouts(now);
               }
-              
+
               int selected = selector.select(sleepTime);
-              
+
               lastWakeup = System.currentTimeMillis();
               long slept = lastWakeup - now;
 
@@ -224,7 +224,7 @@ public class NioThread implements Runnable {
                   }
                   sloops++;
               }
-              
+
               // handle events for existing req first.
               if (selected != 0) {
                   sloops = 0;
@@ -237,14 +237,14 @@ public class NioThread implements Runnable {
                       long beforeCallback = System.currentTimeMillis();
                       SelectionKey sk = i.next();
                       i.remove();
-                      
+
                       boolean valid = sk.isValid();
                       int readyOps = (valid) ? sk.readyOps() : 0;
-                      
+
                       NioChannel ch = (NioChannel) sk.attachment();
                       if (debugWakeup) {
-                          log.info("Wakeup selCnt=" + selected + " slept=" + (lastWakeup - now) + 
-                                  " ready: " + readyOps + " v=" + 
+                          log.info("Wakeup selCnt=" + selected + " slept=" + (lastWakeup - now) +
+                                  " ready: " + readyOps + " v=" +
                                   sk.isValid() + " ch=" + ch);
                       }
                       if (ch == null) {
@@ -295,13 +295,13 @@ public class NioThread implements Runnable {
                               // Leave readable interest !
                               handleReadable(ch);
                           }
-                          
-                          long callbackTime = 
+
+                          long callbackTime =
                               System.currentTimeMillis() - beforeCallback;
-                          
-                          if (callbackTime > 250) { 
-                              log.warning("Callback too long ! ops=" + ready + 
-                                      " time=" + callbackTime + " ch=" + ch + 
+
+                          if (callbackTime > 250) {
+                              log.warning("Callback too long ! ops=" + ready +
+                                      " time=" + callbackTime + " ch=" + ch +
                                       " " + callbackCnt);
                           }
                           if (callbackTime > maxCallbackTime) {
@@ -309,7 +309,7 @@ public class NioThread implements Runnable {
                           }
                           callbackCount.incrementAndGet();
                           this.callbackTotalTime.addAndGet(callbackTime);
-                          
+
                       } catch (Throwable t) {
                           log.log(Level.SEVERE, "SelectorThread: Channel error, closing", t);
                           ch.lastException = t;
@@ -329,9 +329,9 @@ public class NioThread implements Runnable {
   }
 
   private void log(String msg, int selected, long slept, SelectionKey sk, int readyOps) {
-      log.info(msg + " " + selected 
-              + " " + slept    
-              + " ready: " + readyOps + " " 
+      log.info(msg + " " + selected
+              + " " + slept
+              + " ready: " + readyOps + " "
               + sk.readyOps() + " " + sk);
   }
 
@@ -347,7 +347,7 @@ public class NioThread implements Runnable {
           oldCh.add(cd);
           k.cancel();
       }
-      
+
       selector.close();
       selector = Selector.open();
       for (int i = 0; i < oldCh.size(); i++) {
@@ -357,17 +357,17 @@ public class NioThread implements Runnable {
           }
           int interest = interests.get(i);
           if (selectorData.channel instanceof ServerSocketChannel) {
-              ServerSocketChannel socketChannel = 
+              ServerSocketChannel socketChannel =
                   (ServerSocketChannel) selectorData.channel;
               selectorData.selKey = socketChannel.register(selector, SelectionKey.OP_ACCEPT);
           } else {
               SocketChannel socketChannel =
                   (SocketChannel) selectorData.channel;
               if (interest != 0) {
-                  selectorData.selKey = socketChannel.register(selector, 
+                  selectorData.selKey = socketChannel.register(selector,
                       interest);
               }
-              
+
           }
       }
   }
@@ -381,9 +381,9 @@ public class NioThread implements Runnable {
           log.warning("LOOP: read interest" +
                       " after incomplete read");
           ch.close();
-      }                                        
+      }
   }
-  
+
   private void handleDataWriteable(NioChannel ch) throws IOException {
       ch.lastWriteResult = 0;
       if (ch.callback != null) {
@@ -404,7 +404,7 @@ public class NioThread implements Runnable {
           ch.sel = this;
           //sc.socket().setSoLinger(true, 0);
           if (debug) {
-              log.info("connected() " + ch + " isConnected()=" + sc.isConnected() + " " + 
+              log.info("connected() " + ch + " isConnected()=" + sc.isConnected() + " " +
                       sc.isConnectionPending());
           }
 
@@ -428,13 +428,13 @@ public class NioThread implements Runnable {
       ServerSocketChannel ssc=(ServerSocketChannel)selc;
       SocketChannel sockC = ssc.accept();
       sockC.configureBlocking(false);
-      
+
       NioChannel acceptedChannel = new NioChannel(this);
-      acceptedChannel.selKey = sockC.register(selector, 
-              SelectionKey.OP_READ, 
+      acceptedChannel.selKey = sockC.register(selector,
+              SelectionKey.OP_READ,
               acceptedChannel);
       acceptedChannel.channel = sockC;
-      
+
       synchronized (active) {
           active.add(acceptedChannel);
       }
@@ -447,10 +447,10 @@ public class NioThread implements Runnable {
           } catch (Throwable t) {
               log.log(Level.SEVERE, "SelectorThread: Channel error, closing ", t);
               acceptedChannel.lastException = t;
-              acceptedChannel.close();              
+              acceptedChannel.close();
           }
      }
-      
+
       //sk.interestOps(sk.interestOps() | SelectionKey.OP_ACCEPT);
       if (debug) {
           log.info("handleAccept " + ch);
@@ -470,9 +470,9 @@ public class NioThread implements Runnable {
           }
       }
   }
-  
-  /** 
-   * Called from the IO thread 
+
+  /**
+   * Called from the IO thread
    */
   private void closeIOThread(NioChannel ch, boolean remove) {
       SelectionKey sk = (SelectionKey) ch.selKey;
@@ -497,7 +497,7 @@ public class NioThread implements Runnable {
                   sk.cancel();
                   ch.selKey = null;
               }
-              
+
               if (channel instanceof SocketChannel) {
                   SocketChannel sc = (SocketChannel) channel;
 
@@ -519,7 +519,7 @@ public class NioThread implements Runnable {
               channel.close();
 
               closed.incrementAndGet();
-              
+
               if (ch.callback != null) {
                   ch.callback.handleClosed(ch);
               }
@@ -537,17 +537,17 @@ public class NioThread implements Runnable {
 
   // --------------- Socket op abstractions ------------
 
-  public int readNonBlocking(NioChannel selectorData, ByteBuffer bb) 
+  public int readNonBlocking(NioChannel selectorData, ByteBuffer bb)
   throws IOException {
       try {
           int off = bb.position();
 
           int done = 0;
-          
+
           done = ((SocketChannel) selectorData.channel).read(bb);
-          
+
           if (debug) {
-              log.info("-------------readNB rd=" + done + " bb.limit=" + 
+              log.info("-------------readNB rd=" + done + " bb.limit=" +
                       bb.limit() + " pos=" + bb.position() + " " + selectorData);
           }
           if (done > 0) {
@@ -581,7 +581,7 @@ public class NioThread implements Runnable {
           return done;
       } catch(IOException ex) {
           if (debug) {
-              log.info("readNB error rd=" + -1 + " bblen=" + 
+              log.info("readNB error rd=" + -1 + " bblen=" +
                       (bb.limit() - bb.position()) + " " + selectorData + " " + ex);
           }
           // common case: other side closed the connection. No need for trace
@@ -597,21 +597,21 @@ public class NioThread implements Runnable {
   /**
    *  May be called from any thread
    */
-  public int writeNonBlocking(NioChannel selectorData, ByteBuffer bb) 
+  public int writeNonBlocking(NioChannel selectorData, ByteBuffer bb)
           throws IOException {
       try {
           if (debug) {
-              log.info("writeNB pos=" + bb.position() + " len=" + 
+              log.info("writeNB pos=" + bb.position() + " len=" +
                       (bb.limit() - bb.position()) + " " + selectorData);
              if (!bb.isDirect()) {
                   String s = new String(bb.array(), bb.position(),
-              
+
                       bb.limit() - bb.position());
                   log.info("Data:\n" + s);
               }
           }
           if (selectorData.writeInterest) {
-              // writeInterest will be false after a callback, if it is 
+              // writeInterest will be false after a callback, if it is
               // set it means we want to wait for the callback.
               if (debug) {
                   log.info("Prevent writeNB when writeInterest is set");
@@ -625,8 +625,8 @@ public class NioThread implements Runnable {
           return done;
       } catch(IOException ex) {
           if (debug) {
-              log.info("writeNB error pos=" + bb.position() + " len=" + 
-                      (bb.limit() - bb.position()) + " " + selectorData + " " + 
+              log.info("writeNB error pos=" + bb.position() + " len=" +
+                      (bb.limit() - bb.position()) + " " + selectorData + " " +
                       ex);
           }
           //ex.printStackTrace();
@@ -638,18 +638,18 @@ public class NioThread implements Runnable {
   }
 
   public int getPort(NioChannel sd, boolean remote) {
-      SocketChannel socketChannel = (SocketChannel) sd.channel;        
-      
+      SocketChannel socketChannel = (SocketChannel) sd.channel;
+
       if (remote) {
           return socketChannel.socket().getPort();
       } else {
           return socketChannel.socket().getLocalPort();
       }
   }
-  
+
   public InetAddress getAddress(NioChannel sd, boolean remote) {
-      SocketChannel socketChannel = (SocketChannel) sd.channel;        
-      
+      SocketChannel socketChannel = (SocketChannel) sd.channel;
+
       if (remote) {
           return socketChannel.socket().getInetAddress();
       } else {
@@ -657,21 +657,21 @@ public class NioThread implements Runnable {
       }
   }
 
-  /** 
+  /**
    */
-  public void connect(String host, int port, NioChannelCallback cstate) 
+  public void connect(String host, int port, NioChannelCallback cstate)
           throws IOException {
       connect(new InetSocketAddress(host, port), cstate);
   }
-  
+
 
   public void connect(SocketAddress sa, NioChannelCallback cstate)
           throws IOException {
       connect(sa, cstate, null);
   }
-  
-  public void connect(SocketAddress sa, NioChannelCallback cstate, 
-                      NioChannel filter) 
+
+  public void connect(SocketAddress sa, NioChannelCallback cstate,
+                      NioChannel filter)
           throws IOException {
 
       SocketChannel socketChannel = SocketChannel.open();
@@ -681,10 +681,10 @@ public class NioThread implements Runnable {
       selectorData.callback = cstate;
       selectorData.channel = socketChannel;
       selectorData.channel = socketChannel; // no key
-      
+
       socketChannel.connect(sa);
       opened.incrementAndGet();
-      
+
       synchronized (connectAcceptInterest) {
           connectAcceptInterest.add(selectorData);
       }
@@ -700,16 +700,16 @@ public class NioThread implements Runnable {
 
   // TODO
   public void setSocketOptions(NioChannel selectorData,
-                               int linger, 
+                               int linger,
                                boolean tcpNoDelay,
                                int socketTimeout)
   throws IOException {
 
-      SocketChannel socketChannel = 
+      SocketChannel socketChannel =
           (SocketChannel) selectorData.channel;
       Socket socket = socketChannel.socket();
 
-      if(linger >= 0 ) 
+      if(linger >= 0 )
           socket.setSoLinger( true, linger);
       if( tcpNoDelay )
           socket.setTcpNoDelay(tcpNoDelay);
@@ -717,7 +717,7 @@ public class NioThread implements Runnable {
           socket.setSoTimeout( socketTimeout );
   }
 
-  /** 
+  /**
    * Can be called from multiple threads or multiple times.
    */
   public int close(NioChannel selectorData, Throwable exception) throws IOException {
@@ -739,18 +739,18 @@ public class NioThread implements Runnable {
   }
 
 
-  public void acceptor(NioChannelCallback cstate, 
-                       int port, 
-                       InetAddress inet, 
+  public void acceptor(NioChannelCallback cstate,
+                       int port,
+                       InetAddress inet,
                        int backlog,
                        int serverTimeout)
-  throws IOException 
+  throws IOException
   {
       ServerSocketChannel ssc=ServerSocketChannel.open();
       ServerSocket serverSocket = ssc.socket();
-      
+
       SocketAddress sa = null;
-      
+
       if (inet == null) {
           sa = new InetSocketAddress( port );
       } else {
@@ -764,23 +764,23 @@ public class NioThread implements Runnable {
       if( serverTimeout >= 0 ) {
           serverSocket.setSoTimeout( serverTimeout );
       }
-      
+
 
       ssc.configureBlocking(false);
 
       NioChannel selectorData = new NioChannel(this);
       selectorData.channel = ssc; // no key yet
-      selectorData.callback = cstate; 
+      selectorData.callback = cstate;
       // key will be set in pending
 
       // TODO: add SSL here
-      
+
       synchronized (connectAcceptInterest) {
           connectAcceptInterest.add(selectorData);
       }
       selector.wakeup();
   }
-  
+
   public void runInSelectorThread(Runnable cb) throws IOException {
       if (isSelectorThread()) {
           cb.run();
@@ -793,25 +793,25 @@ public class NioThread implements Runnable {
   }
 
   /**
-   * Example config: 
-   * 
+   * Example config:
+   *
    * www stream tcp wait USER  PATH_TO_tomcatInetd.sh
-   * 
+   *
    * For a different port, you need to add it to /etc/services.
-   * 
-   * 'wait' is critical - the common use of inetd is 'nowait' for 
+   *
+   * 'wait' is critical - the common use of inetd is 'nowait' for
    * tcp services, which doesn't make sense for java ( too slow startup
    * time ). It may make sense in future with something like android VM.
-   * 
+   *
    * In 'wait' mode, inetd will pass the acceptor socket to java - so
    * you can listen on port 80 and run as regular user with no special
    * code and magic.
    * If tomcat dies, inetd will get back the acceptor and on next connection
-   * restart tomcat. 
-   * 
+   * restart tomcat.
+   *
    * This also works with xinetd. It might work with Apple launchd.
-   * 
-   * TODO: detect inactivity for N minutes, exist - to free resources. 
+   *
+   * TODO: detect inactivity for N minutes, exist - to free resources.
    */
   public void inetdAcceptor(NioChannelCallback cstate) throws IOException {
       SelectorProvider sp=SelectorProvider.provider();
@@ -826,7 +826,7 @@ public class NioThread implements Runnable {
           NioChannel selectorData = new NioChannel(this);
           selectorData.channel = ssc;
           selectorData.callback = cstate;
-          
+
           synchronized (connectAcceptInterest) {
               connectAcceptInterest.add(selectorData);
           }
@@ -839,11 +839,11 @@ public class NioThread implements Runnable {
 
   // -------------- Housekeeping -------------
   /**
-   *  Same as APR connector - iterate over tasks, get 
+   *  Same as APR connector - iterate over tasks, get
    *  smallest timeout
-   * @throws IOException 
+   * @throws IOException
    */
-  void updateSleepTimeAndProcessTimeouts(long now) 
+  void updateSleepTimeAndProcessTimeouts(long now)
           throws IOException {
       long min = Long.MAX_VALUE;
       // TODO: test with large sets, maybe sort
@@ -854,7 +854,7 @@ public class NioThread implements Runnable {
               NioChannel selectorData = activeIt.next();
               if (! selectorData.channel.isOpen()) {
                   if (debug) {
-                      log.info("Found closed socket, removing " + 
+                      log.info("Found closed socket, removing " +
                               selectorData.channel);
                   }
 //                  activeIt.remove();
@@ -892,18 +892,18 @@ public class NioThread implements Runnable {
       nextWakeup = now + sleepTime;
   }
 
-  /** 
-   * Request a callback whenever data can be written. 
-   * When the callback is invoked, the write interest is removed ( to avoid 
+  /**
+   * Request a callback whenever data can be written.
+   * When the callback is invoked, the write interest is removed ( to avoid
    * looping ). If the write() operation doesn't complete, you must call
    * writeInterest - AND stop writing, some implementations will throw
-   * exception. write() will actually attempt to detect this and avoid the 
+   * exception. write() will actually attempt to detect this and avoid the
    * error.
-   * 
+   *
    * @param sc
    */
   public void writeInterest(NioChannel selectorData) {
-      // TODO: suspended ? 
+      // TODO: suspended ?
 
       SelectionKey sk = (SelectionKey) selectorData.selKey;
       if (!sk.isValid()) {
@@ -915,9 +915,9 @@ public class NioThread implements Runnable {
           return;
       }
       if (Thread.currentThread() == selectorThread) {
-          interest = 
+          interest =
               interest | SelectionKey.OP_WRITE;
-          sk.interestOps(interest);                
+          sk.interestOps(interest);
           if (debug) {
               log.info("Write interest " + selectorData + " i=" + interest);
           }
@@ -931,11 +931,11 @@ public class NioThread implements Runnable {
       }
       selector.wakeup();
   }
-  
-  
+
+
   public void readInterest(NioChannel selectorData, boolean b) throws IOException {
       if (Thread.currentThread() == selectorThread) {
-          selectorData.readInterest = b; 
+          selectorData.readInterest = b;
           selThreadReadInterest(selectorData);
           return;
       }
@@ -970,12 +970,12 @@ public class NioThread implements Runnable {
               if (debug) {
                   log.info("Register again for read interest");
               }
-              SocketChannel socketChannel = 
+              SocketChannel socketChannel =
                   (SocketChannel) selectorData.channel;
               if (socketChannel.isOpen()) {
                   selectorData.sel = this;
-                  selectorData.selKey = 
-                      socketChannel.register(selector, 
+                  selectorData.selKey =
+                      socketChannel.register(selector,
                               SelectionKey.OP_READ, selectorData);
                   selectorData.channel = socketChannel;
               }
@@ -991,14 +991,14 @@ public class NioThread implements Runnable {
 //              if ((interest | SelectionKey.OP_READ) != 0) {
 //                  return;
 //              }
-              interest = 
+              interest =
                   interest | SelectionKey.OP_READ;
           } else {
 //              if ((interest | SelectionKey.OP_READ) == 0) {
 //                  return;
 //              }
-              interest = 
-                  interest & ~SelectionKey.OP_READ;                
+              interest =
+                  interest & ~SelectionKey.OP_READ;
           }
           if (interest == 0) {
               if (!selectorData.inClosed) {
@@ -1013,13 +1013,13 @@ public class NioThread implements Runnable {
               sk.interestOps(interest);
           }
           if (debug) {
-              log.info(((selectorData.readInterest) 
-                      ? "RESUME read " : "SUSPEND read ") 
+              log.info(((selectorData.readInterest)
+                      ? "RESUME read " : "SUSPEND read ")
                       + selectorData);
           }
       }
   }
-  
+
 
   private void processPendingConnectAccept() throws IOException {
       synchronized (connectAcceptInterest) {
@@ -1027,18 +1027,18 @@ public class NioThread implements Runnable {
 
           while (ci.hasNext()) {
               NioChannel selectorData = ci.next();
-              
+
               // Find host, port - initiate connection
               try {
                   // Accept interest ?
                   if (selectorData.channel instanceof ServerSocketChannel) {
-                      ServerSocketChannel socketChannel = 
+                      ServerSocketChannel socketChannel =
                           (ServerSocketChannel) selectorData.channel;
                       selectorData.sel = this;
-                      selectorData.selKey = 
-                        socketChannel.register(selector, 
+                      selectorData.selKey =
+                        socketChannel.register(selector,
                             SelectionKey.OP_ACCEPT, selectorData);
-                      
+
                       selectorData.channel = socketChannel;
                       synchronized (active) {
                           active.add(selectorData);
@@ -1050,8 +1050,8 @@ public class NioThread implements Runnable {
                       SocketChannel socketChannel =
                           (SocketChannel) selectorData.channel;
                       selectorData.sel = this;
-                      selectorData.selKey = 
-                        socketChannel.register(selector, 
+                      selectorData.selKey =
+                        socketChannel.register(selector,
                             SelectionKey.OP_CONNECT, selectorData);
                       synchronized (active) {
                           active.add(selectorData);
@@ -1061,22 +1061,22 @@ public class NioThread implements Runnable {
                       }
                   }
               } catch (Throwable e) {
-                  log.log(Level.SEVERE, "error registering connect/accept", 
+                  log.log(Level.SEVERE, "error registering connect/accept",
                           e);
               }
           }
           connectAcceptInterest.clear();
       }
   }
-  
+
   private void processPending() throws IOException {
       if (closeInterest.size() > 0) {
           synchronized (closeInterest) {
               List<NioChannel> closeList = new ArrayList(closeInterest);
               closeInterest.clear();
-              
+
               Iterator<NioChannel> ci = closeList.iterator();
-              
+
               while (ci.hasNext()) {
                   try {
                       NioChannel selectorData = ci.next();
@@ -1089,7 +1089,7 @@ public class NioThread implements Runnable {
       }
       processPendingConnectAccept();
       processPendingReadWrite();
-      
+
       if (runnableInterest.size() > 0) {
           synchronized (runnableInterest) {
               Iterator<Runnable> ci = runnableInterest.iterator();
@@ -1111,7 +1111,7 @@ public class NioThread implements Runnable {
   }
 
   private void processPendingReadWrite() throws IOException {
-      // Update interest 
+      // Update interest
       if (readInterest.size() > 0) {
           synchronized (readInterest) {
               Iterator<NioChannel> ci = readInterest.iterator();
@@ -1145,10 +1145,10 @@ public class NioThread implements Runnable {
   protected boolean isSelectorThread() {
       return Thread.currentThread() == selectorThread;
   }
-  
+
   public static boolean isSelectorThread(IOChannel ch) {
       SocketIOChannel sc = (SocketIOChannel) ch.getFirst();
       return Thread.currentThread() == sc.ch.sel.selectorThread;
   }
-  
+
 }
\ No newline at end of file

==================================================
SocketIOChannel.java
index 93bae2ad43..283b947456 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/SocketConnector.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/SocketConnector.java
@@ -14,28 +14,28 @@ import org.apache.tomcat.lite.io.NioChannel.NioChannelCallback;
 /**
  * Class for handling sockets. It manages a pool of SelectorThreads, fully
  * non-blocking. There is no caching or buffer management. SelectorChannel
- * represents on connection. 
- * 
+ * represents on connection.
+ *
  * In the old types, the connector was socket-centric, and quite ugly. After
  * many refactoring the buffers ( buckets and brigade ) and callbacks are
  * used everywhere, and the sockets play a supporting role.
- * 
- * TODO: discover if APR is available and use it, or fall back to NIO. 
- * 
+ *
+ * TODO: discover if APR is available and use it, or fall back to NIO.
+ *
  * @author Costin Manolache
  */
 public class SocketConnector extends IOConnector {
     static Logger log = Logger.getLogger(SocketConnector.class.getName());
     static boolean debug = false;
-    
+
     // TODO: pool, balanced usage
-    // TODO: bind into OM or callback when created 
+    // TODO: bind into OM or callback when created
 
     private NioThread selector;
-    
+
     // For resolving DNS ( i.e. connect )
     Executor threadPool = Executors.newCachedThreadPool();
-    
+
     public SocketConnector() {
         timer = new Timer(true);
     }
@@ -49,7 +49,7 @@ public class SocketConnector extends IOConnector {
      * If the IP address is provided - it shouldn't block.
      */
     @Override
-    public void connect(final String host, final int port, 
+    public void connect(final String host, final int port,
                              final IOConnector.ConnectedCallback sc) throws IOException {
         final SocketIOChannel ioch = new SocketIOChannel(this, null, host + ":" + port);
         ioch.setConnectedCallback(sc);
@@ -70,15 +70,15 @@ public class SocketConnector extends IOConnector {
             }
         });
     }
-    
+
     /**
-     * Create a new server socket, register the callback. 
+     * Create a new server socket, register the callback.
      * If port == 0 it'll use the inherited channel, i.e. inetd mode.
      * TODO: if port == -1, detect a free port. May block.
      */
-    public void acceptor(final IOConnector.ConnectedCallback sc, 
+    public void acceptor(final IOConnector.ConnectedCallback sc,
                          final CharSequence address, Object extra)
-        throws IOException 
+        throws IOException
     {
         final int port = Integer.parseInt(address.toString());
         NioChannelCallback acceptCb = new NioChannelCallback() {
@@ -88,7 +88,7 @@ public class SocketConnector extends IOConnector {
 
             @Override
             public void handleConnected(NioChannel ch) throws IOException {
-                SocketIOChannel ioch = new SocketIOChannel(SocketConnector.this, 
+                SocketIOChannel ioch = new SocketIOChannel(SocketConnector.this,
                         ch, ":" + port);
                 sc.handleConnected(ioch);
             }
@@ -101,11 +101,11 @@ public class SocketConnector extends IOConnector {
             public void handleWriteable(NioChannel ch) throws IOException {
             }
         };
-        
+
         if (port == -1) {
             // TODO: find an unused port
         } else if (port == 0) {
-            getSelector().inetdAcceptor(acceptCb);          
+            getSelector().inetdAcceptor(acceptCb);
         }  else {
             getSelector().acceptor(acceptCb, port, null, 200, 20000);
         }
@@ -121,12 +121,12 @@ public class SocketConnector extends IOConnector {
 
         return selector;
     }
-    
+
     public void stop() {
         getSelector().stop();
     }
 
 
     // TODO: suspendAccept(boolean)
-    
+
 }

==================================================
SslProvider.java
index 88a964d9bc..c74ccc5240 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/SocketIOChannel.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/SocketIOChannel.java
@@ -14,10 +14,10 @@ import org.apache.tomcat.lite.io.NioChannel.NioChannelCallback;
 public class SocketIOChannel extends IOChannel implements NioChannelCallback {
     IOBuffer out;
     IOBuffer in;
-    
+
     NioChannel ch;
-        
-    SocketIOChannel(IOConnector connector, NioChannel data, 
+
+    SocketIOChannel(IOConnector connector, NioChannel data,
             String target)
             throws IOException {
         this.connector = connector;
@@ -35,8 +35,8 @@ public class SocketIOChannel extends IOChannel implements NioChannelCallback {
             ch.callback = this;
         }
     }
-    
-    
+
+
     @Override
     public IOBuffer getIn() {
         return in;
@@ -46,15 +46,15 @@ public class SocketIOChannel extends IOChannel implements NioChannelCallback {
     public IOBuffer getOut() {
         return out;
     }
-    
-    /** 
+
+    /**
      * Both in and out open
      */
     public boolean isOpen() {
         if (ch == null) {
             return false;
         }
-        return ch.isOpen() && ch.channel != null && 
+        return ch.isOpen() && ch.channel != null &&
             ch.channel.isOpen() && !getIn().isAppendClosed() &&
             !getOut().isAppendClosed();
     }
@@ -66,16 +66,16 @@ public class SocketIOChannel extends IOChannel implements NioChannelCallback {
     public String toString() {
         return ch.toString();
     }
-    
+
     public void setOutBuffer(IOBuffer out) {
         this.out = out;
     }
-    
+
     ByteBuffer flushBuffer;
 
     /**
-     * Send as much as possible. 
-     * 
+     * Send as much as possible.
+     *
      * Adjust write interest so we can send more when possible.
      */
     private void flush(NioChannel ch) throws IOException {
@@ -91,13 +91,13 @@ public class SocketIOChannel extends IOChannel implements NioChannelCallback {
                     ch.shutdownOutput();
                     break;
                 }
-                BBucket bb = out.peekFirst(); 
+                BBucket bb = out.peekFirst();
                 if (bb == null) {
                     break;
                 }
                 flushBuffer = getReadableBuffer(flushBuffer, bb);
                 int before = flushBuffer.position();
-                
+
                 int done = 0;
                 while (flushBuffer.remaining() > 0) {
                     try {
@@ -126,19 +126,19 @@ public class SocketIOChannel extends IOChannel implements NioChannelCallback {
 
         }
     }
-    
+
     /**
      * Data available for read, called from IO thread.
      * You MUST read all data ( i.e. until read() returns 0).
-     *  
-     * OP_READ remain active - call readInterest(false) to disable - 
+     *
+     * OP_READ remain active - call readInterest(false) to disable -
      * for example to suspend reading if buffer is full.
      */
     public void handleReceived(IOChannel net) throws IOException {
         // All data will go to currentReceiveBuffer, until it's full.
         // Then a new buffer will be allocated/pooled.
-        
-        // When we fill the buffers or finish this round of reading - 
+
+        // When we fill the buffers or finish this round of reading -
         // we place the Buckets in the queue, as 'readable' buffers.
         boolean newData = false;
         try {
@@ -153,15 +153,15 @@ public class SocketIOChannel extends IOChannel implements NioChannelCallback {
                         newData = true;
                         break;
                     }
-                    
+
                     ByteBuffer bb = in.getWriteBuffer();
                     read = ch.read(bb);
                     in.releaseWriteBuffer(read);
-    
+
                     if (in == null) { // Detached.
                         break;
                     }
-                    
+
                     if (read < 0) {
                         // mark the in buffer as closed
                         in.close();
@@ -179,7 +179,7 @@ public class SocketIOChannel extends IOChannel implements NioChannelCallback {
             if (newData) {
                 super.sendHandleReceivedCallback();
             }
-            
+
         } catch (Throwable t) {
             close();
             if (t instanceof IOException) {
@@ -198,7 +198,7 @@ public class SocketIOChannel extends IOChannel implements NioChannelCallback {
         orig.limit(bucket.limit());
         return orig;
     }
-    
+
     public static final void releaseReadableBuffer(ByteBuffer bb, BBucket bucket) {
         bucket.position(bb.position());
     }
@@ -207,7 +207,7 @@ public class SocketIOChannel extends IOChannel implements NioChannelCallback {
     public void readInterest(boolean b) throws IOException {
         ch.readInterest(b);
     }
-    
+
     public InetAddress getAddress(boolean remote) {
         return ch.getAddress(remote);
     }
@@ -215,19 +215,19 @@ public class SocketIOChannel extends IOChannel implements NioChannelCallback {
     @Override
     public Object getAttribute(String name) {
         if (ATT_REMOTE_HOSTNAME.equals(name)) {
-            return getAddress(true).getHostName();                        
+            return getAddress(true).getHostName();
         } else if (ATT_LOCAL_HOSTNAME.equals(name)) {
-            return getAddress(false).getHostName();                        
+            return getAddress(false).getHostName();
         } else if (ATT_REMOTE_ADDRESS.equals(name)) {
-            return getAddress(true).getHostAddress();                        
+            return getAddress(true).getHostAddress();
         } else if (ATT_LOCAL_ADDRESS.equals(name)) {
-            return getAddress(false).getHostAddress();                        
+            return getAddress(false).getHostAddress();
         } else if (ATT_REMOTE_PORT.equals(name)) {
             return ch.getPort(true);
         } else if (ATT_LOCAL_PORT.equals(name)) {
             return ch.getPort(false);
         }
-        return null;        
+        return null;
     }
 
     public void startSending() throws IOException {
@@ -240,19 +240,19 @@ public class SocketIOChannel extends IOChannel implements NioChannelCallback {
             startSending();
         }
     }
-    
+
     @Override
     public void handleClosed(NioChannel ch) throws IOException {
         lastException = ch.lastException;
         closed(); // our callback.
     }
-    
+
     public void closed() throws IOException {
         getIn().close();
         sendHandleReceivedCallback();
         //super.closed();
     }
-    
+
     @Override
     public void handleConnected(NioChannel ch) throws IOException {
         setChannel(ch);

==================================================
UrlEncoding.java
index 94e86ae4a0..8c584b8756 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/SslProvider.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/SslProvider.java
@@ -11,14 +11,14 @@ public interface SslProvider {
     public static final String ATT_SSL_KEY_SIZE = "SslKeySize";
     public static final String ATT_SSL_SESSION_ID = "SslSessionId";
 
-    /** 
+    /**
      * Wrap channel with SSL.
-     * 
-     * The result will start a handshake 
+     *
+     * The result will start a handshake
      */
-    public IOChannel channel(IOChannel net, String host, int port) 
+    public IOChannel channel(IOChannel net, String host, int port)
         throws IOException;
 
     public IOChannel serverChannel(IOChannel net) throws IOException;
-    
+
 }

==================================================
WrappedException.java
index 3266491365..09e4b539b6 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/UrlEncoding.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/UrlEncoding.java
@@ -25,12 +25,12 @@ import java.util.BitSet;
 
 /**
  * Support for %xx URL encoding.
- * 
+ *
  * @author Costin Manolache
  */
 public final class UrlEncoding {
 
-    protected static final boolean ALLOW_ENCODED_SLASH = 
+    protected static final boolean ALLOW_ENCODED_SLASH =
         Boolean.valueOf(
                 System.getProperty(
                         "org.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH",
@@ -44,10 +44,10 @@ public final class UrlEncoding {
     static BitSet SAFE_CHARS = new BitSet(128);
     BBuffer tmpBuffer = BBuffer.allocate(1024);
     CBuffer tmpCharBuffer = CBuffer.newInstance();
-    
+
     public void urlEncode(CBuffer url, CBuffer encoded, IOWriter enc) {
         tmpBuffer.recycle();
-        urlEncode(url, tmpBuffer, encoded, enc.getEncoder("UTF-8"), 
+        urlEncode(url, tmpBuffer, encoded, enc.getEncoder("UTF-8"),
                 SAFE_CHARS_URL, true, enc);
     }
 
@@ -56,9 +56,9 @@ public final class UrlEncoding {
         tmpCharBuffer.append(url);
         urlEncode(tmpCharBuffer, encoded, enc);
     }
-    
+
     /** Only works for UTF-8 or charsets preserving ascii.
-     * 
+     *
      * @param url
      * @param tmpBuffer
      * @param encoded
@@ -72,7 +72,7 @@ public final class UrlEncoding {
             BitSet safeChars, boolean last, IOWriter enc) {
         // tomcat charset-encoded each character first. I don't think
         // this is needed.
-        
+
         // TODO: space to +
         enc.encodeAll(url, tmpBuffer, utf8Enc, last);
         byte[] array = tmpBuffer.array();
@@ -89,13 +89,13 @@ public final class UrlEncoding {
             }
         }
     }
-    
+
     static {
         initSafeChars(SAFE_CHARS);
         initSafeChars(SAFE_CHARS_URL);
         SAFE_CHARS_URL.set('/');
     }
-    
+
     private static void initSafeChars(BitSet safeChars) {
         int i;
         for (i = 'a'; i <= 'z'; i++) {
@@ -121,12 +121,12 @@ public final class UrlEncoding {
         safeChars.set('$'); // ?
         safeChars.set('!'); // ?
         safeChars.set('\''); // ?
-        safeChars.set('('); // ? 
-        safeChars.set(')'); // ? 
-        safeChars.set(','); // ? 
+        safeChars.set('('); // ?
+        safeChars.set(')'); // ?
+        safeChars.set(','); // ?
     }
-    
-    public void urlDecode(BBuffer bb, CBuffer dest, boolean q, 
+
+    public void urlDecode(BBuffer bb, CBuffer dest, boolean q,
             IOReader charDec) throws IOException {
         // Replace %xx
         tmpBuffer.append(bb);
@@ -134,8 +134,8 @@ public final class UrlEncoding {
         charDec.decodeAll(bb, dest);
     }
 
-    
-    public void urlDecode(BBuffer bb, CBuffer dest,  
+
+    public void urlDecode(BBuffer bb, CBuffer dest,
             IOReader charDec) throws IOException {
         // Replace %xx
         tmpBuffer.append(bb);
@@ -143,11 +143,11 @@ public final class UrlEncoding {
         charDec.decodeAll(bb, dest);
     }
 
-    
+
     /**
-     * URLDecode, will modify the source. This is only at byte level - 
-     * it needs conversion to chars using the right charset. 
-     * 
+     * URLDecode, will modify the source. This is only at byte level -
+     * it needs conversion to chars using the right charset.
+     *
      * @param query Converts '+' to ' ' and allow '/'
      */
     public void urlDecode(BBuffer mb, boolean query) throws IOException {

==================================================
JsseSslProvider.java
index 3d8a281a76..5d0897cb50 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/WrappedException.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/WrappedException.java
@@ -6,8 +6,8 @@ import java.io.IOException;
 
 /**
  * For specific exceptions - also has cause ( good if compiling against
- * JDK1.5 ) 
- * 
+ * JDK1.5 )
+ *
  * @author Costin Manolache
  */
 public class WrappedException extends IOException {
@@ -15,7 +15,7 @@ public class WrappedException extends IOException {
     public WrappedException() {
         super();
     }
-    
+
     public WrappedException(String message) {
         super(message);
     }
@@ -24,17 +24,17 @@ public class WrappedException extends IOException {
         super(message);
         initCause(cause);
     }
-    
+
     public WrappedException(Throwable cause) {
         super("");
         initCause(cause);
     }
-    
-    
+
+
     public static class ClientAbortException extends WrappedException {
         public ClientAbortException(Throwable throwable) {
             super(null, throwable);
         }
     }
-    
+
 }

==================================================
SslChannel.java
index 56c80b1387..aad716a62c 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/jsse/JsseSslProvider.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/jsse/JsseSslProvider.java
@@ -54,68 +54,68 @@ public class JsseSslProvider implements SslProvider {
 
     /**
      * TODO: option to require validation.
-     * TODO: remember cert signature. This is needed to support self-signed 
-     * certs, like those used by the test. 
-     * 
+     * TODO: remember cert signature. This is needed to support self-signed
+     * certs, like those used by the test.
+     *
      */
     public static class BasicTrustManager implements X509TrustManager {
-    
+
         private X509Certificate[] chain;
-        
+
         public void checkClientTrusted(X509Certificate[] chain, String authType)
                 throws CertificateException {
             this.chain = chain;
         }
-    
+
         public void checkServerTrusted(X509Certificate[] chain, String authType)
                 throws CertificateException {
             this.chain = chain;
         }
-    
+
         public X509Certificate[] getAcceptedIssuers() {
             return new X509Certificate[0];
         }
     }
 
-    public static TrustManager[] trustAllCerts = new TrustManager[] { 
-        new BasicTrustManager() }; 
+    public static TrustManager[] trustAllCerts = new TrustManager[] {
+        new BasicTrustManager() };
 
     static String[] enabledCiphers;
 
     static final boolean debug = false;
-    
+
     IOConnector net;
-    private KeyManager[] keyManager; 
+    private KeyManager[] keyManager;
     SSLContext sslCtx;
     boolean server;
     private TrustManager[] trustManagers;
-    
+
     public AtomicInteger handshakeCount = new AtomicInteger();
     public AtomicInteger handshakeOk = new AtomicInteger();
     public AtomicInteger handshakeErr = new AtomicInteger();
     public AtomicInteger handshakeTime = new AtomicInteger();
-    
+
     Executor handshakeExecutor = Executors.newCachedThreadPool();
     static int id = 0;
-    
+
     public JsseSslProvider() {
     }
-    
+
     public static void setEnabledCiphers(String[] enabled) {
         enabledCiphers = enabled;
     }
-    
+
     public void start() {
-        
+
     }
-    
+
     SSLContext getSSLContext() {
         if (sslCtx == null) {
             try {
                 sslCtx = SSLContext.getInstance("TLS");
                 if (trustManagers == null) {
-                    trustManagers = 
-                        new TrustManager[] {new BasicTrustManager()}; 
+                    trustManagers =
+                        new TrustManager[] {new BasicTrustManager()};
 
                 }
                 sslCtx.init(keyManager, trustManagers, null);
@@ -128,7 +128,7 @@ public class JsseSslProvider implements SslProvider {
         }
         return sslCtx;
     }
-    
+
     public IOConnector getNet() {
         if (net == null) {
             getSSLContext();
@@ -136,7 +136,7 @@ public class JsseSslProvider implements SslProvider {
         }
         return net;
     }
-    
+
     @Override
     public IOChannel channel(IOChannel net, String host, int port) throws IOException {
       if (debug) {
@@ -158,8 +158,8 @@ public class JsseSslProvider implements SslProvider {
         ch.setSink(net);
         return ch;
     }
-    
-    public void acceptor(final ConnectedCallback sc, CharSequence port, Object extra) 
+
+    public void acceptor(final ConnectedCallback sc, CharSequence port, Object extra)
             throws IOException {
         getNet().acceptor(new ConnectedCallback() {
             @Override
@@ -168,7 +168,7 @@ public class JsseSslProvider implements SslProvider {
                 if (debug) {
                     first = DumpChannel.wrap("S-ENC-" + id, ch);
                 }
-                
+
                 IOChannel sslch = serverChannel(first);
                 sslch.setSink(first);
                 first.setHead(sslch);
@@ -177,12 +177,12 @@ public class JsseSslProvider implements SslProvider {
                     sslch = DumpChannel.wrap("S-CLR-" + id, sslch);
                     id++;
                 }
-                
+
                 sc.handleConnected(sslch);
             }
         }, port, extra);
     }
-    
+
     public void connect(final String host, final int port, final ConnectedCallback sc)
             throws IOException {
         getNet().connect(host, port, new ConnectedCallback() {
@@ -193,7 +193,7 @@ public class JsseSslProvider implements SslProvider {
                 if (debug) {
                     first = DumpChannel.wrap("ENC-" + id, first);
                 }
-                
+
                 IOChannel sslch = channel(first, host, port);
 //                first.setHead(sslch);
 
@@ -201,10 +201,10 @@ public class JsseSslProvider implements SslProvider {
                     sslch = DumpChannel.wrap("CLR-" + id, sslch);
                     id++;
                 }
-                
+
                 sc.handleConnected(sslch);
             }
-            
+
         });
     }
 
@@ -212,16 +212,16 @@ public class JsseSslProvider implements SslProvider {
         this.keyManager = kms;
         return this;
     }
-    
+
     public JsseSslProvider setKeystoreFile(String file, String pass) throws IOException {
         return setKeystore(new FileInputStream(file), pass);
     }
 
     public JsseSslProvider setKeystoreResource(String res, String pass) throws IOException {
-        return setKeystore(this.getClass().getClassLoader().getResourceAsStream(res), 
+        return setKeystore(this.getClass().getClassLoader().getResourceAsStream(res),
                 pass);
     }
-    
+
     public JsseSslProvider setKeystore(InputStream file, String pass) {
         char[] passphrase = pass.toCharArray();
         KeyStore ks;
@@ -232,14 +232,14 @@ public class JsseSslProvider implements SslProvider {
             // Android: BKS
             ks = KeyStore.getInstance(type);
             ks.load(file, passphrase);
-            KeyManagerFactory kmf = 
+            KeyManagerFactory kmf =
                 KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
             kmf.init(ks, passphrase);
-            
-            TrustManagerFactory tmf = 
+
+            TrustManagerFactory tmf =
                 TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
             tmf.init(ks);
-            
+
             keyManager = kmf.getKeyManagers();
             trustManagers = tmf.getTrustManagers();
         } catch (KeyStoreException e) {
@@ -261,38 +261,38 @@ public class JsseSslProvider implements SslProvider {
             // TODO Auto-generated catch block
             e.printStackTrace();
         }
-                
+
         return this;
     }
-    
+
     public JsseSslProvider setKeys(X509Certificate cert, PrivateKey privKey) {
         keyManager = new KeyManager[] {
                 new TestKeyManager(cert, privKey)
         };
         return this;
     }
-    
-    public JsseSslProvider setKeyFiles(String certPem, String keyFile) 
+
+    public JsseSslProvider setKeyFiles(String certPem, String keyFile)
             throws IOException {
-        
+
 
         return this;
     }
-    
-    public JsseSslProvider setKeyRes(String certPem, String keyFile) 
+
+    public JsseSslProvider setKeyRes(String certPem, String keyFile)
             throws IOException {
         setKeys(this.getClass().getClassLoader().getResourceAsStream(certPem),
                 this.getClass().getClassLoader().getResourceAsStream(keyFile));
         return this;
     }
-    
+
     private void setKeys(InputStream certPem,
             InputStream keyDer) throws IOException {
         BBuffer keyB = BBuffer.allocate(2048);
         keyB.readAll(keyDer);
         byte[] key = new byte[keyB.remaining()];
         keyB.getByteBuffer().get(key);
-        
+
         setKeys(certPem, key);
     }
 
@@ -300,19 +300,19 @@ public class JsseSslProvider implements SslProvider {
         InputStream is = new ByteArrayInputStream(certPem.getBytes());
         return setKeys(is, keyBytes);
     }
-    
+
     /**
      * Initialize using a PEM certificate and key bytes.
      * ( TODO: base64 dep to set the key as PEM )
-     * 
+     *
      *  openssl genrsa 1024 > host.key
-     *  openssl pkcs8 -topk8 -nocrypt -in host.key -inform PEM 
+     *  openssl pkcs8 -topk8 -nocrypt -in host.key -inform PEM
      *     -out host.der -outform DER
      *  openssl req -new -x509 -nodes -sha1 -days 365 -key host.key > host.cert
-     * 
+     *
      */
     public JsseSslProvider setKeys(InputStream certPem, byte[] keyBytes) throws IOException{
-        // convert key 
+        // convert key
         try {
             KeyFactory kf = KeyFactory.getInstance("RSA");
             PKCS8EncodedKeySpec keysp = new PKCS8EncodedKeySpec(keyBytes);
@@ -332,22 +332,22 @@ public class JsseSslProvider implements SslProvider {
     public class TestKeyManager extends X509ExtendedKeyManager {
         X509Certificate cert;
         PrivateKey privKey;
-        
+
         public TestKeyManager(X509Certificate cert2, PrivateKey privKey2) {
             cert = cert2;
             privKey = privKey2;
         }
 
-        public String chooseEngineClientAlias(String[] keyType, 
+        public String chooseEngineClientAlias(String[] keyType,
                 java.security.Principal[] issuers, javax.net.ssl.SSLEngine engine) {
             return "client";
         }
-        
-        public String chooseEngineServerAlias(String keyType, 
+
+        public String chooseEngineServerAlias(String keyType,
                 java.security.Principal[] issuers, javax.net.ssl.SSLEngine engine) {
             return "server";
         }
-        
+
         public String chooseClientAlias(String[] keyType,
                                         Principal[] issuers, Socket socket) {
             return "client";
@@ -367,8 +367,8 @@ public class JsseSslProvider implements SslProvider {
         }
 
         public PrivateKey getPrivateKey(String alias) {
-            
-            return privKey; 
+
+            return privKey;
         }
 
         public String[] getServerAliases(String keyType, Principal[] issuers) {
@@ -377,8 +377,8 @@ public class JsseSslProvider implements SslProvider {
     }
 
     // TODO: add a mode that trust a defined list of certs, like SSH
-    
-    /** 
+
+    /**
      * Make URLConnection accept all certificates.
      * Use only for testing !
      */
@@ -386,7 +386,7 @@ public class JsseSslProvider implements SslProvider {
         try {
             SSLContext sc = SSLContext.getInstance("TLS");
             sc.init(null, JsseSslProvider.trustAllCerts, null);
-            
+
             javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(
                     sc.getSocketFactory());
             javax.net.ssl.HttpsURLConnection.setDefaultHostnameVerifier(
@@ -404,16 +404,16 @@ public class JsseSslProvider implements SslProvider {
                             }
                             return true;
                         }
-                        
+
                     });
-            
+
         } catch (Exception e) {
             e.printStackTrace();
-        } 
+        }
     }
 
     // Utilities
-    public static byte[] getPrivateKeyFromStore(String file, String pass) 
+    public static byte[] getPrivateKeyFromStore(String file, String pass)
             throws Exception {
         KeyStore store = KeyStore.getInstance("JKS");
         store.load(new FileInputStream(file), pass.toCharArray());
@@ -423,7 +423,7 @@ public class JsseSslProvider implements SslProvider {
         return encoded;
     }
 
-    public static byte[] getCertificateFromStore(String file, String pass) 
+    public static byte[] getCertificateFromStore(String file, String pass)
             throws Exception {
         KeyStore store = KeyStore.getInstance("JKS");
         store.load(new FileInputStream(file), pass.toCharArray());
@@ -431,7 +431,7 @@ public class JsseSslProvider implements SslProvider {
 
         return certificate.getEncoded();
     }
-    
+
     public static KeyPair generateRsaOrDsa(boolean rsa) throws Exception {
         if (rsa) {
             KeyPairGenerator keyPairGen =
@@ -455,7 +455,7 @@ public class JsseSslProvider implements SslProvider {
             return pair;
         }
     }
-    
+
     /**
      * I know 2 ways to generate certs:
      *  - keytool

==================================================
CopyCallback.java
index df4425b313..87705dfe08 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/jsse/SslChannel.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/io/jsse/SslChannel.java
@@ -27,17 +27,17 @@ class SslChannel extends IOChannel implements Runnable {
     static Logger log = Logger.getLogger("SSL");
 
     static ByteBuffer EMPTY = ByteBuffer.allocate(0);
-    
+
 
     SSLEngine sslEngine;
     // Last result
     SSLEngineResult unwrapR;
-    
+
     boolean handshakeDone = false;
     boolean handshakeInProgress = false;
     Object handshakeSync = new Object();
     boolean flushing = false;
-    
+
     IOBuffer in = new IOBuffer(this);
     IOBuffer out = new IOBuffer(this);
 
@@ -45,15 +45,15 @@ class SslChannel extends IOChannel implements Runnable {
     // Used for session reuse
     String host;
     int port;
-    
+
     ByteBuffer myAppOutData;
-    ByteBuffer myNetOutData; 
+    ByteBuffer myNetOutData;
     private static boolean debugWrap = false;
 
     /*
      * Special: SSL works in packet mode, and we may receive an incomplete
      * packet. This should be in compacted write mode (i.e. data from 0 to pos,
-     * limit at end )  
+     * limit at end )
      */
     ByteBuffer myNetInData;
     ByteBuffer myAppInData;
@@ -62,15 +62,15 @@ class SslChannel extends IOChannel implements Runnable {
     private SSLContext sslCtx;
 
     private boolean closeHandshake = false;
-    
+
     public SslChannel() {
     }
-    
+
     /**
-     * Setting the host/port enables clients to reuse SSL session - 
-     * less traffic and encryption overhead at startup, assuming the 
+     * Setting the host/port enables clients to reuse SSL session -
+     * less traffic and encryption overhead at startup, assuming the
      * server caches the session ( i.e. single server or distributed cache ).
-     * 
+     *
      * SSL ticket extension is another possibility.
      */
     public SslChannel setTarget(String host, int port) {
@@ -78,13 +78,13 @@ class SslChannel extends IOChannel implements Runnable {
         this.port = port;
         return this;
     }
-    
+
     private synchronized void initSsl() throws GeneralSecurityException {
         if (sslEngine != null) {
             log.severe("Double initSsl");
             return;
         }
-        
+
         if (client) {
             if (port > 0) {
                 sslEngine = sslCtx.createSSLEngine(host, port);
@@ -95,16 +95,16 @@ class SslChannel extends IOChannel implements Runnable {
         } else {
             sslEngine = sslCtx.createSSLEngine();
             sslEngine.setUseClientMode(false);
-            
+
         }
 
         // Some VMs have broken ciphers.
         if (JsseSslProvider.enabledCiphers != null) {
             sslEngine.setEnabledCipherSuites(JsseSslProvider.enabledCiphers);
         }
-        
+
         SSLSession session = sslEngine.getSession();
-    
+
         int packetBuffer = session.getPacketBufferSize();
         myAppOutData = ByteBuffer.allocate(session.getApplicationBufferSize());
         myNetOutData = ByteBuffer.allocate(packetBuffer);
@@ -115,13 +115,13 @@ class SslChannel extends IOChannel implements Runnable {
         myAppInData.flip();
         myAppOutData.flip();
     }
-    
+
     public SslChannel withServer() {
         client = false;
         return this;
     }
-    
-    
+
+
     @Override
     public synchronized void setSink(IOChannel net) throws IOException {
         try {
@@ -133,7 +133,7 @@ class SslChannel extends IOChannel implements Runnable {
             log.log(Level.SEVERE, "Error initializing ", e);
         }
     }
-    
+
     @Override
     public IOBuffer getIn() {
         return in;
@@ -143,14 +143,14 @@ class SslChannel extends IOChannel implements Runnable {
     public IOBuffer getOut() {
         return out;
     }
-    
+
     /**
      * Typically called when a dataReceived callback is passed up.
-     * It's up to the higher layer to decide if it can handle more data 
+     * It's up to the higher layer to decide if it can handle more data
      * and disable read interest and manage its buffers.
-     * 
+     *
      * We have to use one buffer.
-     * @throws IOException 
+     * @throws IOException
      */
     public int processInput(IOBuffer netIn, IOBuffer appIn) throws IOException {
         if (log.isLoggable(Level.FINEST)) {
@@ -160,15 +160,15 @@ class SslChannel extends IOChannel implements Runnable {
             if (!handshakeDone && !handshakeInProgress) {
                 handshakeInProgress = true;
                 handleHandshking();
-                return 0; 
-            }            
+                return 0;
+            }
             if (handshakeInProgress) {
                 return 0; // leave it there
             }
         }
         return processRealInput(netIn, appIn);
     }
-    
+
     private synchronized int processRealInput(IOBuffer netIn, IOBuffer appIn) throws IOException {
         int rd = 0;
         boolean needsMore = true;
@@ -187,7 +187,7 @@ class SslChannel extends IOChannel implements Runnable {
             } finally {
                 myNetInData.flip();
             }
-            if (rdNow == 0 && (myNetInData.remaining() == 0 || 
+            if (rdNow == 0 && (myNetInData.remaining() == 0 ||
                     notEnough)) {
                 return rd;
             }
@@ -221,14 +221,14 @@ class SslChannel extends IOChannel implements Runnable {
                             closeHandshake  = true;
                         }
                         handleHandshking();
-                        
+
                         startSending();
                     }
                     break;
                 }
-                
+
                 if (unwrapR.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {
-                    tasks();                    
+                    tasks();
                 }
                 if (unwrapR.getStatus() == Status.BUFFER_OVERFLOW) {
                     log.severe("Unhandled overflow " + unwrapR);
@@ -241,8 +241,8 @@ class SslChannel extends IOChannel implements Runnable {
                 }
             }
             sendHandleReceivedCallback();
-            
-            
+
+
         }
         return rd;
     }
@@ -256,7 +256,7 @@ class SslChannel extends IOChannel implements Runnable {
     }
 
     public void startSending() throws IOException {
-        
+
         flushing = true;
         boolean needHandshake = false;
         synchronized(handshakeSync) {
@@ -270,12 +270,12 @@ class SslChannel extends IOChannel implements Runnable {
         }
         if (needHandshake) {
             handleHandshking();
-            return; // can't write yet.            
+            return; // can't write yet.
         }
-        
+
         startRealSending();
     }
-    
+
     public void close() throws IOException {
         if (net.getOut().isAppendClosed()) {
             return;
@@ -303,16 +303,16 @@ class SslChannel extends IOChannel implements Runnable {
         // clean close handshake
         super.close();
     }
-    
+
     private Object sendLock = new Object();
 
     private JsseSslProvider sslProvider;
-    
+
     private void startRealSending() throws IOException {
         // Only one thread at a time
         synchronized (sendLock) {
             while (true) {
-                
+
                 myAppOutData.compact();
                 int rd;
                 try {
@@ -332,7 +332,7 @@ class SslChannel extends IOChannel implements Runnable {
                 synchronized(myNetOutData) {
                     myNetOutData.compact();
                     try {
-                        wrap = sslEngine.wrap(myAppOutData, 
+                        wrap = sslEngine.wrap(myAppOutData,
                                 myNetOutData);
                     } finally {
                         myNetOutData.flip();
@@ -354,33 +354,33 @@ class SslChannel extends IOChannel implements Runnable {
                 }
             }
         }
-        
+
         net.startSending();
     }
 
 
-    // SSL handshake require slow tasks - that will need to be executed in a 
-    // thread anyways. Better to keep it simple ( the code is very complex ) - 
+    // SSL handshake require slow tasks - that will need to be executed in a
+    // thread anyways. Better to keep it simple ( the code is very complex ) -
     // and do the initial handshake in a thread, not in the IO thread.
     // We'll need to unregister and register again from the selector.
-    private void handleHandshking() { 
+    private void handleHandshking() {
         if (log.isLoggable(Level.FINEST)) {
             log.info("Starting handshake");
         }
         synchronized(handshakeSync) {
-            handshakeInProgress = true;            
+            handshakeInProgress = true;
         }
 
         sslProvider.handshakeExecutor.execute(this);
     }
-    
+
     private void endHandshake() throws IOException {
         if (log.isLoggable(Level.FINEST)) {
             log.info("Handshake done " + net.getIn().available());
         }
         synchronized(handshakeSync) {
             handshakeDone = true;
-            handshakeInProgress = false;            
+            handshakeInProgress = false;
         }
         if (flushing) {
             flushing = false;
@@ -401,16 +401,16 @@ class SslChannel extends IOChannel implements Runnable {
             SSLEngineResult wrap = null;
 
             HandshakeStatus hstatus = sslEngine.getHandshakeStatus();
-            if (!closeHandshake && 
+            if (!closeHandshake &&
                     (hstatus == HandshakeStatus.NOT_HANDSHAKING || initial)) {
                 sslEngine.beginHandshake();
                 hstatus = sslEngine.getHandshakeStatus();
             }
-            
+
             long t0 = System.currentTimeMillis();
-            
-            while (hstatus != HandshakeStatus.NOT_HANDSHAKING 
-                    && hstatus != HandshakeStatus.FINISHED 
+
+            while (hstatus != HandshakeStatus.NOT_HANDSHAKING
+                    && hstatus != HandshakeStatus.FINISHED
                     && !net.getIn().isAppendClosed()) {
                 if (System.currentTimeMillis() - t0 > handshakeTimeout) {
                     throw new TimeoutException();
@@ -422,7 +422,7 @@ class SslChannel extends IOChannel implements Runnable {
                     log.info("-->doHandshake() loop: status = " + hstatus + " " +
                             sslEngine.getHandshakeStatus());
                 }
-                
+
                 if (hstatus == HandshakeStatus.NEED_WRAP) {
                     // || initial - for client
                     initial = false;
@@ -463,8 +463,8 @@ class SslChannel extends IOChannel implements Runnable {
                                 break;
                             }
                         }
-                        // Still need unwrap 
-                        if (wrap == null 
+                        // Still need unwrap
+                        if (wrap == null
                                 || wrap.getStatus() == Status.BUFFER_UNDERFLOW
                                 || (hstatus == HandshakeStatus.NEED_UNWRAP && myNetInData.remaining() == 0)) {
                             myNetInData.compact();
@@ -494,12 +494,12 @@ class SslChannel extends IOChannel implements Runnable {
                             }
                         }
                         if (log.isLoggable(Level.FINEST)) {
-                            log.info("Unwrap chunk done " + hstatus + " " + wrap 
+                            log.info("Unwrap chunk done " + hstatus + " " + wrap
                                 + " " + sslEngine.getHandshakeStatus());
                         }
 
                     }
-                    
+
                     // rd may have some input bytes.
                 } else if (hstatus == HandshakeStatus.NEED_TASK) {
                     long t0task = System.currentTimeMillis();
@@ -513,7 +513,7 @@ class SslChannel extends IOChannel implements Runnable {
                         log.info("Tasks done in " + (t1task - t0task) + " new status " +
                                 hstatus);
                     }
-                    
+
                 }
                 if (hstatus == HandshakeStatus.NOT_HANDSHAKING) {
                     //log.warning("NOT HANDSHAKING " + this);
@@ -529,7 +529,7 @@ class SslChannel extends IOChannel implements Runnable {
                 net.close();
                 sendHandleReceivedCallback();
             } catch (IOException ex) {
-                log.log(Level.SEVERE, "Error closing", ex);                
+                log.log(Level.SEVERE, "Error closing", ex);
             }
         }
     }
@@ -546,12 +546,12 @@ class SslChannel extends IOChannel implements Runnable {
         this.sslCtx = sslCtx;
         return this;
     }
-    
+
     SslChannel setSslProvider(JsseSslProvider con) {
         this.sslProvider = con;
         return this;
     }
-    
+
     public Object getAttribute(String name) {
         if (SslProvider.ATT_SSL_CERT.equals(name)) {
             try {
@@ -576,7 +576,7 @@ class SslChannel extends IOChannel implements Runnable {
             return size;
         } else if (SslProvider.ATT_SSL_SESSION_ID.equals(name)) {
             byte [] ssl_session = sslEngine.getSession().getId();
-            if ( ssl_session == null) 
+            if ( ssl_session == null)
                 return null;
             StringBuilder buf=new StringBuilder();
             for(int x=0; x<ssl_session.length; x++) {
@@ -587,14 +587,14 @@ class SslChannel extends IOChannel implements Runnable {
             }
             return buf.toString();
         }
-        
+
         if (net != null) {
             return net.getAttribute(name);
         }
-        return null;        
+        return null;
     }
-    
-    
+
+
      /**
       * Simple data class that represents the cipher being used, along with the
       * corresponding effective key size.  The specified phrase must appear in the
@@ -613,8 +613,8 @@ class SslChannel extends IOChannel implements Runnable {
          }
 
      }
-     
-    
+
+
      /**
       * A mapping table to determine the number of effective bits in the key
       * when using a cipher suite containing the specified cipher name.  The
@@ -632,5 +632,5 @@ class SslChannel extends IOChannel implements Runnable {
          new CipherData("_WITH_AES_128_CBC_", 128),
          new CipherData("_WITH_AES_256_CBC_", 256)
      };
-          
+
 }

==================================================
HttpProxyService.java
index 2372859efe..cfb499d249 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/proxy/CopyCallback.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/proxy/CopyCallback.java
@@ -11,12 +11,12 @@ import org.apache.tomcat.lite.io.IOChannel;
 import org.apache.tomcat.lite.io.IOConnector;
 
 /**
- *  Used by socks and http proxy. Will copy received data to a different 
+ *  Used by socks and http proxy. Will copy received data to a different
  *  channel.
  */
 public class CopyCallback implements IOConnector.DataReceivedCallback {
         IOChannel mOutBuffer;
-        
+
         public CopyCallback(IOChannel sc) {
             mOutBuffer = sc;
         }
@@ -27,7 +27,7 @@ public class CopyCallback implements IOConnector.DataReceivedCallback {
             IOChannel outBuffer = mOutBuffer;
             if (outBuffer == null &&
                     ch instanceof HttpChannel) {
-                outBuffer = 
+                outBuffer =
                     (IOChannel) ((HttpChannel)ch).getRequest().getAttribute("P");
             }
             // body.
@@ -52,6 +52,6 @@ public class CopyCallback implements IOConnector.DataReceivedCallback {
                     outBuffer.startSending();
                     return;
                 }
-            }            
+            }
         }
     }
\ No newline at end of file

==================================================
ProxyFlushedCallback.java
index 63b17375ae..6c426b78a0 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/proxy/HttpProxyService.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/proxy/HttpProxyService.java
@@ -19,62 +19,62 @@ import org.apache.tomcat.lite.io.IOConnector;
 import org.apache.tomcat.lite.io.CBuffer;
 import org.apache.tomcat.lite.io.SocketConnector;
 
-/** 
- * Http callback for the server-side. Will forward all requests to 
- * a remote http server - either using proxy mode ( GET http://... ) or 
+/**
+ * Http callback for the server-side. Will forward all requests to
+ * a remote http server - either using proxy mode ( GET http://... ) or
  * forward requests ( GET /foo -> will be served by the remote server ).
- * 
+ *
  * This is not blocking (except the connect, which currenly blocks on dns).
  */
 public class HttpProxyService implements HttpService {
 
-    // target - when used in forwarding mode. 
+    // target - when used in forwarding mode.
     String target = "localhost";
     int port = 8802;
-    
+
     static Logger log = Logger.getLogger("HttpProxy");
     public static boolean debug = false;
     boolean keepOpen = true;
-    
+
     // client side - this connect to the real server that generates the resp.
     ProxyClientCallback clientHeadersReceived = new ProxyClientCallback();
 
     HttpConnector httpConnector;
     IOConnector ioConnector;
-    
+
     public HttpProxyService withSelector(IOConnector pool) {
         this.ioConnector = pool;
         return this;
     }
-    
+
     public HttpProxyService withHttpClient(HttpConnector pool) {
         this.httpConnector = pool;
         return this;
     }
-    
+
     public HttpProxyService withTarget(String host, int port) {
         this.target = host;
         this.port = port;
         return this;
     }
-    
-    private IOConnector getSelector() { 
+
+    private IOConnector getSelector() {
         if (ioConnector == null) {
-            ioConnector = new SocketConnector(); 
+            ioConnector = new SocketConnector();
         }
         return ioConnector;
     }
 
-    private HttpConnector getHttpConnector() { 
+    private HttpConnector getHttpConnector() {
         if (httpConnector == null) {
             httpConnector = new HttpConnector(getSelector());
         }
         return httpConnector;
     }
-    
-    // Connects to the target CONNECT server, as client, forwards 
+
+    // Connects to the target CONNECT server, as client, forwards
     static class ProxyConnectClientConnection implements IOConnector.ConnectedCallback {
-        
+
         IOChannel serverNet;
         private HttpChannel serverHttp;
 
@@ -91,17 +91,17 @@ public class HttpProxyService implements HttpService {
                 return;
             }
             afterClientConnect(ioch);
-            
+
             ioch.setDataReceivedCallback(new CopyCallback(serverNet));
             //ioch.setDataFlushedCallback(new ProxyFlushedCallback(serverNet, ioch));
             serverNet.setDataReceivedCallback(new CopyCallback(ioch));
             //serverNet.setDataFlushedCallback(new ProxyFlushedCallback(ioch, serverNet));
 
             ioch.sendHandleReceivedCallback();
-        }        
-        
+        }
+
         static byte[] OK = "HTTP/1.1 200 OK\r\n\r\n".getBytes();
-        
+
         protected void afterClientConnect(IOChannel clientCh) throws IOException {
             serverNet.getOut().queue(OK);
             serverNet.startSending();
@@ -109,17 +109,17 @@ public class HttpProxyService implements HttpService {
             serverHttp.release(); // no longer used
         }
     }
-    
+
     /**
      * Parse the req, dispatch the connection.
      */
     @Override
-    public void service(HttpRequest serverHttpReq, HttpResponse serverHttpRes) 
+    public void service(HttpRequest serverHttpReq, HttpResponse serverHttpRes)
             throws IOException {
-        
+
         String dstHost = target; // default target ( for normal req ).
         int dstPort = port;
-        
+
         // TODO: more flexibility/callbacks on selecting the target, acl, etc
         if (serverHttpReq.method().equals("CONNECT")) {
             // SSL proxy - just connect and forward all packets
@@ -132,14 +132,14 @@ public class HttpProxyService implements HttpService {
             }
             if (log.isLoggable(Level.FINE)) {
                 HttpChannel server = serverHttpReq.getHttpChannel();
-                log.info("NEW: " + server.getId() + " " + dstHost + " "  + 
-                        server.getRequest().getMethod() + 
+                log.info("NEW: " + server.getId() + " " + dstHost + " "  +
+                        server.getRequest().getMethod() +
                         " " + server.getRequest().getRequestURI() + " " +
                         server.getIn());
             }
-    
+
             try {
-                getSelector().connect(host, port, 
+                getSelector().connect(host, port,
                         new ProxyConnectClientConnection(serverHttpReq.getHttpChannel()));
             } catch (IOException e) {
                 // TODO Auto-generated catch block
@@ -147,8 +147,8 @@ public class HttpProxyService implements HttpService {
             }
             return;
         }
-        
-        
+
+
         CBuffer origURIx = serverHttpReq.requestURI();
 //        String origURI = origURIx.toString();
 //        if (origURI.startsWith("http://")) {
@@ -161,7 +161,7 @@ public class HttpProxyService implements HttpService {
 //            String[] hostPort = hostPortS.split(":");
 //
 //            dstHost = hostPort[0];
-//            dstPort = (hostPort.length > 1) ? Integer.parseInt(hostPort[1]) : 
+//            dstPort = (hostPort.length > 1) ? Integer.parseInt(hostPort[1]) :
 //                80;
 //
 //            if (start >= 0) {
@@ -171,7 +171,7 @@ public class HttpProxyService implements HttpService {
 //            }
 //        } else {
             // Adjust the host header.
-            CBuffer hostHdr = 
+            CBuffer hostHdr =
                 serverHttpReq.getMimeHeaders().getHeader("host");
             if (hostHdr != null) {
                 hostHdr.recycle();
@@ -185,52 +185,52 @@ public class HttpProxyService implements HttpService {
 //        }
         if (debug) {
             HttpChannel server = serverHttpReq.getHttpChannel();
-            log.info("START: " + server.getId() + " " + dstHost + " "  + 
-                    server.getRequest().getMethod() + 
+            log.info("START: " + server.getId() + " " + dstHost + " "  +
+                    server.getRequest().getMethod() +
                     " " + server.getRequest().getRequestURI() + " " +
                     server.getIn());
         }
-        
+
         // Send the request with a non-blocking write
-        HttpChannel serverHttp = serverHttpReq.getHttpChannel(); 
-        
+        HttpChannel serverHttp = serverHttpReq.getHttpChannel();
+
         // Client connection
         HttpChannel httpClient = getHttpConnector().get(dstHost, dstPort);
-        
+
         serverHttp.getRequest().setAttribute("CLIENT", httpClient);
         httpClient.getRequest().setAttribute("SERVER", serverHttp);
         serverHttp.getRequest().setAttribute("P", httpClient);
         httpClient.getRequest().setAttribute("P", serverHttp);
-        
+
         httpClient.setHttpService(clientHeadersReceived);
-        
-        // Will send the original request (TODO: small changes) 
+
+        // Will send the original request (TODO: small changes)
         // Response is not affected ( we use the callback )
         httpClient.getRequest().method().set(serverHttp.getRequest().method());
         httpClient.getRequest().requestURI().set(serverHttp.getRequest().requestURI());
         if (serverHttp.getRequest().queryString().length() != 0) {
             httpClient.getRequest().queryString().set(serverHttp.getRequest().queryString());
         }
-        
+
         httpClient.getRequest().protocol().set(serverHttp.getRequest().protocol());
-        
+
         //cstate.reqHeaders.addValue(name)
-        copyHeaders(serverHttp.getRequest().getMimeHeaders(), 
+        copyHeaders(serverHttp.getRequest().getMimeHeaders(),
                 httpClient.getRequest().getMimeHeaders() /*dest*/);
-        
+
         // For debug
         httpClient.getRequest().getMimeHeaders().remove("Accept-Encoding");
-        
+
         if (!keepOpen) {
             httpClient.getRequest().getMimeHeaders().setValue("Connection").set("Close");
         }
-        
+
         // Any data
         serverHttp.setDataReceivedCallback(copy);
         copy.handleReceived(serverHttp);
 
         httpClient.send();
-        
+
 
         //serverHttp.handleReceived(serverHttp.getSink());
         //httpClient.flush(); // send any data still there
@@ -238,14 +238,14 @@ public class HttpProxyService implements HttpService {
         httpClient.setCompletedCallback(done);
         // Will call release()
         serverHttp.setCompletedCallback(done);
-        
+
         serverHttpReq.async();
     }
-    
+
     static HttpDoneCallback done = new HttpDoneCallback();
     static CopyCallback copy = new CopyCallback(null);
     // POST: after sendRequest(ch) we need to forward the body !!
-    
+
 
     static void copyHeaders(MultiMap mimeHeaders, MultiMap dest)
             throws IOException {
@@ -256,38 +256,38 @@ public class HttpProxyService implements HttpService {
         }
     }
 
-    /** 
+    /**
      * HTTP _CLIENT_ callback - from tomcat to final target.
      */
     public class ProxyClientCallback implements HttpService {
-        /** 
+        /**
          * Headers received from the client (content http server).
          * TODO: deal with version missmatches.
          */
         @Override
         public void service(HttpRequest clientHttpReq, HttpResponse clientHttpRes) throws IOException {
-            HttpChannel serverHttp = (HttpChannel) clientHttpReq.getAttribute("SERVER"); 
-            
+            HttpChannel serverHttp = (HttpChannel) clientHttpReq.getAttribute("SERVER");
+
             try {
                 serverHttp.getResponse().setStatus(clientHttpRes.getStatus());
                 serverHttp.getResponse().getMessageBuffer().set(clientHttpRes.getMessageBuffer());
-                copyHeaders(clientHttpRes.getMimeHeaders(), 
+                copyHeaders(clientHttpRes.getMimeHeaders(),
                         serverHttp.getResponse().getMimeHeaders());
-                
+
                 serverHttp.getResponse().getMimeHeaders().addValue("TomcatProxy").set("True");
 
                 clientHttpReq.getHttpChannel().setDataReceivedCallback(copy);
                 copy.handleReceived(clientHttpReq.getHttpChannel());
 
                 serverHttp.startSending();
-                
-                
+
+
                 //clientHttpReq.flush(); // send any data still there
-                
+
                 //  if (clientHttpReq.getHttpChannel().getIn().isClosedAndEmpty()) {
                 //     serverHttp.getOut().close(); // all data from client already in buffers
                 //  }
-                
+
             } catch (IOException e) {
                 // TODO Auto-generated catch block
                 e.printStackTrace();
@@ -302,13 +302,13 @@ public class HttpProxyService implements HttpService {
 
         @Override
         public void handle(HttpChannel doneCh, Object extraData) throws IOException {
-            HttpChannel serverCh = 
+            HttpChannel serverCh =
                 (HttpChannel) doneCh.getRequest().getAttribute("SERVER");
             HttpChannel clientCh = doneCh;
             String tgt = "C";
             if (serverCh == null) {
                  serverCh = doneCh;
-                 clientCh = 
+                 clientCh =
                     (HttpChannel) doneCh.getRequest().getAttribute("CLIENT");
                  tgt = "S";
             }
@@ -320,34 +320,34 @@ public class HttpProxyService implements HttpService {
                 clientCh.abort("Proxy error");
                 return;
             }
-            
+
             if (log.isLoggable(Level.FINE)) {
-                HttpChannel peerCh = 
-                    (HttpChannel) doneCh.getRequest().getAttribute("SERVER"); 
+                HttpChannel peerCh =
+                    (HttpChannel) doneCh.getRequest().getAttribute("SERVER");
                 if (peerCh == null) {
-                    peerCh = 
+                    peerCh =
                         (HttpChannel) doneCh.getRequest().getAttribute("CLIENT");
                 } else {
-                    
+
                 }
                 log.info(tgt + " " + peerCh.getId() + " " +
                         doneCh.getTarget() + " " +
-                        doneCh.getRequest().getMethod() + 
+                        doneCh.getRequest().getMethod() +
                         " " + doneCh.getRequest().getRequestURI() + " " +
                         doneCh.getResponse().getStatus() + " IN:" + doneCh.getIn()
-                        + " OUT:" + doneCh.getOut() + 
-                        " SIN:" + peerCh.getIn() +  
-                        " SOUT:" + peerCh.getOut() ); 
+                        + " OUT:" + doneCh.getOut() +
+                        " SIN:" + peerCh.getIn() +
+                        " SOUT:" + peerCh.getOut() );
             }
             // stop forwarding. After this call the client object will be
             // recycled
             //clientCB.outBuffer = null;
-            
+
             // We must releaes both at same time
             synchronized (this) {
-                
+
                 serverCh.complete();
-                
+
                 if (clientCh.getRequest().getAttribute("SERVER") == null) {
                     return;
                 }
@@ -364,5 +364,5 @@ public class HttpProxyService implements HttpService {
         }
     }
 
-    
+
 }

==================================================
SocksServer.java
index 05df0ca5e6..63fb18ba90 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/proxy/ProxyFlushedCallback.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/proxy/ProxyFlushedCallback.java
@@ -9,7 +9,7 @@ import org.apache.tomcat.lite.io.IOConnector;
 
 public final class ProxyFlushedCallback implements IOConnector.DataFlushedCallback {
     IOChannel peerCh;
-    
+
     public ProxyFlushedCallback(IOChannel ch2, IOChannel clientChannel2) {
         peerCh = ch2;
     }

==================================================
StaticContentService.java
index 8170afed16..ad683459de 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/proxy/SocksServer.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/proxy/SocksServer.java
@@ -22,54 +22,54 @@ import org.apache.tomcat.lite.io.IOConnector;
 import org.apache.tomcat.lite.io.SocketConnector;
 
 /**
- * A test for the selector package, and helper for the proxy - 
+ * A test for the selector package, and helper for the proxy -
  * a SOCKS4a server.
- * 
- * Besides the connection initialization, it's almost the 
+ *
+ * Besides the connection initialization, it's almost the
  *  same as the CONNECT method in http proxy.
- * 
+ *
  * http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol
  * http://www.smartftp.com/Products/SmartFTP/RFC/socks4a.protocol
  * http://www.faqs.org/rfcs/rfc1928.html
  * https://svn.torproject.org/svn/tor/trunk/doc/spec/socks-extensions.txt
- * 
+ *
  * In firefox, set network.proxy.socks_remote_dns = true to do DNS via proxy.
- * 
+ *
  * Also interesting:
  * http://transocks.sourceforge.net/
- * 
+ *
  * @author Costin Manolache
  */
 public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
     protected int port = 2080;
-    
+
     protected IOConnector ioConnector;
     protected static Logger log = Logger.getLogger("SocksServer");
-    
-    protected long idleTimeout = 10 * 60000; // 10 min 
-    
+
+    protected long idleTimeout = 10 * 60000; // 10 min
+
     protected long lastConnection = 0;
     protected long totalConTime = 0;
     protected AtomicInteger totalConnections = new AtomicInteger();
-    
+
     protected AtomicInteger active = new AtomicInteger();
-    
+
     protected long inBytes;
     protected long outBytes;
     protected static int sockets;
-    
+
     public int getPort() {
         return port;
     }
-    
+
     public int getActive() {
         return active.get();
     }
-    
+
     public int getTotal() {
         return totalConnections.get();
     }
-    
+
     public void setPort(int port) {
         this.port = port;
     }
@@ -83,46 +83,46 @@ public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
         final SocksServerConnection socksCon = new SocksServerConnection(accepted);
         socksCon.pool = ioConnector;
         socksCon.server = this;
-        
+
         accepted.setDataReceivedCallback(socksCon);
         socksCon.handleReceived(accepted);
     }
 
-    /** 
-     * Exit if no activity happens. 
+    /**
+     * Exit if no activity happens.
      */
     public void setIdleTimeout(long to) {
         idleTimeout = to;
     }
-    
+
     public long getIdleTimeout() {
         return idleTimeout;
     }
-    
+
     public void stop() {
         ioConnector.stop();
     }
-    
+
     public void initServer() throws IOException {
         if (ioConnector == null) {
             ioConnector = new SocketConnector();
         }
         ioConnector.acceptor(this, Integer.toString(port), null);
-        
+
         final Timer timer = new Timer(true /* daemon */);
         timer.scheduleAtFixedRate(new TimerTask() {
             @Override
             public void run() {
                 try {
                 // if lastConnection == 0 - it'll terminate on first timer
-                float avg = (totalConnections.get() > 0) ? 
+                float avg = (totalConnections.get() > 0) ?
                         totalConTime / totalConnections.get() : 0;
-                System.err.println("Socks:" 
+                System.err.println("Socks:"
                         + "\ttotal=" + totalConnections
-                        + "\tin=" + inBytes  
+                        + "\tin=" + inBytes
                         + "\tout=" + outBytes
                         + "\tavg=" + (int) avg);
-                if (active.get() <= 0 
+                if (active.get() <= 0
                         && idleTimeout > 0
                         && System.currentTimeMillis() - lastConnection > idleTimeout) {
                     System.err.println("Idle timeout");
@@ -135,21 +135,21 @@ public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
                 }
             }
         }, 5 * 60 * 1000, 5 * 60 * 1000); // 5
-        
-        
+
+
     }
 
 
     public static class SocksServerConnection implements IOConnector.DataReceivedCallback, IOConnector.ConnectedCallback {
-        
+
         protected SocksServer server;
 
         boolean headReceived;
         boolean head5Received = false;
-        
+
         ByteBuffer headBuffer = ByteBuffer.allocate(256);
         ByteBuffer headReadBuffer = headBuffer.duplicate();
-        
+
         ByteBuffer headResBuffer = ByteBuffer.allocate(256);
         IOConnector pool;
         byte ver;
@@ -158,18 +158,18 @@ public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
 
         static final int CMD_CONNECT = 0;
         static final byte CMD_RESOLVE = (byte) 0xF0;
-        
+
         int port;
         byte[] hostB = new byte[4];
         CharBuffer userId = CharBuffer.allocate(256);
         CharBuffer hostName = CharBuffer.allocate(256);
-        
+
         SocketAddress sa = null;
 
         private byte atyp;
 
         IOChannel serverCh;
-        
+
         public SocksServerConnection(IOChannel accepted) {
             this.serverCh = accepted;
         }
@@ -187,17 +187,17 @@ public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
                 headResBuffer.put((byte) 0);
                 headResBuffer.put((byte) 0);
                 headResBuffer.put((byte) 1); // ip
-                
+
                 headResBuffer.put(hostB);
                 int port2 = (Integer) clientCh.getAttribute(IOChannel.ATT_REMOTE_PORT);
                 headResBuffer.putShort((short) port2);
             }
-            
+
             headResBuffer.flip();
-            
+
             serverCh.getOut().queue(headResBuffer);
             log.fine("Connected " + sa.toString());
-            
+
             if (headReadBuffer.remaining() > 0) {
                 serverCh.getOut().queue(headReadBuffer);
             }
@@ -212,7 +212,7 @@ public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
                 server.active.set(0);
             }
 //            System.err.println(sa + "\tsR:" +
-//                    received 
+//                    received
 //                    + "\tcR:" + clientReceived
 //                    + "\tactive:" + a
 //                    + "\ttotC:" + server.totalConnections
@@ -222,16 +222,16 @@ public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
 //            server.outBytes += clientReceived;
         }
 
-        
+
         protected int parseHead() throws IOException {
-            // data is between 0 and pos. 
+            // data is between 0 and pos.
             int pos = headBuffer.position();
             headReadBuffer.clear();
             headReadBuffer.limit(pos);
             if (headReadBuffer.remaining() < 2) {
                 return -1;
             }
-            
+
             ByteBuffer bb = headReadBuffer;
             ver = bb.get();
             if (ver == 5) {
@@ -260,23 +260,23 @@ public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
             } else {
                 atyp = 1;
             }
-            
+
             headReceived = true;
-            
+
             return 4;
         }
 
         protected int parseHead5_2() throws IOException {
-            // data is between 0 and pos. 
+            // data is between 0 and pos.
             int pos = headBuffer.position();
-            
+
             headReadBuffer.clear();
             headReadBuffer.limit(pos);
-            
+
             if (headReadBuffer.remaining() < 7) {
                 return -1;
             }
-            
+
             ByteBuffer bb = headReadBuffer;
             ver = bb.get();
             cmd = bb.get();
@@ -291,11 +291,11 @@ public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
                     return rc;
                 }
             } // ip6 not supported right now, easy to add
-            
+
             port = bb.getShort();
-            
+
             head5Received = true;
-            
+
             return 5;
         }
 
@@ -306,7 +306,7 @@ public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
                 return -1;
             }
             for (int i = 0; i < nrMethods; i++) {
-                // ignore 
+                // ignore
                 bb.get();
             }
             return 5;
@@ -341,18 +341,18 @@ public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
             bc.flip();
             return len;
         }
-        
+
         static ExecutorService connectTP = Executors.newCachedThreadPool();
-        
+
         protected void startClientConnection() throws IOException {
             // TODO: use different thread ?
             if (atyp == 3) {
                 connectTP.execute(new Runnable() {
-                    
+
                     public void run() {
                         try {
                             sa = new InetSocketAddress(hostName.toString(), port);
-                            pool.connect(hostName.toString(), port, 
+                            pool.connect(hostName.toString(), port,
                                     SocksServerConnection.this);
                         } catch (Exception ex) {
                             log.severe("Error connecting");
@@ -361,10 +361,10 @@ public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
                 });
             } else {
                 InetAddress addr = InetAddress.getByAddress(hostB);
-                pool.connect(addr.toString(), port, this); 
+                pool.connect(addr.toString(), port, this);
             } // TODO: ip6
         }
-        
+
         public void handleConnected(IOChannel ioch) throws IOException {
             ioch.setDataReceivedCallback(new CopyCallback(serverCh));
             //ioch.setDataFlushedCallback(new ProxyFlushedCallback(serverCh, ioch));
@@ -375,7 +375,7 @@ public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
             afterClientConnect(ioch);
 
             ioch.sendHandleReceivedCallback();
-        }        
+        }
 
 
         @Override
@@ -390,7 +390,7 @@ public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
                     if (rd == -1) {
                         ch.close();
                     }
-                    
+
                     rd = parseHead();
                     if (rd < 0) {
                         return; // need more
@@ -411,7 +411,7 @@ public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
                         startClientConnection();
                     }
                 }
-                
+
                 if (!head5Received) {
                     int rd = ch.read(headBuffer);
                     if (rd == 0) {
@@ -420,17 +420,17 @@ public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
                     if (rd == -1) {
                         ch.close();
                     }
-                    
+
                     rd = parseHead5_2();
                     if (rd < 0) {
                         return; // need more
                     }
-                    
-                    startClientConnection();                
+
+                    startClientConnection();
                 }
-        }        
+        }
     }
-    
+
     @Override
     public void run() {
         try {

==================================================
IOStatus.java
index c45b2110de..e50e73e091 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/proxy/StaticContentService.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/proxy/StaticContentService.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -28,22 +28,22 @@ import org.apache.tomcat.lite.io.BBucket;
 import org.apache.tomcat.lite.io.IOBuffer;
 
 /*
- * 
- * Serve static content, from memory. 
+ *
+ * Serve static content, from memory.
  */
 public class StaticContentService implements HttpService  {
     protected Logger log = Logger.getLogger("coyote.static");
     protected BBucket mb;
-    
+
     protected boolean chunked = false;
     int code = 200;
-    
+
     protected String contentType = "text/plain";
 
 
     public StaticContentService() {
     }
-    
+
     /**
      * Used for testing chunked encoding.
      * @return
@@ -56,8 +56,8 @@ public class StaticContentService implements HttpService  {
     public StaticContentService setData(byte[] data) {
         mb = BBuffer.wrapper(data, 0, data.length);
         return this;
-    }    
-    
+    }
+
     public StaticContentService setStatus(int status) {
         this.code = status;
         return this;
@@ -71,7 +71,7 @@ public class StaticContentService implements HttpService  {
         mb = BBuffer.wrapper(data, 0, data.length);
         return this;
       }
-      
+
 
     public StaticContentService setData(CharSequence data) {
       try {
@@ -81,18 +81,18 @@ public class StaticContentService implements HttpService  {
       } catch (IOException e) {
       }
       return this;
-    }    
+    }
 
     public StaticContentService setContentType(String ct) {
       this.contentType = ct;
       return this;
     }
-    
+
     public void setFile(String path) {
       try {
         FileInputStream fis = new FileInputStream(path);
         BBuffer bc = BBuffer.allocate(4096);
-        
+
         byte b[] = new byte[4096];
         int rd = 0;
         while ((rd = fis.read(b)) > 0) {
@@ -103,20 +103,20 @@ public class StaticContentService implements HttpService  {
         throw new RuntimeException(e);
       }
     }
-    
+
     @Override
     public void service(HttpRequest httpReq, HttpResponse res) throws IOException {
-       
+
         res.setStatus(code);
-      
+
           if (!chunked) {
             res.setContentLength(mb.remaining());
           }
           res.setContentType(contentType);
-      
+
           int len = mb.remaining();
           int first = 0;
-          
+
           if (chunked) {
               first = len / 2;
               res.getBody()

==================================================
LogConfig.java
index fe5a65070f..0623e8d04f 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/service/IOStatus.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/service/IOStatus.java
@@ -24,13 +24,13 @@ public class IOStatus implements HttpService {
     public IOStatus(HttpConnectionPool pool) {
         this.pool = pool;
     }
-    
+
     @Override
     public void service(HttpRequest httpReq, HttpResponse httpRes)
             throws IOException {
         HttpConnectionPool sc = pool;
         HttpWriter out = httpRes.getBodyWriter();
-        
+
         httpRes.setContentType("text/plain");
         // TODO: use JMX/DynamicObject to get all public info
         out.println("hosts=" + sc.getTargetCount());
@@ -45,7 +45,7 @@ public class IOStatus implements HttpService {
             out.println(Integer.toString(connections.size()));
 
             for (IOChannel ch: connections) {
-                out.println(ch.getId() + 
+                out.println(ch.getId() +
                         " " + ch.toString());
             }
             out.println();

==================================================
FastHttpDateFormat.java
index ab5a3d207d..b3b99a810f 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/service/LogConfig.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/service/LogConfig.java
@@ -6,15 +6,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */ 
+ */
 
 package org.apache.tomcat.lite.service;
 
@@ -28,14 +28,14 @@ import org.apache.tomcat.lite.http.HttpChannel.HttpService;
 
 /**
  * Log configuration
- * 
+ *
  */
 public class LogConfig implements HttpService {
-    
+
     /**
      * Framework can set this attribute with comma separated
      * list of loggers to set to debug level.
-     * This is used at startup. 
+     * This is used at startup.
      */
     public void setDebug(String debug) {
         for (String log : debug.split(",")) {
@@ -45,7 +45,7 @@ public class LogConfig implements HttpService {
     }
 
     /**
-     * 
+     *
      */
     public void setWarn(String nodebug) {
         for (String log : nodebug.split(",")) {

==================================================
LocaleParser.java
index fe3c69a40b..5f76152328 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/util/FastHttpDateFormat.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/util/FastHttpDateFormat.java
@@ -27,7 +27,7 @@ import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * Utility class to generate HTTP dates.
- * 
+ *
  * @author Remy Maucherat
  */
 public final class FastHttpDateFormat {
@@ -36,14 +36,14 @@ public final class FastHttpDateFormat {
     // -------------------------------------------------------------- Variables
 
 
-    protected static final int CACHE_SIZE = 
+    protected static final int CACHE_SIZE =
         Integer.parseInt(System.getProperty("org.apache.tomcat.util.http.FastHttpDateFormat.CACHE_SIZE", "1000"));
 
-    
+
     /**
      * HTTP date format.
      */
-    protected static final SimpleDateFormat format = 
+    protected static final SimpleDateFormat format =
         new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
 
 
@@ -89,14 +89,14 @@ public final class FastHttpDateFormat {
     /**
      * Formatter cache.
      */
-    protected static final ConcurrentHashMap<Long, String> formatCache = 
+    protected static final ConcurrentHashMap<Long, String> formatCache =
         new ConcurrentHashMap<Long, String>(CACHE_SIZE);
 
 
     /**
      * Parser cache.
      */
-    protected static final ConcurrentHashMap<String, Long> parseCache = 
+    protected static final ConcurrentHashMap<String, Long> parseCache =
         new ConcurrentHashMap<String, Long>(CACHE_SIZE);
 
 
@@ -154,7 +154,7 @@ public final class FastHttpDateFormat {
     /**
      * Try to parse the given date as a HTTP date.
      */
-    public static final long parseDate(String value, 
+    public static final long parseDate(String value,
                                        DateFormat[] threadLocalformats) {
 
         Long cachedDate = parseCache.get(value);

==================================================
MimeMap.java
index fafdbffb8d..cdd3718b80 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/util/LocaleParser.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/util/LocaleParser.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -133,7 +133,7 @@ public final class LocaleParser {
 
       return locales;
     }
-    
+
     /**
      * The characters of the current string, as a character array.  Stored
      * when the string is first specified to speed up access to characters

==================================================
Range.java
index bedb0ff0e4..11828ba739 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/util/MimeMap.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/util/MimeMap.java
@@ -32,7 +32,7 @@ public class MimeMap implements FileNameMap {
 
     // Defaults - all of them are "well-known" types,
     // you can add using normal web.xml.
-    
+
     public static Hashtable<String,String> defaultMap =
         new Hashtable<String,String>(101);
     static {
@@ -121,11 +121,11 @@ public class MimeMap implements FileNameMap {
         defaultMap.put("avx", "video/x-rad-screenplay");
         defaultMap.put("wrl", "x-world/x-vrml");
         defaultMap.put("mpv2", "video/mpeg2");
-        
+
         /* Add XML related MIMEs */
-        
+
         defaultMap.put("xml", "text/xml");
-        defaultMap.put("xsl", "text/xml");        
+        defaultMap.put("xsl", "text/xml");
         defaultMap.put("svg", "image/svg+xml");
         defaultMap.put("svgz", "image/svg+xml");
         defaultMap.put("wbmp", "image/vnd.wap.wbmp");
@@ -134,7 +134,7 @@ public class MimeMap implements FileNameMap {
         defaultMap.put("wmls", "text/vnd.wap.wmlscript");
         defaultMap.put("wmlscriptc", "application/vnd.wap.wmlscriptc");
     }
-    
+
 
     private Hashtable<String,String> map = new Hashtable<String,String>();
 
@@ -149,7 +149,7 @@ public class MimeMap implements FileNameMap {
     public String getMimeType(String ext) {
         return getContentTypeFor(ext);
     }
-    
+
     public String getContentType(String extn) {
         String type = (String)map.get(extn.toLowerCase());
         if( type == null ) type=(String)defaultMap.get( extn );
@@ -166,7 +166,7 @@ public class MimeMap implements FileNameMap {
         // play it safe and get rid of any fragment id
         // that might be there
         int length=fileName.length();
-        
+
         int newEnd = fileName.lastIndexOf('#');
         if( newEnd== -1 ) newEnd=length;
         // Instead of creating a new string.
@@ -181,7 +181,7 @@ public class MimeMap implements FileNameMap {
             return null;
         }
     }
-    
+
     public String getContentTypeFor(String fileName) {
         String extn=getExtension( fileName );
         if (extn!=null) {

==================================================
URLEncoder.java
index 6bc1f5f96f..210a8277fc 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/util/Range.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/util/Range.java
@@ -21,16 +21,16 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.StringTokenizer;
 
-/** 
- * Utils to process HTTP/1.1 ranges. Used by default servlet, could 
+/**
+ * Utils to process HTTP/1.1 ranges. Used by default servlet, could
  * be used by any servlet that needs to deal with ranges.
- * 
+ *
  * It is very good to support ranges if you have large content. In most
  * cases supporting one range is enough - getting multiple ranges doesn't
  * seem very common, and it's complex (multipart response).
- * 
+ *
  * @author Costin Manolache
- * @author Remy Maucherat 
+ * @author Remy Maucherat
  * @author - see DefaultServlet in Catalin for other contributors
  */
 public class Range {
@@ -54,12 +54,12 @@ public class Range {
         end = 0;
         length = 0;
     }
-    
-    /** Parse ranges. 
-     * 
+
+    /** Parse ranges.
+     *
      * @return null if the range is invalid or can't be parsed
      */
-    public static ArrayList parseRanges(long fileLength, 
+    public static ArrayList parseRanges(long fileLength,
                                         String rangeHeader) throws IOException {
         ArrayList result = new ArrayList();
         StringTokenizer commaTokenizer = new StringTokenizer(rangeHeader, ",");
@@ -112,7 +112,7 @@ public class Range {
 
     /**
      * Parse the Content-Range header. Used with PUT or in response.
-     * 
+     *
      * @return Range
      */
     public static Range parseContentRange(String rangeHeader)

==================================================
UrlUtils.java
index 4364aea86c..f946e56456 100644
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/util/URLEncoder.java
+++ b/modules/tomcat-lite/java/org/apache/tomcat/lite/util/URLEncoder.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -26,7 +26,7 @@ import java.util.BitSet;
  *
  * This class is very similar to the java.net.URLEncoder class.
  *
- * Unfortunately, with java.net.URLEncoder there is no way to specify to the 
+ * Unfortunately, with java.net.URLEncoder there is no way to specify to the
  * java.net.URLEncoder which characters should NOT be encoded.
  *
  * This code was moved from DefaultServlet.java
@@ -80,7 +80,7 @@ public class URLEncoder {
 
     public String encodeURL(String path, String enc, boolean allowSlash) {
         int maxBytesPerChar = 10;
-        
+
         StringBuffer rewrittenPath = new StringBuffer(path.length());
         ByteArrayOutputStream buf = new ByteArrayOutputStream(maxBytesPerChar);
         OutputStreamWriter writer = null;
@@ -89,7 +89,7 @@ public class URLEncoder {
         } catch (UnsupportedEncodingException e1) {
             // shouldn't happen.
         }
-        
+
         for (int i = 0; i < path.length(); i++) {
             int c = (int) path.charAt(i);
             if (c < 128 && safeChars.get(c) || allowSlash && c == '/') {
@@ -127,7 +127,7 @@ public class URLEncoder {
         }
         return rewrittenPath.toString();
     }
-    
+
     /**
      * Decode and return the specified URL-encoded String.
      *
@@ -156,8 +156,8 @@ public class URLEncoder {
         return URLDecode(bytes, enc);
 
     }
-    
-    
+
+
     /**
      * Decode and return the specified URL-encoded String.
      * When the byte array is converted to a string, the system default
@@ -174,7 +174,7 @@ public class URLEncoder {
         return URLDecode(str, null);
 
     }
-    
+
     /**
      * Decode and return the specified URL-encoded byte array.
      *
@@ -211,7 +211,7 @@ public class URLEncoder {
         return new String(bytes, 0, ox);
 
     }
-    
+
     /**
      * Convert a byte character value to hexidecimal digit value.
      *
@@ -223,5 +223,5 @@ public class URLEncoder {
         if ((b >= 'A') && (b <= 'F')) return (byte)(b - 'A' + 10);
         return 0;
     }
-    
+
 }

==================================================
ServletTests.java
index d44cd77d23..742ae8dfd1 100644
--- a/modules/tomcat-lite/pom.xml
+++ b/modules/tomcat-lite/pom.xml
@@ -1,11 +1,11 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  
+
   <groupId>org.apache.tomcat.lite</groupId>
   <artifactId>lite</artifactId>
-  
+
   <version>0.0.1-SNAPSHOT</version>
-  
+
   <dependencies>
         <dependency>
                 <groupId>com.jcraft</groupId>
@@ -53,7 +53,7 @@
                 <version>6.0.20</version>
                 <type>jar</type>
                 <scope>compile</scope>
-        </dependency>  
+        </dependency>
         <dependency>
                 <groupId>asm</groupId>
                 <artifactId>asm</artifactId>
@@ -79,11 +79,11 @@
         	<version>1.7.1</version>
         </dependency>
   </dependencies>
-   
+
    <build>
-  
+
     <sourceDirectory>java</sourceDirectory>
-    
+
     <testSourceDirectory>test</testSourceDirectory>
 
     <plugins>

==================================================
Tomcat.java
index f7ce095a01..71b6bce411 100644
--- a/modules/tomcat-lite/test/org/apache/coyote/lite/ServletTests.java
+++ b/modules/tomcat-lite/test/org/apache/coyote/lite/ServletTests.java
@@ -12,17 +12,17 @@ import org.apache.tomcat.test.watchdog.WatchdogClient;
 
 import junit.framework.Test;
 
-/** 
+/**
  * Wrapper to run watchdog.
- * 
+ *
  */
 public class ServletTests extends WatchdogClient {
 
-    
+
     public ServletTests() {
         super();
         goldenDir = getWatchdogdir() + "/src/clients/org/apache/jcheck/servlet/client/";
-        testMatch = 
+        testMatch =
             //"HttpServletResponseWrapperSetStatusMsgTest";
             //"ServletContextAttributeAddedEventTest";
             null;
@@ -40,7 +40,7 @@ public class ServletTests extends WatchdogClient {
                 "ServletToJSPError502PageTest",
         };
     }
-    
+
     public ServletTests(String name) {
        this();
        super.single = name;
@@ -51,7 +51,7 @@ public class ServletTests extends WatchdogClient {
         // required for the tests
         System.setProperty("org.apache.coyote.USE_CUSTOM_STATUS_MSG_IN_HEADER",
                 "true");
-        
+
         try {
             initServerWithWatchdog(getWatchdogdir());
         } catch (ServletException e) {
@@ -62,24 +62,24 @@ public class ServletTests extends WatchdogClient {
             e.printStackTrace();
         }
     }
-    
-    public void initServerWithWatchdog(String wdDir) throws ServletException, 
+
+    public void initServerWithWatchdog(String wdDir) throws ServletException,
             IOException {
         Tomcat tomcat = new Tomcat();
         tomcat.setPort(port);
-        
+
         File f = new File(wdDir + "/build/webapps");
         tomcat.setBaseDir(f.getAbsolutePath());
-        
-        for (String s : new String[] {      
-                "servlet-compat", 
+
+        for (String s : new String[] {
+                "servlet-compat",
                 "servlet-tests",
                 "jsp-tests"} ) {
             tomcat.addWebapp("/" + s, f.getCanonicalPath() + "/" + s);
         }
-        
+
         TomcatStandaloneMain.setUp(tomcat, port);
-        
+
         try {
             tomcat.start();
         } catch (LifecycleException e) {
@@ -89,8 +89,8 @@ public class ServletTests extends WatchdogClient {
         System.err.println("Init done");
     }
 
-    /** 
-     * Magic JUnit method 
+    /**
+     * Magic JUnit method
      */
     public static Test suite() {
         return new ServletTests().getSuite();

==================================================
TomcatLiteCoyoteTest.java
index 880165b695..a2aa816e3b 100644
--- a/modules/tomcat-lite/test/org/apache/coyote/lite/Tomcat.java
+++ b/modules/tomcat-lite/test/org/apache/coyote/lite/Tomcat.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -49,37 +49,37 @@ import org.apache.catalina.startup.ContextConfig;
 
 // This class is here for compat with Tomcat6.
 
-// TODO: lazy init for the temp dir - only when a JSP is compiled or 
-// get temp dir is called we need to create it. This will avoid the 
+// TODO: lazy init for the temp dir - only when a JSP is compiled or
+// get temp dir is called we need to create it. This will avoid the
 // need for the baseDir
 
-// TODO: allow contexts without a base dir - i.e. 
+// TODO: allow contexts without a base dir - i.e.
 // only programmatic. This would disable the default servlet.
 
 /**
  * Minimal tomcat starter for embedding/unit tests.
- * 
- * Tomcat supports multiple styles of configuration and 
+ *
+ * Tomcat supports multiple styles of configuration and
  * startup - the most common and stable is server.xml-based,
  * implemented in org.apache.catalina.startup.Bootstrap.
  *
- * This class is for use in apps that embed tomcat. 
+ * This class is for use in apps that embed tomcat.
  * Requirements:
- * 
+ *
  * - all tomcat classes and possibly servlets are in the classpath.
  * ( for example all is in one big jar, or in eclipse CP, or in any other
  * combination )
- * 
+ *
  * - we need one temporary directory for work files
- * 
- * - no config file is required. This class provides methods to 
- * use if you have a webapp with a web.xml file, but it is 
+ *
+ * - no config file is required. This class provides methods to
+ * use if you have a webapp with a web.xml file, but it is
  * optional - you can use your own servlets.
- * 
+ *
  * This class provides a main() and few simple CLI arguments,
  * see setters for doc. It can be used for simple tests and
  * demo.
- * 
+ *
  * @see TestTomcat for examples on how to use this
  * @author Costin Manolache
  */
@@ -93,134 +93,134 @@ public class Tomcat {
 
     boolean started = false;
     // To make it a bit easier to config for the common case
-    // ( one host, one context ). 
+    // ( one host, one context ).
     protected StandardHost host;
 
-    // TODO: it's easy to add support for more hosts - but is it 
+    // TODO: it's easy to add support for more hosts - but is it
     // really needed ?
 
     // TODO: allow use of in-memory connector
-    
+
     protected int port = 8080;
     protected String hostname = "localhost";
     protected String basedir;
-    
-    // Default in-memory realm, will be set by default on 
-    // created contexts. Can be replaced with setRealm() on 
+
+    // Default in-memory realm, will be set by default on
+    // created contexts. Can be replaced with setRealm() on
     // the context.
     protected Realm defaultRealm;
     private Map<String, String> userPass = new HashMap<String, String>();
-    private Map<String, List<String>> userRoles = 
+    private Map<String, List<String>> userRoles =
             new HashMap<String, List<String>>();
     private Map<String, Principal> userPrincipals = new HashMap<String, Principal>();
-    
+
     public Tomcat() {
         // NOOP
     }
-    
+
     /**
-     * Tomcat needs a directory for temp files. This should be the 
-     * first method called. 
-     * 
+     * Tomcat needs a directory for temp files. This should be the
+     * first method called.
+     *
      * By default, if this method is not called, we use:
-     *  - system properties - catalina.base, catalina.home 
+     *  - system properties - catalina.base, catalina.home
      *  - $HOME/tomcat.$PORT
      * ( /tmp doesn't seem a good choice for security ).
-     *   
      *
-     * TODO: better default ? Maybe current dir ? 
+     *
+     * TODO: better default ? Maybe current dir ?
      * TODO: disable work dir if not needed ( no jsp, etc ).
      */
     public void setBaseDir(String basedir) {
         this.basedir = basedir;
     }
 
-    /** 
-     * Set the port for the default connector. Must 
+    /**
+     * Set the port for the default connector. Must
      * be called before start().
      */
     public void setPort(int port) {
         this.port = port;
     }
-    
-    /** 
-     * The the hostname of the default host, default is 
+
+    /**
+     * The the hostname of the default host, default is
      * 'localhost'.
      */
     public void setHostname(String s) {
         hostname = s;
     }
 
-    /** 
+    /**
      * Add a webapp using normal WEB-INF/web.xml if found.
-     * 
+     *
      * @param contextPath
      * @param baseDir
      * @return new StandardContext
-     * @throws ServletException 
+     * @throws ServletException
      */
-    public StandardContext addWebapp(String contextPath, 
+    public StandardContext addWebapp(String contextPath,
                                      String baseDir) throws ServletException {
-        
-        return addWebapp(getHost(), contextPath, baseDir);    
+
+        return addWebapp(getHost(), contextPath, baseDir);
     }
-    
-    
-    /** 
+
+
+    /**
      * Add a context - programmatic mode, no web.xml used.
      *
      * API calls equivalent with web.xml:
-     * 
+     *
      * context-param
      *  ctx.addParameter("name", "value");
-     *     
+     *
      *
      * error-page
      *    ErrorPage ep = new ErrorPage();
      *    ep.setErrorCode(500);
      *    ep.setLocation("/error.html");
      *    ctx.addErrorPage(ep);
-     *   
+     *
      * ctx.addMimeMapping("ext", "type");
-     * 
+     *
      * Note: If you reload the Context, all your configuration will be lost. If
      * you need reload support, consider using a LifecycleListener to provide
      * your configuration.
-     *  
+     *
      * TODO: add the rest
      *
      *  @param contextPath "/" for root context.
-     *  @param baseDir base dir for the context, for static files. Must exist, 
+     *  @param baseDir base dir for the context, for static files. Must exist,
      *  relative to the server home
      */
-    public StandardContext addContext(String contextPath, 
+    public StandardContext addContext(String contextPath,
                                       String baseDir) {
         return addContext(getHost(), contextPath, baseDir);
     }
 
     /**
-     * Equivalent with 
+     * Equivalent with
      *  <servlet><servlet-name><servlet-class>.
-     *  
-     * In general it is better/faster to use the method that takes a 
-     * Servlet as param - this one can be used if the servlet is not 
+     *
+     * In general it is better/faster to use the method that takes a
+     * Servlet as param - this one can be used if the servlet is not
      * commonly used, and want to avoid loading all deps.
      * ( for example: jsp servlet )
-     * 
+     *
      * You can customize the returned servlet, ex:
-     * 
+     *
      *    wrapper.addInitParameter("name", "value");
-     *    
+     *
      * @param contextPath   Context to add Servlet to
      * @param servletName   Servlet name (used in mappings)
      * @param servletClass  The class to be used for the Servlet
      * @return The wrapper for the servlet
      */
-    public StandardWrapper addServlet(String contextPath, 
-            String servletName, 
+    public StandardWrapper addServlet(String contextPath,
+            String servletName,
             String servletClass) {
         Container ctx = getHost().findChild(contextPath);
-        return addServlet((StandardContext) ctx, 
+        return addServlet((StandardContext) ctx,
                 servletName, servletClass);
     }
 
@@ -231,15 +231,15 @@ public class Tomcat {
      * @param servletClass  The class to be used for the Servlet
      * @return The wrapper for the servlet
      */
-    public static StandardWrapper addServlet(StandardContext ctx, 
-                                      String servletName, 
+    public static StandardWrapper addServlet(StandardContext ctx,
+                                      String servletName,
                                       String servletClass) {
         // will do class for name and set init params
         StandardWrapper sw = (StandardWrapper)ctx.createWrapper();
         sw.setServletClass(servletClass);
         sw.setName(servletName);
         ctx.addChild(sw);
-        
+
         return sw;
     }
 
@@ -251,11 +251,11 @@ public class Tomcat {
      * @param servlet       The Servlet to add
      * @return The wrapper for the servlet
      */
-    public StandardWrapper addServlet(String contextPath, 
-            String servletName, 
+    public StandardWrapper addServlet(String contextPath,
+            String servletName,
             Servlet servlet) {
         Container ctx = getHost().findChild(contextPath);
-        return addServlet((StandardContext) ctx, 
+        return addServlet((StandardContext) ctx,
                 servletName, servlet);
     }
 
@@ -267,20 +267,20 @@ public class Tomcat {
      * @return The wrapper for the servlet
      */
     public static StandardWrapper addServlet(StandardContext ctx,
-                                      String servletName, 
+                                      String servletName,
                                       Servlet servlet) {
         // will do class for name and set init params
         StandardWrapper sw = new ExistingStandardWrapper(servlet);
         sw.setName(servletName);
         ctx.addChild(sw);
-        
+
         return sw;
     }
-    
-    
+
+
     /**
      * Initialize and start the server.
-     * @throws LifecycleException 
+     * @throws LifecycleException
      */
     public void start() throws LifecycleException {
         if (started) {
@@ -292,26 +292,26 @@ public class Tomcat {
         server.start();
     }
 
-    /** 
+    /**
      * Stop the server.
-     * @throws LifecycleException 
+     * @throws LifecycleException
      */
     public void stop() throws LifecycleException {
         getServer().stop();
     }
 
 
-    /** 
-     * Add a user for the in-memory realm. All created apps use this 
+    /**
+     * Add a user for the in-memory realm. All created apps use this
      * by default, can be replaced using setRealm().
-     *  
+     *
      */
     public void addUser(String user, String pass) {
         userPass.put(user, pass);
     }
-    
+
     /**
-     * @see #addUser(String, String) 
+     * @see #addUser(String, String)
      */
     public void addRole(String user, String role) {
         List<String> roles = userRoles.get(user);
@@ -324,14 +324,14 @@ public class Tomcat {
 
     // ------- Extra customization -------
     // You can tune individual tomcat objects, using internal APIs
-    
-    /** 
-     * Get the default http connector. You can set more 
+
+    /**
+     * Get the default http connector. You can set more
      * parameters - the port is already initialized.
-     * 
+     *
      * Alternatively, you can construct a Connector and set any params,
      * then call addConnector(Connector)
-     * 
+     *
      * @return A connector object that can be customized
      */
     public Connector getConnector() {
@@ -342,7 +342,7 @@ public class Tomcat {
         // This will load Apr connector if available,
         // default to nio. I'm having strange problems with apr
         // and for the use case the speed benefit wouldn't matter.
-        
+
         //connector = new Connector("HTTP/1.1");
         try {
             connector = new Connector("org.apache.coyote.http11.Http11Protocol");
@@ -351,16 +351,16 @@ public class Tomcat {
         } catch (Exception e) {
             // TODO Auto-generated catch block
             e.printStackTrace();
-        } 
+        }
         return connector;
     }
-    
+
     public void setConnector(Connector connector) {
         this.connector = connector;
     }
-    
-    /** 
-     * Get the service object. Can be used to add more 
+
+    /**
+     * Get the service object. Can be used to add more
      * connectors and few other global settings.
      */
     public StandardService getService() {
@@ -368,17 +368,17 @@ public class Tomcat {
         return service;
     }
 
-    /** 
+    /**
      * Sets the current host - all future webapps will
-     * be added to this host. When tomcat starts, the 
+     * be added to this host. When tomcat starts, the
      * host will be the default host.
-     * 
+     *
      * @param host
      */
     public void setHost(StandardHost host) {
         this.host = host;
     }
-    
+
     public StandardHost getHost() {
         if (host == null) {
             host = new StandardHost();
@@ -388,19 +388,19 @@ public class Tomcat {
         }
         return host;
     }
-    
-    /** 
+
+    /**
      * Set a custom realm for auth. If not called, a simple
      * default will be used, using an internal map.
-     * 
+     *
      * Must be called before adding a context.
      */
     public void setDefaultRealm(Realm realm) {
         defaultRealm = realm;
     }
-    
 
-    /** 
+
+    /**
      * Access to the engine, for further customization.
      */
     public StandardEngine getEngine() {
@@ -416,36 +416,36 @@ public class Tomcat {
 
     /**
      * Get the server object. You can add listeners and few more
-     * customizations. JNDI is disabled by default.  
+     * customizations. JNDI is disabled by default.
      */
     public StandardServer getServer() {
-        
+
         if (server != null) {
             return server;
         }
-        
-        initBaseDir(); 
-        
+
+        initBaseDir();
+
         System.setProperty("catalina.useNaming", "false");
-        
+
         server = new StandardServer();
         server.setPort( -1 );
-        
+
         service = new StandardService();
         service.setName("Tomcat");
         server.addService( service );
         return server;
     }
 
-    public StandardContext addContext(StandardHost host, 
-                                      String contextPath, 
+    public StandardContext addContext(StandardHost host,
+                                      String contextPath,
                                       String dir) {
         silence(contextPath);
         StandardContext ctx = new StandardContext();
         ctx.setPath( contextPath );
         ctx.setDocBase(dir);
         ctx.addLifecycleListener(new FixContextListener());
-        
+
         if (host == null) {
             getHost().addChild(ctx);
         } else {
@@ -453,8 +453,8 @@ public class Tomcat {
         }
         return ctx;
     }
-    
-    public StandardContext addWebapp(StandardHost host, 
+
+    public StandardContext addWebapp(StandardHost host,
                                      String url, String path) {
         silence(url);
 
@@ -466,27 +466,27 @@ public class Tomcat {
         }
         ctx.setRealm(defaultRealm);
         ctx.addLifecycleListener(new DefaultWebXmlListener());
-        
+
         ContextConfig ctxCfg = new ContextConfig();
         ctx.addLifecycleListener( ctxCfg );
         // prevent it from looking ( if it finds one - it'll have dup error )
         ctxCfg.setDefaultWebXml("org/apache/catalin/startup/NO_DEFAULT_XML");
-        
+
         if (host == null) {
             getHost().addChild(ctx);
         } else {
             host.addChild(ctx);
         }
-        
+
         return ctx;
     }
 
 
     // ---------- Helper methods and classes -------------------
-    
-    /** 
-     * Initialize an in-memory realm. You can replace it 
-     * for contexts with a real one. 
+
+    /**
+     * Initialize an in-memory realm. You can replace it
+     * for contexts with a real one.
      */
     protected void initSimpleAuth() {
         defaultRealm = new RealmBase() {
@@ -512,16 +512,16 @@ public class Tomcat {
                             public String getName() {
                                 return username;
                             }
-                            
+
                         };
                     }
                 }
                 return p;
             }
-            
-        };        
+
+        };
     }
-    
+
     protected void initBaseDir() {
         if (basedir == null) {
             basedir = System.getProperty("catalina.base");
@@ -531,7 +531,7 @@ public class Tomcat {
         }
         if (basedir == null) {
             // Create a temp dir.
-            basedir = System.getProperty("user.dir") + 
+            basedir = System.getProperty("user.dir") +
                 "/tomcat." + port;
             File home = new File(basedir);
             home.mkdir();
@@ -555,7 +555,7 @@ public class Tomcat {
         "org.apache.catalina.core.ApplicationContext",
         "org.apache.catalina.core.AprLifecycleListener"
     };
-    
+
     /**
      * Controls if the loggers will be silenced or not.
      * @param silent    <code>true</code> sets the log level to WARN for the
@@ -573,16 +573,16 @@ public class Tomcat {
             }
         }
     }
-    
+
     private void silence(String ctx) {
         String base = "org.apache.catalina.core.ContainerBase.[default].[";
         base += getHost().getName();
         base += "].[";
-        base += ctx; 
+        base += ctx;
         base += "]";
         Logger.getLogger(base).setLevel(Level.WARNING);
     }
-    
+
     /**
      * Enables JNDI naming which is disabled by default.
      */
@@ -590,7 +590,7 @@ public class Tomcat {
         // Make sure getServer() has been called as that is where naming is
         // disabled
         getServer();
-        
+
         System.setProperty("catalina.useNaming", "true");
         String value = "org.apache.naming";
         String oldValue =
@@ -610,24 +610,24 @@ public class Tomcat {
 
     /**
      * Provide default configuration for a context. This is the programmatic
-     * equivalent of the default web.xml. 
-     * 
-     *  TODO: in normal tomcat, if default-web.xml is not found, use this 
+     * equivalent of the default web.xml.
+     *
+     *  TODO: in normal tomcat, if default-web.xml is not found, use this
      *  method
-     *  
+     *
      * @param contextPath   The context to set the defaults for
      */
     public void initWebappDefaults(String contextPath) {
         Container ctx = getHost().findChild(contextPath);
         initWebappDefaults((StandardContext) ctx);
     }
-    
+
     /**
      * Static version of {@link #initWebappDefaults(String)}
      * @param ctx   The context to set the defaults for
      */
     public static void initWebappDefaults(StandardContext ctx) {
-        // Default servlet 
+        // Default servlet
         StandardWrapper servlet = addServlet(
                 ctx, "default", "org.apache.catalina.servlets.DefaultServlet");
         servlet.setLoadOnStartup(1);
@@ -637,8 +637,8 @@ public class Tomcat {
                 ctx, "jsp", "org.apache.jasper.servlet.JspServlet");
         servlet.addInitParameter("fork", "false");
         servlet.setLoadOnStartup(3);
-        
-        // Servlet mappings 
+
+        // Servlet mappings
         ctx.addServletMapping("/", "default");
         ctx.addServletMapping("*.jsp", "jsp");
         ctx.addServletMapping("*.jspx", "jsp");
@@ -646,23 +646,23 @@ public class Tomcat {
         // Sessions
         ctx.setManager( new StandardManager());
         ctx.setSessionTimeout(30);
-        
+
         // MIME mappings
         for (int i = 0; i < DEFAULT_MIME_MAPPINGS.length; ) {
             ctx.addMimeMapping(DEFAULT_MIME_MAPPINGS[i++],
                     DEFAULT_MIME_MAPPINGS[i++]);
         }
-        
+
         // Welcome files
         ctx.addWelcomeFile("index.html");
         ctx.addWelcomeFile("index.htm");
         ctx.addWelcomeFile("index.jsp");
     }
 
-    
+
     /**
      * Fix startup sequence - required if you don't use web.xml.
-     * 
+     *
      * The start() method in context will set 'configured' to false - and
      * expects a listener to set it back to true.
      */
@@ -678,7 +678,7 @@ public class Tomcat {
                 return;
             }
         }
-        
+
     }
 
 
@@ -700,14 +700,14 @@ public class Tomcat {
 
 
     /**
-     * Helper class for wrapping existing servlets. This disables servlet 
+     * Helper class for wrapping existing servlets. This disables servlet
      * lifecycle and normal reloading, but also reduces overhead and provide
-     * more direct control over the servlet.  
+     * more direct control over the servlet.
      */
     public static class ExistingStandardWrapper extends StandardWrapper {
         private Servlet existing;
         boolean init = false;
-        
+
         public ExistingStandardWrapper( Servlet existing ) {
             this.existing = existing;
         }
@@ -726,105 +726,105 @@ public class Tomcat {
         }
         @Override
         public boolean isUnavailable() {
-            return false;       
+            return false;
         }
     }
-    
+
     /**
      * TODO: would a properties resource be better ? Or just parsing
      * /etc/mime.types ?
-     * This is needed because we don't use the default web.xml, where this 
+     * This is needed because we don't use the default web.xml, where this
      * is encoded.
      */
     public static final String[] DEFAULT_MIME_MAPPINGS = {
-        "abs", "audio/x-mpeg", 
-        "ai", "application/postscript", 
-        "aif", "audio/x-aiff", 
-        "aifc", "audio/x-aiff", 
-        "aiff", "audio/x-aiff", 
-        "aim", "application/x-aim", 
-        "art", "image/x-jg", 
-        "asf", "video/x-ms-asf", 
-        "asx", "video/x-ms-asf", 
-        "au", "audio/basic", 
-        "avi", "video/x-msvideo", 
-        "avx", "video/x-rad-screenplay", 
-        "bcpio", "application/x-bcpio", 
-        "bin", "application/octet-stream", 
-        "bmp", "image/bmp", 
-        "body", "text/html", 
-        "cdf", "application/x-cdf", 
-        "cer", "application/x-x509-ca-cert", 
-        "class", "application/java", 
-        "cpio", "application/x-cpio", 
-        "csh", "application/x-csh", 
-        "css", "text/css", 
-        "dib", "image/bmp", 
-        "doc", "application/msword", 
-        "dtd", "application/xml-dtd", 
-        "dv", "video/x-dv", 
-        "dvi", "application/x-dvi", 
-        "eps", "application/postscript", 
-        "etx", "text/x-setext", 
-        "exe", "application/octet-stream", 
-        "gif", "image/gif", 
-        "gtar", "application/x-gtar", 
-        "gz", "application/x-gzip", 
-        "hdf", "application/x-hdf", 
-        "hqx", "application/mac-binhex40", 
-        "htc", "text/x-component", 
-        "htm", "text/html", 
-        "html", "text/html", 
-        "hqx", "application/mac-binhex40", 
-        "ief", "image/ief", 
-        "jad", "text/vnd.sun.j2me.app-descriptor", 
-        "jar", "application/java-archive", 
-        "java", "text/plain", 
-        "jnlp", "application/x-java-jnlp-file", 
-        "jpe", "image/jpeg", 
-        "jpeg", "image/jpeg", 
-        "jpg", "image/jpeg", 
-        "js", "text/javascript", 
-        "jsf", "text/plain", 
-        "jspf", "text/plain", 
-        "kar", "audio/x-midi", 
-        "latex", "application/x-latex", 
-        "m3u", "audio/x-mpegurl", 
-        "mac", "image/x-macpaint", 
-        "man", "application/x-troff-man", 
-        "mathml", "application/mathml+xml", 
-        "me", "application/x-troff-me", 
-        "mid", "audio/x-midi", 
-        "midi", "audio/x-midi", 
-        "mif", "application/x-mif", 
-        "mov", "video/quicktime", 
-        "movie", "video/x-sgi-movie", 
-        "mp1", "audio/x-mpeg", 
-        "mp2", "audio/x-mpeg", 
-        "mp3", "audio/x-mpeg", 
-        "mp4", "video/mp4", 
-        "mpa", "audio/x-mpeg", 
-        "mpe", "video/mpeg", 
-        "mpeg", "video/mpeg", 
-        "mpega", "audio/x-mpeg", 
-        "mpg", "video/mpeg", 
-        "mpv2", "video/mpeg2", 
-        "ms", "application/x-wais-source", 
-        "nc", "application/x-netcdf", 
-        "oda", "application/oda", 
-        "odb", "application/vnd.oasis.opendocument.database", 
-        "odc", "application/vnd.oasis.opendocument.chart", 
-        "odf", "application/vnd.oasis.opendocument.formula", 
-        "odg", "application/vnd.oasis.opendocument.graphics", 
-        "odi", "application/vnd.oasis.opendocument.image", 
-        "odm", "application/vnd.oasis.opendocument.text-master", 
-        "odp", "application/vnd.oasis.opendocument.presentation", 
-        "ods", "application/vnd.oasis.opendocument.spreadsheet", 
-        "odt", "application/vnd.oasis.opendocument.text", 
-        "otg", "application/vnd.oasis.opendocument.graphics-template", 
-        "oth", "application/vnd.oasis.opendocument.text-web", 
-        "otp", "application/vnd.oasis.opendocument.presentation-template", 
-        "ots", "application/vnd.oasis.opendocument.spreadsheet-template ", 
+        "abs", "audio/x-mpeg",
+        "ai", "application/postscript",
+        "aif", "audio/x-aiff",
+        "aifc", "audio/x-aiff",
+        "aiff", "audio/x-aiff",
+        "aim", "application/x-aim",
+        "art", "image/x-jg",
+        "asf", "video/x-ms-asf",
+        "asx", "video/x-ms-asf",
+        "au", "audio/basic",
+        "avi", "video/x-msvideo",
+        "avx", "video/x-rad-screenplay",
+        "bcpio", "application/x-bcpio",
+        "bin", "application/octet-stream",
+        "bmp", "image/bmp",
+        "body", "text/html",
+        "cdf", "application/x-cdf",
+        "cer", "application/x-x509-ca-cert",
+        "class", "application/java",
+        "cpio", "application/x-cpio",
+        "csh", "application/x-csh",
+        "css", "text/css",
+        "dib", "image/bmp",
+        "doc", "application/msword",
+        "dtd", "application/xml-dtd",
+        "dv", "video/x-dv",
+        "dvi", "application/x-dvi",
+        "eps", "application/postscript",
+        "etx", "text/x-setext",
+        "exe", "application/octet-stream",
+        "gif", "image/gif",
+        "gtar", "application/x-gtar",
+        "gz", "application/x-gzip",
+        "hdf", "application/x-hdf",
+        "hqx", "application/mac-binhex40",
+        "htc", "text/x-component",
+        "htm", "text/html",
+        "html", "text/html",
+        "hqx", "application/mac-binhex40",
+        "ief", "image/ief",
+        "jad", "text/vnd.sun.j2me.app-descriptor",
+        "jar", "application/java-archive",
+        "java", "text/plain",
+        "jnlp", "application/x-java-jnlp-file",
+        "jpe", "image/jpeg",
+        "jpeg", "image/jpeg",
+        "jpg", "image/jpeg",
+        "js", "text/javascript",
+        "jsf", "text/plain",
+        "jspf", "text/plain",
+        "kar", "audio/x-midi",
+        "latex", "application/x-latex",
+        "m3u", "audio/x-mpegurl",
+        "mac", "image/x-macpaint",
+        "man", "application/x-troff-man",
+        "mathml", "application/mathml+xml",
+        "me", "application/x-troff-me",
+        "mid", "audio/x-midi",
+        "midi", "audio/x-midi",
+        "mif", "application/x-mif",
+        "mov", "video/quicktime",
+        "movie", "video/x-sgi-movie",
+        "mp1", "audio/x-mpeg",
+        "mp2", "audio/x-mpeg",
+        "mp3", "audio/x-mpeg",
+        "mp4", "video/mp4",
+        "mpa", "audio/x-mpeg",
+        "mpe", "video/mpeg",
+        "mpeg", "video/mpeg",
+        "mpega", "audio/x-mpeg",
+        "mpg", "video/mpeg",
+        "mpv2", "video/mpeg2",
+        "ms", "application/x-wais-source",
+        "nc", "application/x-netcdf",
+        "oda", "application/oda",
+        "odb", "application/vnd.oasis.opendocument.database",
+        "odc", "application/vnd.oasis.opendocument.chart",
+        "odf", "application/vnd.oasis.opendocument.formula",
+        "odg", "application/vnd.oasis.opendocument.graphics",
+        "odi", "application/vnd.oasis.opendocument.image",
+        "odm", "application/vnd.oasis.opendocument.text-master",
+        "odp", "application/vnd.oasis.opendocument.presentation",
+        "ods", "application/vnd.oasis.opendocument.spreadsheet",
+        "odt", "application/vnd.oasis.opendocument.text",
+        "otg", "application/vnd.oasis.opendocument.graphics-template",
+        "oth", "application/vnd.oasis.opendocument.text-web",
+        "otp", "application/vnd.oasis.opendocument.presentation-template",
+        "ots", "application/vnd.oasis.opendocument.spreadsheet-template ",
         "ott", "application/vnd.oasis.opendocument.text-template",
         "ogx", "application/ogg",
         "ogv", "video/ogg",
@@ -836,79 +836,79 @@ public class Tomcat {
         "axa", "audio/annodex",
         "axv", "video/annodex",
         "xspf", "application/xspf+xml",
-        "pbm", "image/x-portable-bitmap", 
-        "pct", "image/pict", 
-        "pdf", "application/pdf", 
-        "pgm", "image/x-portable-graymap", 
-        "pic", "image/pict", 
-        "pict", "image/pict", 
-        "pls", "audio/x-scpls", 
-        "png", "image/png", 
-        "pnm", "image/x-portable-anymap", 
-        "pnt", "image/x-macpaint", 
-        "ppm", "image/x-portable-pixmap", 
+        "pbm", "image/x-portable-bitmap",
+        "pct", "image/pict",
+        "pdf", "application/pdf",
+        "pgm", "image/x-portable-graymap",
+        "pic", "image/pict",
+        "pict", "image/pict",
+        "pls", "audio/x-scpls",
+        "png", "image/png",
+        "pnm", "image/x-portable-anymap",
+        "pnt", "image/x-macpaint",
+        "ppm", "image/x-portable-pixmap",
         "ppt", "application/vnd.ms-powerpoint",
         "pps", "application/vnd.ms-powerpoint",
-        "ps", "application/postscript", 
-        "psd", "image/x-photoshop", 
-        "qt", "video/quicktime", 
-        "qti", "image/x-quicktime", 
-        "qtif", "image/x-quicktime", 
-        "ras", "image/x-cmu-raster", 
-        "rdf", "application/rdf+xml", 
-        "rgb", "image/x-rgb", 
-        "rm", "application/vnd.rn-realmedia", 
-        "roff", "application/x-troff", 
-        "rtf", "application/rtf", 
-        "rtx", "text/richtext", 
-        "sh", "application/x-sh", 
-        "shar", "application/x-shar", 
+        "ps", "application/postscript",
+        "psd", "image/x-photoshop",
+        "qt", "video/quicktime",
+        "qti", "image/x-quicktime",
+        "qtif", "image/x-quicktime",
+        "ras", "image/x-cmu-raster",
+        "rdf", "application/rdf+xml",
+        "rgb", "image/x-rgb",
+        "rm", "application/vnd.rn-realmedia",
+        "roff", "application/x-troff",
+        "rtf", "application/rtf",
+        "rtx", "text/richtext",
+        "sh", "application/x-sh",
+        "shar", "application/x-shar",
         /*"shtml", "text/x-server-parsed-html",*/
-        "smf", "audio/x-midi", 
-        "sit", "application/x-stuffit", 
-        "snd", "audio/basic", 
-        "src", "application/x-wais-source", 
-        "sv4cpio", "application/x-sv4cpio", 
-        "sv4crc", "application/x-sv4crc", 
-        "svg", "image/svg+xml", 
-        "svgz", "image/svg+xml", 
-        "swf", "application/x-shockwave-flash", 
-        "t", "application/x-troff", 
-        "tar", "application/x-tar", 
-        "tcl", "application/x-tcl", 
-        "tex", "application/x-tex", 
-        "texi", "application/x-texinfo", 
-        "texinfo", "application/x-texinfo", 
-        "tif", "image/tiff", 
-        "tiff", "image/tiff", 
-        "tr", "application/x-troff", 
-        "tsv", "text/tab-separated-values", 
-        "txt", "text/plain", 
-        "ulw", "audio/basic", 
-        "ustar", "application/x-ustar", 
-        "vxml", "application/voicexml+xml", 
-        "xbm", "image/x-xbitmap", 
-        "xht", "application/xhtml+xml", 
-        "xhtml", "application/xhtml+xml", 
-        "xls", "application/vnd.ms-excel", 
-        "xml", "application/xml", 
-        "xpm", "image/x-xpixmap", 
-        "xsl", "application/xml", 
-        "xslt", "application/xslt+xml", 
-        "xul", "application/vnd.mozilla.xul+xml", 
-        "xwd", "image/x-xwindowdump", 
-        "vsd", "application/x-visio", 
-        "wav", "audio/x-wav", 
-        "wbmp", "image/vnd.wap.wbmp", 
-        "wml", "text/vnd.wap.wml", 
-        "wmlc", "application/vnd.wap.wmlc", 
-        "wmls", "text/vnd.wap.wmlscript", 
-        "wmlscriptc", "application/vnd.wap.wmlscriptc", 
-        "wmv", "video/x-ms-wmv", 
-        "wrl", "x-world/x-vrml", 
-        "wspolicy", "application/wspolicy+xml", 
-        "Z", "application/x-compress", 
-        "z", "application/x-compress", 
-        "zip", "application/zip" 
+        "smf", "audio/x-midi",
+        "sit", "application/x-stuffit",
+        "snd", "audio/basic",
+        "src", "application/x-wais-source",
+        "sv4cpio", "application/x-sv4cpio",
+        "sv4crc", "application/x-sv4crc",
+        "svg", "image/svg+xml",
+        "svgz", "image/svg+xml",
+        "swf", "application/x-shockwave-flash",
+        "t", "application/x-troff",
+        "tar", "application/x-tar",
+        "tcl", "application/x-tcl",
+        "tex", "application/x-tex",
+        "texi", "application/x-texinfo",
+        "texinfo", "application/x-texinfo",
+        "tif", "image/tiff",
+        "tiff", "image/tiff",
+        "tr", "application/x-troff",
+        "tsv", "text/tab-separated-values",
+        "txt", "text/plain",
+        "ulw", "audio/basic",
+        "ustar", "application/x-ustar",
+        "vxml", "application/voicexml+xml",
+        "xbm", "image/x-xbitmap",
+        "xht", "application/xhtml+xml",
+        "xhtml", "application/xhtml+xml",
+        "xls", "application/vnd.ms-excel",
+        "xml", "application/xml",
+        "xpm", "image/x-xpixmap",
+        "xsl", "application/xml",
+        "xslt", "application/xslt+xml",
+        "xul", "application/vnd.mozilla.xul+xml",
+        "xwd", "image/x-xwindowdump",
+        "vsd", "application/x-visio",
+        "wav", "audio/x-wav",
+        "wbmp", "image/vnd.wap.wbmp",
+        "wml", "text/vnd.wap.wml",
+        "wmlc", "application/vnd.wap.wmlc",
+        "wmls", "text/vnd.wap.wmlscript",
+        "wmlscriptc", "application/vnd.wap.wmlscriptc",
+        "wmv", "video/x-ms-wmv",
+        "wrl", "x-world/x-vrml",
+        "wspolicy", "application/wspolicy+xml",
+        "Z", "application/x-compress",
+        "z", "application/x-compress",
+        "zip", "application/zip"
     };
 }

==================================================
TomcatStandaloneMain.java
index 2a8b233a51..a995076e02 100644
--- a/modules/tomcat-lite/test/org/apache/coyote/lite/TomcatLiteCoyoteTest.java
+++ b/modules/tomcat-lite/test/org/apache/coyote/lite/TomcatLiteCoyoteTest.java
@@ -17,26 +17,26 @@ import org.apache.tomcat.lite.io.BBuffer;
  * Very simple test.
  */
 public class TomcatLiteCoyoteTest extends TestCase {
-    static int port = 8884; 
+    static int port = 8884;
     static {
         Logger.getLogger("org.apache.catalina.core.StandardService").setLevel(Level.WARNING);
         Logger.getLogger("org.apache.catalina.core.StandardEngine").setLevel(Level.WARNING);
-        Logger.getLogger("org.apache.catalina.startup.ContextConfig").setLevel(Level.WARNING);        
+        Logger.getLogger("org.apache.catalina.startup.ContextConfig").setLevel(Level.WARNING);
     }
     static Tomcat main = TomcatStandaloneMain.setUp(port);
-    
+
     public void testSimple() throws IOException {
         HttpConnector clientCon = HttpClient.newClient();
-        
+
         HttpChannel ch = clientCon.get("localhost", port);
         ch.getRequest().setRequestURI("/index.html");
         ch.getRequest().send();
-        
+
         BBuffer res = ch.readAll(null, 0);
-        
-        assertTrue(res.toString(), 
+
+        assertTrue(res.toString(),
                 res.toString().indexOf("<title>Apache Tomcat</title>") >= 0);
     }
-    
-    
+
+
 }

==================================================
TestMain.java
index 008bee5ba0..98cf16e828 100644
--- a/modules/tomcat-lite/test/org/apache/coyote/lite/TomcatStandaloneMain.java
+++ b/modules/tomcat-lite/test/org/apache/coyote/lite/TomcatStandaloneMain.java
@@ -11,18 +11,18 @@ import org.apache.tomcat.lite.TestMain;
 /**
  * Startup tomcat + coyote lite connector.
  * No config files used.
- * 
+ *
  * @author Costin Manolache
  */
 public class TomcatStandaloneMain {
-    
+
     public static Tomcat setUp(int port) {
         try {
             Tomcat tomcat = new Tomcat();
 
             tomcat.setPort(port);
             String base = TestMain.findDir("/output/build");
-            tomcat.setBaseDir(base);               
+            tomcat.setBaseDir(base);
             // Absolute path - tomcat6 and 7 are different,
             // 7 adds webapps.
             tomcat.addWebapp("/", base + "/webapps/ROOT");
@@ -40,7 +40,7 @@ public class TomcatStandaloneMain {
         }
         return null;
     }
-    
+
     public static LiteProtocolHandler setUp(Tomcat tomcat, int port) {
         Connector connector;
         try {
@@ -48,7 +48,7 @@ public class TomcatStandaloneMain {
             tomcat.getService().addConnector(connector);
             connector.setPort(port);
             tomcat.setConnector(connector);
-            LiteProtocolHandler ph = 
+            LiteProtocolHandler ph =
                 (LiteProtocolHandler) connector.getProtocolHandler();
             return ph;
         } catch (Exception e) {

==================================================
ClientTest.java
index 1ceafb4a34..643fcfe401 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/TestMain.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/TestMain.java
@@ -30,9 +30,9 @@ import org.apache.tomcat.lite.service.IOStatus;
 
 /**
  * Laucher for tomcat-lite standalone, configured with test handlers.
- * 
+ *
  * Used in tests - one is running for the entire suite.
- * 
+ *
  * @author Costin Manolache
  */
 public class TestMain {
@@ -42,9 +42,9 @@ public class TestMain {
     }
 
     static TestMain defaultServer;
-    
+
     private boolean init = false;
-    
+
     HttpConnector testClient;
     HttpConnector testServer;
     HttpConnector testProxy;
@@ -58,7 +58,7 @@ public class TestMain {
     protected void init() {
         testClient = HttpClient.newClient();
     }
-    
+
     /**
      * A single instance used for all tests.
      */
@@ -69,7 +69,7 @@ public class TestMain {
         }
         return defaultServer;
     }
-    
+
     public static HttpConnector getTestServer() {
         return shared().testServer;
     }
@@ -80,7 +80,7 @@ public class TestMain {
 
     public static BaseMapper.Context initTestContext(Dispatcher d) throws IOException {
         BaseMapper.Context mCtx = d.addContext(null, "", null, null, null, null);
-        
+
         mCtx.addWrapper("/", new StaticContentService()
             .setContentType("text/html")
             .setData("<a href='/proc/cpool/client'>Client pool</a><br/>" +
@@ -88,7 +88,7 @@ public class TestMain {
                     "<a href='/proc/cpool/proxy'>Proxy pool</a><br/>" +
                     ""));
 
-        mCtx.addWrapper("/favicon.ico", 
+        mCtx.addWrapper("/favicon.ico",
                 new StaticContentService().setStatus(404).setData("Not found"));
 
         mCtx.addWrapper("/hello", new StaticContentService().setData("Hello world"));
@@ -118,7 +118,7 @@ public class TestMain {
         mCtx.addWrapper("/proc/cpool/proxy", new IOStatus(testProxy.cpool));
         mCtx.addWrapper("/proc/cpool/server", new IOStatus(testServer.cpool));
     }
-    
+
     public void run() {
         try {
             startAll();
@@ -134,8 +134,8 @@ public class TestMain {
         } catch (Throwable t) {
             t.printStackTrace();
         }
-    } 
-    
+    }
+
     public static String findDir(String dir) {
         String path = ".";
         for (int i = 0; i < 5; i++) {
@@ -151,7 +151,7 @@ public class TestMain {
         }
         return null;
     }
-    
+
     public int getServerPort() {
         return 8802;
     }
@@ -163,8 +163,8 @@ public class TestMain {
     public int getSslServerPort() {
         return 8443;
     }
-    
-    static String PRIVATE_KEY = 
+
+    static String PRIVATE_KEY =
     "MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALsz2milZGHliWte61TfMTSwpAdq" +
 "9uJkMTqgpSVtwxxOe8kT84QtIzhdAsQYjRz9ZtQn9DYWhJQs/cs/R3wWsjWwgiFHLzGalvsmMYJ3" +
 "vBO8VMj762fAWu7GjUApIXcxMJoK4sQUpZKbqTuXpwzVUeeqBcspsIDgOLCo233G7/fBAgMBAAEC" +
@@ -196,7 +196,7 @@ public class TestMain {
 "c82iSbM0LseFeHwxAfeNXosSShMFtQzKt2wKZLLQB/Oqrea32m4hU//NP8rNbTux" +
 "dcAHeNQEDB5EUUSewAlh+fUE6HB6c8j0\n" +
 "-----END CERTIFICATE-----\n\n";
-    
+
     protected synchronized void startAll() throws IOException {
         if (init) {
             System.err.println("2x init ???");
@@ -204,13 +204,13 @@ public class TestMain {
             init = true;
             boolean debug = false;
             if (debug) {
-                System.setProperty("javax.net.debug", "ssl");            
-                System.setProperty("jsse", "conn_state,alert,engine,record,ssocket,socket,prf");            
+                System.setProperty("javax.net.debug", "ssl");
+                System.setProperty("jsse", "conn_state,alert,engine,record,ssocket,socket,prf");
                 Logger.getLogger("SSL").setLevel(Level.FINEST);
                 testClient.setDebug(true);
                 testClient.setDebugHttp(true);
             }
-            
+
             proxy = new HttpProxyService()
                 .withHttpClient(testClient);
             testProxy = HttpServer.newServer(getProxyPort());
@@ -219,7 +219,7 @@ public class TestMain {
                 testProxy.setDebugHttp(true);
                 testProxy.setDebug(true);
             }
-            
+
             // dispatcher rejects 'http://'
             testProxy.setHttpService(proxy);
             try {
@@ -227,7 +227,7 @@ public class TestMain {
             } catch (IOException e) {
                 e.printStackTrace();
             }
-            
+
             testServer = HttpServer.newServer(getServerPort());
             if (debug) {
                 testServer.setDebugHttp(true);
@@ -245,20 +245,20 @@ public class TestMain {
 //            byte[] keyBytes = b64.decode(PRIVATE_KEY);
 
             sslServer = HttpServer.newSslServer(getSslServerPort());
-            
+
             if (debug) {
                 sslServer.setDebug(true);
                 sslServer.setDebugHttp(true);
             }
             JsseSslProvider sslCon = (JsseSslProvider) sslServer.getSslProvider();
-            
+
             sslCon = sslCon
-                .setKeyRes("org/apache/tomcat/lite/http/genrsa_512.cert", 
+                .setKeyRes("org/apache/tomcat/lite/http/genrsa_512.cert",
                         "org/apache/tomcat/lite/http/genrsa_512.der");
-            initTestCallback(sslServer.getDispatcher());            
+            initTestCallback(sslServer.getDispatcher());
             sslServer.start();
-        }   
-        
+        }
+
         Runtime.getRuntime().addShutdownHook(new Thread() {
             public void run() {
                 System.err.println("Done");
@@ -268,7 +268,7 @@ public class TestMain {
             }
         });
     }
-    
+
     /**
      * Blocking get, returns when the body has been read.
      */
@@ -278,23 +278,23 @@ public class TestMain {
 
         HttpRequest aclient = HttpClient.newClient().request(url);
         aclient.send();
-        aclient.readAll(out, 
+        aclient.readAll(out,
                 //Long.MAX_VALUE);//
                 2000000);
         aclient.release(); // return connection to pool
         return out;
     }
-    
+
     public static BBuffer getUrl(String path) throws IOException {
         BBuffer out = BBuffer.allocate();
         getUrl(path, out);
         return out;
     }
 
-    public static HttpURLConnection getUrl(String path, 
+    public static HttpURLConnection getUrl(String path,
                              BBuffer out) throws IOException {
         URL url = new URL(path);
-        HttpURLConnection connection = 
+        HttpURLConnection connection =
             (HttpURLConnection) url.openConnection();
         connection.setReadTimeout(10000);
         connection.connect();
@@ -308,6 +308,6 @@ public class TestMain {
         }
         return connection;
     }
-    
-    
+
+
 }

==================================================
CompressFilterTest.java
index 66c51fd047..226cad3581 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/ClientTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/http/ClientTest.java
@@ -11,50 +11,50 @@ import junit.framework.TestCase;
 
 /**
  * Examples and tests for Tomcat-lite in client mode.
- * 
+ *
  */
 public class ClientTest extends TestCase {
 
-    /** 
-     * All connectors created this way will share a single 
-     * IO thread. Each connector will have its keep-alive 
+    /**
+     * All connectors created this way will share a single
+     * IO thread. Each connector will have its keep-alive
      * pool - so it's better to share them.
-     * 
+     *
      * Since I want to test keep-alive works, I use a static one
      */
     static HttpConnector httpCon = HttpClient.newClient();
 
-    /** 
+    /**
      * Start a http server, runs on 8802 - shared by all tests.
-     * Will use /echo handler. 
+     * Will use /echo handler.
      */
     static HttpConnector testServer = TestMain.getTestServer();
 
-    
+
     public void testSimpleBlocking() throws IOException {
         HttpRequest req = httpCon.request("http://localhost:8802/echo/test1");
         HttpResponse res = req.waitResponse();
-        
+
         assertEquals(200, res.getStatus());
         //assertEquals("", res.getHeader(""));
-        
+
         BufferedReader reader = res.getReader();
         String line1 = reader.readLine();
         assertEquals("REQ HEAD:", line1);
     }
-    
+
     public void testSimpleCallback() throws IOException {
-        
+
     }
-    
+
     public void testGetParams() throws IOException {
-    }    
+    }
 
     public void testPostParams() throws IOException {
-    }    
+    }
 
     public void testPostBody() throws IOException {
-    }    
-    
+    }
+
 
 }

==================================================
DispatcherTest.java
index 23666c2ae1..0ec3b82d27 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/CompressFilterTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/http/CompressFilterTest.java
@@ -11,18 +11,18 @@ import org.apache.tomcat.lite.io.IOBuffer;
 public class CompressFilterTest extends TestCase {
 
     CompressFilter cf = new CompressFilter();
-    
+
     private void check(String clear, String xtra) throws Exception {
         IOBuffer in = new IOBuffer();
         IOBuffer out = new IOBuffer();
-        
+
         in.append(clear);
         in.close();
-        
+
         cf.compress(in, out);
-        
+
 //        BBuffer bb = out.copyAll(null);
-//        String hd = Hex.getHexDump(bb.array(), bb.position(), 
+//        String hd = Hex.getHexDump(bb.array(), bb.position(),
 //                bb.remaining(), true);
 //        System.err.println(hd);
 
@@ -32,27 +32,27 @@ public class CompressFilterTest extends TestCase {
         in.recycle();
         out.close();
         cf.decompress(out, in);
-        
+
         assertEquals(in.copyAll(null).toString(), clear);
         assertTrue(in.isAppendClosed());
-        
+
         if (xtra != null) {
-            assertEquals(out.copyAll(null).toString(), xtra);            
+            assertEquals(out.copyAll(null).toString(), xtra);
         }
     }
 
     public void test1() throws Exception {
         check("X1Y2Z3", null);
     }
-        
+
     public void testXtra() throws Exception {
         check("X1Y2Z3", "GET /");
     }
-        
+
     public void testLarge() throws Exception {
         StringBuffer sb = new StringBuffer();
         for (int i = 0; i < 2 * 1024; i++) {
-            sb.append("0123456789012345"); 
+            sb.append("0123456789012345");
         }
         check(sb.toString(), null);
     }
@@ -63,17 +63,17 @@ public class CompressFilterTest extends TestCase {
             cf.recycle();
         }
     }
-    
+
     public void testLargeIn() throws Exception {
         StringBuffer sb = new StringBuffer();
         Random r = new Random();
         for (int i = 0; i < 16 * 2 * 1024; i++) {
-            sb.append(' ' + r.nextInt(32)); 
+            sb.append(' ' + r.nextInt(32));
         }
         check(sb.toString(), null);
     }
-        
-    
+
+
     public void testSpdy() throws Exception {
         cf.setDictionary(SpdyConnection.SPDY_DICT, SpdyConnection.DICT_ID);
         check("connection: close\n", null);

==================================================
HttpChannelInMemoryTest.java
index 6c90bcaaaf..f4740073c2 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/DispatcherTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/http/DispatcherTest.java
@@ -31,15 +31,15 @@ public class DispatcherTest extends TestCase {
         mapper.addContext("asdf.com", "", "context0", new String[0], null, null);
 
         MappingData mappingData = new MappingData();
-        
+
         CBuffer host = CBuffer.newInstance();
         host.set("test1.com");
-        
+
         CBuffer uri = CBuffer.newInstance();
         uri.set("/foo/bar/blah/bobou/foo");
 
         mapper.map(host, uri, mappingData);
-        
+
         assertEquals("context2", mappingData.context.toString());
         assertEquals("/foo/bar", mappingData.contextPath.toString());
     }

==================================================
HttpChannelTest.java
index 59b89cba0b..f0b2cf2570 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/HttpChannelInMemoryTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/http/HttpChannelInMemoryTest.java
@@ -20,15 +20,15 @@ import org.apache.tomcat.lite.io.MemoryIOConnector.MemoryIOChannel;
 // TODO: rename to Http11ConnectionTest
 public class HttpChannelInMemoryTest extends TestCase {
     /**
-     *  Connection under test 
+     *  Connection under test
      */
     Http11Connection conn;
 
-    /** 
+    /**
      * Last http channel created by the connection
      */
     volatile HttpChannel http;
-    
+
     // Input/output for the connection
     MemoryIOConnector.MemoryIOChannel net = new MemoryIOChannel();
 
@@ -40,12 +40,12 @@ public class HttpChannelInMemoryTest extends TestCase {
     boolean bodySentDone = false;
     boolean headersDone = false;
     boolean allDone = false;
-    
+
     public void setUp() throws IOException {
         // Requests will not be serviced - you must manually generate
         // the response.
         serverConnector.setHttpService(null);
-    
+
         conn = new Http11Connection(serverConnector) {
             protected HttpChannel checkHttpChannel() throws IOException {
                 return http = super.checkHttpChannel();
@@ -53,17 +53,17 @@ public class HttpChannelInMemoryTest extends TestCase {
         }.serverMode();
         conn.setSink(net);
     }
-    
-   
+
+
     public void test2Req() throws IOException {
         String req = "GET /index.html?q=b&c=d HTTP/1.1\r\n" +
-        "Host:  Foo.com \n" + 
-        "H2:Bar\r\n" + 
+        "Host:  Foo.com \n" +
+        "H2:Bar\r\n" +
         "H3: Foo \r\n" +
         " Bar\r\n" +
         "H4: Foo\n" +
         "    Bar\n" +
-        "\r\n" + 
+        "\r\n" +
         "HEAD /r2? HTTP/1.1\n" +
         "Host: Foo.com\r\n" +
         "H3: Foo \r\n" +
@@ -71,8 +71,8 @@ public class HttpChannelInMemoryTest extends TestCase {
         "H4: Foo\n" +
         " Bar\n" +
         "\r\n";
-        net.getIn().append(req);        
-        
+        net.getIn().append(req);
+
         //http = lastServer.get(0);
         assertTrue(http.getRequest().method().equals("GET"));
         assertTrue(http.getRequest().protocol().equals("HTTP/1.1"));
@@ -81,17 +81,17 @@ public class HttpChannelInMemoryTest extends TestCase {
                 "Foo.com");
         assertEquals(http.getRequest().getMimeHeaders().getHeader("H2").toString(),
                 "Bar");
-        
+
         http.getOut().append("Response1");
         http.getOut().close();
         http.startSending();
-        http.release(); 
-        
-        // now second response must be in. 
+        http.release();
+
+        // now second response must be in.
         // the connector will create a new http channel
-        
+
         //http = lastServer.get(1);
-        
+
         assertTrue(http.getRequest().method().equals("HEAD"));
         assertTrue(http.getRequest().protocol().equals("HTTP/1.1"));
         assertTrue(http.getRequest().getMimeHeaders().size() == 3);
@@ -101,36 +101,36 @@ public class HttpChannelInMemoryTest extends TestCase {
 
     public void testHttp11Close() throws IOException {
         String req = "GET /index.html?q=b&c=d HTTP/1.1\r\n" +
-        "Host:  Foo.com\n" + 
+        "Host:  Foo.com\n" +
         "Connection: close\n" +
-        "\n"; 
-        net.getIn().append(req);        
-        
+        "\n";
+        net.getIn().append(req);
+
         assertTrue(http.getRequest().method().equals("GET"));
         assertTrue(http.getRequest().protocol().equals("HTTP/1.1"));
-        
+
         http.getOut().append("Response1");
         http.getOut().close();
         http.startSending();
-        http.release(); 
-        
+        http.release();
+
         assertTrue(net.out.indexOf("connection:close") > 0);
         assertFalse(net.isOpen());
     }
 
     public void testHttp10Close() throws IOException {
         String req = "GET /index.html?q=b&c=d HTTP/1.0\r\n" +
-        "Host:  Foo.com \n" + 
-        "\r\n"; 
-        net.getIn().append(req);        
-        
+        "Host:  Foo.com \n" +
+        "\r\n";
+        net.getIn().append(req);
+
         assertTrue(http.getRequest().method().equals("GET"));
         assertTrue(http.getRequest().protocol().equals("HTTP/1.0"));
-        
+
         http.getOut().append("Response1");
         http.getOut().close();
         http.startSending();
-        
+
         assertTrue(net.out.indexOf("connection:close") > 0);
         assertFalse(net.isOpen());
     }
@@ -138,47 +138,47 @@ public class HttpChannelInMemoryTest extends TestCase {
     public void testHttp10KA() throws IOException {
         String req = "GET /index.html?q=b&c=d HTTP/1.0\r\n" +
         "Connection: Keep-Alive\n" +
-        "Host:  Foo.com \n" + 
-        "\r\n"; 
-        net.getIn().append(req);        
-        
+        "Host:  Foo.com \n" +
+        "\r\n";
+        net.getIn().append(req);
+
         assertTrue(http.getRequest().method().equals("GET"));
         assertTrue(http.getRequest().protocol().equals("HTTP/1.0"));
-        
+
         http.getOut().append("Hi");
         http.getOut().close();
         http.startSending();
-        
+
         // after request
         assertEquals(conn.activeHttp, null);
-        
+
         assertTrue(net.out.indexOf("connection:keep-alive") > 0);
         assertTrue(net.isOpen());
         // inserted since we can calculate the response
         assertEquals(http.getResponse().getHeader("Content-Length"),
                    "2");
     }
-    
+
     public void testHttp10KANoCL() throws IOException {
         String req = "GET /index.html?q=b&c=d HTTP/1.0\r\n" +
         "Connection: Keep-Alive\n" +
-        "Host:  Foo.com \n" + 
-        "\r\n"; 
-        net.getIn().append(req);        
-        
+        "Host:  Foo.com \n" +
+        "\r\n";
+        net.getIn().append(req);
+
         assertTrue(http.getRequest().method().equals("GET"));
         assertTrue(http.getRequest().protocol().equals("HTTP/1.0"));
-        
+
         http.getOut().append("Hi");
         http.startSending();
 
         http.getOut().append("After");
         http.getOut().close();
         http.startSending();
-        
+
         // after request
         assertEquals(conn.activeHttp, null);
-        
+
         assertFalse(net.out.indexOf("connection:keep-alive") > 0);
         assertFalse(net.isOpen());
         // inserted since we can calculate the response
@@ -187,21 +187,21 @@ public class HttpChannelInMemoryTest extends TestCase {
         assertEquals(http.getResponse().getHeader("Transfer-Encoding"),
                 null);
     }
-    
+
     public void testMultiLineHead() throws IOException {
         net.getIn().append("GET / HTTP/1.0\n" +
                 "Cookie: 1234\n" +
                 "  456 \n" +
                 "Connection:   Close\n\n");
         net.getIn().close();
-        
+
         MultiMap headers = http.getRequest().getMimeHeaders();
         CBuffer cookie = headers.getHeader("Cookie");
         CBuffer conn = headers.getHeader("Connection");
         assertEquals(conn.toString(), "close");
         assertEquals(cookie.toString(), "1234 456");
-        
-        assertEquals(http.conn.headRecvBuf.toString(), 
+
+        assertEquals(http.conn.headRecvBuf.toString(),
                 "GET / HTTP/1.0\n" +
                 "Cookie: 1234 456   \n" + // \n -> trailing space
                 "Connection:   Close\n\n");
@@ -216,39 +216,39 @@ public class HttpChannelInMemoryTest extends TestCase {
         net.getIn().close();
         assertFalse(((Http11Connection)http.conn).keepAlive());
     }
-    
+
     public void test2ReqByte2Byte() throws IOException {
         String req = "GET /index.html?q=b&c=d HTTP/1.1\r\n" +
-        "Host:  Foo.com \n" + 
-        "H2:Bar\r\n" + 
+        "Host:  Foo.com \n" +
+        "H2:Bar\r\n" +
         "H3: Foo \r\n" +
         " Bar\r\n" +
         "H4: Foo\n" +
         "    Bar\n" +
-        "\r\n" + 
+        "\r\n" +
         "HEAD /r2? HTTP/1.1\n" +
         "Host: Foo1.com\n" +
         "H3: Foo \r\n" +
         "       Bar\r\n" +
         "\r\n";
         for (int i = 0; i < req.length(); i++) {
-            net.getIn().append(req.charAt(i));        
+            net.getIn().append(req.charAt(i));
         }
-        
+
         assertTrue(http.getRequest().method().equals("GET"));
         assertTrue(http.getRequest().protocol().equals("HTTP/1.1"));
         assertTrue(http.getRequest().getMimeHeaders().size() == 4);
         assertTrue(http.getRequest().getMimeHeaders().getHeader("Host")
                 .equals("Foo.com"));
-        
+
         // send a response
         http.sendBody.append("Response1");
         http.getOut().close();
-        
+
         http.startSending(); // This will trigger a pipelined request
-        
+
         http.release(); // now second response must be in
-        
+
         assertTrue(http.getRequest().method().equals("HEAD"));
         assertTrue(http.getRequest().protocol().equals("HTTP/1.1"));
         assertTrue(http.getRequest().getMimeHeaders().size() == 2);
@@ -259,12 +259,12 @@ public class HttpChannelInMemoryTest extends TestCase {
         http.sendBody.append("Response2");
         http.getOut().close();
         http.release(); // now second response must be in
-        
-        
+
+
     }
-    
+
     public void testEndWithoutFlushCallbacks() throws IOException {
-        
+
         net.getIn().append(POST);
 
         net.getIn().close();
@@ -274,13 +274,13 @@ public class HttpChannelInMemoryTest extends TestCase {
                 allDone = true;
             }
         });
-        
+
         http.sendBody.queue("Hi");
         http.getOut().close();
         http.startSending(); // will call handleEndSend
 
         assertTrue(allDone);
-        
+
     }
 
     public void testCallbacks() throws IOException {
@@ -288,10 +288,10 @@ public class HttpChannelInMemoryTest extends TestCase {
         serverConnector.setHttpService(new HttpService() {
             public void service(HttpRequest httpReq, HttpResponse httpRes)
                     throws IOException {
-                
+
                 headersDone = true;
                 HttpChannel http = httpReq.getHttpChannel();
-                
+
                 http.setCompletedCallback(new RequestCompleted() {
                     public void handle(HttpChannel data, Object extra)
                     throws IOException {
@@ -324,24 +324,24 @@ public class HttpChannelInMemoryTest extends TestCase {
                 "1");
         assertTrue(headersDone);
         net.getIn().append("234");
-        
+
         net.getIn().close();
         assertTrue(bodyDone);
-        
-        
+
+
         http.sendBody.queue("Hi");
         http.getOut().close();
         http.startSending();
         assertTrue(bodySentDone);
 
         assertTrue(allDone);
-        
+
     }
-    
+
     public static String POST = "POST / HTTP/1.0\n" +
         "Connection: Close\n" +
         "Content-Length: 4\n\n" +
-        "1234"; 
+        "1234";
 
     public void testClose() throws IOException {
         net.getIn().append(POST);
@@ -351,19 +351,19 @@ public class HttpChannelInMemoryTest extends TestCase {
         IOBuffer appData = receiveBody;
         BBuffer res = BBuffer.allocate(1000);
         appData.readAll(res);
-        
+
         assertEquals(res.toString(), "1234");
         assertFalse(((Http11Connection)http.conn).keepAlive());
-        
+
         http.sendBody.queue(res);
         http.getOut().close();
         http.startSending();
-        
+
         assertTrue(net.getOut().isAppendClosed());
         assertTrue(net.out.toString().indexOf("\n1234") > 0);
-        
+
     }
-    
+
     public void testReadLine() throws Exception {
         net.getIn().append("POST / HTTP/1.0\n" +
         		"Content-Length: 28\n\n" +
@@ -372,13 +372,13 @@ public class HttpChannelInMemoryTest extends TestCase {
                 "Line 3\r" +
                 "Line 4");
         net.getIn().close();
-        
+
         BufferedReader r = http.getRequest().getReader();
         assertEquals("Line 1", r.readLine());
         assertEquals("Line 2", r.readLine());
         assertEquals("Line 3", r.readLine());
         assertEquals("Line 4", r.readLine());
         assertEquals(null, r.readLine());
-        
+
     }
 }

==================================================
HttpsTest.java
index b49dea2af2..ad13187995 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/HttpChannelTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/http/HttpChannelTest.java
@@ -13,33 +13,33 @@ public class HttpChannelTest extends TestCase {
     HttpChannel ch = new HttpChannel().serverMode(true);
     Http11Connection con = new Http11Connection(null).serverMode();
     HttpRequest req = ch.getRequest();
-    
-    
+
+
     BBuffer head = BBuffer.allocate();
     BBuffer line = BBuffer.wrapper();
     BBuffer name = BBuffer.wrapper();
     BBuffer value = BBuffer.wrapper();
-    
+
     BBuffer statusB = BBuffer.wrapper();
     BBuffer msgB = BBuffer.wrapper();
     BBuffer methodB = BBuffer.wrapper();
     BBuffer queryB = BBuffer.wrapper("");
     BBuffer requestB = BBuffer.wrapper();
     BBuffer protoB = BBuffer.wrapper();
-    
+
     BBuffer l7 = BBuffer.wrapper("GET \n");
     BBuffer l8 = BBuffer.wrapper("GET /\n");
     BBuffer l9 = BBuffer.wrapper("GET /a?b\n");
     BBuffer l10 = BBuffer.wrapper("GET /a?b HTTP/1.0\n");
     BBuffer l11 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b");
     BBuffer l12 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\n");
-    
+
     BBuffer f1 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\n\n");
     BBuffer f2 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\r\n\r\n");
     BBuffer f3 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\r\r");
     BBuffer f4 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\r\n\r");
 
-    public void reqTest(String lineS, String method, String req, 
+    public void reqTest(String lineS, String method, String req,
             String qry, String proto) throws IOException {
         BBuffer line = BBuffer.wrapper(lineS);
         queryB.recycle();
@@ -65,7 +65,7 @@ public class HttpChannelTest extends TestCase {
         MultiMap params = req.getParameters();
         return params;
     }
-    
+
     public void testParseReq() throws IOException {
         reqTest("GET / HTTP/1.0", "GET", "/", "", "HTTP/1.0");
         reqTest("GET", "GET", "", "", "");
@@ -76,20 +76,20 @@ public class HttpChannelTest extends TestCase {
         reqTest("GET a HTTP/1.0", "GET", "a", "", "HTTP/1.0");
         reqTest("GET a? HTTP/1.0", "GET", "a", "", "HTTP/1.0");
     }
-    
-    public void headTest(String headS, String expName, String expValue, 
+
+    public void headTest(String headS, String expName, String expValue,
             String expLine, String expRest) throws IOException {
         head = BBuffer.wrapper(headS);
         head.readLine(line);
         con.parseHeader(ch, head, line, name, value);
-        
+
         assertEquals(expName, name.toString());
         assertEquals(expValue, value.toString());
 
         assertEquals(expLine, line.toString());
         assertEquals(expRest, head.toString());
     }
-    
+
     public void testParseHeader() throws IOException {
         headTest("a:b\n", "a", "b", "", "");
         headTest("a :b\n", "a", "b", "", "");
@@ -101,22 +101,22 @@ public class HttpChannelTest extends TestCase {
         headTest("a :  b  \n c\n", "a", "b c", "", "");
         headTest("a :  b  \n  c\n", "a", "b c", "", "");
         headTest("a :  b  \n  c\nd:", "a", "b c", "", "d:");
-       
+
     }
-    
-    public void responseTest(String lineS, String proto, String status, 
+
+    public void responseTest(String lineS, String proto, String status,
             String msg) throws IOException {
         protoB.recycle();
         statusB.recycle();
         msgB.recycle();
         BBuffer line = BBuffer.wrapper(lineS);
-        con.parseResponseLine(line, 
+        con.parseResponseLine(line,
                 protoB, statusB, msgB);
         assertEquals(proto, protoB.toString());
         assertEquals(status, statusB.toString());
         assertEquals(msg, msgB.toString());
     }
-    
+
     public void testResponse() throws Exception {
         responseTest("HTTP/1.1 200 OK", "HTTP/1.1", "200", "OK");
         responseTest("HTTP/1.1  200 OK", "HTTP/1.1", "200", "OK");

==================================================
LiveHttp1Test.java
index 8ce9bc9bfc..bc42b3b3ad 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/HttpsTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/http/HttpsTest.java
@@ -23,39 +23,39 @@ import org.apache.tomcat.lite.TestMain;
 import org.apache.tomcat.lite.io.BBuffer;
 
 public class HttpsTest extends TestCase {
-    
+
     static int port = 8443;
-    
+
     public void testSimpleClient() throws Exception {
         final HttpConnector httpClient = TestMain.shared().getClient();
         checkResponse(httpClient);
     }
-    
+
     public void testSimpleServer() throws Exception {
         final HttpConnector httpClient = TestMain.shared().getClient();
         BBuffer res = TestMain.getUrl("https://localhost:8443/hello");
         assertTrue(res.toString().indexOf("Hello") >= 0);
-    }       
+    }
+
 
-    
     private void checkResponse(HttpConnector httpCon) throws Exception {
         HttpRequest ch = httpCon.request("localhost", port).setSecure(true);
-        
+
         ch.setRequestURI("/hello");
         ch.setProtocol("HTTP/1.0"); // to force close
         ch.send();
         BBuffer res = ch.readAll();
-        
+
         assertTrue(res.toString().indexOf("Hello") >= 0);
-    }    
-    
+    }
+
     public void testSimpleClient20() throws Exception {
         final HttpConnector httpClient = TestMain.shared().getClient();
         for (int i = 0; i < 10; i++) {
             checkResponse(httpClient);
         }
     }
-    
+
     public void testSimpleRequestGoogle() throws Exception {
         for (int i = 0; i < 40; i++) {
         final HttpConnector httpClient = TestMain.shared().getClient();
@@ -64,11 +64,11 @@ public class HttpsTest extends TestCase {
         client.getHttpChannel().setIOTimeout(2000000);
         client.setRequestURI("/accounts/ServiceLogin");
         client.send();
-        
+
         BBuffer res = client.readAll();
         assertTrue(res.toString().indexOf("<title>Google Accounts</title>") > 0);
         }
     }
-        
+
 
 }

==================================================
MultiMapTest.java
index 4d30843c3f..00e4eac2f7 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/LiveHttp1Test.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/http/LiveHttp1Test.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -24,7 +24,7 @@ import org.apache.tomcat.lite.TestMain;
 import org.apache.tomcat.lite.io.BBuffer;
 
 public class LiveHttp1Test extends TestCase {
-    // Proxy tests extend this class, run same tests via proxy on 8903 
+    // Proxy tests extend this class, run same tests via proxy on 8903
     protected int clientPort = 8802;
 
     HttpRequest httpReq;
@@ -38,7 +38,7 @@ public class LiveHttp1Test extends TestCase {
         // DefaultHttpConnector.get().setDebugHttp(true);
         TestMain.getTestServer();
 
-        httpReq = HttpClient.newClient().request("localhost", 
+        httpReq = HttpClient.newClient().request("localhost",
                 clientPort);
 
         bodyRecvBuffer.recycle();
@@ -145,7 +145,7 @@ public class LiveHttp1Test extends TestCase {
         httpReq.requestURI().set("/hello");
 
         httpReq.send();
-        
+
         httpReq.readAll(bodyRecvBuffer, to);
         assertEquals(0, bodyRecvBuffer.remaining());
     }

==================================================
SpdyTest.java
index 497f275c42..e222f36d3c 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/MultiMapTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/http/MultiMapTest.java
@@ -10,7 +10,7 @@ public class MultiMapTest extends TestCase {
 
     MultiMap map = new MultiMap();
     MultiMap lmap = new MultiMap().insensitive();
-    
+
     public void testAdd() {
         map.add("foo", "bar");
         assertEquals("bar", map.get("foo").toString());
@@ -43,7 +43,7 @@ public class MultiMapTest extends TestCase {
         lmap.add("B", "bar4");
         assertEquals(4, lmap.count);
         assertEquals(3, lmap.map.size());
-        
+
         assertEquals("bar3", lmap.getString("a"));
         assertEquals("bar3", lmap.getString("A"));
         assertEquals("bar1", lmap.getString("Foo"));

==================================================
EchoCallback.java
index 500201f3cd..3b51e10858 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/SpdyTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/http/SpdyTest.java
@@ -15,68 +15,68 @@ import org.apache.tomcat.lite.io.SocketConnector;
 
 public class SpdyTest extends TestCase {
     HttpConnector http11Con = TestMain.shared().getClient();
-    
+
     static HttpConnector spdyCon = HttpClient.newClient();
 
-    static HttpConnector spdyConSsl = HttpClient.newClient(); 
-    
+    static HttpConnector spdyConSsl = HttpClient.newClient();
+
     HttpConnector memSpdyCon = new HttpConnector(null);
-    
+
     public void testClient() throws IOException {
-        HttpRequest req = 
+        HttpRequest req =
             spdyCon.request("http://localhost:8802/echo/test1");
-        
+
         // Force SPDY - no negotiation
         req.setProtocol("SPDY/1.0");
-        
+
         HttpResponse res = req.waitResponse();
-        
+
         assertEquals(200, res.getStatus());
         //assertEquals("", res.getHeader(""));
-        
+
         BufferedReader reader = res.getReader();
         String line1 = reader.readLine();
-        //assertEquals("", line1);        
+        //assertEquals("", line1);
     }
-    
+
     public void testSslClient() throws IOException {
-        
-        HttpRequest req = 
+
+        HttpRequest req =
             spdyConSsl.request("http://localhost:8443/echo/test1");
         // Enable SSL for the connection.
-        // TODO: this must be done on the first request, all will be 
+        // TODO: this must be done on the first request, all will be
         // encrypted.
         req.setSecure(true);
         // Force SPDY - no negotiation
         req.setProtocol("SPDY/1.0");
-        
+
         HttpResponse res = req.waitResponse();
-        
+
         assertEquals(200, res.getStatus());
         //assertEquals("", res.getHeader(""));
-        
+
         res.setReadTimeout(2000);
         BufferedReader reader = res.getReader();
         String line1 = reader.readLine();
-        //assertEquals("", line1);        
+        //assertEquals("", line1);
     }
 
-    
+
     // Initial frame generated by Chrome
     public void testParse() throws IOException {
-            InputStream is = 
+            InputStream is =
             getClass().getClassLoader().getResourceAsStream("org/apache/tomcat/lite/http/spdyreq0.bin");
-        
+
         IOBuffer iob = new IOBuffer();
         iob.append(is);
-        
+
         SpdyConnection con = new SpdyConnection(memSpdyCon, new RemoteServer());
-        
-        // By default it has a dispatcher buit-in 
+
+        // By default it has a dispatcher buit-in
         con.serverMode = true;
-        
+
         con.dataReceived(iob);
-        
+
         HttpChannel spdyChannel = con.channels.get(1);
 
         assertEquals(1, con.lastFrame.version);
@@ -88,24 +88,24 @@ public class SpdyTest extends TestCase {
         // TODO: test req, headers
         HttpRequest req = spdyChannel.getRequest();
         assertTrue(req.getHeader("accept").indexOf("application/xml") >= 0);
-        
+
     }
-    
+
     // Initial frame generated by Chrome
     public void testParseCompressed() throws IOException {
-        InputStream is = 
+        InputStream is =
             getClass().getClassLoader().getResourceAsStream("org/apache/tomcat/lite/http/spdyreqCompressed.bin");
-        
+
         IOBuffer iob = new IOBuffer();
         iob.append(is);
-        
+
         SpdyConnection con = new SpdyConnection(memSpdyCon, new RemoteServer());
-        
-        // By default it has a dispatcher buit-in 
+
+        // By default it has a dispatcher buit-in
         con.serverMode = true;
-        
+
         con.dataReceived(iob);
-        
+
         HttpChannel spdyChannel = con.channels.get(1);
 
         assertEquals(1, con.lastFrame.version);
@@ -115,12 +115,12 @@ public class SpdyTest extends TestCase {
         // TODO: test req, headers
         HttpRequest req = spdyChannel.getRequest();
         assertTrue(req.getHeader("accept").indexOf("application/xml") >= 0);
-        
+
     }
-    
+
     // Does int parsing works ?
     public void testLargeInt() throws Exception {
-        
+
         IOBuffer iob = new IOBuffer();
         iob.append(0x80);
         iob.append(0x01);
@@ -138,12 +138,12 @@ public class SpdyTest extends TestCase {
         assertEquals(0xFFFF, con.currentInFrame.type);
         assertEquals(0xFF, con.currentInFrame.flags);
         assertEquals(0xFFFFFF, con.currentInFrame.length);
-        
+
     }
 
     // Does int parsing works ?
     public void testBad() throws Exception {
-        
+
             IOBuffer iob = new IOBuffer();
             iob.append(0xFF);
             iob.append(0xFF);
@@ -157,9 +157,9 @@ public class SpdyTest extends TestCase {
 
             SpdyConnection con = new SpdyConnection(memSpdyCon, new RemoteServer());
             con.dataReceived(iob);
-            
+
             assertEquals(1, con.streamErrors.get());
-        
+
     }
 
 }

==================================================
SleepCallback.java
index 1c29ec492b..bd614ec707 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/services/EchoCallback.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/http/services/EchoCallback.java
@@ -30,7 +30,7 @@ import org.apache.tomcat.lite.io.IOBuffer;
  */
 public class EchoCallback implements HttpService {
     Logger log = Logger.getLogger("coyote.static");
-    
+
     String contentType = "text/plain";
 
 
@@ -42,20 +42,20 @@ public class EchoCallback implements HttpService {
         HttpChannel sproc = req.getHttpChannel();
         res.setStatus(200);
         res.setContentType(contentType);
-        
+
         IOBuffer tmp = new IOBuffer(null);
         Http11Connection.serialize(req, tmp);
-        
+
         sproc.getOut().append("REQ HEAD:\n");
         sproc.getOut().append(tmp.readAll(null));
         IOBuffer reqBuf = sproc.getOut();
-        
+
         reqBuf.append("\nCONTENT_LENGTH:")
             .append(Long.toString(req.getContentLength()))
             .append("\n");
-//      
+//
 //        sproc.release();
     }
 
-    
+
 }
\ No newline at end of file

==================================================
BBufferTest.java
index 12657d1147..5bb174b61a 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/services/SleepCallback.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/http/services/SleepCallback.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -32,7 +32,7 @@ public class SleepCallback extends StaticContentService {
   long t2;
   long t3;
   long t4;
-  
+
   public SleepCallback() {
   }
 
@@ -44,7 +44,7 @@ public class SleepCallback extends StaticContentService {
     this.t4 = t4;
     return this;
   }
-    
+
   public SleepCallback sleep(long t1) {
     return sleep(t1, t1, t1, t1);
   }

==================================================
CBufferTest.java
index ae02346f92..ec7c9e9240 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/io/BBufferTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/io/BBufferTest.java
@@ -25,7 +25,7 @@ public class BBufferTest extends TestCase {
     BBuffer l10 = BBuffer.wrapper("GET /a?b HTTP/1.0\n");
     BBuffer l11 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b");
     BBuffer l12 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\n");
-    
+
     BBuffer f1 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\n\n");
     BBuffer f2 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\r\n\r\n");
     BBuffer f3 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\r\r");
@@ -43,7 +43,7 @@ public class BBufferTest extends TestCase {
     public void hashTest(String s) {
         assertEquals(s.hashCode(), BBuffer.wrapper(s).hashCode());
     }
-    
+
     public void testHash() {
         hashTest("");
         hashTest("a");
@@ -51,31 +51,31 @@ public class BBufferTest extends TestCase {
         hashTest("123abc\0");
         // Fails for UTF chars - only ascii hashTest("123abc\u12345;");
     }
-    
+
     public void testReadToSpace() {
         assertEquals(3, l8.readToSpace(res));
         assertEquals("GET", res.toString());
-        assertEquals(" /\n", l8.toString());        
+        assertEquals(" /\n", l8.toString());
 
         assertEquals(0, l1.readToSpace(res));
         assertEquals("", res.toString());
-        assertEquals("", l1.toString());        
+        assertEquals("", l1.toString());
     }
-    
+
     public void testReadToDelim() {
         assertEquals(1, h1.readToDelimOrSpace((byte)'?', res));
         assertEquals("a", res.toString());
-        assertEquals("", h1.toString());        
-        
+        assertEquals("", h1.toString());
+
         assertEquals(1, h2.readToDelimOrSpace((byte)'?', res));
         assertEquals("a", res.toString());
-        assertEquals("?b", h2.toString());        
-        
+        assertEquals("?b", h2.toString());
+
         assertEquals(1, h3.readToDelimOrSpace((byte)'?', res));
         assertEquals("a", res.toString());
-        assertEquals(" b", h3.toString());        
+        assertEquals(" b", h3.toString());
     }
-    
+
     public void testGet() {
         assertEquals(0x20, s1.get(0));
         assertEquals(0x0a, s1.get(1));
@@ -86,24 +86,24 @@ public class BBufferTest extends TestCase {
         }
         fail("Exception");
     }
-    
+
     public void testSkipSpace() {
         assertEquals(1, s1.skipSpace());
-        assertEquals("\n", s1.toString());        
+        assertEquals("\n", s1.toString());
 
         assertEquals(1, s2.skipSpace());
-        assertEquals("a", s2.toString());        
-        
+        assertEquals("a", s2.toString());
+
         assertEquals(2, s3.skipSpace());
-        assertEquals("", s3.toString());        
+        assertEquals("", s3.toString());
 
         assertEquals(3, s4.skipSpace());
-        assertEquals("a", s4.toString());        
-        
+        assertEquals("a", s4.toString());
+
         assertEquals(0, l1.skipSpace());
-        assertEquals("", l1.toString());        
+        assertEquals("", l1.toString());
     }
-    
+
     public void testLFLF() {
         assertTrue(f1.hasLFLF());
         assertTrue(f2.hasLFLF());
@@ -118,21 +118,21 @@ public class BBufferTest extends TestCase {
         assertFalse(l11.hasLFLF());
         assertFalse(l12.hasLFLF());
     }
-        
+
     public void testReadLine() {
         assertEquals(-1, l1.readLine(res));
         assertEquals("", res.toString());
-        assertEquals("", l1.toString());        
-        
+        assertEquals("", l1.toString());
+
         assertEquals(-1, l1a.readLine(res));
         assertEquals("", res.toString());
-        assertEquals("a", l1a.toString());        
-        
+        assertEquals("a", l1a.toString());
+
         assertEquals(0, l2.readLine(res));
-        assertEquals("", l2.toString());        
+        assertEquals("", l2.toString());
         assertEquals("", res.toString());
         assertEquals(0, l3.readLine(res));
-        assertEquals("", l3.toString());        
+        assertEquals("", l3.toString());
         assertEquals("", res.toString());
         assertEquals(0, l4.readLine(res));
         assertEquals("", res.toString());
@@ -146,7 +146,7 @@ public class BBufferTest extends TestCase {
         assertEquals(0, l5_a.readLine(res));
         assertEquals("", res.toString());
         assertEquals("a", l5_a.toString());
-        
+
         assertEquals(1, l6.readLine(res));
         assertEquals("a", res.toString());
 

==================================================
OneTest.java
index db0152c192..ab064d9434 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/io/CBufferTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/io/CBufferTest.java
@@ -7,12 +7,12 @@ import junit.framework.TestCase;
 public class CBufferTest extends TestCase {
 
     CBuffer ext = CBuffer.newInstance();
-    
+
     public void extTest(String path, String exp) {
         CBuffer.newInstance().append(path).getExtension(ext, '/', '.');
         assertEquals(exp, ext.toString());
     }
-    
+
     public void testExt() {
         extTest("foo.jsp", "jsp");
         extTest("foo.j", "j");
@@ -25,8 +25,8 @@ public class CBufferTest extends TestCase {
         extTest("/abc/", "");
         extTest("/abc/d", "");
     }
-    
+
     public void testLastIndexOf() {
-        
+
     }
 }

==================================================
SocksTest.java
index 74470cd3f0..eb5202a7e4 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/io/OneTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/io/OneTest.java
@@ -12,16 +12,16 @@ import org.apache.tomcat.lite.io.MemoryIOConnector.MemoryIOChannel;
 import junit.framework.TestCase;
 
 public class OneTest extends TestCase {
- 
+
     public void setUp() throws Exception {
         TestMain.getTestServer();
     }
-    
+
     public void tearDown() throws IOException {
     }
 
 
     public void testOne() throws Exception {
-        
+
     }
 }

==================================================
UEncoderTest.java
index a1f9870a7b..3a1443d1c3 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/io/SocksTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/io/SocksTest.java
@@ -20,7 +20,7 @@ import junit.framework.TestCase;
 
 public class SocksTest extends TestCase {
 
-    public void setUp() { 
+    public void setUp() {
 //        SocksServer socks = new SocksServer();
 //        try {
 //            socks.initServer();
@@ -28,7 +28,7 @@ public class SocksTest extends TestCase {
 //            // TODO Auto-generated catch block
 //            e1.printStackTrace();
 //        }
-//        
+//
 //        ProxySelector.setDefault(new ProxySelector() {
 //
 //            @Override
@@ -37,10 +37,10 @@ public class SocksTest extends TestCase {
 //
 //            @Override
 //            public List<Proxy> select(URI uri) {
-//                
+//
 //                List<Proxy> res = new ArrayList<Proxy>();
 //                try {
-//                    res.add(new Proxy(Proxy.Type.SOCKS, 
+//                    res.add(new Proxy(Proxy.Type.SOCKS,
 //                            new InetSocketAddress(InetAddress.getLocalHost(), 1080)));
 //                } catch (UnknownHostException e) {
 //                    // TODO Auto-generated catch block
@@ -48,11 +48,11 @@ public class SocksTest extends TestCase {
 //                }
 //                return res;
 //            }
-//            
+//
 //        });
     }
-    
+
     public void testSocks() {
-        
+
     }
 }

==================================================
LiveHttp5Test.java
index f48a61c61c..9f4ffcc120 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/io/UEncoderTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/io/UEncoderTest.java
@@ -9,17 +9,17 @@ public class UEncoderTest extends TestCase {
     IOWriter enc=new IOWriter(null);
     UrlEncoding dec = new UrlEncoding();
     CBuffer cc = CBuffer.newInstance();
-    
+
     /*
-     * 
+     *
      * Test method for 'org.apache.tomcat.util.buf.UEncoder.encodeURL(String)'
-     * TODO: find the relevant rfc and apache tests and add more 
+     * TODO: find the relevant rfc and apache tests and add more
      */
     public void testEncodeURL() {
 
         String eurl1=encodeURL("test");
         assertEquals("test", eurl1);
-        
+
         eurl1=encodeURL("/test");
         assertEquals("/test", eurl1);
 
@@ -33,7 +33,7 @@ public class UEncoderTest extends TestCase {
         eurl1=encodeURL("//test");
         assertEquals("//test", eurl1);
     }
-    
+
     public String encodeURL(String uri) {
         cc.recycle();
         dec.urlEncode(uri, cc, enc);

==================================================
LiveHttpThreadedTest.java
index 3bcdb74c13..d167a5dea9 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/load/LiveHttp5Test.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/load/LiveHttp5Test.java
@@ -18,19 +18,19 @@ public class LiveHttp5Test extends LiveHttp1Test {
         }
         return s;
     }
-    
+
     public void test100() throws Exception {
         for (int i = 0; i < 100; i++) {
             testSimpleRequest();
-            tearDown(); 
+            tearDown();
             setUp();
-            
+
             notFound();
-            tearDown(); 
+            tearDown();
             setUp();
 
             testSimpleRequest();
-            tearDown(); 
+            tearDown();
             setUp();
         }
     }

==================================================
MicroTest.java
index 2e8ef071ca..7849f49abb 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/load/LiveHttpThreadedTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/load/LiveHttpThreadedTest.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -35,46 +35,46 @@ import org.apache.tomcat.lite.io.BBuffer;
 import org.apache.tomcat.lite.io.SocketConnector;
 
 /*
-  Notes on memory use ( from heap dumps ): 
+  Notes on memory use ( from heap dumps ):
     - buffers are not yet recycled ( the BBuffers used in channels )
-  
+
     - each active connection consumes at least 26k - 2 buffers + head buffer
      ( 8k each )
      TODO: could 'peak' in the In buffer and move headRecv to HttpChannel
-     
-     
+
+
     - HttpChannel keeps about 64K ( for the hello world ).
     -- res is 25k
     -- req is 32k, BufferedIOReader 16k,
-    
+
    TODO:
     - leak in NioThread.active - closed sockets not removed
     - need to rate-limit and queue requests - OOM
     - timeouts
-    - seems few responses missing on large async requests (URL works)     
+    - seems few responses missing on large async requests (URL works)
  */
 
 /**
  * Long running test - async tests are failing since rate control
- * is not implemented ( too many outstanding requests - OOM ), 
+ * is not implemented ( too many outstanding requests - OOM ),
  * it seems there is a bug as well.
  */
 public class LiveHttpThreadedTest extends TestCase {
     HttpConnector clientCon = TestMain.shared().getClient();
     HttpConnector serverCon = TestMain.shared().getTestServer();
-    
-    HttpConnector spdyClient = 
+
+    HttpConnector spdyClient =
         HttpClient.newClient().setCompression(false);
-    
+
     HttpConnector spdyClientCompress =
         HttpClient.newClient();
-    
-    HttpConnector spdyClientCompressSsl = 
+
+    HttpConnector spdyClientCompressSsl =
         HttpClient.newClient();
-    
+
     ThreadRunner tr;
     static boolean dumpHeap = true;
-    
+
     AtomicInteger ok = new AtomicInteger();
     int reqCnt;
 
@@ -83,7 +83,7 @@ public class LiveHttpThreadedTest extends TestCase {
     public void tearDown() throws IOException {
         clientCon.cpool.clear();
     }
-    
+
     public void test1000Async() throws Exception {
 //        try {
             asyncRequest(10, 100, false, false, clientCon, "AsyncHttp");
@@ -136,9 +136,9 @@ public class LiveHttpThreadedTest extends TestCase {
 
     Object thrlock = new Object();
     Object lock = new Object();
-    
-    public void asyncRequest(final int thr, int perthr, 
-            final boolean spdy, final boolean ssl, 
+
+    public void asyncRequest(final int thr, int perthr,
+            final boolean spdy, final boolean ssl,
             final HttpConnector clientCon, String test) throws Exception {
         clientCon.getConnectionPool().clear();
         reqCnt = thr * perthr;
@@ -146,7 +146,7 @@ public class LiveHttpThreadedTest extends TestCase {
 
         tr = new ThreadRunner(thr, perthr) {
             public void makeRequest(int i) throws Exception {
-                HttpRequest cstate = clientCon.request("localhost", 
+                HttpRequest cstate = clientCon.request("localhost",
                         ssl ? 8443 : 8802);
                 synchronized (active) {
                     active.put(cstate, cstate);
@@ -163,9 +163,9 @@ public class LiveHttpThreadedTest extends TestCase {
                 cstate.setCompletedCallback(reqCallback);
                 // no body
                 cstate.getBody().close();
-                
+
                 cstate.send();
-                
+
                 while (active.size() >= thr) {
                     synchronized(thrlock) {
                         thrlock.wait();
@@ -181,34 +181,34 @@ public class LiveHttpThreadedTest extends TestCase {
         }
         long time = (System.currentTimeMillis() - t0);
 
-        System.err.println("====== " + test + 
-                " threads: " + thr + ", req: " + 
-                reqCnt + ", sendTime" + tr.time + 
-                ", time: " + time + 
+        System.err.println("====== " + test +
+                " threads: " + thr + ", req: " +
+                reqCnt + ", sendTime" + tr.time +
+                ", time: " + time +
                 ", connections: " + clientCon.getConnectionPool().getSocketCount() +
                 ", avg: " + (time / reqCnt));
 
         assertEquals(reqCnt, ok.get());
         assertEquals(0, tr.errors.get());
     }
-    
+
     RequestCompleted reqCallback = new RequestCompleted() {
         @Override
-        public void handle(HttpChannel data, Object extraData) 
+        public void handle(HttpChannel data, Object extraData)
         throws IOException {
             String out = data.getIn().copyAll(null).toString();
             if (200 != data.getResponse().getStatus()) {
                 System.err.println("Wrong status");
-                tr.errors.incrementAndGet();            
+                tr.errors.incrementAndGet();
             } else if (!"Hello world".equals(out)) {
                 tr.errors.incrementAndGet();
                 System.err.println("bad result " + out);
-            }        
+            }
             synchronized (active) {
                 active.remove(data.getRequest());
             }
             synchronized (thrlock) {
-                thrlock.notify();                
+                thrlock.notify();
             }
             data.release();
             int okres = ok.incrementAndGet();
@@ -241,10 +241,10 @@ public class LiveHttpThreadedTest extends TestCase {
 
     }
 
-    /** 
+    /**
      * HttpURLConnection client against lite.http server.
      */
-    public void urlRequest(int thr, int cnt, final boolean ssl, String test) 
+    public void urlRequest(int thr, int cnt, final boolean ssl, String test)
             throws Exception {
         long t0 = System.currentTimeMillis();
 
@@ -259,7 +259,7 @@ public class LiveHttpThreadedTest extends TestCase {
                         BBuffer out = BBuffer.allocate();
                         String url = ssl ? "https://localhost:8443/hello" :
                             "http://localhost:8802/hello";
-                        HttpURLConnection con = 
+                        HttpURLConnection con =
                             TestMain.getUrl(url, out);
                         if (con.getResponseCode() != 200) {
                             errors.incrementAndGet();
@@ -278,7 +278,7 @@ public class LiveHttpThreadedTest extends TestCase {
             assertEquals(0, tr.errors.get());
             long time = (System.currentTimeMillis() - t0);
 
-            System.err.println("====== " + test + " threads: " + thr + ", req: " + 
+            System.err.println("====== " + test + " threads: " + thr + ", req: " +
                     (thr * cnt) + ", time: " + time + ", avg: " +
                     (time / (thr * cnt)));
         } finally {

==================================================
ThreadRunner.java
index 4539312f8f..732205e518 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/load/MicroTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/load/MicroTest.java
@@ -16,7 +16,7 @@ public class MicroTest extends TestCase {
         MappingData mappingData = new MappingData();
         CBuffer host = CBuffer.newInstance();
         host.set("test1.com");
-        
+
         CBuffer uri = CBuffer.newInstance();
         uri.set("/foo/bar/blah/bobou/foo");
 
@@ -45,6 +45,6 @@ public class MicroTest extends TestCase {
             mapper.map(host, uri, mappingData);
         }
         // TODO: asserts
-        //System.out.println("Elapsed:" + (System.currentTimeMillis() - time));        
+        //System.out.println("Elapsed:" + (System.currentTimeMillis() - time));
     }
 }

==================================================
LiveProxyHttp1Test.java
index 96fea90fe4..098f5b8bfb 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/load/ThreadRunner.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/load/ThreadRunner.java
@@ -9,12 +9,12 @@ public class ThreadRunner {
     int rCount = 100;
     Thread[] threads;
     int[] ok;
-    
+
     int sleepTime = 0;
-    
+
     long time;
     protected AtomicInteger errors = new AtomicInteger();
-    
+
     public ThreadRunner(int threads, int count) {
         tCount = threads;
         rCount = count;
@@ -33,7 +33,7 @@ public class ThreadRunner {
           });
           threads[i].start();
         }
-        
+
         int res = 0;
         for (int i = 0; i < tCount; i++) {
           try {
@@ -46,7 +46,7 @@ public class ThreadRunner {
         long t1 = System.currentTimeMillis();
         time = t1 - t0;
     }
-    
+
     public void makeRequests(int cnt) {
         for (int i = 0; i < rCount ; i++) {
             try {
@@ -57,8 +57,8 @@ public class ThreadRunner {
             }
           }
     }
-    
+
     public void makeRequest(int i) throws Exception {
-        
+
     }
 }
\ No newline at end of file

==================================================
ProxyTest.java
index 6a1b8e5ed3..d04d624de6 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/proxy/LiveProxyHttp1Test.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/proxy/LiveProxyHttp1Test.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -24,10 +24,10 @@ import org.apache.tomcat.lite.http.LiveHttp1Test;
 
 public class LiveProxyHttp1Test extends LiveHttp1Test {
     public void setUp() throws IOException {
-        // All tests in super, but with client pointing to 
+        // All tests in super, but with client pointing to
         // the proxy server, which in turn hits the real server.
         clientPort = 8903;
         super.setUp();
   }
-  
+
 }

==================================================
SmallProxyTest.java
index 1d21a57ade..9d3181c8bb 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/proxy/ProxyTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/proxy/ProxyTest.java
@@ -5,9 +5,9 @@ n * Licensed to the Apache Software Foundation (ASF) under one or more
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -26,95 +26,95 @@ import junit.framework.TestCase;
 public class ProxyTest extends TestCase {
 
   String resStr;
-    
+
   public void setUp() throws Exception {
       TestMain.getTestServer();
   }
-  
+
   public void tearDown() throws IOException {
   }
-  
+
   public void xtestRequestSlowChunked() throws Exception {
-      resStr = 
+      resStr =
           TestMain.get("http://localhost:8903/sleep/1c").toString();
       assertEquals("sleep 1csleep 1c", resStr);
   }
-  
+
   public void testSingleRequest() throws Exception {
-      String resStr = 
+      String resStr =
           TestMain.get("http://localhost:8903/hello").toString();
       assertEquals("Hello world", resStr);
   }
-  
+
 
   public void test2Requests() throws Exception {
-      String resStr = 
+      String resStr =
           TestMain.get("http://localhost:8903/hello").toString();
       assertEquals("Hello world", resStr);
-      resStr = 
+      resStr =
           TestMain.get("http://localhost:8903/hello?a=b").toString();
       assertEquals("Hello world", resStr);
   }
 
   public void testRequestSimple() throws Exception {
-      resStr = 
+      resStr =
           TestMain.get("http://localhost:8903/hello").toString();
       assertEquals("Hello world", resStr);
-      resStr = 
+      resStr =
           TestMain.get("http://localhost:8903/hello").toString();
       assertEquals("Hello world", resStr);
-      resStr = 
+      resStr =
           TestMain.get("http://localhost:8903/hello").toString();
       assertEquals(resStr, "Hello world");
 
   }
-  
+
   public void testExtAdapter() throws Exception {
-      String res = 
+      String res =
               TestMain.get("http://www.apache.org/").toString();
       assertTrue(res.indexOf("Apache") > 0);
-      
+
       Thread.currentThread().sleep(100);
       // second time - are we reusing ?
-      res = 
+      res =
           TestMain.get("http://www.apache.org/").toString();
-      
+
       assertTrue(res.indexOf("Apache") > 0);
-      
-  }  
-  
+
+  }
+
   public void testStaticAdapter() throws Exception {
-      
-      assertEquals("Hello world", 
+
+      assertEquals("Hello world",
           TestMain.get("http://localhost:8802/hello").toString());
-      assertEquals("Hello world2", 
+      assertEquals("Hello world2",
           TestMain.get("http://localhost:8802/2nd").toString());
-      
+
     }
-    
+
   public void testRequestParams() throws Exception {
       // qry string
-      String resStr = 
+      String resStr =
           TestMain.get("http://localhost:8903/echo/foo?q=a&b")
           .toString();
       assertTrue(resStr, resStr.indexOf("foo?q=a&b") > 0);
   }
 
-  
+
   public void testRequestChunked() throws Exception {
       // Chunked encoding
-      String resStr = 
+      String resStr =
           TestMain.get("http://localhost:8903/chunked/test")
           .toString();
       assertEquals(4, resStr.length());
       assertTrue(resStr.indexOf("AAA") >= 0);
   }
-  
+
 
   public void testRequestSlow() throws Exception {
       // Slow
-      String resStr = 
+      String resStr =
           TestMain.get("http://localhost:8903/sleep/1").toString();
       assertEquals("sleep 1sleep 1", resStr.toString());
-  }  
+  }
 }

==================================================
UEncoderTest.java
index 83ac8a974c..bc8bac9f72 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/proxy/SmallProxyTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/proxy/SmallProxyTest.java
@@ -13,14 +13,14 @@ import org.apache.tomcat.lite.io.MemoryIOConnector;
 import org.apache.tomcat.lite.io.MemoryIOConnector.MemoryIOChannel;
 
 public class SmallProxyTest extends TestCase {
-    
-    MemoryIOConnector memoryServerConnector = 
+
+    MemoryIOConnector memoryServerConnector =
         new MemoryIOConnector();
-    
-    MemoryIOConnector memoryClientConnector = 
+
+    MemoryIOConnector memoryClientConnector =
         new MemoryIOConnector().withServer(memoryServerConnector);
 
-    
+
     HttpConnector httpCon = new HttpConnector(memoryServerConnector) {
         @Override
         public HttpChannel get(CharSequence target) throws IOException {
@@ -45,12 +45,12 @@ public class SmallProxyTest extends TestCase {
             lastClient = new HttpChannel();
             lastClient.setConnector(this);
             return lastClient;
-        }        
+        }
         public HttpChannel getServer() {
             throw new RuntimeException();
         }
     };
-    
+
     HttpChannel lastServer;
     HttpChannel lastClient;
 
@@ -59,20 +59,20 @@ public class SmallProxyTest extends TestCase {
     boolean bodySentDone = false;
     boolean headersDone = false;
     boolean allDone = false;
-    
-    
-    //MemoryIOChannel clientNet = new MemoryIOChannel(); 
-    
+
+
+    //MemoryIOChannel clientNet = new MemoryIOChannel();
+
     MemoryIOConnector.MemoryIOChannel net = new MemoryIOChannel();
     HttpChannel http;
 
     HttpConnection serverConnection;
-    
+
     public void setUp() throws IOException {
         http = httpCon.getServer();
         serverConnection = httpCon.handleAccepted(net);
     }
- 
+
     /**
      * More complicated test..
      * @throws IOException
@@ -85,25 +85,25 @@ public class SmallProxyTest extends TestCase {
         net.getIn().append("GET http://www.apache.org/ HTTP/1.0\n" +
                 "Connection: Close\n\n");
         net.getIn().close();
-        
+
         // lastClient.rawSendBuffers has the request sent by proxy
         lastClient.getNet().getIn()
             .append("HTTP/1.0 200 OK\n\nHi\n");
         lastClient.getNet().getIn()
             .append("world\n");
-        
+
         // TODO: check what the proxy sent
         // lastClient.getOut();
-    
-        // will also trigger 'release' - both sides are closed. 
-        lastClient.getNet().getIn().close(); 
-        
-        // wait response... 
+
+        // will also trigger 'release' - both sides are closed.
+        lastClient.getNet().getIn().close();
+
+        // wait response...
         // http.sendBody.close();
         String res = net.out.toString();
         assertTrue(res.indexOf("Hi\nworld\n") > 0);
         assertTrue(res.indexOf("HTTP/1.0 200 OK") == 0);
         assertTrue(res.indexOf("tomcatproxy") > 0);
-        
-    }    
+
+    }
 }

==================================================
AntProperties.java
index 5048e28758..ba606f09c6 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/util/UEncoderTest.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/lite/util/UEncoderTest.java
@@ -21,17 +21,17 @@ import junit.framework.TestCase;
 
 public class UEncoderTest extends TestCase {
     URLEncoder enc=new URLEncoder();
-    
+
     /*
-     * 
+     *
      * Test method for 'org.apache.tomcat.util.buf.UEncoder.encodeURL(String)'
-     * TODO: find the relevant rfc and apache tests and add more 
+     * TODO: find the relevant rfc and apache tests and add more
      */
     public void testEncodeURL() {
 
         String eurl1=enc.encodeURL("test");
         assertEquals("test", eurl1);
-        
+
         eurl1=enc.encodeURL("/test");
         assertEquals("/test", eurl1);
 
@@ -45,7 +45,7 @@ public class UEncoderTest extends TestCase {
         eurl1=enc.encodeURL("//test");
         assertEquals("//test", eurl1);
 
-        
+
     }
 
 }

==================================================
CookieController.java
index b7e7ff3b12..7e1b03b072 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/AntProperties.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/AntProperties.java
@@ -5,11 +5,11 @@ package org.apache.tomcat.test.watchdog;
 import java.util.Hashtable;
 
 /**
- * Extracted from IntrospectionHelper - a simple utility class to 
+ * Extracted from IntrospectionHelper - a simple utility class to
  * do ant style ${property} replacements on a string, using a map
- * holding properties. Also allows a hook for dynamic, on-demand 
+ * holding properties. Also allows a hook for dynamic, on-demand
  * properties.
- * 
+ *
  * @author Costin Manolache
  */
 public class AntProperties {

==================================================
DynamicObject.java
index f63bd1a0e4..0c7e64c586 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/CookieController.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/CookieController.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -31,13 +31,13 @@ import java.util.Vector;
 
 
 /**
- * Represents a collection of Cookie instances. 
+ * Represents a collection of Cookie instances.
  * <p>
  * Fires events when the cookies have been changed internally. Deals
  * with management of cookies in terms of saving and loading them,
  * and disabling them.
  *
- * @author	Ramesh.Mandava 
+ * @author	Ramesh.Mandava
  */
 public class CookieController {
 
@@ -64,10 +64,10 @@ public class CookieController {
 	}	
 	try {
 	/*
-        Properties properties = new Properties(); 
+        Properties properties = new Properties();
 	FileInputStream fin = new FileInputStream("ServerAutoRun.properties");
 	properties.load(fin);
-      
+
 	String cookiepolicy = properties.getProperty("cookie.acceptpolicy");
 	if (cookiepolicy == null || cookiepolicy.equals("none")) {
 	    return;
@@ -155,7 +155,7 @@ public class CookieController {
 	    return;
 	}
 	synchronized (cookieJar) {
-	    
+	
 	    String domain = cookie.getDomain().toLowerCase();
 
 	    Vector cookieList = (Vector)cookieJar.get(domain);
@@ -165,7 +165,7 @@ public class CookieController {
 
 	    addOrReplaceCookie(cookieList, cookie);
 	    cookieJar.put(domain, cookieList);
-	    
+	
 	}
 
     }
@@ -210,8 +210,8 @@ public class CookieController {
 	}
 	
 	
-	// Do the replace - if cookie has already expired, remove 
-	// the replaced cookie. 
+	// Do the replace - if cookie has already expired, remove
+	// the replaced cookie.
 	if (replaced != null) {
 	    if (cookie.isSaveableInMemory()) {
 		cookies.setElementAt(cookie, replacedIndex);
@@ -226,7 +226,7 @@ public class CookieController {
 	    if (cookie.isSaveableInMemory()) {
 		cookies.addElement(cookie);
 		//System.out.println("RECORDED new cookie " + cookie);
-	    } 
+	    }
 
 	}
 
@@ -236,7 +236,7 @@ public class CookieController {
 
        try {	
 		/*
-		Properties properties = new Properties(); 
+		Properties properties = new Properties();
 		FileInputStream fin = new FileInputStream("ServerAutoRun.properties");
 		properties.load(fin);
 		// check current accept policy instead enableCookies
@@ -259,7 +259,7 @@ public class CookieController {
 
     }
 
-    
+
    /**
      * Host may be a FQDN, or a partial domain name starting with a dot.
      * Adds any cookies which match the host and path to the
@@ -279,12 +279,12 @@ public class CookieController {
 		    cookieString = cookieString + "; " + cookie.getNameValue();
 		}
 	    }
-	    
+	
 	 /*
 
 	    if( cookieString != null ) {
 		httpConn.setRequestProperty("Cookie", cookieString);
-	 
+	
 //		System.out.println("Returned cookie string: " + cookieString + " for HOST = " + host);
 	     }
 
@@ -307,7 +307,7 @@ public class CookieController {
 	while ((index = host.indexOf('.', 1)) >= 0) {
 	    // trim off everything up to, and including the dot.
 	    host = host.substring(index+1);
-	    
+	
             // add onto cookieVector
 	    tempVector = getSubsetRelevantCookies(host,url);
 	    if (tempVector != null ) {
@@ -334,13 +334,13 @@ public class CookieController {
 	    if (cookieList == null) {
 		cookieList = new Vector(10);
 	    }
-	    Enumeration cookies = cookiePortList.elements(); 
+	    Enumeration cookies = cookiePortList.elements();
 	    while (cookies.hasMoreElements()) {
 		cookieList.addElement(cookies.nextElement());
-	    }  
+	    }
 	}
 	
-	    
+	
 	if (cookieList == null) {
 	    return null;
 	}
@@ -460,15 +460,15 @@ public class CookieController {
 		if (cookie.getExpirationDate() != null) {
 		    if (cookie.isSaveable()) {
 			pw.println(cookie);
-		    } else { // the cookie must have expired, 
+		    } else { // the cookie must have expired,
 			//remove from Vector cookieList
 			cookieList.removeElement(cookie);
 		    }
-		 
-		}   
+		
+		}
 	    }
 	}
-        // Must print something to the printwriter in the case that 
+        // Must print something to the printwriter in the case that
 	// the cookieJar has been cleared - otherwise the old cookie
 	// file will continue to exist.
 	pw.print("");
@@ -495,7 +495,7 @@ public class CookieController {
     public void loadCookieJarFromFile(String cookieFileName) {
 	try {
 	    FileReader fr = new FileReader(cookieFileName);
-	    
+	
 	    BufferedReader in = new BufferedReader(fr);
 
 	    try {
@@ -511,13 +511,13 @@ public class CookieController {
 		in.close();
 	    }
 
-	    
+	
 	} catch (IOException e) {
 	    // do nothing; it's not an error not to have persistent cookies
 	}
 
     }
-    
+
     /* saves the cookies to the given file specified by fname */
     public void saveCookieJarToFile(String cookieFileName) {
 	try {
@@ -554,7 +554,7 @@ public class CookieController {
 		for (int i = 0; i < v.size(); i++) {
 		    HttpCookie hc = (HttpCookie) v.elementAt(i);
 		    result.addElement(hc);
-		    
+		
 		}
 		
 	    }
@@ -584,7 +584,7 @@ public class CookieController {
 	    cookieArr[i++] = (HttpCookie)e.nextElement();
 //	    System.out.println("cookieArr["+(i-1)+"] = " +cookieArr[i-1].toString());
 	}
-	    
+	
 	return cookieArr;
     }
 
@@ -611,7 +611,7 @@ public class CookieController {
 	
     }
 
-    /* 
+    /*
      * purges any expired cookies in the Cookie hashtable.
      */
     public void purgeExpiredCookies() {
@@ -627,7 +627,7 @@ public class CookieController {
 		
 		if (cookie.hasExpired()) {
 		    cookieList.removeElement(cookie);
-		}   
+		}
 	    }
 	}
 

==================================================
HttpCookie.java
index 6d618858ae..c01b5bedbb 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/DynamicObject.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/DynamicObject.java
@@ -20,11 +20,11 @@ import java.util.logging.Logger;
 
 /**
  * Refactoring of IntrospectionUtils and modeler dynamic bean.
- * 
+ *
  * Unlike IntrospectionUtils, the method informations can be cached.
- * Also I hope this class will be simpler to use. 
+ * Also I hope this class will be simpler to use.
  * There is no static cache.
- * 
+ *
  * @author Costin Manolache
  */
 public class DynamicObject {
@@ -45,7 +45,7 @@ public class DynamicObject {
             BigDecimal.class, BigInteger.class, AtomicInteger.class,
             AtomicLong.class, java.io.File.class, };
 
-    
+
     private Class realClass;
 
     // Method or Field
@@ -99,7 +99,7 @@ public class DynamicObject {
                 getAttMap.put(fields[j].getName(), fields[j]);
             }
         }
-        
+
     }
 
     public List<String> attributeNames() {
@@ -148,11 +148,11 @@ public class DynamicObject {
         }
     }
 
-    /** 
+    /**
      * Set an object-type attribute.
-     * 
-     * Use setProperty to use a string value and convert it to the 
-     * specific (primitive) type. 
+     *
+     * Use setProperty to use a string value and convert it to the
+     * specific (primitive) type.
      */
     public boolean setAttribute(Object proxy, String name, Object value) {
         // TODO: use the cache...
@@ -188,7 +188,7 @@ public class DynamicObject {
 
         try {
             Method methods[] = proxy.getClass().getMethods();
-            
+
             Method setPropertyMethod = null;
 
             // First, the ideal case - a setFoo( String ) method
@@ -213,7 +213,7 @@ public class DynamicObject {
                     }
                 }
                 // save "setProperty" for later
-                if ("setProperty".equals(methods[i].getName()) && 
+                if ("setProperty".equals(methods[i].getName()) &&
                         paramT.length == 2 &&
                         paramT[0] == String.class &&
                         paramT[1] == String.class) {
@@ -251,7 +251,7 @@ public class DynamicObject {
     }
 
     // ----------- Helpers ------------------
-    
+
     static Object convert(String object, Class<?> paramType) {
         Object result = null;
         if ("java.lang.String".equals(paramType.getName())) {
@@ -285,7 +285,7 @@ public class DynamicObject {
 
     /**
      * Converts the first character of the given String into lower-case.
-     * 
+     *
      * @param name
      *            The string to convert
      * @return String
@@ -302,7 +302,7 @@ public class DynamicObject {
     /**
      * Check if this class is one of the supported types. If the class is
      * supported, returns true. Otherwise, returns false.
-     * 
+     *
      * @param ret
      *            The class to check
      * @return boolean True if class is supported
@@ -322,7 +322,7 @@ public class DynamicObject {
     /**
      * Check if this class conforms to JavaBeans specifications. If the class is
      * conformant, returns true.
-     * 
+     *
      * @param javaType
      *            The class to check
      * @return boolean True if the class is compatible.
@@ -357,7 +357,7 @@ public class DynamicObject {
         }
         return true;
     }
-    
+
     /**
      * Reverse of Introspector.decapitalize
      */
@@ -380,6 +380,6 @@ public class DynamicObject {
             return true;
         return false;
     }
-    
-    
+
+
 }

==================================================
RfcDateParser.java
index 33e21a07ca..0a7e9c9b8f 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/HttpCookie.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/HttpCookie.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -151,22 +151,22 @@ public class HttpCookie {
 	}
 
 	// commented the following out, b/c ok to have no expirationDate
-	// that means that the cookie should last only for that particular 
+	// that means that the cookie should last only for that particular
 	// session.
 	//	if (expirationDate == null) {
 	//     	    expirationDate = getDefaultExpiration();
 	//	}
     }
-    
+
     /* Returns the default expiration, which is the current time + default
        expiration as specified in the properties file.
-       This uses reflection to get at the properties file, since Globals is 
-       not in the utils/ directory 
+       This uses reflection to get at the properties file, since Globals is
+       not in the utils/ directory
        */
     private Date getDefaultExpiration() {
 	if (defaultSet == false) {
 	    Properties props = new Properties();
-	    
+	
 	    try {
 		FileInputStream fin = new FileInputStream("ServerAutoRun.properties");
 		props.load( fin );
@@ -177,13 +177,13 @@ public class HttpCookie {
 	    } catch (IOException ex) {
 		System.out.println("HttpCookie getDefaultExpiration : ServerAutoRun.properties not found!" + ex);
 	    }
-	    
+	
 		 // defExprTime = props.getProperty("cookies.default.expiration");
 		 defExprTime = Long.parseLong( props.getProperty("cookies.default.expiration") );
 
 	    }
 	    defaultSet = true;
-	  
+	
 	return (new Date(System.currentTimeMillis() + defExprTime));
 	
     }

==================================================
WatchdogClient.java
index 2aeebb7f18..9a7f604b02 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/RfcDateParser.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/RfcDateParser.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -26,7 +26,7 @@ import java.util.TimeZone;
  * attempt to parse it by trying matches with a set of patterns, returning
  * null on failure, a Date object on success.
  *
- * @author Ramesh.Mandava 
+ * @author Ramesh.Mandava
  */
 public class RfcDateParser {
 
@@ -86,7 +86,7 @@ public class RfcDateParser {
         }
 
         return null;
-    }    
+    }
 
     private Date tryParsing(String format) {
 

==================================================
WatchdogHttpClient.java
index ccd2d6fe35..05b481c0c4 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/WatchdogClient.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/WatchdogClient.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -39,32 +39,32 @@ import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 
 public class WatchdogClient {
-        
-  protected String goldenDir; 
+
+  protected String goldenDir;
   protected String testMatch;
   protected String file;
   protected String[] exclude = null;
-  protected String[] slow = 
-  { 
-      "SingleModelTest" // slow  
-  };  
+  protected String[] slow =
+  {
+      "SingleModelTest" // slow
+  };
 
   protected String targetMatch;
-  
+
   protected int port;
-  
+
   Properties props = new Properties();
-  
+
   protected void beforeSuite() {
   }
-  
+
   protected void afterSuite(TestResult res) {
   }
-  
+
   public Test getSuite() {
       return getSuite(port);
   }
-  
+
   public static class NullResolver implements EntityResolver {
       public InputSource resolveEntity (String publicId,
                                                  String systemId)
@@ -73,7 +73,7 @@ public class WatchdogClient {
           return new InputSource(new StringReader(""));
       }
   }
-  
+
   /** Read XML as DOM.
    */
   public static Document readXml(InputStream is)
@@ -89,10 +89,10 @@ public class WatchdogClient {
       Document doc = db.parse(is);
       return doc;
   }
-  
-  /** 
-   * Return a test suite for running a watchdog-like 
-   * test file. 
+
+  /**
+   * Return a test suite for running a watchdog-like
+   * test file.
    *
    * @param base base dir for the watchdog dir
    * @param testMatch Prefix of tests to be run
@@ -101,13 +101,13 @@ public class WatchdogClient {
   public Test getSuite(int port) {
     TestSuite tests = new WatchdogTests();
     tests.setName(this.getClass().getSimpleName());
-    
+
     props.setProperty("port", Integer.toString(port));
     props.setProperty("host", "localhost");
-    props.setProperty("wgdir", 
+    props.setProperty("wgdir",
         goldenDir);
-    
-    
+
+
     try {
       Document doc = readXml(new FileInputStream(file));
       Element docE = doc.getDocumentElement();
@@ -118,10 +118,10 @@ public class WatchdogClient {
         if (targetMatch != null && !targetName.equals(targetMatch)) {
             continue;
         }
-        
+
         // Tests are duplicated
         //TestSuite targetSuite = new TestSuite(targetName);
-        
+
         NodeList watchDogL = target.getElementsByTagName("watchdog");
         for (int j = 0; j < watchDogL.getLength(); j++) {
           Element watchE = (Element) watchDogL.item(j);
@@ -138,7 +138,7 @@ public class WatchdogClient {
               boolean found = false;
               for (String e: exclude) {
                   if (e.equals(testName)) {
-                      found = true; 
+                      found = true;
                       break;
                   }
               }
@@ -155,7 +155,7 @@ public class WatchdogClient {
           }
         }
       }
-      
+
     } catch (IOException e) {
         e.printStackTrace();
     } catch (SAXException e) {
@@ -165,7 +165,7 @@ public class WatchdogClient {
     }
     return tests;
   }
-  
+
   // --------- Inner classes -------------
 
   protected String getWatchdogdir() {
@@ -193,10 +193,10 @@ public class WatchdogClient {
   }
 
   // Support for running a single test in the suite
-  
+
   protected String single;
   WatchdogTestCase singleTest;
-  
+
   public int countTestCases() {
       return 1;
   }

==================================================
WatchdogTestCase.java
index 0763c48966..2464f3398e 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/WatchdogHttpClient.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/WatchdogHttpClient.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -33,16 +33,16 @@ import java.util.Vector;
 public class WatchdogHttpClient {
     private static final String CRLF         = "\r\n";
     private static final int LINE_FEED       = 10;
-    
+
     static int debug = 0;
-    
+
     public static void dispatch(WatchdogTestImpl client) throws Exception {
         HashMap requestHeaders = client.requestHeaders;
         String host = client.host;
         int port = client.port;
         String content = client.content;
         String request = client.request;
-        
+
         // XXX headers are ignored
         Socket socket;
         try {
@@ -52,7 +52,7 @@ public class WatchdogHttpClient {
             return;
         }
         socket.setSoTimeout(10000);
-        
+
         //socket obtained, rebuild the request.
         rebuildRequest(client, client.request, socket);
 
@@ -61,7 +61,7 @@ public class WatchdogHttpClient {
         // Write the request
         socket.setSoLinger( true, 1000 );
 
-        OutputStream out = new BufferedOutputStream( 
+        OutputStream out = new BufferedOutputStream(
                                socket.getOutputStream() );
         StringBuffer reqbuf = new StringBuffer( 128 );
 
@@ -93,10 +93,10 @@ public class WatchdogHttpClient {
         }
         reqbuf.append( client.request ).append( CRLF );
 
-        // append all request headers 
+        // append all request headers
         if ( !requestHeaders.isEmpty() ) {
             Iterator iter = requestHeaders.keySet().iterator();
-                        
+
             while ( iter.hasNext() ) {
                 StringBuffer tmpBuf = new StringBuffer(32);
                 String headerKey = ( String ) iter.next();
@@ -131,12 +131,12 @@ public class WatchdogHttpClient {
             reqbuf.append( "" ).append( CRLF );
         }
 
-        // append request content 
+        // append request content
         if ( content != null ) {
             reqbuf.append( content );
             // XXX no CRLF at the end -see HTTP specs!
         }
-        
+
         byte[] reqbytes = reqbuf.toString().getBytes();
 
         try {
@@ -153,7 +153,7 @@ public class WatchdogHttpClient {
 
         // read the response
         try {
-  
+
                 client.responseLine = read( in );
 
                 if ( debug > 0 ) {
@@ -161,7 +161,7 @@ public class WatchdogHttpClient {
                 }
 
                 client.headers = parseHeaders( client, in );
-           
+
             byte[] result = readBody( in );
 
             if ( result != null ) {
@@ -170,7 +170,7 @@ public class WatchdogHttpClient {
                             System.out.println( " RESPONSE BODY:\n" + new String( client.responseBody ) );
                         }
                 }
-                
+
         } catch ( SocketException ex ) {
             System.out.println( " Socket Exception: " + ex );
         } finally {
@@ -180,9 +180,9 @@ public class WatchdogHttpClient {
                 socket.close();
                 socket = null;
             }
-        
+
     }
-    
+
     /**
      * <code>readBody</code> reads the body of the response
      * from the InputStream.
@@ -204,7 +204,7 @@ public class WatchdogHttpClient {
                     }
                 }
                 sb.append( ( char ) ch );
-                 
+
             } catch ( IOException ex ) {
                 return null;
             }
@@ -259,7 +259,7 @@ public class WatchdogHttpClient {
         return  sb.toString();
     }
 
-    
+
     // ==================== Code from JSERV !!! ====================
     /**
      * Parse the incoming HTTP request headers, and set the corresponding
@@ -323,14 +323,14 @@ public class WatchdogHttpClient {
 
     /**
      * <code>CRBufferedInputStream</code> is a modified version of
-     * the java.io.BufferedInputStream class.  The fill code is 
+     * the java.io.BufferedInputStream class.  The fill code is
      * the same, but the read is modified in that if a carriage return
-     * is found in the response stream from the target server, 
+     * is found in the response stream from the target server,
      * it will skip that byte and return the next in the stream.
      */
     private static class CRBufferedInputStream extends BufferedInputStream {
         private static final int CARRIAGE_RETURN = 13;
-        
+
         private static final int DEFAULT_BUFFER = 2048;
 
         /**
@@ -401,11 +401,11 @@ public class WatchdogHttpClient {
                 }
             }
             count = pos;
-            int n = in.read(buf, pos, buf.length - pos); 
+            int n = in.read(buf, pos, buf.length - pos);
             if (n > 0) {
                 count = n + pos;
             }
         }
     }
-    
+
 }

==================================================
WatchdogTestImpl.java
index 344f725498..8da9b35aec 100644
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/WatchdogTestCase.java
+++ b/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/WatchdogTestCase.java
@@ -20,11 +20,11 @@ public class WatchdogTestCase implements Test {
     private Properties props;
 
     private WatchdogClient wc;
-    
+
     public WatchdogTestCase() {
-        
+
     }
-    
+
     public WatchdogTestCase(Element watchE, Properties props, String testName) {
         this.testName = testName;
         this.watchE = watchE;
@@ -42,10 +42,10 @@ public class WatchdogTestCase implements Test {
     public String toString() {
         return getName();
     }
-    
+
     public void testDummy() {
     }
-    
+
     public void run(TestResult res) {
         if (watchE == null) {
             res.endTest(this);
@@ -60,7 +60,7 @@ public class WatchdogTestCase implements Test {
             String value = n.getNodeValue();
             value = AntProperties.replaceProperties(value, props, null);
             try {
-                new DynamicObject(test.getClass()).setProperty(test, 
+                new DynamicObject(test.getClass()).setProperty(test,
                         name, value);
             } catch (Exception e) {
                 // TODO Auto-generated catch block

==================================================
