95bda71b55f78df6c2bc5067f76e840ae35f1ee0
==================================================
Don't assume servlet 3+ async when processing long poll connections (it might be comet)
==================================================
Mark Emlyn
==================================================
Wed Jan 26 16:11:46 2011 +0000
==================================================
Http11AprProtocol.java
Don't assume servlet 3+ async when processing long poll connections (it might be comet)
Use socket rather than socket wrapper as key in connection list else comet sockets may be lost

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1063774 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AprEndpoint.java
index 916520b441..a706cac3d2 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -204,8 +204,8 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
         protected AtomicLong registerCount = new AtomicLong(0);
         protected RequestGroupInfo global = new RequestGroupInfo();
         
-        protected ConcurrentHashMap<SocketWrapper<Long>, Http11AprProcessor> connections =
-            new ConcurrentHashMap<SocketWrapper<Long>, Http11AprProcessor>();
+        protected ConcurrentHashMap<Long, Http11AprProcessor> connections =
+            new ConcurrentHashMap<Long, Http11AprProcessor>();
 
         protected ConcurrentLinkedQueue<Http11AprProcessor> recycledProcessors = 
             new ConcurrentLinkedQueue<Http11AprProcessor>() {
@@ -264,7 +264,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
         
         @Override
         public SocketState event(SocketWrapper<Long> socket, SocketStatus status) {
-            Http11AprProcessor processor = connections.get(socket);
+            Http11AprProcessor processor = connections.get(socket.getSocket());
             
             SocketState state = SocketState.CLOSED; 
             if (processor != null) {
@@ -294,7 +294,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
                                 "http11protocol.proto.error"), e);
                     } finally {
                         if (state != SocketState.LONG) {
-                            connections.remove(socket);
+                            connections.remove(socket.getSocket());
                             socket.setAsync(false);
                             recycledProcessors.offer(processor);
                             if (state == SocketState.OPEN) {
@@ -329,8 +329,13 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
                 if (state == SocketState.LONG || state == SocketState.ASYNC_END) {
                     // Need to make socket available for next processing cycle
                     // but no need for the poller
-                    connections.put(socket, processor);
-                    socket.setAsync(true);
+                    connections.put(socket.getSocket(), processor);
+                    if (processor.isAsync()) {
+                        socket.setAsync(true);
+                    } else if (processor.comet) {
+                        ((AprEndpoint) proto.endpoint).getCometPoller().add(
+                                socket.getSocket().longValue());
+                    }
                 } else {
                     recycledProcessors.offer(processor);
                 }
@@ -362,7 +367,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
 
         @Override
         public SocketState asyncDispatch(SocketWrapper<Long> socket, SocketStatus status) {
-            Http11AprProcessor result = connections.get(socket);
+            Http11AprProcessor result = connections.get(socket.getSocket());
             
             SocketState state = SocketState.CLOSED; 
             if (result != null) {

==================================================
