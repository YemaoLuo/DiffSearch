64beeead88d3d8172d1e04b5bd2efca09deaaa93
==================================================
Code clean-up - no functional change
==================================================
Mark Thomas
==================================================
Thu Apr 13 17:11:10 2023 +0100
==================================================
BeanELResolver.java
Code clean-up - no functional change


==================================================
BeanSupportStandalone.java
index 9551b43489..7577163539 100644
--- a/java/jakarta/el/BeanELResolver.java
+++ b/java/jakarta/el/BeanELResolver.java
@@ -38,7 +38,7 @@ public class BeanELResolver extends ELResolver {
 
     private final boolean readOnly;
 
-    private final ConcurrentCache<String, BeanProperties> cache = new ConcurrentCache<>(CACHE_SIZE);
+    private final ConcurrentCache<String,BeanProperties> cache = new ConcurrentCache<>(CACHE_SIZE);
 
     /**
      * Creates a writable instance of the standard JavaBean resolver.
@@ -135,8 +135,8 @@ public class BeanELResolver extends ELResolver {
         // Find the matching method
         Method matchingMethod = Util.findMethod(context, base.getClass(), base, methodName, paramTypes, params);
 
-        Object[] parameters = Util.buildParameters(context, matchingMethod.getParameterTypes(),
-                matchingMethod.isVarArgs(), params);
+        Object[] parameters =
+                Util.buildParameters(context, matchingMethod.getParameterTypes(), matchingMethod.isVarArgs(), params);
 
         Object result = null;
         try {
@@ -174,7 +174,7 @@ public class BeanELResolver extends ELResolver {
     }
 
     abstract static class BeanProperties {
-        protected final Map<String, BeanProperty> properties;
+        protected final Map<String,BeanProperty> properties;
         protected final Class<?> type;
 
         BeanProperties(Class<?> type) throws ELException {
@@ -262,8 +262,8 @@ public class BeanELResolver extends ELResolver {
     private static final class ConcurrentCache<K, V> {
 
         private final int size;
-        private final Map<K, V> eden;
-        private final Map<K, V> longterm;
+        private final Map<K,V> eden;
+        private final Map<K,V> longterm;
 
         ConcurrentCache(int size) {
             this.size = size;

==================================================
ELContext.java
index 0414261359..e4db4b5589 100644
--- a/java/jakarta/el/BeanSupportStandalone.java
+++ b/java/jakarta/el/BeanSupportStandalone.java
@@ -49,7 +49,7 @@ class BeanSupportStandalone extends BeanSupport {
 
 
     private static PropertyDescriptor[] getPropertyDescriptors(Class<?> type) {
-        Map<String, PropertyDescriptor> pds = new HashMap<>();
+        Map<String,PropertyDescriptor> pds = new HashMap<>();
         Method[] methods = type.getMethods();
         for (Method method : methods) {
             if (!Modifier.isStatic(method.getModifiers())) {

==================================================
ELManager.java
index 0e80de277f..12840d1597 100644
--- a/java/jakarta/el/ELContext.java
+++ b/java/jakarta/el/ELContext.java
@@ -32,7 +32,7 @@ public abstract class ELContext {
 
     private Locale locale;
 
-    private Map<Class<?>, Object> map;
+    private Map<Class<?>,Object> map;
 
     private boolean resolved;
 
@@ -40,7 +40,7 @@ public abstract class ELContext {
 
     private List<EvaluationListener> listeners;
 
-    private Deque<Map<String, Object>> lambdaArguments = new ArrayDeque<>();
+    private Deque<Map<String,Object>> lambdaArguments = new ArrayDeque<>();
 
     public ELContext() {
         this.resolved = false;
@@ -235,7 +235,7 @@ public abstract class ELContext {
      * @since EL 3.0
      */
     public boolean isLambdaArgument(String name) {
-        for (Map<String, Object> arguments : lambdaArguments) {
+        for (Map<String,Object> arguments : lambdaArguments) {
             if (arguments.containsKey(name)) {
                 return true;
             }
@@ -253,7 +253,7 @@ public abstract class ELContext {
      * @since EL 3.0
      */
     public Object getLambdaArgument(String name) {
-        for (Map<String, Object> arguments : lambdaArguments) {
+        for (Map<String,Object> arguments : lambdaArguments) {
             Object result = arguments.get(name);
             if (result != null) {
                 return result;
@@ -270,7 +270,7 @@ public abstract class ELContext {
      *
      * @since EL 3.0
      */
-    public void enterLambdaScope(Map<String, Object> arguments) {
+    public void enterLambdaScope(Map<String,Object> arguments) {
         lambdaArguments.push(arguments);
     }
 

==================================================
ExpressionFactory.java
index b3787bbd3e..40749368d3 100644
--- a/java/jakarta/el/ELManager.java
+++ b/java/jakarta/el/ELManager.java
@@ -73,7 +73,7 @@ public class ELManager {
     }
 
     public Object defineBean(String name, Object bean) {
-        Map<String, Object> localBeans = getELContext().getLocalBeans();
+        Map<String,Object> localBeans = getELContext().getLocalBeans();
 
         if (bean == null) {
             return localBeans.remove(name);

==================================================
ImportHandler.java
index 546c7d2736..b05488ea6c 100644
--- a/java/jakarta/el/ExpressionFactory.java
+++ b/java/jakarta/el/ExpressionFactory.java
@@ -41,11 +41,11 @@ public abstract class ExpressionFactory {
 
     private static final String PROPERTY_NAME = "jakarta.el.ExpressionFactory";
 
-    private static final String PROPERTY_FILE = System.getProperty("java.home") + File.separator + "lib" +
-            File.separator + "el.properties";
+    private static final String PROPERTY_FILE =
+            System.getProperty("java.home") + File.separator + "lib" + File.separator + "el.properties";
 
     private static final CacheValue nullTcclFactory = new CacheValue();
-    private static final Map<CacheKey, CacheValue> factoryCache = new ConcurrentHashMap<>();
+    private static final Map<CacheKey,CacheValue> factoryCache = new ConcurrentHashMap<>();
 
     /**
      * Create a new {@link ExpressionFactory}. The class to use is determined by the following search order:
@@ -214,7 +214,7 @@ public abstract class ExpressionFactory {
      *
      * @since EL 3.0
      */
-    public Map<String, Method> getInitFunctionMap() {
+    public Map<String,Method> getInitFunctionMap() {
         return null;
     }
 

==================================================
LambdaExpression.java
index 936ec97bf3..82c26a867a 100644
--- a/java/jakarta/el/ImportHandler.java
+++ b/java/jakarta/el/ImportHandler.java
@@ -31,7 +31,7 @@ import java.util.concurrent.ConcurrentHashMap;
  */
 public class ImportHandler {
 
-    private static final Map<String, Set<String>> standardPackages = new HashMap<>();
+    private static final Map<String,Set<String>> standardPackages = new HashMap<>();
 
     static {
         // Servlet 6.0
@@ -272,10 +272,10 @@ public class ImportHandler {
 
     }
 
-    private Map<String, Set<String>> packageNames = new ConcurrentHashMap<>();
-    private Map<String, String> classNames = new ConcurrentHashMap<>();
-    private Map<String, Class<?>> clazzes = new ConcurrentHashMap<>();
-    private Map<String, Class<?>> statics = new ConcurrentHashMap<>();
+    private Map<String,Set<String>> packageNames = new ConcurrentHashMap<>();
+    private Map<String,String> classNames = new ConcurrentHashMap<>();
+    private Map<String,Class<?>> clazzes = new ConcurrentHashMap<>();
+    private Map<String,Class<?>> statics = new ConcurrentHashMap<>();
 
 
     public ImportHandler() {
@@ -398,7 +398,7 @@ public class ImportHandler {
 
         // Search the package imports - note there may be multiple matches
         // (which correctly triggers an error)
-        for (Map.Entry<String, Set<String>> entry : packageNames.entrySet()) {
+        for (Map.Entry<String,Set<String>> entry : packageNames.entrySet()) {
             if (!entry.getValue().isEmpty()) {
                 // Standard package where we know all the class names
                 if (!entry.getValue().contains(name)) {

==================================================
MapELResolver.java
index 899eacf2f4..737eadff61 100644
--- a/java/jakarta/el/LambdaExpression.java
+++ b/java/jakarta/el/LambdaExpression.java
@@ -25,7 +25,7 @@ public class LambdaExpression {
 
     private final List<String> formalParameters;
     private final ValueExpression expression;
-    private final Map<String, Object> nestedArguments = new HashMap<>();
+    private final Map<String,Object> nestedArguments = new HashMap<>();
     private ELContext context = null;
 
     public LambdaExpression(List<String> formalParameters, ValueExpression expression) {
@@ -61,7 +61,7 @@ public class LambdaExpression {
         // Build the argument map
         // Start with the arguments from any outer expressions so if there is
         // any overlap the local arguments have priority
-        Map<String, Object> lambdaArguments = new HashMap<>(nestedArguments);
+        Map<String,Object> lambdaArguments = new HashMap<>(nestedArguments);
         for (int i = 0; i < formalParamCount; i++) {
             lambdaArguments.put(formalParameters.get(i), args[i]);
         }

==================================================
StandardELContext.java
index eea566ca88..8b4dfa5cad 100644
--- a/java/jakarta/el/MapELResolver.java
+++ b/java/jakarta/el/MapELResolver.java
@@ -39,10 +39,10 @@ public class MapELResolver extends ELResolver {
     public Class<?> getType(ELContext context, Object base, Object property) {
         Objects.requireNonNull(context);
 
-        if (base instanceof Map<?, ?>) {
+        if (base instanceof Map<?,?>) {
             context.setPropertyResolved(base, property);
 
-            Map<?, ?> map = (Map<?, ?>) base;
+            Map<?,?> map = (Map<?,?>) base;
             if (readOnly || map.getClass() == UNMODIFIABLE) {
                 return null;
             }
@@ -57,9 +57,9 @@ public class MapELResolver extends ELResolver {
     public Object getValue(ELContext context, Object base, Object property) {
         Objects.requireNonNull(context);
 
-        if (base instanceof Map<?, ?>) {
+        if (base instanceof Map<?,?>) {
             context.setPropertyResolved(base, property);
-            return ((Map<?, ?>) base).get(property);
+            return ((Map<?,?>) base).get(property);
         }
 
         return null;
@@ -69,7 +69,7 @@ public class MapELResolver extends ELResolver {
     public void setValue(ELContext context, Object base, Object property, Object value) {
         Objects.requireNonNull(context);
 
-        if (base instanceof Map<?, ?>) {
+        if (base instanceof Map<?,?>) {
             context.setPropertyResolved(base, property);
 
             if (this.readOnly) {
@@ -79,7 +79,7 @@ public class MapELResolver extends ELResolver {
 
             try {
                 @SuppressWarnings("unchecked") // Must be OK
-                Map<Object, Object> map = ((Map<Object, Object>) base);
+                Map<Object,Object> map = ((Map<Object,Object>) base);
                 map.put(property, value);
             } catch (UnsupportedOperationException e) {
                 throw new PropertyNotWritableException(e);
@@ -91,7 +91,7 @@ public class MapELResolver extends ELResolver {
     public boolean isReadOnly(ELContext context, Object base, Object property) {
         Objects.requireNonNull(context);
 
-        if (base instanceof Map<?, ?>) {
+        if (base instanceof Map<?,?>) {
             context.setPropertyResolved(base, property);
             return this.readOnly || UNMODIFIABLE.equals(base.getClass());
         }
@@ -101,7 +101,7 @@ public class MapELResolver extends ELResolver {
 
     @Override
     public Class<?> getCommonPropertyType(ELContext context, Object base) {
-        if (base instanceof Map<?, ?>) {
+        if (base instanceof Map<?,?>) {
             return Object.class;
         }
         return null;

==================================================
StaticFieldELResolver.java
index 092d439f40..11121b7c0b 100644
--- a/java/jakarta/el/StandardELContext.java
+++ b/java/jakarta/el/StandardELContext.java
@@ -30,7 +30,7 @@ public class StandardELContext extends ELContext {
     private final FunctionMapper functionMapper;
     private final CompositeELResolver standardResolver;
     private final CompositeELResolver customResolvers;
-    private final Map<String, Object> localBeans = new HashMap<>();
+    private final Map<String,Object> localBeans = new HashMap<>();
 
 
     public StandardELContext(ExpressionFactory factory) {
@@ -108,14 +108,14 @@ public class StandardELContext extends ELContext {
     }
 
 
-    Map<String, Object> getLocalBeans() {
+    Map<String,Object> getLocalBeans() {
         return localBeans;
     }
 
 
     private static class StandardVariableMapper extends VariableMapper {
 
-        private Map<String, ValueExpression> vars;
+        private Map<String,ValueExpression> vars;
 
         @Override
         public ValueExpression resolveVariable(String variable) {
@@ -141,9 +141,9 @@ public class StandardELContext extends ELContext {
 
     private static class StandardBeanNameResolver extends BeanNameResolver {
 
-        private final Map<String, Object> beans;
+        private final Map<String,Object> beans;
 
-        StandardBeanNameResolver(Map<String, Object> beans) {
+        StandardBeanNameResolver(Map<String,Object> beans) {
             this.beans = beans;
         }
 
@@ -176,9 +176,9 @@ public class StandardELContext extends ELContext {
 
     private static class StandardFunctionMapper extends FunctionMapper {
 
-        private final Map<String, Method> methods = new HashMap<>();
+        private final Map<String,Method> methods = new HashMap<>();
 
-        StandardFunctionMapper(Map<String, Method> initFunctionMap) {
+        StandardFunctionMapper(Map<String,Method> initFunctionMap) {
             if (initFunctionMap != null) {
                 methods.putAll(initFunctionMap);
             }

==================================================
Util.java
index e4b32461a9..5b5c908392 100644
--- a/java/jakarta/el/StaticFieldELResolver.java
+++ b/java/jakarta/el/StaticFieldELResolver.java
@@ -85,8 +85,8 @@ public class StaticFieldELResolver extends ELResolver {
             if ("<init>".equals(methodName)) {
                 Constructor<?> match = Util.findConstructor(context, clazz, paramTypes, params);
 
-                Object[] parameters = Util.buildParameters(context, match.getParameterTypes(), match.isVarArgs(),
-                        params);
+                Object[] parameters =
+                        Util.buildParameters(context, match.getParameterTypes(), match.isVarArgs(), params);
 
                 Object result = null;
 
@@ -110,8 +110,8 @@ public class StaticFieldELResolver extends ELResolver {
                             Util.message(context, "staticFieldELResolver.methodNotFound", methodName, clazz.getName()));
                 }
 
-                Object[] parameters = Util.buildParameters(context, match.getParameterTypes(), match.isVarArgs(),
-                        params);
+                Object[] parameters =
+                        Util.buildParameters(context, match.getParameterTypes(), match.isVarArgs(), params);
 
                 Object result = null;
                 try {

==================================================
