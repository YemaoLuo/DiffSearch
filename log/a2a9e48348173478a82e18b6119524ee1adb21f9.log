a2a9e48348173478a82e18b6119524ee1adb21f9
==================================================
Add first part of generics for EL 5.0 API
==================================================
Mark Thomas
==================================================
Tue May 25 14:39:47 2021 +0100
==================================================
BeanELResolver.java
Add first part of generics for EL 5.0 API

There are more generics changes to implement around ValueExpression but
I want to do some more research as I think the current EL 5.0 API might
need some additional generics to get the full benefit.


==================================================
CompositeELResolver.java
index 7525e064b2..8eed486a8b 100644
--- a/java/jakarta/el/BeanELResolver.java
+++ b/java/jakarta/el/BeanELResolver.java
@@ -137,7 +137,7 @@ public class BeanELResolver extends ELResolver {
 
         ExpressionFactory factory = ELManager.getExpressionFactory();
 
-        String methodName = (String) factory.coerceToType(method, String.class);
+        String methodName = factory.coerceToType(method, String.class);
 
         // Find the matching method
         Method matchingMethod =

==================================================
ELContext.java
index d144f2ccc2..2ff04fae82 100644
--- a/java/jakarta/el/CompositeELResolver.java
+++ b/java/jakarta/el/CompositeELResolver.java
@@ -151,11 +151,11 @@ public class CompositeELResolver extends ELResolver {
     }
 
     @Override
-    public Object convertToType(ELContext context, Object obj, Class<?> type) {
+    public <T> T convertToType(ELContext context, Object obj, Class<T> type) {
         context.setPropertyResolved(false);
         int sz = this.size;
         for (int i = 0; i < sz; i++) {
-            Object result = this.resolvers[i].convertToType(context, obj, type);
+            T result = this.resolvers[i].convertToType(context, obj, type);
             if (context.isPropertyResolved()) {
                 return result;
             }

==================================================
ELResolver.java
index c58037a1b2..d406a12c7d 100644
--- a/java/jakarta/el/ELContext.java
+++ b/java/jakarta/el/ELContext.java
@@ -299,14 +299,14 @@ public abstract class ELContext {
      *
      * @since EL 3.0
      */
-    public Object convertToType(Object obj, Class<?> type) {
+    public <T> T convertToType(Object obj, Class<T> type) {
 
         boolean originalResolved = isPropertyResolved();
         setPropertyResolved(false);
         try {
             ELResolver resolver = getELResolver();
             if (resolver != null) {
-                Object result = resolver.convertToType(this, obj, type);
+                T result = resolver.convertToType(this, obj, type);
                 if (isPropertyResolved()) {
                     return result;
                 }

==================================================
ExpressionFactory.java
index 5c3a928eb0..43479e87bb 100644
--- a/java/jakarta/el/ELResolver.java
+++ b/java/jakarta/el/ELResolver.java
@@ -135,7 +135,7 @@ public abstract class ELResolver {
      *
      * @since EL 3.0
      */
-    public Object convertToType(ELContext context, Object obj, Class<?> type) {
+    public <T> T convertToType(ELContext context, Object obj, Class<T> type) {
         context.setPropertyResolved(false);
         return null;
     }

==================================================
TypeConverter.java
index 67b3556fb6..825386ff7b 100644
--- a/java/jakarta/el/ExpressionFactory.java
+++ b/java/jakarta/el/ExpressionFactory.java
@@ -226,7 +226,7 @@ public abstract class ExpressionFactory {
      * @throws ELException
      *              If the conversion fails
      */
-    public abstract Object coerceToType(Object obj, Class<?> expectedType);
+    public abstract <T> T coerceToType(Object obj, Class<T> expectedType);
 
     /**
      * @return This default implementation returns null

==================================================
ExpressionFactoryImpl.java
index 8acfddc9d7..abbae0e34c 100644
--- a/java/jakarta/el/TypeConverter.java
+++ b/java/jakarta/el/TypeConverter.java
@@ -57,6 +57,5 @@ public abstract class TypeConverter extends ELResolver {
     }
 
     @Override
-    public abstract Object convertToType(ELContext context, Object obj,
-            Class<?> type);
+    public abstract <T> T convertToType(ELContext context, Object obj, Class<T> type);
 }

==================================================
ELSupport.java
index d85ed93c7d..7f41d8c9d0 100644
--- a/java/org/apache/el/ExpressionFactoryImpl.java
+++ b/java/org/apache/el/ExpressionFactoryImpl.java
@@ -37,7 +37,7 @@ import org.apache.el.util.MessageFactory;
 public class ExpressionFactoryImpl extends ExpressionFactory {
 
     @Override
-    public Object coerceToType(Object obj, Class<?> type) {
+    public <T> T coerceToType(Object obj, Class<T> type) {
         return ELSupport.coerceToType(null, obj, type);
     }
 

==================================================
EvaluationContext.java
index 16fd4db0da..7a810155b5 100644
--- a/java/org/apache/el/lang/ELSupport.java
+++ b/java/org/apache/el/lang/ELSupport.java
@@ -488,13 +488,13 @@ public class ELSupport {
         }
     }
 
-    public static final Object coerceToType(final ELContext ctx, final Object obj,
-            final Class<?> type) throws ELException {
+    public static final <T> T coerceToType(final ELContext ctx, final Object obj,
+            final Class<T> type) throws ELException {
 
         if (ctx != null) {
             boolean originalIsPropertyResolved = ctx.isPropertyResolved();
             try {
-                Object result = ctx.getELResolver().convertToType(ctx, obj, type);
+                T result = ctx.getELResolver().convertToType(ctx, obj, type);
                 if (ctx.isPropertyResolved()) {
                     return result;
                 }
@@ -505,7 +505,9 @@ public class ELSupport {
 
         if (type == null || Object.class.equals(type) ||
                 (obj != null && type.isAssignableFrom(obj.getClass()))) {
-            return obj;
+            @SuppressWarnings("unchecked")
+            T result = (T) obj;
+            return result;
         }
 
         if (!COERCE_TO_ZERO) {
@@ -516,24 +518,35 @@ public class ELSupport {
         }
 
         if (String.class.equals(type)) {
-            return coerceToString(ctx, obj);
+            @SuppressWarnings("unchecked")
+            T result = (T) coerceToString(ctx, obj);
+            return result;
         }
         if (ELArithmetic.isNumberType(type)) {
-            return coerceToNumber(ctx, obj, type);
+            @SuppressWarnings("unchecked")
+            T result = (T) coerceToNumber(ctx, obj, type);
+            return result;
         }
         if (Character.class.equals(type) || Character.TYPE == type) {
-            return coerceToCharacter(ctx, obj);
+            @SuppressWarnings("unchecked")
+            T result = (T) coerceToCharacter(ctx, obj);
+            return result;
         }
         if (Boolean.class.equals(type) || Boolean.TYPE == type) {
-            return coerceToBoolean(ctx, obj, Boolean.TYPE == type);
+            @SuppressWarnings("unchecked")
+            T result = (T) coerceToBoolean(ctx, obj, Boolean.TYPE == type);
+            return result;
         }
         if (type.isEnum()) {
-            return coerceToEnum(ctx, obj, type);
+            @SuppressWarnings("unchecked")
+            T result = (T) coerceToEnum(ctx, obj, type);
+            return result;
         }
 
         // new to spec
-        if (obj == null)
+        if (obj == null) {
             return null;
+        }
         if (obj instanceof String) {
             String str = (String) obj;
             PropertyEditor editor = PropertyEditorManager.findEditor(type);
@@ -546,7 +559,9 @@ public class ELSupport {
             } else {
                 try {
                     editor.setAsText(str);
-                    return editor.getValue();
+                    @SuppressWarnings("unchecked")
+                    T result = (T) editor.getValue();
+                    return result;
                 } catch (RuntimeException e) {
                     if (str.isEmpty()) {
                         return null;
@@ -561,12 +576,16 @@ public class ELSupport {
         // for an empty map. The parser will always parse {} as an empty set.
         if (obj instanceof Set && type == Map.class &&
                 ((Set<?>) obj).isEmpty()) {
-            return Collections.EMPTY_MAP;
+            @SuppressWarnings("unchecked")
+            T result = (T) Collections.EMPTY_MAP;
+            return result;
         }
 
         // Handle arrays
         if (type.isArray() && obj.getClass().isArray()) {
-            return coerceToArray(ctx, obj, type);
+            @SuppressWarnings("unchecked")
+            T result = (T) coerceToArray(ctx, obj, type);
+            return result;
         }
 
         throw new ELException(MessageFactory.get("error.convert",

==================================================
JspContextWrapper.java
index 6f39efc222..a853b04f8b 100644
--- a/java/org/apache/el/lang/EvaluationContext.java
+++ b/java/org/apache/el/lang/EvaluationContext.java
@@ -148,7 +148,7 @@ public final class EvaluationContext extends ELContext {
     }
 
     @Override
-    public Object convertToType(Object obj, Class<?> type) {
+    public <T> T convertToType(Object obj, Class<T> type) {
         return elContext.convertToType(obj, type);
     }
 }

==================================================
TesterELResolverOne.java
index 746be094c9..718c8032af 100644
--- a/java/org/apache/jasper/runtime/JspContextWrapper.java
+++ b/java/org/apache/jasper/runtime/JspContextWrapper.java
@@ -496,8 +496,9 @@ public class JspContextWrapper extends PageContext implements VariableResolver {
      */
     private String findAlias(String varName) {
 
-        if (aliases == null)
+        if (aliases == null) {
             return varName;
+        }
 
         String alias = aliases.get(varName);
         if (alias == null) {
@@ -644,7 +645,7 @@ public class JspContextWrapper extends PageContext implements VariableResolver {
         }
 
         @Override
-        public Object convertToType(Object obj, Class<?> type) {
+        public <T> T convertToType(Object obj, Class<T> type) {
             return wrapped.convertToType(obj, type);
         }
 

==================================================
TesterELResolverTwo.java
index 07427f7827..478fe2868e 100644
--- a/test/jakarta/el/TesterELResolverOne.java
+++ b/test/jakarta/el/TesterELResolverOne.java
@@ -19,10 +19,12 @@ package jakarta.el;
 public class TesterELResolverOne extends TypeConverter {
 
     @Override
-    public Object convertToType(ELContext context, Object obj, Class<?> type) {
+    public <T> T convertToType(ELContext context, Object obj, Class<T> type) {
         if ("1".equals(obj) && type == String.class) {
             context.setPropertyResolved(obj, type);
-            return "ONE";
+            @SuppressWarnings("unchecked")
+            T result = (T) "ONE";
+            return result;
         }
         return null;
     }

==================================================
