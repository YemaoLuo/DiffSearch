b51f8ad1c91c635a17ea19695f92463cfc39b188
==================================================
Pull up Handler.process
==================================================
Mark Emlyn
==================================================
Fri Jul 8 18:01:30 2011 +0000
==================================================
AbstractProcessor.java
Pull up Handler.process

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1144405 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractProtocol.java
index 912dc25440..c0c168d91b 100644
--- a/java/org/apache/coyote/AbstractProcessor.java
+++ b/java/org/apache/coyote/AbstractProcessor.java
@@ -16,16 +16,19 @@
  */
 package org.apache.coyote;
 
+import java.io.IOException;
 import java.util.concurrent.Executor;
 
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
+import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketWrapper;
 
 /**
  * Provides functionality and attributes common to all supported protocols
  * (currently HTTP and AJP).
  */
-public abstract class AbstractProcessor implements ActionHook, Processor {
+public abstract class AbstractProcessor<S> implements ActionHook, Processor {
 
     protected Adapter adapter;
     protected final AsyncStateMachine asyncStateMachine;
@@ -100,4 +103,25 @@ public abstract class AbstractProcessor implements ActionHook, Processor {
     public SocketState asyncPostProcess() {
         return asyncStateMachine.asyncPostProcess();
     }
+
+    protected abstract boolean isComet();
+
+    /**
+     * Process HTTP requests. All requests are treated as HTTP requests to start
+     * with although they may change type during processing.
+     */
+    public abstract SocketState process(SocketWrapper<S> socket)
+        throws IOException;
+
+
+    /**
+     * Process in-progress Comet requests. These will start as HTTP requests.
+     */
+    public abstract SocketState event(SocketStatus status) throws IOException;
+
+    /**
+     * Process in-progress Servlet 3.0 Async requests. These will start as HTTP
+     * requests.
+     */
+    public abstract SocketState asyncDispatch(SocketStatus status);
 }

==================================================
AbstractAjpProcessor.java
index 8cbc31c804..d719bb940a 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -17,6 +17,7 @@
 package org.apache.coyote;
 
 import java.net.InetAddress;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -28,9 +29,12 @@ import javax.management.MalformedObjectNameException;
 import javax.management.ObjectName;
 
 import org.apache.juli.logging.Log;
+import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler;
+import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketWrapper;
 import org.apache.tomcat.util.res.StringManager;
 
 public abstract class AbstractProtocol implements ProtocolHandler,
@@ -456,14 +460,22 @@ public abstract class AbstractProtocol implements ProtocolHandler,
     
     // ------------------------------------------- Connection handler base class
     
-    protected abstract static class AbstractConnectionHandler
+    protected abstract static class AbstractConnectionHandler<S,P extends AbstractProcessor<S>>
             implements AbstractEndpoint.Handler {
 
+        protected abstract Log getLog();
+
         protected RequestGroupInfo global = new RequestGroupInfo();
         protected AtomicLong registerCount = new AtomicLong(0);
 
+        protected ConcurrentHashMap<SocketWrapper<S>,P> connections =
+            new ConcurrentHashMap<SocketWrapper<S>,P>();
+
+        protected RecycledProcessors<P,S> recycledProcessors =
+            new RecycledProcessors<P,S>(this);
+        
+
         protected abstract AbstractProtocol getProtocol();
-        protected abstract Log getLog();
 
 
         @Override
@@ -471,8 +483,88 @@ public abstract class AbstractProtocol implements ProtocolHandler,
             return global;
         }
 
+        @Override
+        public void recycle() {
+            recycledProcessors.clear();
+        }
+        
+
+        public SocketState process(SocketWrapper<S> socket,
+                SocketStatus status) {
+            P processor = connections.remove(socket);
+
+            socket.setAsync(false);
+
+            try {
+                if (processor == null) {
+                    processor = recycledProcessors.poll();
+                }
+                if (processor == null) {
+                    processor = createProcessor();
+                }
+
+                initSsl(socket, processor);
+
+                SocketState state = SocketState.CLOSED;
+                do {
+                    if (processor.isAsync() || state == SocketState.ASYNC_END) {
+                        state = processor.asyncDispatch(status);
+                    } else if (processor.isComet()) {
+                        state = processor.event(status);
+                    } else {
+                        state = processor.process(socket);
+                    }
+    
+                    if (state != SocketState.CLOSED && processor.isAsync()) {
+                        state = processor.asyncPostProcess();
+                    }
+                } while (state == SocketState.ASYNC_END);
+
+                if (state == SocketState.LONG) {
+                    // In the middle of processing a request/response. Keep the
+                    // socket associated with the processor. Exact requirements
+                    // depend on type of long poll
+                    longPoll(socket, processor);
+                } else if (state == SocketState.OPEN){
+                    // In keep-alive but between requests. OK to recycle
+                    // processor. Continue to poll for the next request.
+                    release(socket, processor, false, true);
+                } else {
+                    // Connection closed. OK to recycle the processor.
+                    release(socket, processor, true, false);
+                }
+                return state;
+            } catch(java.net.SocketException e) {
+                // SocketExceptions are normal
+                getLog().debug(sm.getString(
+                        "ajpprotocol.proto.socketexception.debug"), e);
+            } catch (java.io.IOException e) {
+                // IOExceptions are normal
+                getLog().debug(sm.getString(
+                        "ajpprotocol.proto.ioexception.debug"), e);
+            }
+            // Future developers: if you discover any other
+            // rare-but-nonfatal exceptions, catch them here, and log as
+            // above.
+            catch (Throwable e) {
+                ExceptionUtils.handleThrowable(e);
+                // any other exception or error is odd. Here we log it
+                // with "ERROR" level, so it will show up even on
+                // less-than-verbose logs.
+                getLog().error(sm.getString("ajpprotocol.proto.error"), e);
+            }
+            release(socket, processor, true, false);
+            return SocketState.CLOSED;
+        }
+        
+        protected abstract P createProcessor();
+        protected abstract void initSsl(SocketWrapper<S> socket, P processor);
+        protected abstract void longPoll(SocketWrapper<S> socket, P processor);
+        protected abstract void release(SocketWrapper<S> socket, P processor,
+                boolean socketClosing, boolean addToPoller);
+
 
-        protected void register(AbstractProcessor processor) {
+        protected void register(AbstractProcessor<S> processor) {
             if (getProtocol().getDomain() != null) {
                 synchronized (this) {
                     try {
@@ -499,7 +591,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
             }
         }
 
-        protected void unregister(AbstractProcessor processor) {
+        protected void unregister(AbstractProcessor<S> processor) {
             if (getProtocol().getDomain() != null) {
                 synchronized (this) {
                     try {
@@ -521,14 +613,14 @@ public abstract class AbstractProtocol implements ProtocolHandler,
         }
     }
     
-    protected static class RecycledProcessors<P extends AbstractProcessor>
+    protected static class RecycledProcessors<P extends AbstractProcessor<S>, S>
             extends ConcurrentLinkedQueue<P> {
 
         private static final long serialVersionUID = 1L;
-        private AbstractConnectionHandler handler;
+        private transient AbstractConnectionHandler<S,P> handler;
         protected AtomicInteger size = new AtomicInteger(0);
 
-        public RecycledProcessors(AbstractConnectionHandler handler) {
+        public RecycledProcessors(AbstractConnectionHandler<S,P> handler) {
             this.handler = handler;
         }
 

==================================================
AbstractAjpProtocol.java
index cde518ca7a..04a0f55777 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
@@ -42,13 +42,12 @@ import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
  * Base class for AJP Processor implementations.
  */
-public abstract class AbstractAjpProcessor<S> extends AbstractProcessor {
+public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
 
     protected abstract Log getLog();
 
@@ -213,11 +212,6 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor {
     protected long byteCount = 0;
 
 
-    /**
-     * AJP does not support comet
-     */
-    protected final boolean comet = false;
-
     // ------------------------------------------------------------ Constructor
 
     public AbstractAjpProcessor(int packetSize, AbstractEndpoint endpoint) {
@@ -459,9 +453,7 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor {
     protected abstract void finish() throws IOException;
 
 
-    public abstract SocketState process(SocketWrapper<S> socket)
-            throws IOException;
-
+    @Override
     public SocketState asyncDispatch(SocketStatus status) {
 
         RequestInfo rp = request.getRequestProcessor();
@@ -502,7 +494,13 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor {
     }
 
 
-    @SuppressWarnings("unused")
+    @Override
+    protected final boolean isComet() {
+        // AJP does not support Comet
+        return false;
+    }
+
+    @Override
     public SocketState event(SocketStatus status) throws IOException {
         // Should never reach this code but in case we do...
         throw new IOException(

==================================================
AbstractHttp11Processor.java
index c31d47d178..3e6c0600d8 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProtocol.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProtocol.java
@@ -16,11 +16,7 @@
  */
 package org.apache.coyote.ajp;
 
-import java.util.concurrent.ConcurrentHashMap;
-
 import org.apache.coyote.AbstractProtocol;
-import org.apache.tomcat.util.ExceptionUtils;
-import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapper;
 import org.apache.tomcat.util.res.StringManager;
 
@@ -77,99 +73,18 @@ public abstract class AbstractAjpProtocol extends AbstractProtocol {
     }
     
     protected abstract static class AbstractAjpConnectionHandler<S,P extends AbstractAjpProcessor<S>>
-            extends AbstractConnectionHandler {
-
-        protected ConcurrentHashMap<SocketWrapper<S>,P> connections =
-            new ConcurrentHashMap<SocketWrapper<S>,P>();
+            extends AbstractConnectionHandler<S, P> {
 
-        protected RecycledProcessors<P> recycledProcessors =
-            new RecycledProcessors<P>(this);
-        
         @Override
-        public void recycle() {
-            recycledProcessors.clear();
-        }
-        
-        public SocketState process(SocketWrapper<S> socket,
-                SocketStatus status) {
-            P processor = connections.remove(socket);
-
-            socket.setAsync(false);
-
-            try {
-                if (processor == null) {
-                    processor = recycledProcessors.poll();
-                }
-                if (processor == null) {
-                    processor = createProcessor();
-                }
-
-                initSsl(socket, processor);
-
-                SocketState state = SocketState.CLOSED;
-                do {
-                    if (processor.isAsync() || state == SocketState.ASYNC_END) {
-                        state = processor.asyncDispatch(status);
-                    } else if (processor.comet) {
-                        state = processor.event(status);
-                    } else {
-                        state = processor.process(socket);
-                    }
-    
-                    if (state != SocketState.CLOSED && processor.isAsync()) {
-                        state = processor.asyncPostProcess();
-                    }
-                } while (state == SocketState.ASYNC_END);
-
-                if (state == SocketState.LONG) {
-                    // In the middle of processing a request/response. Keep the
-                    // socket associated with the processor. Exact requirements
-                    // depend on type of long poll
-                    longPoll(socket, processor);
-                } else if (state == SocketState.OPEN){
-                    // In keep-alive but between requests. OK to recycle
-                    // processor. Continue to poll for the next request.
-                    release(socket, processor, false, true);
-                } else {
-                    // Connection closed. OK to recycle the processor.
-                    release(socket, processor, true, false);
-                }
-                return state;
-            } catch(java.net.SocketException e) {
-                // SocketExceptions are normal
-                getLog().debug(sm.getString(
-                        "ajpprotocol.proto.socketexception.debug"), e);
-            } catch (java.io.IOException e) {
-                // IOExceptions are normal
-                getLog().debug(sm.getString(
-                        "ajpprotocol.proto.ioexception.debug"), e);
-            }
-            // Future developers: if you discover any other
-            // rare-but-nonfatal exceptions, catch them here, and log as
-            // above.
-            catch (Throwable e) {
-                ExceptionUtils.handleThrowable(e);
-                // any other exception or error is odd. Here we log it
-                // with "ERROR" level, so it will show up even on
-                // less-than-verbose logs.
-                getLog().error(sm.getString("ajpprotocol.proto.error"), e);
-            }
-            release(socket, processor, true, false);
-            return SocketState.CLOSED;
-        }
-        
-        protected abstract P createProcessor();
-        @SuppressWarnings("unused")
         protected void initSsl(SocketWrapper<S> socket, P processor) {
             // NOOP for AJP
         }
+
+        @Override
         protected void longPoll(SocketWrapper<S> socket, P processor) {
             // Same requirements for all AJP connectors
             connections.put(socket, processor);
             socket.setAsync(true);
-            
         }
-        protected abstract void release(SocketWrapper<S> socket, P processor,
-                boolean socketClosing, boolean addToPoller);
     }
 }

==================================================
AbstractHttp11Protocol.java
index 54a3f4ca48..7d5385a3bd 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Processor.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Processor.java
@@ -47,10 +47,9 @@ import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
 import org.apache.tomcat.util.res.StringManager;
 
-public abstract class AbstractHttp11Processor<S> extends AbstractProcessor {
+public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
 
     protected abstract Log getLog();
 
@@ -1212,9 +1211,7 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor {
     }
 
     
-    public abstract SocketState process(SocketWrapper<S> socket)
-            throws IOException;
-    
+    @Override
     public SocketState asyncDispatch(SocketStatus status) {
 
         RequestInfo rp = request.getRequestProcessor();
@@ -1252,7 +1249,10 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor {
     }
 
 
-    public abstract SocketState event(SocketStatus status) throws IOException;
+    @Override
+    public boolean isComet() {
+        return comet;
+    }
 
 
     /**

==================================================
Http11AprProtocol.java
index b15c35b352..85b8371d03 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
@@ -16,12 +16,8 @@
  */
 package org.apache.coyote.http11;
 
-import java.util.concurrent.ConcurrentHashMap;
 
 import org.apache.coyote.AbstractProtocol;
-import org.apache.tomcat.util.ExceptionUtils;
-import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
 import org.apache.tomcat.util.res.StringManager;
 
 public abstract class AbstractHttp11Protocol extends AbstractProtocol {
@@ -187,94 +183,4 @@ public abstract class AbstractHttp11Protocol extends AbstractProtocol {
     public void setMaxKeepAliveRequests(int mkar) {
         endpoint.setMaxKeepAliveRequests(mkar);
     }
-
-
-    protected abstract static class AbstractHttp11ConnectionHandler<S,P extends AbstractHttp11Processor<S>>
-            extends AbstractConnectionHandler {
-        
-        protected ConcurrentHashMap<SocketWrapper<S>,P> connections =
-            new ConcurrentHashMap<SocketWrapper<S>,P>();
-
-        protected RecycledProcessors<P> recycledProcessors =
-            new RecycledProcessors<P>(this);
-        
-        @Override
-        public void recycle() {
-            recycledProcessors.clear();
-        }
-        
-        public SocketState process(SocketWrapper<S> socket,
-                SocketStatus status) {
-            P processor = connections.remove(socket);
-
-            socket.setAsync(false); //no longer check for timeout
-
-            try {
-                if (processor == null) {
-                    processor = recycledProcessors.poll();
-                }
-                if (processor == null) {
-                    processor = createProcessor();
-                }
-
-                initSsl(socket, processor);
-                
-                SocketState state = SocketState.CLOSED;
-                do {
-                    if (processor.isAsync() || state == SocketState.ASYNC_END) {
-                        state = processor.asyncDispatch(status);
-                    } else if (processor.comet) {
-                        state = processor.event(status);
-                    } else {
-                        state = processor.process(socket);
-                    }
-    
-                    if (state != SocketState.CLOSED && processor.isAsync()) {
-                        state = processor.asyncPostProcess();
-                    }
-                } while (state == SocketState.ASYNC_END);
-
-                if (state == SocketState.LONG) {
-                    // In the middle of processing a request/response. Keep the
-                    // socket associated with the processor. Exact requirements
-                    // depend on type of long poll
-                    longPoll(socket, processor);
-                } else if (state == SocketState.OPEN){
-                    // In keep-alive but between requests. OK to recycle
-                    // processor. Continue to poll for the next request.
-                    release(socket, processor, false, true);
-                } else {
-                    // Connection closed. OK to recycle the processor.
-                    release(socket, processor, true, false);
-                }
-                return state;
-            } catch(java.net.SocketException e) {
-                // SocketExceptions are normal
-                getLog().debug(sm.getString(
-                        "http11protocol.proto.socketexception.debug"), e);
-            } catch (java.io.IOException e) {
-                // IOExceptions are normal
-                getLog().debug(sm.getString(
-                        "http11protocol.proto.ioexception.debug"), e);
-            }
-            // Future developers: if you discover any other
-            // rare-but-nonfatal exceptions, catch them here, and log as
-            // above.
-            catch (Throwable e) {
-                ExceptionUtils.handleThrowable(e);
-                // any other exception or error is odd. Here we log it
-                // with "ERROR" level, so it will show up even on
-                // less-than-verbose logs.
-                getLog().error(sm.getString("http11protocol.proto.error"), e);
-            }
-            release(socket, processor, true, false);
-            return SocketState.CLOSED;
-        }
-        
-        protected abstract P createProcessor();
-        protected abstract void initSsl(SocketWrapper<S> socket, P processor);
-        protected abstract void longPoll(SocketWrapper<S> socket, P processor);
-        protected abstract void release(SocketWrapper<S> socket, P processor,
-                boolean socketClosing, boolean addToPoller);        
-    }
 }

==================================================
Http11NioProtocol.java
index f630dfbf42..ca8e49ca20 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -177,7 +177,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
     // --------------------  Connection handler --------------------
 
     protected static class Http11ConnectionHandler
-            extends AbstractHttp11ConnectionHandler<Long,Http11AprProcessor> implements Handler {
+            extends AbstractConnectionHandler<Long,Http11AprProcessor> implements Handler {
         
         protected Http11AprProtocol proto;
         

==================================================
Http11Protocol.java
index b3915ba42e..a589d85550 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -148,7 +148,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
     // --------------------  Connection handler --------------------
 
     protected static class Http11ConnectionHandler
-            extends AbstractHttp11ConnectionHandler<NioChannel,Http11NioProcessor>
+            extends AbstractConnectionHandler<NioChannel,Http11NioProcessor>
             implements Handler {
 
         protected Http11NioProtocol proto;

==================================================
