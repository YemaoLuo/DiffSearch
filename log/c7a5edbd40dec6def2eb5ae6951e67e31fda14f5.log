c7a5edbd40dec6def2eb5ae6951e67e31fda14f5
==================================================
Whitespace removal from remaining /java/org/apache/el
==================================================
Mark Emlyn
==================================================
Sat Oct 22 21:17:12 2011 +0000
==================================================
ExpressionFactoryImpl.java
Whitespace removal from remaining /java/org/apache/el

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1187802 13f79535-47bb-0310-9956-ffa450edef68



==================================================
MethodExpressionImpl.java
index a90bf7686d..bba9d83145 100644
--- a/java/org/apache/el/ExpressionFactoryImpl.java
+++ b/java/org/apache/el/ExpressionFactoryImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -29,14 +29,14 @@ import org.apache.el.util.MessageFactory;
 
 /**
  * @see javax.el.ExpressionFactory
- * 
+ *
  * @author Jacob Hookom [jacob@hookom.net]
  * @version $Id$
  */
 public class ExpressionFactoryImpl extends ExpressionFactory {
 
     /**
-     * 
+     *
      */
     public ExpressionFactoryImpl() {
         super();

==================================================
MethodExpressionLiteral.java
index e3fea05d91..8725c07a17 100644
--- a/java/org/apache/el/MethodExpressionImpl.java
+++ b/java/org/apache/el/MethodExpressionImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -39,38 +39,38 @@ import org.apache.el.util.ReflectionUtil;
 
 /**
  * An <code>Expression</code> that refers to a method on an object.
- * 
+ *
  * <p>
  * <code>The {@link javax.el.ExpressionFactory#createMethodExpression} method
  * can be used to parse an expression string and return a concrete instance
  * of <code>MethodExpression</code> that encapsulates the parsed expression.
- * The {@link FunctionMapper} is used at parse time, not evaluation time, 
- * so one is not needed to evaluate an expression using this class.  
+ * The {@link FunctionMapper} is used at parse time, not evaluation time,
+ * so one is not needed to evaluate an expression using this class.
  * However, the {@link ELContext} is needed at evaluation time.</p>
  *
- * <p>The {@link #getMethodInfo} and {@link #invoke} methods will evaluate the 
- * expression each time they are called. The {@link javax.el.ELResolver} in the 
- * <code>ELContext</code> is used to resolve the top-level variables and to 
- * determine the behavior of the <code>.</code> and <code>[]</code> 
+ * <p>The {@link #getMethodInfo} and {@link #invoke} methods will evaluate the
+ * expression each time they are called. The {@link javax.el.ELResolver} in the
+ * <code>ELContext</code> is used to resolve the top-level variables and to
+ * determine the behavior of the <code>.</code> and <code>[]</code>
  * operators. For any of the two methods, the
  * {@link javax.el.ELResolver#getValue} method is used to resolve all properties
  * up to but excluding the last one. This provides the <code>base</code> object
- * on which the method appears. If the <code>base</code> object is null, a 
- * <code>NullPointerException</code> must be thrown. At the last resolution, 
+ * on which the method appears. If the <code>base</code> object is null, a
+ * <code>NullPointerException</code> must be thrown. At the last resolution,
  * the final <code>property</code> is then coerced to a <code>String</code>,
- * which provides the name of the method to be found. A method matching the 
- * name and expected parameters provided at parse time is found and it is 
+ * which provides the name of the method to be found. A method matching the
+ * name and expected parameters provided at parse time is found and it is
  * either queried or invoked (depending on the method called on this
  * <code>MethodExpression</code>).</p>
  *
- * <p>See the notes about comparison, serialization and immutability in 
+ * <p>See the notes about comparison, serialization and immutability in
  * the {@link javax.el.Expression} javadocs.
  *
  * @see javax.el.ELResolver
  * @see javax.el.Expression
  * @see javax.el.ExpressionFactory
  * @see javax.el.MethodExpression
- * 
+ *
  * @author Jacob Hookom [jacob@hookom.net]
  * @version $Id$
  */
@@ -90,7 +90,7 @@ public final class MethodExpressionImpl extends MethodExpression implements
     private Class<?>[] paramTypes;
 
     /**
-     * 
+     *
      */
     public MethodExpressionImpl() {
         super();
@@ -118,7 +118,7 @@ public final class MethodExpressionImpl extends MethodExpression implements
     /**
      * Determines whether the specified object is equal to this
      * <code>Expression</code>.
-     * 
+     *
      * <p>
      * The result is <code>true</code> if and only if the argument is not
      * <code>null</code>, is an <code>Expression</code> object that is the
@@ -126,7 +126,7 @@ public final class MethodExpressionImpl extends MethodExpression implements
      * <code>MethodExpression</code>), and has an identical parsed
      * representation.
      * </p>
-     * 
+     *
      * <p>
      * Note that two expressions can be equal if their expression Strings are
      * different. For example, <code>${fn1:foo()}</code> and
@@ -134,7 +134,7 @@ public final class MethodExpressionImpl extends MethodExpression implements
      * <code>FunctionMapper</code>s mapped <code>fn1:foo</code> and
      * <code>fn2:foo</code> to the same method.
      * </p>
-     * 
+     *
      * @param obj
      *            the <code>Object</code> to test for equality.
      * @return <code>true</code> if <code>obj</code> equals this
@@ -151,22 +151,22 @@ public final class MethodExpressionImpl extends MethodExpression implements
     /**
      * Returns the original String used to create this <code>Expression</code>,
      * unmodified.
-     * 
+     *
      * <p>
      * This is used for debugging purposes but also for the purposes of
      * comparison (e.g. to ensure the expression in a configuration file has not
      * changed).
      * </p>
-     * 
+     *
      * <p>
      * This method does not provide sufficient information to re-create an
      * expression. Two different expressions can have exactly the same
      * expression string but different function mappings. Serialization should
      * be used to save and restore the state of an <code>Expression</code>.
      * </p>
-     * 
+     *
      * @return The original expression String.
-     * 
+     *
      * @see javax.el.Expression#getExpressionString()
      */
     @Override
@@ -177,7 +177,7 @@ public final class MethodExpressionImpl extends MethodExpression implements
     /**
      * Evaluates the expression relative to the provided context, and returns
      * information about the actual referenced method.
-     * 
+     *
      * @param context
      *            The context of this evaluation
      * @return an instance of <code>MethodInfo</code> containing information
@@ -219,7 +219,7 @@ public final class MethodExpressionImpl extends MethodExpression implements
 
     /**
      * Returns the hash code for this <code>Expression</code>.
-     * 
+     *
      * <p>
      * See the note in the {@link #equals} method on how two expressions can be
      * equal if their expression Strings are different. Recall that if two
@@ -228,7 +228,7 @@ public final class MethodExpressionImpl extends MethodExpression implements
      * objects must produce the same integer result. Implementations must take
      * special note and implement <code>hashCode</code> correctly.
      * </p>
-     * 
+     *
      * @return The hash code for this <code>Expression</code>.
      * @see #equals
      * @see java.util.Hashtable
@@ -243,7 +243,7 @@ public final class MethodExpressionImpl extends MethodExpression implements
      * Evaluates the expression relative to the provided context, invokes the
      * method that was found using the supplied parameters, and returns the
      * result of the method invocation.
-     * 
+     *
      * @param context
      *            The context of this evaluation.
      * @param params
@@ -280,7 +280,7 @@ public final class MethodExpressionImpl extends MethodExpression implements
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see java.io.Externalizable#readExternal(java.io.ObjectInput)
      */
     @Override
@@ -299,7 +299,7 @@ public final class MethodExpressionImpl extends MethodExpression implements
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see java.io.Externalizable#writeExternal(java.io.ObjectOutput)
      */
     @Override
@@ -327,5 +327,5 @@ public final class MethodExpressionImpl extends MethodExpression implements
     public boolean isParmetersProvided() {
         return this.getNode().isParametersProvided();
     }
-    
+
 }

==================================================
ValueExpressionImpl.java
index ebe9856271..e8b411ca3e 100644
--- a/java/org/apache/el/MethodExpressionLiteral.java
+++ b/java/org/apache/el/MethodExpressionLiteral.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
ValueExpressionLiteral.java
index 873d29589d..72e40441fc 100644
--- a/java/org/apache/el/ValueExpressionImpl.java
+++ b/java/org/apache/el/ValueExpressionImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -41,7 +41,7 @@ import org.apache.el.util.ReflectionUtil;
 
 /**
  * An <code>Expression</code> that can get or set a value.
- * 
+ *
  * <p>
  * In previous incarnations of this API, expressions could only be read.
  * <code>ValueExpression</code> objects can now be used both to retrieve a
@@ -53,13 +53,13 @@ import org.apache.el.util.ReflectionUtil;
  * details. Expressions that cannot be used as l-values must always return
  * <code>true</code> from <code>isReadOnly()</code>.
  * </p>
- * 
+ *
  * <p>
  * <code>The {@link javax.el.ExpressionFactory#createValueExpression} method
  * can be used to parse an expression string and return a concrete instance
  * of <code>ValueExpression</code> that encapsulates the parsed expression.
- * The {@link FunctionMapper} is used at parse time, not evaluation time, 
- * so one is not needed to evaluate an expression using this class.  
+ * The {@link FunctionMapper} is used at parse time, not evaluation time,
+ * so one is not needed to evaluate an expression using this class.
  * However, the {@link ELContext} is needed at evaluation time.</p>
  *
  * <p>The {@link #getValue}, {@link #setValue}, {@link #isReadOnly} and
@@ -76,14 +76,14 @@ import org.apache.el.util.ReflectionUtil;
  * method, depending on which was called on the <code>ValueExpression</code>.
  * </p>
  *
- * <p>See the notes about comparison, serialization and immutability in 
+ * <p>See the notes about comparison, serialization and immutability in
  * the {@link javax.el.Expression} javadocs.
  *
  * @see javax.el.ELResolver
  * @see javax.el.Expression
  * @see javax.el.ExpressionFactory
  * @see javax.el.ValueExpression
- * 
+ *
  * @author Jacob Hookom [jacob@hookom.net]
  * @version $Id$
  */
@@ -105,7 +105,7 @@ public final class ValueExpressionImpl extends ValueExpression implements
     }
 
     /**
-     * 
+     *
      */
     public ValueExpressionImpl(String expr, Node node, FunctionMapper fnMapper,
             VariableMapper varMapper, Class<?> expectedType) {
@@ -118,7 +118,7 @@ public final class ValueExpressionImpl extends ValueExpression implements
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see java.lang.Object#equals(java.lang.Object)
      */
     @Override
@@ -129,7 +129,7 @@ public final class ValueExpressionImpl extends ValueExpression implements
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see javax.el.ValueExpression#getExpectedType()
      */
     @Override
@@ -140,11 +140,11 @@ public final class ValueExpressionImpl extends ValueExpression implements
     /**
      * Returns the type the result of the expression will be coerced to after
      * evaluation.
-     * 
+     *
      * @return the <code>expectedType</code> passed to the
      *         <code>ExpressionFactory.createValueExpression</code> method
      *         that created this <code>ValueExpression</code>.
-     * 
+     *
      * @see javax.el.Expression#getExpressionString()
      */
     @Override
@@ -165,7 +165,7 @@ public final class ValueExpressionImpl extends ValueExpression implements
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see javax.el.ValueExpression#getType(javax.el.ELContext)
      */
     @Override
@@ -178,7 +178,7 @@ public final class ValueExpressionImpl extends ValueExpression implements
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see javax.el.ValueExpression#getValue(javax.el.ELContext)
      */
     @Override
@@ -195,7 +195,7 @@ public final class ValueExpressionImpl extends ValueExpression implements
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see java.lang.Object#hashCode()
      */
     @Override
@@ -205,7 +205,7 @@ public final class ValueExpressionImpl extends ValueExpression implements
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see javax.el.ValueExpression#isLiteralText()
      */
     @Override
@@ -219,7 +219,7 @@ public final class ValueExpressionImpl extends ValueExpression implements
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see javax.el.ValueExpression#isReadOnly(javax.el.ELContext)
      */
     @Override
@@ -244,7 +244,7 @@ public final class ValueExpressionImpl extends ValueExpression implements
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see javax.el.ValueExpression#setValue(javax.el.ELContext,
      *      java.lang.Object)
      */
@@ -280,5 +280,5 @@ public final class ValueExpressionImpl extends ValueExpression implements
                 this.varMapper);
         return this.getNode().getValueReference(ctx);
     }
-    
+
 }

==================================================
ELSupport.java
index 38d0b8ddfa..e3dbe98af9 100644
--- a/java/org/apache/el/ValueExpressionLiteral.java
+++ b/java/org/apache/el/ValueExpressionLiteral.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
EvaluationContext.java
index 54a2e85765..3203cb341a 100644
--- a/java/org/apache/el/lang/ELSupport.java
+++ b/java/org/apache/el/lang/ELSupport.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -29,7 +29,7 @@ import org.apache.el.util.MessageFactory;
 
 /**
  * A helper class that implements the EL Specification
- * 
+ *
  * @author Jacob Hookom [jacob@hookom.net]
  * @version $Id$
  */
@@ -39,27 +39,27 @@ public class ELSupport {
 
     /**
      * Compare two objects, after coercing to the same type if appropriate.
-     * 
-     * If the objects are identical, or they are equal according to 
+     *
+     * If the objects are identical, or they are equal according to
      * {@link #equals(Object, Object)} then return 0.
-     * 
+     *
      * If either object is a BigDecimal, then coerce both to BigDecimal first.
      * Similarly for Double(Float), BigInteger, and Long(Integer, Char, Short, Byte).
-     *  
+     *
      * Otherwise, check that the first object is an instance of Comparable, and compare
      * against the second object. If that is null, return 1, otherwise
      * return the result of comparing against the second object.
-     * 
+     *
      * Similarly, if the second object is Comparable, if the first is null, return -1,
      * else return the result of comparing against the first object.
-     * 
+     *
      * A null object is considered as:
      * <ul>
      * <li>ZERO when compared with Numbers</li>
      * <li>the empty string for String compares</li>
      * <li>Otherwise null is considered to be lower than anything else.</li>
      * </ul>
-     * 
+     *
      * @param obj0 first object
      * @param obj1 second object
      * @return -1, 0, or 1 if this object is less than, equal to, or greater than val.
@@ -109,13 +109,13 @@ public class ELSupport {
 
     /**
      * Compare two objects for equality, after coercing to the same type if appropriate.
-     * 
+     *
      * If the objects are identical (including both null) return true.
      * If either object is null, return false.
      * If either object is Boolean, coerce both to Boolean and check equality.
      * Similarly for Enum, String, BigDecimal, Double(Float), Long(Integer, Short, Byte, Character)
      * Otherwise default to using Object.equals().
-     * 
+     *
      * @param obj0 the first object
      * @param obj1 the second object
      * @return true if the objects are equal
@@ -173,7 +173,7 @@ public class ELSupport {
         if (type.isAssignableFrom(obj.getClass())) {
             return (Enum<?>) obj;
         }
-        
+
         if (!(obj instanceof String)) {
             throw new ELException(MessageFactory.get("error.convert",
                     obj, obj.getClass(), type));
@@ -473,7 +473,7 @@ public class ELSupport {
     }
 
     /**
-     * 
+     *
      */
     public ELSupport() {
         super();

==================================================
FunctionMapperFactory.java
index 412f049ca8..3e3841a243 100644
--- a/java/org/apache/el/lang/EvaluationContext.java
+++ b/java/org/apache/el/lang/EvaluationContext.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
FunctionMapperImpl.java
index 60557e229f..3e54d64eb3 100644
--- a/java/org/apache/el/lang/FunctionMapperFactory.java
+++ b/java/org/apache/el/lang/FunctionMapperFactory.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
VariableMapperFactory.java
index ab86449d1d..1b0e36228d 100644
--- a/java/org/apache/el/lang/FunctionMapperImpl.java
+++ b/java/org/apache/el/lang/FunctionMapperImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -43,7 +43,7 @@ public class FunctionMapperImpl extends FunctionMapper implements
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see javax.el.FunctionMapper#resolveFunction(java.lang.String,
      *      java.lang.String)
      */
@@ -68,7 +68,7 @@ public class FunctionMapperImpl extends FunctionMapper implements
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see java.io.Externalizable#writeExternal(java.io.ObjectOutput)
      */
     @Override
@@ -78,7 +78,7 @@ public class FunctionMapperImpl extends FunctionMapper implements
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see java.io.Externalizable#readExternal(java.io.ObjectInput)
      */
     @SuppressWarnings("unchecked")
@@ -98,7 +98,7 @@ public class FunctionMapperImpl extends FunctionMapper implements
         protected String localName;
 
         /**
-         * 
+         *
          */
         public Function(String prefix, String localName, Method m) {
             if (localName == null) {
@@ -118,7 +118,7 @@ public class FunctionMapperImpl extends FunctionMapper implements
 
         /*
          * (non-Javadoc)
-         * 
+         *
          * @see java.io.Externalizable#writeExternal(java.io.ObjectOutput)
          */
         @Override
@@ -141,7 +141,7 @@ public class FunctionMapperImpl extends FunctionMapper implements
 
         /*
          * (non-Javadoc)
-         * 
+         *
          * @see java.io.Externalizable#readExternal(java.io.ObjectInput)
          */
         @Override

==================================================
VariableMapperImpl.java
index 6a937ea081..4f6f4dc7b4 100644
--- a/java/org/apache/el/lang/VariableMapperFactory.java
+++ b/java/org/apache/el/lang/VariableMapperFactory.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
ArithmeticNode.java
index 6ebb362c63..629a90f386 100644
--- a/java/org/apache/el/lang/VariableMapperImpl.java
+++ b/java/org/apache/el/lang/VariableMapperImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
AstDotSuffix.java
index e77a7d1b85..6ad32f5c15 100644
--- a/java/org/apache/el/parser/ArithmeticNode.java
+++ b/java/org/apache/el/parser/ArithmeticNode.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
AstFunction.java
index 0b0307b79f..c7d8140b47 100644
--- a/java/org/apache/el/parser/AstDotSuffix.java
+++ b/java/org/apache/el/parser/AstDotSuffix.java
@@ -39,7 +39,7 @@ public final class AstDotSuffix extends SimpleNode {
             throws ELException {
         return this.image;
     }
-    
+
     @Override
     public void setImage(String image) {
         if (!Validation.isIdentifier(image)) {

==================================================
AstIdentifier.java
index e9a982eb50..c06a1bdc02 100644
--- a/java/org/apache/el/parser/AstFunction.java
+++ b/java/org/apache/el/parser/AstFunction.java
@@ -61,9 +61,9 @@ public final class AstFunction extends SimpleNode {
     @Override
     public Class<?> getType(EvaluationContext ctx)
             throws ELException {
-        
+
         FunctionMapper fnMapper = ctx.getFunctionMapper();
-        
+
         // quickly validate again for this request
         if (fnMapper == null) {
             throw new ELException(MessageFactory.get("error.fnMapper.null"));
@@ -79,9 +79,9 @@ public final class AstFunction extends SimpleNode {
     @Override
     public Object getValue(EvaluationContext ctx)
             throws ELException {
-        
+
         FunctionMapper fnMapper = ctx.getFunctionMapper();
-        
+
         // quickly validate again for this request
         if (fnMapper == null) {
             throw new ELException(MessageFactory.get("error.fnMapper.null"));
@@ -127,8 +127,8 @@ public final class AstFunction extends SimpleNode {
     public void setPrefix(String prefix) {
         this.prefix = prefix;
     }
-    
-    
+
+
     @Override
     public String toString()
     {

==================================================
AstMethodParameters.java
index d51e94dee5..f689ee50b7 100644
--- a/java/org/apache/el/parser/AstIdentifier.java
+++ b/java/org/apache/el/parser/AstIdentifier.java
@@ -118,7 +118,7 @@ public final class AstIdentifier extends SimpleNode {
             Object[] paramValues) throws ELException {
         return this.getMethodExpression(ctx).invoke(ctx.getELContext(), paramValues);
     }
-    
+
 
     @Override
     public MethodInfo getMethodInfo(EvaluationContext ctx,

==================================================
AstValue.java
index 9ad6d6eebc..0e2f82a29a 100644
--- a/java/org/apache/el/parser/AstMethodParameters.java
+++ b/java/org/apache/el/parser/AstMethodParameters.java
@@ -37,7 +37,7 @@ public final class AstMethodParameters extends SimpleNode {
         }
         return params.toArray(new Object[params.size()]);
     }
-    
+
     public Class<?>[] getParameterTypes(EvaluationContext ctx) {
         ArrayList<Class<?>> paramTypes = new ArrayList<Class<?>>();
         for (int i = 0; i < this.jjtGetNumChildren(); i++) {

==================================================
BooleanNode.java
index 92dab46345..283c3d5432 100644
--- a/java/org/apache/el/parser/AstValue.java
+++ b/java/org/apache/el/parser/AstValue.java
@@ -46,7 +46,7 @@ public final class AstValue extends SimpleNode {
         (System.getSecurityManager() != null);
 
     protected static final boolean COERCE_TO_ZERO;
-    
+
     static {
         if (IS_SECURITY_ENABLED) {
             COERCE_TO_ZERO = AccessController.doPrivileged(
@@ -84,7 +84,7 @@ public final class AstValue extends SimpleNode {
         Class<?> result = ctx.getELResolver().getType(ctx, t.base, t.property);
         if (!ctx.isPropertyResolved()) {
             throw new PropertyNotFoundException(MessageFactory.get(
-                    "error.resolver.unhandled", t.base, t.property));            
+                    "error.resolver.unhandled", t.base, t.property));
         }
         return result;
     }
@@ -102,10 +102,10 @@ public final class AstValue extends SimpleNode {
         // set up our start/end
         Object property = null;
         int propCount = this.jjtGetNumChildren();
-        
+
         if (propCount > 2 &&
                 this.jjtGetChild(propCount - 1) instanceof AstMethodParameters) {
-            // Method call with paramaters. 
+            // Method call with paramaters.
             propCount-=2;
         } else {
             propCount--;
@@ -164,7 +164,7 @@ public final class AstValue extends SimpleNode {
                 if (suffix == null) {
                     return null;
                 }
-                
+
                 ctx.setPropertyResolved(false);
                 base = resolver.getValue(ctx, base, suffix);
                 i++;
@@ -172,7 +172,7 @@ public final class AstValue extends SimpleNode {
         }
         if (!ctx.isPropertyResolved()) {
             throw new PropertyNotFoundException(MessageFactory.get(
-                    "error.resolver.unhandled", base, suffix));            
+                    "error.resolver.unhandled", base, suffix));
         }
         return base;
     }
@@ -185,7 +185,7 @@ public final class AstValue extends SimpleNode {
             ctx.getELResolver().isReadOnly(ctx, t.base, t.property);
         if (!ctx.isPropertyResolved()) {
             throw new PropertyNotFoundException(MessageFactory.get(
-                    "error.resolver.unhandled", t.base, t.property));            
+                    "error.resolver.unhandled", t.base, t.property));
         }
         return result;
     }
@@ -208,7 +208,7 @@ public final class AstValue extends SimpleNode {
         }
         if (!ctx.isPropertyResolved()) {
             throw new PropertyNotFoundException(MessageFactory.get(
-                    "error.resolver.unhandled", t.base, t.property));            
+                    "error.resolver.unhandled", t.base, t.property));
         }
     }
 
@@ -226,7 +226,7 @@ public final class AstValue extends SimpleNode {
 
     @Override
     // Interface el.parser.Node uses raw types (and is auto-generated)
-    public MethodInfo getMethodInfo(EvaluationContext ctx, 
+    public MethodInfo getMethodInfo(EvaluationContext ctx,
             @SuppressWarnings("rawtypes") Class[] paramTypes)
             throws ELException {
         Target t = getTarget(ctx);
@@ -237,10 +237,10 @@ public final class AstValue extends SimpleNode {
 
     @Override
     // Interface el.parser.Node uses a raw type (and is auto-generated)
-    public Object invoke(EvaluationContext ctx, 
+    public Object invoke(EvaluationContext ctx,
             @SuppressWarnings("rawtypes") Class[] paramTypes,
             Object[] paramValues) throws ELException {
-        
+
         Target t = getTarget(ctx);
         Method m = null;
         Object[] values = null;
@@ -272,7 +272,7 @@ public final class AstValue extends SimpleNode {
 
     private Object[] toVarArgs(Object[] src, Method m) {
         int paramCount = m.getParameterTypes().length;
-        
+
         Object[] dest = new Object[paramCount];
         Object[] varArgs = (Object[]) Array.newInstance(
                 m.getParameterTypes()[paramCount - 1].getComponentType(),
@@ -283,12 +283,12 @@ public final class AstValue extends SimpleNode {
         dest[paramCount - 1] = varArgs;
         return dest;
     }
-    
+
     private Class<?>[] getTypesFromValues(Object[] values) {
         if (values == null) {
             return null;
         }
-        
+
         Class<?> result[] = new Class<?>[values.length];
         for (int i = 0; i < values.length; i++) {
             if (values[i] == null) {
@@ -300,7 +300,7 @@ public final class AstValue extends SimpleNode {
         return result;
     }
 
-    
+
     /**
      * @since EL 2.2
      */
@@ -316,7 +316,7 @@ public final class AstValue extends SimpleNode {
         return new ValueReference(t.base, t.property);
     }
 
-    
+
     /**
      * @since EL 2.2
      */

==================================================
ELParserTokenManager.java
index e67be13169..793323335c 100644
--- a/java/org/apache/el/parser/BooleanNode.java
+++ b/java/org/apache/el/parser/BooleanNode.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
Node.java
index e277cf8904..8e9ded967b 100644
--- a/java/org/apache/el/parser/ELParserTokenManager.java
+++ b/java/org/apache/el/parser/ELParserTokenManager.java
@@ -1035,9 +1035,9 @@ private int jjMoveNfa_1(int startState, int curPos)
    }
 }
 static final int[] jjnextStates = {
-   0, 1, 3, 4, 2, 0, 1, 4, 2, 0, 1, 4, 5, 2, 0, 1, 
-   2, 6, 16, 17, 18, 23, 24, 11, 12, 14, 6, 7, 9, 3, 4, 21, 
-   22, 25, 26, 
+   0, 1, 3, 4, 2, 0, 1, 4, 2, 0, 1, 4, 5, 2, 0, 1,
+   2, 6, 16, 17, 18, 23, 24, 11, 12, 14, 6, 7, 9, 3, 4, 21,
+   22, 25, 26,
 };
 private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
 {
@@ -1074,12 +1074,12 @@ private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, lo
 
 /** Token literal values. */
 public static final String[] jjstrLiteralImages = {
-"", null, "\44\173", "\43\173", null, null, null, null, null, null, null, null, 
-"\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\175", "\56", "\50", "\51", 
-"\133", "\135", "\72", "\54", "\76", "\147\164", "\74", "\154\164", "\76\75", 
-"\147\145", "\74\75", "\154\145", "\75\75", "\145\161", "\41\75", "\156\145", "\41", 
-"\156\157\164", "\46\46", "\141\156\144", "\174\174", "\157\162", "\145\155\160\164\171", 
-"\151\156\163\164\141\156\143\145\157\146", "\52", "\53", "\55", "\77", "\57", "\144\151\166", "\45", "\155\157\144", null, 
+"", null, "\44\173", "\43\173", null, null, null, null, null, null, null, null,
+"\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\175", "\56", "\50", "\51",
+"\133", "\135", "\72", "\54", "\76", "\147\164", "\74", "\154\164", "\76\75",
+"\147\145", "\74\75", "\154\145", "\75\75", "\145\161", "\41\75", "\156\145", "\41",
+"\156\157\164", "\46\46", "\141\156\144", "\174\174", "\157\162", "\145\155\160\164\171",
+"\151\156\163\164\141\156\143\145\157\146", "\52", "\53", "\55", "\77", "\57", "\144\151\166", "\45", "\155\157\144", null,
 null, null, null, null, null, };
 
 /** Lexer state names. */
@@ -1090,15 +1090,15 @@ public static final String[] lexStateNames = {
 
 /** Lex State array. */
 public static final int[] jjnewLexState = {
-   -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-   -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+   -1, -1, -1, -1, -1, -1, -1,
 };
 static final long[] jjtoToken = {
-   0x11ffffffffffb0fL, 
+   0x11ffffffffffb0fL,
 };
 static final long[] jjtoSkip = {
-   0xf0L, 
+   0xf0L,
 };
 protected SimpleCharStream input_stream;
 private final int[] jjrounds = new int[30];
@@ -1181,7 +1181,7 @@ int jjmatchedPos;
 int jjmatchedKind;
 
 /** Get the next Token. */
-public Token getNextToken() 
+public Token getNextToken()
 {
   Token matchedToken;
   int curPos = 0;

==================================================
NodeVisitor.java
index f495fc87ba..91e48f5d34 100644
--- a/java/org/apache/el/parser/Node.java
+++ b/java/org/apache/el/parser/Node.java
@@ -7,9 +7,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -59,9 +59,9 @@ public interface Node {
 
   /** Return the number of children the node has. */
   public int jjtGetNumChildren();
-  
+
   public String getImage();
-  
+
   public Object getValue(EvaluationContext ctx) throws ELException;
   public void setValue(EvaluationContext ctx, Object value) throws ELException;
   public Class<?> getType(EvaluationContext ctx) throws ELException;
@@ -71,12 +71,12 @@ public interface Node {
           throws ELException;
   public Object invoke(EvaluationContext ctx, Class<?>[] paramTypes,
           Object[] paramValues) throws ELException;
-  
+
   /**
    * @since EL 2.2
    */
   public ValueReference getValueReference(EvaluationContext ctx);
-  
+
   /**
    * @since EL 2.2
    */

==================================================
SimpleNode.java
index 0be7a963f5..58fdf9b09f 100644
--- a/java/org/apache/el/parser/NodeVisitor.java
+++ b/java/org/apache/el/parser/NodeVisitor.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
MessageFactory.java
index 8e5f237053..57448af0e1 100644
--- a/java/org/apache/el/parser/SimpleNode.java
+++ b/java/org/apache/el/parser/SimpleNode.java
@@ -163,8 +163,8 @@ public abstract class SimpleNode extends ELSupport implements Node {
             Class<?>[] paramTypes) throws ELException {
         throw new UnsupportedOperationException();
     }
-    
-    
+
+
     @Override
     public int hashCode() {
         final int prime = 31;
@@ -207,7 +207,7 @@ public abstract class SimpleNode extends ELSupport implements Node {
     public ValueReference getValueReference(EvaluationContext ctx) {
         return null;
     }
-    
+
     /**
      * @since EL 2.2
      */

==================================================
ReflectionUtil.java
index cecafc9c6b..7df9cad0b7 100644
--- a/java/org/apache/el/util/MessageFactory.java
+++ b/java/org/apache/el/util/MessageFactory.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
Validation.java
index 44a037c05c..577397be05 100644
--- a/java/org/apache/el/util/ReflectionUtil.java
+++ b/java/org/apache/el/util/ReflectionUtil.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -28,7 +28,7 @@ import javax.el.MethodNotFoundException;
 
 /**
  * Utilities for Managing Serialization and Reflection
- * 
+ *
  * @author Jacob Hookom [jacob@hookom.net]
  * @version $Id$
  */
@@ -120,7 +120,7 @@ public class ReflectionUtil {
 
         String methodName = (property instanceof String) ? (String) property
                 : property.toString();
-        
+
         int paramCount;
         if (paramTypes == null) {
             paramCount = 0;
@@ -130,13 +130,13 @@ public class ReflectionUtil {
 
         Method[] methods = base.getClass().getMethods();
         Map<Method,Integer> candidates = new HashMap<Method,Integer>();
-        
+
         for (Method m : methods) {
             if (!m.getName().equals(methodName)) {
                 // Method name doesn't match
                 continue;
             }
-            
+
             Class<?>[] mParamTypes = m.getParameterTypes();
             int mParamCount;
             if (mParamTypes == null) {
@@ -144,14 +144,14 @@ public class ReflectionUtil {
             } else {
                 mParamCount = mParamTypes.length;
             }
-            
+
             // Check the number of parameters
             if (!(paramCount == mParamCount ||
                     (m.isVarArgs() && paramCount >= mParamCount))) {
                 // Method has wrong number of parameters
                 continue;
             }
-            
+
             // Check the parameters match
             int exactMatch = 0;
             boolean noMatch = false;
@@ -177,13 +177,13 @@ public class ReflectionUtil {
             if (noMatch) {
                 continue;
             }
-            
+
             // If a method is found where every parameter matches exactly,
             // return it
             if (exactMatch == paramCount) {
                 return m;
             }
-            
+
             candidates.put(m, Integer.valueOf(exactMatch));
         }
 
@@ -210,7 +210,7 @@ public class ReflectionUtil {
             } else {
                 match = null;
             }
-            
+
             if (match == null) {
                 // If multiple methods have the same matching number of parameters
                 // the match is ambiguous so throw an exception
@@ -219,14 +219,14 @@ public class ReflectionUtil {
                         paramString(paramTypes)));
                 }
         }
-        
+
         // Handle case where no match at all was found
         if (match == null) {
             throw new MethodNotFoundException(MessageFactory.get(
                         "error.method.notfound", base, property,
                         paramString(paramTypes)));
         }
-        
+
         return match;
     }
 
@@ -235,10 +235,10 @@ public class ReflectionUtil {
             Class<?>[] paramTypes) {
         // Identify which parameter isn't an exact match
         Method m = candidates.iterator().next();
-        
+
         int nonMatchIndex = 0;
         Class<?> nonMatchClass = null;
-        
+
         for (int i = 0; i < paramTypes.length; i++) {
             if (m.getParameterTypes()[i] != paramTypes[i]) {
                 nonMatchIndex = i;
@@ -246,7 +246,7 @@ public class ReflectionUtil {
                 break;
             }
         }
-        
+
         for (Method c : candidates) {
            if (c.getParameterTypes()[nonMatchIndex] ==
                    paramTypes[nonMatchIndex]) {
@@ -255,7 +255,7 @@ public class ReflectionUtil {
                return null;
            }
         }
-        
+
         // Can't be null
         nonMatchClass = nonMatchClass.getSuperclass();
         while (nonMatchClass != null) {
@@ -268,7 +268,7 @@ public class ReflectionUtil {
             }
             nonMatchClass = nonMatchClass.getSuperclass();
         }
-        
+
         return null;
     }
 

==================================================
