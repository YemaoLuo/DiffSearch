b323d5c3db51e6cc5223bce10fdfb2ff15bc5578
==================================================
Add blocking mode tweak, as I accidentally found out blocking does make a difference.
==================================================
Remy Maucherat
==================================================
Thu Mar 9 12:26:34 2017 +0000
==================================================
Nio2Endpoint.java
Add blocking mode tweak, as I accidentally found out blocking does make a difference.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1786153 13f79535-47bb-0310-9956-ffa450edef68



==================================================
SocketWrapperBase.java
index 5b4a2b7e9c..18770ed9c2 100644
--- a/java/org/apache/tomcat/util/net/Nio2Endpoint.java
+++ b/java/org/apache/tomcat/util/net/Nio2Endpoint.java
@@ -971,9 +971,9 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel,AsynchronousS
 
         @Override
         public <A> CompletionState read(ByteBuffer[] dsts, int offset, int length,
-                boolean block, long timeout, TimeUnit unit, A attachment,
+                BlockingMode block, long timeout, TimeUnit unit, A attachment,
                 CompletionCheck check, CompletionHandler<Long, ? super A> handler) {
-            if (block) {
+            if (block != BlockingMode.NON_BLOCK) {
                 try {
                     if (!readPending.tryAcquire(timeout, unit)) {
                         handler.failed(new SocketTimeoutException(), attachment);
@@ -992,7 +992,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel,AsynchronousS
             Nio2Endpoint.startInline();
             getSocket().read(dsts, offset, length, timeout, unit, state, new ScatterReadCompletionHandler<>());
             Nio2Endpoint.endInline();
-            if (block && state.state == CompletionState.PENDING) {
+            if (block == BlockingMode.BLOCK && state.state == CompletionState.PENDING) {
                 if (!awaitReadComplete(timeout, unit)) {
                     handler.failed(new SocketTimeoutException(), attachment);
                     return CompletionState.ERROR;
@@ -1010,9 +1010,9 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel,AsynchronousS
 
         @Override
         public  <A> CompletionState write(ByteBuffer[] srcs, int offset, int length,
-                boolean block, long timeout, TimeUnit unit, A attachment,
+                BlockingMode block, long timeout, TimeUnit unit, A attachment,
                 CompletionCheck check, CompletionHandler<Long, ? super A> handler) {
-            if (block) {
+            if (block != BlockingMode.NON_BLOCK) {
                 try {
                     if (!writePending.tryAcquire(timeout, unit)) {
                         handler.failed(new SocketTimeoutException(), attachment);
@@ -1031,7 +1031,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel,AsynchronousS
             Nio2Endpoint.startInline();
             getSocket().write(srcs, offset, length, timeout, unit, state, new GatherWriteCompletionHandler<>());
             Nio2Endpoint.endInline();
-            if (block && state.state == CompletionState.PENDING) {
+            if (block == BlockingMode.BLOCK && state.state == CompletionState.PENDING) {
                 if (!awaitWriteComplete(timeout, unit)) {
                     handler.failed(new SocketTimeoutException(), attachment);
                     return CompletionState.ERROR;

==================================================
