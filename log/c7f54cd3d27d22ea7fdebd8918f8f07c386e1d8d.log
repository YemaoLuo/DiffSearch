c7f54cd3d27d22ea7fdebd8918f8f07c386e1d8d
==================================================
Fix https://bz.apache.org/bugzilla/show_bug.cgi?id=57570
==================================================
Mark Thomas
==================================================
Fri Mar 13 10:02:34 2015 +0000
==================================================
AbstractHttp11Protocol.java
Fix https://bz.apache.org/bugzilla/show_bug.cgi?id=57570
Make processing of trailer headers for chunked input optional.
Trailer headers to process must be added to the allowedTrailerHeader list or they will be ignored

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1666386 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http11Processor.java
index dbfdb92c5e..506ecd0f9c 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
@@ -18,6 +18,13 @@ package org.apache.coyote.http11;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 import javax.servlet.http.HttpUpgradeHandler;
 
@@ -196,6 +203,59 @@ public abstract class AbstractHttp11Protocol<S> extends AbstractProtocol<S> {
     }
 
 
+    /**
+     * The names of headers that are allowed to be sent via a trailer when using
+     * chunked encoding. They are stored in lower case.
+     */
+    private Set<String> allowedTrailerHeaders =
+            Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());
+    public void setAllowedTrailerHeaders(String commaSeparatedHeaders) {
+        // Jump through some hoops so we don't end up with an empty set while
+        // doing updates.
+        Set<String> toRemove = new HashSet<>();
+        toRemove.addAll(allowedTrailerHeaders);
+        if (commaSeparatedHeaders != null) {
+            String[] headers = commaSeparatedHeaders.split(",");
+            for (String header : headers) {
+                String trimmedHeader = header.trim().toLowerCase(Locale.ENGLISH);
+                if (toRemove.contains(trimmedHeader)) {
+                    toRemove.remove(trimmedHeader);
+                } else {
+                    allowedTrailerHeaders.add(trimmedHeader);
+                }
+            }
+            allowedTrailerHeaders.removeAll(toRemove);
+        }
+    }
+    public String getAllowedTrailerHeaders() {
+        // Chances of a size change between these lines are small enough that a
+        // sync is unnecessary.
+        List<String> copy = new ArrayList<>(allowedTrailerHeaders.size());
+        copy.addAll(allowedTrailerHeaders);
+        StringBuilder result = new StringBuilder();
+        boolean first = true;
+        for (String header : copy) {
+            if (first) {
+                first = false;
+            } else {
+                result.append(',');
+            }
+            result.append(header);
+        }
+        return result.toString();
+    }
+    public void addAllowedTrailerHeader(String header) {
+        if (header != null) {
+            allowedTrailerHeaders.add(header.trim().toLowerCase(Locale.ENGLISH));
+        }
+    }
+    public void removeAllowedTrailerHeader(String header) {
+        if (header != null) {
+            allowedTrailerHeaders.remove(header.trim().toLowerCase(Locale.ENGLISH));
+        }
+    }
+
+
     // ------------------------------------------------ HTTP specific properties
     // ------------------------------------------ passed through to the EndPoint
 
@@ -271,8 +331,8 @@ public abstract class AbstractHttp11Protocol<S> extends AbstractProtocol<S> {
         @Override
         public Http11Processor createProcessor() {
             Http11Processor processor = new Http11Processor(
-                    proto.getMaxHttpHeaderSize(), proto.getEndpoint(),
-                    proto.getMaxTrailerSize(), proto.getMaxExtensionSize(),
+                    proto.getMaxHttpHeaderSize(), proto.getEndpoint(), proto.getMaxTrailerSize(),
+                    proto.allowedTrailerHeaders, proto.getMaxExtensionSize(),
                     proto.getMaxSwallowSize());
             proto.configureProcessor(processor);
             register(processor);

==================================================
BufferedInputFilter.java
index b561ff1a59..2ff25045d4 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -20,6 +20,7 @@ import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.nio.ByteBuffer;
 import java.util.Locale;
+import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.regex.Pattern;
@@ -238,8 +239,8 @@ public class Http11Processor extends AbstractProcessor {
     protected SSLSupport sslSupport;
 
 
-    public Http11Processor(int maxHttpHeaderSize, AbstractEndpoint<?> endpoint,
-            int maxTrailerSize, int maxExtensionSize, int maxSwallowSize) {
+    public Http11Processor(int maxHttpHeaderSize, AbstractEndpoint<?> endpoint,int maxTrailerSize,
+            Set<String> allowedTrailerHeaders, int maxExtensionSize, int maxSwallowSize) {
 
         super(endpoint);
         userDataHelper = new UserDataHelper(log);
@@ -255,8 +256,8 @@ public class Http11Processor extends AbstractProcessor {
         outputBuffer.addFilter(new IdentityOutputFilter());
 
         // Create and add the chunked filters.
-        inputBuffer.addFilter(
-                new ChunkedInputFilter(maxTrailerSize, maxExtensionSize, maxSwallowSize));
+        inputBuffer.addFilter(new ChunkedInputFilter(maxTrailerSize, allowedTrailerHeaders,
+                maxExtensionSize, maxSwallowSize));
         outputBuffer.addFilter(new ChunkedOutputFilter());
 
         // Create and add the void filters.

==================================================
ChunkedInputFilter.java
index ea2375e641..ebdfb9230d 100644
--- a/java/org/apache/coyote/http11/filters/BufferedInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/BufferedInputFilter.java
@@ -59,6 +59,8 @@ public class BufferedInputFilter implements InputFilter {
     /**
      * Set the buffering limit. This should be reset every time the buffer is
      * used.
+     *
+     * @param limit The maximum number of bytes that will be buffered
      */
     public void setLimit(int limit) {
         if (buffered == null) {

==================================================
TestChunkedInputFilter.java
index dfc06d02e4..0b2b799090 100644
--- a/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
@@ -19,6 +19,8 @@ package org.apache.coyote.http11.filters;
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
+import java.util.Locale;
+import java.util.Set;
 
 import org.apache.coyote.InputBuffer;
 import org.apache.coyote.Request;
@@ -146,10 +148,14 @@ public class ChunkedInputFilter implements InputFilter {
     private boolean error;
 
 
+    private final Set<String> allowedTrailerHeaders;
+
     // ----------------------------------------------------------- Constructors
 
-    public ChunkedInputFilter(int maxTrailerSize, int maxExtensionSize, int maxSwallowSize) {
+    public ChunkedInputFilter(int maxTrailerSize, Set<String> allowedTrailerHeaders,
+            int maxExtensionSize, int maxSwallowSize) {
         this.trailingHeaders.setLimit(maxTrailerSize);
+        this.allowedTrailerHeaders = allowedTrailerHeaders;
         this.maxExtensionSize = maxExtensionSize;
         this.maxTrailerSize = maxTrailerSize;
         this.maxSwallowSize = maxSwallowSize;
@@ -469,7 +475,7 @@ public class ChunkedInputFilter implements InputFilter {
         }
 
         // Mark the current buffer position
-        int start = trailingHeaders.getEnd();
+        int startPos = trailingHeaders.getEnd();
 
         //
         // Reading the header name
@@ -500,11 +506,7 @@ public class ChunkedInputFilter implements InputFilter {
             pos++;
 
         }
-        MessageBytes headerValue = headers.addValue(trailingHeaders.getBytes(),
-                start, trailingHeaders.getEnd() - start);
-
-        // Mark the current buffer position
-        start = trailingHeaders.getEnd();
+        int colonPos = trailingHeaders.getEnd();
 
         //
         // Reading the header value (which can be spanned over multiple lines)
@@ -592,9 +594,16 @@ public class ChunkedInputFilter implements InputFilter {
 
         }
 
-        // Set the header value
-        headerValue.setBytes(trailingHeaders.getBytes(), start,
-                lastSignificantChar - start);
+        String headerName = new String(trailingHeaders.getBytes(), startPos,
+                colonPos - startPos, StandardCharsets.ISO_8859_1);
+
+        if (allowedTrailerHeaders.contains(headerName.trim().toLowerCase(Locale.ENGLISH))) {
+            MessageBytes headerValue = headers.addValue(headerName);
+
+            // Set the header value
+            headerValue.setBytes(trailingHeaders.getBytes(), colonPos,
+                    lastSignificantChar - colonPos);
+        }
 
         return true;
     }

==================================================
