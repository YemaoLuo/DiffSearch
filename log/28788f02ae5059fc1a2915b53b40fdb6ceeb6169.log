28788f02ae5059fc1a2915b53b40fdb6ceeb6169
==================================================
fix typo (an ssl)
==================================================
KangZhiDong worldkzd@gmail.com
==================================================
Wed Sep 4 22:48:23 2019 +0800
==================================================
CertificateCreateRule.java
index 723540a745..41393778a6 100644
--- a/java/org/apache/catalina/realm/LocalStrings.properties
+++ b/java/org/apache/catalina/realm/LocalStrings.properties
@@ -75,7 +75,7 @@ jndiRealm.exception=Exception performing authentication
 jndiRealm.exception.retry=Exception performing authentication. Retrying...
 jndiRealm.invalidHostnameVerifier=[{0}] not a valid class name for a HostnameVerifier
 jndiRealm.invalidSslProtocol=Given protocol [{0}] is invalid. It has to be one of [{1}]
-jndiRealm.invalidSslSocketFactory=[{0}] not a valid class name for a SSLSocketFactory
+jndiRealm.invalidSslSocketFactory=[{0}] not a valid class name for an SSLSocketFactory
 jndiRealm.negotiatedTls=Negotiated tls connection using protocol [{0}]
 jndiRealm.open=Exception opening directory server connection
 jndiRealm.tlsClose=Exception closing tls response

==================================================
SSL.java
index 6e49e19395..1db3c701a4 100644
--- a/java/org/apache/catalina/startup/CertificateCreateRule.java
+++ b/java/org/apache/catalina/startup/CertificateCreateRule.java
@@ -23,7 +23,7 @@ import org.apache.tomcat.util.net.SSLHostConfigCertificate.Type;
 import org.xml.sax.Attributes;
 
 /**
- * Rule implementation that creates a SSLHostConfigCertificate.
+ * Rule implementation that creates an SSLHostConfigCertificate.
  */
 public class CertificateCreateRule extends Rule {
 

==================================================
SSLConf.java
index 6c3f2b435e..06b6090111 100644
--- a/java/org/apache/tomcat/jni/SSL.java
+++ b/java/org/apache/tomcat/jni/SSL.java
@@ -140,7 +140,7 @@ public final class SSL {
     /* Set on servers to choose the cipher according to the server's
      * preferences */
     public static final int SSL_OP_CIPHER_SERVER_PREFERENCE         = 0x00400000;
-    /* If set, a server will allow a client to issue a SSLv3.0 version number
+    /* If set, a server will allow a client to issue an SSLv3.0 version number
      * as latest version supported in the premaster secret, even when TLSv1.0
      * (version 3.1) was announced in the client hello. Normally this is
      * forbidden to prevent version rollback attacks. */
@@ -647,7 +647,7 @@ public final class SSL {
      * Authentication. Notice that this directive can be used both in per-server
      * and per-directory context. In per-server context it applies to the client
      * authentication process used in the standard SSL handshake when a connection
-     * is established. In per-directory context it forces a SSL renegotiation with
+     * is established. In per-directory context it forces an SSL renegotiation with
      * the reconfigured client verification level after the HTTP request was read
      * but before the HTTP response is sent.
      * <br>
@@ -704,7 +704,7 @@ public final class SSL {
      * is permitted to negotiate in the SSL handshake phase. Notice that this
      * directive can be used both in per-server and per-directory context.
      * In per-server context it applies to the standard SSL handshake when a
-     * connection is established. In per-directory context it forces a SSL
+     * connection is established. In per-directory context it forces an SSL
      * renegotiation with the reconfigured Cipher Suite after the HTTP request
      * was read but before the HTTP response is sent.
      * @param ssl the SSL instance (SSL *)

==================================================
SSLContext.java
index 272c0a188a..ede4565dd7 100644
--- a/java/org/apache/tomcat/jni/SSLConf.java
+++ b/java/org/apache/tomcat/jni/SSLConf.java
@@ -73,7 +73,7 @@ public final class SSLConf {
     public static native int check(long cctx, String name, String value) throws Exception;
 
     /**
-     * Assign an SSL context to a SSL_CONF context.
+     * Assign an SSL context to an SSL_CONF context.
      * All following calls to {@link #apply(long, String, String)} will be
      * applied to this SSL context.
      *

==================================================
SSLSocket.java
index 45fcc482cd..e0759b3e67 100644
--- a/java/org/apache/tomcat/jni/SSLContext.java
+++ b/java/org/apache/tomcat/jni/SSLContext.java
@@ -126,7 +126,7 @@ public final class SSLContext {
      * <b>mode</b>. SSL objects created from <b>ctx</b> inherit the
      * <b>mode</b> valid at the time and may be 0 or 1.
      * <br>
-     * Normally when a SSL connection is finished, the parties must send out
+     * Normally when an SSL connection is finished, the parties must send out
      * "close notify" alert messages using L&lt;SSL_shutdown(3)|SSL_shutdown(3)&gt;
      * for a clean shutdown.
      * <br>
@@ -150,7 +150,7 @@ public final class SSLContext {
      * is permitted to negotiate in the SSL handshake phase. Notice that this
      * directive can be used both in per-server and per-directory context.
      * In per-server context it applies to the standard SSL handshake when a
-     * connection is established. In per-directory context it forces a SSL
+     * connection is established. In per-directory context it forces an SSL
      * renegotiation with the reconfigured Cipher Suite after the HTTP request
      * was read but before the HTTP response is sent.
      * @param ctx Server or Client context to use.
@@ -368,7 +368,7 @@ public final class SSLContext {
      * Authentication. Notice that this directive can be used both in per-server
      * and per-directory context. In per-server context it applies to the client
      * authentication process used in the standard SSL handshake when a connection
-     * is established. In per-directory context it forces a SSL renegotiation with
+     * is established. In per-directory context it forces an SSL renegotiation with
      * the reconfigured client verification level after the HTTP request was read
      * but before the HTTP response is sent.
      * <br>

==================================================
Nio2Channel.java
index c8108a0e1a..2cc42f7718 100644
--- a/java/org/apache/tomcat/jni/SSLSocket.java
+++ b/java/org/apache/tomcat/jni/SSLSocket.java
@@ -24,7 +24,7 @@ package org.apache.tomcat.jni;
 public class SSLSocket {
 
     /**
-     * Attach APR socket on a SSL connection.
+     * Attach APR socket on an SSL connection.
      * @param ctx SSLContext to use.
      * @param sock APR Socket that already did physical connect or accept.
      * @return APR_STATUS code.
@@ -34,14 +34,14 @@ public class SSLSocket {
         throws Exception;
 
     /**
-     * Do a SSL handshake.
+     * Do an SSL handshake.
      * @param thesocket The socket to use
      * @return the handshake status
      */
     public static native int handshake(long thesocket);
 
     /**
-     * Do a SSL renegotiation.
+     * Do an SSL renegotiation.
      * SSL supports per-directory re-configuration of SSL parameters.
      * This is implemented by performing an SSL renegotiation of the
      * re-configured parameters after the request is read, but before the

==================================================
NioChannel.java
index ff8c302d7c..90986a5080 100644
--- a/java/org/apache/tomcat/util/net/Nio2Channel.java
+++ b/java/org/apache/tomcat/util/net/Nio2Channel.java
@@ -29,7 +29,7 @@ import java.util.concurrent.TimeoutException;
 
 /**
  * Base class for a SocketChannel wrapper used by the endpoint.
- * This way, logic for a SSL socket channel remains the same as for
+ * This way, logic for an SSL socket channel remains the same as for
  * a non SSL, making sure we don't need to code for any exception cases.
  */
 public class Nio2Channel implements AsynchronousByteChannel {

==================================================
SecureNio2Channel.java
index e400cb0a53..9f39afb363 100644
--- a/java/org/apache/tomcat/util/net/NioChannel.java
+++ b/java/org/apache/tomcat/util/net/NioChannel.java
@@ -29,7 +29,7 @@ import org.apache.tomcat.util.res.StringManager;
 
 /**
  * Base class for a SocketChannel wrapper used by the endpoint.
- * This way, logic for a SSL socket channel remains the same as for
+ * This way, logic for an SSL socket channel remains the same as for
  * a non SSL, making sure we don't need to code for any exception cases.
  *
  * @version 1.0

==================================================
SecureNioChannel.java
index d446254baf..9e5ab07ea0 100644
--- a/java/org/apache/tomcat/util/net/SecureNio2Channel.java
+++ b/java/org/apache/tomcat/util/net/SecureNio2Channel.java
@@ -563,7 +563,7 @@ public class SecureNio2Channel extends Nio2Channel  {
     }
 
     /**
-     * Sends a SSL close message, will not physically close the connection here.<br>
+     * Sends an SSL close message, will not physically close the connection here.<br>
      * To close the connection, you could do something like
      * <pre><code>
      *   close();

==================================================
