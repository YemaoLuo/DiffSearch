23c3475f192023b63bbb37cac2223228ec436086
==================================================
Refactor
==================================================
Mark Emlyn
==================================================
Thu Feb 23 00:40:02 2012 +0000
==================================================
StreamInbound.java
Refactor

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1292598 13f79535-47bb-0310-9956-ffa450edef68



==================================================
WsFrame.java
index a3bfd5d115..cd034ba860 100644
--- a/java/org/apache/catalina/websocket/StreamInbound.java
+++ b/java/org/apache/catalina/websocket/StreamInbound.java
@@ -20,7 +20,6 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
-import java.nio.ByteBuffer;
 
 import org.apache.coyote.http11.upgrade.UpgradeInbound;
 import org.apache.coyote.http11.upgrade.UpgradeOutbound;
@@ -55,15 +54,15 @@ public abstract class StreamInbound implements UpgradeInbound {
         try {
             WsInputStream wsIs = new WsInputStream(processor);
 
-            WsFrameHeader header = wsIs.getFrameHeader();
+            WsFrame frame = wsIs.getFrame();
 
             // TODO User defined extensions may define values for rsv
-            if (header.getRsv() > 0) {
+            if (frame.getRsv() > 0) {
                 getOutbound().close(1002, null);
                 return SocketState.CLOSED;
             }
 
-            byte opCode = header.getOpCode();
+            byte opCode = frame.getOpCode();
 
             if (opCode == Constants.OPCODE_BINARY) {
                 onBinaryData(wsIs);
@@ -75,22 +74,14 @@ public abstract class StreamInbound implements UpgradeInbound {
                 return SocketState.UPGRADED;
             }
 
-            // Must be a control frame and control frames:
-            // - have a limited payload length
-            // - must not be fragmented
-            if (wsIs.getPayloadLength() > 125 || !wsIs.getFrameHeader().getFin()) {
-                getOutbound().close(1002, null);
-                return SocketState.CLOSED;
-            }
-
             if (opCode == Constants.OPCODE_CLOSE){
-                doClose(wsIs);
+                doClose(frame);
                 return SocketState.CLOSED;
             } else if (opCode == Constants.OPCODE_PING) {
-                doPing(wsIs);
+                doPing(frame);
                 return SocketState.UPGRADED;
             } else if (opCode == Constants.OPCODE_PONG) {
-                doPong(wsIs);
+                // NO-OP
                 return SocketState.UPGRADED;
             }
 
@@ -105,70 +96,23 @@ public abstract class StreamInbound implements UpgradeInbound {
         }
     }
 
-    private void doClose(WsInputStream is) throws IOException {
-        // Control messages have a max size of 125 bytes. Need to try and read
-        // one more so we reach end of stream (less 2 for the status). Note that
-        // the 125 byte limit is enforced in #onData() before this method is
-        // ever called.
-        ByteBuffer data = null;
-
-        int status = is.read();
-        if (status != -1) {
-            status = status << 8;
-            int i = is.read();
-            if (i == -1) {
-                // EOF during middle of close message. Closing anyway but set
-                // close code to protocol error
-                status = 1002;
-            } else {
-                status = status + i;
-                if (is.getPayloadLength() > 2) {
-                    data = ByteBuffer.allocate((int) is.getPayloadLength() - 1);
-                    int read = 0;
-                    while (read > -1) {
-                        data.position(data.position() + read);
-                        read = is.read(data.array(), data.position(),
-                                data.remaining());
-                    }
-                    data.flip();
-                }
+    private void doClose(WsFrame frame) throws IOException {
+        if (frame.getPayLoadLength() > 0) {
+            // Must be status (2 bytes) plus optional message
+            if (frame.getPayLoadLength() == 1) {
+                throw new IOException();
             }
+            int status = (frame.getPayLoad().get() & 0xFF) << 8;
+            status += frame.getPayLoad().get() & 0xFF;
+            getOutbound().close(status, frame.getPayLoad());
         } else {
-            status = 0;
+            // No status
+            getOutbound().close(0, null);
         }
-        getOutbound().close(status, data);
     }
 
-    private void doPing(WsInputStream is) throws IOException {
-        // Control messages have a max size of 125 bytes. Need to try and read
-        // one more so we reach end of stream. Note that the 125 byte limit is
-        // enforced in #onData() before this method is ever called.
-        ByteBuffer data = null;
-
-        if (is.getPayloadLength() > 0) {
-            data = ByteBuffer.allocate((int) is.getPayloadLength() + 1);
-
-            int read = 0;
-            while (read > -1) {
-                data.position(data.position() + read);
-                read = is.read(data.array(), data.position(), data.remaining());
-            }
-
-            data.flip();
-        }
-
-        getOutbound().pong(data);
-    }
-
-    private void doPong(WsInputStream is) throws IOException {
-        // Unsolicited pong - swallow it
-        // Control messages have a max size of 125 bytes. Note that the 125 byte
-        // limit is enforced in #onData() before this method is ever called so
-        // the loop below is not unbounded.
-        int read = 0;
-        while (read > -1) {
-            read = is.read();
-        }
+    private void doPing(WsFrame frame) throws IOException {
+        getOutbound().pong(frame.getPayLoad());
     }
 
     protected abstract void onBinaryData(InputStream is) throws IOException;

==================================================
WsFrameHeader.java
new file mode 100644
index 0000000000..efd04e984d
--- /dev/null
+++ b/java/org/apache/catalina/websocket/WsFrame.java
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.websocket;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+import org.apache.catalina.util.Conversions;
+import org.apache.coyote.http11.upgrade.UpgradeProcessor;
+
+/**
+ * Represents a WebSocket frame with the exception of the payload for
+ * non-control frames.
+ */
+public class WsFrame {
+
+    private final boolean fin;
+    private final int rsv;
+    private final byte opCode;
+    private int[] mask = new int[4];
+    private long payloadLength;
+    private ByteBuffer payload;
+
+    public WsFrame(UpgradeProcessor<?> processor) throws IOException {
+
+        int b = processorRead(processor);
+        fin = (b & 0x80) > 0;
+        rsv = (b & 0x70) >>> 4;
+        opCode = (byte) (b & 0x0F);
+
+        b = processorRead(processor);
+        // Client data must be masked
+        if ((b & 0x80) == 0) {
+            // TODO: StringManager / i18n
+            throw new IOException("Client frame not masked");
+        }
+
+        payloadLength = b & 0x7F;
+        if (payloadLength == 126) {
+            byte[] extended = new byte[2];
+            processorRead(processor, extended);
+            payloadLength = Conversions.byteArrayToLong(extended);
+        } else if (payloadLength == 127) {
+            byte[] extended = new byte[8];
+            processorRead(processor, extended);
+            payloadLength = Conversions.byteArrayToLong(extended);
+        }
+
+        boolean isControl = (opCode & 0x08) > 0;
+
+        if (isControl) {
+            if (payloadLength > 125) {
+                throw new IOException();
+            }
+            if (!fin) {
+                throw new IOException();
+            }
+        }
+
+        for (int j = 0; j < mask.length; j++) {
+            mask[j] = processorRead(processor) & 0xFF;
+        }
+
+        if (isControl) {
+            // Note: Payload limited to <= 125 bytes by test above
+            payload = ByteBuffer.allocate((int) payloadLength);
+            processorRead(processor, payload);
+        } else {
+            payload = null;
+        }
+    }
+
+    public boolean getFin() {
+        return fin;
+    }
+
+    public int getRsv() {
+        return rsv;
+    }
+
+    public byte getOpCode() {
+        return opCode;
+    }
+
+    public int[] getMask() {
+        return mask;
+    }
+
+    public long getPayLoadLength() {
+        return payloadLength;
+    }
+
+    public ByteBuffer getPayLoad() {
+        return payload;
+    }
+
+
+    // ----------------------------------- Guaranteed read methods for processor
+
+    private int processorRead(UpgradeProcessor<?> processor)
+            throws IOException {
+        int result = processor.read();
+        if (result == -1) {
+            // TODO i18n
+            throw new IOException("End of stream before end of frame");
+        }
+        return result;
+    }
+
+
+    private void processorRead(UpgradeProcessor<?> processor, byte[] bytes)
+            throws IOException {
+        int read = 0;
+        int last = 0;
+        while (read < bytes.length) {
+            last = processor.read(bytes, read, bytes.length - read);
+            if (last == -1) {
+                // TODO i18n
+                throw new IOException("End of stream before end of frame");
+            }
+            read += last;
+        }
+    }
+
+
+    /*
+     * Intended to read whole payload. Therefore able to unmask.
+     */
+    private void processorRead(UpgradeProcessor<?> processor, ByteBuffer bb)
+            throws IOException {
+        int last = 0;
+        while (bb.hasRemaining()) {
+            last = processor.read();
+            if (last == -1) {
+                // TODO i18n
+                throw new IOException("End of stream before end of frame");
+            }
+            bb.put((byte) (last ^ mask[bb.position() % 4]));
+        }
+        bb.flip();
+    }
+}

==================================================
WsInputStream.java
deleted file mode 100644
index 503dd52355..0000000000
--- a/java/org/apache/catalina/websocket/WsFrameHeader.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.websocket;
-
-/**
- * This class does not represent the complete frame header, just those parts of
- * it that need to be exposed more widely than the {@link WsInputStream}.
- */
-public class WsFrameHeader {
-
-    private final boolean fin;
-    private final int rsv;
-    private final byte opCode;
-
-    public WsFrameHeader(int b) {
-        fin = (b & 0x80) > 0;
-
-        rsv = (b & 0x70) >>> 4;
-
-        opCode = (byte) (b & 0x0F);
-    }
-
-    public boolean getFin() {
-        return fin;
-    }
-
-    public int getRsv() {
-        return rsv;
-    }
-
-    public byte getOpCode() {
-        return opCode;
-    }
-}

==================================================
WsOutbound.java
index d7b41b8242..a48b9430d1 100644
--- a/java/org/apache/catalina/websocket/WsInputStream.java
+++ b/java/org/apache/catalina/websocket/WsInputStream.java
@@ -18,7 +18,6 @@ package org.apache.catalina.websocket;
 
 import java.io.IOException;
 
-import org.apache.catalina.util.Conversions;
 import org.apache.coyote.http11.upgrade.UpgradeProcessor;
 
 /**
@@ -30,98 +29,36 @@ import org.apache.coyote.http11.upgrade.UpgradeProcessor;
 public class WsInputStream extends java.io.InputStream {
 
     private UpgradeProcessor<?> processor;
-    private WsFrameHeader wsFrameHeader;
-    private long payloadLength = -1;
-    private int[] mask = new int[4];
-
+    private WsFrame frame;
 
     private long remaining;
     private long readThisFragment;
 
     public WsInputStream(UpgradeProcessor<?> processor) throws IOException {
         this.processor = processor;
-
-        processFrameHeader();
+        processFrame();
     }
 
-
-    private void processFrameHeader() throws IOException {
-
-        // TODO: Per frame extension handling is not currently supported.
-
-        // TODO: Handle control frames between fragments
-
-        this.wsFrameHeader = new WsFrameHeader(processorRead());
-
-        // Client data must be masked
-        int i = processorRead();
-        if ((i & 0x80) == 0) {
-            // TODO: StringManager / i18n
-            throw new IOException("Client frame not masked");
-        }
-
-        payloadLength = i & 0x7F;
-        if (payloadLength == 126) {
-            byte[] extended = new byte[2];
-            processorRead(extended);
-            payloadLength = Conversions.byteArrayToLong(extended);
-        } else if (payloadLength == 127) {
-            byte[] extended = new byte[8];
-            processorRead(extended);
-            payloadLength = Conversions.byteArrayToLong(extended);
-        }
-        remaining = payloadLength;
-
-        for (int j = 0; j < mask.length; j++) {
-            mask[j] = processor.read() & 0xFF;
-        }
-
-        readThisFragment = 0;
+    public WsFrame getFrame() {
+        return frame;
     }
 
-    public WsFrameHeader getFrameHeader() {
-        return wsFrameHeader;
-    }
-
-    public long getPayloadLength() {
-        return payloadLength;
-    }
-
-
-    // ----------------------------------- Guaranteed read methods for processor
-
-    private int processorRead() throws IOException {
-        int result = processor.read();
-        if (result == -1) {
-            // TODO i18n
-            throw new IOException("End of stream before end of frame");
-        }
-        return result;
+    private void processFrame() throws IOException {
+        frame = new WsFrame(processor);
+        readThisFragment = 0;
+        remaining = frame.getPayLoadLength();
     }
 
 
-    private void processorRead(byte[] bytes) throws IOException {
-        int read = 0;
-        int last = 0;
-        while (read < bytes.length) {
-            last = processor.read(bytes, read, bytes.length - read);
-            if (last == -1) {
-                // TODO i18n
-                throw new IOException("End of stream before end of frame");
-            }
-            read += last;
-        }
-    }
-
     // ----------------------------------------------------- InputStream methods
 
     @Override
     public int read() throws IOException {
-        while (remaining == 0 && !getFrameHeader().getFin()) {
+        while (remaining == 0 && !getFrame().getFin()) {
             // Need more data - process next frame
-            processFrameHeader();
+            processFrame();
 
-            if (getFrameHeader().getOpCode() != Constants.OPCODE_CONTINUATION) {
+            if (getFrame().getOpCode() != Constants.OPCODE_CONTINUATION) {
                 // TODO i18n
                 throw new IOException("Not a continuation frame");
             }
@@ -138,6 +75,6 @@ public class WsInputStream extends java.io.InputStream {
         if(masked == -1) {
             return -1;
         }
-        return masked ^ mask[(int) ((readThisFragment - 1) % 4)];
+        return masked ^ frame.getMask()[(int) ((readThisFragment - 1) % 4)];
     }
 }

==================================================
