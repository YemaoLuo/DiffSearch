c77f96a0bda66881199b3f2d4f2740a1667a9704
==================================================
Drop tomcat-lite module. It never saw a release and has not seen meaningful development for over 4 years.
==================================================
Mark Emlyn
==================================================
Mon Nov 3 13:27:33 2014 +0000
==================================================
LiteProtocolHandler.java
deleted file mode 100644
index 2034732dd3..0000000000
--- a/modules/tomcat-lite/ivy.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<?xml version="1.0" encoding="ISO-8859-1"?>
-<!--
-   Licensed to the Apache Software Foundation (ASF) under one
-   or more contributor license agreements.  See the NOTICE file
-   distributed with this work for additional information
-   regarding copyright ownership.  The ASF licenses this file
-   to you under the Apache License, Version 2.0 (the
-   "License"); you may not use this file except in compliance
-   with the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing,
-   software distributed under the License is distributed on an
-   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.  See the License for the
-   specific language governing permissions and limitations
-   under the License.
--->
-<ivy-module version="2.0"
-       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-       xsi:noNamespaceSchemaLocation="http://ant.apache.org/ivy/schemas/ivy.xsd">
-    <info
-        organisation="org.apache.tomcat.lite"
-        module="tomcat-lite"
-        status="integration">
-	</info>
-	
-	<dependencies>
-	
-	</dependencies>
-</ivy-module>

==================================================
BaseMapper.java
deleted file mode 100644
index c7817d435d..0000000000
--- a/modules/tomcat-lite/java/org/apache/coyote/lite/LiteProtocolHandler.java
+++ /dev/null
@@ -1,426 +0,0 @@
-package org.apache.coyote.lite;
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
-import org.apache.coyote.ActionCode;
-import org.apache.coyote.ActionHook;
-import org.apache.coyote.Adapter;
-import org.apache.coyote.InputBuffer;
-import org.apache.coyote.OutputBuffer;
-import org.apache.coyote.ProtocolHandler;
-import org.apache.coyote.Request;
-import org.apache.coyote.Response;
-import org.apache.tomcat.lite.http.HttpClient;
-import org.apache.tomcat.lite.http.HttpChannel;
-import org.apache.tomcat.lite.http.HttpConnectionPool;
-import org.apache.tomcat.lite.http.HttpConnector;
-import org.apache.tomcat.lite.http.HttpRequest;
-import org.apache.tomcat.lite.http.HttpResponse;
-import org.apache.tomcat.lite.http.HttpServer;
-import org.apache.tomcat.lite.http.MultiMap;
-import org.apache.tomcat.lite.http.HttpChannel.HttpService;
-import org.apache.tomcat.lite.http.HttpConnectionPool.RemoteServer;
-import org.apache.tomcat.lite.http.HttpConnector.HttpChannelEvents;
-import org.apache.tomcat.lite.http.HttpConnector.HttpConnection;
-import org.apache.tomcat.lite.http.MultiMap.Entry;
-import org.apache.tomcat.lite.io.CBuffer;
-import org.apache.tomcat.lite.io.IOConnector;
-import org.apache.tomcat.lite.io.SocketConnector;
-import org.apache.tomcat.lite.io.SslProvider;
-import org.apache.tomcat.util.buf.ByteChunk;
-import org.apache.tomcat.util.buf.MessageBytes;
-import org.apache.tomcat.util.http.MimeHeaders;
-import org.apache.tomcat.util.modeler.Registry;
-
-/**
- * Work in progress - use the refactored http as a coyote connector.
- * Just basic requests work right now - need to implement all the
- * methods of coyote.
- *
- *
- * @author Costin Manolache
- */
-public class LiteProtocolHandler implements ProtocolHandler {
-
-    Adapter adapter;
-    Map<String, Object> attributes = new HashMap<String, Object>();
-
-
-    HttpConnector httpConnServer;
-    int port = 8999;
-
-    // Tomcat JMX integration
-    Registry registry;
-
-    public LiteProtocolHandler() {
-    }
-
-    @Override
-    public void destroy() throws Exception {
-    }
-
-    @Override
-    public Adapter getAdapter() {
-        return adapter;
-    }
-
-    @Override
-    public Object getAttribute(String name) {
-        // TODO: dynamic
-        return attributes.get(name);
-    }
-
-    @Override
-    public Iterator<String> getAttributeNames() {
-        return attributes.keySet().iterator();
-    }
-
-    @Override
-    public void init() throws Exception {
-        registry = Registry.getRegistry(null, null);
-        httpConnServer = HttpServer.newServer(port);
-
-        httpConnServer.getDispatcher().setDefaultService(new HttpService() {
-            @Override
-            public void service(HttpRequest httpReq, HttpResponse httpRes)
-                    throws IOException {
-                coyoteService(httpReq, httpRes);
-            }
-
-        });
-        final String base = "" + port;
-        bind("Httpconnector-" + port, httpConnServer);
-        bind("HttpconnectorPool-" + port, httpConnServer.cpool);
-        IOConnector io = httpConnServer.getIOConnector();
-        int ioLevel = 0;
-        while (io != null) {
-            bind("IOConnector-" + (ioLevel++) + "-" + base, io);
-            if (io instanceof SocketConnector) {
-                bind("NioThread-" + base,
-                        ((SocketConnector) io).getSelector());
-
-            }
-            io = io.getNet();
-        }
-        httpConnServer.cpool.setEvents(new HttpConnectionPool.HttpConnectionPoolEvents() {
-
-            @Override
-            public void closedConnection(RemoteServer host, HttpConnection con) {
-                unbind("HttpConnection-" + base + "-" + con.getId());
-            }
-
-            @Override
-            public void newConnection(RemoteServer host, HttpConnection con) {
-                bind("HttpConnection-" + base + "-" + con.getId(), con);
-            }
-
-            @Override
-            public void newTarget(RemoteServer host) {
-                bind("AsyncHttp-" + base + "-" + host.target, host);
-            }
-
-            @Override
-            public void targetRemoved(RemoteServer host) {
-                unbind("AsyncHttp-" + base + "-" + host.target);
-            }
-
-        });
-
-        httpConnServer.setOnCreate(new HttpChannelEvents() {
-            @Override
-            public void onCreate(HttpChannel data, HttpConnector extraData)
-                    throws IOException {
-                bind("AsyncHttp-" + base + "-" + data.getId(), data);
-            }
-            @Override
-            public void onDestroy(HttpChannel data, HttpConnector extraData)
-                    throws IOException {
-                unbind("AsyncHttp-" + base + "-" + data.getId());
-            }
-        });
-
-        // TODO: process attributes via registry !!
-
-    }
-
-    private void bind(String name, Object o) {
-        try {
-            registry.registerComponent(o, "TomcatLite:name=" + name, null);
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-
-    private void unbind(String name) {
-        registry.unregisterComponent("name=" + name);
-    }
-
-    @Override
-    public void pause() throws Exception {
-    }
-
-    @Override
-    public void resume() throws Exception {
-    }
-
-    @Override
-    public void setAdapter(Adapter adapter) {
-        this.adapter = adapter;
-
-    }
-
-    @Override
-    public void setAttribute(String name, Object value) {
-        attributes.put(name, value);
-    }
-
-    @Override
-    public void start() throws Exception {
-        httpConnServer.start();
-    }
-
-    public void setPort(int port) {
-        this.port = port;
-    }
-
-    /**
-     * Wrap old tomcat buffer to lite buffer.
-     */
-    private void wrap(MessageBytes dest, CBuffer buffer) {
-        dest.setChars(buffer.array(), buffer.position(),
-                buffer.length());
-    }
-
-    /**
-     * Main lite service method, will wrap to coyote request
-     */
-    private void coyoteService(final HttpRequest httpReq, final HttpResponse httpRes) {
-        // TODO: reuse, per req
-        RequestData rc = new RequestData();
-        rc.init(httpReq, httpRes);
-
-        try {
-            adapter.service(rc.req, rc.res);
-        } catch (Exception e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        }
-    }
-
-    /**
-     * ActionHook implementation, include coyote request/response objects.
-     */
-    public class RequestData implements ActionHook {
-        private final class LiteOutputBuffer implements OutputBuffer {
-            @Override
-            public int doWrite(org.apache.tomcat.util.buf.ByteChunk chunk,
-                    Response response) throws IOException {
-                httpRes.getBody().append(chunk.getBuffer(), chunk.getStart(),
-                        chunk.getLength());
-                return chunk.getLength();
-            }
-        }
-
-        OutputBuffer outputBuffer = new LiteOutputBuffer();
-        // TODO: recycle, etc.
-        Request req = new Request();
-
-        Response res = new Response();
-        HttpResponse httpRes;
-        HttpRequest httpReq;
-
-        InputBuffer inputBuffer = new InputBuffer() {
-            @Override
-            public int doRead(ByteChunk bchunk, Request request)
-                    throws IOException {
-                httpReq.getBody().waitData(httpReq.getHttpChannel().getIOTimeout());
-                int rd =
-                    httpReq.getBody().read(bchunk.getBytes(),
-                        bchunk.getStart(), bchunk.getBytes().length);
-                if (rd > 0) {
-                    bchunk.setEnd(bchunk.getEnd() + rd);
-                }
-                return rd;
-            }
-        };
-
-        public RequestData() {
-            req.setInputBuffer(inputBuffer);
-            res.setOutputBuffer(outputBuffer);
-            req.setResponse(res);
-            res.setRequest(req);
-            res.setHook(this);
-        }
-
-        public void init(HttpRequest httpReq, HttpResponse httpRes) {
-            this.httpRes = httpRes;
-            this.httpReq = httpReq;
-            // TODO: turn http request into a coyote request - copy all fields,
-            // add hooks where needed.
-
-            wrap(req.decodedURI(), httpReq.decodedURI());
-            wrap(req.method(), httpReq.method());
-            wrap(req.protocol(), httpReq.protocol());
-            wrap(req.requestURI(), httpReq.requestURI());
-            wrap(req.queryString(), httpReq.queryString());
-
-            req.setServerPort(httpReq.getServerPort());
-            req.serverName().setString(req.localName().toString());
-
-            MultiMap mimeHeaders = httpReq.getMimeHeaders();
-            MimeHeaders coyoteHeaders = req.getMimeHeaders();
-            for (int i = 0; i < mimeHeaders.size(); i++ ) {
-                Entry entry = mimeHeaders.getEntry(i);
-                MessageBytes val =
-                    coyoteHeaders.addValue(entry.getName().toString());
-                val.setString(entry.getValue().toString());
-            }
-        }
-
-        /**
-         * Send an action to the connector.
-         *
-         * @param actionCode Type of the action
-         * @param param Action parameter
-         */
-        public void action(ActionCode actionCode, Object param) {
-
-            if (actionCode == ActionCode.ACTION_POST_REQUEST) {
-                commit(); // make sure it's sent - on errors
-            } else if (actionCode == ActionCode.ACTION_COMMIT) {
-                commit();
-            } else if (actionCode == ActionCode.ACTION_ACK) {
-                // Done automatically by http connector
-            } else if (actionCode == ActionCode.ACTION_CLIENT_FLUSH) {
-                try {
-                    httpReq.send();
-                } catch (IOException e) {
-                    httpReq.getHttpChannel().abort(e);
-                    res.setErrorException(e);
-                }
-
-            } else if (actionCode == ActionCode.ACTION_CLOSE) {
-                // Close
-
-                // End the processing of the current request, and stop any further
-                // transactions with the client
-
-//                comet = false;
-//                try {
-//                    outputBuffer.endRequest();
-//                } catch (IOException e) {
-//                    // Set error flag
-//                    error = true;
-//                }
-
-            } else if (actionCode == ActionCode.ACTION_RESET) {
-                // Reset response
-                // Note: This must be called before the response is committed
-                httpRes.getBody().clear();
-
-            } else if (actionCode == ActionCode.ACTION_CUSTOM) {
-
-                // Do nothing
-
-            } else if (actionCode == ActionCode.ACTION_REQ_HOST_ADDR_ATTRIBUTE) {
-                req.remoteAddr().setString(httpReq.remoteAddr().toString());
-            } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE) {
-                req.localName().setString(httpReq.localName().toString());
-            } else if (actionCode == ActionCode.ACTION_REQ_HOST_ATTRIBUTE) {
-                req.remoteHost().setString(httpReq.remoteHost().toString());
-            } else if (actionCode == ActionCode.ACTION_REQ_LOCAL_ADDR_ATTRIBUTE) {
-                req.localAddr().setString(httpReq.localAddr().toString());
-            } else if (actionCode == ActionCode.ACTION_REQ_REMOTEPORT_ATTRIBUTE) {
-                req.setRemotePort(httpReq.getRemotePort());
-            } else if (actionCode == ActionCode.ACTION_REQ_LOCALPORT_ATTRIBUTE) {
-                req.setLocalPort(httpReq.getLocalPort());
-            } else if (actionCode == ActionCode.ACTION_REQ_SSL_ATTRIBUTE ) {
-
-                Object sslAtt = httpReq.getHttpChannel().getNet().getAttribute(SslProvider.ATT_SSL_CIPHER);
-                req.setAttribute("javax.servlet.request.cipher_suite", sslAtt);
-
-                sslAtt = httpReq.getHttpChannel().getNet().getAttribute(SslProvider.ATT_SSL_KEY_SIZE);
-                req.setAttribute("javax.servlet.request.key_size", sslAtt);
-
-                sslAtt = httpReq.getHttpChannel().getNet().getAttribute(SslProvider.ATT_SSL_SESSION_ID);
-                req.setAttribute("javax.servlet.request.ssl_session", sslAtt);
-
-            } else if (actionCode == ActionCode.ACTION_REQ_SSL_CERTIFICATE) {
-
-                Object cert = httpReq.getHttpChannel().getNet().getAttribute(SslProvider.ATT_SSL_CERT);
-                req.setAttribute("javax.servlet.request.X509Certificate", cert);
-
-            } else if (actionCode == ActionCode.ACTION_REQ_SET_BODY_REPLAY) {
-                ByteChunk body = (ByteChunk) param;
-                httpReq.getBody().clear();
-                try {
-                    httpReq.getBody().append(body.getBuffer(), body.getStart(), body.getLength());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-
-            } else if (actionCode == ActionCode.ACTION_AVAILABLE) {
-                req.setAvailable(httpReq.getBody().available());
-            } else if (actionCode == ActionCode.ACTION_COMET_BEGIN) {
-//                comet = true;
-            } else if (actionCode == ActionCode.ACTION_COMET_END) {
-//                comet = false;
-            } else if (actionCode == ActionCode.ACTION_COMET_CLOSE) {
-                //no op
-            } else if (actionCode == ActionCode.ACTION_COMET_SETTIMEOUT) {
-                //no op
-//            } else if (actionCode == ActionCode.ACTION_ASYNC_START) {
-//                //TODO SERVLET3 - async
-//            } else if (actionCode == ActionCode.ACTION_ASYNC_COMPLETE) {
-//                //TODO SERVLET3 - async
-//            } else if (actionCode == ActionCode.ACTION_ASYNC_SETTIMEOUT) {
-//                //TODO SERVLET3 - async
-            }
-
-
-        }
-
-        private void commit() {
-            if (res.isCommitted())
-                return;
-
-            // TODO: copy headers, fields
-            httpRes.setStatus(res.getStatus());
-            httpRes.setMessage(res.getMessage());
-            MultiMap mimeHeaders = httpRes.getMimeHeaders();
-            MimeHeaders coyoteHeaders = res.getMimeHeaders();
-            for (int i = 0; i < coyoteHeaders.size(); i++ ) {
-                MessageBytes name = coyoteHeaders.getName(i);
-                MessageBytes val = coyoteHeaders.getValue(i);
-                Entry entry = mimeHeaders.addEntry(name.toString());
-                entry.getValue().set(val.toString());
-            }
-            String contentType = res.getContentType();
-            if (contentType != null) {
-                mimeHeaders.addEntry("Content-Type").getValue().set(contentType);
-            }
-            String contentLang = res.getContentType();
-            if (contentLang != null) {
-                mimeHeaders.addEntry("Content-Language").getValue().set(contentLang);
-            }
-            long contentLength = res.getContentLengthLong();
-            if (contentLength != -1) {
-                httpRes.setContentLength(contentLength);
-            }
-            String lang = res.getContentLanguage();
-            if (lang != null) {
-                httpRes.setHeader("Content-Language", lang);
-            }
-
-            try {
-                httpReq.send();
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-
-    }
-}

==================================================
CompressFilter.java
deleted file mode 100644
index 6b2075b96e..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/BaseMapper.java
+++ /dev/null
@@ -1,1112 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.lite.http;
-
-
-import java.io.IOException;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.lite.http.HttpChannel.HttpService;
-import org.apache.tomcat.lite.io.CBuffer;
-import org.apache.tomcat.lite.io.FileConnector;
-import org.apache.tomcat.lite.io.BBucket;
-
-/**
- * Mapper, which implements the servlet API mapping rules (which are derived
- * from the HTTP rules).
- *
- * This class doesn't use JNDI.
- */
-public class BaseMapper {
-
-    private static Logger logger =
-        Logger.getLogger(BaseMapper.class.getName());
-
-    // TODO:
-    /**
-     * Mapping should be done on bytes - as received from net, before
-     * translation to chars. This would allow setting the default charset
-     * for the context - or even executing the servlet and letting it specify
-     * the charset to use for further decoding.
-     *
-     */
-    public static interface Mapper {
-        public void map(BBucket host, BBucket url, MappingData md);
-    }
-
-
-    /**
-     * Like BaseMapper, for a Context.
-     */
-    public static class ServiceMapper extends BaseMapper {
-        /**
-         * Context associated with this wrapper, used for wrapper mapping.
-         */
-        public BaseMapper.Context contextMapElement = new BaseMapper.Context(this);
-
-        /**
-         * Set context, used for wrapper mapping (request dispatcher).
-         *
-         * @param welcomeResources Welcome files defined for this context
-         */
-        public void setContext(String path, String[] welcomeResources) {
-            contextMapElement.name = path;
-            contextMapElement.welcomeResources = welcomeResources;
-        }
-
-
-        /**
-         * Add a wrapper to the context associated with this wrapper.
-         *
-         * @param path Wrapper mapping
-         * @param wrapper The Wrapper object
-         */
-        public void addWrapper(String path, Object wrapper) {
-            addWrapper(contextMapElement, path, wrapper);
-        }
-
-
-        public void addWrapper(String path, Object wrapper, boolean jspWildCard) {
-            addWrapper(contextMapElement, path, wrapper, jspWildCard);
-        }
-
-
-        /**
-         * Remove a wrapper from the context associated with this wrapper.
-         *
-         * @param path Wrapper mapping
-         */
-        public void removeWrapper(String path) {
-            removeWrapper(contextMapElement, path);
-        }
-
-
-//        /**
-//         * Map the specified URI relative to the context,
-//         * mutating the given mapping data.
-//         *
-//         * @param uri URI
-//         * @param mappingData This structure will contain the result of the mapping
-//         *                    operation
-//         */
-//        public void map(CBuffer uri, MappingData mappingData)
-//            throws Exception {
-//
-//           CBuffer uricc = uri.getCharBuffer();
-//           internalMapWrapper(contextMapElement, uricc, mappingData);
-//
-//        }
-    }
-
-    /**
-     * Array containing the virtual hosts definitions.
-     */
-    Host[] hosts = new Host[0];
-
-    /**
-     * If no other host is found.
-     * For single-host servers ( most common ) this is the only one
-     * used.
-     */
-    Host defaultHost = new Host();
-
-    public BaseMapper() {
-        defaultHost.contextList = new ContextList();
-    }
-
-    // --------------------------------------------------------- Public Methods
-
-    public synchronized Host addHost(String name) {
-        if (name == null) {
-            name = "localhost";
-        }
-        Host[] newHosts = new Host[hosts.length + 1];
-        Host newHost = new Host();
-        newHost.name = name;
-        newHost.contextList = new ContextList();
-
-        if (insertMap(hosts, newHosts, newHost)) {
-            hosts = newHosts;
-        }
-        return newHost;
-    }
-
-
-    /**
-     * Remove a host from the mapper.
-     *
-     * @param name Virtual host name
-     */
-    public synchronized void removeHost(String name) {
-        // Find and remove the old host
-        int pos = find(hosts, name);
-        if (pos < 0) {
-            return;
-        }
-        Object host = hosts[pos].object;
-        Host[] newHosts = new Host[hosts.length - 1];
-        if (removeMap(hosts, newHosts, name)) {
-            hosts = newHosts;
-        }
-        // Remove all aliases (they will map to the same host object)
-        for (int i = 0; i < newHosts.length; i++) {
-            if (newHosts[i].object == host) {
-                Host[] newHosts2 = new Host[hosts.length - 1];
-                if (removeMap(hosts, newHosts2, newHosts[i].name)) {
-                    hosts = newHosts2;
-                }
-            }
-        }
-    }
-
-    /**
-     * Add an alias to an existing host.
-     * @param name  The name of the host
-     * @param alias The alias to add
-     */
-    public synchronized void addHostAlias(String name, String alias) {
-        int pos = find(hosts, name);
-        if (pos < 0) {
-            // Should not be adding an alias for a host that doesn't exist but
-            // just in case...
-            return;
-        }
-        Host realHost = hosts[pos];
-
-        Host[] newHosts = new Host[hosts.length + 1];
-        Host newHost = new Host();
-        newHost.name = alias;
-        newHost.contextList = realHost.contextList;
-        newHost.object = realHost;
-        if (insertMap(hosts, newHosts, newHost)) {
-            hosts = newHosts;
-        }
-    }
-
-    private Host getHost(String host) {
-        return getHost(CBuffer.newInstance().append(host));
-    }
-
-    private Host getHost(CBuffer host) {
-        if (hosts == null || hosts.length <= 1 || host == null
-                || host.length() == 0 || host.equals("")) {
-            return defaultHost;
-        } else {
-            Host[] hosts = this.hosts;
-            // TODO: if hosts.length == 1 or defaultHost ?
-            int pos = findIgnoreCase(hosts, host);
-            if ((pos != -1) && (host.equalsIgnoreCase(hosts[pos].name))) {
-                return hosts[pos];
-            } else {
-                return defaultHost;
-            }
-        }
-    }
-
-    private Host getOrCreateHost(String hostName) {
-        Host host = getHost(CBuffer.newInstance().append(hostName));
-        if (host == null) {
-            host = addHost(hostName);
-        }
-        return host;
-    }
-
-    // Contexts
-
-    /**
-     * Add a new Context to an existing Host.
-     *
-     * @param hostName Virtual host name this context belongs to
-     * @param path Context path
-     * @param context Context object
-     * @param welcomeResources Welcome files defined for this context
-     * @param resources Static resources of the context
-     * @param ctxService
-     */
-    public BaseMapper.Context addContext(String hostName, String path, Object context,
-            String[] welcomeResources, FileConnector resources,
-            HttpChannel.HttpService ctxService) {
-
-        if (path == null) {
-            path = "/";
-        }
-
-        Host host = getOrCreateHost(hostName);
-
-        int slashCount = slashCount(path);
-        synchronized (host) {
-            BaseMapper.Context[] contexts = host.contextList.contexts;
-            // Update nesting
-            if (slashCount > host.contextList.nesting) {
-                host.contextList.nesting = slashCount;
-            }
-            for (int i = 0; i < contexts.length; i++) {
-                if (path.equals(contexts[i].name)) {
-                    return contexts[i];
-                }
-            }
-            BaseMapper.Context[] newContexts = new BaseMapper.Context[contexts.length + 1];
-            BaseMapper.Context newContext = new BaseMapper.Context(this);
-            newContext.name = path;
-            newContext.object = context;
-            if (welcomeResources != null) {
-                newContext.welcomeResources = welcomeResources;
-            }
-            newContext.resources = resources;
-            if (ctxService != null) {
-                newContext.defaultWrapper = new BaseMapper.ServiceMapping();
-                newContext.defaultWrapper.object = ctxService;
-            }
-
-            if (insertMap(contexts, newContexts, newContext)) {
-                host.contextList.contexts = newContexts;
-            }
-            return newContext;
-        }
-
-    }
-
-
-    /**
-     * Remove a context from an existing host.
-     *
-     * @param hostName Virtual host name this context belongs to
-     * @param path Context path
-     */
-    public void removeContext(String hostName, String path) {
-        Host host = getHost(hostName);
-        synchronized (host) {
-            BaseMapper.Context[] contexts = host.contextList.contexts;
-            if( contexts.length == 0 ){
-                return;
-            }
-            BaseMapper.Context[] newContexts = new BaseMapper.Context[contexts.length - 1];
-            if (removeMap(contexts, newContexts, path)) {
-                host.contextList.contexts = newContexts;
-                // Recalculate nesting
-                host.contextList.nesting = 0;
-                for (int i = 0; i < newContexts.length; i++) {
-                    int slashCount = slashCount(newContexts[i].name);
-                    if (slashCount > host.contextList.nesting) {
-                        host.contextList.nesting = slashCount;
-                    }
-                }
-            }
-        }
-    }
-
-
-    /**
-     * Add a new Wrapper to an existing Context.
-     *
-     * @param hostName Virtual host name this wrapper belongs to
-     * @param contextPath Context path this wrapper belongs to
-     * @param path Wrapper mapping
-     * @param wrapper Wrapper object
-     */
-    public void addWrapper(String hostName, String contextPath, String path,
-                           Object wrapper) {
-        addWrapper(hostName, contextPath, path, wrapper, false);
-    }
-
-
-    public void addWrapper(String hostName, String contextPath, String path,
-                           Object wrapper, boolean jspWildCard) {
-        Host host = getHost(hostName);
-        BaseMapper.Context[] contexts = host.contextList.contexts;
-        int pos2 = find(contexts, contextPath);
-        if( pos2<0 ) {
-            logger.severe("No context found: " + contextPath );
-            return;
-        }
-        BaseMapper.Context context = contexts[pos2];
-        if (context.name.equals(contextPath)) {
-            addWrapper(context, path, wrapper, jspWildCard);
-        }
-    }
-
-
-    public void addWrapper(BaseMapper.Context context, String path, Object wrapper) {
-        addWrapper(context, path, wrapper, false);
-    }
-
-
-    /**
-     * Adds a wrapper to the given context.
-     *
-     * @param context The context to which to add the wrapper
-     * @param path Wrapper mapping
-     * @param wrapper The Wrapper object
-     * @param jspWildCard true if the wrapper corresponds to the JspServlet
-     * and the mapping path contains a wildcard; false otherwise
-     */
-    protected void addWrapper(BaseMapper.Context context, String path, Object wrapper,
-                              boolean jspWildCard) {
-
-        synchronized (context) {
-            BaseMapper.ServiceMapping newWrapper = new BaseMapper.ServiceMapping();
-            newWrapper.object = wrapper;
-            newWrapper.jspWildCard = jspWildCard;
-            if (path.endsWith("/*")) {
-                // Wildcard wrapper
-                newWrapper.name = path.substring(0, path.length() - 2);
-                BaseMapper.ServiceMapping[] oldWrappers = context.wildcardWrappers;
-                BaseMapper.ServiceMapping[] newWrappers =
-                    new BaseMapper.ServiceMapping[oldWrappers.length + 1];
-                if (insertMap(oldWrappers, newWrappers, newWrapper)) {
-                    context.wildcardWrappers = newWrappers;
-                    int slashCount = slashCount(newWrapper.name);
-                    if (slashCount > context.nesting) {
-                        context.nesting = slashCount;
-                    }
-                }
-            } else if (path.startsWith("*.")) {
-                // Extension wrapper
-                newWrapper.name = path.substring(2);
-                BaseMapper.ServiceMapping[] oldWrappers = context.extensionWrappers;
-                BaseMapper.ServiceMapping[] newWrappers =
-                    new BaseMapper.ServiceMapping[oldWrappers.length + 1];
-                if (insertMap(oldWrappers, newWrappers, newWrapper)) {
-                    context.extensionWrappers = newWrappers;
-                }
-            } else if (path.equals("/")) {
-                // Default wrapper
-                newWrapper.name = "";
-                context.defaultWrapper = newWrapper;
-            } else {
-                // Exact wrapper
-                newWrapper.name = path;
-                BaseMapper.ServiceMapping[] oldWrappers = context.exactWrappers;
-                BaseMapper.ServiceMapping[] newWrappers =
-                    new BaseMapper.ServiceMapping[oldWrappers.length + 1];
-                if (insertMap(oldWrappers, newWrappers, newWrapper)) {
-                    context.exactWrappers = newWrappers;
-                }
-            }
-        }
-    }
-
-    /**
-     * Remove a wrapper from an existing context.
-     *
-     * @param hostName Virtual host name this wrapper belongs to
-     * @param contextPath Context path this wrapper belongs to
-     * @param path Wrapper mapping
-     */
-    public void removeWrapper(String hostName, String contextPath,
-                              String path) {
-        Host host = getHost(hostName);
-        BaseMapper.Context[] contexts = host.contextList.contexts;
-        int pos2 = find(contexts, contextPath);
-        if (pos2 < 0) {
-            return;
-        }
-        BaseMapper.Context context = contexts[pos2];
-        if (context.name.equals(contextPath)) {
-            removeWrapper(context, path);
-        }
-    }
-
-    protected void removeWrapper(BaseMapper.Context context, String path) {
-        synchronized (context) {
-            if (path.endsWith("/*")) {
-                // Wildcard wrapper
-                String name = path.substring(0, path.length() - 2);
-                BaseMapper.ServiceMapping[] oldWrappers = context.wildcardWrappers;
-                BaseMapper.ServiceMapping[] newWrappers =
-                    new BaseMapper.ServiceMapping[oldWrappers.length - 1];
-                if (removeMap(oldWrappers, newWrappers, name)) {
-                    // Recalculate nesting
-                    context.nesting = 0;
-                    for (int i = 0; i < newWrappers.length; i++) {
-                        int slashCount = slashCount(newWrappers[i].name);
-                        if (slashCount > context.nesting) {
-                            context.nesting = slashCount;
-                        }
-                    }
-                    context.wildcardWrappers = newWrappers;
-                }
-            } else if (path.startsWith("*.")) {
-                // Extension wrapper
-                String name = path.substring(2);
-                BaseMapper.ServiceMapping[] oldWrappers = context.extensionWrappers;
-                BaseMapper.ServiceMapping[] newWrappers =
-                    new BaseMapper.ServiceMapping[oldWrappers.length - 1];
-                if (removeMap(oldWrappers, newWrappers, name)) {
-                    context.extensionWrappers = newWrappers;
-                }
-            } else if (path.equals("/")) {
-                // Default wrapper
-                context.defaultWrapper = null;
-            } else {
-                // Exact wrapper
-                String name = path;
-                BaseMapper.ServiceMapping[] oldWrappers = context.exactWrappers;
-                BaseMapper.ServiceMapping[] newWrappers =
-                    new BaseMapper.ServiceMapping[oldWrappers.length - 1];
-                if (removeMap(oldWrappers, newWrappers, name)) {
-                    context.exactWrappers = newWrappers;
-                }
-            }
-        }
-    }
-
-    /**
-     * Map the specified host name and URI, mutating the given mapping data.
-     *
-     * @param host Virtual host name
-     * @param uri URI
-     * @param mappingData This structure will contain the result of the mapping
-     *                    operation
-     */
-    public void map(CBuffer host, CBuffer uri,
-                    MappingData mappingData)
-        throws Exception {
-
-        internalMap(host.length() == 0 ? null :
-            host, uri, mappingData);
-    }
-
-
-    // -------------------------------------------------------- Private Methods
-
-    // public Context mapContext(CBuffer host, CBuffer url);
-
-    /**
-     * Map the specified URI.
-     */
-    private final void internalMap(CBuffer host, CBuffer uri,
-                                   MappingData mappingData)
-        throws Exception {
-        BaseMapper.Context[] contexts = null;
-        BaseMapper.Context context = null;
-        int nesting = 0;
-
-        // Virtual host mapping
-        Host mappedHost = getHost(host);
-        contexts = mappedHost.contextList.contexts;
-        nesting = mappedHost.contextList.nesting;
-
-        // Context mapping
-        if (contexts.length == 0) {
-            return;
-        }
-
-        if (mappingData.context == null) {
-            if (nesting < 1 || contexts.length == 1 && "".equals(contexts[0].name)) {
-                // if 1 context (default) -> fast return
-                context = contexts[0];
-            } else if (nesting == 1) {
-                // if all contexts are 1-component-only
-                int nextSlash = uri.indexOf('/', 1);
-                if (nextSlash == -1) {
-                  nextSlash = uri.length();
-                }
-                mappingData.contextPath.set(uri, 0, nextSlash);
-                int pos = find(contexts, uri);
-                if (pos == -1) {
-                        pos = find(contexts, "/");
-                }
-                if (pos >= 0) {
-                    context = contexts[pos];
-                }
-            } else {
-                int pos = find(contexts, uri);
-                if (pos >= 0) {
-                    int lastSlash = -1;
-                    int length = -1;
-                    boolean found = false;
-                    CBuffer tmp = mappingData.tmpPrefix;
-                    tmp.wrap(uri, 0, uri.length());
-
-                    while (pos >= 0) {
-                        if (tmp.startsWith(contexts[pos].name)) {
-                            length = contexts[pos].name.length();
-                            if (tmp.length() == length) {
-                                found = true;
-                                break;
-                            } else if (tmp.startsWithIgnoreCase("/", length)) {
-                                found = true;
-                                break;
-                            }
-                        }
-                        if (lastSlash == -1) {
-                            lastSlash = tmp.nthSlash(nesting + 1);
-                        } else {
-                            lastSlash = tmp.lastIndexOf('/');
-                        }
-                        tmp.delete(lastSlash);
-                        pos = find(contexts, tmp);
-                    }
-
-                    if (!found) {
-                        if (contexts[0].name.equals("")) {
-                            context = contexts[0];
-                        }
-                    } else {
-                        context = contexts[pos];
-                    }
-                }
-            }
-
-            if (context != null) {
-                mappingData.context = context.object;
-                mappingData.contextPath.set(context.name);
-            }
-        }
-
-        // Wrapper mapping
-        if ((context != null) && (mappingData.getServiceObject() == null)) {
-            internalMapWrapper(context, uri, mappingData);
-        }
-
-    }
-
-
-    /**
-     * Wrapper mapping, using servlet rules.
-     */
-    protected final void internalMapWrapper(
-            BaseMapper.Context context,
-            CBuffer url,
-            MappingData mappingData)
-                throws Exception {
-
-        boolean noServletPath = false;
-        if (url.length() < context.name.length()) {
-            throw new IOException("Invalid mapping " + context.name + " " +
-                    url);
-        }
-
-        try {
-            // Set the servlet path.
-            mappingData.tmpServletPath.set(url,
-                    context.name.length(),
-                    url.length() - context.name.length());
-
-            if (mappingData.tmpServletPath.length() == 0) {
-                mappingData.tmpServletPath.append('/');
-                // This is just the context /example or /
-                if (!context.name.equals("/")) {
-                    noServletPath = true;
-                }
-            }
-
-            mapAfterContext(context, url, mappingData.tmpServletPath, mappingData,
-                    noServletPath);
-        } catch (ArrayIndexOutOfBoundsException ex) {
-            System.err.println(1);
-        }
-    }
-
-    void mapAfterContext(BaseMapper.Context context,
-            CBuffer url, CBuffer urlNoContext,
-            MappingData mappingData, boolean noServletPath)
-        throws Exception {
-
-
-        // Rule 1 -- Exact Match
-        BaseMapper.ServiceMapping[] exactWrappers = context.exactWrappers;
-        internalMapExactWrapper(exactWrappers, urlNoContext, mappingData);
-
-        // Rule 2 -- Prefix Match
-        boolean checkJspWelcomeFiles = false;
-        BaseMapper.ServiceMapping[] wildcardWrappers = context.wildcardWrappers;
-        if (mappingData.getServiceObject() == null) {
-
-            internalMapWildcardWrapper(wildcardWrappers, context.nesting,
-                                       urlNoContext, mappingData);
-
-            if (mappingData.getServiceObject() != null
-                    && mappingData.service.jspWildCard) {
-                if (urlNoContext.lastChar() == '/') {
-                    /*
-                     * Path ending in '/' was mapped to JSP servlet based on
-                     * wildcard match (e.g., as specified in url-pattern of a
-                     * jsp-property-group.
-                     * Force the context's welcome files, which are interpreted
-                     * as JSP files (since they match the url-pattern), to be
-                     * considered. See Bugzilla 27664.
-                     */
-                    mappingData.service = null;
-                    checkJspWelcomeFiles = true;
-                } else {
-                    // See Bugzilla 27704
-                    mappingData.wrapperPath.set(urlNoContext);
-                    mappingData.pathInfo.recycle();
-                }
-            }
-        }
-
-        if(mappingData.getServiceObject() == null && noServletPath) {
-            // The path is empty, redirect to "/"
-            mappingData.redirectPath.set(context.name);
-            mappingData.redirectPath.append("/");
-            return;
-        }
-
-        // Rule 3 -- Extension Match
-        BaseMapper.ServiceMapping[] extensionWrappers = context.extensionWrappers;
-        if (mappingData.getServiceObject() == null && !checkJspWelcomeFiles) {
-            internalMapExtensionWrapper(extensionWrappers, urlNoContext, mappingData);
-        }
-
-        // Rule 4 -- Welcome resources processing for servlets
-        if (mappingData.getServiceObject() == null) {
-            boolean checkWelcomeFiles = checkJspWelcomeFiles;
-            if (!checkWelcomeFiles) {
-                checkWelcomeFiles = (urlNoContext.lastChar() == '/');
-            }
-            if (checkWelcomeFiles) {
-                for (int i = 0; (i < context.welcomeResources.length)
-                         && (mappingData.getServiceObject() == null); i++) {
-
-                    CBuffer wpath = mappingData.tmpWelcome;
-                    wpath.set(urlNoContext);
-                    wpath.append(context.welcomeResources[i]);
-
-                    // Rule 4a -- Welcome resources processing for exact macth
-                    internalMapExactWrapper(exactWrappers, urlNoContext, mappingData);
-
-                    // Rule 4b -- Welcome resources processing for prefix match
-                    if (mappingData.getServiceObject() == null) {
-                        internalMapWildcardWrapper
-                            (wildcardWrappers, context.nesting,
-                             urlNoContext, mappingData);
-                    }
-
-                    // Rule 4c -- Welcome resources processing
-                    //            for physical folder
-                    if (mappingData.getServiceObject() == null
-                        && context.resources != null) {
-                        String pathStr = urlNoContext.toString();
-
-                        mapWelcomResource(context, urlNoContext, mappingData,
-                                extensionWrappers, pathStr);
-
-                    }
-                }
-            }
-
-        }
-
-
-        // Rule 7 -- Default servlet
-        if (mappingData.getServiceObject() == null && !checkJspWelcomeFiles) {
-            if (context.defaultWrapper != null) {
-                mappingData.service = context.defaultWrapper;
-                mappingData.requestPath.set(urlNoContext);
-                mappingData.wrapperPath.set(urlNoContext);
-            }
-            // Redirection to a folder
-            if (context.resources != null && urlNoContext.lastChar() != '/') {
-                String pathStr = urlNoContext.toString();
-                mapDefaultServlet(context, urlNoContext, mappingData,
-                        url,
-                        pathStr);
-            }
-        }
-    }
-
-    /**
-     * Filesystem-dependent method:
-     *  if pathStr corresponds to a directory, we'll need to redirect with /
-     *  at end.
-     */
-    protected void mapDefaultServlet(BaseMapper.Context context,
-            CBuffer path,
-            MappingData mappingData,
-            CBuffer url,
-            String pathStr) throws IOException {
-
-        if (context.resources != null
-                && context.resources.isDirectory(pathStr)) {
-            mappingData.redirectPath.set(url);
-            mappingData.redirectPath.append("/");
-        } else {
-            mappingData.requestPath.set(pathStr);
-            mappingData.wrapperPath.set(pathStr);
-        }
-    }
-
-
-    /**
-     * Filesystem dependent method:
-     *  check if a resource exists in filesystem.
-     */
-    protected void mapWelcomResource(BaseMapper.Context context, CBuffer path,
-                               MappingData mappingData,
-                               BaseMapper.ServiceMapping[] extensionWrappers, String pathStr) {
-
-        if (context.resources != null &&
-                context.resources.isFile(pathStr)) {
-            internalMapExtensionWrapper(extensionWrappers,
-                                        path, mappingData);
-            if (mappingData.getServiceObject() == null
-                && context.defaultWrapper != null) {
-                mappingData.service = context.defaultWrapper;
-                mappingData.requestPath.set(path);
-                mappingData.wrapperPath.set(path);
-                mappingData.requestPath.set(pathStr);
-                mappingData.wrapperPath.set(pathStr);
-            }
-        }
-    }
-
-    /**
-     * Exact mapping.
-     */
-    private final void internalMapExactWrapper
-        (BaseMapper.ServiceMapping[] wrappers, CBuffer path, MappingData mappingData) {
-        int pos = find(wrappers, path);
-        if ((pos != -1) && (path.equals(wrappers[pos].name))) {
-            mappingData.requestPath.set(wrappers[pos].name);
-            mappingData.wrapperPath.set(wrappers[pos].name);
-            mappingData.service = wrappers[pos];
-        }
-    }
-
-
-    /**
-     * Prefix mapping. ( /foo/* )
-     */
-    private final void internalMapWildcardWrapper
-        (BaseMapper.ServiceMapping[] wrappers, int nesting, CBuffer path,
-         MappingData mappingData) {
-
-        int lastSlash = -1;
-        int length = -1;
-
-        CBuffer tmp = mappingData.tmpPrefix;
-        tmp.wrap(path, 0, path.length());
-
-        int pos = find(wrappers, tmp);
-        if (pos != -1) {
-            boolean found = false;
-            while (pos >= 0) {
-                if (tmp.startsWith(wrappers[pos].name)) {
-                    length = wrappers[pos].name.length();
-                    if (tmp.length() == length) {
-                        found = true;
-                        break;
-                    } else if (tmp.startsWithIgnoreCase("/", length)) {
-                        found = true;
-                        break;
-                    }
-                }
-                if (lastSlash == -1) {
-                    lastSlash = tmp.nthSlash(nesting + 1);
-                } else {
-                    lastSlash = tmp.lastIndexOf('/');
-                }
-                tmp.delete(lastSlash);
-                pos = find(wrappers, tmp);
-            }
-            if (found) {
-                mappingData.wrapperPath.set(wrappers[pos].name);
-
-                if (path.length() > length) {
-                    mappingData.pathInfo.set
-                        (path, length, path.length() - length);
-                }
-                mappingData.requestPath.set(path);
-
-                mappingData.service = wrappers[pos];
-            }
-        }
-    }
-
-
-    /**
-     * Extension mappings.
-     */
-    protected final void internalMapExtensionWrapper
-        (BaseMapper.ServiceMapping[] wrappers, CBuffer path, MappingData mappingData) {
-
-        int dot = path.getExtension(mappingData.ext, '/', '.');
-        if (dot >= 0) {
-            int pos = find(wrappers, mappingData.ext);
-
-            if ((pos != -1)
-                    && (mappingData.ext.equals(wrappers[pos].name))) {
-
-                mappingData.wrapperPath.set(path);
-                mappingData.requestPath.set(path);
-
-                mappingData.service = wrappers[pos];
-            }
-        }
-    }
-
-
-    /**
-     * Find a map elemnt given its name in a sorted array of map elements.
-     * This will return the index for the closest inferior or equal item in the
-     * given array.
-     */
-    private static final int find(BaseMapper.Mapping[] map, CBuffer name) {
-
-        int a = 0;
-        int b = map.length - 1;
-
-        // Special cases: -1 and 0
-        if (b == -1) {
-            return -1;
-        }
-
-        if (name.compare(map[0].name) < 0 ) {
-            return -1;
-        }
-        if (b == 0) {
-            return 0;
-        }
-
-        int i = 0;
-        while (true) {
-            i = (b + a) / 2;
-            int result = name.compare(map[i].name);
-            if (result == 1) {
-                a = i;
-            } else if (result == 0) {
-                return i;
-            } else {
-                b = i;
-            }
-            if ((b - a) == 1) {
-                int result2 = name.compare(map[b].name);
-                if (result2 < 0) {
-                    return a;
-                } else {
-                    return b;
-                }
-            }
-        }
-
-    }
-
-    /**
-     * Find a map elemnt given its name in a sorted array of map elements.
-     * This will return the index for the closest inferior or equal item in the
-     * given array.
-     */
-    private static final int findIgnoreCase(BaseMapper.Mapping[] map,
-            CBuffer name) {
-        int a = 0;
-        int b = map.length - 1;
-
-        // Special cases: -1 and 0
-        if (b == -1) {
-            return -1;
-        }
-        if (name.compareIgnoreCase(map[0].name) < 0 ) {
-            return -1;
-        }
-        if (b == 0) {
-            return 0;
-        }
-
-        int i = 0;
-        while (true) {
-            i = (b + a) / 2;
-            int result = name.compareIgnoreCase(map[i].name);
-            if (result == 1) {
-                a = i;
-            } else if (result == 0) {
-                return i;
-            } else {
-                b = i;
-            }
-            if ((b - a) == 1) {
-                int result2 = name.compareIgnoreCase(map[b].name);
-                if (result2 < 0) {
-                    return a;
-                } else {
-                    return b;
-                }
-            }
-        }
-
-    }
-
-
-    /**
-     * Find a map element given its name in a sorted array of map elements.
-     * This will return the index for the closest inferior or equal item in the
-     * given array.
-     */
-    private static final int find(BaseMapper.Mapping[] map, String name) {
-
-        int a = 0;
-        int b = map.length - 1;
-
-        // Special cases: -1 and 0
-        if (b == -1) {
-            return -1;
-        }
-
-        if (name.compareTo(map[0].name) < 0) {
-            return -1;
-        }
-        if (b == 0) {
-            return 0;
-        }
-
-        int i = 0;
-        while (true) {
-            i = (b + a) / 2;
-            int result = name.compareTo(map[i].name);
-            if (result > 0) {
-                a = i;
-            } else if (result == 0) {
-                return i;
-            } else {
-                b = i;
-            }
-            if ((b - a) == 1) {
-                int result2 = name.compareTo(map[b].name);
-                if (result2 < 0) {
-                    return a;
-                } else {
-                    return b;
-                }
-            }
-        }
-
-    }
-
-
-    /**
-     * Return the slash count in a given string.
-     */
-    private static final int slashCount(String name) {
-        int pos = -1;
-        int count = 0;
-        while ((pos = name.indexOf('/', pos + 1)) != -1) {
-            count++;
-        }
-        return count;
-    }
-
-
-    /**
-     * Insert into the right place in a sorted MapElement array, and prevent
-     * duplicates.
-     */
-    private static final boolean insertMap
-        (BaseMapper.Mapping[] oldMap, BaseMapper.Mapping[] newMap, BaseMapper.Mapping newElement) {
-        int pos = find(oldMap, newElement.name);
-        if ((pos != -1) && (newElement.name.equals(oldMap[pos].name))) {
-            return false;
-        }
-        System.arraycopy(oldMap, 0, newMap, 0, pos + 1);
-        newMap[pos + 1] = newElement;
-        System.arraycopy
-            (oldMap, pos + 1, newMap, pos + 2, oldMap.length - pos - 1);
-        return true;
-    }
-
-
-    /**
-     * Insert into the right place in a sorted MapElement array.
-     */
-    private static final boolean removeMap
-        (BaseMapper.Mapping[] oldMap, BaseMapper.Mapping[] newMap, String name) {
-        int pos = find(oldMap, name);
-        if ((pos != -1) && (name.equals(oldMap[pos].name))) {
-            System.arraycopy(oldMap, 0, newMap, 0, pos);
-            System.arraycopy(oldMap, pos + 1, newMap, pos,
-                             oldMap.length - pos - 1);
-            return true;
-        }
-        return false;
-    }
-
-
-    // ------------------------------------------------- MapElement Inner Class
-
-
-    protected static final class Host
-        extends BaseMapper.Mapping {
-        //Map<String, Context> contexts = new HashMap();
-        //Context rootContext;
-
-        public ContextList contextList = null;
-
-    }
-
-
-    // ------------------------------------------------ ContextList Inner Class
-
-    // Shared among host aliases.
-    protected static final class ContextList {
-
-        public BaseMapper.Context[] contexts = new BaseMapper.Context[0];
-        public int nesting = 0;
-
-    }
-
-
-    public static final class Context extends BaseMapper.Mapping {
-
-        Context(BaseMapper mapper) {
-            this.mapper = mapper;
-        }
-        public BaseMapper mapper;
-        public String[] welcomeResources = new String[0];
-        public FileConnector resources = null;
-
-        public BaseMapper.ServiceMapping defaultWrapper = null;
-
-        public BaseMapper.ServiceMapping[] exactWrappers = new BaseMapper.ServiceMapping[0];
-        public BaseMapper.ServiceMapping[] wildcardWrappers = new BaseMapper.ServiceMapping[0];
-        public BaseMapper.ServiceMapping[] extensionWrappers = new BaseMapper.ServiceMapping[0];
-        public int nesting = 0;
-
-        public void addWrapper(String path, HttpService service) {
-            mapper.addWrapper(this, path, service);
-        }
-
-    }
-
-
-    public static class ServiceMapping extends BaseMapper.Mapping {
-        public boolean jspWildCard = false;
-        // If set, the service will run in the selector thread ( should
-        // be non-blocking )
-        public boolean selectorThread = false;
-
-    }
-
-
-    protected static abstract class Mapping {
-        public String name = null;
-        public Object object = null;
-
-        public String toString() {
-            if (name == null || "".equals(name)) {
-                return "DEFAULT";
-            }
-            return name;
-        }
-    }
-
-
-    // ---------------------------------------------------- Context Inner Class
-
-
-}

==================================================
ContentType.java
deleted file mode 100644
index ecf5851006..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/CompressFilter.java
+++ /dev/null
@@ -1,225 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
-import org.apache.tomcat.lite.io.BBucket;
-import org.apache.tomcat.lite.io.IOBuffer;
-
-import com.jcraft.jzlib.JZlib;
-import com.jcraft.jzlib.ZStream;
-
-public class CompressFilter {
-
-    // Stream format: RFC1950
-    // 1CMF 1FLG [4DICTID] DATA 4ADLER
-    // CMF:  CINFO + CM (compression method). == x8
-    // 78 == deflate with 32k window, i.e. max window
-
-    // FLG: 2bit level, 1 bit FDICT, 5 bit FCHECK
-    // Cx, Dx - no dict; Fx, Ex - dict ( for BEST_COMPRESSION )
-
-    // Overhead: 6 bytes without dict, 10 with dict
-    // data is encoded in blocks - there is a 'block end' marker and
-    // 'last block'.
-
-    // Flush: http://www.bolet.org/~pornin/deflate-flush.html
-    // inflater needs about 9 bits
-    // Z_SYNC_FLUSH: send empty block, 00 00 FF FF - seems recomended
-    // PPP can skip this - there is a record format on top
-    // Z_PARTIAL_FLUSH: standard for SSH
-
-    ZStream cStream;
-    ZStream dStream;
-
-    byte[] dict;
-    long dictId;
-
-    public CompressFilter() {
-    }
-
-    public void recycle() {
-        if (cStream == null) {
-            return;
-        }
-        cStream.free();
-        cStream = null;
-        dStream.free();
-        dStream = null;
-    }
-
-    public void init() {
-        if (cStream != null) {
-            return;
-        }
-        // can't call: cStream.free(); - will kill the adler, NPE
-        cStream = new ZStream();
-        // BEST_COMRESSION results in 256Kb per Deflate
-        // 15 == default = 32k window
-        cStream.deflateInit(JZlib.Z_BEST_SPEED, 10);
-
-        dStream = new ZStream();
-        dStream.inflateInit();
-
-    }
-
-    CompressFilter setDictionary(byte[] dict, long id) {
-        init();
-        this.dict = dict;
-        this.dictId = id;
-        cStream.deflateSetDictionary(dict, dict.length);
-        return this;
-    }
-
-    void compress(IOBuffer in, IOBuffer out) throws IOException {
-        init();
-        BBucket bb = in.popFirst();
-
-        while (bb != null) {
-            // TODO: only the last one needs flush
-
-            // TODO: size missmatches ?
-            compress(bb, out, false);
-            bb = in.popFirst();
-        }
-
-        if (in.isClosedAndEmpty()) {
-            compressEnd(out);
-        }
-    }
-
-    void compress(BBucket bb, IOBuffer out, boolean last) throws IOException {
-        // TODO: only the last one needs flush
-
-        // TODO: size missmatches ?
-        init();
-        int flush = JZlib.Z_PARTIAL_FLUSH;
-
-        cStream.next_in = bb.array();
-        cStream.next_in_index = bb.position();
-        cStream.avail_in = bb.remaining();
-
-        while (true) {
-            ByteBuffer outB = out.getWriteBuffer();
-            cStream.next_out = outB.array();
-            cStream.next_out_index = outB.position();
-            cStream.avail_out = outB.remaining();
-
-            int err = cStream.deflate(flush);
-            check(err, cStream);
-            outB.position(cStream.next_out_index);
-            out.releaseWriteBuffer(1);
-            if (cStream.avail_out > 0 || cStream.avail_in == 0) {
-                break;
-            }
-        }
-
-        if (last) {
-            compressEnd(out);
-        }
-    }
-
-    private void compressEnd(IOBuffer out) throws IOException {
-        while (true) {
-            ByteBuffer outB = out.getWriteBuffer();
-            cStream.next_out = outB.array();
-
-            cStream.next_out_index = outB.position();
-            cStream.avail_out = outB.remaining();
-            cStream.deflate(JZlib.Z_FINISH);
-            cStream.deflateEnd();
-
-            outB.position(cStream.next_out_index);
-            out.releaseWriteBuffer(1);
-            if (cStream.avail_out > 0) {
-                break;
-            }
-        }
-    }
-
-    void decompress(IOBuffer in, IOBuffer out) throws IOException {
-        decompress(in, out, in.available());
-    }
-
-    void decompress(IOBuffer in, IOBuffer out, int len) throws IOException {
-        init();
-        BBucket bb = in.peekFirst();
-
-        while (bb != null && len > 0) {
-            dStream.next_in = bb.array();
-            dStream.next_in_index = bb.position();
-            int rd = Math.min(bb.remaining(), len);
-            dStream.avail_in = rd;
-
-            while (true) {
-                ByteBuffer outB = out.getWriteBuffer();
-
-                dStream.next_out = outB.array();
-                dStream.next_out_index = outB.position();
-                dStream.avail_out = outB.remaining();
-
-                int err = dStream.inflate(JZlib.Z_SYNC_FLUSH);
-                if (err == JZlib.Z_NEED_DICT && dict != null) {
-                    // dStream.adler has the dict id - not sure how to check
-                    if (dictId != 0 && dStream.adler != dictId) {
-                        throw new IOException("Invalid dictionary");
-                    }
-                    if (dictId == 0) {
-                        // initDict should pass a real dict id.
-                        System.err.println("Missing dict ID: " + dStream.adler);
-                    }
-                    dStream.inflateSetDictionary(dict, dict.length);
-                    err = dStream.inflate(JZlib.Z_SYNC_FLUSH);
-                }
-                outB.position(dStream.next_out_index);
-                out.releaseWriteBuffer(1);
-
-                if (err == JZlib.Z_STREAM_END) {
-                    err = dStream.inflateEnd();
-                    out.close();
-                    check(err, dStream);
-                    // move in back, not consummed
-                    bb.position(dStream.next_in_index);
-                    return;
-                }
-                check(err, dStream);
-
-                if (dStream.avail_out > 0 || dStream.avail_in == 0) {
-                    break;
-                }
-            }
-
-            in.advance(rd); // consummed
-            len -= rd;
-            bb = in.peekFirst();
-        }
-
-        if (in.isClosedAndEmpty()) {
-            // Shouldn't happen - input was not properly closed..
-            // This should throw an exception, inflateEnd will check the CRC
-            int err = dStream.inflateEnd();
-            out.close();
-            check(err, dStream);
-            out.close();
-        }
-    }
-
-    private void check(int err, ZStream stream) throws IOException {
-        if (err != JZlib.Z_OK) {
-            throw new IOException(err + " " + stream.msg);
-        }
-    }
-
-    boolean isCompressed(HttpMessage http) {
-        return false;
-    }
-
-    boolean needsCompression(HttpMessage in, HttpMessage out) {
-        return false;
-    }
-
-
-}
-

==================================================
DefaultHttpConnector.java
deleted file mode 100644
index 31c6b9c65d..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/ContentType.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.lite.http;
-
-
-/**
- * Usefull methods for Content-Type processing
- *
- * @author James Duncan Davidson [duncan@eng.sun.com]
- * @author James Todd [gonzo@eng.sun.com]
- * @author Jason Hunter [jch@eng.sun.com]
- * @author Harish Prabandham
- * @author costin@eng.sun.com
- */
-public class ContentType {
-
-    /**
-     * Parse the character encoding from the specified content type header.
-     * If the content type is null, or there is no explicit character encoding,
-     * <code>null</code> is returned.
-     *
-     * @param contentType a content type header
-     */
-    public static String getCharsetFromContentType(String contentType) {
-
-        if (contentType == null)
-            return (null);
-        int start = contentType.indexOf("charset=");
-        if (start < 0)
-            return (null);
-        String encoding = contentType.substring(start + 8);
-        int end = encoding.indexOf(';');
-        if (end >= 0)
-            encoding = encoding.substring(0, end);
-        encoding = encoding.trim();
-        if ((encoding.length() > 2) && (encoding.startsWith("\""))
-            && (encoding.endsWith("\"")))
-            encoding = encoding.substring(1, encoding.length() - 1);
-        return (encoding.trim());
-
-    }
-
-
-    /**
-     * Returns true if the given content type contains a charset component,
-     * false otherwise.
-     *
-     * @param type Content type
-     * @return true if the given content type contains a charset component,
-     * false otherwise
-     */
-    public static boolean hasCharset(String type) {
-
-        boolean hasCharset = false;
-
-        int len = type.length();
-        int index = type.indexOf(';');
-        while (index != -1) {
-            index++;
-            while (index < len && Character.isWhitespace(type.charAt(index))) {
-                index++;
-            }
-            if (index+8 < len
-                    && type.charAt(index) == 'c'
-                    && type.charAt(index+1) == 'h'
-                    && type.charAt(index+2) == 'a'
-                    && type.charAt(index+3) == 'r'
-                    && type.charAt(index+4) == 's'
-                    && type.charAt(index+5) == 'e'
-                    && type.charAt(index+6) == 't'
-                    && type.charAt(index+7) == '=') {
-                hasCharset = true;
-                break;
-            }
-            index = type.indexOf(';', index);
-        }
-
-        return hasCharset;
-    }
-
-}

==================================================
Dispatcher.java
deleted file mode 100644
index e43b4fdab1..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/DefaultHttpConnector.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import org.apache.tomcat.lite.io.SocketConnector;
-
-public class DefaultHttpConnector {
-
-    public synchronized static HttpConnector getNew() {
-        return new HttpConnector(new SocketConnector());
-    }
-
-    public synchronized static HttpConnector get() {
-        if (DefaultHttpConnector.socketConnector == null) {
-            socketConnector =
-                new SocketConnector();
-        }
-        return new HttpConnector(socketConnector);
-    }
-
-    private static SocketConnector socketConnector;
-
-}

==================================================
Http11Connection.java
deleted file mode 100644
index 51537e6ff0..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/Dispatcher.java
+++ /dev/null
@@ -1,199 +0,0 @@
-/*  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.lite.http;
-
-import java.io.IOException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.lite.http.HttpChannel.HttpService;
-import org.apache.tomcat.lite.http.HttpChannel.RequestCompleted;
-import org.apache.tomcat.lite.io.CBuffer;
-import org.apache.tomcat.lite.io.FileConnector;
-
-/**
- * This class has several functions:
- * - maps the request to another HttpService
- * - decide if the request should be run in the selector thread
- * or in a thread pool
- * - finalizes the request ( close / flush )
- * - detects if the request is complete or set callbacks
- * for receive/flush/done.
- *
- */
-public class Dispatcher implements HttpService {
-
-    private BaseMapper mapper;
-    static boolean debug = false;
-    static Logger log = Logger.getLogger("Mapper");
-    Executor tp = Executors.newCachedThreadPool();
-
-    public Dispatcher() {
-        init();
-    }
-
-    protected void init() {
-        mapper = new BaseMapper();
-    }
-
-    public void runService(HttpChannel ch) {
-        runService(ch, true);
-    }
-
-    public void runService(HttpChannel ch, boolean recycle) {
-        MappingData mapRes = ch.getRequest().getMappingData();
-        HttpService h = (HttpService) mapRes.getServiceObject();
-        try {
-            h.service(ch.getRequest(), ch.getResponse());
-            if (!ch.getRequest().isAsyncStarted()) {
-                ch.complete();
-                if (recycle) {
-                    ch.release(); // recycle objects.
-                }
-            } else {
-                // Nothing - complete must be called when done.
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-        } catch( Throwable t ) {
-            t.printStackTrace();
-        }
-    }
-
-    @Override
-    public void service(HttpRequest httpReq, HttpResponse httpRes) throws IOException {
-        service(httpReq, httpRes, false, true);
-    }
-
-    /**
-     * Process the request/response in the current thread, without
-     * release ( recycle ) at the end.
-     *
-     * For use by tests and/or in-memory running of servlets.
-     *
-     * If no connection is associated with the request - the
-     * output will remain in the out buffer.
-     */
-    public void run(HttpRequest httpReq, HttpResponse httpRes) throws IOException {
-        service(httpReq, httpRes, true, false);
-    }
-
-
-    public void service(HttpRequest httpReq, HttpResponse httpRes, boolean noThread, boolean recycle)
-            throws IOException {
-        long t0 = System.currentTimeMillis();
-        HttpChannel http = httpReq.getHttpChannel();
-
-        http.setCompletedCallback(doneCallback);
-
-        try {
-          // compute decodedURI - not done by connector
-            MappingData mapRes = httpReq.getMappingData();
-            mapRes.recycle();
-
-            mapper.map(httpReq.serverName(),
-                  httpReq.decodedURI(), mapRes);
-
-          HttpService h = (HttpService) mapRes.getServiceObject();
-
-          if (h != null) {
-              if (debug) {
-                  log.info(">>>>>>>> START: " + http.getRequest().method() + " " +
-                      http.getRequest().decodedURI() + " " +
-                      h.getClass().getSimpleName());
-              }
-
-              if (mapRes.service.selectorThread || noThread) {
-                  runService(http, recycle);
-              } else {
-                  tp.execute(httpReq.getHttpChannel().dispatcherRunnable);
-              }
-
-          } else {
-              httpRes.setStatus(404);
-              http.complete();
-          }
-
-        } catch (IOException ex) {
-            if ("Broken pipe".equals(ex.getMessage())) {
-                log.warning("Connection interrupted while writting");
-            }
-            throw ex;
-        } catch( Throwable t ) {
-            t.printStackTrace();
-            httpRes.setStatus(500);
-            http.abort(t);
-        }
-    }
-
-    private RequestCompleted doneCallback = new RequestCompleted() {
-        @Override
-        public void handle(HttpChannel client, Object extraData) throws IOException {
-            if (debug) {
-                log.info("<<<<<<<< DONE: " + client.getRequest().method() + " " +
-                        client.getRequest().decodedURI() + " " +
-                        client.getResponse().getStatus() + " "
-                        );
-            }
-        }
-    };
-
-    public BaseMapper.Context addContext(String hostname, String ctxPath,
-            Object ctx, String[] welcomeResources, FileConnector resources,
-            HttpService ctxService) {
-        return mapper.addContext(hostname, ctxPath, ctx, welcomeResources, resources,
-                ctxService);
-    }
-
-    public BaseMapper.Context addContext(String ctxPath) {
-        return mapper.addContext(null, ctxPath, null, null, null,
-                null);
-    }
-
-    public void map(CBuffer hostMB, CBuffer urlMB, MappingData md) {
-        try {
-            mapper.map(hostMB, urlMB, md);
-        } catch (Exception e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        }
-    }
-
-    public void map(BaseMapper.Context ctx,
-            CBuffer uri, MappingData md) {
-        try {
-            mapper.internalMapWrapper(ctx, uri, md);
-        } catch (Exception e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        }
-    }
-
-    public void addWrapper(BaseMapper.Context ctx, String path,
-            HttpService service) {
-        mapper.addWrapper(ctx, path, service);
-    }
-
-
-    public void setDefaultService(HttpService service) {
-        BaseMapper.Context mCtx =
-            mapper.addContext(null, "/", null, null, null, null);
-        mapper.addWrapper(mCtx, "/", service);
-    }
-
-
-}
\ No newline at end of file

==================================================
HttpChannel.java
deleted file mode 100644
index 335333b1f0..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/Http11Connection.java
+++ /dev/null
@@ -1,1459 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.lite.http.HttpConnector.HttpConnection;
-import org.apache.tomcat.lite.http.HttpMessage.HttpMessageBytes;
-import org.apache.tomcat.lite.io.BBucket;
-import org.apache.tomcat.lite.io.BBuffer;
-import org.apache.tomcat.lite.io.CBuffer;
-import org.apache.tomcat.lite.io.DumpChannel;
-import org.apache.tomcat.lite.io.FastHttpDateFormat;
-import org.apache.tomcat.lite.io.Hex;
-import org.apache.tomcat.lite.io.IOBuffer;
-import org.apache.tomcat.lite.io.IOChannel;
-import org.apache.tomcat.lite.io.IOConnector;
-
-public class Http11Connection extends HttpConnection
-        implements IOConnector.ConnectedCallback {
-    public static final String CHUNKED = "chunked";
-
-    public static final String CLOSE = "close";
-
-    public static final String KEEPALIVE_S = "keep-alive";
-
-    public static final String CONNECTION = "connection";
-
-    public static final String TRANSFERENCODING = "transfer-encoding";
-
-
-    protected static Logger log = Logger.getLogger("Http11Connection");
-    static final byte COLON = (byte) ':';
-
-    // super.net is the socket
-
-    boolean debug;
-    BBuffer line = BBuffer.wrapper();
-    boolean endSent = false;
-
-    BodyState receiveBodyState = new BodyState();
-    BodyState sendBodyState = new BodyState();
-
-    BBuffer headW = BBuffer.wrapper();
-
-    boolean headersReceived = false;
-    boolean bodyReceived = false;
-
-    /**
-     * Close connection when done writting, no content-length/chunked,
-     * or no keep-alive ( http/1.0 ) or error.
-     *
-     * ServerMode: set if HTTP/0.9 &1.0 || !keep-alive
-     * ClientMode: not currently used
-     */
-    boolean keepAlive = true;
-
-    protected boolean http11 = true;
-    protected boolean http10 = false;
-    protected boolean http09 = false;
-
-    HttpConnection switchedProtocol = null;
-
-    private int requestCount = 0;
-
-    // dataReceived and endSendReceive
-    private Object readLock = new Object();
-
-    public Http11Connection(HttpConnector httpConnector) {
-        this.httpConnector = httpConnector;
-        if (httpConnector != null) {
-            debug = httpConnector.debugHttp;
-        }
-    }
-
-    public void beforeRequest() {
-        nextRequest();
-        headRecvBuf.recycle();
-    }
-
-    public void nextRequest() {
-        endSent = false;
-        keepAlive = true;
-        receiveBodyState.recycle();
-        sendBodyState.recycle();
-        http11 = true;
-        http09 = false;
-        http10 = false;
-        headersReceived = false;
-        bodyReceived = false;
-    }
-
-    public Http11Connection serverMode() {
-        serverMode = true;
-        return this;
-    }
-
-    private boolean readHead() throws IOException {
-        while (true) {
-            int read;
-            if (requestCount == 0 && headRecvBuf.remaining() < 4) {
-                // requests have at least 4 bytes - detect protocol
-                read = net.getIn().read(headRecvBuf, 4);
-                if (read < 0) {
-                    return closeInHead();
-                }
-                if (read < 4) {
-                    return false; // need more
-                }
-                // we have at least 4 bytes
-                if (headRecvBuf.get(0) == 0x80 &&
-                        headRecvBuf.get(1) == 0x01) {
-                    // SPDY signature ( experimental )
-                    switchedProtocol = new SpdyConnection(httpConnector,
-                            remoteHost);
-                    if (serverMode) {
-                        switchedProtocol.serverMode = true;
-                    }
-                    switchedProtocol.withExtraBuffer(headRecvBuf);
-                    // Will also call handleReceived
-                    switchedProtocol.setSink(net);
-                    return false;
-                }
-
-            }
-
-            // we know we have one
-            read = net.getIn().readLine(headRecvBuf);
-            // Remove starting empty lines.
-            headRecvBuf.skipEmptyLines();
-
-            // Do we have another full line in the input ?
-            if (BBuffer.hasLFLF(headRecvBuf)) {
-                break; // done
-            }
-            if (read == 0) { // no more data
-                return false;
-            }
-            if (read < 0) {
-                return closeInHead();
-            }
-        }
-
-
-        return true;
-    }
-
-    private boolean closeInHead() throws IOException {
-        if (debug) {
-            trace("CLOSE while reading HEAD");
-        }
-        // too early - we don't have the head
-        abort("Close in head");
-        return false;
-    }
-
-    // Unit tests use this to access the HttpChannel
-    protected HttpChannel checkHttpChannel() throws IOException {
-        if (switchedProtocol != null) {
-            return switchedProtocol.checkHttpChannel();
-        }
-        if (activeHttp == null) {
-            if (serverMode) {
-                activeHttp = httpConnector.getServer();
-                activeHttp.setConnection(this);
-                if (httpConnector.defaultService != null) {
-                    activeHttp.setHttpService(httpConnector.defaultService);
-                }
-            } else {
-            }
-        }
-        return activeHttp;
-    }
-
-    @Override
-    public void dataReceived(IOBuffer netx) throws IOException {
-        if (switchedProtocol != null) {
-            switchedProtocol.dataReceived(netx);
-            return;
-        }
-        //trace("handleReceived " + headersReceived);
-        if (!checkKeepAliveClient()) {
-            return; // we were in client keep alive mode
-        }
-        // endSendReceived uses same lock - it will call this
-        // to check outstanding bytes
-        synchronized (readLock) {
-            if (bodyReceived) {
-                return; // leave data in net buffer, for next req
-            }
-
-            if (!headersReceived) {
-                if (!readHead()) {
-                    return;
-                }
-            }
-
-            // We have a header
-            if (activeHttp == null) {
-                if (checkHttpChannel() == null) {
-                    return;
-                }
-            }
-
-            IOBuffer receiveBody = activeHttp.receiveBody;
-
-            if (!headersReceived) {
-                headRecvBuf.wrapTo(headW);
-                parseMessage(activeHttp, headW);
-                // Part of parseMessage we can switch the protocol
-                if (switchedProtocol != null) {
-                    return;
-                }
-
-                if (serverMode && activeHttp.httpReq.decodedUri.remaining() == 0) {
-                    abort(activeHttp, "Invalid url");
-                }
-
-                headersReceived = true;
-                // Send header callbacks - we process any incoming data
-                // first, so callbacks have more info
-                trace("Send headers received callback " + activeHttp.httpService);
-                activeHttp.handleHeadersReceived(activeHttp.inMessage);
-            }
-
-            // any remaining data will be processed as part of the
-            // body - or left in the channel until endSendReceive()
-
-            if (!bodyReceived) {
-                // Will close receiveBody when it consummed enough
-                rawDataReceived(activeHttp, receiveBody, net.getIn());
-                // Did we process anything ?
-                if (receiveBody.getBufferCount() > 0) {
-                    activeHttp.sendHandleReceivedCallback(); // callback
-                }
-            }
-            // Receive has marked the body as closed
-            if (receiveBody.isAppendClosed()) {
-                bodyReceived = true;
-                activeHttp.handleEndReceive();
-            }
-
-
-            if (net.getIn().isClosedAndEmpty()) {
-                // If not already closed.
-                closeStreamOnEnd("closed after body");
-            }
-
-        }
-    }
-
-    /**
-     * We got data while in client keep alive ( no activeHttp )
-     *
-     * @return false if there is an error
-     */
-    private boolean checkKeepAliveClient() throws IOException {
-        // Client, no active connection ( keep alive )
-        if (!serverMode && activeHttp == null) {
-            if (net.getIn().isClosedAndEmpty() || !net.isOpen()) {
-                // server disconnected, fine
-                httpConnector.cpool.stopKeepAlive(this);
-                return false;
-            }
-            if (net.getIn().available() == 0) {
-                return true;
-            }
-            log.warning("Unexpected message from server in client keep alive "
-                    + net.getIn() + ": " + net.getIn().readAll(null));
-            if (net.isOpen()) {
-                net.close();
-            }
-            return false;
-        }
-        return true;
-    }
-
-    private void processProtocol(CBuffer protocolMB) throws IOException {
-        http11 = false;
-        http09 = false;
-        http10 = false;
-
-        if (protocolMB.equals(HttpChannel.HTTP_11)) {
-            http11 = true;
-        } else if (protocolMB.equals(HttpChannel.HTTP_10)) {
-            http10 = true;
-        } else if (protocolMB.equals("")) {
-            http09 = true;
-        } else {
-            http11 = true; // hopefully will be backward compat
-        }
-    }
-
-    void closeStreamOnEnd(String cause) {
-        if (debug) {
-            log.info("Not reusing connection because: " + cause);
-        }
-        keepAlive = false;
-    }
-
-    boolean keepAlive() {
-        if (httpConnector != null) {
-            if (serverMode && !httpConnector.serverKeepAlive) {
-                keepAlive = false;
-            }
-            if (!serverMode && !httpConnector.clientKeepAlive) {
-                keepAlive = false;
-            }
-        }
-        if (http09) {
-            keepAlive = false;
-        }
-        if (net != null && !net.isOpen()) {
-            keepAlive = false;
-        }
-        return keepAlive;
-    }
-
-    @Override
-    protected void endSendReceive(HttpChannel http) throws IOException {
-        if (switchedProtocol != null) {
-            switchedProtocol.endSendReceive(http);
-            return;
-        }
-        chunk.recycle();
-        rchunk.recycle();
-        boolean keepAlive = keepAlive();
-        if (!keepAlive) {
-            if (debug) {
-                log.info("--- Close socket, no keepalive " + net);
-            }
-            if (net != null) {
-                net.close();
-                net.startSending();
-
-            }
-        }
-
-        requestCount++;
-        beforeRequest();
-        httpConnector.cpool.afterRequest(http, this, true);
-
-        if (serverMode && keepAlive) {
-            handleReceived(net); // will attempt to read next req
-        }
-    }
-
-    private void trace(String s) {
-        if(debug) {
-            log.info(this.toString() + " " + activeHttp + " " + s);
-        }
-    }
-
-    private boolean isDone(BodyState bodys, IOBuffer body) {
-        if (bodys.noBody) {
-            return true;
-        }
-        if (bodys.isContentDelimited()) {
-            if (!bodys.chunked && bodys.remaining == 0) {
-                return true;
-            } else if (bodys.chunked && body.isAppendClosed()) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    void parseMessage(HttpChannel http, BBuffer headB) throws IOException {
-        //Parse the response
-        line.recycle();
-        headB.readLine(line);
-
-        HttpMessageBytes msgBytes;
-
-        if (serverMode) {
-            msgBytes = http.httpReq.getMsgBytes();
-            parseRequestLine(line, msgBytes.method(),
-                    msgBytes.url(),
-                    msgBytes.query(),
-                    msgBytes.protocol());
-        } else {
-            msgBytes = http.httpRes.getMsgBytes();
-            parseResponseLine(line, msgBytes.protocol(),
-                    msgBytes.status(), msgBytes.message());
-        }
-
-        parseHeaders(http, msgBytes, headB);
-
-        http.inMessage.state = HttpMessage.State.BODY_DATA;
-
-        http.inMessage.processReceivedHeaders();
-
-        // TODO: hook to allow specific charsets ( can be done later )
-        processProtocol(http.inMessage.protocol());
-
-        if (serverMode) {
-            // requested connection:close/keepAlive and proto
-            updateKeepAlive(http.getRequest().getMimeHeaders(), true);
-
-            processExpectation(http);
-
-            processContentDelimitation(receiveBodyState, http.getRequest());
-            // Spec:
-            // The presence of a message-body in a request is signaled by the
-            // inclusion of a Content-Length or Transfer-Encoding header field in
-            // the request's message-headers
-            // Server should read - but ignore ..
-            receiveBodyState.noBody = !receiveBodyState.isContentDelimited();
-
-            updateCloseOnEnd(receiveBodyState, http, http.receiveBody);
-
-            /*
-             * The presence of a message-body in a request is signaled by the
-             * inclusion of a Content-Length or Transfer-Encoding header field in
-             * the request's message-headers. A message-body MUST NOT be included
-             * in a request if the specification of the request method
-             * (section 5.1.1) does not allow sending an entity-body in requests.
-             * A server SHOULD read and forward a message-body on any request; if the request method does not include defined semantics for an entity-body, then the message-body SHOULD be ignored when handling the request.
-             */
-            if (!receiveBodyState.isContentDelimited()) {
-                // No body
-                http.getIn().close();
-            }
-
-        } else {
-            receiveBodyState.noBody = !http.getResponse().hasBody();
-
-            updateKeepAlive(http.getResponse().getMimeHeaders(), false);
-
-            if (statusDropsConnection(http.getResponse().getStatus())) {
-                closeStreamOnEnd("response status drops connection");
-            }
-            IOBuffer body = http.receiveBody;
-            processContentDelimitation(receiveBodyState, http.getResponse());
-
-            if (isDone(receiveBodyState, body)) {
-                body.close();
-            }
-
-            if (!receiveBodyState.isContentDelimited()) {
-                closeStreamOnEnd("not content delimited");
-            }
-        }
-
-    }
-
-    private void processExpectation(HttpChannel http) throws IOException {
-        http.expectation = false;
-        MultiMap headers = http.getRequest().getMimeHeaders();
-
-        CBuffer expect = headers.getHeader("expect");
-        if ((expect != null)
-                && (expect.indexOf("100-continue") != -1)) {
-            http.expectation = true;
-
-            // TODO: configure, use the callback or the servlet 'read'.
-            net.getOut().append("HTTP/1.1 100 Continue\r\n\r\n");
-            net.startSending();
-        }
-    }
-
-
-    /**
-     * Updates chunked, contentLength, remaining - based
-     * on headers
-     */
-    private void processContentDelimitation(BodyState bodys,
-            HttpMessage httpMsg) {
-
-        bodys.contentLength = httpMsg.getContentLength();
-        if (bodys.contentLength >= 0) {
-            bodys.remaining = bodys.contentLength;
-        }
-
-        // TODO: multiple transfer encoding headers, only process the last
-        String transferEncodingValue = httpMsg.getHeader(TRANSFERENCODING);
-        if (transferEncodingValue != null) {
-            int startPos = 0;
-            int commaPos = transferEncodingValue.indexOf(',');
-            String encodingName = null;
-            while (commaPos != -1) {
-                encodingName = transferEncodingValue.substring
-                (startPos, commaPos).toLowerCase().trim();
-                if ("chunked".equalsIgnoreCase(encodingName)) {
-                    bodys.chunked = true;
-                }
-                startPos = commaPos + 1;
-                commaPos = transferEncodingValue.indexOf(',', startPos);
-            }
-            encodingName = transferEncodingValue.substring(startPos)
-                .toLowerCase().trim();
-            if ("chunked".equals(encodingName)) {
-                bodys.chunked = true;
-                httpMsg.chunked = true;
-            } else {
-                System.err.println("TODO: ABORT 501");
-                //return 501; // Currently only chunked is supported for
-                // transfer encoding.
-            }
-        }
-
-        if (bodys.chunked) {
-            bodys.remaining = 0;
-        }
-    }
-
-    /**
-     * Read the request line. This function is meant to be used during the
-     * HTTP request header parsing. Do NOT attempt to read the request body
-     * using it.
-     *
-     * @throws IOException If an exception occurs during the underlying socket
-     * read operations, or if the given buffer is not big enough to accomodate
-     * the whole line.
-     */
-    boolean parseRequestLine(BBuffer line,
-            BBuffer methodMB, BBuffer requestURIMB,
-            BBuffer queryMB,
-            BBuffer protoMB)
-        throws IOException {
-
-        line.readToSpace(methodMB);
-        line.skipSpace();
-
-        line.readToDelimOrSpace(HttpChannel.QUESTION, requestURIMB);
-        if (line.remaining() > 0 && line.get(0) == HttpChannel.QUESTION) {
-            // Has query
-            line.readToSpace(queryMB);
-            // don't include '?'
-            queryMB.position(queryMB.position() + 1);
-        } else {
-            queryMB.setBytes(line.array(), line.position(), 0);
-        }
-        line.skipSpace();
-
-        line.readToSpace(protoMB);
-
-        // proto is optional ( for 0.9 )
-        return requestURIMB.remaining() > 0;
-    }
-
-    boolean parseResponseLine(BBuffer line,
-            BBuffer protoMB, BBuffer statusCode, BBuffer status)
-            throws IOException {
-        line.skipEmptyLines();
-
-        line.readToSpace(protoMB);
-        line.skipSpace();
-        line.readToSpace(statusCode);
-        line.skipSpace();
-        line.wrapTo(status);
-
-        // message may be empty
-        return statusCode.remaining() > 0;
-    }
-
-    List<String> connectionHeaders = new ArrayList<String>();
-
-    private void parseHeaders(HttpChannel http, HttpMessageBytes msgBytes,
-            BBuffer head)
-                throws IOException {
-
-        head.readLine(line);
-
-        int idx = 0;
-
-        BBuffer upgrade = null;
-
-        while(line.remaining() > 0) {
-            // not empty..
-            idx = msgBytes.addHeader();
-            BBuffer nameBuf = msgBytes.getHeaderName(idx);
-            BBuffer valBuf = msgBytes.getHeaderValue(idx);
-            parseHeader(http, head, line, nameBuf, valBuf);
-
-            // TODO: process 'interesting' headers here.
-            if (nameBuf.equalsIgnoreCase("connection")) {
-                // TODO: save and remove if not recognized
-            }
-            if (nameBuf.equalsIgnoreCase("upgrade")) {
-                upgrade = valBuf;
-            }
-        }
-
-        if (upgrade != null) {
-            if (upgrade.equalsIgnoreCase("WebSocket")) {
-
-            } else if (upgrade.equalsIgnoreCase("SPDY/1.0")) {
-
-            }
-        }
-
-        // TODO: process connection headers
-    }
-
-    /**
-     * Parse one header.
-     * Line must be populated. On return line will be populated
-     * with the next header:
-     *
-     * @param line current header line, not empty.
-     */
-    int parseHeader(HttpChannel http, BBuffer head,
-            BBuffer line, BBuffer name, BBuffer value)
-          throws IOException {
-
-        int newPos = line.readToDelimOrSpace(COLON, name);
-        line.skipSpace();
-        if (line.readByte() != COLON) {
-            throw new IOException("Missing ':' in header name " + line);
-        }
-        line.skipSpace();
-        line.read(value); // remaining of the line
-
-        while (true) {
-            head.readLine(line);
-            if (line.remaining() == 0) {
-                break;
-            }
-            int first = line.get(0);
-            if (first != BBuffer.SP && first != BBuffer.HT) {
-                break;
-            }
-            // continuation line - append it to value
-            value.setEnd(line.getEnd());
-            line.position(line.limit());
-        }
-
-        // We may want to keep the original and use separate buffer ?
-        http.normalizeHeader(value);
-        return 1;
-    }
-
-    private int receiveDone(HttpChannel http, IOBuffer body, boolean frameError) throws IOException {
-        // Content-length case, we're done reading
-        body.close();
-
-        http.error = frameError;
-        if (frameError) {
-            closeStreamOnEnd("frame error");
-        }
-
-        return DONE;
-    }
-
-    /**
-     * Called when raw body data is received.
-     * Callback should not consume past the end of the body.
-     * @param rawReceiveBuffers
-     *
-     */
-    private void rawDataReceived(HttpChannel http, IOBuffer body,
-            IOBuffer rawReceiveBuffers) throws IOException {
-        // TODO: Make sure we don't process more than we need ( eat next req ).
-        // If we read too much: leave it in readBuf, the finalzation code
-        // should skip KeepAlive and start processing it.
-        // we need to read at least something - to detect -1 ( we could
-        // suspend right away, but seems safer
-        BodyState bodys = receiveBodyState;
-
-        while (http.inMessage.state == HttpMessage.State.BODY_DATA) {
-            if (receiveBodyState.noBody) {
-                receiveDone(http, body, false);
-                return;
-            }
-            if (rawReceiveBuffers.isClosedAndEmpty()) {
-                if (receiveBodyState.isContentDelimited()) {
-                    if (receiveBodyState.contentLength >= 0 && receiveBodyState.remaining == 0) {
-                        receiveDone(http, body, false);
-                    } else {
-                        // End of input - other side closed, no more data
-                        //log.info("CLOSE while reading " + this);
-                        // they're not supposed to close !
-                        receiveDone(http, body, true);
-                    }
-                } else {
-                    receiveDone(http, body, false); // ok
-                }
-                // input connection closed ?
-                closeStreamOnEnd("Closed input");
-                return;
-            }
-            BBucket rawBuf = rawReceiveBuffers.peekFirst();
-            if (rawBuf == null) {
-                return;  // need more data
-            }
-
-            if (!bodys.isContentDelimited()) {
-                while (true) {
-                    BBucket first = rawReceiveBuffers.popFirst();
-                    if (first == null) {
-                        break; // will go back to check if done.
-                    } else {
-                        received(body, first);
-                    }
-                }
-            } else {
-
-                if (bodys.contentLength >= 0 && bodys.remaining == 0) {
-                    receiveDone(http, body, false);
-                    return;
-                }
-
-                if (bodys.chunked && bodys.remaining == 0) {
-                    int rc = NEED_MORE;
-                    // TODO: simplify, use readLine()
-                    while (rc == NEED_MORE) {
-                        rc = rchunk.parseChunkHeader(rawReceiveBuffers);
-                        if (rc == ERROR) {
-                            http.abort("Chunk error");
-                            receiveDone(http, body, true);
-                            return;
-                        } else if (rc == NEED_MORE) {
-                            return;
-                        }
-                    }
-                    if (rc == 0) { // last chunk
-                        receiveDone(http, body, false);
-                        return;
-                    } else {
-                        bodys.remaining = rc;
-                    }
-                }
-
-                rawBuf = (BBucket) rawReceiveBuffers.peekFirst();
-                if (rawBuf == null) {
-                    return;  // need more data
-                }
-
-
-                if (bodys.remaining < rawBuf.remaining()) {
-                    // To buffer has more data than we need.
-                    int lenToConsume = (int) bodys.remaining;
-                    BBucket sb = rawReceiveBuffers.popLen(lenToConsume);
-                    received(body, sb);
-                    //log.info("Queue received buffer " + this + " " + lenToConsume);
-                    bodys.remaining = 0;
-                } else {
-                    BBucket first = rawReceiveBuffers.popFirst();
-                    bodys.remaining -= first.remaining();
-                    received(body, first);
-                    //log.info("Queue full received buffer " + this + " RAW: " + rawReceiveBuffers);
-                }
-                if (bodys.contentLength >= 0 && bodys.remaining == 0) {
-                    // Content-Length, all done
-                    body.close();
-                    receiveDone(http, body, false);
-                }
-            }
-        }
-    }
-
-    private void received(IOBuffer body, BBucket bb) throws IOException {
-        body.queue(bb);
-    }
-
-
-    protected void sendRequest(HttpChannel http)
-            throws IOException {
-        if (switchedProtocol != null) {
-            switchedProtocol.sendRequest(http);
-            return;
-        }
-
-        // Update transfer fields based on headers.
-        processProtocol(http.getRequest().protocol());
-        updateKeepAlive(http.getRequest().getMimeHeaders(), true);
-
-        // Update Host header
-        if (http.getRequest().getMimeHeaders().getHeader("Host") == null) {
-            String target = http.getTarget();
-            if (target == null) {
-                throw new IOException("Missing host header");
-            }
-            CBuffer hostH = http.getRequest().getMimeHeaders().addValue("Host");
-            if (target.endsWith(":80")) {
-                hostH.set(target.substring(0, target.length() - 3));
-            } else {
-                hostH.set(target);
-            }
-        }
-
-        processContentDelimitation(sendBodyState,
-                http.getRequest());
-
-
-        CBuffer method = http.getRequest().method();
-        if (method.equals("GET") || method.equals("HEAD")) {
-            // TODO: add the others
-            sendBodyState.noBody = true;
-        }
-
-        // 1.0: The presence of an entity body in a request is signaled by
-        // the inclusion of a Content-Length header field in the request
-        // message headers. HTTP/1.0 requests containing an entity body
-        // must include a valid Content-Length header field.
-        if (http10 && !sendBodyState.isContentDelimited()) {
-            // Will not close connection - just flush and mark the body
-            // as sent
-            sendBodyState.noBody = true;
-        }
-
-        if (sendBodyState.noBody) {
-            http.getRequest().getMimeHeaders().remove(HttpChannel.CONTENT_LENGTH);
-            http.getRequest().getMimeHeaders().remove(TRANSFERENCODING);
-            http.getOut().close();
-        } else {
-            long contentLength =
-                http.getRequest().getContentLength();
-            if (contentLength < 0) {
-                http.getRequest().getMimeHeaders().addValue("Transfer-Encoding").
-                    set(CHUNKED);
-            }
-        }
-
-        updateCloseOnEnd(sendBodyState, http, http.sendBody);
-
-        try {
-            serialize(http.getRequest(), net.getOut());
-            if (http.debug) {
-                http.trace("S: \n" + net.getOut());
-            }
-
-            if (http.outMessage.state == HttpMessage.State.HEAD) {
-                http.outMessage.state = HttpMessage.State.BODY_DATA;
-            }
-
-
-            // TODO: add any body and flush. More body can be added later -
-            // including 'end'.
-
-            http.startSending();
-        } catch (Throwable t) {
-            log.log(Level.SEVERE, "Error sending request", t);
-            abort(t.getMessage());
-        }
-
-    }
-
-
-    /**
-     * Determine if we must drop the connection because of the HTTP status
-     * code.  Use the same list of codes as Apache/httpd.
-     */
-    private boolean statusDropsConnection(int status) {
-        return status == 400 /* SC_BAD_REQUEST */ ||
-        status == 408 /* SC_REQUEST_TIMEOUT */ ||
-        status == 411 /* SC_LENGTH_REQUIRED */ ||
-        status == 413 /* SC_REQUEST_ENTITY_TOO_LARGE */ ||
-        status == 414 /* SC_REQUEST_URI_TOO_LARGE */ ||
-        status == 500 /* SC_INTERNAL_SERVER_ERROR */ ||
-        status == 503 /* SC_SERVICE_UNAVAILABLE */ ||
-        status == 501 /* SC_NOT_IMPLEMENTED */;
-    }
-
-    protected void sendResponseHeaders(HttpChannel http)
-            throws IOException {
-        if (switchedProtocol != null) {
-            switchedProtocol.sendResponseHeaders(http);
-            return;
-        }
-
-        if (!serverMode) {
-            throw new IOException("Only in server mode");
-        }
-        endSent = false;
-        IOBuffer sendBody = http.sendBody;
-        HttpResponse res = http.getResponse();
-        if (res.isCommitted()) {
-            return;
-        }
-        res.setCommitted(true);
-
-        sendBodyState.noBody = !res.hasBody();
-
-        if (statusDropsConnection(res.getStatus())) {
-            closeStreamOnEnd("status drops connection");
-        }
-        if (http.error) {
-            closeStreamOnEnd("error");
-        }
-
-        MultiMap headers = res.getMimeHeaders();
-
-        // Add date header
-        if (headers.getHeader("Date") == null) {
-            headers.setValue("Date").set(FastHttpDateFormat.getCurrentDate());
-        }
-
-        // Add server header
-        if (http.serverHeader.length() > 0) {
-            headers.setValue("Server").set(http.serverHeader);
-        }
-
-        // Decide on a transfer encoding for out.
-        if (keepAlive()) { // request and user allows keep alive
-            int cl = res.getContentLength();
-
-            if (http10) {
-                if (cl < 0 && !sendBodyState.noBody &&
-                        sendBody.isAppendClosed()) {
-                    // We can generate content-lenght
-                    cl = sendBody.available();
-                    res.setContentLength(cl);
-                }
-                if (cl < 0 && !sendBodyState.noBody) {
-                    closeStreamOnEnd("HTTP/1.0 without content length");
-                } else {
-                    headers.setValue(CONNECTION).set(KEEPALIVE_S);
-                }
-            } else { // http11
-                if (!sendBodyState.noBody) {
-                    if (cl < 0) {
-                        res.getMimeHeaders().setValue(TRANSFERENCODING).set(CHUNKED);
-                    }
-                }
-            }
-        } else {
-            headers.setValue(CONNECTION).set(CLOSE);
-            // since we close the connection - don't bother with
-            // transfer encoding
-            headers.remove(TRANSFERENCODING);
-        }
-
-        // Update our internal state based on headers we just set.
-        processContentDelimitation(sendBodyState, res);
-        updateCloseOnEnd(sendBodyState, http, sendBody);
-
-
-        if (http.debug) {
-            http.trace("Send response headers " + net);
-        }
-        if (net != null) {
-            serialize(res, net.getOut());
-        }
-
-        if (http.outMessage.state == HttpMessage.State.HEAD) {
-            http.outMessage.state = HttpMessage.State.BODY_DATA;
-        }
-
-        if (isDone(sendBodyState, sendBody)) {
-            http.getOut().close();
-        }
-
-        if (net != null) {
-            net.startSending();
-        }
-    }
-
-    private void abort(String t) throws IOException {
-        abort(activeHttp, t);
-    }
-
-    private void updateCloseOnEnd(BodyState bodys, HttpChannel http, IOBuffer body) {
-        if (!bodys.isContentDelimited() && !bodys.noBody) {
-            closeStreamOnEnd("not content delimited");
-        }
-    }
-
-    /**
-     * Disconnect abruptly - client closed, frame errors, etc
-     * @param t
-     * @throws IOException
-     */
-    public void abort(HttpChannel http, String t) throws IOException {
-        if (switchedProtocol != null) {
-            switchedProtocol.abort(http, t);
-            return;
-        }
-        keepAlive = false;
-        if (net != null ) {
-            if (net.isOpen()) {
-                net.close();
-                net.startSending();
-            }
-        }
-        if (http != null) {
-            http.abort(t);
-        }
-    }
-
-    /**
-     * Update keepAlive based on Connection header and protocol.
-     */
-    private void updateKeepAlive(MultiMap headers, boolean request) {
-        if (http09) {
-            closeStreamOnEnd("http 0.9");
-            return;
-        }
-
-        // TODO: also need to remove headers matching connection
-        // ( like 'upgrade')
-
-        CBuffer value = headers.getHeader(CONNECTION);
-        // TODO: split it by space
-        if (value != null) {
-            value.toLower();
-            if (value.indexOf(CLOSE) >= 0) {
-                // 1.1 ( but we accept it for 1.0 too )
-                closeStreamOnEnd("connection close");
-            }
-            if (http10 && value.indexOf(KEEPALIVE_S) < 0) {
-                // Keep-Alive required for http/1.0
-                closeStreamOnEnd("connection != keep alive");
-            }
-            // we have connection: keepalive, good
-        } else {
-            // no connection header - for 1.1 default is keepAlive,
-            // for 10 it's close
-            if (http10) {
-                closeStreamOnEnd("http1.0 no connection header");
-            }
-        }
-    }
-
-    @Override
-    public void startSending() throws IOException {
-        if (switchedProtocol != null) {
-            switchedProtocol.startSending();
-            return;
-        }
-
-    }
-
-    @Override
-    public void startSending(HttpChannel http) throws IOException {
-        if (switchedProtocol != null) {
-            switchedProtocol.startSending(http);
-            return;
-        }
-        http.send(); // if needed
-
-        if (net == null) {
-            return; // not connected yet.
-        }
-
-        if (net.getOut().isAppendClosed()) {
-            abort("Net closed");
-        } else {
-            flushToNext(http.sendBody, net.getOut());
-            net.startSending();
-        }
-
-    }
-
-    protected void outClosed(HttpChannel http) throws IOException {
-        if (switchedProtocol != null) {
-            switchedProtocol.outClosed(http);
-            return;
-        }
-        // TODO: move it ?
-        if (sendBodyState.isContentDelimited() && !http.error) {
-            if (!sendBodyState.chunked &&
-                    sendBodyState.remaining - http.getOut().available() > 0) {
-                http.abort("CLOSE CALLED WITHOUT FULL LEN");
-            }
-        }
-
-    }
-
-    @Override
-    public void handleFlushed(IOChannel net) throws IOException {
-        if (switchedProtocol != null) {
-            switchedProtocol.handleFlushed(net);
-            return;
-        }
-        if (activeHttp != null) {
-            activeHttp.flushLock.signal(this);
-            activeHttp.handleFlushed(this);
-            if (activeHttp.sendBody.isClosedAndEmpty()) {
-                activeHttp.handleEndSent();
-            }
-        }
-    }
-
-
-    private void flushToNext(IOBuffer body, IOBuffer out) throws IOException {
-
-        synchronized (this) {
-            // TODO: better head support
-            if (sendBodyState.noBody) {
-                for (int i = 0; i < body.getBufferCount(); i++) {
-                    Object bc = body.peekBucket(i);
-                    if (bc instanceof BBucket) {
-                        ((BBucket) bc).release();
-                    }
-                }
-                body.clear();
-                return;
-            }
-
-            // TODO: only send < remainingWrite, if buffer
-            // keeps changing after startWrite() is called (shouldn't)
-
-            if (sendBodyState.chunked) {
-                sendChunked(sendBodyState, body, out);
-            } else if (sendBodyState.contentLength >= 0) {
-                // content-length based
-                sendContentLen(sendBodyState, body, out);
-            } else {
-                sendCloseDelimited(body, out);
-            }
-        }
-    }
-
-    private void sendCloseDelimited(IOBuffer body, IOBuffer out) throws IOException {
-        // Close delimitation
-        while (true) {
-            Object bc = body.popFirst();
-            if (bc == null) {
-                break;
-            }
-            out.queue(bc);
-        }
-        if (body.isClosedAndEmpty()) {
-            out.close(); // no content-delimitation
-        }
-    }
-
-    /**
-     * Convert the request to bytes, ready to send.
-     */
-    public static void serialize(HttpRequest req, IOBuffer rawSendBuffers2) throws IOException {
-        rawSendBuffers2.append(req.method());
-        rawSendBuffers2.append(BBuffer.SP);
-
-        // TODO: encode or use decoded
-        rawSendBuffers2.append(req.requestURI());
-        if (req.queryString().length() > 0) {
-            rawSendBuffers2.append("?");
-            rawSendBuffers2.append(req.queryString());
-        }
-
-        rawSendBuffers2.append(BBuffer.SP);
-        rawSendBuffers2.append(req.protocol());
-        rawSendBuffers2.append(BBuffer.CRLF_BYTES);
-
-        serializeHeaders(req.getMimeHeaders(), rawSendBuffers2);
-    }
-
-    /**
-     * Convert the response to bytes, ready to send.
-     */
-    public static void serialize(HttpResponse res, IOBuffer rawSendBuffers2) throws IOException {
-
-        rawSendBuffers2.append(res.protocol()).append(' ');
-        String status = Integer.toString(res.getStatus());
-        rawSendBuffers2.append(status).append(' ');
-        if (res.getMessageBuffer().length() > 0) {
-            rawSendBuffers2.append(res.getMessage());
-        } else {
-            rawSendBuffers2
-                .append(res.getMessage(res.getStatus()));
-        }
-        rawSendBuffers2.append(BBuffer.CRLF_BYTES);
-        // Headers
-        serializeHeaders(res.getMimeHeaders(), rawSendBuffers2);
-    }
-
-    public static void serializeHeaders(MultiMap mimeHeaders, IOBuffer rawSendBuffers2) throws IOException {
-        for (int i = 0; i < mimeHeaders.size(); i++) {
-            CBuffer name = mimeHeaders.getName(i);
-            CBuffer value = mimeHeaders.getValue(i);
-            if (name.length() == 0 || value.length() == 0) {
-                continue;
-            }
-            rawSendBuffers2.append(name);
-            rawSendBuffers2.append(Http11Connection.COLON);
-            rawSendBuffers2.append(value);
-            rawSendBuffers2.append(BBuffer.CRLF_BYTES);
-        }
-        rawSendBuffers2.append(BBuffer.CRLF_BYTES);
-    }
-
-
-    private boolean sendContentLen(BodyState bodys, IOBuffer body, IOBuffer out) throws IOException {
-        while (true) {
-            BBucket bucket = body.peekFirst();
-            if (bucket == null) {
-                break;
-            }
-            int len = bucket.remaining();
-            if (len <= bodys.remaining) {
-                bodys.remaining -= len;
-                bucket = body.popFirst();
-                out.queue(bucket);
-            } else {
-                // Write over the end of the buffer !
-                log.severe("write more than Content-Length");
-                len = (int) bodys.remaining;
-                // data between position and limit
-                bucket = body.popLen((int) bodys.remaining);
-                out.queue(bucket);
-                while (bucket != null) {
-                    bucket = body.popFirst();
-                    if (bucket != null) {
-                        bucket.release();
-                    }
-                }
-
-                // forced close
-                //close();
-                bodys.remaining = 0;
-                return true;
-            }
-        }
-        if (body.isClosedAndEmpty()) {
-            //http.rawSendBuffers.queue(IOBrigade.MARK);
-            if (bodys.remaining > 0) {
-                closeStreamOnEnd("sent more than content-length");
-                log.severe("Content-Length > body");
-            }
-            return true;
-        }
-        return false;
-    }
-
-    private boolean sendChunked(BodyState bodys, IOBuffer body, IOBuffer out) throws IOException {
-        int len = body.available();
-
-        if (len > 0) {
-            ByteBuffer sendChunkBuffer = chunk.prepareChunkHeader(len);
-            bodys.remaining = len;
-            out.queue(sendChunkBuffer);
-            while (bodys.remaining > 0) {
-                BBucket bc = body.popFirst();
-                bodys.remaining -= bc.remaining();
-                out.queue(bc);
-            }
-        }
-
-        if (body.isClosedAndEmpty()) {
-            synchronized(this) {
-                if (!endSent) {
-                    out.append(chunk.endChunk());
-                    endSent = true;
-                }
-            }
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    // used for chunk parsing/end
-    ChunkState chunk = new ChunkState();
-    ChunkState rchunk = new ChunkState();
-    static final int NEED_MORE = -1;
-    static final int ERROR = -4;
-    static final int DONE = -5;
-
-
-    static class ChunkState {
-        static byte[] END_CHUNK_BYTES = {
-            (byte) '\r', (byte) '\n',
-            (byte) '0',
-            (byte) '\r', (byte) '\n',
-            (byte) '\r', (byte) '\n'};
-
-
-        int partialChunkLen;
-        boolean readDigit = false;
-        boolean trailer = false;
-        protected boolean needChunkCrlf = false;
-
-        // Buffer used for chunk length conversion.
-        protected byte[] sendChunkLength = new byte[10];
-
-        /** End chunk marker - will include chunked end or empty */
-        protected BBuffer endSendBuffer = BBuffer.wrapper();
-
-        public ChunkState() {
-            sendChunkLength[8] = (byte) '\r';
-            sendChunkLength[9] = (byte) '\n';
-        }
-
-        void recycle() {
-            partialChunkLen = 0;
-            readDigit = false;
-            trailer = false;
-            needChunkCrlf = false;
-            endSendBuffer.recycle();
-        }
-
-        /**
-         * Parse the header of a chunk.
-         * A chunk header can look like
-         * A10CRLF
-         * F23;chunk-extension to be ignoredCRLF
-         * The letters before CRLF but after the trailer mark, must be valid hex digits,
-         * we should not parse F23IAMGONNAMESSTHISUP34CRLF as a valid header
-         * according to spec
-         */
-        int parseChunkHeader(IOBuffer buffer) throws IOException {
-            if (buffer.peekFirst() == null) {
-                return NEED_MORE;
-            }
-            if (needChunkCrlf) {
-                // TODO: Trailing headers
-                int c = buffer.read();
-                if (c == BBuffer.CR) {
-                    if (buffer.peekFirst() == null) {
-                        return NEED_MORE;
-                    }
-                    c = buffer.read();
-                }
-                if (c == BBuffer.LF) {
-                    needChunkCrlf = false;
-                } else {
-                    System.err.println("Bad CRLF " + c);
-                    return ERROR;
-                }
-            }
-
-            while (true) {
-                if (buffer.peekFirst() == null) {
-                    return NEED_MORE;
-                }
-                int c = buffer.read();
-
-                if (c == BBuffer.CR) {
-                    continue;
-                } else if (c == BBuffer.LF) {
-                    break;
-                } else if (c == HttpChannel.SEMI_COLON) {
-                    trailer = true;
-                } else if (c == BBuffer.SP) {
-                    // ignore
-                } else if (trailer) {
-                    // ignore
-                } else {
-                    //don't read data after the trailer
-                    if (Hex.DEC[c] != -1) {
-                        readDigit = true;
-                        partialChunkLen *= 16;
-                        partialChunkLen += Hex.DEC[c];
-                    } else {
-                        //we shouldn't allow invalid, non hex characters
-                        //in the chunked header
-                        log.info("Chunk parsing error1 " + c + " " + buffer);
-                        //http.abort("Chunk error");
-                        return ERROR;
-                    }
-                }
-            }
-
-            if (!readDigit) {
-                log.info("Chunk parsing error2 " + buffer);
-                return ERROR;
-            }
-
-            needChunkCrlf = true;  // next time I need to parse CRLF
-            int result = partialChunkLen;
-            partialChunkLen = 0;
-            trailer = false;
-            readDigit = false;
-            return result;
-        }
-
-
-        ByteBuffer prepareChunkHeader(int current) {
-            int pos = 7; // 8, 9 are CRLF
-            while (current > 0) {
-                int digit = current % 16;
-                current = current / 16;
-                sendChunkLength[pos--] = Hex.HEX[digit];
-            }
-            if (needChunkCrlf) {
-                sendChunkLength[pos--] = (byte) '\n';
-                sendChunkLength[pos--] = (byte) '\r';
-            } else {
-                needChunkCrlf = true;
-            }
-            // TODO: pool - this may stay in the queue while we flush more
-            ByteBuffer chunkBB = ByteBuffer.allocate(16);
-            chunkBB.put(sendChunkLength, pos + 1, 9 - pos);
-            chunkBB.flip();
-            return chunkBB;
-        }
-
-        public BBuffer endChunk() {
-            if (! needChunkCrlf) {
-                endSendBuffer.setBytes(END_CHUNK_BYTES, 2,
-                        END_CHUNK_BYTES.length - 2); // CRLF
-            } else { // 0
-                endSendBuffer.setBytes(END_CHUNK_BYTES, 0,
-                        END_CHUNK_BYTES.length);
-            }
-            return endSendBuffer;
-        }
-    }
-
-    static class BodyState {
-        /** response: HEAD or  1xx, 204, 304 status
-         *  req: missing content-length or transfer-encoding
-         */
-        protected boolean noBody = false;
-        protected boolean chunked = false;
-        protected long contentLength = -1; // C-L header
-        /** Bytes remaining in the current chunk or body ( if CL ) */
-        protected long remaining = 0; // both chunked and C-L
-
-        public void recycle() {
-            chunked = false;
-            remaining = 0;
-            contentLength = -1;
-            noBody = false;
-        }
-        public boolean isContentDelimited() {
-            return chunked || contentLength >= 0;
-        }
-
-    }
-
-    public String toString() {
-        if (switchedProtocol != null) {
-            return switchedProtocol.toString();
-        }
-
-        return (serverMode ? "SR " : "CL ") +
-        (keepAlive() ? " KA " : "") +
-        (headersReceived ? " HEAD " : "") +
-        (bodyReceived ? " BODY " : "")
-        ;
-    }
-
-    @Override
-    public void handleConnected(IOChannel net) throws IOException {
-        HttpChannel httpCh = activeHttp;
-
-        if (!net.isOpen()) {
-            httpCh.abort(net.lastException());
-            return;
-        }
-
-        boolean ssl = httpCh.getRequest().isSecure();
-        if (ssl) {
-            String[] hostPort = httpCh.getTarget().split(":");
-
-            IOChannel ch1 = httpConnector.sslProvider.channel(net,
-                    hostPort[0], Integer.parseInt(hostPort[1]));
-            //net.setHead(ch1);
-            net = ch1;
-        }
-        if (httpConnector.debugHttp) {
-            net = DumpChannel.wrap("Http-Client-", net);
-        }
-
-        setSink(net);
-
-        sendRequest(httpCh);
-    }
-
-}

==================================================
HttpClient.java
deleted file mode 100644
index cb4b2ada8d..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpChannel.java
+++ /dev/null
@@ -1,830 +0,0 @@
-/*  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.lite.http;
-
-import java.io.IOException;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.lite.http.HttpConnector.HttpConnection;
-import org.apache.tomcat.lite.io.BBucket;
-import org.apache.tomcat.lite.io.BBuffer;
-import org.apache.tomcat.lite.io.FutureCallbacks;
-import org.apache.tomcat.lite.io.IOBuffer;
-import org.apache.tomcat.lite.io.IOChannel;
-import org.apache.tomcat.lite.io.IOConnector;
-
-/**
- * HTTP async client and server, based on tomcat NIO/APR connectors
- *
- * 'Input', 'read', 'Recv' refers to information we get from the remote side -
- * the request body for server-mode or response body for client.
- *
- * 'Output', 'write', 'Send' is for info we send - the post in client mode
- * and the response body for server mode.
- *
- * @author Costin Manolache
- */
-public class HttpChannel extends IOChannel {
-
-    static final int HEADER_SIZE = 8192;
-
-    static AtomicInteger serCnt = new AtomicInteger();
-
-    public static final String CONTENT_LENGTH= "Content-Length";
-
-    public static final String HTTP_10 = "HTTP/1.0";
-
-    public static final String HTTP_11 = "HTTP/1.1";
-
-    /**
-     * SEMI_COLON.
-     */
-    public static final byte SEMI_COLON = (byte) ';';
-
-    public static final byte QUESTION = (byte) '?';
-
-
-    protected static Logger log = Logger.getLogger("HttpChannel");
-
-
-    boolean debug = false;
-
-    // ---- Callbacks and locks
-
-    FutureCallbacks<HttpChannel> doneLock = new FutureCallbacks<HttpChannel>();
-    FutureCallbacks<HttpChannel> headersReceivedLock =
-            new FutureCallbacks<HttpChannel>();
-    /**
-     * Called when the incoming headers have been received.
-     * ( response for client mode, request for server mode )
-     * @throws IOException
-     */
-    protected HttpService httpService;
-    /**
-     * Called when:
-     *  - body sent
-     *  - body received
-     *  - release() called - either service() done or client done with the
-     *  buffers.
-     *
-     *  After this callback:
-     *  - socket closed if closeOnEndSend, or put in keep-alive
-     *  - AsyncHttp.recycle()
-     *  - returned to the pool.
-     */
-    private RequestCompleted doneAllCallback;
-    protected boolean sendReceiveDone = false;
-
-    // Will be signalled (open) when the buffer is empty.
-    FutureCallbacks<IOChannel> flushLock = new FutureCallbacks<IOChannel>();
-
-    FutureCallbacks<HttpChannel> doneFuture;
-    boolean doneCallbackCalled = false;
-
-
-    // ----------
-
-    // Set if Exect: 100-continue was set on reqest.
-    // If this is the case - body won't be sent until
-    // server responds ( client ) and server will only
-    // read body after ack() - or skip to next request
-    // without swallowing the body.
-    protected boolean expectation = false;
-
-    /** Ready for recycle, if send/receive are done */
-    protected boolean release = false;
-
-    // -----------
-
-    protected boolean headersDone = false;
-    protected boolean error = false;
-    protected boolean abortDone = false;
-
-
-    protected int ser; // id - for jmx registration and logs
-    protected int channelId;
-
-    /**
-     * Null after endSendReceive and before sending the request
-     */
-    HttpConnection conn;
-
-    HttpConnector httpConnector;
-
-    // Different ways to point to request response (server/client)
-    HttpRequest httpReq;
-    HttpResponse httpRes;
-    HttpMessage inMessage;
-    HttpMessage outMessage;
-    // receive can be for request ( server mode ) or response ( client )
-    IOBuffer receiveBody = new IOBuffer();
-
-    // notify us that user called close()
-    IOBuffer sendBody = new IOBuffer() {
-        public void close() throws IOException {
-            if (isAppendClosed()) {
-                return;
-            }
-            super.close();
-            outClosed();
-        }
-    };
-
-
-    // Server side only
-    protected String serverHeader = "TomcatLite";
-
-    long ioTimeout = 30 * 60000; // 30 min seems high enough
-
-
-    public HttpChannel() {
-        ser = serCnt.incrementAndGet();
-        httpReq = new HttpRequest(this);
-        httpRes = new HttpResponse(this);
-        init();
-        serverMode(false);
-    }
-
-    /**
-     * Close the connection, return to pool. Called if a
-     * framing error happens, or if we want to force the connection
-     * to close, without waiting for all data to be sent/received.
-     * @param t
-     *
-     * @throws IOException
-     */
-    public void abort(Throwable t) {
-        abort(t.toString());
-    }
-
-    public void abort(String t)  {
-        synchronized (this) {
-            if (abortDone) {
-                return;
-            }
-            abortDone = true;
-        }
-        try {
-            checkRelease();
-            trace("abort " + t);
-            if (conn != null) {
-                conn.abort(this, t);
-            }
-            inMessage.state = HttpMessage.State.DONE;
-            outMessage.state = HttpMessage.State.DONE;
-            sendReceiveDone = true;
-            error = true;
-            handleEndSendReceive();
-        } catch (Throwable ex) {
-            log.severe("Exception in abort " + ex);
-        }
-    }
-
-    /**
-     * If release was called - throw exception, you shouldn't use
-     * the object again.
-     * @throws IOException
-     */
-    private void checkRelease() throws IOException {
-        if (release && sendReceiveDone) {
-            throw new IOException("Object released");
-        }
-    }
-
-    public IOChannel getSink() {
-        if (conn == null) {
-            return null;
-        }
-        return conn.getSink();
-    }
-
-
-    /**
-     * Called when the request is done. Need to send remaining byte.
-     *
-     */
-    public void complete() throws IOException {
-        checkRelease();
-        if (!getOut().isAppendClosed()) {
-            getOut().close();
-        }
-        if (!getIn().isAppendClosed()) {
-            getIn().close();
-        }
-
-        startSending();
-   }
-
-    public int doRead(BBuffer chunk)
-            throws IOException {
-        checkRelease();
-        BBucket next = null;
-        while (true) {
-            getIn().waitData(0);
-            next = (BBucket) getIn().popFirst();
-            if (next != null) {
-                break;
-            } else if (getIn().isAppendClosed()) {
-                return -1;
-            } else {
-                System.err.println("Spurious waitData signal, no data");
-            }
-        }
-        chunk.append(next.array(), next.position(), next.remaining());
-        int read =  next.remaining();
-        next.release();
-        return read;
-    }
-
-    public HttpConnector getConnector() {
-        return httpConnector;
-    }
-
-    public boolean getError() {
-        return error;
-    }
-
-    // ---------------- Writting -------------------------------
-
-    public String getId() {
-        return Integer.toString(ser);
-    }
-
-    public IOBuffer getIn() {
-        return receiveBody;
-    }
-
-
-    public long getIOTimeout() {
-        return ioTimeout;
-    }
-
-    // TODO: replace with getSocketChannel - used for remote addr, etc
-    public IOChannel getNet() {
-        if (conn == null) {
-            return null;
-        }
-        return conn.getSink();
-    }
-
-
-    public IOBuffer getOut() {
-        return sendBody;
-    }
-
-    public HttpRequest getRequest() {
-        return httpReq;
-    }
-
-
-    public HttpResponse getResponse() {
-        return httpRes;
-    }
-
-
-    public String getState() {
-        return
-            conn +
-            "RCV=[" + inMessage.state.toString() + " " +
-            receiveBody.toString()
-            + "] SND=[" + outMessage.state.toString()
-            + " " + sendBody.toString() + "]";
-    }
-
-
-    public String getStatus() {
-        return getResponse().getStatus() + " " + getResponse().getMessage();
-    }
-
-
-    public String getTarget() {
-        if (target == null) {
-            return ":0"; // server mode ?
-        }
-        return target.toString();
-    }
-
-
-    /**
-     * Called from IO thread, after the request body
-     * is completed ( or if there is no req body )
-     * @throws IOException
-     */
-    protected void handleEndReceive() throws IOException {
-        if (inMessage.state == HttpMessage.State.DONE) {
-            return;
-        }
-        if (debug) {
-            trace("END_RECV");
-        }
-        getIn().close();
-
-        inMessage.state = HttpMessage.State.DONE;
-        handleEndSendReceive();
-    }
-
-    /*
-     * Called when sending, receiving and processing is done.
-     * Can be called:
-     *  - from IO thread, if this is a result of a read/write event that
-     *  finished the send/recev pair.
-     *  - from an arbitrary thread, if read was complete and the last write
-     *  was a success and done in that thread ( write is not bound to IO thr)
-     *
-     */
-    protected void handleEndSendReceive() throws IOException {
-        // make sure the callback was called ( needed for abort )
-        handleHeadersReceived(inMessage);
-
-        this.doneLock.signal(this);
-        synchronized (this) {
-            if (doneCallbackCalled) {
-                return;
-            }
-            if (outMessage.state != HttpMessage.State.DONE ||
-                    inMessage.state != HttpMessage.State.DONE) {
-                return;
-            }
-            doneCallbackCalled = true;
-        }
-
-        getIn().close();
-
-        if (doneAllCallback != null) {
-            doneAllCallback.handle(this, error ? new Throwable() : null);
-        }
-
-        if (conn != null) {
-            conn.endSendReceive(this);
-        }
-
-        conn = null;
-
-        if (debug) {
-            trace("END_SEND_RECEIVE"
-                    + (release ? " REL" : ""));
-        }
-
-        synchronized(this) {
-            sendReceiveDone = true;
-            maybeRelease();
-        }
-    }
-
-    /**
-     * called from IO thread OR servlet thread when last block has been sent.
-     * If not using the socket ( net.getOut().flushCallback ) - this must
-     * be called explicitely after flushing the body.
-     */
-    void handleEndSent() throws IOException {
-        if (outMessage.state == HttpMessage.State.DONE) {
-            // Only once.
-            if (debug) {
-                trace("Duplicate END SEND");
-            }
-            return;
-        }
-        outMessage.state = HttpMessage.State.DONE;
-
-        getOut().close();
-
-        // Make sure the send/receive callback is called once
-        if (debug) {
-            trace("END_SEND");
-        }
-        handleEndSendReceive();
-    }
-
-    // ----- End Selector thread callbacks ----
-    public void handleError(String type) {
-        System.err.println("Error " + type + " " + outMessage.state);
-    }
-
-    void handleHeadersReceived(HttpMessage in) throws IOException {
-        if (!headersDone) {
-            headersDone = true;
-            headersReceivedLock.signal(this);
-            if (httpService != null) {
-                try {
-                    httpService.service(getRequest(), getResponse());
-                } catch (Throwable t) {
-                    t.printStackTrace();
-                    abort(t);
-                }
-            }
-        }
-    }
-
-
-    private void init() {
-        headersDone = false;
-        sendReceiveDone = false;
-
-        receiveBody.recycle();
-        sendBody.recycle();
-        expectation = false;
-
-        error = false;
-        abortDone = false;
-
-
-        getRequest().recycle();
-        getResponse().recycle();
-        target = null;
-
-        doneLock.recycle();
-        headersReceivedLock.recycle();
-        flushLock.recycle();
-
-        doneCallbackCalled = false;
-        // Will be set again after pool
-        setHttpService(null);
-        doneAllCallback = null;
-        release = false;
-    }
-
-    public boolean isDone() {
-        return outMessage.state == HttpMessage.State.DONE && inMessage.state == HttpMessage.State.DONE;
-    }
-
-    /**
-     * Called when all done:
-     *  - service finished ( endService was called )
-     *  - output written
-     *  - input read
-     *
-     * or by abort().
-     *
-     * @throws IOException
-     */
-    private void maybeRelease() throws IOException {
-        synchronized (this) {
-            if (release && sendReceiveDone) {
-                if (debug) {
-                    trace("RELEASE");
-                }
-                if (getConnector() != null) {
-                    getConnector().returnToPool(this);
-                } else {
-                    log.severe("Attempt to release with no pool");
-                }
-            }
-        }
-    }
-
-
-    /*
-    The field-content does not include any leading or trailing LWS:
-    linear white space occurring before the first non-whitespace
-    character of the field-value or after the last non-whitespace
-     character of the field-value. Such leading or trailing LWS MAY
-     be removed without changing the semantics of the field value.
-     Any LWS that occurs between field-content MAY be replaced with
-     a single Http11Parser.SP before interpreting the field value or forwarding
-     the message downstream.
-     */
-    int normalizeHeader(BBuffer value) {
-        byte[] buf = value.array();
-        int cstart = value.position();
-        int end = value.limit();
-
-        int realPos = cstart;
-        int lastChar = cstart;
-        byte chr = 0;
-        boolean gotSpace = true;
-
-        for (int i = cstart; i < end; i++) {
-            chr = buf[i];
-            if (chr == BBuffer.CR) {
-                // skip
-            } else if(chr == BBuffer.LF) {
-                // skip
-            } else if (chr == BBuffer.SP || chr == BBuffer.HT) {
-                if (gotSpace) {
-                    // skip
-                } else {
-                    buf[realPos++] = BBuffer.SP;
-                    gotSpace = true;
-                }
-            } else {
-                buf[realPos++] = chr;
-                lastChar = realPos; // to skip trailing spaces
-                gotSpace = false;
-            }
-        }
-        realPos = lastChar;
-
-        // so buffer is clean
-        for (int i = realPos; i < end; i++) {
-            buf[i] = BBuffer.SP;
-        }
-        value.setEnd(realPos);
-        return realPos;
-    }
-
-
-    protected void recycle() {
-        if (debug) {
-            trace("RECYCLE");
-        }
-        init();
-    }
-
-    /**
-     * Finalize sending and receiving.
-     * Indicates client is no longer interested, some IO may still be in flight.
-     * If in a POST and you're not interested in the body - it may be
-     * better to call abort().
-     *
-     * MUST be called to allow connection reuse and pooling.
-     *
-     * @throws IOException
-     */
-    public void release() throws IOException {
-        synchronized(this) {
-            if (release) {
-                return;
-            }
-            trace("RELEASE");
-            release = true;
-            // If send/receive is done - we can reuse this object
-            maybeRelease();
-        }
-    }
-
-    public void send() throws IOException {
-        checkRelease();
-        if (httpReq == inMessage) {
-            conn.sendResponseHeaders(this);
-        } else {
-            if (getRequest().isCommitted()) {
-                return;
-            }
-            getRequest().setCommitted(true);
-
-            outMessage.state = HttpMessage.State.HEAD;
-
-            getConnector().connectAndSend(this);
-        }
-    }
-
-    /** Called when the outgoing stream is closed:
-     * - by an explicit call to close()
-     * - when all content has been sent.
-     */
-    protected void outClosed() throws IOException {
-        if (conn != null) {
-            conn.outClosed(this);
-        }
-    }
-
-    public HttpChannel serverMode(boolean enabled) {
-        if (enabled) {
-            httpReq.setBody(receiveBody);
-            httpRes.setBody(sendBody);
-            inMessage = httpReq;
-            outMessage = httpRes;
-        } else {
-            httpReq.setBody(sendBody);
-            httpRes.setBody(receiveBody);
-            inMessage = httpRes;
-            outMessage = httpReq;
-        }
-        if (debug) {
-        }
-        return this;
-    }
-
-    public void setCompletedCallback(RequestCompleted doneAllCallback)
-            throws IOException {
-        this.doneAllCallback = doneAllCallback;
-        synchronized (this) {
-            if (doneCallbackCalled) {
-                return;
-            }
-            if (outMessage.state != HttpMessage.State.DONE || inMessage.state != HttpMessage.State.DONE) {
-                return;
-            }
-        }
-        doneCallbackCalled = true;
-        if (doneAllCallback != null) {
-            doneAllCallback.handle(this, error ? new Throwable() : null);
-        }
-    }
-
-    public void setConnector(HttpConnector pool) {
-        this.httpConnector = pool;
-    }
-
-    public void setHttpService(HttpService headersReceivedCallback) {
-        this.httpService = headersReceivedCallback;
-    }
-
-    public void setIOTimeout(long timeout) {
-        ioTimeout = timeout;
-    }
-
-
-    public void setTarget(String host) {
-        this.target = host;
-    }
-
-    public void startSending() throws IOException {
-        checkRelease();
-        if (conn != null) {
-            conn.startSending(this);
-        }
-    }
-
-    public String toString() {
-        StringBuffer sb = new StringBuffer();
-        sb.append("id=").append(ser)
-            .append(",rs=").append(getState())
-            .append(")");
-        return sb.toString();
-    }
-
-
-    void trace(String msg) {
-        if(debug) {
-            log.info(this.toString() + " " + msg + " done=" + doneCallbackCalled);
-        }
-    }
-
-    @Override
-    public void waitFlush(long timeMs) throws IOException {
-        if (getOut().getBufferCount() == 0) {
-            return;
-        }
-        flushLock.waitSignal(timeMs);
-    }
-
-    public HttpChannel setConnection(HttpConnection conn) {
-        this.conn = conn;
-        return this;
-    }
-
-    /**
-     * Normalize URI.
-     * <p>
-     * This method normalizes "\", "//", "/./" and "/../". This method will
-     * return false when trying to go above the root, or if the URI contains
-     * a null byte.
-     *
-     * @param uriMB URI to be normalized, will be modified
-     */
-    public static boolean normalize(BBuffer uriBC) {
-
-        byte[] b = uriBC.array();
-        int start = uriBC.getStart();
-        int end = uriBC.getEnd();
-
-        // URL * is acceptable
-        if ((end - start == 1) && b[start] == (byte) '*')
-            return true;
-
-        if (b[start] != '/') {
-            // TODO: http://.... URLs
-            return true;
-        }
-
-        int pos = 0;
-        int index = 0;
-
-        // Replace '\' with '/'
-        // Check for null byte
-        for (pos = start; pos < end; pos++) {
-            if (b[pos] == (byte) '\\')
-                b[pos] = (byte) '/';
-            if (b[pos] == (byte) 0)
-                return false;
-        }
-
-        // The URL must start with '/'
-        if (b[start] != (byte) '/') {
-            return false;
-        }
-
-        // Replace "//" with "/"
-        for (pos = start; pos < (end - 1); pos++) {
-            if (b[pos] == (byte) '/') {
-                while ((pos + 1 < end) && (b[pos + 1] == (byte) '/')) {
-                    copyBytes(b, pos, pos + 1, end - pos - 1);
-                    end--;
-                }
-            }
-        }
-
-        // If the URI ends with "/." or "/..", then we append an extra "/"
-        // Note: It is possible to extend the URI by 1 without any side effect
-        // as the next character is a non-significant WS.
-        if (((end - start) >= 2) && (b[end - 1] == (byte) '.')) {
-            if ((b[end - 2] == (byte) '/')
-                    || ((b[end - 2] == (byte) '.')
-                            && (b[end - 3] == (byte) '/'))) {
-                b[end] = (byte) '/';
-                end++;
-            }
-        }
-
-        uriBC.setEnd(end);
-
-        index = 0;
-
-        // Resolve occurrences of "/./" in the normalized path
-        while (true) {
-            index = uriBC.indexOf("/./", 0, 3, index);
-            if (index < 0)
-                break;
-            copyBytes(b, start + index, start + index + 2,
-                    end - start - index - 2);
-            end = end - 2;
-            uriBC.setEnd(end);
-        }
-
-        index = 0;
-
-        // Resolve occurrences of "/../" in the normalized path
-        while (true) {
-            index = uriBC.indexOf("/../", 0, 4, index);
-            if (index < 0)
-                break;
-            // Prevent from going outside our context
-            if (index == 0)
-                return false;
-            int index2 = -1;
-            for (pos = start + index - 1; (pos >= 0) && (index2 < 0); pos --) {
-                if (b[pos] == (byte) '/') {
-                    index2 = pos;
-                }
-            }
-            copyBytes(b, start + index2, start + index + 3,
-                    end - start - index - 3);
-            end = end + index2 - index - 3;
-            uriBC.setEnd(end);
-            index = index2;
-        }
-
-        //uriBC.setBytes(b, start, end);
-        uriBC.setEnd(end);
-        return true;
-
-    }
-
-    /**
-     * Copy an array of bytes to a different position. Used during
-     * normalization.
-     */
-    private static void copyBytes(byte[] b, int dest, int src, int len) {
-        for (int pos = 0; pos < len; pos++) {
-            b[pos + dest] = b[pos + src];
-        }
-    }
-
-
-    /**
-     * This method will be called when the http headers have been received -
-     * the body may or may not be available.
-     *
-     * In server mode this is equivalent with a servlet request.
-     * This is also called for http client, when the response headers
-     * are received.
-     *
-     * TODO: rename it to HttMessageReceived or something similar.
-     */
-    public static interface HttpService {
-        void service(HttpRequest httpReq, HttpResponse httpRes) throws IOException;
-    }
-
-    /**
-     * Called when both request and response bodies have been sent/
-     * received. After this call the HttpChannel will be disconnected
-     * from the http connection, which can be used for other requests.
-     */
-    public static interface RequestCompleted {
-        void handle(HttpChannel data, Object extraData) throws IOException;
-    }
-
-    Runnable dispatcherRunnable = new Runnable() {
-        @Override
-        public void run() {
-            getConnector().getDispatcher().runService(HttpChannel.this);
-        }
-    };
-
-
-}
\ No newline at end of file

==================================================
HttpConnectionPool.java
deleted file mode 100644
index d53796230e..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpClient.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import org.apache.tomcat.lite.io.SocketConnector;
-import org.apache.tomcat.lite.io.SslProvider;
-import org.apache.tomcat.lite.io.jsse.JsseSslProvider;
-
-/**
- * Entry point for http client code.
- *
- * ( initial version after removing 'integration', will add settings,
- * defaults, helpers )
- */
-public class HttpClient {
-    static SslProvider sslConC = new JsseSslProvider();
-
-    public synchronized static HttpConnector newClient() {
-        return new HttpConnector(new SocketConnector()).withSsl(sslConC);
-    }
-
-}

==================================================
HttpConnector.java
deleted file mode 100644
index ab568302be..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpConnectionPool.java
+++ /dev/null
@@ -1,399 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Queue;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.lite.http.HttpConnector.HttpConnection;
-import org.apache.tomcat.lite.io.IOChannel;
-import org.apache.tomcat.lite.io.IOConnector;
-
-/**
- * - Holds references to all active and kept-alive connections.
- * - makes decisions on accepting more connections, closing old
- * connections, etc
- *
- */
-public class HttpConnectionPool {
-    // TODO: add timeouts, limits per host/total, expire old entries
-
-    public static interface HttpConnectionPoolEvents {
-        public void newTarget(RemoteServer host);
-
-        public void targetRemoved(RemoteServer host);
-
-        public void newConnection(RemoteServer host, HttpConnection con);
-        public void closedConnection(RemoteServer host, HttpConnection con);
-    }
-
-    /**
-     * Connections for one remote host.
-     * This should't be restricted by IP:port or even hostname,
-     * for example if a server has multiple IPs or LB replicas - any would work.
-     */
-    public static class RemoteServer {
-        // all access sync on RemoteServer
-        private SpdyConnection spdy;
-
-        // all access sync on RemoteServer
-        private ArrayList<Http11Connection> connections
-            = new ArrayList<Http11Connection>();
-
-        Queue<HttpChannel> pending = new LinkedList<HttpChannel>();
-
-
-        // TODO: setter, default from connector
-        private int maxConnections = 20;
-
-        AtomicInteger activeRequests = new AtomicInteger();
-        AtomicInteger totalRequests = new AtomicInteger();
-        private volatile long lastActivity;
-
-        public String target;
-
-        public synchronized List<HttpConnector.HttpConnection> getConnections()
-        {
-            return new ArrayList<HttpConnection>(connections);
-        }
-
-        public synchronized Collection<HttpChannel> getActives() {
-            ArrayList<HttpChannel> actives = new ArrayList();
-            for (Http11Connection con: connections) {
-                if (con.activeHttp != null) {
-                    actives.add(con.activeHttp);
-                }
-            }
-            if (spdy != null) {
-                actives.addAll(spdy.getActives());
-            }
-
-            return actives;
-        }
-
-        public synchronized void touch() {
-            lastActivity = System.currentTimeMillis();
-        }
-    }
-
-    private HttpConnectionPoolEvents poolEvents;
-
-    private static Logger log = Logger.getLogger("HttpConnector");
-
-    // visible for debugging - will be made private, with accessor
-    /**
-     * Map from client names to socket pools.
-     */
-    public Map<CharSequence, HttpConnectionPool.RemoteServer> hosts = new HashMap<CharSequence,
-        HttpConnectionPool.RemoteServer>();
-
-    // Statistics
-    public AtomicInteger waitingSockets = new AtomicInteger();
-    public AtomicInteger closedSockets = new AtomicInteger();
-
-    public AtomicInteger hits = new AtomicInteger();
-    public AtomicInteger misses = new AtomicInteger();
-    public AtomicInteger queued = new AtomicInteger();
-
-    public AtomicInteger activeRequests = new AtomicInteger();
-
-    private static boolean debug = false;
-    HttpConnector httpConnector;
-
-    public HttpConnectionPool(HttpConnector httpConnector) {
-        this.httpConnector = httpConnector;
-    }
-
-    public int getTargetCount() {
-        return hosts.size();
-    }
-
-    public int getSocketCount() {
-        return waitingSockets.get();
-    }
-
-    public int getClosedSockets() {
-        return closedSockets.get();
-    }
-
-    public Set<CharSequence> getKeepAliveTargets() {
-        return hosts.keySet();
-    }
-
-    public List<RemoteServer> getServers() {
-        return new ArrayList<RemoteServer>(hosts.values());
-    }
-
-    public void setEvents(HttpConnectionPoolEvents events) {
-        this.poolEvents = events;
-    }
-    /**
-     * Stop all cached connections.
-     */
-    public void clear() throws IOException {
-        synchronized (hosts) {
-            int active = 0;
-            for (RemoteServer rs: hosts.values()) {
-                synchronized (rs) {
-                    int hostActive = 0;
-                    if (rs.spdy != null) {
-                        if (rs.spdy.channels.size() == 0) {
-                            rs.spdy.close();
-                            rs.spdy = null;
-                        } else {
-                            hostActive += rs.spdy.channels.size();
-                        }
-                    }
-                    for (Http11Connection con: rs.connections) {
-                        if (con.activeHttp == null) {
-                            con.close();
-                        } else {
-                            hostActive++;
-                        }
-                    }
-                    if (hostActive != rs.activeRequests.get()) {
-                        log.warning("Active missmatch " + rs.target + " " +
-                                hostActive + " "
-                                + rs.activeRequests.get());
-                        rs.activeRequests.set(hostActive);
-                    }
-                    active += hostActive;
-                }
-            }
-            if (active != this.activeRequests.get()) {
-                log.warning("Active missmatch " + active + " "
-                        + activeRequests.get());
-                activeRequests.set(active);
-            }
-        }
-    }
-
-    /**
-     * Stop all active and cached connections
-     * @throws IOException
-     */
-    public void abort() throws IOException {
-        // TODO
-        clear();
-        hosts.clear();
-    }
-
-    /**
-     * @param key host:port, or some other key if multiple hosts:ips
-     * are connected to equivalent servers ( LB )
-     * @param httpCh
-     * @throws IOException
-     */
-    public void send(HttpChannel httpCh)
-            throws IOException {
-        String target = httpCh.getTarget();
-        HttpConnection con = null;
-        // TODO: check ssl on connection - now if a second request
-        // is received on a ssl connection - we just send it
-        boolean ssl = httpCh.getRequest().isSecure();
-
-        HttpConnectionPool.RemoteServer remoteServer = null;
-        synchronized (hosts) {
-            remoteServer = hosts.get(target);
-            if (remoteServer == null) {
-                remoteServer = new HttpConnectionPool.RemoteServer();
-                remoteServer.target = target;
-                hosts.put(target, remoteServer);
-            }
-        }
-
-        // TODO: remove old servers and connections
-
-        // Temp magic - until a better negotiation is defined
-        boolean forceSpdy = "SPDY/1.0".equals(httpCh.getRequest().getProtocol());
-        if (forceSpdy) {
-            // switch back the protocol
-            httpCh.getRequest().setProtocol("HTTP/1.1");
-        }
-
-        activeRequests.incrementAndGet();
-        remoteServer.activeRequests.incrementAndGet();
-
-        // if we already have a spdy connection or explicitely
-        // requested.
-        if (forceSpdy || remoteServer.spdy != null) {
-            synchronized (remoteServer) {
-                if (remoteServer.spdy == null) {
-                    remoteServer.spdy = new SpdyConnection(httpConnector,
-                            remoteServer);
-                }
-                con = remoteServer.spdy;
-            }
-
-            // Will be queued - multiple threads may try to send
-            // at the same time, and we need to queue anyways.
-            con.sendRequest(httpCh);
-        } else {
-            synchronized (remoteServer) {
-                Http11Connection hcon;
-                for (int i = 0; i < remoteServer.connections.size(); i++) {
-                    hcon = (Http11Connection) remoteServer.connections.get(i);
-                    if (hcon != null && hcon.activeHttp == null) {
-                        hcon.beforeRequest(); // recycle
-
-                        hcon.activeHttp = httpCh;
-                        con = hcon;
-                        break;
-                    }
-                }
-                if (con == null) {
-//                    if (remoteServer.connections.size() > remoteServer.maxConnections) {
-//                        remoteServer.pending.add(httpCh);
-//                        queued.incrementAndGet();
-//                        if (debug) {
-//                            log.info("Queue: " + target + " " + remoteServer.connections.size());
-//                        }
-//                        return;
-//                    }
-                    hcon = new Http11Connection(httpConnector);
-                    hcon.setTarget(target);
-                    hcon.activeHttp = httpCh;
-                    hcon.remoteHost = remoteServer;
-                    remoteServer.connections.add(hcon);
-                    con = hcon;
-                }
-            }
-
-
-            // we got a connection - make sure we're connected
-            http11ConnectOrSend(httpCh, target, con, ssl);
-        }
-    }
-
-    private void http11ConnectOrSend(HttpChannel httpCh, String target,
-            HttpConnection con, boolean ssl) throws IOException {
-        httpCh.setConnection(con);
-
-        if (con.isOpen()) {
-            hits.incrementAndGet();
-//            if (debug) {
-//                log.info("HTTP_CONNECT: Reuse connection " + target + " " + this);
-//            }
-            con.sendRequest(httpCh);
-        } else {
-            misses.incrementAndGet();
-            if (debug) {
-                log.info("HTTP_CONNECT: Start connection " + target + " " + this);
-            }
-            httpConnect(httpCh, target, ssl,
-                    (Http11Connection) con);
-        }
-    }
-
-    void httpConnect(HttpChannel httpCh, String target,
-            boolean ssl, IOConnector.ConnectedCallback cb)
-            throws IOException {
-        if (debug) {
-            log.info("HTTP_CONNECT: New connection " + target);
-        }
-        String[] hostPort = target.split(":");
-
-        int targetPort = ssl ? 443 : 80;
-        if (hostPort.length > 1) {
-            targetPort = Integer.parseInt(hostPort[1]);
-        }
-
-        httpConnector.getIOConnector().connect(hostPort[0], targetPort,
-                cb);
-    }
-
-    public void afterRequest(HttpChannel http, HttpConnection con,
-            boolean keepAlive)
-                throws IOException {
-        activeRequests.decrementAndGet();
-        if (con.remoteHost != null) {
-            con.remoteHost.touch();
-            con.remoteHost.activeRequests.decrementAndGet();
-        }
-        if (con.serverMode) {
-            afterServerRequest(con, keepAlive);
-        } else {
-            afterClientRequest(con);
-        }
-    }
-
-    private void afterClientRequest(HttpConnection con)
-            throws IOException {
-        RemoteServer remoteServer = con.remoteHost;
-        HttpChannel req = null;
-
-        // If we have pending requests ( because too many active limit ), pick
-        // one and send it.
-        synchronized (remoteServer) {
-            // If closed - we can remove the object - or
-            // let a background thread do it, in case it's needed
-            // again.
-            if (remoteServer.pending.size() == 0) {
-                con.activeHttp = null;
-                return;
-            }
-            req = remoteServer.pending.remove();
-            con.activeHttp = req;
-            if (debug) {
-                log.info("After request: send pending " + remoteServer.pending.size());
-            }
-        }
-
-        http11ConnectOrSend(req, con.getTarget().toString(),
-                con, req.getRequest().isSecure());
-    }
-
-    RemoteServer serverPool = new RemoteServer();
-
-    public void afterServerRequest(HttpConnection con, boolean keepAlive)
-            throws IOException {
-        con.activeHttp = null;
-        if (!keepAlive) {
-            synchronized (serverPool) {
-                // I could also reuse the object.
-                serverPool.connections.remove(con);
-            }
-        }
-    }
-
-    public HttpConnection accepted(IOChannel accepted) {
-        Http11Connection con = new Http11Connection(httpConnector);
-        con.remoteHost = serverPool;
-        synchronized (serverPool) {
-            serverPool.connections.add(con);
-        }
-        return con;
-    }
-
-
-    // Called by handleClosed
-    void stopKeepAlive(IOChannel schannel) {
-        CharSequence target = schannel.getTarget();
-        HttpConnectionPool.RemoteServer remoteServer = null;
-        synchronized (hosts) {
-            remoteServer = hosts.get(target);
-            if (remoteServer == null) {
-                return;
-            }
-        }
-        synchronized (remoteServer) {
-            if (remoteServer.connections.remove(schannel)) {
-                waitingSockets.decrementAndGet();
-                if (remoteServer.connections.size() == 0) {
-                    hosts.remove(target);
-                }
-            }
-        }
-    }
-
-
-}

==================================================
HttpMessage.java
deleted file mode 100644
index 0b4708d4f7..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpConnector.java
+++ /dev/null
@@ -1,514 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import java.io.IOException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Timer;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.lite.http.HttpChannel.HttpService;
-import org.apache.tomcat.lite.io.BBuffer;
-import org.apache.tomcat.lite.io.DumpChannel;
-import org.apache.tomcat.lite.io.IOBuffer;
-import org.apache.tomcat.lite.io.IOChannel;
-import org.apache.tomcat.lite.io.IOConnector;
-import org.apache.tomcat.lite.io.SslProvider;
-import org.apache.tomcat.lite.io.IOConnector.DataReceivedCallback;
-
-/**
- * Manages HttpChannels and associated socket pool.
- *
- *
- * @author Costin Manolache
- */
-public class HttpConnector {
-
-    public static interface HttpChannelEvents {
-        /** HttpChannel object created. It'll be used many times.
-         * @throws IOException
-         */
-        public void onCreate(HttpChannel ch, HttpConnector con) throws IOException;
-
-        /**
-         * HttpChannel object no longer needed, out of pool.
-         * @throws IOException
-         */
-        public void onDestroy(HttpChannel ch, HttpConnector con) throws IOException;
-    }
-
-    private static Logger log = Logger.getLogger("HttpConnector");
-
-    /**
-     * Cache HttpChannel/request/buffers
-     */
-    private int maxHttpPoolSize = 50;
-
-    /**
-     * Max number of connections to keep alive.
-     * Each connection holds a header buffer and the socket.
-     * ( we could skip the header buffer )
-     */
-    private int maxSocketPoolSize = 500; // 10000;
-
-    private int keepAliveTimeMs = 300000;
-
-    private List<HttpChannel> httpChannelPool = new ArrayList<HttpChannel>();
-
-    protected IOConnector ioConnector;
-
-    // for https connections
-    protected SslProvider sslProvider;
-
-    boolean debugHttp = false;
-    boolean debug = false;
-
-    boolean clientKeepAlive = true;
-    boolean serverKeepAlive = true;
-
-    HttpChannelEvents httpEvents;
-
-    public AtomicInteger inUse = new AtomicInteger();
-    public AtomicInteger newHttpChannel = new AtomicInteger();
-    public AtomicInteger totalHttpChannel = new AtomicInteger();
-    public AtomicInteger totalClientHttpChannel = new AtomicInteger();
-    public AtomicInteger recycledChannels = new AtomicInteger();
-    public AtomicInteger reusedChannels = new AtomicInteger();
-
-    public HttpConnectionPool cpool = new HttpConnectionPool(this);
-
-    // Host + context mapper.
-    Dispatcher dispatcher;
-    protected HttpService defaultService;
-    int port = 8080;
-
-    private Timer timer;
-
-    boolean compression = true;
-
-    boolean serverSSL = false;
-
-    private static Timer defaultTimer = new Timer(true);
-
-    public HttpConnector(IOConnector ioConnector) {
-        this.ioConnector = ioConnector;
-        dispatcher = new Dispatcher();
-        defaultService = dispatcher;
-        if (ioConnector != null) {
-            timer = ioConnector.getTimer();
-        } else {
-            // tests
-            timer = defaultTimer;
-        }
-    }
-
-    protected HttpConnector() {
-        this(null);
-    }
-
-    public Dispatcher getDispatcher() {
-        return dispatcher;
-    }
-
-    public HttpConnectionPool getConnectionPool() {
-        return cpool;
-    }
-
-    public HttpConnector withIOConnector(IOConnector selectors) {
-        ioConnector = selectors;
-        return this;
-    }
-
-    public void setDebug(boolean b) {
-        this.debug = b;
-    }
-
-    public void setDebugHttp(boolean b) {
-        this.debugHttp  = b;
-    }
-
-    public HttpConnector withSsl(SslProvider ssl) {
-        sslProvider = ssl;
-        return this;
-    }
-
-    HttpConnector setServerSsl(boolean b) {
-        serverSSL = b;
-        return this;
-    }
-
-    public SslProvider getSslProvider() {
-        return sslProvider;
-    }
-
-    /**
-     * Allow or disable compression for this connector.
-     * Compression is enabled by default.
-     */
-    public HttpConnector setCompression(boolean b) {
-        this.compression = b;
-        return this;
-    }
-
-    public void setClientKeepAlive(boolean b) {
-        this.clientKeepAlive = b;
-    }
-
-    public void setServerKeepAlive(boolean b) {
-        this.serverKeepAlive = b;
-    }
-
-    public boolean isDebug() {
-        return debug;
-    }
-
-    public boolean isClientKeepAlive() {
-        return clientKeepAlive;
-    }
-
-    public boolean isServerKeepAlive() {
-        return serverKeepAlive;
-    }
-
-    public int getInUse() {
-        return inUse.get();
-    }
-
-    public int getMaxHttpPoolSize() {
-        return maxHttpPoolSize;
-    }
-
-    public void setMaxHttpPoolSize(int maxHttpPoolSize) {
-        this.maxHttpPoolSize = maxHttpPoolSize;
-    }
-
-    public void setOnCreate(HttpChannelEvents callback) {
-        httpEvents = callback;
-    }
-
-    /**
-     *  Override to create customized client/server connections.
-     *
-     * @return
-     * @throws IOException
-     */
-    protected HttpChannel create() throws IOException {
-        HttpChannel res = new HttpChannel();
-        newHttpChannel.incrementAndGet();
-        res.setConnector(this);
-        if (httpEvents != null) {
-            httpEvents.onCreate(res, this);
-        }
-        if (debugHttp) {
-            res.debug = debugHttp;
-        }
-        return res;
-    }
-
-    public HttpChannel get(String host, int port) throws IOException {
-        HttpChannel http = get(false);
-        http.setTarget(host + ":" + port);
-        return http;
-    }
-
-    public HttpChannel getServer() {
-        try {
-            return get(true);
-        } catch (IOException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-            return null;
-        }
-    }
-
-    public HttpRequest request(String host, int port) throws IOException {
-        HttpChannel http = get(false);
-        http.setTarget(host + ":" + port);
-        return http.getRequest();
-
-    }
-
-    public HttpRequest request(CharSequence urlString) throws IOException {
-        return get(urlString).getRequest();
-    }
-
-    /**
-     * Get an existing AsyncHttp object. Since it uses many buffers and
-     * objects - it's more efficient to pool it.
-     *
-     * release will return the object to the pool.
-     * @throws IOException
-     */
-    public HttpChannel get(CharSequence urlString) throws IOException {
-        URL url = new URL(urlString.toString());
-        String host = url.getHost();
-        int port = url.getPort();
-        boolean secure = "http".equals(url.getAuthority());
-        if (port == -1) {
-            port = secure ? 443: 80;
-        }
-        // TODO: insert SSL filter
-        HttpChannel http = get(false);
-        http.setTarget(host + ":" + port);
-        String path = url.getFile(); // path + qry
-        // TODO: query string
-        http.getRequest().requestURI().set(path);
-        return http;
-    }
-
-    protected HttpChannel get(boolean server) throws IOException {
-        HttpChannel processor = null;
-        synchronized (httpChannelPool) {
-            int cnt = httpChannelPool.size();
-            if (cnt > 0) {
-                processor = httpChannelPool.remove(cnt - 1);
-            }
-        }
-        boolean reuse = false;
-        totalHttpChannel.incrementAndGet();
-        if (!server) {
-            totalClientHttpChannel.incrementAndGet();
-        }
-        if (processor == null) {
-            processor = create();
-        } else {
-            reuse = true;
-            reusedChannels.incrementAndGet();
-            processor.release = false;
-        }
-        processor.serverMode(server);
-        if (debug) {
-            log.info((reuse ? "REUSE ": "Create ") +
-                    (server? " S" : "")
-                    + " id=" + processor.ser +
-                    " " + processor +
-                    " size=" + httpChannelPool.size());
-        }
-
-        processor.setConnector(this);
-        inUse.incrementAndGet();
-        return processor;
-    }
-
-    protected void returnToPool(HttpChannel http) throws IOException {
-        inUse.decrementAndGet();
-        recycledChannels.incrementAndGet();
-        int size = 0;
-        boolean pool = false;
-
-        http.recycle();
-        http.setConnection(null);
-        http.setConnector(null);
-
-        // No more data - release the object
-        synchronized (httpChannelPool) {
-            size = httpChannelPool.size();
-            if (httpChannelPool.contains(http)) {
-                log.severe("Duplicate element in pool !");
-            } else if (size < maxHttpPoolSize) {
-                httpChannelPool.add(http);
-                pool = true;
-            }
-        }
-
-        if (!pool && httpEvents != null) {
-            httpEvents.onDestroy(http, this);
-        }
-        if (debug) {
-            log.info((pool ? "Return " : "Destroy ")
-                    + http.getTarget() + " obj=" +
-                    http + " size=" + size);
-        }
-    }
-
-
-    public IOConnector getIOConnector() {
-        return ioConnector;
-    }
-
-
-    public void setHttpService(HttpService s) {
-        defaultService = s;
-    }
-
-    public void start() throws IOException {
-        if (ioConnector != null) {
-            ioConnector.acceptor(new AcceptorCallback(),
-                    Integer.toString(port), null);
-        }
-    }
-
-    /**
-     *
-     * TODO: only clean our state and sockets we listen on.
-     *
-     */
-    public void stop() {
-        if (ioConnector != null) {
-            ioConnector.stop();
-        }
-    }
-
-    protected void connectAndSend(HttpChannel httpCh) throws IOException {
-        cpool.send(httpCh);
-
-    }
-
-    private class AcceptorCallback implements IOConnector.ConnectedCallback {
-        @Override
-        public void handleConnected(IOChannel accepted) throws IOException {
-            handleAccepted(accepted);
-        }
-    }
-
-    public HttpConnection handleAccepted(IOChannel accepted) throws IOException {
-        // TODO: reuse
-        HttpConnection shttp = cpool.accepted(accepted);
-        shttp.serverMode = true;
-
-        IOChannel head = accepted;
-        IOChannel ch;
-
-        String id = null;
-        if (debugHttp) {
-            id = port + "-" + accepted.getFirst().getAttribute(IOChannel.ATT_REMOTE_PORT);
-            log.info("Accepted " + id);
-            head = DumpChannel.wrap("SSL-" + id, head);
-        }
-
-        // TODO: seems cleaner this way...
-        if (serverSSL) {
-            ch = sslProvider.serverChannel(head);
-            head.setHead(ch);
-            head = ch;
-
-            if (debugHttp) {
-                head = DumpChannel.wrap("CLEAR-" + id, head);
-            }
-        }
-
-        shttp.setSink(head);
-
-        // Will read any data in the channel, notify data available up
-        accepted.handleReceived(accepted);
-        return shttp;
-    }
-
-    public HttpConnector setPort(int port2) {
-        this.port = port2;
-        return this;
-    }
-
-    /**
-     * Actual HTTP/1.1 wire protocol.
-     *
-     */
-    public static abstract class HttpConnection extends IOChannel
-        implements DataReceivedCallback
-    {
-        protected HttpConnector httpConnector;
-        protected boolean serverMode = false;
-
-        protected BBuffer headRecvBuf = BBuffer.allocate(8192);
-        protected CompressFilter compress = new CompressFilter();
-
-        protected boolean secure = false;
-
-        protected HttpConnectionPool.RemoteServer remoteHost;
-        // If set, the connection is in use ( active )
-        // null == keep alive. Changes synchronized on remoteHost
-        // before/after request
-        protected HttpChannel activeHttp;
-
-        @Override
-        public final void handleReceived(IOChannel ch) throws IOException {
-            int before = ch.getIn().available();
-            dataReceived(ch.getIn());
-        }
-
-        protected HttpChannel checkHttpChannel() throws IOException {
-            return null;
-        }
-
-        /**
-         * Called before a new request is sent, on a channel that is
-         * reused.
-         */
-        public void beforeRequest() {
-        }
-
-        public void setSink(IOChannel ch) throws IOException {
-            this.net = ch;
-            ch.setDataReceivedCallback(this);
-            ch.setDataFlushedCallback(this);
-            // we may have data in the buffer;
-            handleReceived(ch);
-        }
-
-
-        /**
-         * Incoming data.
-         */
-        public abstract void dataReceived(IOBuffer iob) throws IOException;
-
-        /**
-         * Framing error, client interrupt, etc.
-         */
-        public void abort(HttpChannel http, String t) throws IOException {
-        }
-
-        protected void sendRequest(HttpChannel http)
-            throws IOException {
-        }
-
-        protected void sendResponseHeaders(HttpChannel http)
-            throws IOException {
-        }
-
-        public void startSending(HttpChannel http) throws IOException {
-        }
-
-        @Override
-        public IOBuffer getIn() {
-            return net == null ? null : net.getIn();
-        }
-
-        @Override
-        public IOBuffer getOut() {
-            return net == null ? null : net.getOut();
-        }
-
-        @Override
-        public void startSending() throws IOException {
-        }
-
-        /** Called when the outgoing stream is closed:
-         * - by an explicit call to close()
-         * - when all content has been sent.
-         */
-        protected void outClosed(HttpChannel http) throws IOException {
-        }
-
-        /**
-         * Called by HttpChannel when both input and output are fully
-         * sent/received. When this happens the request is no longer associated
-         * with the Connection, and the connection can be re-used.
-         *
-         * The channel can still be used to access the retrieved data that may
-         * still be buffered until HttpChannel.release() is called.
-         *
-         * This method will be called only once, for both succesful and aborted
-         * requests.
-         */
-        protected abstract void endSendReceive(HttpChannel httpChannel) throws IOException;
-
-        public void withExtraBuffer(BBuffer received) {
-            return;
-        }
-
-    }
-
-}

==================================================
HttpRequest.java
deleted file mode 100644
index 5d30e6317b..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpMessage.java
+++ /dev/null
@@ -1,508 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.PrintWriter;
-import java.io.UnsupportedEncodingException;
-import java.io.Writer;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Locale;
-import java.util.TimeZone;
-
-import org.apache.tomcat.lite.http.HttpChannel.RequestCompleted;
-import org.apache.tomcat.lite.http.HttpConnector.HttpConnection;
-import org.apache.tomcat.lite.io.BBuffer;
-import org.apache.tomcat.lite.io.BufferedIOReader;
-import org.apache.tomcat.lite.io.CBuffer;
-import org.apache.tomcat.lite.io.FastHttpDateFormat;
-import org.apache.tomcat.lite.io.IOBuffer;
-import org.apache.tomcat.lite.io.IOInputStream;
-import org.apache.tomcat.lite.io.IOOutputStream;
-import org.apache.tomcat.lite.io.IOReader;
-import org.apache.tomcat.lite.io.IOWriter;
-import org.apache.tomcat.lite.io.UrlEncoding;
-
-
-/**
- * Basic Http request or response message.
- *
- * Because the HttpChannel can be used for both client and
- * server, and to make proxy and other code simpler - the request
- * and response are represented by the same class.
- *
- * @author Costin Manolache
- */
-public abstract class HttpMessage {
-
-    public static enum State {
-        HEAD,
-        BODY_DATA,
-        DONE
-    }
-
-    /**
-     * Raw, off-the-wire message.
-     */
-    public static class HttpMessageBytes {
-        BBuffer head1 = BBuffer.wrapper();
-        BBuffer head2 = BBuffer.wrapper();
-        BBuffer proto = BBuffer.wrapper();
-
-        BBuffer query = BBuffer.wrapper();
-
-        List<BBuffer> headerNames = new ArrayList<BBuffer>();
-        List<BBuffer> headerValues  = new ArrayList<BBuffer>();
-
-        int headerCount;
-
-        public BBuffer status() {
-            return head1;
-        }
-
-        public BBuffer method() {
-            return head1;
-        }
-
-        public BBuffer url() {
-            return head2;
-        }
-
-        public BBuffer query() {
-            return query;
-        }
-
-        public BBuffer protocol() {
-            return proto;
-        }
-
-        public BBuffer message() {
-            return head2;
-        }
-
-        public int addHeader() {
-            if (headerCount >= headerNames.size()) {
-                // make space for the new header.
-                headerNames.add(BBuffer.wrapper());
-                headerValues.add(BBuffer.wrapper());
-            }
-            return headerCount++;
-        }
-
-        public BBuffer getHeaderName(int i) {
-            if (i >= headerNames.size()) {
-                return null;
-            }
-            return headerNames.get(i);
-        }
-
-        public BBuffer getHeaderValue(int i) {
-            if (i >= headerValues.size()) {
-                return null;
-            }
-            return headerValues.get(i);
-        }
-
-        public void recycle() {
-            head1.recycle();
-            head2.recycle();
-            proto.recycle();
-            query.recycle();
-            headerCount = 0;
-            for (int i = 0; i < headerCount; i++) {
-                headerNames.get(i).recycle();
-                headerValues.get(i).recycle();
-            }
-        }
-    }
-
-    protected static final TimeZone GMT_ZONE = TimeZone.getTimeZone("GMT");
-
-    private HttpMessageBytes msgBytes = new HttpMessageBytes();
-
-    protected HttpMessage.State state = HttpMessage.State.HEAD;
-
-    protected HttpChannel httpCh;
-
-    protected MultiMap headers = new MultiMap().insensitive();
-
-    protected CBuffer protoMB;
-
-    // Cookies
-    protected boolean cookiesParsed = false;
-
-    // TODO: cookies parsed when headers are added !
-    protected ArrayList<ServerCookie> cookies;
-    protected ArrayList<ServerCookie> cookiesCache;
-
-    protected UrlEncoding urlDecoder = new UrlEncoding();
-    protected String charEncoding;
-
-    IOReader reader;
-    BufferedIOReader bufferedReader;
-    HttpWriter writer;
-    IOWriter conv;
-
-    IOOutputStream out;
-    private IOInputStream in;
-
-    boolean commited;
-
-    protected IOBuffer body;
-
-    long contentLength = -2;
-    boolean chunked;
-
-    /**
-     * The set of SimpleDateFormat formats to use in getDateHeader().
-     *
-     * Notice that because SimpleDateFormat is not thread-safe, we can't
-     * declare formats[] as a static variable.
-     */
-    protected SimpleDateFormat formats[] = null;
-
-
-    BBuffer clBuffer = BBuffer.allocate(64);
-
-    public HttpMessage(HttpChannel httpCh) {
-        this.httpCh = httpCh;
-
-        out = new IOOutputStream(httpCh.getOut(), httpCh);
-        conv = new IOWriter(httpCh);
-        writer = new HttpWriter(this, out, conv);
-
-        in = new IOInputStream(httpCh, httpCh.getIOTimeout());
-
-        reader = new IOReader(httpCh.getIn());
-        bufferedReader = new BufferedIOReader(reader);
-
-        cookies = new ArrayList<ServerCookie>();
-        cookiesCache = new ArrayList<ServerCookie>();
-        protoMB = CBuffer.newInstance();
-    }
-
-    public void addHeader(String name, String value) {
-        getMimeHeaders().addValue(name).set(value);
-    }
-
-    public void setHeader(String name, String value) {
-        getMimeHeaders().setValue(name).set(value);
-    }
-
-    public void setMimeHeaders(MultiMap resHeaders) {
-        this.headers = resHeaders;
-    }
-
-    public String getHeader(String name) {
-        CBuffer cb = headers.getHeader(name);
-        return (cb == null) ? null : cb.toString();
-    }
-
-    public MultiMap getMimeHeaders() {
-        return headers;
-    }
-
-    /**
-     * Return the value of the specified date header, if any; otherwise
-     * return -1.
-     *
-     * @param name Name of the requested date header
-     *
-     * @exception IllegalArgumentException if the specified header value
-     *  cannot be converted to a date
-     */
-    public long getDateHeader(String name) {
-
-        String value = getHeader(name);
-        if (value == null)
-            return (-1L);
-        if (formats == null) {
-            formats = new SimpleDateFormat[] {
-                new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US),
-                new SimpleDateFormat("EEEEEE, dd-MMM-yy HH:mm:ss zzz", Locale.US),
-                new SimpleDateFormat("EEE MMMM d HH:mm:ss yyyy", Locale.US)
-            };
-            formats[0].setTimeZone(GMT_ZONE);
-            formats[1].setTimeZone(GMT_ZONE);
-            formats[2].setTimeZone(GMT_ZONE);
-        }
-
-        // Attempt to convert the date header in a variety of formats
-        long result = FastHttpDateFormat.parseDate(value, formats);
-        if (result != (-1L)) {
-            return result;
-        }
-        throw new IllegalArgumentException(value);
-
-    }
-
-
-    public Collection<String> getHeaderNames() {
-
-        MultiMap headers = getMimeHeaders();
-        int n = headers.size();
-        ArrayList<String> result = new ArrayList<String>();
-        for (int i = 0; i < n; i++) {
-            result.add(headers.getName(i).toString());
-        }
-        return result;
-    }
-
-    public boolean containsHeader(String name) {
-        return headers.getHeader(name) != null;
-    }
-
-    public void setContentLength(long len) {
-        contentLength = len;
-        clBuffer.setLong(len);
-        setCLHeader();
-    }
-
-    public void setContentLength(int len) {
-        contentLength = len;
-        clBuffer.setLong(len);
-        setCLHeader();
-    }
-
-    private void setCLHeader() {
-        MultiMap.Entry clB = headers.setEntry("content-length");
-        clB.valueB = clBuffer;
-    }
-
-    public long getContentLengthLong() {
-        if (contentLength == -2) {
-            CBuffer clB = headers.getHeader("content-length");
-            contentLength = (clB == null) ?
-                    -1 : clB.getLong();
-        }
-        return contentLength;
-    }
-
-    public int getContentLength() {
-        long length = getContentLengthLong();
-
-        if (length < Integer.MAX_VALUE) {
-            return (int) length;
-        }
-        return -1;
-    }
-
-    public String getContentType() {
-        CBuffer contentTypeMB = headers.getHeader("content-type");
-        if (contentTypeMB == null) {
-            return null;
-        }
-        return contentTypeMB.toString();
-    }
-
-    public void setContentType(String contentType) {
-        CBuffer clB = getMimeHeaders().getHeader("content-type");
-        if (clB == null) {
-            setHeader("Content-Type", contentType);
-        } else {
-            clB.set(contentType);
-        }
-    }
-
-    /**
-     * Get the character encoding used for this request.
-     * Need a field because it can be overriden. Used to construct the
-     * Reader.
-     */
-    public String getCharacterEncoding() {
-        if (charEncoding != null)
-            return charEncoding;
-
-        charEncoding = ContentType.getCharsetFromContentType(getContentType());
-        return charEncoding;
-    }
-
-    private static final String DEFAULT_ENCODING = "ISO-8859-1";
-
-    public String getEncoding() {
-        String charEncoding = getCharacterEncoding();
-        if (charEncoding == null) {
-            return DEFAULT_ENCODING;
-        } else {
-            return charEncoding;
-        }
-    }
-
-    public void setCharacterEncoding(String enc)
-            throws UnsupportedEncodingException {
-        this.charEncoding = enc;
-    }
-
-
-    public void recycle() {
-        commited = false;
-        headers.recycle();
-        protoMB.set("HTTP/1.1");
-        for (int i = 0; i < cookies.size(); i++) {
-            cookies.get(i).recycle();
-        }
-        cookies.clear();
-        charEncoding = null;
-        bufferedReader.recycle();
-
-        writer.recycle();
-        conv.recycle();
-
-        contentLength = -2;
-        chunked = false;
-        clBuffer.recycle();
-        state = State.HEAD;
-        cookiesParsed = false;
-        getMsgBytes().recycle();
-
-    }
-
-
-    public String getProtocol() {
-        return protoMB.toString();
-    }
-
-    public void setProtocol(String proto) {
-        protoMB.set(proto);
-    }
-
-    public CBuffer protocol() {
-        return protoMB;
-    }
-
-    public ServerCookie getCookie(String name) {
-        for (ServerCookie sc: getServerCookies()) {
-            if (sc.getName().equalsIgnoreCase(name)) {
-                return sc;
-            }
-        }
-        return null;
-    }
-
-    public List<ServerCookie> getServerCookies() {
-        if (!cookiesParsed) {
-            cookiesParsed = true;
-            ServerCookie.processCookies(cookies, cookiesCache, getMsgBytes());
-        }
-        return cookies;
-    }
-
-    public UrlEncoding getURLDecoder() {
-        return urlDecoder;
-    }
-
-    public boolean isCommitted() {
-        return commited;
-    }
-
-    public void setCommitted(boolean b) {
-        commited = b;
-    }
-
-    public HttpChannel getHttpChannel() {
-        return httpCh;
-    }
-
-    public IOBuffer getBody() {
-        return body;
-    }
-
-    void setBody(IOBuffer body) {
-        this.body = body;
-    }
-
-    public void flush() throws IOException {
-        httpCh.startSending();
-    }
-
-    // not servlet input stream
-    public IOInputStream getBodyInputStream() {
-        return in;
-    }
-
-    public InputStream getInputStream() {
-        return in;
-    }
-
-    public IOOutputStream getOutputStream() {
-        return out;
-    }
-
-    public IOOutputStream getBodyOutputStream() {
-        return out;
-    }
-
-    public IOReader getBodyReader() throws IOException {
-        reader.setEncoding(getCharacterEncoding());
-        return reader;
-    }
-
-    public BBuffer readAll(BBuffer chunk, long to) throws IOException {
-        return httpCh.readAll(chunk, to);
-    }
-
-    public BBuffer readAll() throws IOException {
-        return httpCh.readAll(null, httpCh.ioTimeout);
-    }
-
-    /**
-     * We're done with this object, it can be recycled.
-     * Any use after this should throw exception or affect an
-     *  unrelated request.
-     */
-    public void release() throws IOException {
-        httpCh.release();
-    }
-
-    public void setCompletedCallback(RequestCompleted doneAllCallback) throws IOException {
-        httpCh.setCompletedCallback(doneAllCallback);
-    }
-
-    public void setReadTimeout(long to) {
-        reader.setTimeout(to);
-    }
-
-    /**
-     * Returns a buffered reader.
-     */
-    public BufferedReader getReader() throws IOException {
-        reader.setEncoding(getCharacterEncoding());
-        return bufferedReader;
-    }
-
-    public PrintWriter getWriter() {
-        return new PrintWriter(getBodyWriter());
-    }
-
-    public HttpWriter getBodyWriter() {
-        conv.setEncoding(getCharacterEncoding());
-        return writer;
-    }
-
-
-    protected void processMimeHeaders() {
-        for (int idx = 0; idx < getMsgBytes().headerCount; idx++) {
-            BBuffer nameBuf = getMsgBytes().getHeaderName(idx);
-            BBuffer valBuf = getMsgBytes().getHeaderValue(idx);
-
-            MultiMap.Entry header = headers.addEntry(nameBuf);
-            header.valueB = valBuf;
-        }
-    }
-
-
-    protected abstract void processReceivedHeaders() throws IOException;
-
-    public abstract boolean hasBody();
-
-    public HttpMessageBytes getMsgBytes() {
-        // TODO: serialize if not set
-        return msgBytes;
-    }
-
-}

==================================================
HttpResponse.java
deleted file mode 100644
index be934dd8c8..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpRequest.java
+++ /dev/null
@@ -1,1019 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import java.io.IOException;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.tomcat.lite.http.HttpChannel.HttpService;
-import org.apache.tomcat.lite.http.MultiMap.Entry;
-import org.apache.tomcat.lite.io.BBuffer;
-import org.apache.tomcat.lite.io.CBuffer;
-import org.apache.tomcat.lite.io.Hex;
-import org.apache.tomcat.lite.io.IOBuffer;
-import org.apache.tomcat.lite.io.IOChannel;
-import org.apache.tomcat.lite.io.IOReader;
-import org.apache.tomcat.lite.io.IOWriter;
-import org.apache.tomcat.lite.io.UrlEncoding;
-
-public class HttpRequest extends HttpMessage {
-    public static final String DEFAULT_CHARACTER_ENCODING="ISO-8859-1";
-
-    protected CBuffer schemeMB;
-    protected CBuffer methodMB;
-    protected CBuffer remoteAddrMB;
-    protected CBuffer remoteHostMB;
-    protected int remotePort;
-
-    protected CBuffer localNameMB;
-    protected CBuffer localAddrMB;
-    protected int localPort = -1;
-
-    // Host: header, or default:80
-    protected CBuffer serverNameMB;
-    protected int serverPort = -1;
-
-
-    // ==== Derived fields, computed after request is received ===
-
-    protected CBuffer requestURI;
-    protected CBuffer queryMB;
-
-    protected BBuffer decodedUri = BBuffer.allocate();
-    protected CBuffer decodedUriMB;
-
-    // Decoded query
-    protected MultiMap parameters;
-
-    boolean parametersParsed = false;
-
-    protected IOWriter charEncoder = new IOWriter(null);
-    protected IOReader charDecoder = new IOReader(null);
-    protected UrlEncoding urlEncoding = new UrlEncoding();
-
-    // Reference to 'real' request object
-    // will not be recycled
-    public Object nativeRequest;
-    public Object wrapperRequest;
-
-    boolean ssl = false;
-
-    boolean async = false;
-
-    CBuffer requestURL = CBuffer.newInstance();
-
-    private Map<String, Object> attributes = new HashMap<String, Object>();
-
-    /**
-     * Mapping data.
-     */
-    protected MappingData mappingData = new MappingData();
-
-
-    HttpRequest(HttpChannel httpCh) {
-        super(httpCh);
-        decodedUriMB = CBuffer.newInstance();
-        requestURI = CBuffer.newInstance();
-        queryMB = CBuffer.newInstance();
-        serverNameMB = CBuffer.newInstance();
-
-        parameters = new MultiMap();
-
-        schemeMB =
-            CBuffer.newInstance();
-        methodMB = CBuffer.newInstance();
-        initRemote();
-    }
-
-    protected void initRemote() {
-        remoteAddrMB = CBuffer.newInstance();
-        localNameMB = CBuffer.newInstance();
-        remoteHostMB = CBuffer.newInstance();
-        localAddrMB = CBuffer.newInstance();
-    }
-
-    public void recycle() {
-        super.recycle();
-        schemeMB.recycle();
-        methodMB.set("GET");
-        requestURI.recycle();
-        requestURL.recycle();
-        queryMB.recycle();
-        decodedUriMB.recycle();
-
-        parameters.recycle();
-        remoteAddrMB.recycle();
-        remoteHostMB.recycle();
-        parametersParsed = false;
-        ssl = false;
-        async = false;
-        asyncTimeout = -1;
-        charEncoder.recycle();
-
-        localPort = -1;
-        remotePort = -1;
-        localAddrMB.recycle();
-        localNameMB.recycle();
-
-        serverPort = -1;
-        serverNameMB.recycle();
-        decodedUri.recycle();
-        decodedQuery.recycle();
-    }
-
-    public Object getAttribute(String name) {
-        return attributes.get(name);
-    }
-
-    public void setAttribute(String name, Object o) {
-        if (o == null) {
-            attributes.remove(name);
-        } else {
-            attributes.put(name, o);
-        }
-    }
-    // getAttributeNames not supported
-
-    public Map<String, Object> attributes() {
-        return attributes;
-    }
-
-
-    public CBuffer method() {
-        return methodMB;
-    }
-
-    public String getMethod() {
-        return methodMB.toString();
-    }
-
-    public void setMethod(String method) {
-        methodMB.set(method);
-    }
-
-    public CBuffer scheme() {
-        return schemeMB;
-    }
-
-    public String getScheme() {
-        String scheme = schemeMB.toString();
-        if (scheme == null) {
-            return "http";
-        }
-        return scheme;
-    }
-
-    public void setScheme(String s) {
-        schemeMB.set(s);
-    }
-
-    public MappingData getMappingData() {
-        return (mappingData);
-    }
-
-    /**
-     * Return the portion of the request URI used to select the Context
-     * of the Request.
-     */
-    public String getContextPath() {
-        return (getMappingData().contextPath.toString());
-    }
-
-    public String getPathInfo() {
-        CBuffer pathInfo = getMappingData().pathInfo;
-        if (pathInfo.length() == 0) {
-            return null;
-        }
-        return (getMappingData().pathInfo.toString());
-    }
-
-    /**
-     * Return the portion of the request URI used to select the servlet
-     * that will process this request.
-     */
-    public String getServletPath() {
-        return (getMappingData().wrapperPath.toString());
-    }
-
-    /**
-     * Parse query parameters - but not POST body.
-     *
-     * If you don't call this method, getParameters() will
-     * also read the body for POST with x-www-url-encoded
-     * mime type.
-     */
-    public void parseQueryParameters() {
-        parseQuery();
-    }
-
-    /**
-     * Explicitely parse the body, adding the parameters to
-     * those from the query ( if already parsed ).
-     *
-     * By default servlet mode ( both query and body ) is used.
-     */
-    public void parsePostParameters() {
-        parseBody();
-    }
-
-    MultiMap getParameters() {
-        if (!parametersParsed) {
-            parseQuery();
-            parseBody();
-        }
-        return parameters;
-    }
-
-    public Enumeration<String> getParameterNames() {
-        return getParameters().names();
-    }
-
-    /**
-     * Expensive, creates a copy on each call.
-     * @param name
-     * @return
-     */
-    public String[] getParameterValues(String name) {
-        Entry entry = getParameters().getEntry(name);
-        if (entry == null) {
-            return null;
-        }
-        String[] values = new String[entry.values.size()];
-        for (int j = 0; j < values.length; j++) {
-            values[j] = entry.values.get(j).toString();
-        }
-        return values;
-    }
-
-    // Inefficient - we convert from a different representation.
-    public Map<String, String[]> getParameterMap() {
-        // we could allow 'locking' - I don't think this is
-        // a very useful optimization
-        Map<String, String[]> map = new HashMap();
-        for (int i = 0; i < getParameters().size(); i++) {
-            Entry entry = getParameters().getEntry(i);
-            if (entry == null) {
-                continue;
-            }
-            if (entry.key == null) {
-                continue;
-            }
-            String name = entry.key.toString();
-            String[] values = new String[entry.values.size()];
-            for (int j = 0; j < values.length; j++) {
-                values[j] = entry.values.get(j).toString();
-            }
-            map.put(name, values);
-        }
-        return map;
-    }
-
-    public String getParameter(String name) {
-        CharSequence value = getParameters().get(name);
-        if (value == null) {
-            return null;
-        }
-        return value.toString();
-    }
-
-    public void setParameter(String name, String value) {
-        getParameters().set(name, value);
-    }
-
-    public void addParameter(String name, String values) {
-        getParameters().add(name, values);
-    }
-
-    public CBuffer queryString() {
-        return queryMB;
-    }
-
-    // TODO
-    void serializeParameters(Appendable cc) throws IOException {
-        int keys = parameters.size();
-        boolean notFirst = false;
-        for (int i = 0; i < parameters.size(); i++) {
-            Entry entry = parameters.getEntry(i);
-            for (int j = 0; j < entry.values.size(); j++) {
-                // TODO: Uencode
-                if (notFirst) {
-                    cc.append('&');
-                } else {
-                    notFirst = true;
-                }
-                cc.append(entry.key);
-                cc.append("=");
-                cc.append(entry.values.get(j).getValue());
-            }
-        }
-    }
-
-    public void setURI(CharSequence encoded) {
-        decodedUriMB.recycle();
-        decodedUriMB.append(encoded);
-        // TODO: generate % encoding ( reverse of decodeRequest )
-    }
-
-    public CBuffer decodedURI() {
-        return decodedUriMB;
-    }
-
-    public CBuffer requestURI() {
-        return requestURI;
-    }
-
-    public CBuffer requestURL() {
-        CBuffer url = requestURL;
-        url.recycle();
-
-        String scheme = getScheme();
-        int port = getServerPort();
-        if (port < 0)
-            port = 80; // Work around java.net.URL bug
-
-        url.append(scheme);
-        url.append("://");
-        url.append(getServerName());
-        if ((scheme.equals("http") && (port != 80))
-            || (scheme.equals("https") && (port != 443))) {
-            url.append(':');
-            url.append(port);
-        }
-        // Decoded !!
-        url.append(getRequestURI());
-
-        return (url);
-
-    }
-
-    /**
-     * Not decoded - %xx as in original.
-     * @return
-     */
-    public String getRequestURI() {
-        return requestURI.toString();
-    }
-
-    public void setRequestURI(String encodedUri) {
-        requestURI.set(encodedUri);
-    }
-
-    CBuffer getOrAdd(String name) {
-        CBuffer header = getMimeHeaders().getHeader(name);
-        if (header == null) {
-            header = getMimeHeaders().addValue(name);
-        }
-        return header;
-    }
-
-    /**
-     * Set the Host header of the request.
-     * @param target
-     */
-    public void setHost(String target) {
-        serverNameMB.recycle();
-        getOrAdd("Host").set(target);
-    }
-
-    // XXX
-    public CBuffer serverName() {
-        if (serverNameMB.length() == 0) {
-            parseHost();
-        }
-        return serverNameMB;
-    }
-
-    public String getServerName() {
-        return serverName().toString();
-    }
-
-    public void setServerName(String name)  {
-        serverName().set(name);
-    }
-
-    public int getServerPort() {
-        serverName();
-        return serverPort;
-    }
-
-    public void setServerPort(int serverPort ) {
-        this.serverPort=serverPort;
-    }
-
-    public CBuffer remoteAddr() {
-        if (remoteAddrMB.length() == 0) {
-            HttpChannel asyncHttp = getHttpChannel();
-            IOChannel iochannel = asyncHttp.getNet().getFirst();
-            remoteAddrMB.set((String)
-                    iochannel.getAttribute(IOChannel.ATT_REMOTE_ADDRESS));
-        }
-        return remoteAddrMB;
-    }
-
-    public CBuffer remoteHost() {
-        if (remoteHostMB.length() == 0) {
-            HttpChannel asyncHttp = getHttpChannel();
-            IOChannel iochannel = asyncHttp.getNet().getFirst();
-            remoteHostMB.set((String)
-                    iochannel.getAttribute(IOChannel.ATT_REMOTE_HOSTNAME));
-        }
-        return remoteHostMB;
-    }
-
-    public CBuffer localName() {
-        return localNameMB;
-    }
-
-    public CBuffer localAddr() {
-        return localAddrMB;
-    }
-
-    public int getRemotePort(){
-        if (remotePort == -1) {
-            HttpChannel asyncHttp = getHttpChannel();
-            IOChannel iochannel = asyncHttp.getNet().getFirst();
-            remotePort = (Integer) iochannel.getAttribute(IOChannel.ATT_REMOTE_PORT);
-        }
-        return remotePort;
-    }
-
-    public void setRemotePort(int port){
-        this.remotePort = port;
-    }
-
-    public int getLocalPort(){
-        if (localPort == -1) {
-            HttpChannel asyncHttp = getHttpChannel();
-            IOChannel iochannel = asyncHttp.getNet().getFirst();
-            localPort = (Integer) iochannel.getAttribute(IOChannel.ATT_LOCAL_PORT);
-        }
-        return localPort;
-    }
-
-    public void setLocalPort(int port){
-        this.localPort = port;
-    }
-
-    public HttpResponse waitResponse() throws IOException {
-        return waitResponse(httpCh.ioTimeout);
-    }
-
-    public void send(HttpService headersCallback, long timeout) throws IOException {
-        if (headersCallback != null) {
-            httpCh.setHttpService(headersCallback);
-        }
-
-        httpCh.send();
-    }
-
-    public void send(HttpService headersCallback) throws IOException {
-        send(headersCallback, httpCh.ioTimeout);
-    }
-
-    public void send() throws IOException {
-        send(null, httpCh.ioTimeout);
-    }
-
-    public HttpResponse waitResponse(long timeout) throws IOException {
-        // TODO: close out if post
-        httpCh.send();
-
-        httpCh.headersReceivedLock.waitSignal(timeout);
-
-        return httpCh.getResponse();
-    }
-
-    /**
-     * Parse host.
-     * @param serverNameMB2
-     * @throws IOException
-     */
-    boolean parseHost()  {
-        MultiMap.Entry hostHF = getMimeHeaders().getEntry("Host");
-        if (hostHF == null) {
-            // HTTP/1.0
-            // Default is what the socket tells us. Overriden if a host is
-            // found/parsed
-            return true;
-        }
-
-        BBuffer valueBC = hostHF.valueB;
-        if (valueBC == null) {
-            valueBC = BBuffer.allocate();
-            hostHF.getValue().toAscii(valueBC);
-        }
-        byte[] valueB = valueBC.array();
-        int valueL = valueBC.getLength();
-        int valueS = valueBC.getStart();
-
-        int colonPos = valueBC.indexOf(':', 0);
-
-        serverNameMB.recycle();
-
-        boolean ipv6 = (valueB[valueS] == '[');
-        boolean bracketClosed = false;
-        for (int i = 0; i < valueL; i++) {
-            char b = (char) valueB[i + valueS];
-            if (b == ':') {
-                if (!ipv6 || bracketClosed) {
-                    colonPos = i;
-                    break;
-                }
-            }
-            serverNameMB.append(b);
-            if (b == ']') {
-                bracketClosed = true;
-            }
-        }
-
-        if (colonPos < 0) {
-            if (!ssl) {
-                setServerPort(80);
-            } else {
-                setServerPort(443);
-            }
-        } else {
-            int port = 0;
-            int mult = 1;
-            for (int i = valueL - 1; i > colonPos; i--) {
-                int charValue = Hex.DEC[(int) valueB[i + valueS]];
-                if (charValue == -1) {
-                    // we don't return 400 - could do it
-                    return false;
-                }
-                port = port + (charValue * mult);
-                mult = 10 * mult;
-            }
-            setServerPort(port);
-
-        }
-        return true;
-    }
-
-    // TODO: this is from coyote - MUST be rewritten !!!
-    // - cleaner
-    // - chunked encoding for body
-    // - buffer should be in a pool, etc.
-    /**
-     * Post data buffer.
-     */
-    public final static int CACHED_POST_LEN = 8192;
-
-    public  byte[] postData = null;
-
-    private long asyncTimeout = -1;
-
-    /**
-     * Parse request parameters.
-     */
-    protected void parseQuery() {
-
-        parametersParsed = true;
-
-        // getCharacterEncoding() may have been overridden to search for
-        // hidden form field containing request encoding
-        String enc = getEncoding();
-
-//        boolean useBodyEncodingForURI = connector.getUseBodyEncodingForURI();
-//        if (enc != null) {
-//            parameters.setEncoding(enc);
-////            if (useBodyEncodingForURI) {
-////                parameters.setQueryStringEncoding(enc);
-////            }
-//        } else {
-//            parameters.setEncoding(DEFAULT_CHARACTER_ENCODING);
-////            if (useBodyEncodingForURI) {
-////                parameters.setQueryStringEncoding
-////                    (DEFAULT_CHARACTER_ENCODING);
-////            }
-//        }
-
-        handleQueryParameters();
-    }
-
-    // Copy - will be modified by decoding
-    BBuffer decodedQuery = BBuffer.allocate(1024);
-
-    CBuffer tmpNameC = CBuffer.newInstance();
-    BBuffer tmpName = BBuffer.wrapper();
-    BBuffer tmpValue = BBuffer.wrapper();
-
-    CBuffer tmpNameCB = CBuffer.newInstance();
-    CBuffer tmpValueCB = CBuffer.newInstance();
-
-    /**
-     * Process the query string into parameters
-     */
-    public void handleQueryParameters() {
-        if( queryMB.length() == 0) {
-            return;
-        }
-
-        decodedQuery.recycle();
-        decodedQuery.append(getMsgBytes().query());
-        // TODO: option 'useBodyEncodingForUri' - versus UTF or ASCII
-        String queryStringEncoding = getEncoding();
-        processParameters( decodedQuery, queryStringEncoding );
-    }
-
-    public void processParameters( BBuffer bc, String encoding ) {
-        if( bc.isNull())
-            return;
-        if (bc.remaining() ==0) {
-            return;
-        }
-        processParameters( bc.array(), bc.getOffset(),
-                           bc.getLength(), encoding);
-    }
-
-    public void processParameters( byte bytes[], int start, int len,
-            String enc ) {
-        int end=start+len;
-        int pos=start;
-
-        do {
-            boolean noEq=false;
-            int valStart=-1;
-            int valEnd=-1;
-
-            int nameStart=pos;
-            int nameEnd=BBuffer.indexOf(bytes, nameStart, end, '=' );
-            // Workaround for a&b&c encoding
-            int nameEnd2=BBuffer.indexOf(bytes, nameStart, end, '&' );
-            if( (nameEnd2!=-1 ) &&
-                    ( nameEnd==-1 || nameEnd > nameEnd2) ) {
-                nameEnd=nameEnd2;
-                noEq=true;
-                valStart=nameEnd;
-                valEnd=nameEnd;
-            }
-            if( nameEnd== -1 )
-                nameEnd=end;
-
-            if( ! noEq ) {
-                valStart= (nameEnd < end) ? nameEnd+1 : end;
-                valEnd=BBuffer.indexOf(bytes, valStart, end, '&');
-                if( valEnd== -1 ) valEnd = (valStart < end) ? end : valStart;
-            }
-
-            pos=valEnd+1;
-
-            if( nameEnd<=nameStart ) {
-                // No name eg ...&=xx&... will trigger this
-                continue;
-            }
-
-            // TODO: use CBuffer, recycle
-            tmpName.setBytes( bytes, nameStart, nameEnd-nameStart );
-            tmpValue.setBytes( bytes, valStart, valEnd-valStart );
-
-            try {
-                parameters.add(urlDecode(tmpName, enc),
-                        urlDecode(tmpValue, enc));
-            } catch (IOException e) {
-                // ignored
-            }
-        } while( pos<end );
-    }
-
-//    public void processParameters(char bytes[], int start, int len,
-//            String enc ) {
-//        int end=start+len;
-//        int pos=start;
-//
-//        do {
-//            boolean noEq=false;
-//            int valStart=-1;
-//            int valEnd=-1;
-//
-//            int nameStart=pos;
-//            int nameEnd=CBuffer.indexOf(bytes, nameStart, end, '=' );
-//            // Workaround for a&b&c encoding
-//            int nameEnd2=CBuffer.indexOf(bytes, nameStart, end, '&' );
-//            if( (nameEnd2!=-1 ) &&
-//                    ( nameEnd==-1 || nameEnd > nameEnd2) ) {
-//                nameEnd=nameEnd2;
-//                noEq=true;
-//                valStart=nameEnd;
-//                valEnd=nameEnd;
-//            }
-//            if( nameEnd== -1 )
-//                nameEnd=end;
-//
-//            if( ! noEq ) {
-//                valStart= (nameEnd < end) ? nameEnd+1 : end;
-//                valEnd=CBuffer.indexOf(bytes, valStart, end, '&');
-//                if( valEnd== -1 ) valEnd = (valStart < end) ? end : valStart;
-//            }
-//
-//            pos=valEnd+1;
-//
-//            if( nameEnd<=nameStart ) {
-//                // No name eg ...&=xx&... will trigger this
-//                continue;
-//            }
-//
-//            // TODO: use CBuffer, recycle
-//            tmpNameCB.recycle();
-//            tmpValueCB.recycle();
-//
-//            tmpNameCB.wrap( bytes, nameStart, nameEnd );
-//            tmpValueCB.wrap( bytes, valStart, valEnd );
-//
-//            //CharChunk name = new CharChunk();
-//            //CharChunk value = new CharChunk();
-//            // TODO:
-//            try {
-//                parameters.add(urlDecode(tmpName, enc),
-//                        urlDecode(tmpValue, enc));
-//            } catch (IOException e) {
-//                // ignored
-//            }
-//        } while( pos<end );
-//    }
-
-    private String urlDecode(BBuffer bc, String enc)
-            throws IOException {
-        // Replace %xx
-        urlDecoder.urlDecode(bc, true);
-
-        String result = null;
-        if (enc != null) {
-            result = bc.toString(enc);
-        } else {
-            // Ascii
-
-            CBuffer cc = tmpNameC;
-            cc.recycle();
-            int length = bc.getLength();
-            byte[] bbuf = bc.array();
-            int start = bc.getStart();
-            cc.appendAscii(bbuf, start, length);
-            result = cc.toString();
-            cc.recycle();
-        }
-        return result;
-    }
-
-    private void processParameters( byte bytes[], int start, int len ) {
-        processParameters(bytes, start, len, getEncoding());
-    }
-
-    protected void parseBody() {
-
-        parametersParsed = true;
-        String enc = getCharacterEncoding();
-
-//      if (usingInputStream || usingReader)
-//      return;
-        if (!getMethod().equalsIgnoreCase("POST"))
-            return;
-
-        String contentType = getContentType();
-        if (contentType == null)
-            contentType = "";
-        int semicolon = contentType.indexOf(';');
-        if (semicolon >= 0) {
-            contentType = contentType.substring(0, semicolon).trim();
-        } else {
-            contentType = contentType.trim();
-        }
-        if (!("application/x-www-form-urlencoded".equals(contentType)))
-            return;
-
-        int len = getContentLength();
-
-        if (len > 0) {
-            try {
-                byte[] formData = null;
-                if (len < CACHED_POST_LEN) {
-                    if (postData == null)
-                        postData = new byte[CACHED_POST_LEN];
-                    formData = postData;
-                } else {
-                    formData = new byte[len];
-                }
-                int actualLen = readPostBody(formData, len);
-                if (actualLen == len) {
-                    processParameters(formData, 0, len);
-                }
-            } catch (Throwable t) {
-                ; // Ignore
-            }
-        }
-
-    }
-
-    /**
-     * Read post body in an array.
-     */
-    protected int readPostBody(byte body[], int len)
-        throws IOException {
-
-        int offset = 0;
-        do {
-            int inputLen = getBodyInputStream().read(body, offset, len - offset);
-            if (inputLen <= 0) {
-                return offset;
-            }
-            offset += inputLen;
-        } while ((len - offset) > 0);
-        return len;
-
-    }
-
-    // Async support - a subset of servlet spec, the fancy stuff is in the
-    // facade.
-
-    public boolean isAsyncStarted() {
-        return async;
-    }
-
-    public void async() {
-        this.async = true;
-    }
-
-    public void setAsyncTimeout(long timeout) {
-        this.asyncTimeout  = timeout;
-    }
-
-    /**
-     * Server mode, request just received.
-     */
-    protected void processReceivedHeaders() throws IOException {
-        BBuffer url = getMsgBytes().url();
-        if (url.remaining() == 0) {
-            System.err.println("No input");
-        }
-        if (url.get(0) == 'h') {
-            int firstSlash = url.indexOf('/', 0);
-            schemeMB.appendAscii(url.array(),
-                    url.getStart(), firstSlash + 2);
-            if (!schemeMB.equals("http://") &&
-                    !schemeMB.equals("https://")) {
-                httpCh.getResponse().setStatus(400);
-                httpCh.abort("Error normalizing url " +
-                        getMsgBytes().url());
-                return;
-            }
-
-            int urlStart = url.indexOf('/', firstSlash + 2);
-            serverNameMB.recycle();
-            serverNameMB.appendAscii(url.array(),
-                    url.getStart() + firstSlash + 2, urlStart - firstSlash - 2);
-
-            url.position(url.getStart() + urlStart);
-        }
-        if (!httpCh.normalize(getMsgBytes().url())) {
-            httpCh.getResponse().setStatus(400);
-            httpCh.abort("Error normalizing url " +
-                    getMsgBytes().url());
-            return;
-        }
-
-        method().set(getMsgBytes().method());
-        requestURI().set(getMsgBytes().url());
-        queryString().set(getMsgBytes().query());
-        protocol().set(getMsgBytes().protocol());
-
-        processMimeHeaders();
-
-        // URL decode and normalize
-        decodedUri.append(getMsgBytes().url());
-
-        getURLDecoder().urlDecode(decodedUri, false);
-
-        // Need to normalize again - %decoding may decode /
-        if (!httpCh.normalize(decodedUri)) {
-            httpCh.getResponse().setStatus(400);
-            httpCh.abort("Invalid decoded uri " + decodedUri);
-            return;
-        }
-        decodedURI().set(decodedUri);
-
-        // default response protocol
-        httpCh.getResponse().protocol().set(getMsgBytes().protocol());
-    }
-
-
-    public boolean hasBody() {
-        return chunked || contentLength >= 0;
-    }
-
-    /**
-     * Convert (if necessary) and return the absolute URL that represents the
-     * resource referenced by this possibly relative URL.  If this URL is
-     * already absolute, return it unchanged.
-     *
-     * @param location URL to be (possibly) converted and then returned
-     *
-     * @exception IllegalArgumentException if a MalformedURLException is
-     *  thrown when converting the relative URL to an absolute one
-     */
-    public void toAbsolute(String location, CBuffer cb) {
-
-        cb.recycle();
-        if (location == null)
-            return;
-
-        boolean leadingSlash = location.startsWith("/");
-        if (leadingSlash || !hasScheme(location)) {
-
-            String scheme = getScheme();
-            String name = serverName().toString();
-            int port = getServerPort();
-
-            cb.append(scheme);
-            cb.append("://", 0, 3);
-            cb.append(name);
-            if ((scheme.equals("http") && port != 80)
-                    || (scheme.equals("https") && port != 443)) {
-                cb.append(':');
-                String portS = port + "";
-                cb.append(portS);
-            }
-            if (!leadingSlash) {
-                String relativePath = decodedURI().toString();
-                int pos = relativePath.lastIndexOf('/');
-                relativePath = relativePath.substring(0, pos);
-
-                //String encodedURI = null;
-                urlEncoding.urlEncode(relativePath,  cb, charEncoder);
-                //encodedURI = urlEncoder.encodeURL(relativePath);
-                //redirectURLCC.append(encodedURI, 0, encodedURI.length());
-                cb.append('/');
-            }
-
-            cb.append(location);
-        } else {
-            cb.append(location);
-        }
-
-    }
-
-    /**
-     * Determine if a URI string has a <code>scheme</code> component.
-     */
-    public static boolean hasScheme(String uri) {
-        int len = uri.length();
-        for(int i=0; i < len ; i++) {
-            char c = uri.charAt(i);
-            if(c == ':') {
-                return i > 0;
-            } else if(!isSchemeChar(c)) {
-                return false;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Determine if the character is allowed in the scheme of a URI.
-     * See RFC 2396, Section 3.1
-     */
-    private static boolean isSchemeChar(char c) {
-        return Character.isLetterOrDigit(c) ||
-            c == '+' || c == '-' || c == '.';
-    }
-
-    public IOWriter getCharEncoder() {
-        return charEncoder;
-    }
-
-    public IOReader getCharDecoder() {
-        return charDecoder;
-    }
-
-    public UrlEncoding getUrlEncoding() {
-        return urlEncoding;
-    }
-
-    public BBuffer toBytes(CBuffer cb, BBuffer bb) {
-        if (bb == null) {
-            bb = BBuffer.allocate(cb.length());
-        }
-        getCharEncoder().encodeAll(cb, bb, "UTF-8");
-        return bb;
-    }
-
-    public String toString() {
-        IOBuffer out = new IOBuffer();
-        try {
-            Http11Connection.serialize(this, out);
-            return out.readAll(null).toString();
-        } catch (IOException e) {
-            return "Invalid request";
-        }
-    }
-
-    public boolean isSecure() {
-        return ssl;
-    }
-
-    public HttpRequest setSecure(boolean ssl) {
-        this.ssl = ssl;
-        return this;
-    }
-}

==================================================
HttpServer.java
deleted file mode 100644
index d616c1c4aa..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpResponse.java
+++ /dev/null
@@ -1,581 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import java.io.IOException;
-import java.util.HashMap;
-
-import org.apache.tomcat.lite.io.BBucket;
-import org.apache.tomcat.lite.io.BBuffer;
-import org.apache.tomcat.lite.io.CBuffer;
-
-public class HttpResponse extends HttpMessage {
-
-    /*
-     * Server status codes; see RFC 2068.
-     */
-
-    /**
-     * Status code (100) indicating the client can continue.
-     */
-
-    public static final int SC_CONTINUE = 100;
-
-
-    /**
-     * Status code (101) indicating the server is switching protocols
-     * according to Upgrade header.
-     */
-
-    public static final int SC_SWITCHING_PROTOCOLS = 101;
-
-    /**
-     * Status code (200) indicating the request succeeded normally.
-     */
-
-    public static final int SC_OK = 200;
-
-    /**
-     * Status code (201) indicating the request succeeded and created
-     * a new resource on the server.
-     */
-
-    public static final int SC_CREATED = 201;
-
-    /**
-     * Status code (202) indicating that a request was accepted for
-     * processing, but was not completed.
-     */
-
-    public static final int SC_ACCEPTED = 202;
-
-    /**
-     * Status code (203) indicating that the meta information presented
-     * by the client did not originate from the server.
-     */
-
-    public static final int SC_NON_AUTHORITATIVE_INFORMATION = 203;
-
-    /**
-     * Status code (204) indicating that the request succeeded but that
-     * there was no new information to return.
-     */
-
-    public static final int SC_NO_CONTENT = 204;
-
-    /**
-     * Status code (205) indicating that the agent <em>SHOULD</em> reset
-     * the document view which caused the request to be sent.
-     */
-
-    public static final int SC_RESET_CONTENT = 205;
-
-    /**
-     * Status code (206) indicating that the server has fulfilled
-     * the partial GET request for the resource.
-     */
-
-    public static final int SC_PARTIAL_CONTENT = 206;
-
-    /**
-     * Used by Webdav.
-     */
-    public static final int SC_MULTI_STATUS = 207;
-    // This one collides with HTTP 1.1
-    // "207 Partial Update OK"
-
-    /**
-     * Status code (300) indicating that the requested resource
-     * corresponds to any one of a set of representations, each with
-     * its own specific location.
-     */
-
-    public static final int SC_MULTIPLE_CHOICES = 300;
-
-    /**
-     * Status code (301) indicating that the resource has permanently
-     * moved to a new location, and that future references should use a
-     * new URI with their requests.
-     */
-
-    public static final int SC_MOVED_PERMANENTLY = 301;
-
-    /**
-     * Status code (302) indicating that the resource has temporarily
-     * moved to another location, but that future references should
-     * still use the original URI to access the resource.
-     *
-     * This definition is being retained for backwards compatibility.
-     * SC_FOUND is now the preferred definition.
-     */
-
-    public static final int SC_MOVED_TEMPORARILY = 302;
-
-    /**
-    * Status code (302) indicating that the resource reside
-    * temporarily under a different URI. Since the redirection might
-    * be altered on occasion, the client should continue to use the
-    * Request-URI for future requests.(HTTP/1.1) To represent the
-    * status code (302), it is recommended to use this variable.
-    */
-
-    public static final int SC_FOUND = 302;
-
-    /**
-     * Status code (303) indicating that the response to the request
-     * can be found under a different URI.
-     */
-
-    public static final int SC_SEE_OTHER = 303;
-
-    /**
-     * Status code (304) indicating that a conditional GET operation
-     * found that the resource was available and not modified.
-     */
-
-    public static final int SC_NOT_MODIFIED = 304;
-
-    /**
-     * Status code (305) indicating that the requested resource
-     * <em>MUST</em> be accessed through the proxy given by the
-     * <code><em>Location</em></code> field.
-     */
-
-    public static final int SC_USE_PROXY = 305;
-
-     /**
-     * Status code (307) indicating that the requested resource
-     * resides temporarily under a different URI. The temporary URI
-     * <em>SHOULD</em> be given by the <code><em>Location</em></code>
-     * field in the response.
-     */
-
-     public static final int SC_TEMPORARY_REDIRECT = 307;
-
-    /**
-     * Status code (400) indicating the request sent by the client was
-     * syntactically incorrect.
-     */
-
-    public static final int SC_BAD_REQUEST = 400;
-
-    /**
-     * Status code (401) indicating that the request requires HTTP
-     * authentication.
-     */
-
-    public static final int SC_UNAUTHORIZED = 401;
-
-    /**
-     * Status code (402) reserved for future use.
-     */
-
-    public static final int SC_PAYMENT_REQUIRED = 402;
-
-    /**
-     * Status code (403) indicating the server understood the request
-     * but refused to fulfill it.
-     */
-
-    public static final int SC_FORBIDDEN = 403;
-
-    /**
-     * Status code (404) indicating that the requested resource is not
-     * available.
-     */
-
-    public static final int SC_NOT_FOUND = 404;
-
-    /**
-     * Status code (405) indicating that the method specified in the
-     * <code><em>Request-Line</em></code> is not allowed for the resource
-     * identified by the <code><em>Request-URI</em></code>.
-     */
-
-    public static final int SC_METHOD_NOT_ALLOWED = 405;
-
-    /**
-     * Status code (406) indicating that the resource identified by the
-     * request is only capable of generating response entities which have
-     * content characteristics not acceptable according to the accept
-     * headers sent in the request.
-     */
-
-    public static final int SC_NOT_ACCEPTABLE = 406;
-
-    /**
-     * Status code (407) indicating that the client <em>MUST</em> first
-     * authenticate itself with the proxy.
-     */
-
-    public static final int SC_PROXY_AUTHENTICATION_REQUIRED = 407;
-
-    /**
-     * Status code (408) indicating that the client did not produce a
-     * request within the time that the server was prepared to wait.
-     */
-
-    public static final int SC_REQUEST_TIMEOUT = 408;
-
-    /**
-     * Status code (409) indicating that the request could not be
-     * completed due to a conflict with the current state of the
-     * resource.
-     */
-
-    public static final int SC_CONFLICT = 409;
-
-    /**
-     * Status code (410) indicating that the resource is no longer
-     * available at the server and no forwarding address is known.
-     * This condition <em>SHOULD</em> be considered permanent.
-     */
-
-    public static final int SC_GONE = 410;
-
-    /**
-     * Status code (411) indicating that the request cannot be handled
-     * without a defined <code><em>Content-Length</em></code>.
-     */
-
-    public static final int SC_LENGTH_REQUIRED = 411;
-
-    /**
-     * Status code (412) indicating that the precondition given in one
-     * or more of the request-header fields evaluated to false when it
-     * was tested on the server.
-     */
-
-    public static final int SC_PRECONDITION_FAILED = 412;
-
-    /**
-     * Status code (413) indicating that the server is refusing to process
-     * the request because the request entity is larger than the server is
-     * willing or able to process.
-     */
-
-    public static final int SC_REQUEST_ENTITY_TOO_LARGE = 413;
-
-    /**
-     * Status code (414) indicating that the server is refusing to service
-     * the request because the <code><em>Request-URI</em></code> is longer
-     * than the server is willing to interpret.
-     */
-
-    public static final int SC_REQUEST_URI_TOO_LONG = 414;
-
-    /**
-     * Status code (415) indicating that the server is refusing to service
-     * the request because the entity of the request is in a format not
-     * supported by the requested resource for the requested method.
-     */
-
-    public static final int SC_UNSUPPORTED_MEDIA_TYPE = 415;
-
-    /**
-     * Status code (416) indicating that the server cannot serve the
-     * requested byte range.
-     */
-
-    public static final int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;
-
-    /**
-     * Status code (417) indicating that the server could not meet the
-     * expectation given in the Expect request header.
-     */
-
-    public static final int SC_EXPECTATION_FAILED = 417;
-
-    /**
-     * Status code (423) indicating the destination resource of a
-     * method is locked, and either the request did not contain a
-     * valid Lock-Info header, or the Lock-Info header identifies
-     * a lock held by another principal.
-     */
-    public static final int SC_LOCKED = 423;
-
-    /**
-     * Status code (500) indicating an error inside the HTTP server
-     * which prevented it from fulfilling the request.
-     */
-
-    public static final int SC_INTERNAL_SERVER_ERROR = 500;
-
-    /**
-     * Status code (501) indicating the HTTP server does not support
-     * the functionality needed to fulfill the request.
-     */
-
-    public static final int SC_NOT_IMPLEMENTED = 501;
-
-    /**
-     * Status code (502) indicating that the HTTP server received an
-     * invalid response from a server it consulted when acting as a
-     * proxy or gateway.
-     */
-
-    public static final int SC_BAD_GATEWAY = 502;
-
-    /**
-     * Status code (503) indicating that the HTTP server is
-     * temporarily overloaded, and unable to handle the request.
-     */
-
-    public static final int SC_SERVICE_UNAVAILABLE = 503;
-
-    /**
-     * Status code (504) indicating that the server did not receive
-     * a timely response from the upstream server while acting as
-     * a gateway or proxy.
-     */
-
-    public static final int SC_GATEWAY_TIMEOUT = 504;
-
-    /**
-     * Status code (505) indicating that the server does not support
-     * or refuses to support the HTTP protocol version that was used
-     * in the request message.
-     */
-
-    public static final int SC_HTTP_VERSION_NOT_SUPPORTED = 505;
-
-    // will not be recycled
-    public Object nativeResponse;
-
-    protected CBuffer message = CBuffer.newInstance();
-
-    int status = -1;
-
-    HttpResponse(HttpChannel httpCh) {
-        super(httpCh);
-    }
-
-    public void recycle() {
-        super.recycle();
-        message.recycle();
-        status = -1;
-    }
-
-    public void setMessage(String s) {
-        message.set(filter(s));
-    }
-
-    public String getMessage() {
-        return message.toString();
-    }
-
-    public CBuffer getMessageBuffer() {
-        return message;
-    }
-
-    byte[] S_200 = new byte[] { '2', '0', '0' };
-
-    public void setStatus(int i) {
-        status = i;
-    }
-
-    public void sendError(int status) {
-        this.status = status;
-    }
-
-    public void sendError(int status, String msg) {
-        message.set(msg);
-    }
-
-    public int getStatus() {
-        if (status >= 0) {
-            return status;
-        }
-        if (getMsgBytes().status().isNull()) {
-            status = 200;
-        } else {
-            try {
-                status = getMsgBytes().status().getInt();
-            } catch(NumberFormatException ex) {
-                status = 500;
-                httpCh.log.severe("Invalid status " + getMsgBytes().status());
-            }
-        }
-        return status;
-    }
-
-    public HttpRequest getRequest() {
-        return getHttpChannel().getRequest();
-    }
-
-    // Http client mode.
-    protected void processReceivedHeaders() throws IOException {
-        protocol().set(getMsgBytes().protocol());
-        message.set(getMsgBytes().message());
-        processMimeHeaders();
-        // TODO: if protocol == 1.0 and we requested 1.1, downgrade getHttpChannel().pro
-        try {
-            status = getStatus();
-        } catch (Throwable t) {
-            getHttpChannel().log.warning("Invalid status " + getMsgBytes().status() + " " + getMessage());
-        }
-    }
-
-    /**
-     * All responses to the HEAD request method MUST NOT include a
-     * message-body, even though the presence of entity- header fields might
-     *  lead one to believe they do. All 1xx (informational), 204 (no content)
-     *  , and 304 (not modified) responses MUST NOT include a message-body. All
-     *  other responses do include a message-body, although it MAY be of zero
-     *  length.
-     */
-    public boolean hasBody() {
-        if (httpCh.getRequest().method().equals("HEAD")) {
-            return false;
-        }
-        if (status >= 100 && status < 200) {
-            return false;
-        }
-        // what about (status == 205) ?
-        if ((status == 204)
-                || (status == 304)) {
-            return false;
-        }
-        return true;
-    }
-
-    /** Get the status string associated with a status code.
-     *  No I18N - return the messages defined in the HTTP spec.
-     *  ( the user isn't supposed to see them, this is the last
-     *  thing to translate)
-     *
-     *  Common messages are cached.
-     *
-     */
-    static BBucket getMessage( int status ) {
-        // method from Response.
-
-        // Does HTTP requires/allow international messages or
-        // are pre-defined? The user doesn't see them most of the time
-        switch( status ) {
-        case 200:
-            return st_200;
-        case 302:
-            return st_302;
-        case 400:
-            return st_400;
-        case 404:
-            return st_404;
-        }
-        BBucket bb = stats.get(status);
-        if (bb == null) {
-            return st_unknown;
-        }
-        return bb;
-    }
-
-    public static String getStatusText(int code) {
-        return getMessage(code).toString();
-    }
-
-    static BBucket st_unknown = BBuffer.wrapper("No Message");
-    static BBucket st_200 = BBuffer.wrapper("OK");
-    static BBucket st_302= BBuffer.wrapper("Moved Temporarily");
-    static BBucket st_400= BBuffer.wrapper("Bad Request");
-    static BBucket st_404= BBuffer.wrapper("Not Found");
-
-    static HashMap<Integer,BBucket> stats = new HashMap<Integer, BBucket>();
-    private static void addStatus(int stat, String msg) {
-        stats.put(stat, BBuffer.wrapper(msg));
-    }
-
-    static {
-        addStatus(100, "Continue");
-        addStatus(101, "Switching Protocols");
-        addStatus(200, "OK");
-        addStatus(201, "Created");
-        addStatus(202, "Accepted");
-        addStatus(203, "Non-Authoritative Information");
-        addStatus(204, "No Content");
-        addStatus(205, "Reset Content");
-        addStatus(206, "Partial Content");
-        addStatus(207, "Multi-Status");
-        addStatus(300, "Multiple Choices");
-        addStatus(301, "Moved Permanently");
-        addStatus(302, "Moved Temporarily");
-        addStatus(303, "See Other");
-        addStatus(304, "Not Modified");
-        addStatus(305, "Use Proxy");
-        addStatus(307, "Temporary Redirect");
-        addStatus(400, "Bad Request");
-        addStatus(401, "Unauthorized");
-        addStatus(402, "Payment Required");
-        addStatus(403, "Forbidden");
-        addStatus(404, "Not Found");
-        addStatus(405, "Method Not Allowed");
-        addStatus(406, "Not Acceptable");
-        addStatus(407, "Proxy Authentication Required");
-        addStatus(408, "Request Timeout");
-        addStatus(409, "Conflict");
-        addStatus(410, "Gone");
-        addStatus(411, "Length Required");
-        addStatus(412, "Precondition Failed");
-        addStatus(413, "Request Entity Too Large");
-        addStatus(414, "Request-URI Too Long");
-        addStatus(415, "Unsupported Media Type");
-        addStatus(416, "Requested Range Not Satisfiable");
-        addStatus(417, "Expectation Failed");
-        addStatus(422, "Unprocessable Entity");
-        addStatus(423, "Locked");
-        addStatus(424, "Failed Dependency");
-        addStatus(500, "Internal Server Error");
-        addStatus(501, "Not Implemented");
-        addStatus(502, "Bad Gateway");
-        addStatus(503, "Service Unavailable");
-        addStatus(504, "Gateway Timeout");
-        addStatus(505, "HTTP Version Not Supported");
-        addStatus(507, "Insufficient Storage");
-        addStatus(SC_LOCKED, "Locked");
-
-
-    }
-
-    /**
-     * Filter the specified message string for characters that are sensitive
-     * in HTML.  This avoids potential attacks caused by including JavaScript
-     * codes in the request URL that is often reported in error messages.
-     *
-     * @param message The message string to be filtered
-     */
-    private static String filter(String message) {
-
-        if (message == null)
-            return (null);
-        if (message.indexOf('<') < 0 &&
-                message.indexOf('>') < 0 &&
-                message.indexOf('&') < 0 &&
-                message.indexOf('"') < 0) {
-            return message;
-        }
-
-        char content[] = new char[message.length()];
-        message.getChars(0, message.length(), content, 0);
-
-        StringBuffer result = new StringBuffer(content.length + 50);
-        for (int i = 0; i < content.length; i++) {
-            switch (content[i]) {
-            case '<':
-                result.append("&lt;");
-                break;
-            case '>':
-                result.append("&gt;");
-                break;
-            case '&':
-                result.append("&amp;");
-                break;
-            case '"':
-                result.append("&quot;");
-                break;
-            default:
-                result.append(content[i]);
-            }
-        }
-        return (result.toString());
-    }
-
-}

==================================================
HttpWriter.java
deleted file mode 100644
index 799e4c42e1..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpServer.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import org.apache.tomcat.lite.io.SocketConnector;
-import org.apache.tomcat.lite.io.SslProvider;
-import org.apache.tomcat.lite.io.jsse.JsseSslProvider;
-
-/**
- * Main entry point for HTTP server code.
- *
- * ( initial draft - will replace statics, add helpers, etc )
- */
-public class HttpServer {
-    static SslProvider sslConC = new JsseSslProvider();
-
-    public synchronized static HttpConnector newServer(int port) {
-        return new HttpConnector(new SocketConnector()).
-            withSsl(sslConC).setPort(port);
-    }
-
-    public synchronized static HttpConnector newSslServer(int port) {
-        // DHE broken in harmony - will replace with a flag
-        //      SslConnector.setEnabledCiphers(new String[] {
-        //              "TLS_RSA_WITH_3DES_EDE_CBC_SHA"
-        //      });
-        // -cipher DES-CBC3-SHA
-
-        SslProvider sslCon = new JsseSslProvider();
-
-        return new HttpConnector(new SocketConnector()).
-            withSsl(sslCon).setPort(port).setServerSsl(true);
-    }
-
-}

==================================================
MappingData.java
deleted file mode 100644
index b18e0aced2..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/HttpWriter.java
+++ /dev/null
@@ -1,313 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import java.io.IOException;
-import java.io.Writer;
-
-import org.apache.tomcat.lite.io.IOOutputStream;
-import org.apache.tomcat.lite.io.IOWriter;
-
-/**
- * Implement character translation and buffering.
- *
- * The actual buffering happens in the IOBuffer - we translate the
- * chars as soon as we get them.
- *
- * For servlet compat you can set a buffer size and a flush() will happen
- * when the number of chars have been written. Note that writes at a lower
- * layer can be done and are not counted.
- *
- * @author Costin Manolache
- */
-public class HttpWriter extends Writer {
-
-    public static final String DEFAULT_ENCODING = "ISO-8859-1";
-    public static final int DEFAULT_BUFFER_SIZE = 8*1024;
-
-    // ----------------------------------------------------- Instance Variables
-    HttpMessage message;
-
-    /**
-     * The byte buffer.
-     */
-    protected IOOutputStream bb;
-
-    int bufferSize = DEFAULT_BUFFER_SIZE;
-
-    /**
-     * Number of chars written.
-     */
-    protected int wSinceFlush = 0;
-
-
-    /**
-     * Flag which indicates if the output buffer is closed.
-     */
-    protected boolean closed = false;
-
-    /**
-     * Encoding to use.
-     * TODO: isn't it redundant ? enc, gotEnc, conv plus the enc in the bb
-     */
-    protected String enc;
-
-
-    /**
-     * Encoder is set.
-     */
-    protected boolean gotEnc = false;
-
-
-    /**
-     * List of encoders. The writer is reused - the encoder mapping
-     * avoids creating expensive objects. In future it'll contain nio.Charsets
-     */
-    //protected Map<String, C2BConverter> encoders = new HashMap();
-
-
-    /**
-     * Current char to byte converter. TODO: replace with Charset
-     */
-    private IOWriter conv;
-
-    /**
-     * Suspended flag. All output bytes will be swallowed if this is true.
-     */
-    protected boolean suspended = false;
-
-
-    // ----------------------------------------------------------- Constructors
-
-
-    /**
-     * Default constructor. Allocate the buffer with the default buffer size.
-     * @param out
-     */
-    public HttpWriter(HttpMessage message, IOOutputStream out,
-            IOWriter conv) {
-        this.message = message;
-        bb = out;
-        this.conv = conv;
-    }
-
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * Is the response output suspended ?
-     *
-     * @return suspended flag value
-     */
-    public boolean isSuspended() {
-        return this.suspended;
-    }
-
-
-    /**
-     * Set the suspended flag.
-     *
-     * @param suspended New suspended flag value
-     */
-    public void setSuspended(boolean suspended) {
-        this.suspended = suspended;
-    }
-
-
-    // --------------------------------------------------------- Public Methods
-
-
-    /**
-     * Recycle the output buffer.
-     */
-    public void recycle() {
-        wSinceFlush = 0;
-        bb.recycle();
-        closed = false;
-        suspended = false;
-
-//        if (conv != null) {
-//            conv.recycle();
-//        }
-
-        gotEnc = false;
-        enc = null;
-    }
-
-    public void close()
-        throws IOException {
-
-        if (closed)
-            return;
-        if (suspended)
-            return;
-
-        push();
-        closed = true;
-
-        bb.close();
-    }
-
-
-    /**
-     * Flush bytes or chars contained in the buffer.
-     *
-     * @throws IOException An underlying IOException occurred
-     */
-    public void flush()
-            throws IOException {
-        push();
-        bb.flush(); // will send the data
-        wSinceFlush = 0;
-    }
-
-    /**
-     * Flush chars to the byte buffer.
-     */
-    public void push()
-        throws IOException {
-
-        if (suspended)
-            return;
-        getConv().push();
-
-    }
-
-
-    private void updateSize(int cnt) throws IOException {
-        wSinceFlush += cnt;
-        if (wSinceFlush > bufferSize) {
-            flush();
-        }
-    }
-
-    public void write(int c)
-            throws IOException {
-        if (suspended)
-            return;
-        getConv().write(c);
-        updateSize(1);
-    }
-
-
-    public void write(char c[])
-            throws IOException {
-        write(c, 0, c.length);
-    }
-
-
-    public void write(char c[], int off, int len)
-            throws IOException {
-        if (suspended)
-            return;
-        getConv().write(c, off, len);
-        updateSize(len);
-    }
-
-
-    public void write(StringBuffer sb)
-            throws IOException {
-        if (suspended)
-            return;
-        int len = sb.length();
-        getConv().write(sb.toString());
-        updateSize(len);
-    }
-
-
-    /**
-     * Append a string to the buffer
-     */
-    public void write(String s, int off, int len)
-        throws IOException {
-        if (suspended)
-            return;
-        if (s==null)
-            s="null";
-        getConv().write( s, off, len );
-        updateSize(len);
-    }
-
-
-    public void write(String s)
-            throws IOException {
-        if (s==null)
-            s="null";
-        write(s, 0, s.length());
-    }
-
-    public void println() throws IOException {
-        write("\n");
-    }
-
-    public void println(String s) throws IOException {
-        write(s);
-        write("\n");
-    }
-
-    public void print(String s) throws IOException {
-        write(s);
-    }
-
-    public void checkConverter()
-            throws IOException {
-//        if (gotEnc) {
-//            return;
-//        }
-//        if (enc == null) {
-//            enc = message.getCharacterEncoding();
-//        }
-//
-//        gotEnc = true;
-//        if (enc == null)
-//            enc = DEFAULT_ENCODING;
-//        conv = (C2BConverter) encoders.get(enc);
-//
-//        if (conv == null) {
-//            conv = C2BConverter.newConverter(message.getBodyOutputStream(),
-//                    enc);
-//            encoders.put(enc, conv);
-//
-//        }
-    }
-
-    public int getWrittenSinceFlush() {
-        return wSinceFlush;
-    }
-
-
-    public void setBufferSize(int size) {
-        if (size > bufferSize) {
-            bufferSize = size;
-        }
-    }
-
-    /**
-     *  Clear any data that was buffered.
-     */
-    public void reset() {
-        if (conv != null) {
-            conv.recycle();
-        }
-        wSinceFlush = 0;
-        gotEnc = false;
-        enc = null;
-        bb.reset();
-    }
-
-
-    public int getBufferSize() {
-        return bufferSize;
-    }
-
-    protected IOWriter getConv() throws IOException {
-        checkConverter();
-        return conv;
-    }
-
-    public void println(CharSequence key) throws IOException {
-        // TODO: direct
-        println(key.toString());
-    }
-
-}

==================================================
MultiMap.java
deleted file mode 100644
index 1b8d939936..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/MappingData.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.lite.http;
-
-import org.apache.tomcat.lite.io.CBuffer;
-
-
-/**
- * Mapping data.
- *
- * @author Remy Maucherat
- */
-public class MappingData {
-
-    public Object context = null; // ServletContextImpl
-
-    public BaseMapper.Context contextMap;
-
-    public BaseMapper.ServiceMapping service = null;
-
-    public CBuffer contextPath = CBuffer.newInstance();
-    public CBuffer requestPath = CBuffer.newInstance();
-    public CBuffer wrapperPath = CBuffer.newInstance();
-    public CBuffer pathInfo = CBuffer.newInstance();
-
-    public CBuffer redirectPath = CBuffer.newInstance();
-
-    // Extension
-    CBuffer ext = CBuffer.newInstance();
-    CBuffer tmpPrefix = CBuffer.newInstance();
-
-    // Excluding context path, with a '/' added if needed
-    CBuffer tmpServletPath = CBuffer.newInstance();
-
-    // Excluding context path, with a '/' added if needed
-    CBuffer tmpWelcome = CBuffer.newInstance();
-
-    public void recycle() {
-        service = null;
-        context = null;
-        pathInfo.recycle();
-        requestPath.recycle();
-        wrapperPath.recycle();
-        contextPath.recycle();
-        redirectPath.recycle();
-        contextMap = null;
-    }
-
-
-    public Object getServiceObject() {
-        return service == null ? null : service.object;
-    }
-
-}

==================================================
ServerCookie.java
deleted file mode 100644
index 7b8fb143b6..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/MultiMap.java
+++ /dev/null
@@ -1,357 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.lite.http;
-
-import java.util.ArrayList;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.tomcat.lite.io.BBuffer;
-import org.apache.tomcat.lite.io.CBucket;
-import org.apache.tomcat.lite.io.CBuffer;
-
-/**
- * Map used to represent headers and parameters ( could be used
- * for cookies too )
- *
- * It'll avoid garbage collection, like original tomcat classes,
- * by converting to chars and strings late.
- *
- * Not thread safe.
- */
-public class MultiMap {
-
-    public static class Entry {
-        // Wrappers from the head message bytes.
-        BBuffer nameB;
-        BBuffer valueB;
-
-        CBuffer key = CBuffer.newInstance();
-        private CBuffer value = CBuffer.newInstance();
-
-        /**
-         * For the first entry with a given name: list of all
-         * other entries, including this one, with same name.
-         *
-         * For second or more: empty list
-         */
-        public List<Entry> values = new ArrayList<Entry>();
-
-        public void recycle() {
-            key.recycle();
-            value.recycle();
-            //next=null;
-            nameB = null;
-            valueB = null;
-            values.clear();
-        }
-
-        public CBuffer getName() {
-            if (key.length() == 0 && nameB != null) {
-                key.set(nameB);
-            }
-            return key;
-        }
-
-        public CBuffer getValue() {
-            if (value.length() == 0 && valueB != null) {
-                value.set(valueB);
-            }
-            return value;
-        }
-
-        /** Important - used by values iterator, returns strings
-         * from each entry
-         */
-        public String toString() {
-            return getValue().toString();
-        }
-
-    }
-
-    // active entries
-    protected int count;
-
-    // The key will be converted to lower case
-    boolean toLower = false;
-
-    // Some may be inactive - up to count.
-    protected List<Entry> entries = new ArrayList<Entry>();
-
-    // 2 options: convert all header/param names to String
-    // or use a temp CBuffer to map
-    Map<CBuffer, Entry> map =
-        new HashMap<CBuffer, Entry>();
-
-    public void recycle() {
-        for (int i = 0; i < count; i++) {
-            Entry entry = entries.get(i);
-            entry.recycle();
-        }
-        count = 0;
-        map.clear();
-    }
-
-    // ----------- Mutations ------------------------
-
-    protected Entry newEntry()  {
-        return new Entry();
-    }
-
-    /**
-     * Adds a partially constructed field entry.
-     * Updates count - but will not affect the map.
-     */
-    private Entry getEntryForAdd() {
-        Entry entry;
-        if (count >= entries.size()) {
-            entry = newEntry();
-            entries.add(entry);
-        } else {
-            entry = entries.get(count);
-        }
-        count++;
-        return entry;
-    }
-
-
-    /** Create a new named header , return the CBuffer
-     *  container for the new value
-     */
-   public Entry addEntry(CharSequence name ) {
-       Entry mh = getEntryForAdd();
-       mh.getName().append(name);
-       if (toLower) {
-           mh.getName().toLower();
-       }
-       updateMap(mh);
-       return mh;
-   }
-
-   /** Create a new named header , return the CBuffer
-    *  container for the new value
-    */
-   public Entry addEntry(BBuffer name ) {
-       Entry mh = getEntryForAdd();
-       mh.nameB = name;
-       if (toLower) {
-           mh.getName().toLower();
-       }
-       updateMap(mh);
-
-       return mh;
-   }
-
-   private void updateMap(Entry mh) {
-       Entry topEntry = map.get(mh.getName());
-
-       if (topEntry == null) {
-           map.put(mh.getName(), mh);
-           mh.values.add(mh);
-       } else {
-           topEntry.values.add(mh);
-       }
-   }
-
-
-
-    public void remove(CharSequence key) {
-        CBucket ckey = key(key);
-        Entry entry = getEntry(ckey);
-        if (entry != null) {
-            map.remove(ckey);
-
-            for (int i = count - 1; i >= 0; i--) {
-                entry = entries.get(i);
-                if (entry.getName().equals(key)) {
-                    entry.recycle();
-                    entries.remove(i);
-                    count--;
-                }
-            }
-        }
-    }
-
-    // --------------- Key-based access --------------
-    CBuffer tmpKey = CBuffer.newInstance();
-
-    /**
-     * Finds and returns a header field with the given name.  If no such
-     * field exists, null is returned.  If more than one such field is
-     * in the header, an arbitrary one is returned.
-     */
-    public CBuffer getHeader(String name) {
-        for (int i = 0; i < count; i++) {
-            if (entries.get(i).getName().equalsIgnoreCase(name)) {
-                return entries.get(i).getValue();
-            }
-        }
-        return null;
-    }
-
-    private CBucket key(CharSequence key) {
-        if (key instanceof CBucket) {
-            CBucket res = (CBucket) key;
-            if (!toLower || !res.hasUpper()) {
-                return res;
-            }
-        }
-        tmpKey.recycle();
-        tmpKey.append(key);
-        if (toLower) {
-            tmpKey.toLower();
-        }
-        return tmpKey;
-    }
-
-    public Entry getEntry(CharSequence key) {
-        Entry entry = map.get(key(key));
-        return entry;
-    }
-
-    public Entry getEntry(CBucket buf) {
-        // lowercase ?
-        Entry entry = map.get(buf);
-        return entry;
-    }
-
-    public Enumeration<String> names() {
-        return new IteratorEnumerator(map.keySet().iterator());
-    }
-
-    // ----------- Index access --------------
-
-    /**
-     *  Number of entries ( including those with same key
-     *
-     * @return
-     */
-    public int size() {
-        return count;
-    }
-
-
-    public CharSequence getKey(int idx) {
-        return entries.get(idx).key;
-    }
-
-    public Entry getEntry(int idx) {
-        return entries.get(idx);
-    }
-
-    /**
-     * Returns the Nth header name, or null if there is no such header.
-     * This may be used to iterate through all header fields.
-     */
-    public CBuffer getName(int n) {
-        return n < count ? entries.get(n).getName() : null;
-    }
-
-    /**
-     * Returns the Nth header value, or null if there is no such header.
-     * This may be used to iterate through all header fields.
-     */
-    public CBuffer getValue(int n) {
-        return n >= 0 && n < count ? entries.get(n).getValue() : null;
-    }
-
-    // ----------- Helpers --------------
-    public void add(CharSequence key, CharSequence value) {
-        Entry mh = addEntry(key);
-        mh.value.append(value);
-    }
-
-    /** Create a new named header , return the CBuffer
-     * container for the new value
-     */
-    public CBuffer addValue( String name ) {
-        return addEntry(name).getValue();
-    }
-
-     public Entry setEntry( String name ) {
-         remove(name);
-         return addEntry(name);
-     }
-
-     public void set(CharSequence key, CharSequence value) {
-         remove(key);
-         add(key, value);
-     }
-
-     public CBuffer setValue( String name ) {
-         remove(name);
-         return addValue(name);
-     }
-
-     public CBuffer get(CharSequence key) {
-         Entry entry = getEntry(key);
-         return (entry == null) ? null : entry.value;
-     }
-
-     public String getString(CharSequence key) {
-         Entry entry = getEntry(key);
-         return (entry == null) ? null : entry.value.toString();
-     }
-
-
-    // -------------- support classes ----------------
-
-    public static class IteratorEnumerator implements Enumeration<String> {
-        private final Iterator keyI;
-
-        public IteratorEnumerator(Iterator iterator) {
-            this.keyI = iterator;
-        }
-
-
-        public boolean hasMoreElements() {
-            return keyI.hasNext();
-        }
-
-
-        public String nextElement() {
-            return keyI.next().toString();
-        }
-
-    }
-
-    public static final Enumeration<String> EMPTY =
-        new Enumeration<String>() {
-
-            @Override
-            public boolean hasMoreElements() {
-                return false;
-            }
-
-            @Override
-            public String nextElement() {
-                return null;
-            }
-
-    };
-
-    public MultiMap insensitive() {
-        toLower = true;
-        return this;
-    }
-
-
-}

==================================================
SpdyConnection.java
deleted file mode 100644
index 4cf66f2b79..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/http/ServerCookie.java
+++ /dev/null
@@ -1,819 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.lite.http;
-
-import java.io.Serializable;
-import java.text.DateFormat;
-import java.text.FieldPosition;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.TimeZone;
-
-import org.apache.tomcat.lite.io.BBuffer;
-import org.apache.tomcat.lite.io.CBuffer;
-
-
-/**
- *  Server-side cookie representation.
- *  Allows recycling and uses MessageBytes as low-level
- *  representation ( and thus the byte-> char conversion can be delayed
- *  until we know the charset ).
- *
- *  Tomcat.core uses this recyclable object to represent cookies,
- *  and the facade will convert it to the external representation.
- */
-public class ServerCookie implements Serializable {
-
-    // Version 0 (Netscape) attributes
-    private BBuffer name = BBuffer.allocate();
-    private BBuffer value = BBuffer.allocate();
-
-    private CBuffer nameC = CBuffer.newInstance();
-
-    // Expires - Not stored explicitly. Generated from Max-Age (see V1)
-    private BBuffer path = BBuffer.allocate();
-    private BBuffer domain = BBuffer.allocate();
-    private boolean secure;
-
-    // Version 1 (RFC2109) attributes
-    private BBuffer comment = BBuffer.allocate();
-    private int maxAge = -1;
-    private int version = 0;
-
-    // Other fields
-    private static final String OLD_COOKIE_PATTERN =
-        "EEE, dd-MMM-yyyy HH:mm:ss z";
-    private static final ThreadLocal<DateFormat> OLD_COOKIE_FORMAT =
-        new ThreadLocal<DateFormat>() {
-        protected DateFormat initialValue() {
-            DateFormat df =
-                new SimpleDateFormat(OLD_COOKIE_PATTERN, Locale.US);
-            df.setTimeZone(TimeZone.getTimeZone("GMT"));
-            return df;
-        }
-    };
-
-    private static final String ancientDate;
-
-
-    static {
-        ancientDate = OLD_COOKIE_FORMAT.get().format(new Date(10000));
-    }
-
-    /**
-     * If set to true, we parse cookies according to the servlet spec,
-     */
-    public static final boolean STRICT_SERVLET_COMPLIANCE =
-        Boolean.valueOf(System.getProperty("org.apache.catalina.STRICT_SERVLET_COMPLIANCE", "false")).booleanValue();
-
-    /**
-     * If set to false, we don't use the IE6/7 Max-Age/Expires work around
-     */
-    public static final boolean ALWAYS_ADD_EXPIRES =
-        Boolean.valueOf(System.getProperty("org.apache.tomcat.util.http.ServerCookie.ALWAYS_ADD_EXPIRES", "true")).booleanValue();
-
-    // Note: Servlet Spec =< 2.5 only refers to Netscape and RFC2109,
-    // not RFC2965
-
-    // Version 1 (RFC2965) attributes
-    // TODO Add support for CommentURL
-    // Discard - implied by maxAge <0
-    // TODO Add support for Port
-
-    public ServerCookie() {
-    }
-
-    public void recycle() {
-        path.recycle();
-        name.recycle();
-        value.recycle();
-        comment.recycle();
-        maxAge=-1;
-        path.recycle();
-        domain.recycle();
-        version=0;
-        secure=false;
-    }
-
-    public BBuffer getComment() {
-        return comment;
-    }
-
-    public BBuffer getDomain() {
-        return domain;
-    }
-
-    public void setMaxAge(int expiry) {
-        maxAge = expiry;
-    }
-
-    public int getMaxAge() {
-        return maxAge;
-    }
-
-    public BBuffer getPath() {
-        return path;
-    }
-
-    public void setSecure(boolean flag) {
-        secure = flag;
-    }
-
-    public boolean getSecure() {
-        return secure;
-    }
-
-    public BBuffer getName() {
-        return name;
-    }
-
-    public BBuffer getValue() {
-        return value;
-    }
-
-    public int getVersion() {
-        return version;
-    }
-
-    public void setVersion(int v) {
-        version = v;
-    }
-
-
-    // -------------------- utils --------------------
-
-    public String toString() {
-        return "Cookie " + getName() + "=" + getValue() + " ; "
-            + getVersion() + " " + getPath() + " " + getDomain();
-    }
-
-    private static final String tspecials = ",; ";
-    private static final String tspecials2 = "()<>@,;:\\\"/[]?={} \t";
-    private static final String tspecials2NoSlash = "()<>@,;:\\\"[]?={} \t";
-
-    /*
-     * Tests a string and returns true if the string counts as a
-     * reserved token in the Java language.
-     *
-     * @param value the <code>String</code> to be tested
-     *
-     * @return      <code>true</code> if the <code>String</code> is a reserved
-     *              token; <code>false</code> if it is not
-     */
-    public static boolean isToken(String value) {
-        return isToken(value,null);
-    }
-
-    public static boolean isToken(String value, String literals) {
-        String tspecials = (literals==null?ServerCookie.tspecials:literals);
-        if( value==null) return true;
-        int len = value.length();
-
-        for (int i = 0; i < len; i++) {
-            char c = value.charAt(i);
-
-            if (tspecials.indexOf(c) != -1)
-                return false;
-        }
-        return true;
-    }
-
-    public static boolean containsCTL(String value, int version) {
-        if( value==null) return false;
-        int len = value.length();
-        for (int i = 0; i < len; i++) {
-            char c = value.charAt(i);
-            if (c < 0x20 || c >= 0x7f) {
-                if (c == 0x09)
-                    continue; //allow horizontal tabs
-                return true;
-            }
-        }
-        return false;
-    }
-
-    public static boolean isToken2(String value) {
-        return isToken2(value,null);
-    }
-
-    public static boolean isToken2(String value, String literals) {
-        String tspecials2 = (literals==null?ServerCookie.tspecials2:literals);
-        if( value==null) return true;
-        int len = value.length();
-
-        for (int i = 0; i < len; i++) {
-            char c = value.charAt(i);
-            if (tspecials2.indexOf(c) != -1)
-                return false;
-        }
-        return true;
-    }
-
-    // -------------------- Cookie parsing tools
-
-
-    /**
-     * Return the header name to set the cookie, based on cookie version.
-     */
-    public String getCookieHeaderName() {
-        return getCookieHeaderName(version);
-    }
-
-    /**
-     * Return the header name to set the cookie, based on cookie version.
-     */
-    public static String getCookieHeaderName(int version) {
-        // TODO Re-enable logging when RFC2965 is implemented
-        // log( (version==1) ? "Set-Cookie2" : "Set-Cookie");
-        if (version == 1) {
-            // XXX RFC2965 not referenced in Servlet Spec
-            // Set-Cookie2 is not supported by Netscape 4, 6, IE 3, 5
-            // Set-Cookie2 is supported by Lynx and Opera
-            // Need to check on later IE and FF releases but for now...
-            // RFC2109
-            return "Set-Cookie";
-            // return "Set-Cookie2";
-        } else {
-            // Old Netscape
-            return "Set-Cookie";
-        }
-    }
-
-    // TODO RFC2965 fields also need to be passed
-    public static void appendCookieValue( StringBuffer headerBuf,
-                                          int version,
-                                          String name,
-                                          String value,
-                                          String path,
-                                          String domain,
-                                          String comment,
-                                          int maxAge,
-                                          boolean isSecure,
-                                          boolean isHttpOnly)
-    {
-        StringBuffer buf = new StringBuffer();
-        // Servlet implementation checks name
-        buf.append( name );
-        buf.append("=");
-        // Servlet implementation does not check anything else
-
-        version = maybeQuote2(version, buf, value,true);
-
-        // Add version 1 specific information
-        if (version == 1) {
-            // Version=1 ... required
-            buf.append ("; Version=1");
-
-            // Comment=comment
-            if ( comment!=null ) {
-                buf.append ("; Comment=");
-                maybeQuote2(version, buf, comment);
-            }
-        }
-
-        // Add domain information, if present
-        if (domain!=null) {
-            buf.append("; Domain=");
-            maybeQuote2(version, buf, domain);
-        }
-
-        // Max-Age=secs ... or use old "Expires" format
-        // TODO RFC2965 Discard
-        if (maxAge >= 0) {
-            if (version > 0) {
-                buf.append ("; Max-Age=");
-                buf.append (maxAge);
-            }
-            // IE6, IE7 and possibly other browsers don't understand Max-Age.
-            // They do understand Expires, even with V1 cookies!
-            if (version == 0 || ALWAYS_ADD_EXPIRES) {
-                // Wdy, DD-Mon-YY HH:MM:SS GMT ( Expires Netscape format )
-                buf.append ("; Expires=");
-                // To expire immediately we need to set the time in past
-                if (maxAge == 0)
-                    buf.append( ancientDate );
-                else
-                    OLD_COOKIE_FORMAT.get().format(
-                            new Date(System.currentTimeMillis() +
-                                    maxAge*1000L),
-                            buf, new FieldPosition(0));
-            }
-        }
-
-        // Path=path
-        if (path!=null) {
-            buf.append ("; Path=");
-            if (version==0) {
-                maybeQuote2(version, buf, path);
-            } else {
-                maybeQuote2(version, buf, path, ServerCookie.tspecials2NoSlash, false);
-            }
-        }
-
-        // Secure
-        if (isSecure) {
-          buf.append ("; Secure");
-        }
-
-        // HttpOnly
-        if (isHttpOnly) {
-            buf.append("; HttpOnly");
-        }
-        headerBuf.append(buf);
-    }
-
-    public static boolean alreadyQuoted (String value) {
-        if (value==null || value.length()==0) return false;
-        return (value.charAt(0)=='\"' && value.charAt(value.length()-1)=='\"');
-    }
-
-    /**
-     * Quotes values using rules that vary depending on Cookie version.
-     * @param version
-     * @param buf
-     * @param value
-     */
-    public static int maybeQuote2 (int version, StringBuffer buf, String value) {
-        return maybeQuote2(version,buf,value,false);
-    }
-
-    public static int maybeQuote2 (int version, StringBuffer buf, String value, boolean allowVersionSwitch) {
-        return maybeQuote2(version,buf,value,null,allowVersionSwitch);
-    }
-
-    public static int maybeQuote2 (int version, StringBuffer buf, String value, String literals, boolean allowVersionSwitch) {
-        if (value==null || value.length()==0) {
-            buf.append("\"\"");
-        }else if (containsCTL(value,version))
-            throw new IllegalArgumentException("Control character in cookie value, consider BASE64 encoding your value");
-        else if (alreadyQuoted(value)) {
-            buf.append('"');
-            buf.append(escapeDoubleQuotes(value,1,value.length()-1));
-            buf.append('"');
-        } else if (allowVersionSwitch && (!STRICT_SERVLET_COMPLIANCE) && version==0 && !isToken2(value, literals)) {
-            buf.append('"');
-            buf.append(escapeDoubleQuotes(value,0,value.length()));
-            buf.append('"');
-            version = 1;
-        } else if (version==0 && !isToken(value,literals)) {
-            buf.append('"');
-            buf.append(escapeDoubleQuotes(value,0,value.length()));
-            buf.append('"');
-        } else if (version==1 && !isToken2(value,literals)) {
-            buf.append('"');
-            buf.append(escapeDoubleQuotes(value,0,value.length()));
-            buf.append('"');
-        }else {
-            buf.append(value);
-        }
-        return version;
-    }
-
-
-    /**
-     * Escapes any double quotes in the given string.
-     *
-     * @param s the input string
-     * @param beginIndex start index inclusive
-     * @param endIndex exclusive
-     * @return The (possibly) escaped string
-     */
-    private static String escapeDoubleQuotes(String s, int beginIndex, int endIndex) {
-
-        if (s == null || s.length() == 0 || s.indexOf('"') == -1) {
-            return s;
-        }
-
-        StringBuffer b = new StringBuffer();
-        for (int i = beginIndex; i < endIndex; i++) {
-            char c = s.charAt(i);
-            if (c == '\\' ) {
-                b.append(c);
-                //ignore the character after an escape, just append it
-                if (++i>=endIndex) throw new IllegalArgumentException("Invalid escape character in cookie value.");
-                b.append(s.charAt(i));
-            } else if (c == '"')
-                b.append('\\').append('"');
-            else
-                b.append(c);
-        }
-
-        return b.toString();
-    }
-
-    /**
-     * Unescapes any double quotes in the given cookie value.
-     *
-     * @param bc The cookie value to modify
-     */
-    public static void unescapeDoubleQuotes(BBuffer bc) {
-
-        if (bc == null || bc.getLength() == 0 || bc.indexOf('"', 0) == -1) {
-            return;
-        }
-
-        int src = bc.getStart();
-        int end = bc.getEnd();
-        int dest = src;
-        byte[] buffer = bc.array();
-
-        while (src < end) {
-            if (buffer[src] == '\\' && src < end && buffer[src+1]  == '"') {
-                src++;
-            }
-            buffer[dest] = buffer[src];
-            dest ++;
-            src ++;
-        }
-        bc.setEnd(dest);
-    }
-
-    /*
-    List of Separator Characters (see isSeparator())
-    Excluding the '/' char violates the RFC, but
-    it looks like a lot of people put '/'
-    in unquoted values: '/': ; //47
-    '\t':9 ' ':32 '\"':34 '\'':39 '(':40 ')':41 ',':44 ':':58 ';':59 '<':60
-    '=':61 '>':62 '?':63 '@':64 '[':91 '\\':92 ']':93 '{':123 '}':125
-    */
-    public static final char SEPARATORS[] = { '\t', ' ', '\"', '\'', '(', ')', ',',
-        ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '{', '}' };
-
-    protected static final boolean separators[] = new boolean[128];
-    static {
-        for (int i = 0; i < 128; i++) {
-            separators[i] = false;
-        }
-        for (int i = 0; i < SEPARATORS.length; i++) {
-            separators[SEPARATORS[i]] = true;
-        }
-    }
-
-    /** Add all Cookie found in the headers of a request.
-     */
-    public  static void processCookies(List<ServerCookie> cookies,
-            List<ServerCookie> cookiesCache,
-            HttpMessage.HttpMessageBytes msgBytes ) {
-
-        // process each "cookie" header
-        for (int i = 0; i < msgBytes.headerCount; i++) {
-            if (msgBytes.getHeaderName(i).equalsIgnoreCase("Cookie")) {
-                BBuffer bc = msgBytes.getHeaderValue(i);
-                if (bc.remaining() == 0) {
-                    continue;
-                }
-                processCookieHeader(cookies, cookiesCache,
-                        bc.array(),
-                        bc.getOffset(),
-                        bc.getLength());
-
-            }
-
-        }
-    }
-
-    /**
-     * Returns true if the byte is a separator character as
-     * defined in RFC2619. Since this is called often, this
-     * function should be organized with the most probable
-     * outcomes first.
-     * JVK
-     */
-    private static final boolean isSeparator(final byte c) {
-         if (c > 0 && c < 126)
-             return separators[c];
-         else
-             return false;
-    }
-
-    /**
-     * Returns true if the byte is a whitespace character as
-     * defined in RFC2619
-     * JVK
-     */
-    private static final boolean isWhiteSpace(final byte c) {
-        // This switch statement is slightly slower
-        // for my vm than the if statement.
-        // Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_07-164)
-        /*
-        switch (c) {
-        case ' ':;
-        case '\t':;
-        case '\n':;
-        case '\r':;
-        case '\f':;
-            return true;
-        default:;
-            return false;
-        }
-        */
-       if (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f')
-           return true;
-       else
-           return false;
-    }
-
-    /**
-     * Parses a cookie header after the initial "Cookie:"
-     * [WS][$]token[WS]=[WS](token|QV)[;|,]
-     * RFC 2965
-     * JVK
-     */
-    public static final void processCookieHeader(
-            List<ServerCookie> cookies,
-            List<ServerCookie> cookiesCache,
-            byte bytes[], int off, int len){
-        if( len<=0 || bytes==null ) return;
-        int end=off+len;
-        int pos=off;
-        int nameStart=0;
-        int nameEnd=0;
-        int valueStart=0;
-        int valueEnd=0;
-        int version = 0;
-        ServerCookie sc=null;
-        boolean isSpecial;
-        boolean isQuoted;
-
-        while (pos < end) {
-            isSpecial = false;
-            isQuoted = false;
-
-            // Skip whitespace and non-token characters (separators)
-            while (pos < end &&
-                   (isSeparator(bytes[pos]) || isWhiteSpace(bytes[pos])))
-                {pos++; }
-
-            if (pos >= end)
-                return;
-
-            // Detect Special cookies
-            if (bytes[pos] == '$') {
-                isSpecial = true;
-                pos++;
-            }
-
-            // Get the cookie name. This must be a token
-            valueEnd = valueStart = nameStart = pos;
-            pos = nameEnd = getTokenEndPosition(bytes,pos,end);
-
-            // Skip whitespace
-            while (pos < end && isWhiteSpace(bytes[pos])) {pos++; }
-
-
-            // Check for an '=' -- This could also be a name-only
-            // cookie at the end of the cookie header, so if we
-            // are past the end of the header, but we have a name
-            // skip to the name-only part.
-            if (pos < end && bytes[pos] == '=') {
-
-                // Skip whitespace
-                do {
-                    pos++;
-                } while (pos < end && isWhiteSpace(bytes[pos]));
-
-                if (pos >= end)
-                    return;
-
-                // Determine what type of value this is, quoted value,
-                // token, name-only with an '=', or other (bad)
-                switch (bytes[pos]) {
-                case '"': // Quoted Value
-                    isQuoted = true;
-                    valueStart=pos + 1; // strip "
-                    // getQuotedValue returns the position before
-                    // at the last qoute. This must be dealt with
-                    // when the bytes are copied into the cookie
-                    valueEnd=getQuotedValueEndPosition(bytes,
-                                                       valueStart, end);
-                    // We need pos to advance
-                    pos = valueEnd;
-                    // Handles cases where the quoted value is
-                    // unterminated and at the end of the header,
-                    // e.g. [myname="value]
-                    if (pos >= end)
-                        return;
-                    break;
-                case ';':
-                case ',':
-                    // Name-only cookie with an '=' after the name token
-                    // This may not be RFC compliant
-                    valueStart = valueEnd = -1;
-                    // The position is OK (On a delimiter)
-                    break;
-                default:
-                    if (!isSeparator(bytes[pos])) {
-                        // Token
-                        valueStart=pos;
-                        // getToken returns the position at the delimeter
-                        // or other non-token character
-                        valueEnd=getTokenEndPosition(bytes, valueStart, end);
-                        // We need pos to advance
-                        pos = valueEnd;
-                    } else  {
-                        // INVALID COOKIE, advance to next delimiter
-                        // The starting character of the cookie value was
-                        // not valid.
-                        //log("Invalid cookie. Value not a token or quoted value");
-                        while (pos < end && bytes[pos] != ';' &&
-                               bytes[pos] != ',')
-                            {pos++; }
-                        pos++;
-                        // Make sure no special avpairs can be attributed to
-                        // the previous cookie by setting the current cookie
-                        // to null
-                        sc = null;
-                        continue;
-                    }
-                }
-            } else {
-                // Name only cookie
-                valueStart = valueEnd = -1;
-                pos = nameEnd;
-
-            }
-
-            // We should have an avpair or name-only cookie at this
-            // point. Perform some basic checks to make sure we are
-            // in a good state.
-
-            // Skip whitespace
-            while (pos < end && isWhiteSpace(bytes[pos])) {pos++; }
-
-
-            // Make sure that after the cookie we have a separator. This
-            // is only important if this is not the last cookie pair
-            while (pos < end && bytes[pos] != ';' && bytes[pos] != ',') {
-                pos++;
-            }
-
-            pos++;
-
-            /*
-            if (nameEnd <= nameStart || valueEnd < valueStart ) {
-                // Something is wrong, but this may be a case
-                // of having two ';' characters in a row.
-                // log("Cookie name/value does not conform to RFC 2965");
-                // Advance to next delimiter (ignoring everything else)
-                while (pos < end && bytes[pos] != ';' && bytes[pos] != ',')
-                    { pos++; };
-                pos++;
-                // Make sure no special cookies can be attributed to
-                // the previous cookie by setting the current cookie
-                // to null
-                sc = null;
-                continue;
-            }
-            */
-
-            // All checks passed. Add the cookie, start with the
-            // special avpairs first
-            if (isSpecial) {
-                isSpecial = false;
-                // $Version must be the first avpair in the cookie header
-                // (sc must be null)
-                if (equals( "Version", bytes, nameStart, nameEnd) &&
-                    sc == null) {
-                    // Set version
-                    if( bytes[valueStart] =='1' && valueEnd == (valueStart+1)) {
-                        version=1;
-                    } else {
-                        // unknown version (Versioning is not very strict)
-                    }
-                    continue;
-                }
-
-                // We need an active cookie for Path/Port/etc.
-                if (sc == null) {
-                    continue;
-                }
-
-                // Domain is more common, so it goes first
-                if (equals( "Domain", bytes, nameStart, nameEnd)) {
-                    sc.getDomain().setBytes( bytes,
-                                           valueStart,
-                                           valueEnd-valueStart);
-                    continue;
-                }
-
-                if (equals( "Path", bytes, nameStart, nameEnd)) {
-                    sc.getPath().setBytes( bytes,
-                                           valueStart,
-                                           valueEnd-valueStart);
-                    continue;
-                }
-
-
-                if (equals( "Port", bytes, nameStart, nameEnd)) {
-                    // sc.getPort is not currently implemented.
-                    // sc.getPort().setBytes( bytes,
-                    //                        valueStart,
-                    //                        valueEnd-valueStart );
-                    continue;
-                }
-
-                // Unknown cookie, complain
-                //log("Unknown Special Cookie");
-
-            } else { // Normal Cookie
-                // use a previous value from cache, if any (to avoid GC - tomcat
-                // legacy )
-                if (cookiesCache.size() > cookies.size()) {
-                    sc = cookiesCache.get(cookies.size());
-                    cookies.add(sc);
-                } else {
-                    sc = new ServerCookie();
-                    cookiesCache.add(sc);
-                    cookies.add(sc);
-                }
-                sc.setVersion( version );
-                sc.getName().append( bytes, nameStart,
-                                       nameEnd-nameStart);
-
-                if (valueStart != -1) { // Normal AVPair
-                    sc.getValue().append( bytes, valueStart,
-                            valueEnd-valueStart);
-                    if (isQuoted) {
-                        // We know this is a byte value so this is safe
-                        ServerCookie.unescapeDoubleQuotes(
-                                sc.getValue());
-                    }
-                } else {
-                    // Name Only
-                    sc.getValue().recycle();
-                }
-                sc.nameC.recycle();
-                sc.nameC.append(sc.getName());
-                continue;
-            }
-        }
-    }
-
-    /**
-     * Given the starting position of a token, this gets the end of the
-     * token, with no separator characters in between.
-     * JVK
-     */
-    private static final int getTokenEndPosition(byte bytes[], int off, int end){
-        int pos = off;
-        while (pos < end && !isSeparator(bytes[pos])) {pos++; }
-
-        if (pos > end)
-            return end;
-        return pos;
-    }
-
-    /**
-     * Given a starting position after an initial quote chracter, this gets
-     * the position of the end quote. This escapes anything after a '\' char
-     * JVK RFC 2616
-     */
-    private static final int getQuotedValueEndPosition(byte bytes[], int off, int end){
-        int pos = off;
-        while (pos < end) {
-            if (bytes[pos] == '"') {
-                return pos;
-            } else if (bytes[pos] == '\\' && pos < (end - 1)) {
-                pos+=2;
-            } else {
-                pos++;
-            }
-        }
-        // Error, we have reached the end of the header w/o a end quote
-        return end;
-    }
-
-
-    public static boolean equals( String s, byte b[], int start, int end) {
-        int blen = end-start;
-        if (b == null || blen != s.length()) {
-            return false;
-        }
-        int boff = start;
-        for (int i = 0; i < blen; i++) {
-            if (b[boff++] != s.charAt(i)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-}
-

==================================================
BBucket.java
deleted file mode 100644
index e69de29bb2..0000000000

==================================================
BBuffer.java
deleted file mode 100644
index 560629bd05..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/BBucket.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.nio.ByteBuffer;
-
-
-
-/**
- * Holds raw data. Similar interface with a ByteBuffer in 'channel write'
- * or 'read mode'. Data is between position and limit - there is no
- * switching.
- *
- * TODO: FileBucket, DirectBufferBucket, CharBucket, ...
- *
- * @author Costin Manolache
- */
-public interface BBucket {
-
-    public void release();
-
-    public byte[] array();
-    public int position();
-    public int remaining();
-    public int limit();
-
-    public boolean hasRemaining();
-
-    public void position(int newStart);
-
-    /**
-     * Return a byte buffer, with data between position and limit.
-     * Changes in the ByteBuffer position will not be reflected
-     * in the IOBucket.
-     *
-     * @return
-     */
-    public ByteBuffer getByteBuffer();
-
-
-}
\ No newline at end of file

==================================================
BufferedIOReader.java
deleted file mode 100644
index e3c20fa588..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/BBuffer.java
+++ /dev/null
@@ -1,1204 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Serializable;
-import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
-
-/*
- * In a server it is very important to be able to operate on
- * the original byte[] without converting everything to chars.
- * Some protocols are ASCII only, and some allow different
- * non-UNICODE encodings. The encoding is not known beforehand,
- * and can even change during the execution of the protocol.
- * ( for example a multipart message may have parts with different
- *  encoding )
- *
- * For HTTP it is not very clear how the encoding of RequestURI
- * and mime values can be determined, but it is a great advantage
- * to be able to parse the request without converting to string.
- */
-
-// Renamed from ByteChunk to make it easier to write code using both
-
-/**
- * This class is used to represent a chunk of bytes, and utilities to manipulate
- * byte[].
- *
- * The buffer can be modified and used for both input and output.
- *
- * There are 2 modes: The chunk can be associated with a sink - ByteInputChannel
- * or ByteOutputChannel, which will be used when the buffer is empty ( on input
- * ) or filled ( on output ). For output, it can also grow. This operating mode
- * is selected by calling setLimit() or allocate(initial, limit) with limit !=
- * -1.
- *
- * Various search and append method are defined - similar with String and
- * StringBuffer, but operating on bytes.
- *
- * This is important because it allows processing the http headers directly on
- * the received bytes, without converting to chars and Strings until the strings
- * are needed. In addition, the charset is determined later, from headers or
- * user code.
- *
- *
- * @author dac@sun.com
- * @author James Todd [gonzo@sun.com]
- * @author Costin Manolache
- * @author Remy Maucherat
- */
-public class BBuffer implements Cloneable, Serializable,
-    BBucket {
-
-    /**
-     * Default encoding used to convert to strings. It should be UTF8, but:
-     * - the servlet API requires 8859_1 as default
-     * -
-     */
-    public static final String DEFAULT_CHARACTER_ENCODING = "ISO-8859-1";
-
-    // byte[]
-    private byte[] buff;
-
-    private int start = 0;
-
-    private int end;
-
-    private ByteBuffer byteBuffer;
-
-    public static final String CRLF = "\r\n";
-
-    /* Various constant "strings" */
-    public static final byte[] CRLF_BYTES = convertToBytes(BBuffer.CRLF);
-
-    /**
-     * HT.
-     */
-    public static final byte HT = (byte) '\t';
-
-    /**
-     * SP.
-     */
-    public static final byte SP = (byte) ' ';
-
-    /**
-     * LF.
-     */
-    public static final byte LF = (byte) '\n';
-
-    /**
-     * CR.
-     */
-    public static final byte CR = (byte) '\r';
-
-    //private int useCount;
-
-
-    private static final boolean[] isDigit = new boolean[256];
-
-    static Charset UTF8;
-
-    public static final byte A = (byte) 'A';
-
-    public static final byte Z = (byte) 'Z';
-
-    public static final byte a = (byte) 'a';
-
-    public static final byte LC_OFFSET = A - a;
-    private static final byte[] toLower = new byte[256];
-    private static final boolean[] isUpper = new boolean[256];
-
-    static {
-        for (int i = 0; i < 256; i++) {
-            toLower[i] = (byte)i;
-        }
-
-        for (int lc = 'a'; lc <= 'z'; lc++) {
-            int uc = lc + 'A' - 'a';
-            toLower[uc] = (byte)lc;
-            isUpper[uc] = true;
-        }
-    }
-
-    static {
-        for (int d = '0'; d <= '9'; d++) {
-            isDigit[d] = true;
-        }
-        UTF8 = Charset.forName("UTF-8");
-    }
-
-    public static BBuffer allocate() {
-        return new BBuffer();
-    }
-
-    public static BBuffer allocate(int initial) {
-        return new BBuffer().makeSpace(initial);
-    }
-
-
-    public static BBuffer allocate(String msg) {
-        BBuffer bc = allocate();
-        byte[] data = msg.getBytes();
-        bc.append(data, 0, data.length);
-        return bc;
-    }
-
-    public static BBuffer wrapper(String msg) {
-        BBuffer bc = new IOBucketWrap();
-        byte[] data = msg.getBytes();
-        bc.setBytes(data, 0, data.length);
-        return bc;
-    }
-
-    public static BBuffer wrapper() {
-        return new IOBucketWrap();
-    }
-
-    public static BBuffer wrapper(BBuffer bb) {
-        BBuffer res = new IOBucketWrap();
-        res.setBytes(bb.array(), bb.position(), bb.remaining());
-        return res;
-    }
-
-    public static BBuffer wrapper(byte b[], int off, int len) {
-        BBuffer res = new IOBucketWrap();
-        res.setBytes(b, off, len);
-        return res;
-    }
-
-    public static BBuffer wrapper(BBucket bb, int start, int len) {
-        BBuffer res = new IOBucketWrap();
-        res.setBytes(bb.array(), bb.position() + start, len);
-        return res;
-    }
-
-    /**
-     * Creates a new, uninitialized ByteChunk object.
-     */
-    private BBuffer() {
-    }
-
-    public void append(BBuffer src) {
-        append(src.array(), src.getStart(), src.getLength());
-    }
-
-    /**
-     * Add data to the buffer
-     */
-    public void append(byte src[], int off, int len) {
-        // will grow, up to limit
-        makeSpace(len);
-
-        // assert: makeSpace made enough space
-        System.arraycopy(src, off, buff, end, len);
-        end += len;
-        return;
-    }
-
-    // -------------------- Adding data to the buffer --------------------
-    /**
-     * Append a char, by casting it to byte. This IS NOT intended for unicode.
-     *
-     * @param c
-     */
-    public void append(char c) {
-        put((byte) c);
-    }
-
-    // -------------------- Removing data from the buffer --------------------
-
-    /**
-     * Returns the message bytes.
-     */
-    @Override
-    public byte[] array() {
-        return buff;
-    }
-
-    public int capacity() {
-        return buff.length;
-    }
-
-    public boolean equals(BBuffer bb) {
-        return equals(bb.array(), bb.getStart(), bb.getLength());
-    }
-
-    public boolean equals(byte b2[], int off2, int len2) {
-        byte b1[] = buff;
-        if (b1 == null && b2 == null)
-            return true;
-
-        int len = end - start;
-        if (len2 != len || b1 == null || b2 == null)
-            return false;
-
-        int off1 = start;
-
-        while (len-- > 0) {
-            if (b1[off1++] != b2[off2++]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-
-    public boolean equals(char c2[], int off2, int len2) {
-        // XXX works only for enc compatible with ASCII/UTF !!!
-        byte b1[] = buff;
-        if (c2 == null && b1 == null)
-            return true;
-
-        if (b1 == null || c2 == null || end - start != len2) {
-            return false;
-        }
-        int off1 = start;
-        int len = end - start;
-
-        while (len-- > 0) {
-            if ((char) b1[off1++] != c2[off2++]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // -------------------- Conversion and getters --------------------
-
-    /**
-     * Compares the message bytes to the specified String object.
-     *
-     * @param s
-     *            the String to compare
-     * @return true if the comparison succeeded, false otherwise
-     */
-    public boolean equals(String s) {
-        // XXX ENCODING - this only works if encoding is UTF8-compat
-        // ( ok for tomcat, where we compare ascii - header names, etc )!!!
-
-        byte[] b = buff;
-        int blen = end - start;
-        if (b == null || blen != s.length()) {
-            return false;
-        }
-        int boff = start;
-        for (int i = 0; i < blen; i++) {
-            if (b[boff++] != s.charAt(i)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Compares the message bytes to the specified String object.
-     *
-     * @param s
-     *            the String to compare
-     * @return true if the comparison succeeded, false otherwise
-     */
-    public boolean equalsIgnoreCase(String s) {
-        byte[] b = buff;
-        int blen = end - start;
-        if (b == null || blen != s.length()) {
-            return false;
-        }
-        int boff = start;
-        for (int i = 0; i < blen; i++) {
-            if (toLower(b[boff++]) != toLower(s.charAt(i))) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public int get(int off) {
-        if (start + off >= end) {
-            throw new ArrayIndexOutOfBoundsException();
-        }
-        return buff[start + off] & 0xFF;
-    }
-
-    /**
-     * Return a byte buffer. Changes in the ByteBuffer position will
-     * not be reflected in the IOBucket
-     * @return
-     */
-    public ByteBuffer getByteBuffer() {
-        if (byteBuffer == null || byteBuffer.array() != buff) {
-            byteBuffer = ByteBuffer.wrap(buff, start, end - start);
-        } else {
-            byteBuffer.position(start);
-            byteBuffer.limit(end);
-        }
-        return byteBuffer;
-    }
-
-    // --------------------
-    public BBuffer getClone() {
-        try {
-            return (BBuffer) this.clone();
-        } catch (Exception ex) {
-            return null;
-        }
-    }
-
-    public int getEnd() {
-        return end;
-    }
-
-    public int getInt() {
-        return parseInt(buff, start, end - start);
-    }
-    /**
-     * Returns the length of the bytes. XXX need to clean this up
-     */
-    public int getLength() {
-        return end - start;
-    }
-
-    public long getLong() {
-        return parseLong(buff, start, end - start);
-    }
-
-    public int getOffset() {
-        return start;
-    }
-
-    // -------------------- equals --------------------
-
-    /**
-     * Returns the start offset of the bytes. For output this is the end of the
-     * buffer.
-     */
-    public int getStart() {
-        return start;
-    }
-
-    public ByteBuffer getWriteByteBuffer(int space) {
-        if (space == 0) {
-            space = 16;
-        }
-        makeSpace(space);
-        if (byteBuffer == null || byteBuffer.array() != buff) {
-            byteBuffer = ByteBuffer.wrap(buff, end, buff.length);
-        } else {
-            byteBuffer.position(end);
-            byteBuffer.limit(buff.length);
-        }
-        return byteBuffer;
-    }
-
-    // -------------------- Hash code --------------------
-    public int hashCode() {
-        return hashBytes(buff, start, end - start);
-    }
-
-    public boolean hasLFLF() {
-        return hasLFLF(this);
-    }
-
-    public boolean hasRemaining() {
-        return start < end;
-    }
-
-    /**
-     * Returns true if the message bytes starts with the specified string.
-     *
-     * @param s
-     *            the string
-     */
-//    public boolean startsWith(String s) {
-//        // Works only if enc==UTF
-//        byte[] b = buff;
-//        int blen = s.length();
-//        if (b == null || blen > end - start) {
-//            return false;
-//        }
-//        int boff = start;
-//        for (int i = 0; i < blen; i++) {
-//            if (b[boff++] != s.charAt(i)) {
-//                return false;
-//            }
-//        }
-//        return true;
-//    }
-
-    /* Returns true if the message bytes start with the specified byte array */
-//    public boolean startsWith(byte[] b2) {
-//        byte[] b1 = buff;
-//        if (b1 == null && b2 == null) {
-//            return true;
-//        }
-//
-//        int len = end - start;
-//        if (b1 == null || b2 == null || b2.length > len) {
-//            return false;
-//        }
-//        for (int i = start, j = 0; i < end && j < b2.length;) {
-//            if (b1[i++] != b2[j++])
-//                return false;
-//        }
-//        return true;
-//    }
-
-    /**
-     * Returns true if the message bytes starts with the specified string.
-     *
-     * @param c
-     *            the character
-     * @param starting
-     *            The start position
-     */
-    public int indexOf(char c, int starting) {
-        int ret = indexOf(buff, start + starting, end, c);
-        return (ret >= start) ? ret - start : -1;
-    }
-
-    /**
-     * Returns true if the message bytes starts with the specified string.
-     *
-     * @param s
-     *            the string
-     * @param pos
-     *            The position
-     */
-//    public boolean startsWithIgnoreCase(String s, int pos) {
-//        byte[] b = buff;
-//        int len = s.length();
-//        if (b == null || len + pos > end - start) {
-//            return false;
-//        }
-//        int off = start + pos;
-//        for (int i = 0; i < len; i++) {
-//            if (Ascii.toLower(b[off++]) != Ascii.toLower(s.charAt(i))) {
-//                return false;
-//            }
-//        }
-//        return true;
-//    }
-    public int indexOf(String src) {
-        return indexOf(src, 0, src.length(), 0);
-    }
-
-    public int indexOf(String src, int srcOff, int srcLen, int myOff) {
-        if ("".equals(src)) {
-            return myOff;
-        }
-        char first = src.charAt(srcOff);
-
-        // Look for first char
-        int srcEnd = srcOff + srcLen;
-
-        for (int i = myOff + start; i <= (end - srcLen); i++) {
-            if (buff[i] != first)
-                continue;
-            // found first char, now look for a match
-            int myPos = i + 1;
-            for (int srcPos = srcOff + 1; srcPos < srcEnd;) {
-                if (buff[myPos++] != src.charAt(srcPos++))
-                    break;
-                if (srcPos == srcEnd)
-                    return i - start; // found it
-            }
-        }
-        return -1;
-    }
-
-    // hash ignoring case
-//    public int hashIgnoreCase() {
-//        return hashBytesIC(buff, start, end - start);
-//    }
-
-    public boolean isNull() {
-        return start == end;
-    }
-
-//    private static int hashBytesIC(byte bytes[], int start, int bytesLen) {
-//        int max = start + bytesLen;
-//        byte bb[] = bytes;
-//        int code = 0;
-//        for (int i = start; i < max; i++) {
-//            code = code * 37 + Ascii.toLower(bb[i]);
-//        }
-//        return code;
-//    }
-
-    @Override
-    public int limit() {
-        return end;
-    }
-
-    public void limit(int newEnd) {
-        end = newEnd;
-    }
-
-    /**
-     * Make space for len chars.
-     * If len is small, allocate a reserve space too.
-     */
-    public BBuffer makeSpace(int count) {
-        byte[] tmp = null;
-
-        int newSize;
-        int desiredSize = end + count;
-
-        if (buff == null) {
-            if (desiredSize < 16)
-                desiredSize = 16; // take a minimum
-            buff = new byte[desiredSize];
-            start = 0;
-            end = 0;
-            return this;
-        }
-
-        // limit < buf.length ( the buffer is already big )
-        // or we already have space XXX
-        if (desiredSize <= buff.length) {
-            return this;
-        }
-        // grow in larger chunks
-        if (desiredSize < 2 * buff.length) {
-            newSize = buff.length * 2;
-            tmp = new byte[newSize];
-        } else {
-            newSize = buff.length * 2 + count;
-            tmp = new byte[newSize];
-        }
-
-        System.arraycopy(buff, start, tmp, 0, end - start);
-        buff = tmp;
-        tmp = null;
-        end = end - start;
-        start = 0;
-        return this;
-    }
-
-//    /**
-//     * Find a character, no side effects.
-//     *
-//     * @return index of char if found, -1 if not
-//     */
-//    public static int findChars(byte buf[], int start, int end, byte c[]) {
-//        int clen = c.length;
-//        int offset = start;
-//        while (offset < end) {
-//            for (int i = 0; i < clen; i++)
-//                if (buf[offset] == c[i]) {
-//                    return offset;
-//                }
-//            offset++;
-//        }
-//        return -1;
-//    }
-
-//    /**
-//     * Find the first character != c
-//     *
-//     * @return index of char if found, -1 if not
-//     */
-//    public static int findNotChars(byte buf[], int start, int end, byte c[]) {
-//        int clen = c.length;
-//        int offset = start;
-//        boolean found;
-//
-//        while (offset < end) {
-//            found = true;
-//            for (int i = 0; i < clen; i++) {
-//                if (buf[offset] == c[i]) {
-//                    found = false;
-//                    break;
-//                }
-//            }
-//            if (found) { // buf[offset] != c[0..len]
-//                return offset;
-//            }
-//            offset++;
-//        }
-//        return -1;
-//    }
-
-    @Override
-    public int position() {
-        return start;
-    }
-
-    public void advance(int len) {
-        start += len;
-    }
-
-    @Override
-    public void position(int newStart) {
-        start = newStart;
-    }
-
-    public void put(byte b) {
-        makeSpace(1);
-        buff[end++] = b;
-    }
-
-    public void putByte(int b) {
-        makeSpace(1);
-        buff[end++] = (byte) b;
-    }
-
-    public int read(BBuffer res) {
-        res.setBytes(buff, start, remaining());
-        end = start;
-        return res.remaining();
-    }
-
-    /**
-     * Read a chunk from is.
-     *
-     * You don't need to use buffered input stream, we do the
-     * buffering.
-     */
-    public int read(InputStream is) throws IOException {
-        makeSpace(1024);
-        int res = is.read(buff, end, buff.length - end);
-        if (res > 0) {
-            end += res;
-        }
-        return res;
-    }
-
-    public int readAll(InputStream is) throws IOException {
-        int size = 0;
-        while (true) {
-            int res = read(is);
-            if (res < 0) {
-                return size;
-            }
-            size += res;
-        }
-    }
-
-    public int readByte() {
-        if (start == end) {
-            return -1;
-        }
-        return buff[start++];
-    }
-
-
-    /**
-     *  Read a line - excluding the line terminator, which is consummed as
-     *  well but not included in the response.
-     *
-     *  Line can end with CR, LF or CR/LF
-     *
-     * @param res
-     * @return number of bytes read, or -1 if line ending not found in buffer.
-     */
-    public int readLine(BBuffer res) {
-        int cstart = start;
-        while(start < end) {
-            byte chr = buff[start++];
-            if (chr == CR || chr == LF) {
-                res.setBytes(buff, cstart, start - cstart -1);
-                if (chr == CR) {
-                    if (start < end) {
-                        byte chr2 = buff[start];
-                        if (chr2 == LF) {
-                            start++;
-                        }
-                    }
-                }
-                return res.remaining();
-            }
-        }
-        start = cstart;
-        return -1;
-    }
-    /**
-     * Consume up to but not including delim.
-     *
-     */
-    public final int readToDelimOrSpace(byte delim,
-            BBuffer res) {
-        int resStart = start;
-        while (true) {
-            if (start >= end) {
-                break;
-            }
-            byte chr = buff[start];
-            if (chr == delim || chr == SP || chr == HT) {
-                break;
-            }
-            start++;
-        }
-        res.setBytes(buff, resStart, start - resStart);
-        return res.remaining();
-    }
-
-
-    /**
-     * Consume all up to the first space or \t, which will be the
-     * first character in the buffer.
-     *
-     * Consumed data is wrapped in res.
-     */
-    public int readToSpace(BBuffer res) {
-        int resStart = start;
-        while (true) {
-          if (start >= end) {
-              break;
-          }
-          if (buff[start] == SP
-                  || buff[start] == HT) {
-              break;
-          }
-          start++;
-        }
-        res.setBytes(buff, resStart, start - resStart);
-        return res.remaining();
-    }
-    /**
-     * Resets the message buff to an uninitialized state.
-     */
-    public void recycle() {
-        start = 0;
-        end = 0;
-    }
-    @Override
-    public void release() {
-//        synchronized (this) {
-//            useCount--;
-//            if (useCount == -1) {
-//                // all slices have been released -
-//                // TODO: callback, return to pool
-//            }
-//        }
-    }
-    public int remaining() {
-        return end - start;
-    }
-
-    public void reset() {
-        buff = null;
-    }
-
-    // -------------------- Setup --------------------
-    /**
-     * Sets the message bytes to the specified subarray of bytes.
-     *
-     * @param b
-     *            the ascii bytes
-     * @param off
-     *            the start offset of the bytes
-     * @param len
-     *            the length of the bytes
-     */
-    public void setBytes(byte[] b, int off, int len) {
-        throw new RuntimeException("Can't setBytes on allocated buffer");
-    }
-
-    public void wrap(BBucket b) {
-        setBytes(b.array(), b.position(), b.remaining());
-    }
-
-    public void wrap(ByteBuffer b) {
-        setBytes(b.array(), b.position(), b.remaining());
-    }
-
-    protected void setBytesInternal(byte[] b, int off, int len) {
-        buff = b;
-        start = off;
-        end = start + len;
-    }
-
-//    public final void lowerCase() {
-//        while (start < end) {
-//            byte chr = buff[start];
-//            if ((chr >= A) && (chr <= Z)) {
-//                buff[start] = (byte) (chr - LC_OFFSET);
-//            }
-//            start++;
-//        }
-//    }
-
-    public void setEnd(int i) {
-        end = i;
-    }
-
-    /**
-     * The old code from MessageBytes, used for setContentLength
-     * and setStatus.
-     * TODO: just use StringBuilder, the method is faster.
-     */
-    public void setLong(long l) {
-        if (array() == null) {
-            makeSpace(20);
-        }
-        long current = l;
-        byte[] buf = array();
-        int start = 0;
-        int end = 0;
-        if (l == 0) {
-            buf[end++] = (byte) '0';
-        } else if (l < 0) {
-            current = -l;
-            buf[end++] = (byte) '-';
-        }
-        while (current > 0) {
-            int digit = (int) (current % 10);
-            current = current / 10;
-            buf[end++] = Hex.HEX[digit];
-        }
-        setOffset(0);
-        setEnd(end);
-        // Inverting buffer
-        end--;
-        if (l < 0) {
-            start++;
-        }
-        while (end > start) {
-            byte temp = buf[start];
-            buf[start] = buf[end];
-            buf[end] = temp;
-            start++;
-            end--;
-        }
-    }
-
-    public void setOffset(int off) {
-        if (end < off)
-            end = off;
-        start = off;
-    }
-
-
-    public int skipEmptyLines() {
-        int resStart = start;
-        while (buff[start] == CR || buff[start] == LF) {
-            start++;
-            if (start == end) {
-                break;
-            }
-        }
-        return start - resStart;
-    }
-
-    public int skipSpace() {
-        int cstart = start;
-        while (true) {
-          if (start >= end) {
-            return start - cstart;
-          }
-          if ((buff[start] == SP) || (buff[start] == HT)) {
-            start++;
-          } else {
-            return start - cstart;
-          }
-        }
-    }
-
-    public int read() {
-        if (end  == start) {
-            return -1;
-        }
-        return (buff[start++] & 0xFF);
-
-    }
-
-    public int substract(BBuffer src) {
-
-        if (end == start) {
-            return -1;
-        }
-
-        int len = getLength();
-        src.append(buff, start, len);
-        start = end;
-        return len;
-
-    }
-
-    public int substract(byte src[], int off, int len)  {
-
-        if ((end - start) == 0) {
-            return -1;
-        }
-
-        int n = len;
-        if (len > getLength()) {
-            n = getLength();
-        }
-        System.arraycopy(buff, start, src, off, n);
-        start += n;
-        return n;
-
-    }
-
-    public String toString() {
-        return toString(DEFAULT_CHARACTER_ENCODING);
-    }
-
-    public String toString(String enc) {
-        if (null == buff) {
-            return null;
-        } else if (end == start) {
-            return "";
-        }
-
-        String strValue = null;
-        try {
-            if (enc == null) {
-                enc = DEFAULT_CHARACTER_ENCODING;
-            }
-
-            strValue = new String(buff, start, end - start, enc);
-            /*
-             * Does not improve the speed too much on most systems, it's safer
-             * to use the "clasical" new String().
-             *
-             * Most overhead is in creating char[] and copying, the internal
-             * implementation of new String() is very close to what we do. The
-             * decoder is nice for large buffers and if we don't go to String (
-             * so we can take advantage of reduced GC)
-             *
-             * // Method is commented out, in: return B2CConverter.decodeString(
-             * enc );
-             */
-        } catch (java.io.UnsupportedEncodingException e) {
-            // Use the platform encoding in that case; the usage of a bad
-            // encoding will have been logged elsewhere already
-            strValue = new String(buff, start, end - start);
-        }
-        return strValue;
-    }
-
-    public void wrapTo(BBuffer res) {
-        res.setBytes(buff, start, remaining());
-    }
-
-    /**
-     * Convert specified String to a byte array. This ONLY WORKS for ascii, UTF
-     * chars will be truncated.
-     *
-     * @param value
-     *            to convert to byte array
-     * @return the byte array value
-     */
-    public static final byte[] convertToBytes(String value) {
-        byte[] result = new byte[value.length()];
-        for (int i = 0; i < value.length(); i++) {
-            result[i] = (byte) value.charAt(i);
-        }
-        return result;
-    }
-
-    /**
-     * Find a character, no side effects.
-     *
-     * @return index of char if found, -1 if not
-     */
-    public static int findChar(byte buf[], int start, int end, char c) {
-        byte b = (byte) c;
-        int offset = start;
-        while (offset < end) {
-            if (buf[offset] == b) {
-                return offset;
-            }
-            offset++;
-        }
-        return -1;
-    }
-    private static int hashBytes(byte buff[], int start, int bytesLen) {
-        int max = start + bytesLen;
-        byte bb[] = buff;
-        int code = 0;
-        for (int i = start; i < max; i++) {
-            code = code * 31 + bb[i];
-            // TODO: if > 0x7F, convert to chars / switch to UTF8
-        }
-        return code;
-    }
-
-    public static boolean hasLFLF(BBucket bucket) {
-        int pos = bucket.position();
-        int lastValid = bucket.limit();
-        byte[] buf = bucket.array();
-
-        for (int i = pos; i < lastValid; i++) {
-            byte chr = buf[i];
-            if (chr == LF) {
-                if (i + 1 < lastValid && buf[i + 1] == CR) {
-                    // \n\r\n
-                    i++;
-                }
-                if (i + 1 < lastValid && buf[i + 1] == LF) {
-                    return true; // \n\n
-                }
-            } else if (chr == CR) {
-                if (i + 1 < lastValid && buf[i + 1] == CR) {
-                    return true; // \r\r
-                }
-                if (i + 1 < lastValid && buf[i + 1] == LF) {
-                        // \r\n
-                    i++; // skip LF
-                    if (i + 1 < lastValid && buf[i + 1] == CR &&
-                            i + 2 < lastValid && buf[i + 2] == LF) {
-                        i++;
-                        return true;
-                    }
-                }
-
-            }
-        }
-        return false;
-    }
-
-    public static int indexOf(byte bytes[], int off, int end, char qq) {
-        // Works only for UTF
-        while (off < end) {
-            byte b = bytes[off];
-            if (b == qq)
-                return off;
-            off++;
-        }
-        return -1;
-    }
-
-    /**
-     * Returns true if the specified ASCII character is a digit.
-     */
-
-    public static boolean isDigit(int c) {
-        return isDigit[c & 0xff];
-    }
-
-    /**
-     * Parses an unsigned integer from the specified subarray of bytes.
-     * @param b the bytes to parse
-     * @param off the start offset of the bytes
-     * @param len the length of the bytes
-     * @exception NumberFormatException if the integer format was invalid
-     */
-    public static int parseInt(byte[] b, int off, int len)
-        throws NumberFormatException
-    {
-        int c;
-
-        if (b == null || len <= 0 || !isDigit(c = b[off++])) {
-            throw new NumberFormatException();
-        }
-
-        int n = c - '0';
-
-        while (--len > 0) {
-            if (!isDigit(c = b[off++])) {
-                throw new NumberFormatException();
-            }
-            n = n * 10 + c - '0';
-        }
-
-        return n;
-    }
-
-    /**
-     * Parses an unsigned long from the specified subarray of bytes.
-     * @param b the bytes to parse
-     * @param off the start offset of the bytes
-     * @param len the length of the bytes
-     * @exception NumberFormatException if the long format was invalid
-     */
-    public static long parseLong(byte[] b, int off, int len)
-        throws NumberFormatException
-    {
-        int c;
-
-        if (b == null || len <= 0 || !isDigit(c = b[off++])) {
-            throw new NumberFormatException();
-        }
-
-        long n = c - '0';
-        long m;
-
-        while (--len > 0) {
-            if (!isDigit(c = b[off++])) {
-                throw new NumberFormatException();
-            }
-            m = n * 10 + c - '0';
-
-            if (m < n) {
-                // Overflow
-                throw new NumberFormatException();
-            } else {
-                n = m;
-            }
-        }
-
-        return n;
-    }
-
-
-
-    /**
-     * Returns the lower case equivalent of the specified ASCII character.
-     */
-    public static int toLower(int c) {
-        if (c > 0x7f) return c;
-        return toLower[c & 0xff] & 0xff;
-    }
-
-    /**
-     * Returns true if the specified ASCII character is upper case.
-     */
-
-    public static boolean isUpper(int c) {
-        return c < 0x7f && isUpper[c];
-    }
-
-    /**
-     * A slice of a bucket, holding reference to a parent bucket.
-     *
-     * This is used when a filter splits a bucket - the original
-     * will be replaced with 1 or more slices. When all slices are
-     * released, the parent will also be released.
-     *
-     * It is not possible to add data.
-     *
-     * @author Costin Manolache
-     */
-    static class IOBucketWrap extends BBuffer {
-        //IOBucket parent;
-
-
-        public BBuffer makeSpace(int count) {
-            throw new RuntimeException("Attempting to change buffer " +
-            		"on a wrapped BBuffer");
-        }
-
-        public void release() {
-//            if (parent != null) {
-//                parent.release();
-//            }
-        }
-
-        public void setBytes(byte[] b, int off, int len) {
-            super.setBytesInternal(b, off, len);
-        }
-    }
-
-
-}

==================================================
CBucket.java
deleted file mode 100644
index 35d339a0ed..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/BufferedIOReader.java
+++ /dev/null
@@ -1,380 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.Reader;
-import java.nio.CharBuffer;
-
-
-/**
- * Cut&pasted from Harmony buffered reader ( apache license ).
- * Changes:
- * - additional method to recycle to avoid re-allocating on
- * each request.
- */
-public class BufferedIOReader extends BufferedReader {
-
-    // Not recycled - the buffer is tied to the message/IOReader
-    IOReader in;
-
-    private String enc;
-    boolean closed;
-    private char[] buf;
-    private int marklimit = -1;
-
-    private int count;
-
-    private int markpos = -1;
-
-    private int pos;
-
-    public BufferedIOReader(IOReader realReader) {
-        // we're not using super - we override all methods, but need the
-        // signature
-        super(DUMMY_READER, 1);
-        this.in = realReader;
-        buf = new char[8192];
-    }
-
-    public void recycle() {
-        enc = null;
-        closed = false;
-
-        if (in != null) {
-            in.recycle();
-        }
-        marklimit = -1;
-        count = 0;
-        markpos = -1;
-        pos = 0;
-    }
-
-    private void checkClosed() throws IOException {
-        if (closed) throw new IOException("closed");
-    }
-
-    public int read(CharBuffer target) throws IOException {
-        checkClosed();
-        int len = target.remaining();
-        int n = read(target.array(), target.position(), target.remaining());
-        if (n > 0)
-            target.position(target.position() + n);
-        return n;
-    }
-
-
-    public int read(char[] cbuf) throws IOException {
-        return read(cbuf, 0, cbuf.length);
-    }
-
-
-    /**
-     * Closes this reader. This implementation closes the buffered source reader
-     * and releases the buffer. Nothing is done if this reader has already been
-     * closed.
-     *
-     * @throws IOException
-     *             if an error occurs while closing this reader.
-     */
-    @Override
-    public void close() throws IOException {
-        synchronized (lock) {
-            if (!isClosed()) {
-                in.close();
-                closed = true;
-                // buf remains
-            }
-        }
-    }
-
-    private int fillbuf() throws IOException {
-        if (markpos == -1 || (pos - markpos >= marklimit)) {
-            /* Mark position not set or exceeded readlimit */
-            int result = in.read(buf, 0, buf.length);
-            if (result > 0) {
-                markpos = -1;
-                pos = 0;
-                count = result == -1 ? 0 : result;
-            }
-            return result;
-        }
-        if (markpos == 0 && marklimit > buf.length) {
-            /* Increase buffer size to accommodate the readlimit */
-            int newLength = buf.length * 2;
-            if (newLength > marklimit) {
-                newLength = marklimit;
-            }
-            char[] newbuf = new char[newLength];
-            System.arraycopy(buf, 0, newbuf, 0, buf.length);
-            buf = newbuf;
-        } else if (markpos > 0) {
-            System.arraycopy(buf, markpos, buf, 0, buf.length - markpos);
-        }
-
-        /* Set the new position and mark position */
-        pos -= markpos;
-        count = markpos = 0;
-        int charsread = in.read(buf, pos, buf.length - pos);
-        count = charsread == -1 ? pos : pos + charsread;
-        return charsread;
-    }
-
-    private boolean isClosed() {
-        return closed;
-    }
-
-    @Override
-    public void mark(int readlimit) throws IOException {
-        if (readlimit < 0) {
-            throw new IllegalArgumentException();
-        }
-        synchronized (lock) {
-            checkClosed();
-            marklimit = readlimit;
-            markpos = pos;
-        }
-    }
-
-    @Override
-    public boolean markSupported() {
-        return true;
-    }
-
-    @Override
-    public int read() throws IOException {
-        synchronized (lock) {
-            checkClosed();
-            /* Are there buffered characters available? */
-            if (pos < count || fillbuf() != -1) {
-                return buf[pos++];
-            }
-            markpos = -1;
-            return -1;
-        }
-    }
-
-    @Override
-    public int read(char[] buffer, int offset, int length) throws IOException {
-        synchronized (lock) {
-            checkClosed();
-            if (offset < 0 || offset > buffer.length - length || length < 0) {
-                throw new IndexOutOfBoundsException();
-            }
-            if (length == 0) {
-                return 0;
-            }
-            int required;
-            if (pos < count) {
-                /* There are bytes available in the buffer. */
-                int copylength = count - pos >= length ? length : count - pos;
-                System.arraycopy(buf, pos, buffer, offset, copylength);
-                pos += copylength;
-                if (copylength == length || !in.ready()) {
-                    return copylength;
-                }
-                offset += copylength;
-                required = length - copylength;
-            } else {
-                required = length;
-            }
-
-            while (true) {
-                int read;
-                /*
-                 * If we're not marked and the required size is greater than the
-                 * buffer, simply read the bytes directly bypassing the buffer.
-                 */
-                if (markpos == -1 && required >= buf.length) {
-                    read = in.read(buffer, offset, required);
-                    if (read == -1) {
-                        return required == length ? -1 : length - required;
-                    }
-                } else {
-                    if (fillbuf() == -1) {
-                        return required == length ? -1 : length - required;
-                    }
-                    read = count - pos >= required ? required : count - pos;
-                    System.arraycopy(buf, pos, buffer, offset, read);
-                    pos += read;
-                }
-                required -= read;
-                if (required == 0) {
-                    return length;
-                }
-                if (!in.ready()) {
-                    return length - required;
-                }
-                offset += read;
-            }
-        }
-    }
-
-    /**
-     * Returns the next line of text available from this reader. A line is
-     * represented by zero or more characters followed by {@code '\n'},
-     * {@code '\r'}, {@code "\r\n"} or the end of the reader. The string does
-     * not include the newline sequence.
-     *
-     * @return the contents of the line or {@code null} if no characters were
-     *         read before the end of the reader has been reached.
-     * @throws IOException
-     *             if this reader is closed or some other I/O error occurs.
-     */
-    public String readLine() throws IOException {
-        synchronized (lock) {
-            checkClosed();
-            /* Are there buffered characters available? */
-            if ((pos >= count) && (fillbuf() == -1)) {
-                return null;
-            }
-            for (int charPos = pos; charPos < count; charPos++) {
-                char ch = buf[charPos];
-                if (ch > '\r') {
-                    continue;
-                }
-                if (ch == '\n') {
-                    String res = new String(buf, pos, charPos - pos);
-                    pos = charPos + 1;
-                    return res;
-                } else if (ch == '\r') {
-                    String res = new String(buf, pos, charPos - pos);
-                    pos = charPos + 1;
-                    if (((pos < count) || (fillbuf() != -1))
-                            && (buf[pos] == '\n')) {
-                        pos++;
-                    }
-                    return res;
-                }
-            }
-
-            char eol = '\0';
-            StringBuilder result = new StringBuilder(80);
-            /* Typical Line Length */
-
-            result.append(buf, pos, count - pos);
-            pos = count;
-            while (true) {
-                /* Are there buffered characters available? */
-                if (pos >= count) {
-                    if (eol == '\n') {
-                        return result.toString();
-                    }
-                    // attempt to fill buffer
-                    if (fillbuf() == -1) {
-                        // characters or null.
-                        return result.length() > 0 || eol != '\0' ? result
-                                .toString() : null;
-                    }
-                }
-                for (int charPos = pos; charPos < count; charPos++) {
-                    if (eol == '\0') {
-                        if ((buf[charPos] == '\n' || buf[charPos] == '\r')) {
-                            eol = buf[charPos];
-                        }
-                    } else if (eol == '\r' && (buf[charPos] == '\n')) {
-                        if (charPos > pos) {
-                            result.append(buf, pos, charPos - pos - 1);
-                        }
-                        pos = charPos + 1;
-                        return result.toString();
-                    } else {
-                        if (charPos > pos) {
-                            result.append(buf, pos, charPos - pos - 1);
-                        }
-                        pos = charPos;
-                        return result.toString();
-                    }
-                }
-                if (eol == '\0') {
-                    result.append(buf, pos, count - pos);
-                } else {
-                    result.append(buf, pos, count - pos - 1);
-                }
-                pos = count;
-            }
-        }
-
-    }
-
-
-    @Override
-    public boolean ready() throws IOException {
-        synchronized (lock) {
-            checkClosed();
-            return ((count - pos) > 0) || in.ready();
-        }
-    }
-
-    @Override
-    public void reset() throws IOException {
-        synchronized (lock) {
-            checkClosed();
-            if (markpos == -1) {
-                throw new IOException("No mark");
-            }
-            pos = markpos;
-        }
-    }
-
-    @Override
-    public long skip(long amount) throws IOException {
-        if (amount < 0) {
-            throw new IllegalArgumentException();
-        }
-        synchronized (lock) {
-            checkClosed();
-            if (amount < 1) {
-                return 0;
-            }
-            if (count - pos >= amount) {
-                pos += amount;
-                return amount;
-            }
-
-            long read = count - pos;
-            pos = count;
-            while (read < amount) {
-                if (fillbuf() == -1) {
-                    return read;
-                }
-                if (count - pos >= amount - read) {
-                    pos += amount - read;
-                    return amount;
-                }
-                // Couldn't get all the characters, skip what we read
-                read += (count - pos);
-                pos = count;
-            }
-            return amount;
-        }
-    }
-
-    private static Reader DUMMY_READER = new Reader() {
-        @Override
-        public void close() throws IOException {
-        }
-
-        @Override
-        public int read(char[] cbuf, int off, int len) throws IOException {
-            return 0;
-        }
-    };
-
-
-}

==================================================
CBuffer.java
deleted file mode 100644
index 688785ecd9..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/CBucket.java
+++ /dev/null
@@ -1,508 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.Serializable;
-import java.nio.CharBuffer;
-
-/**
- * Wraps a char[].
- *
- * Doesn't provide any mutation methods. Classes in this package
- * have access to the buffer, for conversions.
- *
- *
- * @author Costin Manolache
- */
-public class CBucket implements CharSequence, Comparable, Serializable {
-    protected char value[];
-
-    protected int start;
-
-    protected int end;
-
-    // Reused.
-    protected CharBuffer cb;
-
-    // cache
-    protected String strValue;
-    protected int hash;
-
-    public CBucket() {
-    }
-
-    /**
-     * Used by IOWriter for conversion. Will not modify the content.
-     */
-    CharBuffer getNioBuffer() {
-        if (cb == null || cb.array() != value) {
-            cb = CharBuffer.wrap(value, start, end - start);
-        } else {
-            cb.position(start);
-            cb.limit(end);
-        }
-        return cb;
-    }
-
-    public void recycle() {
-        start = 0;
-        end = 0;
-        value = null;
-        strValue = null;
-        hash = 0;
-    }
-
-    public String toString() {
-        if (null == value) {
-            return null;
-        } else if (end - start == 0) {
-            return "";
-        }
-        if (strValue == null) {
-            strValue = new String(value, start, end - start);
-        }
-        return strValue;
-    }
-
-    /**
-     * Same as String
-     */
-    public int hashCode() {
-        int h = hash;
-        if (h == 0) {
-            int off = start;
-            char val[] = value;
-
-            for (int i = start; i < end; i++) {
-                h = 31*h + val[off++];
-            }
-            hash = h;
-        }
-        return h;
-    }
-
-    public long getLong() {
-        return parseLong(value, start, end - start);
-    }
-
-    public int getInt() {
-        return parseInt(value, start, end - start);
-    }
-
-    public static int parseInt(char[] b, int off, int len)
-        throws NumberFormatException
-    {
-        int c;
-
-        if (b == null || len <= 0 || !BBuffer.isDigit(c = b[off++])) {
-            throw new NumberFormatException();
-        }
-
-        int n = c - '0';
-
-        while (--len > 0) {
-            if (!BBuffer.isDigit(c = b[off++])) {
-                throw new NumberFormatException();
-            }
-            n = n * 10 + c - '0';
-        }
-
-        return n;
-    }
-
-
-    public static long parseLong(char[] b, int off, int len)
-        throws NumberFormatException
-    {
-        int c;
-
-        if (b == null || len <= 0 || !BBuffer.isDigit(c = b[off++])) {
-            throw new NumberFormatException();
-        }
-
-        long n = c - '0';
-        long m;
-
-        while (--len > 0) {
-            if (!BBuffer.isDigit(c = b[off++])) {
-                throw new NumberFormatException();
-            }
-            m = n * 10 + c - '0';
-
-            if (m < n) {
-                // Overflow
-                throw new NumberFormatException();
-            } else {
-                n = m;
-            }
-        }
-
-        return n;
-    }
-
-
-    /**
-     * Compares the message bytes to the specified String object.
-     *
-     * @param s
-     *            the String to compare
-     * @return true if the comparison succeeded, false otherwise
-     */
-    public boolean equals(String s) {
-        char[] c = value;
-        int len = end - start;
-        if (c == null || len != s.length()) {
-            return false;
-        }
-        int off = start;
-        for (int i = 0; i < len; i++) {
-            if (c[off++] != s.charAt(i)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Compares the message bytes to the specified String object.
-     *
-     * @param s
-     *            the String to compare
-     * @return true if the comparison succeeded, false otherwise
-     */
-    public boolean equalsIgnoreCase(String s) {
-        char[] c = value;
-        int len = end - start;
-        if (c == null || len != s.length()) {
-            return false;
-        }
-        int off = start;
-        for (int i = 0; i < len; i++) {
-            if (BBuffer.toLower(c[off++]) != BBuffer.toLower(s.charAt(i))) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public boolean equals(Object obj) {
-        if (obj instanceof CBuffer) {
-            CBuffer cc = (CBuffer) obj;
-            return equals(cc.value, cc.start, cc.length());
-        } else if (obj instanceof String) {
-            return equals((String)obj);
-        }
-        return false;
-    }
-
-    public boolean equals(char b2[], int off2, int len2) {
-        char b1[] = value;
-        if (b1 == null && b2 == null)
-            return true;
-
-        if (b1 == null || b2 == null || end - start != len2) {
-            return false;
-        }
-        int off1 = start;
-        int len = end - start;
-        while (len-- > 0) {
-            if (b1[off1++] != b2[off2++]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public boolean equals(byte b2[], int off2, int len2) {
-        char b1[] = value;
-        if (b2 == null && b1 == null)
-            return true;
-
-        if (b1 == null || b2 == null || end - start != len2) {
-            return false;
-        }
-        int off1 = start;
-        int len = end - start;
-
-        while (len-- > 0) {
-            if (b1[off1++] != (char) b2[off2++]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-
-    /**
-     * Returns true if the message bytes starts with the specified string.
-     *
-     * @param s
-     *            the string
-     */
-    public boolean startsWith(String s) {
-        char[] c = value;
-        int len = s.length();
-        if (c == null || len > end - start) {
-            return false;
-        }
-        int off = start;
-        for (int i = 0; i < len; i++) {
-            if (c[off++] != s.charAt(i)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Returns true if the message bytes starts with the specified string.
-     *
-     * @param s
-     *            the string
-     */
-    public boolean startsWithIgnoreCase(String s, int pos) {
-        char[] c = value;
-        int len = s.length();
-        if (c == null || len + pos > end - start) {
-            return false;
-        }
-        int off = start + pos;
-        for (int i = 0; i < len; i++) {
-            if (BBuffer.toLower(c[off++]) != BBuffer.toLower(s.charAt(i))) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public int indexOf(char c) {
-        return indexOf(c, start);
-    }
-
-    public int lastIndexOf(char c) {
-        return lastIndexOf(c, 0, end - start);
-    }
-
-    /**
-     */
-    public int lastIndexOf(char c, int off, int len) {
-        char[] buf = value;
-        int slash = -1;
-        for (int i = start + len - 1; i >= start + off; i--) {
-            if (buf[i] == c) {
-                slash = i - start;
-                break;
-            }
-        }
-        return slash;
-    }
-
-    /**
-     * Returns true if the message bytes starts with the specified string.
-     *
-     * @param c
-     *            the character
-     */
-    public int indexOf(char c, int starting) {
-        int ret = indexOf(value, start + starting, end, c);
-        return (ret >= start) ? ret - start : -1;
-    }
-
-    public static int indexOf(char chars[], int off, int cend, char qq) {
-        while (off < cend) {
-            char b = chars[off];
-            if (b == qq)
-                return off;
-            off++;
-        }
-        return -1;
-    }
-
-    public int indexOf(String src) {
-        return indexOf(src, 0, src.length(), 0);
-    }
-
-    public int indexOf(String src, int srcOff, int srcLen, int myOff) {
-        char first = src.charAt(srcOff);
-
-        // Look for first char
-        int srcEnd = srcOff + srcLen;
-
-        for (int i = myOff + start; i <= (end - srcLen); i++) {
-            if (value[i] != first)
-                continue;
-            // found first char, now look for a match
-            int myPos = i + 1;
-            for (int srcPos = srcOff + 1; srcPos < srcEnd;) {
-                if (value[myPos++] != src.charAt(srcPos++))
-                    break;
-                if (srcPos == srcEnd)
-                    return i - start; // found it
-            }
-        }
-        return -1;
-    }
-
-    public char lastChar() {
-        return value[end - 1];
-    }
-
-    public char charAt(int index) {
-        return value[index + start];
-    }
-
-    public void wrap(char[] buff, int start, int end) {
-        if (value != null) {
-            throw new RuntimeException("Can wrap only once");
-        }
-        this.value = buff;
-        this.start = start;
-        this.end = end;
-    }
-
-    public CharSequence subSequence(int sstart, int send) {
-        CBucket seq = new CBucket();
-        seq.wrap(this.value, start + sstart, start + send);
-        return seq;
-    }
-
-    public int length() {
-        return end - start;
-    }
-
-    @Override
-    public int compareTo(Object o) {
-        // Code based on Harmony
-        if (o instanceof CBuffer) {
-            CBuffer dest = (CBuffer) o;
-            int o1 = start, o2 = dest.start, result;
-            int len = end - start;
-            int destLen = dest.end - dest.start;
-            int fin = (len < destLen ?
-                    end : start + destLen);
-            char[] target = dest.value;
-            while (o1 < fin) {
-                if ((result = value[o1++] - target[o2++]) != 0) {
-                    return result;
-                }
-            }
-            return len - destLen;
-
-        } else if (o instanceof CharSequence) {
-            CharSequence dest = (CharSequence) o;
-            int o1 = start, o2 = 0, result;
-            int len = end - start;
-            int destLen = dest.length();
-            int fin = (len < destLen ?
-                    end : start + destLen);
-            while (o1 < fin) {
-                if ((result = value[o1++] - dest.charAt(o2++)) != 0) {
-                    return result;
-                }
-            }
-            return len - destLen;
-
-        } else {
-            throw new RuntimeException("CompareTo not supported " + o);
-        }
-    }
-
-    /**
-     * Compare given char chunk with String ignoring case.
-     * Return -1, 0 or +1 if inferior, equal, or superior to the String.
-     */
-    public final int compareIgnoreCase(String compareTo) {
-        int result = 0;
-        char[] c = value;
-        int len = compareTo.length();
-        if ((end - start) < len) {
-            len = end - start;
-        }
-        for (int i = 0; (i < len) && (result == 0); i++) {
-            if (BBuffer.toLower(c[i + start]) > BBuffer.toLower(compareTo.charAt(i))) {
-                result = 1;
-            } else if (BBuffer.toLower(c[i + start]) < BBuffer.toLower(compareTo.charAt(i))) {
-                result = -1;
-            }
-        }
-        if (result == 0) {
-            if (compareTo.length() > (end - start)) {
-                result = -1;
-            } else if (compareTo.length() < (end - start)) {
-                result = 1;
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Compare given char chunk with String.
-     * Return -1, 0 or +1 if inferior, equal, or superior to the String.
-     */
-    public final int compare(String compareTo) {
-        int result = 0;
-        char[] c = value;
-        int len = compareTo.length();
-        if ((end - start) < len) {
-            len = end - start;
-        }
-        for (int i = 0; (i < len) && (result == 0); i++) {
-            if (c[i + start] > compareTo.charAt(i)) {
-                result = 1;
-            } else if (c[i + start] < compareTo.charAt(i)) {
-                result = -1;
-            }
-        }
-        if (result == 0) {
-            if (compareTo.length() > (end - start)) {
-                result = -1;
-            } else if (compareTo.length() < (end - start)) {
-                result = 1;
-            }
-        }
-        return result;
-    }
-
-    public int getExtension(CBuffer ext, char slashC, char dotC) {
-        int slash = lastIndexOf(slashC);
-        if (slash < 0) {
-            slash = 0;
-        }
-        int dot = lastIndexOf(dotC, slash, length());
-        if (dot < 0) {
-            return -1;
-        }
-        ext.wrap(this, dot + 1, length());
-        return dot;
-    }
-
-    /**
-     * Find the position of the nth slash, in the given char chunk.
-     */
-    public final int nthSlash(int n) {
-        char[] c = value;
-        int pos = start;
-        int count = 0;
-
-        while (pos < end) {
-            if ((c[pos++] == '/') && ((++count) == n)) {
-                pos--;
-                break;
-            }
-        }
-
-        return pos - start;
-    }
-
-
-    public boolean hasUpper() {
-        for (int i = start; i < end; i++) {
-            char c = value[i];
-            if (c < 0x7F && BBuffer.isUpper(c)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-}

==================================================
DumpChannel.java
deleted file mode 100644
index 86b42347d8..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/CBuffer.java
+++ /dev/null
@@ -1,387 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-import java.nio.CharBuffer;
-
-
-/**
- * Similar with StringBuilder or StringBuffer, but with access to the
- * raw buffer - this avoids copying the data.
- *
- * Utilities to manipluate char chunks. While String is the easiest way to
- * manipulate chars ( search, substrings, etc), it is known to not be the most
- * efficient solution - Strings are designed as imutable and secure objects.
- *
- * @author dac@sun.com
- * @author James Todd [gonzo@sun.com]
- * @author Costin Manolache
- * @author Remy Maucherat
- */
-public class CBuffer extends CBucket implements Cloneable,
-        Appendable {
-
-
-    /**
-     * Creates a new, uninitialized CharChunk object.
-     */
-    public static CBuffer newInstance() {
-        return new CBuffer();
-    }
-
-    private CBuffer() {
-    }
-
-    /**
-     * Resets the message bytes to an uninitialized state.
-     */
-    public void recycle() {
-        dirty();
-        start = 0;
-        end = 0;
-    }
-
-    /**
-     * Same as String
-     */
-    public int hashCode() {
-        int h = 0;
-        int off = start;
-        char val[] = value;
-
-        for (int i = start; i < end; i++) {
-            h = 31*h + val[off++];
-        }
-        return h;
-    }
-
-    public String toString() {
-        if (null == value) {
-            return null;
-        } else if (end - start == 0) {
-            return "";
-        }
-        return new String(value, start, end - start);
-    }
-
-    public void wrap(char[] buff, int start, int end) {
-        dirty();
-        this.value = buff;
-        this.start = start;
-        this.end = end;
-    }
-
-    public void wrap(CBucket buff, int off, int srcEnd) {
-        dirty();
-        this.value = buff.value;
-        this.start = buff.start + off;
-        this.end = this.start + srcEnd - off;
-    }
-
-
-    // ----------- Used for IOWriter / conversion ---------
-
-    public char[] array() {
-        return value;
-    }
-
-    public int position() {
-        return start;
-    }
-
-    CharBuffer getAppendCharBuffer() {
-        makeSpace(16);
-        if (cb == null || cb.array() != value) {
-            cb = CharBuffer.wrap(value, end, value.length - end);
-        } else {
-            cb.position(end);
-            cb.limit(value.length);
-        }
-        return cb;
-    }
-
-    void returnNioBuffer(CharBuffer c) {
-        dirty();
-        start = c.position();
-    }
-
-    void returnAppendCharBuffer(CharBuffer c) {
-        dirty();
-        end = c.position();
-    }
-
-    // -------- Delete / replace ---------------
-
-    /**
-     * 'Delete' all chars after offset.
-     *
-     * @param offset
-     */
-    public void delete(int offset) {
-       dirty();
-       end = start + offset;
-    }
-
-    // -------------------- Adding data --------------------
-
-    /**
-     * Append methods take start and end - similar with this one.
-     * The source is not modified.
-     */
-    @Override
-    public CBuffer append(CharSequence csq, int astart, int aend)
-            throws IOException {
-        makeSpace(aend - astart);
-
-        for (int i = astart; i < aend; i++) {
-            value[end++] = csq.charAt(i);
-        }
-        return this;
-    }
-
-    public CBuffer append(char b) {
-        makeSpace(1);
-        value[end++] = b;
-        return this;
-    }
-
-    public CBuffer append(int i) {
-        // TODO: can be optimizeed...
-        append(Integer.toString(i));
-        return this;
-    }
-
-    /**
-     * Add data to the buffer
-     */
-    public CBuffer append(char src[], int srcStart, int srcEnd)  {
-        int len = srcEnd - srcStart;
-        if (len == 0) {
-            return this;
-        }
-        // will grow, up to limit
-        makeSpace(len);
-
-        // assert: makeSpace made enough space
-        System.arraycopy(src, srcStart, value, end, len);
-        end += len;
-        return this;
-    }
-
-    /**
-     * Add data to the buffer
-     */
-    public CBuffer append(StringBuffer sb) {
-        int len = sb.length();
-        if (len == 0) {
-            return this;
-        }
-        makeSpace(len);
-        sb.getChars(0, len, value, end);
-        end += len;
-        return this;
-    }
-
-    /**
-     * Append a string to the buffer
-     */
-    public CBuffer append(String s) {
-        if (s == null || s.length() == 0) {
-            return this;
-        }
-        append(s, 0, s.length());
-        return this;
-    }
-
-
-    /**
-     * Append a string to the buffer
-     */
-    public CBuffer append(String s, int off, int srcEnd) {
-        if (s == null)
-            return this;
-
-        // will grow, up to limit
-        makeSpace(srcEnd - off);
-
-        // assert: makeSpace made enough space
-        s.getChars(off, srcEnd, value, end);
-        end += srcEnd - off;
-        return this;
-    }
-
-    // TODO: long, int conversions -> get from harmony Long
-    public CBuffer appendInt(int i) {
-        // TODO: copy from harmony StringBuffer
-        append(Integer.toString(i));
-        return this;
-    }
-
-
-    public Appendable append(CharSequence cs) {
-        if (cs instanceof CBuffer) {
-            CBuffer src = (CBuffer) cs;
-            append(src.value, src.start, src.end);
-        } else if (cs instanceof String) {
-            append((String) cs);
-        } else {
-            for (int i = 0; i < cs.length(); i++) {
-                append(cs.charAt(i));
-            }
-        }
-        return  this;
-    }
-
-    public CBuffer append(CBuffer src) {
-        append(src.value, src.start, src.end);
-        return  this;
-    }
-
-
-    public CBuffer append(BBucket bb) {
-        byte[] bbuf = bb.array();
-        int start = bb.position();
-        appendAscii(bbuf, start, bb.remaining());
-        return this;
-    }
-
-    public CBuffer appendAscii(byte[] bbuf, int start, int len) {
-        makeSpace(len);
-        char[] cbuf = value;
-        for (int i = 0; i < len; i++) {
-            cbuf[end + i] = (char) (bbuf[i + start] & 0xff);
-        }
-        end += len;
-        return this;
-    }
-
-
-    public void toAscii(BBuffer bb) {
-        for (int i = start; i < end; i++) {
-            bb.append(value[i]);
-        }
-    }
-
-    /**
-     *  Append and advance CharBuffer.
-     *
-     * @param c
-     */
-    public CBuffer put(CharBuffer c) {
-        append(c.array(), c.position(), c.limit());
-        c.position(c.limit());
-        return this;
-    }
-
-    // ------------- 'set' methods ---------------
-    // equivalent with clean + append
-
-    public CBuffer set(CBuffer csq, int off, int len) {
-        recycle();
-        append(csq.value, csq.start + off, csq.start + off + len);
-        return this;
-    }
-
-    public CBuffer setChars(char[] c, int off, int len) {
-        recycle();
-        append(c, off, off + len);
-        return this;
-    }
-
-    public CBuffer set(BBucket bb) {
-        recycle();
-        byte[] bbuf = bb.array();
-        int start = bb.position();
-        appendAscii(bbuf, start, bb.remaining());
-        return this;
-    }
-
-    public CBuffer set(CharSequence csq) {
-        recycle();
-        append(csq);
-        return this;
-    }
-
-    public CBuffer set(CBuffer csq) {
-        recycle();
-        append(csq);
-        return this;
-    }
-
-    public CBuffer set(String csq) {
-        recycle();
-        append(csq);
-        return this;
-    }
-
-    private void dirty() {
-        hash = 0;
-        strValue = null;
-    }
-
-    /**
-     * Make space for len chars. If len is small, allocate a reserve space too.
-     * Never grow bigger than limit.
-     */
-    private void makeSpace(int count) {
-        dirty();
-        char[] tmp = null;
-
-        int newSize;
-        int desiredSize = end + count;
-
-        if (value == null) {
-            if (desiredSize < 256)
-                desiredSize = 256; // take a minimum
-            value = new char[desiredSize];
-        }
-
-        // limit < buf.length ( the buffer is already big )
-        // or we already have space XXX
-        if (desiredSize <= value.length) {
-            return;
-        }
-        // grow in larger chunks
-        if (desiredSize < 2 * value.length) {
-            newSize = value.length * 2;
-            tmp = new char[newSize];
-        } else {
-            newSize = value.length * 2 + count;
-            tmp = new char[newSize];
-        }
-
-        System.arraycopy(value, 0, tmp, 0, end);
-        value = tmp;
-        tmp = null;
-    }
-
-    public void toLower() {
-        for (int i = start; i < end; i++) {
-            char c = value[i];
-            if (c < 0x7F) {
-                if (BBuffer.isUpper(c)) {
-                    value[i] = (char) BBuffer.toLower(c);
-                }
-
-            }
-        }
-    }
-
-
-}

==================================================
FastHttpDateFormat.java
deleted file mode 100644
index 31529fe5ce..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/DumpChannel.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-
-// TODO: dump to a file, hex, etc.
-
-/**
- * For debug - will print all bytes that go trough the channel
- */
-public class DumpChannel extends IOChannel {
-
-    IOBuffer in = new IOBuffer(this);
-    IOBuffer out = new IOBuffer(this);
-    static final boolean dumpToFile = false;
-    static int idCnt = 0;
-
-    DumpChannel(String id) {
-        this.id = id + idCnt++;
-    }
-
-    public static IOChannel wrap(String id, IOChannel net) throws IOException {
-        if (id == null) {
-            id = "";
-        }
-        DumpChannel dmp = new DumpChannel(id + idCnt++);
-        net.setHead(dmp);
-        return dmp;
-    }
-
-    public String toString() {
-        return "Dump-" + id + "-" + net.toString();
-    }
-
-    @Override
-    public void handleReceived(IOChannel ch) throws IOException {
-        processInput(ch.getIn());
-    }
-
-    private void processInput(IOBuffer netIn) throws IOException {
-        boolean any = false;
-        while (true) {
-            BBucket first = netIn.popFirst();
-            if (first == null) {
-                if (netIn.isClosedAndEmpty()) {
-                    out("IN", first, true);
-                    in.close();
-                    any = true;
-                }
-                if (any) {
-                    sendHandleReceivedCallback();
-                }
-                return;
-            }
-            any = true;
-            out("IN", first, false);
-            if (!in.isAppendClosed()) {
-                in.queue(first);
-            }
-        }
-    }
-
-    public void startSending() throws IOException {
-        while (true) {
-            BBucket first = out.popFirst();
-            if (first == null) {
-                if (out.isClosedAndEmpty()) {
-                    out("OUT", first, true);
-                    net.getOut().close();
-                }
-
-                net.startSending();
-                return;
-            }
-            // Dump
-            out("OUT", first, net.getOut().isAppendClosed());
-            net.getOut().queue(first);
-        }
-    }
-
-    static int did = 0;
-
-    protected void out(String dir, BBucket first, boolean closed) {
-        // Dump
-        if (first != null) {
-            String hd = Hex.getHexDump(first.array(), first.position(),
-                    first.remaining(), true);
-            System.err.println("\n" + dir + ": " + id + " " +
-                    (closed ? "CLS" : "") +
-                    + first.remaining() + "\n" +
-                    hd);
-        } else {
-            System.err.println("\n" + dir + ": " + id + " " +
-                    (closed ? "CLS " : "") +
-                     "END\n");
-        }
-        if (dumpToFile && first != null) {
-            try {
-                OutputStream os = new FileOutputStream("dmp" + did++);
-                os.write(first.array(), first.position(), first.remaining());
-                os.close();
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    @Override
-    public IOBuffer getIn() {
-        return in;
-    }
-
-    @Override
-    public IOBuffer getOut() {
-        return out;
-    }
-}

==================================================
FileConnector.java
deleted file mode 100644
index f74b9b5340..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/FastHttpDateFormat.java
+++ /dev/null
@@ -1,231 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.lite.io;
-
-import java.text.DateFormat;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-import java.util.TimeZone;
-import java.util.concurrent.ConcurrentHashMap;
-
-/**
- * Utility class to generate HTTP dates.
- *
- * @author Remy Maucherat
- */
-public final class FastHttpDateFormat {
-
-
-    // -------------------------------------------------------------- Variables
-
-
-    protected static final int CACHE_SIZE =
-        Integer.parseInt(System.getProperty("org.apache.tomcat.util.http.FastHttpDateFormat.CACHE_SIZE", "1000"));
-
-
-    /**
-     * HTTP date format.
-     */
-    protected static final SimpleDateFormat format =
-        new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-
-
-    /**
-     * The set of SimpleDateFormat formats to use in getDateHeader().
-     */
-    protected static final SimpleDateFormat formats[] = {
-        new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US),
-        new SimpleDateFormat("EEEEEE, dd-MMM-yy HH:mm:ss zzz", Locale.US),
-        new SimpleDateFormat("EEE MMMM d HH:mm:ss yyyy", Locale.US)
-    };
-
-
-    protected final static TimeZone gmtZone = TimeZone.getTimeZone("GMT");
-
-
-    /**
-     * GMT timezone - all HTTP dates are on GMT
-     */
-    static {
-
-        format.setTimeZone(gmtZone);
-
-        formats[0].setTimeZone(gmtZone);
-        formats[1].setTimeZone(gmtZone);
-        formats[2].setTimeZone(gmtZone);
-
-    }
-
-
-    /**
-     * Instant on which the currentDate object was generated.
-     */
-    protected static long currentDateGenerated = 0L;
-
-
-    /**
-     * Current formatted date.
-     */
-    protected static String currentDate = null;
-
-
-    /**
-     * Formatter cache.
-     */
-    protected static final ConcurrentHashMap<Long, String> formatCache =
-        new ConcurrentHashMap<Long, String>(CACHE_SIZE);
-
-
-    /**
-     * Parser cache.
-     */
-    protected static final ConcurrentHashMap<String, Long> parseCache =
-        new ConcurrentHashMap<String, Long>(CACHE_SIZE);
-
-
-    // --------------------------------------------------------- Public Methods
-
-
-    /**
-     * Get the current date in HTTP format.
-     */
-    public static final String getCurrentDate() {
-
-        long now = System.currentTimeMillis();
-        if ((now - currentDateGenerated) > 1000) {
-            synchronized (format) {
-                if ((now - currentDateGenerated) > 1000) {
-                    currentDateGenerated = now;
-                    currentDate = format.format(new Date(now));
-                }
-            }
-        }
-        return currentDate;
-
-    }
-
-
-    /**
-     * Get the HTTP format of the specified date.
-     */
-    public static final String formatDate
-        (long value, DateFormat threadLocalformat) {
-
-        Long longValue = new Long(value);
-        String cachedDate = formatCache.get(longValue);
-        if (cachedDate != null)
-            return cachedDate;
-
-        String newDate = null;
-        Date dateValue = new Date(value);
-        if (threadLocalformat != null) {
-            newDate = threadLocalformat.format(dateValue);
-            updateFormatCache(longValue, newDate);
-        } else {
-            synchronized (formatCache) {
-                synchronized (format) {
-                    newDate = format.format(dateValue);
-                }
-                updateFormatCache(longValue, newDate);
-            }
-        }
-        return newDate;
-
-    }
-
-
-    /**
-     * Try to parse the given date as a HTTP date.
-     */
-    public static final long parseDate(String value,
-                                       DateFormat[] threadLocalformats) {
-
-        Long cachedDate = parseCache.get(value);
-        if (cachedDate != null)
-            return cachedDate.longValue();
-
-        Long date = null;
-        if (threadLocalformats != null) {
-            date = internalParseDate(value, threadLocalformats);
-            updateParseCache(value, date);
-        } else {
-            synchronized (parseCache) {
-                date = internalParseDate(value, formats);
-                updateParseCache(value, date);
-            }
-        }
-        if (date == null) {
-            return (-1L);
-        } else {
-            return date.longValue();
-        }
-
-    }
-
-
-    /**
-     * Parse date with given formatters.
-     */
-    private static final Long internalParseDate
-        (String value, DateFormat[] formats) {
-        Date date = null;
-        for (int i = 0; (date == null) && (i < formats.length); i++) {
-            try {
-                date = formats[i].parse(value);
-            } catch (ParseException e) {
-                ;
-            }
-        }
-        if (date == null) {
-            return null;
-        }
-        return new Long(date.getTime());
-    }
-
-
-    /**
-     * Update cache.
-     */
-    private static void updateFormatCache(Long key, String value) {
-        if (value == null) {
-            return;
-        }
-        if (formatCache.size() > CACHE_SIZE) {
-            formatCache.clear();
-        }
-        formatCache.put(key, value);
-    }
-
-
-    /**
-     * Update cache.
-     */
-    private static void updateParseCache(String key, Long value) {
-        if (value == null) {
-            return;
-        }
-        if (parseCache.size() > CACHE_SIZE) {
-            parseCache.clear();
-        }
-        parseCache.put(key, value);
-    }
-
-
-}

==================================================
FileConnectorJavaIo.java
deleted file mode 100644
index f4dd93b620..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/FileConnector.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-
-/**
- * Initial abstraction for non-blocking File access and to
- * support other abstraction.
- *
- * Tomcat uses JNDI - but that's blocking, does lots of data copy,
- * is complex.
- *
- * Work in progress..
- */
-public abstract class FileConnector extends IOConnector {
-
-    public static class FileInfo {
-        String type;
-        int mode;
-        long size;
-
-    }
-
-    public abstract boolean isDirectory(String path);
-
-    public abstract boolean isFile(String path);
-}

==================================================
FutureCallbacks.java
deleted file mode 100644
index 082c025e1f..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/FileConnectorJavaIo.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.File;
-import java.io.IOException;
-
-
-/**
- * Catalina uses JNDI to abstract filesystem - this is both heavy and
- * a bit complex.
- *
- * This is also a bit complex - but hopefully we can implement it as
- * non-blocking and without much copy.
- *
- */
-public class FileConnectorJavaIo extends FileConnector {
-    File base;
-
-    public FileConnectorJavaIo(File file) {
-        this.base = file;
-    }
-
-    @Override
-    public boolean isDirectory(String path) {
-        File file = new File(base, path);
-        return file.isDirectory();
-    }
-
-    @Override
-    public boolean isFile(String path) {
-        File file = new File(base, path);
-        return file.exists() && !file.isDirectory();
-    }
-
-    @Override
-    public void acceptor(ConnectedCallback sc,
-            CharSequence port,
-            Object extra) throws IOException {
-        // TODO: unix domain socket impl.
-        // Maybe: detect new files in the filesystem ?
-    }
-
-    @Override
-    public void connect(String host, int port, ConnectedCallback sc)
-            throws IOException {
-    }
-
-}
\ No newline at end of file

==================================================
Hex.java
deleted file mode 100644
index 782228c28d..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/FutureCallbacks.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.locks.AbstractQueuedSynchronizer;
-
-
-
-/**
- * Support for blocking calls and callbacks.
- *
- * Unlike FutureTask, it is possible to reuse this and hopefully
- * easier to extends. Also has callbacks.
- *
- * @author Costin Manolache
- */
-public class FutureCallbacks<V> implements Future<V> {
-
-    // Other options: ReentrantLock uses AbstractQueueSynchronizer,
-    // more complex. Same for CountDownLatch
-    // FutureTask - uses Sync as well, ugly interface with
-    // Callable, can't be recycled.
-    // Mina: simple object lock, doesn't extend java.util.concurent.Future
-
-    private Sync sync = new Sync();
-
-    private V value;
-
-    public static interface Callback<V> {
-        public void run(V param);
-    }
-
-    private List<Callback<V>> callbacks = new ArrayList();
-
-    public FutureCallbacks() {
-    }
-
-    /**
-     * Unlocks the object if it was locked. Should be called
-     * when the object is reused.
-     *
-     * Callbacks will not be invoked.
-     */
-    public void reset() {
-        sync.releaseShared(0);
-        sync.reset();
-    }
-
-    public void recycle() {
-        callbacks.clear();
-        sync.releaseShared(0);
-        sync.reset();
-    }
-
-    /**
-     * Unlocks object and calls the callbacks.
-     * @param v
-     *
-     * @throws IOException
-     */
-    public void signal(V v) throws IOException {
-        sync.releaseShared(0);
-        onSignal(v);
-    }
-
-    protected boolean isSignaled() {
-        return true;
-    }
-
-    /**
-     * Override to call specific callbacks
-     */
-    protected void onSignal(V v) {
-        for (Callback<V> cb: callbacks) {
-            if (cb != null) {
-                cb.run(v);
-            }
-        }
-    }
-
-    /**
-     * Set the response. Will cause the callback to be called and lock to be
-     * released.
-     *
-     * @param value
-     * @throws IOException
-     */
-    public void setValue(V value) throws IOException {
-        synchronized (this) {
-            this.value = value;
-            signal(value);
-        }
-    }
-
-    public void waitSignal(long to) throws IOException {
-        try {
-            get(to, TimeUnit.MILLISECONDS);
-        } catch (InterruptedException e1) {
-            throw new WrappedException(e1);
-        } catch (TimeoutException e1) {
-            throw new WrappedException(e1);
-        } catch (ExecutionException e) {
-            throw new WrappedException(e);
-        }
-    }
-
-    @Override
-    public V get() throws InterruptedException, ExecutionException {
-        sync.acquireSharedInterruptibly(0);
-        return value;
-    }
-
-    @Override
-    public V get(long timeout, TimeUnit unit) throws InterruptedException,
-            ExecutionException, TimeoutException {
-        if (!sync.tryAcquireSharedNanos(0, unit.toNanos(timeout))) {
-            throw new TimeoutException("Waiting " + timeout);
-        }
-        return value;
-    }
-
-
-    @Override
-    public boolean cancel(boolean mayInterruptIfRunning) {
-        return false;
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return false;
-    }
-
-    @Override
-    public boolean isDone() {
-        return sync.isSignaled();
-    }
-
-    private class Sync extends AbstractQueuedSynchronizer {
-
-        static final int DONE = 1;
-        static final int BLOCKED = 0;
-        Object result;
-        Throwable t;
-
-        @Override
-        protected int tryAcquireShared(int ignore) {
-            return getState() == DONE ? 1 : -1;
-        }
-
-        @Override
-        protected boolean tryReleaseShared(int ignore) {
-            setState(DONE);
-            return true;
-        }
-
-        public void reset() {
-            setState(BLOCKED);
-        }
-
-        boolean isSignaled() {
-            return getState() == DONE;
-        }
-    }
-}

==================================================
IOBuffer.java
deleted file mode 100644
index 78a5fe27db..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/Hex.java
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.lite.io;
-
-import java.io.ByteArrayOutputStream;
-
-/**
- * Tables useful when converting byte arrays to and from strings of hexadecimal
- * digits.
- * Code from Ajp11, from Apache's JServ.
- *
- * @author Craig R. McClanahan
- */
-
-public final class Hex {
-
-
-    // -------------------------------------------------------------- Constants
-
-    /**
-     *  Table for HEX to DEC byte translation.
-     */
-    public static final int[] DEC = {
-        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        00, 01, 02, 03, 04, 05, 06, 07,  8,  9, -1, -1, -1, -1, -1, -1,
-        -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-    };
-
-
-    /**
-     * Table for DEC to HEX byte translation.
-     */
-    public static final byte[] HEX =
-    { (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5',
-      (byte) '6', (byte) '7', (byte) '8', (byte) '9', (byte) 'a', (byte) 'b',
-      (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f' };
-
-
-    // --------------------------------------------------------- Static Methods
-
-
-    /**
-     * Convert a String of hexadecimal digits into the corresponding
-     * byte array by encoding each two hexadecimal digits as a byte.
-     *
-     * @param digits Hexadecimal digits representation
-     *
-     * @exception IllegalArgumentException if an invalid hexadecimal digit
-     *  is found, or the input string contains an odd number of hexadecimal
-     *  digits
-     */
-    public static byte[] convert(String digits) {
-
-	ByteArrayOutputStream baos = new ByteArrayOutputStream();
-	for (int i = 0; i < digits.length(); i += 2) {
-	    char c1 = digits.charAt(i);
-	    if ((i+1) >= digits.length())
-	        throw new IllegalArgumentException
-		        ("hexUtil.odd");
-	    char c2 = digits.charAt(i + 1);
-	    byte b = 0;
-	    if ((c1 >= '0') && (c1 <= '9'))
-		b += ((c1 - '0') * 16);
-	    else if ((c1 >= 'a') && (c1 <= 'f'))
-		b += ((c1 - 'a' + 10) * 16);
-	    else if ((c1 >= 'A') && (c1 <= 'F'))
-		b += ((c1 - 'A' + 10) * 16);
-	    else
-		throw new IllegalArgumentException
-		    ("hexUtil.bad");
-	    if ((c2 >= '0') && (c2 <= '9'))
-		b += (c2 - '0');
-	    else if ((c2 >= 'a') && (c2 <= 'f'))
-		b += (c2 - 'a' + 10);
-	    else if ((c2 >= 'A') && (c2 <= 'F'))
-		b += (c2 - 'A' + 10);
-	    else
-		throw new IllegalArgumentException
-		    ("hexUtil.bad");
-	    baos.write(b);
-	}
-	return (baos.toByteArray());
-
-    }
-
-
-    /**
-     * Convert a byte array into a printable format containing a
-     * String of hexadecimal digit characters (two per byte).
-     *
-     * @param bytes Byte array representation
-     */
-    public static String convert(byte bytes[]) {
-
-	StringBuffer sb = new StringBuffer(bytes.length * 2);
-	for (int i = 0; i < bytes.length; i++) {
-	    sb.append(convertDigit((bytes[i] >> 4)));
-	    sb.append(convertDigit((bytes[i] & 0x0f)));
-	}
-	return (sb.toString());
-
-    }
-
-
-    /**
-     * Convert 4 hex digits to an int, and return the number of converted
-     * bytes.
-     *
-     * @param hex Byte array containing exactly four hexadecimal digits
-     *
-     * @exception IllegalArgumentException if an invalid hexadecimal digit
-     *  is included
-     */
-    public static int convert2Int( byte[] hex ) {
-	// Code from Ajp11, from Apache's JServ
-
-	// assert b.length==4
-	// assert valid data
-	int len;
-	if(hex.length < 4 ) return 0;
-	if( DEC[hex[0]]<0 )
-	    throw new IllegalArgumentException("hexUtil.bad");
-	len = DEC[hex[0]];
-	len = len << 4;
-	if( DEC[hex[1]]<0 )
-	    throw new IllegalArgumentException("hexUtil.bad");
-	len += DEC[hex[1]];
-	len = len << 4;
-	if( DEC[hex[2]]<0 )
-	    throw new IllegalArgumentException("hexUtil.bad");
-	len += DEC[hex[2]];
-	len = len << 4;
-	if( DEC[hex[3]]<0 )
-	    throw new IllegalArgumentException("hexUtil.bad");
-	len += DEC[hex[3]];
-	return len;
-    }
-
-
-
-    /**
-     * Provide a mechanism for ensuring this class is loaded.
-     */
-    public static void load() {
-        // Nothing to do
-    }
-
-    /**
-     * [Private] Convert the specified value (0 .. 15) to the corresponding
-     * hexadecimal digit.
-     *
-     * @param value Value to be converted
-     */
-    private static char convertDigit(int value) {
-
-	value &= 0x0f;
-	if (value >= 10)
-	    return ((char) (value - 10 + 'a'));
-	else
-	    return ((char) (value + '0'));
-
-    }
-
-    /**
-     * <code>getHexValue</code> displays a formatted hex
-     * representation of the passed byte array.  It also
-     * allows for only a specified offset and length of
-     * a particular array to be returned.
-     *
-     * @param bytes <code>byte[]</code> array to process.
-     * @param pos offset to begin processing.
-     * @param len number of bytes to process.
-     * @return <code>String</code> formatted hex representation of processed
-     *         array.
-     */
-    public static String getHexDump(byte[] bytes, int pos, int len,
-                                     boolean displayOffset) {
-        StringBuffer out = new StringBuffer( len * 2 );
-
-        for (int j = 0; j < len; j += 16) {
-            hexLine(out, bytes, pos + j, pos + len, displayOffset);
-        }
-
-        return out.toString();
-    }
-
-    private static void hexLine(StringBuffer out,
-                                byte[] bytes, int start, int end,
-                                boolean displayOffset) {
-
-        if ( displayOffset ) {
-            out.append(convertDigit((int) (start >> 12)));
-            out.append(convertDigit((int) (start >> 8)));
-            out.append(convertDigit((int) (start >> 4)));
-            out.append(convertDigit(start & 0x0F));
-            out.append(": ");
-        }
-        for (int i = start; i < start + 16; i++) {
-
-            if (i < end) {
-                out.append(convertDigit((int) (bytes[i] >> 4)));
-                out.append(convertDigit(bytes[i] & 0x0F));
-                out.append(" ");
-            } else {
-                out.append("   ");
-            }
-        }
-
-        out.append(" | ");
-
-        for (int i = start; i < start + 16 && i < end; i++) {
-            if( ! Character.isISOControl( (char)bytes[i] )) {
-                out.append( new Character((char)bytes[i]) );
-            } else {
-                out.append( "." );
-            }
-        }
-
-        out.append("\n");
-    }
-}

==================================================
IOChannel.java
deleted file mode 100644
index 04ac2688b4..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOBuffer.java
+++ /dev/null
@@ -1,698 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.ByteBuffer;
-import java.util.LinkedList;
-import java.util.logging.Logger;
-
-
-// TODO: append() will trigger callbacks - do it explicitely !!!
-// TODO: queue() shouldn't modify the buffer
-
-
-/**
- * A list of data buckets.
- *
- * @author Costin Manolache
- */
-public class IOBuffer {
-    static Logger log = Logger.getLogger("IOBrigade");
-
-    static int ALLOC_SIZE = 8192;
-    long defaultTimeout = Long.MAX_VALUE;
-
-    private LinkedList<BBucket> buffers = new LinkedList<BBucket>();
-
-    // close() has been called for out,
-    // or EOF/FIN received for in. It may still have data.
-    boolean closeQueued;
-
-    // Will be signalled (open) when there is data in the buffer.
-    // also used to sync on.
-    FutureCallbacks<IOBuffer> hasDataLock = new FutureCallbacks<IOBuffer>() {
-        protected boolean isSignaled() {
-            return hasData();
-        }
-    };
-
-    // may be null
-    protected IOChannel ch;
-
-    // Support for appending - needs improvements.
-    // appendable buffer is part of the buffer list if it has
-    // data, and kept here if empty.
-    BBuffer appendable;
-    boolean appending = false;
-    ByteBuffer writeBuffer;
-
-
-    public IOBuffer() {
-    }
-
-    public IOBuffer(IOChannel ch) {
-        this.ch = ch;
-    }
-
-    public IOChannel getChannel() {
-        return ch;
-    }
-
-    // ===== Buffer access =====
-
-
-    /**
-     * Return first non-empty buffer.
-     *
-     * The append buffer is part of the buffer list, and is left alone and
-     * empty.
-     *
-     * @return
-     */
-    public BBucket peekFirst() {
-        synchronized (buffers) {
-            BBucket o = (buffers.size() == 0) ? null : buffers.getFirst();
-
-            while (true) {
-                boolean empty = o == null || isEmpty(o);
-                if (o == null) {
-                    //hasDataLock.reset();
-                    return null; // no data in buffers
-                }
-                // o != null
-                if (empty) {
-                    buffers.removeFirst();
-                    o = (buffers.size() == 0) ? null : buffers.getFirst();
-                } else {
-                    return o;
-                }
-            }
-        }
-    }
-
-    public BBucket peekBucket(int idx) {
-        synchronized (buffers) {
-            return buffers.get(idx);
-        }
-    }
-
-
-    public void advance(int len) {
-        while (len > 0) {
-            BBucket first = peekFirst();
-            if (first == null) {
-                return;
-            }
-            if (len > first.remaining()) {
-                len -= first.remaining();
-                first.position(first.limit());
-            } else {
-                first.position(first.position() + len);
-                len = 0;
-            }
-        }
-    }
-
-    public void queue(String s) throws IOException {
-        // TODO: decode with prober charset
-        byte[] bytes = s.getBytes("UTF8");
-        queueInternal(BBuffer.wrapper(bytes, 0, bytes.length));
-    }
-
-    public void queue(BBuffer bc) throws IOException {
-        queueInternal(bc);
-    }
-
-    public void queue(Object bb) throws IOException {
-        queueInternal(bb);
-    }
-
-    private void queueInternal(Object bb) throws IOException {
-        if (closeQueued) {
-            throw new IOException("Closed");
-        }
-        synchronized (buffers) {
-            if (appending) {
-                throw new RuntimeException("Unexpected queue while " +
-                                "appending");
-            }
-            BBucket add = wrap(bb);
-            buffers.add(add);
-            //log.info("QUEUED: " + add.remaining() + " " + this);
-            notifyDataAvailable(add);
-        }
-
-    }
-
-    public int getBufferCount() {
-        peekFirst();
-        synchronized (buffers) {
-            return buffers.size();
-        }
-    }
-
-    public void clear() {
-        synchronized (buffers) {
-            buffers.clear();
-        }
-    }
-
-    public void recycle() {
-        closeQueued = false;
-        clear();
-        // Normally unlocked
-        hasDataLock.recycle();
-
-        appending = false;
-        appendable = null;
-    }
-
-    // ===================
-    /**
-     * Closed for append. It may still have data.
-     * @return
-     */
-    public boolean isClosedAndEmpty() {
-        return closeQueued && 0 == getBufferCount();
-    }
-
-
-    /**
-     * Mark as closed - but will not send data.
-     */
-    public void close() throws IOException {
-        if (closeQueued) {
-            return;
-        }
-        closeQueued = true;
-        notifyDataAvailable(null);
-    }
-
-
-    private boolean isEmpty(BBucket o) {
-        if (o instanceof BBucket &&
-                ((BBucket) o).remaining() == 0) {
-            return true;
-        }
-        return false;
-    }
-
-    private BBucket wrap(Object src) {
-        if (src instanceof byte[]) {
-            return BBuffer.wrapper((byte[]) src, 0, ((byte[]) src).length);
-        }
-        if (src instanceof ByteBuffer) {
-            //return src;
-            ByteBuffer bb = (ByteBuffer) src;
-            return BBuffer.wrapper(bb.array(), bb.position(),
-                        bb.remaining());
-        }
-        if (src instanceof byte[]) {
-            byte[] bb = (byte[]) src;
-            return BBuffer.wrapper(bb, 0, bb.length);
-        }
-        return (BBucket) src;
-    }
-
-    protected void notifyDataAvailable(Object bb) throws IOException {
-        synchronized (hasDataLock) {
-            hasDataLock.signal(this); // or bb ?
-        }
-    }
-
-    public boolean hasData() {
-        return closeQueued || peekFirst() != null;
-    }
-
-    public void waitData(long timeMs) throws IOException {
-        if (timeMs == 0) {
-            timeMs = defaultTimeout;
-        }
-        synchronized (hasDataLock) {
-            if (hasData()) {
-                return;
-            }
-            hasDataLock.reset();
-        }
-        hasDataLock.waitSignal(timeMs);
-    }
-
-
-    public boolean isAppendClosed() {
-        return closeQueued;
-    }
-
-    // =================== Helper methods ==================
-
-    /**
-     * Non-blocking read.
-     *
-     * @return -1 if EOF, -2 if no data available, or 0..255 for normal read.
-     */
-    public int read() throws IOException {
-        if (isClosedAndEmpty()) {
-            return -1;
-        }
-        BBucket bucket = peekFirst();
-        if (bucket == null) {
-            return -2;
-        }
-        int res = bucket.array()[bucket.position()];
-        bucket.position(bucket.position() + 1);
-        return res & 0xFF;
-    }
-
-    public int peek() throws IOException {
-        BBucket bucket = peekFirst();
-        if (bucket == null) {
-            return -1;
-        }
-        int res = bucket.array()[bucket.position()];
-        return res;
-    }
-
-    public int find(char c) {
-        int pos = 0;
-        for (int i = 0; i < buffers.size(); i++) {
-            BBucket bucket = buffers.get(i);
-            if (bucket == null || bucket.remaining() == 0) {
-                continue;
-            }
-            int found= BBuffer.findChar(bucket.array(), bucket.position(),
-                    bucket.limit(), c);
-            if (found >= 0) {
-                return pos + found;
-            }
-            pos += bucket.remaining();
-        }
-        return -1;
-    }
-
-    public int readLine(BBuffer bc) throws IOException {
-        return readToDelim(bc, '\n');
-    }
-
-    /**
-     * Copy up to and including "delim".
-     *
-     * @return number of bytes read, or -1 for end of stream.
-     */
-    int readToDelim(BBuffer bc, int delim) throws IOException {
-        int len = 0;
-        for (int idx = 0; idx < buffers.size(); idx++) {
-            BBucket bucket = buffers.get(idx);
-            if (bucket == null || bucket.remaining() == 0) {
-                continue;
-            }
-            byte[] data = bucket.array();
-            int end = bucket.limit();
-            int start = bucket.position();
-            for (int i = start; i < end; i++) {
-                byte chr = data[i];
-                bc.put(chr);
-                if (chr == delim) {
-                    bucket.position(i + 1);
-                    len += (i - start + 1);
-                    return len;
-                }
-            }
-            bucket.position(end); // empty - should be removed
-        }
-        if (len == 0 && isClosedAndEmpty()) {
-            return -1;
-        }
-        return len;
-    }
-
-
-    public int write(ByteBuffer bb) throws IOException {
-        int len = bb.remaining();
-        int pos = bb.position();
-        if (len == 0) {
-            return 0;
-        }
-        append(bb);
-        bb.position(pos + len);
-        return len;
-    }
-
-    public int read(byte[] buf, int off, int len) throws IOException {
-        if (isClosedAndEmpty()) {
-            return -1;
-        }
-        int rd = 0;
-        while (true) {
-            BBucket bucket = peekFirst();
-            if (bucket == null) {
-                return rd;
-            }
-            int toCopy = Math.min(len, bucket.remaining());
-            System.arraycopy(bucket.array(), bucket.position(),
-                    buf, off + rd, toCopy);
-            bucket.position(bucket.position() + toCopy);
-            rd += toCopy;
-            len -= toCopy;
-            if (len == 0) {
-                return rd;
-            }
-        }
-
-    }
-
-    public int read(BBuffer bb, int len) throws IOException {
-        bb.makeSpace(len);
-        int rd = read(bb.array(), bb.limit(), len);
-        if (rd < 0) {
-            return rd;
-        }
-        bb.limit(bb.limit() + rd);
-        return rd;
-    }
-
-    /**
-     * Non-blocking read.
-     */
-    public int read(ByteBuffer bb) {
-        if (isClosedAndEmpty()) {
-            return -1;
-        }
-        int len = 0;
-        while (true) {
-            int space = bb.remaining(); // to append
-            if (space == 0) {
-                return len;
-            }
-            BBucket first = peekFirst();
-            if (first == null) {
-                return len;
-            }
-            BBucket iob = ((BBucket) first);
-            if (space > iob.remaining()) {
-                space = iob.remaining();
-            }
-            bb.put(iob.array(), iob.position(), space);
-
-            iob.position(iob.position() + space);
-            iob.release();
-            len += space;
-        }
-    }
-
-
-    public BBuffer readAll(BBuffer chunk) throws IOException {
-        if (chunk == null) {
-            chunk = allocate();
-        }
-        while (true) {
-            if (isClosedAndEmpty()) {
-                return chunk;
-            }
-            BBucket first = peekFirst();
-            if (first == null) {
-                return chunk;
-            }
-            BBucket iob = ((BBucket) first);
-            chunk.append(iob.array(), iob.position(), iob.remaining());
-            iob.position(iob.position() + iob.remaining());
-            iob.release();
-
-        }
-    }
-
-    private BBuffer allocate() {
-        int size = 0;
-        for (int i = 0; i < getBufferCount(); i++) {
-            BBucket first = peekBucket(i);
-            if (first != null) {
-                size += first.remaining();
-            }
-        }
-        return BBuffer.allocate(size);
-    }
-
-    public BBuffer copyAll(BBuffer chunk) throws IOException {
-        if (chunk == null) {
-            chunk = allocate();
-        }
-        for (int i = 0; i < getBufferCount(); i++) {
-            BBucket iob = peekBucket(i);
-            chunk.append(iob.array(), iob.position(), iob.remaining());
-        }
-        return chunk;
-    }
-
-    public IOBuffer append(InputStream is) throws IOException {
-        while (true) {
-            ByteBuffer bb = getWriteBuffer();
-            int rd = is.read(bb.array(), bb.position(), bb.remaining());
-            if (rd <= 0) {
-                return this;
-            }
-            bb.position(bb.position() + rd);
-            releaseWriteBuffer(rd);
-        }
-    }
-
-    public IOBuffer append(BBuffer bc) throws IOException {
-        return append(bc.array(), bc.getStart(), bc.getLength());
-    }
-
-    public IOBuffer append(byte[] data) throws IOException {
-        return append(data, 0, data.length);
-    }
-
-    public IOBuffer append(byte[] data, int start, int len) throws IOException {
-        if (closeQueued) {
-            throw new IOException("Closed");
-        }
-        ByteBuffer bb = getWriteBuffer();
-
-        int i = start;
-        int end = start + len;
-        while (i < end) {
-            int rem = Math.min(end - i, bb.remaining());
-            // to write
-            bb.put(data, i, rem);
-            i += rem;
-            if (bb.remaining() < 8) {
-                releaseWriteBuffer(1);
-                bb = getWriteBuffer();
-            }
-        }
-
-        releaseWriteBuffer(1);
-        return this;
-    }
-
-    public IOBuffer append(int data) throws IOException {
-        if (closeQueued) {
-            throw new IOException("Closed");
-        }
-        ByteBuffer bb = getWriteBuffer();
-        bb.put((byte) data);
-        releaseWriteBuffer(1);
-        return this;
-    }
-
-    public IOBuffer append(ByteBuffer cs) throws IOException {
-        return append(cs.array(), cs.position() + cs.arrayOffset(),
-                cs.remaining());
-    }
-
-    /**
-     *  Append a buffer. The buffer will not be modified.
-     */
-    public IOBuffer append(BBucket cs) throws IOException {
-        append(cs.array(), cs.position(), cs.remaining());
-        return this;
-    }
-
-    /**
-     *  Append a buffer. The buffer will not be modified.
-     */
-    public IOBuffer append(BBucket cs, int len) throws IOException {
-        append(cs.array(), cs.position(), len);
-        return this;
-    }
-
-    public IOBuffer append(IOBuffer cs) throws IOException {
-        for (int i = 0; i < cs.getBufferCount(); i++) {
-            BBucket o = cs.peekBucket(i);
-            append(o);
-        }
-
-        return this;
-    }
-
-    public IOBuffer append(IOBuffer cs, int len) throws IOException {
-        for (int i = 0; i < cs.getBufferCount(); i++) {
-            BBucket o = cs.peekBucket(i);
-            append(o);
-        }
-
-        return this;
-    }
-
-    public IOBuffer append(CharSequence cs) throws IOException {
-        byte[] data = cs.toString().getBytes();
-        append(data, 0, data.length);
-        return this;
-    }
-
-    public IOBuffer append(char c) throws IOException {
-        ByteBuffer bb = getWriteBuffer();
-        bb.put((byte) c);
-        releaseWriteBuffer(1);
-        return this;
-    }
-
-    /**
-     * All operations that iterate over buffers must be
-     * sync
-     * @return
-     */
-    public synchronized int available() {
-        int a = 0;
-        int cnt = buffers.size();
-        for (int i = 0; i < cnt; i++) {
-            a += buffers.get(i).remaining();
-        }
-        return a;
-    }
-
-    public String toString() {
-        return "IOB:{c:" + getBufferCount() +
-          ", b:" + available() +
-          (isAppendClosed() ? ", C}" : " }");
-    }
-
-    public BBucket popLen(int lenToConsume) {
-        BBucket o = peekFirst(); // skip empty
-        if (o == null) {
-            return null;
-        }
-        BBucket sb = BBuffer.wrapper(o.array(),
-                o.position(), lenToConsume);
-        o.position(o.position() + lenToConsume);
-        return sb;
-    }
-
-    public BBucket popFirst() {
-        BBucket o = peekFirst(); // skip empty
-        if (o == null) {
-            return null;
-        }
-        if (o == appendable) {
-            synchronized (buffers) {
-                    // TODO: concurrency ???
-                    BBucket sb =
-                        BBuffer.wrapper(appendable.array(),
-                                appendable.position(),
-                                appendable.limit() - appendable.position());
-                    appendable.position(appendable.limit());
-                    return sb;
-            }
-        } else {
-            buffers.removeFirst();
-        }
-        return o;
-    }
-
-
-    public ByteBuffer getWriteBuffer() throws IOException {
-        synchronized (buffers) {
-            if (closeQueued) {
-                throw new IOException("Closed");
-            }
-            BBucket last = (buffers.size() == 0) ?
-                    null : buffers.getLast();
-            if (last == null || last != appendable ||
-                    last.array().length - last.limit() < 16) {
-                last = BBuffer.allocate(ALLOC_SIZE);
-            }
-            appending = true;
-            appendable = (BBuffer) last;
-
-            if (writeBuffer == null || writeBuffer.array() != appendable.array()) {
-                writeBuffer = ByteBuffer.wrap(appendable.array());
-            }
-            writeBuffer.position(appendable.limit());
-            writeBuffer.limit(appendable.array().length);
-            return writeBuffer;
-        }
-    }
-
-    public void releaseWriteBuffer(int read) throws IOException {
-        synchronized (buffers) {
-            if (!appending) {
-                throw new IOException("Not appending");
-            }
-            if (writeBuffer != null) {
-                if (appendable.limit() != writeBuffer.position()) {
-                    appendable.limit(writeBuffer.position());
-                    // We have some more data.
-                    if (buffers.size() == 0 ||
-                            buffers.getLast() != appendable) {
-                        buffers.add(appendable);
-                    }
-                    notifyDataAvailable(appendable);
-                }
-            }
-            appending = false;
-        }
-    }
-
-
-    // ------ More utilities - for parsing request ( later )-------
-//  public final int skipBlank(ByteBuffer bb, int start) {
-//  // Skipping blank lines
-//  byte chr = 0;
-//  do {
-//    if (!bb.hasRemaining()) {
-//      return -1;
-//    }
-//    chr = bb.get();
-//  } while ((chr == HttpParser.CR) || (chr == HttpParser.LF));
-//  return bb.position();
-//}
-
-//public final int readToDelimAndLowerCase(ByteBuffer bb,
-//                                         byte delim,
-//                                         boolean lower) {
-//  boolean space = false;
-//  byte chr = 0;
-//  while (!space) {
-//    if (!bb.hasRemaining()) {
-//      return -1;
-//    }
-//    chr = bb.get();
-//    if (chr == delim) {
-//      space = true;
-//    }
-//    if (lower && (chr >= HttpParser.A) && (chr <= HttpParser.Z)) {
-//      bb.put(bb.position() - 1,
-//          (byte) (chr - HttpParser.LC_OFFSET));
-//    }
-//  }
-//  return bb.position();
-//}
-
-//public boolean skipSpace(ByteBuffer bb) {
-//  boolean space = true;
-//  while (space) {
-//    if (!bb.hasRemaining()) {
-//      return false;
-//    }
-//    byte chr = bb.get();
-//    if ((chr == HttpParser.SP) || (chr == HttpParser.HT)) {
-//      //
-//    } else {
-//      space = false;
-//      bb.position(bb.position() -1); // move back
-//    }
-//  }
-//  return true;
-//}
-}

==================================================
IOConnector.java
deleted file mode 100644
index a7db4dfa18..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOChannel.java
+++ /dev/null
@@ -1,371 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.ByteChannel;
-
-
-
-/**
- * Buffered, non-blocking ByteChannel.
- *
- * write() data will be added to the buffer. Call startSending() to
- * flush.
- *
- *
- *
- * - you can use it as a normal non-blocking ByteChannel.
- * - you can call getRead
- *
- * Very different from MINA IoFilters, also much lower level.
- *
- *
- * @author Costin Manolache
- */
-public abstract class IOChannel implements ByteChannel, IOConnector.DataReceivedCallback,
-        IOConnector.DataFlushedCallback {
-
-    /**
-     * If this channel wraps another channel - for example a socket.
-     * Will be null if this is the 'root' channel - a socket, memory.
-     */
-    protected IOChannel net;
-
-    /**
-     * Set with another channel layered on top of the current channel.
-     */
-    protected IOChannel head;
-
-    protected String id;
-
-    /**
-     * A string that can be parsed to extract the target.
-     * host:port for normal sockets
-     */
-    protected CharSequence target;
-
-    /**
-     * Connector that created the channel.
-     */
-    protected IOConnector connector;
-
-    /**
-     * Callbacks. Will be moved if a new head is inserted.
-     */
-    protected IOConnector.ConnectedCallback connectedCallback;
-
-    /**
-     * Will be called if any data is received.
-     * Will also be called on close. Close with lastException set indicates
-     * an error condition.
-     */
-    protected IOConnector.DataReceivedCallback dataReceivedCallback;
-
-    /**
-     * Out data is buffered, then sent with startSending.
-     * This callback indicates the data has been sent. Can be used
-     * to implement blocking flush.
-     */
-    protected IOConnector.DataFlushedCallback dataFlushedCallback;
-
-    // Last activity timestamp.
-    // TODO: update and use it ( placeholder )
-    public long ts;
-
-    /**
-     * If an async exception happens.
-     */
-    protected Throwable lastException;
-
-    protected IOChannel() {
-    }
-
-    public void setConnectedCallback(IOConnector.ConnectedCallback connectedCallback) {
-        this.connectedCallback = connectedCallback;
-    }
-
-    public void setDataReceivedCallback(IOConnector.DataReceivedCallback dataReceivedCallback) {
-        this.dataReceivedCallback = dataReceivedCallback;
-    }
-
-    /**
-     * Callback called when the bottom ( OS ) channel has finished flushing.
-     *
-     * @param dataFlushedCallback
-     */
-    public void setDataFlushedCallback(IOConnector.DataFlushedCallback dataFlushedCallback) {
-        this.dataFlushedCallback = dataFlushedCallback;
-    }
-
-    // Input
-    public abstract IOBuffer getIn();
-
-    // Output
-    public abstract IOBuffer getOut();
-
-
-    /**
-     * From downstream ( NET ). Pass it to the next channel.
-     */
-    public void handleReceived(IOChannel net) throws IOException {
-        sendHandleReceivedCallback();
-    }
-
-    /**
-     * Called from lower layer (NET) when the last flush is
-     * done and all buffers have been sent to OS ( or
-     * intended recipient ).
-     *
-     * Will call the callback or next filter, may do additional
-     * processing.
-     *
-     * @throws IOException
-     */
-    public void handleFlushed(IOChannel net) throws IOException {
-        sendHandleFlushedCallback();
-    }
-
-    private void sendHandleFlushedCallback() throws IOException {
-        try {
-            if (dataFlushedCallback != null) {
-                dataFlushedCallback.handleFlushed(this);
-            }
-            if (head != null) {
-                head.handleFlushed(this);
-            }
-        } catch (Throwable t) {
-            close();
-            if (t instanceof IOException) {
-                throw (IOException) t;
-            } else {
-                throw new WrappedException("Error in handleFlushed", t);
-            }
-        }
-    }
-
-
-    /**
-     * Notify next channel or callback that data has been received.
-     * Called after a lower channel gets more data ( in the IOThread
-     * for example ).
-     *
-     * Also called when closed stream is detected. Can be called
-     * to just force upper layers to check for data.
-     */
-    public void sendHandleReceivedCallback() throws IOException {
-        try {
-            if (dataReceivedCallback != null) {
-                dataReceivedCallback.handleReceived(this);
-            }
-            if (head != null) {
-                head.handleReceived(this);
-            }
-        } catch (Throwable t) {
-            t.printStackTrace();
-            try {
-                close();
-            } catch(Throwable t2) {
-                t2.printStackTrace();
-            }
-            if (t instanceof IOException) {
-                throw (IOException) t;
-            } else {
-                throw new WrappedException(t);
-            }
-        }
-    }
-
-    /**
-     * Return last IO exception.
-     *
-     * The channel is async, exceptions can happen at any time.
-     * The normal callback will be called ( connected, received ), it
-     * should check if the channel is closed and the exception.
-     */
-    public Throwable lastException() {
-        return lastException;
-    }
-
-    public void close() throws IOException {
-        shutdownOutput();
-        // Should it read the buffers ?
-
-        if (getIn() == null || getIn().isAppendClosed()) {
-            return;
-        } else {
-            getIn().close();
-            sendHandleReceivedCallback();
-        }
-        getIn().hasDataLock.signal(getIn());
-    }
-
-    public boolean isOpen() {
-        return getIn() != null &&
-        getOut() != null &&
-        !getIn().isAppendClosed() && !getOut().isAppendClosed();
-    }
-
-    public void shutdownOutput() throws IOException {
-        if (getOut() == null || getOut().isAppendClosed()) {
-            return;
-        } else {
-            getOut().close();
-            startSending();
-        }
-    }
-
-    public void setSink(IOChannel previous) throws IOException {
-        this.net = previous;
-    }
-
-    public IOChannel getSink() {
-        return net;
-    }
-
-    // Chaining/filtering
-
-    /**
-     * Called to add an filter after the current channel, for
-     * example set SSL on top of a socket channel.
-     *
-     * The 'next' channel will have the received/flushed callbacks
-     * of the current channel. The current channel's callbacks will
-     * be reset.
-     *
-     * "Head" is from STREAMS.
-     *
-     * @throws IOException
-     */
-    public IOChannel setHead(IOChannel head) throws IOException {
-        this.head = head;
-        head.setSink(this);
-
-        // TODO: do we want to migrate them automatically ?
-        head.setDataReceivedCallback(dataReceivedCallback);
-        head.setDataFlushedCallback(dataFlushedCallback);
-        // app.setClosedCallback(closedCallback);
-
-        dataReceivedCallback = null;
-        dataFlushedCallback = null;
-        return this;
-    }
-
-    public IOChannel getFirst() {
-        IOChannel first = this;
-        while (true) {
-            if (!(first instanceof IOChannel)) {
-                return first;
-            }
-            IOChannel before = ((IOChannel) first).getSink();
-            if (before == null) {
-                return first;
-            } else {
-                first = before;
-            }
-        }
-    }
-
-    // Socket support
-
-    public void readInterest(boolean b) throws IOException {
-        if (net != null) {
-            net.readInterest(b);
-        }
-    }
-
-    // Helpers
-
-    public int read(ByteBuffer bb) throws IOException {
-        return getIn().read(bb);
-    }
-
-    public int readNonBlocking(ByteBuffer bb) throws IOException {
-        return getIn().read(bb);
-    }
-
-    public void waitFlush(long timeMs) throws IOException {
-        return;
-    }
-
-    public int readBlocking(ByteBuffer bb, long timeMs) throws IOException {
-        getIn().waitData(timeMs);
-        return getIn().read(bb);
-    }
-
-    /**
-     * Capture all output in a buffer.
-     */
-    public BBuffer readAll(BBuffer chunk, long to)
-            throws IOException {
-        if (chunk == null) {
-            chunk = BBuffer.allocate();
-        }
-        while (true) {
-            getIn().waitData(to);
-            BBucket next = getIn().peekFirst();
-            if (getIn().isClosedAndEmpty() && next == null) {
-                return chunk;
-            }
-            if (next == null) {
-                continue; // false positive
-            }
-            chunk.append(next.array(), next.position(), next.remaining());
-            getIn().advance(next.remaining());
-        }
-    }
-
-    public int write(ByteBuffer bb) throws IOException {
-        return getOut().write(bb);
-    }
-
-    public void write(byte[] data) throws IOException {
-        getOut().append(data, 0, data.length);
-    }
-
-    public void write(String string) throws IOException {
-        write(string.getBytes());
-    }
-
-    /**
-     * Send data in out to the intended recipient.
-     * This is not blocking.
-     */
-    public abstract void startSending() throws IOException;
-
-
-    public void setId(String id) {
-        this.id = id;
-    }
-
-    public String getId() {
-        return id;
-    }
-
-    public CharSequence getTarget() {
-        if (net != null) {
-            return net.getTarget();
-        }
-        return target;
-    }
-
-    public void setTarget(CharSequence target) {
-        this.target = target;
-    }
-
-    public static final String ATT_REMOTE_HOSTNAME = "RemoteHostname";
-    public static final String ATT_LOCAL_HOSTNAME = "LocalHostname";
-    public static final String ATT_REMOTE_PORT = "RemotePort";
-    public static final String ATT_LOCAL_PORT = "LocalPort";
-    public static final String ATT_LOCAL_ADDRESS = "LocalAddress";
-    public static final String ATT_REMOTE_ADDRESS = "RemoteAddress";
-
-    public Object getAttribute(String name) {
-        if (net != null) {
-            return net.getAttribute(name);
-        }
-        return null;
-    }
-
-}

==================================================
IOInputStream.java
deleted file mode 100644
index 43441462f9..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOConnector.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-import java.util.Timer;
-
-
-/**
- * Factory for IOChannels, with support for caching.
- *
- *
- * @author Costin Manolache
- */
-public abstract class IOConnector {
-
-    public static interface DataReceivedCallback {
-        /**
-         * Called when data or EOF has been received.
-         */
-        public void handleReceived(IOChannel ch) throws IOException;
-    }
-
-    /**
-     * Callback for accept and connect.
-     *
-     * Will also be called if an error happens while connecting, in
-     * which case the connection will be closed.
-     */
-    public static interface ConnectedCallback {
-        public void handleConnected(IOChannel ch) throws IOException;
-    }
-
-    public static interface DataFlushedCallback {
-        public void handleFlushed(IOChannel ch) throws IOException;
-    }
-
-    protected Timer timer;
-
-    public Timer getTimer() {
-        return timer;
-    }
-
-    /**
-     * If the connector is layered on top of a different connector,
-     * return the lower layer ( for example the socket connector)
-     */
-    public IOConnector getNet() {
-        return null;
-    }
-
-    public abstract void acceptor(IOConnector.ConnectedCallback sc,
-                         CharSequence port, Object extra)
-        throws IOException;
-
-    // TODO: failures ?
-    // TODO: use String target or url
-    public abstract void connect(String host, int port,
-            IOConnector.ConnectedCallback sc) throws IOException;
-
-    public void stop() {
-        if (timer != null) {
-            timer.cancel();
-        }
-    }
-}

==================================================
IOOutputStream.java
deleted file mode 100644
index aebf5c573f..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOInputStream.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-
-/**
- * Similar with ServletInputStream - adds readLine(byte[]..), using
- * a IOBuffer.
- *
- *
- *
- * @author Costin Manolache
- */
-public class IOInputStream extends InputStream {
-
-    IOBuffer bb;
-    long timeout;
-
-    public IOInputStream(IOChannel httpCh, long to) {
-        bb = httpCh.getIn();
-        this.timeout = to;
-    }
-
-    @Override
-    public int read() throws IOException {
-        // getReadableBucket/peekFirst returns a buffer with at least
-        // 1 byte in it.
-        if (bb.isClosedAndEmpty()) {
-            return -1;
-        }
-        bb.waitData(timeout);
-        if (bb.isClosedAndEmpty()) {
-            return -1;
-        }
-
-        return bb.read();
-    }
-
-    public int read(byte[] buf, int off, int len) throws IOException {
-        if (bb.isClosedAndEmpty()) {
-            return -1;
-        }
-        bb.waitData(timeout);
-        if (bb.isClosedAndEmpty()) {
-            return -1;
-        }
-        return bb.read(buf, off, len);
-    }
-
-    /**
-     *  Servlet-style read line: terminator is \n or \r\n, left in buffer.
-     */
-    public int readLine(byte[] b, int off, int len) throws IOException {
-        if (len <= 0) {
-            return 0;
-        }
-        int count = 0, c;
-
-        while ((c = read()) != -1) {
-            b[off++] = (byte)c;
-            count++;
-            if (c == '\n' || count == len) {
-                break;
-            }
-        }
-        return count > 0 ? count : -1;
-    }
-}

==================================================
IOReader.java
deleted file mode 100644
index 90a6e021f7..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOOutputStream.java
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.CharConversionException;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.nio.ByteBuffer;
-import java.text.MessageFormat;
-
-/**
- * Same methods with ServletOutputStream.
- *
- * There is no restriction in using the Writer and InputStream at the
- * same time - the servlet layer will impose it for compat. You can also use
- * IOBuffer directly.
- *
- * If you mix stream and writer:
- *  - call BufferWriter.push() to make sure all chars are sent down
- *  - the BufferOutputStream doesn't cache any data, all goes to the
- *   IOBuffer.
- *  - flush() on BufferOutputStream and BufferWriter will send the data
- *  to the network and block until it gets to the socket ( so it can
- *  throw exception ).
- *  - You can also use non-blocking flush methods in IOBuffer, and a
- *  callback  if you want to know when the write was completed.
- *
- * @author Costin Manolache
- */
-public class IOOutputStream extends OutputStream {
-
-    IOBuffer bb;
-    IOChannel ch;
-    int bufferSize = 8 * 1024;
-
-    int wSinceFlush = 0;
-
-    public IOOutputStream(IOBuffer out, IOChannel httpMessage) {
-        this.bb = out;
-        ch = httpMessage;
-    }
-
-    public void recycle() {
-        wSinceFlush = 0;
-        bufferSize = 8 * 1024;
-    }
-
-    public void reset() {
-        wSinceFlush = 0;
-        bb.clear();
-    }
-
-    public int getWrittenSinceFlush() {
-        return wSinceFlush;
-    }
-
-
-    public int getBufferSize() {
-        return bufferSize;
-    }
-
-    public void setBufferSize(int size) {
-        if (size > bufferSize) {
-            bufferSize = size;
-        }
-    }
-
-    private void updateSize(int cnt) throws IOException {
-        wSinceFlush += cnt;
-        if (wSinceFlush > bufferSize) {
-            flush();
-        }
-    }
-
-    @Override
-    public void write(int b) throws IOException {
-        bb.append((char) b);
-        updateSize(1);
-    }
-
-    @Override
-    public void write(byte data[]) throws IOException {
-      write(data, 0, data.length);
-    }
-
-    @Override
-    public void write(byte data[], int start, int len) throws IOException {
-        bb.append(data, start, len);
-        updateSize(len);
-    }
-
-    public void flush() throws IOException {
-        if (ch != null) {
-            ch.startSending();
-
-            ch.waitFlush(Long.MAX_VALUE);
-        }
-        wSinceFlush = 0;
-    }
-
-    public void close() throws IOException {
-        flush();
-        bb.close();
-    }
-
-
-    public void write(ByteBuffer source) throws IOException {
-        write(source.array(), source.position(), source.remaining());
-        source.position(source.limit());
-    }
-
-    public void print(String s) throws IOException {
-        if (s==null) s="null";
-        int len = s.length();
-        for (int i = 0; i < len; i++) {
-            char c = s.charAt (i);
-
-            //
-            // XXX NOTE:  This is clearly incorrect for many strings,
-            // but is the only consistent approach within the current
-            // servlet framework.  It must suffice until servlet output
-            // streams properly encode their output.
-            //
-            if ((c & 0xff00) != 0) {    // high order byte must be zero
-                String errMsg = "Not ISO-8859-1";
-                Object[] errArgs = new Object[1];
-                errArgs[0] = new Character(c);
-                errMsg = MessageFormat.format(errMsg, errArgs);
-                throw new CharConversionException(errMsg);
-            }
-            write (c);
-        }
-    }
-
-
-    public void print(boolean b) throws IOException {
-        String msg;
-        if (b) {
-            msg = "true";
-        } else {
-            msg = "false";
-        }
-        print(msg);
-    }
-
-    public void print(char c) throws IOException {
-        print(String.valueOf(c));
-    }
-
-    public void print(int i) throws IOException {
-        print(String.valueOf(i));
-    }
-
-    public void print(long l) throws IOException {
-        print(String.valueOf(l));
-    }
-
-    public void print(float f) throws IOException {
-        print(String.valueOf(f));
-    }
-
-    public void print(double d) throws IOException {
-        print(String.valueOf(d));
-    }
-
-    public void println() throws IOException {
-        print("\r\n");
-    }
-
-    public void println(String s) throws IOException {
-        print(s);
-        println();
-    }
-
-    public void println(boolean b) throws IOException {
-        print(b);
-        println();
-    }
-
-    public void println(char c) throws IOException {
-        print(c);
-        println();
-    }
-
-    public void println(int i) throws IOException {
-        print(i);
-        println();
-    }
-
-    public void println(long l) throws IOException {
-        print(l);
-        println();
-    }
-
-    public void println(float f) throws IOException {
-        print(f);
-        println();
-    }
-
-    public void println(double d) throws IOException {
-        print(d);
-        println();
-    }
-}

==================================================
IOWriter.java
deleted file mode 100644
index bbeacdc613..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOReader.java
+++ /dev/null
@@ -1,236 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-import java.io.Reader;
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-import java.nio.charset.Charset;
-import java.nio.charset.CharsetDecoder;
-import java.nio.charset.CoderResult;
-import java.nio.charset.CodingErrorAction;
-import java.nio.charset.MalformedInputException;
-import java.nio.charset.UnmappableCharacterException;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicInteger;
-
-
-/**
- * Conversion from Bytes to Chars and support for decoding.
- *
- * Replaces tomcat B2CConverter with NIO equivalent. B2CConverter was a hack
- * (re)using an dummy InputStream backed by a ByteChunk.
- *
- * @author Costin Manolache
- */
-public class IOReader extends Reader {
-
-    IOBuffer iob;
-    Map<String, CharsetDecoder> decoders = new HashMap<String, CharsetDecoder>();
-    CharsetDecoder decoder;
-
-    private static boolean REUSE = true;
-    String enc;
-    private boolean closed;
-    public static final String DEFAULT_ENCODING = "ISO-8859-1";
-    long timeout = 0;
-
-    public IOReader(IOBuffer iob) {
-        this.iob = iob;
-    }
-
-    public void setTimeout(long to) {
-        timeout = to;
-    }
-
-    public void setEncoding(String charset) {
-        enc = charset;
-        if (enc == null) {
-            enc = DEFAULT_ENCODING;
-        }
-        decoder = REUSE ? decoders.get(enc) : null;
-        if (decoder == null) {
-            decoder = Charset.forName(enc).newDecoder()
-                .onMalformedInput(CodingErrorAction.REPLACE)
-                .onUnmappableCharacter(CodingErrorAction.REPLACE);
-            if (REUSE) {
-                decoders.put(enc, decoder);
-            }
-        }
-    }
-
-    public String getEncoding() {
-        return enc;
-    }
-
-    public void recycle() {
-        if (decoder != null) {
-            decoder.reset();
-        }
-        closed = false;
-        enc = null;
-    }
-
-    private void checkClosed() throws IOException {
-        if (closed) throw new IOException("closed");
-    }
-
-    public boolean ready() {
-        return iob.peekFirst() != null;
-    }
-
-    public int read(java.nio.CharBuffer target) throws IOException {
-        int len = target.remaining();
-        char[] cbuf = new char[len];
-        int n = read(cbuf, 0, len);
-        if (n > 0)
-            target.put(cbuf, 0, n);
-        return n;
-    }
-
-    public int read() throws IOException {
-        char cb[] = new char[1];
-        if (read(cb, 0, 1) == -1)
-            return -1;
-        else
-            return cb[0];
-    }
-
-    @Override
-    public void close() throws IOException {
-        closed = true;
-        iob.close();
-    }
-
-    /**
-     * Used if a bucket ends on a char boundary
-     */
-    BBuffer underFlowBuffer = BBuffer.allocate(10);
-    public static AtomicInteger underFlows = new AtomicInteger();
-
-    /**
-     * Decode all bytes - for example a URL or header.
-     */
-    public void decodeAll(BBucket bb, CBuffer c) {
-
-        while (bb.hasRemaining()) {
-            CharBuffer charBuffer = c.getAppendCharBuffer();
-            CoderResult res = decode1(bb, charBuffer, true);
-            c.returnAppendCharBuffer(charBuffer);
-            if (res != CoderResult.OVERFLOW) {
-                if (res == CoderResult.UNDERFLOW || bb.hasRemaining()) {
-                    System.err.println("Ignored trailing bytes " + bb.remaining());
-                }
-                return;
-            }
-        }
-
-    }
-
-    /**
-     * Do one decode pass.
-     */
-    public CoderResult decode1(BBucket bb, CharBuffer c, boolean eof) {
-        ByteBuffer b = bb.getByteBuffer();
-
-        if (underFlowBuffer.hasRemaining()) {
-            // Need to get rid of the underFlow first
-            for (int i = 0; i < 10; i++) {
-                underFlowBuffer.put(b.get());
-                bb.position(b.position());
-                ByteBuffer ub = underFlowBuffer.getByteBuffer();
-                CoderResult res = decoder.decode(ub, c, eof);
-                if (! ub.hasRemaining()) {
-                    // underflow resolved
-                    break;
-                }
-                if (res == CoderResult.OVERFLOW) {
-                    return res;
-                }
-            }
-            if (underFlowBuffer.hasRemaining()) {
-                throw new RuntimeException("Can't resolve underflow after " +
-                		"10 bytes");
-            }
-        }
-
-        CoderResult res = decoder.decode(b, c, eof);
-        bb.position(b.position());
-
-        if (res == CoderResult.UNDERFLOW && bb.hasRemaining()) {
-            // b ends on a boundary
-            underFlowBuffer.append(bb.array(), bb.position(), bb.remaining());
-            bb.position(bb.limit());
-        }
-        return res;
-    }
-
-    @Override
-    public int read(char[] cbuf, int offset, int length) throws IOException {
-        checkClosed();
-        if (length == 0) {
-            return 0;
-        }
-        // we can either allocate a new CharBuffer or use a
-        // static one and copy. Seems simpler this way - needs some
-        // load test, but InputStreamReader seems to do the same.
-        CharBuffer out = CharBuffer.wrap(cbuf, offset, length);
-
-        CoderResult result = CoderResult.UNDERFLOW;
-
-        BBucket bucket = iob.peekFirst();
-
-        // Consume as much as possible without blocking
-        while (result == CoderResult.UNDERFLOW) {
-            // fill the buffer if needed
-            if (bucket == null || ! bucket.hasRemaining()) {
-                if (out.position() > offset) {
-                    // we could return the result without blocking read
-                    break;
-                }
-                bucket = null;
-                while (bucket == null) {
-                    iob.waitData(timeout);
-                    bucket = iob.peekFirst();
-                    if (bucket == null && iob.isClosedAndEmpty()) {
-                        // EOF, we couldn't decode anything
-                        break;
-                    }
-                }
-
-                if (bucket == null) {
-                    // eof
-                    break;
-                }
-            }
-
-            result = decode1(bucket, out, false);
-        }
-
-        if (result == CoderResult.UNDERFLOW && iob.isClosedAndEmpty()) {
-            // Flush out any remaining data
-            ByteBuffer bytes = bucket == null ?
-                    underFlowBuffer.getByteBuffer() : bucket.getByteBuffer();
-            result = decoder.decode(bytes, out, true);
-            if (bucket == null) {
-                underFlowBuffer.position(bytes.position());
-            } else {
-                bucket.position(bytes.position());
-            }
-
-            decoder.flush(out);
-            decoder.reset();
-        }
-
-        if (result.isMalformed()) {
-            throw new MalformedInputException(result.length());
-        } else if (result.isUnmappable()) {
-            throw new UnmappableCharacterException(result.length());
-        }
-
-        int rd = out.position() - offset;
-        return rd == 0 ? -1 : rd;
-    }
-}

==================================================
MemoryIOConnector.java
deleted file mode 100644
index 7d06cf16b9..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/IOWriter.java
+++ /dev/null
@@ -1,212 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-import java.io.Writer;
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-import java.nio.charset.Charset;
-import java.nio.charset.CharsetEncoder;
-import java.nio.charset.CoderResult;
-import java.nio.charset.CodingErrorAction;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Converts chars to bytes, and associated encoding.
- *
- * Replaces C2B from old tomcat.
- *
- * @author Costin Manolache
- */
-public class IOWriter extends Writer {
-
-    IOBuffer iob;
-    Map<String, CharsetEncoder> encoders = new HashMap<String, CharsetEncoder>();
-    CharsetEncoder encoder;
-
-    private static boolean REUSE = true;
-    String enc;
-    private boolean closed;
-    IOChannel ioCh;
-
-    public IOWriter(IOChannel iob) {
-        this.ioCh = iob;
-        if (iob != null) {
-            this.iob = iob.getOut();
-        }
-    }
-
-    public void setEncoding(String charset) {
-        if (charset == null) {
-            charset = "UTF-8";
-        }
-        enc = charset;
-        encoder = getEncoder(charset);
-        if (encoder == null) {
-            encoder = Charset.forName(charset).newEncoder()
-                .onMalformedInput(CodingErrorAction.REPLACE)
-                .onUnmappableCharacter(CodingErrorAction.REPLACE);
-            if (REUSE) {
-                encoders.put(charset, encoder);
-            }
-        }
-    }
-
-    CharsetEncoder getEncoder(String charset) {
-        if (charset == null) {
-            charset = "UTF-8";
-        }
-        encoder = REUSE ? encoders.get(charset) : null;
-        if (encoder == null) {
-            encoder = Charset.forName(charset).newEncoder()
-                .onMalformedInput(CodingErrorAction.REPLACE)
-                .onUnmappableCharacter(CodingErrorAction.REPLACE);
-            if (REUSE) {
-                encoders.put(charset, encoder);
-            }
-        }
-        return encoder;
-    }
-
-    public String getEncoding() {
-        return enc;
-    }
-
-    public void recycle() {
-        if (encoder != null) {
-            encoder.reset();
-        }
-        closed = false;
-        enc = null;
-    }
-
-
-    private void checkClosed() throws IOException {
-        if (closed) throw new IOException("closed");
-    }
-
-    @Override
-    public void close() throws IOException {
-        closed = true;
-        // flush the buffer ?
-        ByteBuffer out = iob.getWriteBuffer();
-        encoder.flush(out);
-        iob.releaseWriteBuffer(1);
-
-        iob.close();
-    }
-
-    /**
-     * Used if a bucket ends on a char boundary
-     */
-    CBuffer underFlowBuffer = CBuffer.newInstance();
-
-    public void encode1(CBuffer cc,
-            BBuffer bb, CharsetEncoder encoder, boolean eof) {
-        CharBuffer c = cc.getNioBuffer();
-        ByteBuffer b = bb.getWriteByteBuffer(c.remaining() * 2);
-        encode1(c, b, encoder, eof);
-        cc.returnNioBuffer(c);
-        bb.limit(b.position());
-    }
-
-    /**
-     *
-     * @param cc
-     * @return
-     */
-    public void encode1(CharBuffer c,
-            ByteBuffer b, CharsetEncoder encoder, boolean eof) {
-
-        // TODO: buffer growth in caller
-
-        CoderResult res = encoder.encode(c, b, eof);
-        if (res == CoderResult.OVERFLOW) {
-            // bb is full - next call will get a larger buffer ( it
-            // grows ) or maybe will be flushed.
-        }
-        if (res == CoderResult.UNDERFLOW && c.remaining() > 0 && !eof) {
-            // TODO: if eof -> exception ?
-            // cc has remaining chars - for example a surrogate start.
-            underFlowBuffer.put(c);
-        }
-
-    }
-
-    public void encodeAll(CBuffer cc,
-            BBuffer bb, CharsetEncoder encoder, boolean eof) {
-        while (cc.length() > 0) {
-            encode1(cc, bb, encoder, eof);
-        }
-    }
-
-    public void encodeAll(CBuffer cc,
-            BBuffer bb, String cs) {
-        encodeAll(cc, bb, getEncoder(cs), true);
-    }
-
-    @Override
-    public void flush() throws IOException {
-        if (ioCh != null) {
-            ioCh.startSending();
-        }
-    }
-
-    // TODO: use it for utf-8
-    public static int char2utf8(byte[] ba, int off, char c, char c1) {
-        int i = 0;
-        if (c < 0x80) {
-            ba[off++] = (byte) (c & 0xFF);
-            return 1;
-        } else if (c < 0x800)
-        {
-            ba[off++] = (byte) (0xC0 | c >> 6);
-            ba[off++] = (byte) (0x80 | c & 0x3F);
-            return 2;
-        }
-        else if (c < 0x10000)
-        {
-            ba[off++] = (byte) ((0xE0 | c >> 12));
-            ba[off++] = (byte) ((0x80 | c >> 6 & 0x3F));
-            ba[off++] = (byte) ((0x80 | c & 0x3F));
-            return 3;
-        }
-        else if (c < 0x200000)
-        {
-            ba[off++] = (byte) ((0xF0 | c >> 18));
-            ba[off++] = (byte) ((0x80 | c >> 12 & 0x3F));
-            ba[off++] = (byte) ((0x80 | c >> 6 & 0x3F));
-            ba[off++] = (byte) ((0x80 | c & 0x3F));
-            return 4;
-        }
-
-
-        return i;
-    }
-
-
-    /**
-     * Just send the chars to the byte[], without flushing down.
-     *
-     * @throws IOException
-     */
-    public void push() throws IOException {
-        // we don't cache here.
-    }
-
-    @Override
-    public void write(char[] cbuf, int off, int len) throws IOException {
-        checkClosed();
-        CharBuffer cb = CharBuffer.wrap(cbuf, off, len);
-
-        while (cb.remaining() > 0) {
-            ByteBuffer wb = iob.getWriteBuffer();
-            encode1(cb, wb, encoder, false);
-            iob.releaseWriteBuffer(1);
-        }
-    }
-
-
-}

==================================================
NioChannel.java
deleted file mode 100644
index 75fcc3b5a5..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/MemoryIOConnector.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-import java.util.Timer;
-
-public class MemoryIOConnector extends IOConnector {
-
-    public static class MemoryIOChannel extends IOChannel {
-        IOBuffer netIn = new IOBuffer(this) {
-            protected void notifyDataAvailable(Object bb) throws IOException {
-                sendHandleReceivedCallback();
-                super.notifyDataAvailable(bb);
-            }
-        };
-        IOBuffer netOut = new IOBuffer(this);
-
-        /**
-         * All flushed output will be saved to 'out'.
-         */
-        public BBuffer out = BBuffer.allocate(4096);
-
-        public MemoryIOChannel() {
-        }
-
-        public void startSending() throws IOException {
-            //
-            IOBuffer bb = netOut;
-            while (true) {
-                if (bb.isClosedAndEmpty()) {
-                    break;
-                }
-                BBucket first = bb.peekFirst();
-                if (first == null) {
-                    break;
-                }
-                BBucket iob = ((BBucket) first);
-                out.append(iob.array(), iob.position(), iob.remaining());
-                bb.advance(iob.remaining());
-                iob.release();
-            }
-
-            handleFlushed(this);
-        }
-
-        @Override
-        public IOBuffer getIn() {
-            return netIn;
-        }
-        @Override
-        public IOBuffer getOut() {
-            return netOut;
-        }
-    }
-
-    // TODO: in-process communication without sockets for testing
-    ConnectedCallback acceptor;
-    MemoryIOConnector server;
-
-    public MemoryIOConnector() {
-        timer = new Timer(true);
-    }
-
-    public MemoryIOConnector withServer(MemoryIOConnector server) {
-        this.server = server;
-        return server;
-    }
-
-    @Override
-    public void acceptor(ConnectedCallback sc, CharSequence port, Object extra)
-            throws IOException {
-        this.acceptor = sc;
-    }
-
-    @Override
-    public void connect(String host, int port, ConnectedCallback sc)
-            throws IOException {
-        IOChannel ch = new MemoryIOChannel();
-        IOChannel sch = new MemoryIOChannel();
-        // TODO: mix
-        if (server != null && server.acceptor != null) {
-            server.acceptor.handleConnected(sch);
-        }
-        sc.handleConnected(ch);
-    }
-
-}
\ No newline at end of file

==================================================
NioThread.java
deleted file mode 100644
index 7cc1408658..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/NioChannel.java
+++ /dev/null
@@ -1,198 +0,0 @@
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.nio.ByteBuffer;
-import java.nio.channels.ByteChannel;
-import java.nio.channels.Channel;
-
-
-/**
- * Wrapper around the real channel, with selector-specific info.
- *
- * It is stored as an attachment in the selector.
- */
-public class NioChannel implements ByteChannel {
-
-    public static interface NioChannelCallback {
-        public void handleConnected(NioChannel ch) throws IOException;
-        public void handleClosed(NioChannel ch) throws IOException;
-        public void handleReadable(NioChannel ch) throws IOException;
-        public void handleWriteable(NioChannel ch) throws IOException;
-
-    }
-
-    NioChannel(NioThread sel) {
-        this.sel = sel;
-    }
-
-    // APR long is wrapped in a ByteChannel as well - with few other longs.
-    Channel channel;
-
-    // sync access.
-    Object selKey;
-
-    NioThread sel;
-
-    /**
-     * If != 0 - the callback will be notified closely after this time.
-     * Used for timeouts.
-     */
-    long nextTimeEvent = 0;
-
-    // Callbacks
-    Runnable timeEvent;
-
-    NioChannelCallback callback;
-
-
-    Throwable lastException;
-
-    // True if the callback wants to be notified of read/write
-    boolean writeInterest;
-    boolean readInterest;
-
-    // shutdownOutput has been called ?
-    private boolean outClosed = false;
-
-    // read() returned -1 OR input buffer closed ( no longer interested )
-    boolean inClosed = false;
-
-    // Saved to allow debug messages for bad interest/looping
-    int lastReadResult;
-    int zeroReads = 0;
-    int lastWriteResult;
-
-    protected NioChannel() {
-
-    }
-
-    public NioThread getSelectorThread() {
-        return sel;
-    }
-
-    public String toString() {
-        StringBuffer sb = new StringBuffer();
-        sb.append("SelData/")
-        .append(writeInterest ? "W/" : "")
-        .append(readInterest ? "R/" : "")
-        .append(outClosed ? "Out-CLOSE/" : "")
-        .append(inClosed ? "In-CLOSE/" : "")
-        .append("/")
-        .append(channel.toString());
-
-        return sb.toString();
-    }
-
-    public Channel getChannel() {
-        return channel;
-    }
-
-    public boolean isOpen() {
-        // in and out open
-        return channel.isOpen() && !outClosed && !inClosed;
-    }
-
-    public int read(ByteBuffer bb) throws IOException {
-        return sel.readNonBlocking(this, bb);
-    }
-
-    public int write(ByteBuffer bb) throws IOException {
-        return sel.writeNonBlocking(this, bb);
-    }
-
-    public void readInterest(boolean b) throws IOException {
-        sel.readInterest(this, b);
-    }
-
-    public void writeInterest() throws IOException {
-        sel.writeInterest(this);
-    }
-
-    public InetAddress getAddress(boolean remote) {
-        return sel.getAddress(this, remote);
-    }
-
-    public int getPort(boolean remote) {
-        return sel.getPort(this, remote);
-    }
-
-    /**
-     * Run in selector thread.
-     */
-    public void runInSelectorThread(Runnable t) throws IOException {
-        sel.runInSelectorThread(t);
-    }
-
-    /**
-     * Request a timer event. The thread will generate the events at
-     * a configurable interval - for example no more often than 0.5 sec.
-     */
-    public void setTimer(long timeMs, Runnable cb) {
-        this.nextTimeEvent = timeMs;
-        this.timeEvent = cb;
-    }
-
-    /**
-     *  shutdown out + in
-     *  If there is still data in the input buffer - RST will be sent
-     *  instead of FIN.
-     *
-     *
-     * The proper way to close a connection is to shutdownOutput() first,
-     * wait until read() return -1, then call close().
-     *
-     * If read() returns -1, you need to finish sending, call shutdownOutput()
-     * than close.
-     * If read() returns -1 and there is an error - call close()
-     * directly.
-     *
-     */
-    @Override
-    public void close() throws IOException {
-        shutdownOutput();
-        inputClosed();
-    }
-
-    /**
-     *  Send TCP close(FIN). HTTP uses this to transmit end of body. The other end
-     *  detects this with a '-1' in read().
-     *
-     *  All other forms of close() are reported as exceptions in read().
-     *
-     * @throws IOException
-     */
-    public void shutdownOutput() throws IOException {
-        synchronized (channel) {
-            if (!outClosed) {
-                outClosed = true;
-                try {
-                    sel.shutdownOutput(this);
-                } catch (IOException ex) {
-                    // ignore
-                }
-            }
-            if (inClosed) {
-                sel.close(this, null);
-            }
-        }
-    }
-
-    void inputClosed() throws IOException {
-        synchronized (channel) {
-            if (inClosed) {
-                // already closed
-                return;
-            }
-            inClosed = true; // detected end
-            if (outClosed) {
-                sel.close(this, null);
-            } else {
-                // Don't close the channel - write may still work ?
-                readInterest(false);
-            }
-        }
-    }
-
-    boolean closeCalled = false;
-}
\ No newline at end of file

==================================================
SocketConnector.java
deleted file mode 100644
index 9ec80becd9..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/NioThread.java
+++ /dev/null
@@ -1,1154 +0,0 @@
-/*  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.net.SocketException;
-import java.nio.ByteBuffer;
-import java.nio.channels.ByteChannel;
-import java.nio.channels.Channel;
-import java.nio.channels.ClosedChannelException;
-import java.nio.channels.SelectableChannel;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.Selector;
-import java.nio.channels.ServerSocketChannel;
-import java.nio.channels.SocketChannel;
-import java.nio.channels.spi.SelectorProvider;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.lite.io.NioChannel.NioChannelCallback;
-
-/**
- * Abstract NIO/APR to avoid some of the complexity and allow more code
- * sharing and experiments.
- *
- * SelectorThread provides non-blocking methods for read/write and generates
- * callbacks using SelectorCallback. It has no buffers of its own.
- *
- * This is non-blocking, non-buffering and uses callbacks.
- *
- * @author Costin Manolache
- */
-public class NioThread implements Runnable {
-
-  // ----------- IO handling -----------
-  protected long inactivityTimeout = 5000;
-  protected Thread selectorThread;
-
-
-  static Logger log = Logger.getLogger("NIO");
-
-  Selector selector;
-
-  // will be processed in the selector thread
-  List<NioChannel> readInterest = new ArrayList<NioChannel>();
-  List<NioChannel> writeInterest = new ArrayList<NioChannel>();
-  List<NioChannel> connectAcceptInterest = new ArrayList<NioChannel>();
-  List<NioChannel> updateCallback = new ArrayList<NioChannel>();
-  List<NioChannel> closeInterest = new LinkedList<NioChannel>();
-  List<Runnable> runnableInterest = new ArrayList<Runnable>();
-
-  // Statistics
-  AtomicInteger opened = new AtomicInteger();
-  AtomicInteger closed = new AtomicInteger();
-  AtomicInteger loops = new AtomicInteger();
-
-  AtomicInteger callbackCount = new AtomicInteger();
-  AtomicLong callbackTotalTime = new AtomicLong();
-  long maxCallbackTime = 0;
-
-  // actives are also stored in the Selector. This is only updated in the main
-  // thread
-  public ArrayList<NioChannel> active = new ArrayList<NioChannel>();
-
-  public static boolean debug = false;
-  boolean debugWakeup = false;
-  boolean running = true;
-
-  long lastWakeup = System.currentTimeMillis(); // last time we woke
-  long nextWakeup; // next scheduled wakeup
-
-  // Normally select will wait for the next time event - if it's
-  // too far in future, maxSleep will override it.
-  private long maxSleep = 600000;
-  long sleepTime = maxSleep;
-
-  // Never sleep less than minSleep. This defines the resulution for
-  // time events.
-  private long minSleep = 100;
-
-  boolean daemon = false;
-
-  // TODO: trace log - record all events with timestamps, replay
-
-  public NioThread(String name, boolean daemon) {
-      try {
-          selectorThread = (name == null) ? new Thread(this) :
-              new Thread(this, name);
-
-          selector = Selector.open();
-          // TODO: start it on-demand, close it when not in use
-          selectorThread.setDaemon(daemon);
-          this.daemon = daemon;
-
-          selectorThread.start();
-
-      } catch(IOException e) {
-          throw new RuntimeException(e);
-      }
-  }
-
-  /**
-   * Opened sockets, waiting for something ( close at least )
-   */
-  public int getOpen() {
-      return opened.get();
-  }
-
-  /**
-   * Closed - we're done with them.
-   */
-  public int getClosed() {
-      return closed.get();
-  }
-
-  public int getActive() {
-      return active.size();
-  }
-
-  public int getCallbacks() {
-      return callbackCount.get();
-  }
-
-  public long getMaxCallbackTime() {
-      return maxCallbackTime;
-  }
-
-  public long getAvgCallbackTime() {
-      int cnt = callbackCount.get();
-      if (cnt == 0) {
-          return 0;
-      }
-      return callbackTotalTime.get() / cnt;
-  }
-
-  /**
-   * How many times we looped
-   */
-  public int getLoops() {
-      return loops.get();
-  }
-
-  public long getLastWakeup() {
-      return lastWakeup;
-  }
-
-  public long getTimeSinceLastWakeup() {
-      return System.currentTimeMillis() - lastWakeup;
-  }
-
-  /**
-   * Close all resources, stop accepting, stop the thread.
-   * The actual stop will happen in background.
-   */
-  public void stop() {
-      running = false;
-      if (debug) {
-          log.info("Selector thread stop " + this);
-      }
-      selector.wakeup();
-  }
-
-  public void run() {
-      int sloops = 0;
-      if (debug) {
-          log.info("Start NIO thread, daemon=" + daemon);
-      }
-      while (running) {
-          // if we want timeouts - set here.
-          try {
-              loops.incrementAndGet();
-
-              // Check if new requests were added
-              processPending();
-
-              // Timers
-              long now = System.currentTimeMillis();
-              if (nextWakeup < now) {
-                  // We don't want to iterate on every I/O
-                  updateSleepTimeAndProcessTimeouts(now);
-              }
-
-              int selected = selector.select(sleepTime);
-
-              lastWakeup = System.currentTimeMillis();
-              long slept = lastWakeup - now;
-
-              if (debugWakeup && selected == 0) {
-                  if (sleepTime < maxSleep - 1000) { // short wakeup
-                      log.info("Wakeup " + selected + " " + slept
-                              + " " + sleepTime);
-                  }
-              }
-              if (slept < 10 && selected == 0) {
-                  if (sloops > 50) {
-                      sloops = 0;
-                      log.severe("Looping !");
-                      resetSelector();
-                  }
-                  sloops++;
-              }
-
-              // handle events for existing req first.
-              if (selected != 0) {
-                  sloops = 0;
-                  int callbackCnt = 0;
-                  Set<SelectionKey> sel = selector.selectedKeys();
-                  Iterator<SelectionKey> i = sel.iterator();
-
-                  while (i.hasNext()) {
-                      callbackCnt++;
-                      long beforeCallback = System.currentTimeMillis();
-                      SelectionKey sk = i.next();
-                      i.remove();
-
-                      boolean valid = sk.isValid();
-                      int readyOps = (valid) ? sk.readyOps() : 0;
-
-                      NioChannel ch = (NioChannel) sk.attachment();
-                      if (debugWakeup) {
-                          log.info("Wakeup selCnt=" + selected + " slept=" + (lastWakeup - now) +
-                                  " ready: " + readyOps + " v=" +
-                                  sk.isValid() + " ch=" + ch);
-                      }
-                      if (ch == null) {
-                          log.severe("Missing channel");
-                          sk.cancel();
-                          continue;
-                      }
-                      if (ch.selKey != sk) {
-                          // if (ch.selKey != null) { // null if closed
-                          log.severe("Invalid state, selKey doesn't match ");
-                          ch.selKey = sk;
-                      }
-                      if (ch.channel != sk.channel()) {
-                          ch.channel = sk.channel();
-                          log.severe("Invalid state, channel doesn't match ");
-                      }
-
-                      if (!sk.isValid()) {
-                          if (debug) {
-                              log.info("!isValid, closed socket " + ch);
-                          }
-                          ch.close();
-                          continue;
-                      }
-
-                      try {
-                          int ready = sk.readyOps();
-                          // callbacks
-                          if (sk.isValid() && sk.isAcceptable()) {
-                              handleAccept(ch, sk);
-                          }
-
-                          if (sk.isValid() && sk.isConnectable()) {
-                              sk.interestOps(sk.interestOps() & ~SelectionKey.OP_CONNECT);
-                              SocketChannel sc = (SocketChannel) sk.channel();
-                              handleConnect(ch, sc);
-                          }
-
-                          if (sk.isValid() && sk.isWritable()) {
-                              // Needs to be explicitely re-enabled by callback
-                              // if more data.
-                              sk.interestOps(sk.interestOps() & ~SelectionKey.OP_WRITE);
-                              ch.writeInterest = false;
-                              handleDataWriteable(ch);
-                          }
-
-                          if (sk.isValid() && sk.isReadable()) {
-                              // Leave readable interest !
-                              handleReadable(ch);
-                          }
-
-                          long callbackTime =
-                              System.currentTimeMillis() - beforeCallback;
-
-                          if (callbackTime > 250) {
-                              log.warning("Callback too long ! ops=" + ready +
-                                      " time=" + callbackTime + " ch=" + ch +
-                                      " " + callbackCnt);
-                          }
-                          if (callbackTime > maxCallbackTime) {
-                              maxCallbackTime = callbackTime;
-                          }
-                          callbackCount.incrementAndGet();
-                          this.callbackTotalTime.addAndGet(callbackTime);
-
-                      } catch (Throwable t) {
-                          log.log(Level.SEVERE, "SelectorThread: Channel error, closing", t);
-                          ch.lastException = t;
-                          ch.close();
-                      }
-
-                  }
-                  // All at once
-                  sel.clear();
-              }
-
-          } catch (Throwable e) {
-              log.log(Level.SEVERE, "SelectorThread: Error in select", e);
-          }
-      } // while(running)
-      log.info("SelectorThread done");
-  }
-
-  private void log(String msg, int selected, long slept, SelectionKey sk, int readyOps) {
-      log.info(msg + " " + selected
-              + " " + slept
-              + " ready: " + readyOps + " "
-              + sk.readyOps() + " " + sk);
-  }
-
-  private void resetSelector() throws IOException, ClosedChannelException {
-      // Let's close all sockets - one is bad, but we can't do much.
-      Set<SelectionKey> keys = selector.keys();
-      //Set<SelectionKey> keys = selector.keys();
-      ArrayList<NioChannel> oldCh = new ArrayList<NioChannel>();
-      ArrayList<Integer> interests = new ArrayList<Integer>();
-      for (SelectionKey k : keys) {
-          NioChannel cd = (NioChannel) k.attachment();
-          interests.add(k.interestOps());
-          oldCh.add(cd);
-          k.cancel();
-      }
-
-      selector.close();
-      selector = Selector.open();
-      for (int i = 0; i < oldCh.size(); i++) {
-          NioChannel selectorData = oldCh.get(i);
-          if (selectorData == null) {
-              continue;
-          }
-          int interest = interests.get(i);
-          if (selectorData.channel instanceof ServerSocketChannel) {
-              ServerSocketChannel socketChannel =
-                  (ServerSocketChannel) selectorData.channel;
-              selectorData.selKey = socketChannel.register(selector, SelectionKey.OP_ACCEPT);
-          } else {
-              SocketChannel socketChannel =
-                  (SocketChannel) selectorData.channel;
-              if (interest != 0) {
-                  selectorData.selKey = socketChannel.register(selector,
-                      interest);
-              }
-
-          }
-      }
-  }
-
-  private void handleReadable(NioChannel ch) throws IOException {
-      ch.lastReadResult = 0;
-      if (ch.callback != null) {
-          ch.callback.handleReadable(ch);
-      }
-      if (ch.lastReadResult != 0 && ch.readInterest && !ch.inClosed) {
-          log.warning("LOOP: read interest" +
-                      " after incomplete read");
-          ch.close();
-      }
-  }
-
-  private void handleDataWriteable(NioChannel ch) throws IOException {
-      ch.lastWriteResult = 0;
-      if (ch.callback != null) {
-          ch.callback.handleWriteable(ch);
-      }
-      if (ch.lastWriteResult > 0 && ch.writeInterest) {
-          log.warning("SelectorThread: write interest" +
-                      " after incomplete write, LOOP");
-      }
-  }
-
-  private void handleConnect(NioChannel ch, SocketChannel sc)
-          throws IOException, SocketException {
-      try {
-          if (!sc.finishConnect()) {
-              log.warning("handleConnected - finishConnect returns false");
-          }
-          ch.sel = this;
-          //sc.socket().setSoLinger(true, 0);
-          if (debug) {
-              log.info("connected() " + ch + " isConnected()=" + sc.isConnected() + " " +
-                      sc.isConnectionPending());
-          }
-
-          readInterest(ch, true);
-      } catch (Throwable t) {
-          close(ch, t);
-      }
-      try {
-          if (ch.callback != null) {
-              ch.callback.handleConnected(ch);
-          }
-      } catch(Throwable t1) {
-          log.log(Level.WARNING, "Error in connect callback", t1);
-      }
-
-  }
-
-  private void handleAccept(NioChannel ch, SelectionKey sk)
-          throws IOException, ClosedChannelException {
-      SelectableChannel selc = sk.channel();
-      ServerSocketChannel ssc=(ServerSocketChannel)selc;
-      SocketChannel sockC = ssc.accept();
-      sockC.configureBlocking(false);
-
-      NioChannel acceptedChannel = new NioChannel(this);
-      acceptedChannel.selKey = sockC.register(selector,
-              SelectionKey.OP_READ,
-              acceptedChannel);
-      acceptedChannel.channel = sockC;
-
-      synchronized (active) {
-          active.add(acceptedChannel);
-      }
-
-      // Find the callback for the new socket
-      if (ch.callback != null) {
-          // TODO: use future !
-          try {
-              ch.callback.handleConnected(acceptedChannel);
-          } catch (Throwable t) {
-              log.log(Level.SEVERE, "SelectorThread: Channel error, closing ", t);
-              acceptedChannel.lastException = t;
-              acceptedChannel.close();
-          }
-     }
-
-      //sk.interestOps(sk.interestOps() | SelectionKey.OP_ACCEPT);
-      if (debug) {
-          log.info("handleAccept " + ch);
-      }
-  }
-
-
-  public void shutdownOutput(NioChannel ch) throws IOException {
-      Channel channel = ch.channel;
-      if (channel instanceof SocketChannel) {
-          SocketChannel sc = (SocketChannel) channel;
-          if (sc.isOpen() && sc.isConnected()) {
-              if (debug) {
-                  log.info("Half shutdown " + ch);
-              }
-              sc.socket().shutdownOutput(); // TCP end to the other side
-          }
-      }
-  }
-
-  /**
-   * Called from the IO thread
-   */
-  private void closeIOThread(NioChannel ch, boolean remove) {
-      SelectionKey sk = (SelectionKey) ch.selKey;
-      Channel channel = ch.channel;
-      try {
-          synchronized(closeInterest) {
-              if (ch.closeCalled) {
-                  if (debug) {
-                      log.severe("Close called 2x ");
-                  }
-                  return;
-              }
-              ch.closeCalled = true;
-              int o = opened.decrementAndGet();
-              if (debug) {
-                  log.info("-------------> close: " + ch + " t=" + ch.lastException);
-              }
-              if (sk != null) {
-                  if (sk.isValid()) {
-                      sk.interestOps(0);
-                  }
-                  sk.cancel();
-                  ch.selKey = null;
-              }
-
-              if (channel instanceof SocketChannel) {
-                  SocketChannel sc = (SocketChannel) channel;
-
-                  if (sc.isConnected()) {
-                      if (debug) {
-                          log.info("Close socket, opened=" + o);
-                      }
-                      try {
-                          sc.socket().shutdownInput();
-                      } catch(IOException io1) {
-                      }
-                      try {
-                          sc.socket().shutdownOutput(); // TCP end to the other side
-                      } catch(IOException io1) {
-                      }
-                      sc.socket().close();
-                  }
-              }
-              channel.close();
-
-              closed.incrementAndGet();
-
-              if (ch.callback != null) {
-                  ch.callback.handleClosed(ch);
-              }
-              // remove from active - false only if already removed
-              if (remove) {
-                  synchronized (active) {
-                      boolean removed = active.remove(ch);
-                  }
-              }
-      }
-      } catch (IOException ex2) {
-          log.log(Level.SEVERE, "SelectorThread: Error closing socket ", ex2);
-      }
-  }
-
-  // --------------- Socket op abstractions ------------
-
-  public int readNonBlocking(NioChannel selectorData, ByteBuffer bb)
-  throws IOException {
-      try {
-          int off = bb.position();
-
-          int done = 0;
-
-          done = ((SocketChannel) selectorData.channel).read(bb);
-
-          if (debug) {
-              log.info("-------------readNB rd=" + done + " bb.limit=" +
-                      bb.limit() + " pos=" + bb.position() + " " + selectorData);
-          }
-          if (done > 0) {
-              if (debug) {
-                  if (!bb.isDirect()) {
-                      String s = new String(bb.array(), off,
-                          bb.position() - off);
-                      log.info("Data:\n" + s);
-                  } else {
-                      log.info("Data: " + bb.toString());
-                  }
-              }
-              selectorData.zeroReads = 0;
-          } else if (done < 0) {
-              if (debug) {
-                  log.info("SelectorThread: EOF while reading " + selectorData);
-              }
-          } else {
-              // need more...
-              if (selectorData.lastReadResult == 0) {
-                  selectorData.zeroReads++;
-                  if (selectorData.zeroReads > 6) {
-                      log.severe("LOOP 0 reading ");
-                      selectorData.lastException = new IOException("Polling read");
-                      selectorData.close();
-                      return -1;
-                  }
-              }
-          }
-          selectorData.lastReadResult = done;
-          return done;
-      } catch(IOException ex) {
-          if (debug) {
-              log.info("readNB error rd=" + -1 + " bblen=" +
-                      (bb.limit() - bb.position()) + " " + selectorData + " " + ex);
-          }
-          // common case: other side closed the connection. No need for trace
-          if (ex.toString().indexOf("Connection reset by peer") < 0) {
-              ex.printStackTrace();
-          }
-          selectorData.lastException = ex;
-          selectorData.close();
-          return -1;
-      }
-  }
-
-  /**
-   *  May be called from any thread
-   */
-  public int writeNonBlocking(NioChannel selectorData, ByteBuffer bb)
-          throws IOException {
-      try {
-          if (debug) {
-              log.info("writeNB pos=" + bb.position() + " len=" +
-                      (bb.limit() - bb.position()) + " " + selectorData);
-             if (!bb.isDirect()) {
-                  String s = new String(bb.array(), bb.position(),
-
-                      bb.limit() - bb.position());
-                  log.info("Data:\n" + s);
-              }
-          }
-          if (selectorData.writeInterest) {
-              // writeInterest will be false after a callback, if it is
-              // set it means we want to wait for the callback.
-              if (debug) {
-                  log.info("Prevent writeNB when writeInterest is set");
-              }
-              return 0;
-          }
-
-          int done = 0;
-          done = ((SocketChannel) selectorData.channel).write(bb);
-          selectorData.lastWriteResult = done;
-          return done;
-      } catch(IOException ex) {
-          if (debug) {
-              log.info("writeNB error pos=" + bb.position() + " len=" +
-                      (bb.limit() - bb.position()) + " " + selectorData + " " +
-                      ex);
-          }
-          //ex.printStackTrace();
-          selectorData.lastException = ex;
-          selectorData.close();
-          throw ex;
-          // return -1;
-      }
-  }
-
-  public int getPort(NioChannel sd, boolean remote) {
-      SocketChannel socketChannel = (SocketChannel) sd.channel;
-
-      if (remote) {
-          return socketChannel.socket().getPort();
-      } else {
-          return socketChannel.socket().getLocalPort();
-      }
-  }
-
-  public InetAddress getAddress(NioChannel sd, boolean remote) {
-      SocketChannel socketChannel = (SocketChannel) sd.channel;
-
-      if (remote) {
-          return socketChannel.socket().getInetAddress();
-      } else {
-          return socketChannel.socket().getLocalAddress();
-      }
-  }
-
-  /**
-   */
-  public void connect(String host, int port, NioChannelCallback cstate)
-          throws IOException {
-      connect(new InetSocketAddress(host, port), cstate);
-  }
-
-
-  public void connect(SocketAddress sa, NioChannelCallback cstate)
-          throws IOException {
-      connect(sa, cstate, null);
-  }
-
-  public void connect(SocketAddress sa, NioChannelCallback cstate,
-                      NioChannel filter)
-          throws IOException {
-
-      SocketChannel socketChannel = SocketChannel.open();
-      socketChannel.configureBlocking(false);
-      NioChannel selectorData = new NioChannel(this);
-      selectorData.sel = this;
-      selectorData.callback = cstate;
-      selectorData.channel = socketChannel;
-      selectorData.channel = socketChannel; // no key
-
-      socketChannel.connect(sa);
-      opened.incrementAndGet();
-
-      synchronized (connectAcceptInterest) {
-          connectAcceptInterest.add(selectorData);
-      }
-      selector.wakeup();
-  }
-
-  // TODO
-  public void configureSocket(ByteChannel ch,
-                              boolean noDelay) throws IOException {
-      SocketChannel sockC = (SocketChannel) ch;
-      sockC.socket().setTcpNoDelay(noDelay);
-  }
-
-  // TODO
-  public void setSocketOptions(NioChannel selectorData,
-                               int linger,
-                               boolean tcpNoDelay,
-                               int socketTimeout)
-  throws IOException {
-
-      SocketChannel socketChannel =
-          (SocketChannel) selectorData.channel;
-      Socket socket = socketChannel.socket();
-
-      if(linger >= 0 )
-          socket.setSoLinger( true, linger);
-      if( tcpNoDelay )
-          socket.setTcpNoDelay(tcpNoDelay);
-      if( socketTimeout > 0 )
-          socket.setSoTimeout( socketTimeout );
-  }
-
-  /**
-   * Can be called from multiple threads or multiple times.
-   */
-  public int close(NioChannel selectorData, Throwable exception) throws IOException {
-      synchronized (closeInterest) {
-          if (exception != null) {
-              selectorData.lastException = exception;
-          }
-          selectorData.readInterest = false;
-          if (isSelectorThread()) {
-              closeIOThread(selectorData, true);
-              return 0;
-          }
-          if (!selectorData.inClosed) {
-              closeInterest.add(selectorData);
-          }
-      }
-      selector.wakeup();
-      return 0;
-  }
-
-
-  public void acceptor(NioChannelCallback cstate,
-                       int port,
-                       InetAddress inet,
-                       int backlog,
-                       int serverTimeout)
-  throws IOException
-  {
-      ServerSocketChannel ssc=ServerSocketChannel.open();
-      ServerSocket serverSocket = ssc.socket();
-
-      SocketAddress sa = null;
-
-      if (inet == null) {
-          sa = new InetSocketAddress( port );
-      } else {
-          sa = new InetSocketAddress(inet, port);
-      }
-      if (backlog > 0) {
-          serverSocket.bind( sa , backlog);
-      } else {
-          serverSocket.bind(sa);
-      }
-      if( serverTimeout >= 0 ) {
-          serverSocket.setSoTimeout( serverTimeout );
-      }
-
-
-      ssc.configureBlocking(false);
-
-      NioChannel selectorData = new NioChannel(this);
-      selectorData.channel = ssc; // no key yet
-      selectorData.callback = cstate;
-      // key will be set in pending
-
-      // TODO: add SSL here
-
-      synchronized (connectAcceptInterest) {
-          connectAcceptInterest.add(selectorData);
-      }
-      selector.wakeup();
-  }
-
-  public void runInSelectorThread(Runnable cb) throws IOException {
-      if (isSelectorThread()) {
-          cb.run();
-      } else {
-          synchronized (runnableInterest) {
-              runnableInterest.add(cb);
-          }
-          selector.wakeup();
-      }
-  }
-
-  /**
-   * Example config:
-   *
-   * www stream tcp wait USER  PATH_TO_tomcatInetd.sh
-   *
-   * For a different port, you need to add it to /etc/services.
-   *
-   * 'wait' is critical - the common use of inetd is 'nowait' for
-   * tcp services, which doesn't make sense for java ( too slow startup
-   * time ). It may make sense in future with something like android VM.
-   *
-   * In 'wait' mode, inetd will pass the acceptor socket to java - so
-   * you can listen on port 80 and run as regular user with no special
-   * code and magic.
-   * If tomcat dies, inetd will get back the acceptor and on next connection
-   * restart tomcat.
-   *
-   * This also works with xinetd. It might work with Apple launchd.
-   *
-   * TODO: detect inactivity for N minutes, exist - to free resources.
-   */
-  public void inetdAcceptor(NioChannelCallback cstate) throws IOException {
-      SelectorProvider sp=SelectorProvider.provider();
-
-      Channel ch=sp.inheritedChannel();
-      if(ch!=null ) {
-          log.info("Inherited: " + ch.getClass().getName());
-          // blocking mode
-          ServerSocketChannel ssc=(ServerSocketChannel)ch;
-          ssc.configureBlocking(false);
-
-          NioChannel selectorData = new NioChannel(this);
-          selectorData.channel = ssc;
-          selectorData.callback = cstate;
-
-          synchronized (connectAcceptInterest) {
-              connectAcceptInterest.add(selectorData);
-          }
-          selector.wakeup();
-      } else {
-          log.severe("No inet socket ");
-          throw new IOException("Invalid inheritedChannel");
-      }
-  }
-
-  // -------------- Housekeeping -------------
-  /**
-   *  Same as APR connector - iterate over tasks, get
-   *  smallest timeout
-   * @throws IOException
-   */
-  void updateSleepTimeAndProcessTimeouts(long now)
-          throws IOException {
-      long min = Long.MAX_VALUE;
-      // TODO: test with large sets, maybe sort
-      synchronized (active) {
-          Iterator<NioChannel> activeIt = active.iterator();
-
-          while(activeIt.hasNext()) {
-              NioChannel selectorData = activeIt.next();
-              if (! selectorData.channel.isOpen()) {
-                  if (debug) {
-                      log.info("Found closed socket, removing " +
-                              selectorData.channel);
-                  }
-//                  activeIt.remove();
-//                  selectorData.close();
-              }
-
-              long t = selectorData.nextTimeEvent;
-              if (t == 0) {
-                  continue;
-              }
-              if (t < now) {
-                  // Timeout
-                  if (debug) {
-                      log.info("Time event " + selectorData);
-                  }
-                  if (selectorData.timeEvent != null) {
-                      selectorData.timeEvent.run();
-                  }
-                  // TODO: make sure this is updated if it was selected
-                  continue;
-              }
-              if (t < min) {
-                  min = t;
-              }
-          }
-      }
-      long nextSleep = min - now;
-      if (nextSleep > maxSleep) {
-          sleepTime = maxSleep;
-      } else if (nextSleep < minSleep) {
-          sleepTime = minSleep;
-      } else {
-          sleepTime = nextSleep;
-      }
-      nextWakeup = now + sleepTime;
-  }
-
-  /**
-   * Request a callback whenever data can be written.
-   * When the callback is invoked, the write interest is removed ( to avoid
-   * looping ). If the write() operation doesn't complete, you must call
-   * writeInterest - AND stop writing, some implementations will throw
-   * exception. write() will actually attempt to detect this and avoid the
-   * error.
-   *
-   * @param sc
-   */
-  public void writeInterest(NioChannel selectorData) {
-      // TODO: suspended ?
-
-      SelectionKey sk = (SelectionKey) selectorData.selKey;
-      if (!sk.isValid()) {
-          return;
-      }
-      selectorData.writeInterest = true;
-      int interest = sk.interestOps();
-      if ((interest & SelectionKey.OP_WRITE) != 0) {
-          return;
-      }
-      if (Thread.currentThread() == selectorThread) {
-          interest =
-              interest | SelectionKey.OP_WRITE;
-          sk.interestOps(interest);
-          if (debug) {
-              log.info("Write interest " + selectorData + " i=" + interest);
-          }
-          return;
-      }
-      if (debug) {
-          log.info("Pending write interest " + selectorData);
-      }
-      synchronized (writeInterest) {
-          writeInterest.add(selectorData);
-      }
-      selector.wakeup();
-  }
-
-
-  public void readInterest(NioChannel selectorData, boolean b) throws IOException {
-      if (Thread.currentThread() == selectorThread) {
-          selectorData.readInterest = b;
-          selThreadReadInterest(selectorData);
-          return;
-      }
-      SelectionKey sk = (SelectionKey) selectorData.selKey;
-      if (sk == null) {
-          close(selectorData, null);
-          return;
-      }
-      int interest = sk.interestOps();
-      selectorData.readInterest = b;
-      if (b && (interest & SelectionKey.OP_READ) != 0) {
-          return;
-      }
-      if (!b && (interest & SelectionKey.OP_READ) == 0) {
-          return;
-      }
-      // Schedule the interest update.
-      synchronized (readInterest) {
-          readInterest.add(selectorData);
-      }
-      if (debug) {
-          log.info("Registering pending read interest");
-      }
-      selector.wakeup();
-  }
-
-
-  private void selThreadReadInterest(NioChannel selectorData) throws IOException {
-      SelectionKey sk = (SelectionKey) selectorData.selKey;
-      if (sk == null) {
-          if (selectorData.readInterest) {
-              if (debug) {
-                  log.info("Register again for read interest");
-              }
-              SocketChannel socketChannel =
-                  (SocketChannel) selectorData.channel;
-              if (socketChannel.isOpen()) {
-                  selectorData.sel = this;
-                  selectorData.selKey =
-                      socketChannel.register(selector,
-                              SelectionKey.OP_READ, selectorData);
-                  selectorData.channel = socketChannel;
-              }
-          }
-          return;
-      }
-      if (!sk.isValid()) {
-          return;
-      }
-      int interest = sk.interestOps();
-      if (sk != null && sk.isValid()) {
-          if (selectorData.readInterest) {
-//              if ((interest | SelectionKey.OP_READ) != 0) {
-//                  return;
-//              }
-              interest =
-                  interest | SelectionKey.OP_READ;
-          } else {
-//              if ((interest | SelectionKey.OP_READ) == 0) {
-//                  return;
-//              }
-              interest =
-                  interest & ~SelectionKey.OP_READ;
-          }
-          if (interest == 0) {
-              if (!selectorData.inClosed) {
-                  new Throwable().printStackTrace();
-                  log.warning("No interest(rd removed) " + selectorData);
-              }
-              // TODO: should we remove it ? It needs to be re-activated
-              // later.
-              sk.cancel(); //??
-              selectorData.selKey = null;
-          } else {
-              sk.interestOps(interest);
-          }
-          if (debug) {
-              log.info(((selectorData.readInterest)
-                      ? "RESUME read " : "SUSPEND read ")
-                      + selectorData);
-          }
-      }
-  }
-
-
-  private void processPendingConnectAccept() throws IOException {
-      synchronized (connectAcceptInterest) {
-          Iterator<NioChannel> ci = connectAcceptInterest.iterator();
-
-          while (ci.hasNext()) {
-              NioChannel selectorData = ci.next();
-
-              // Find host, port - initiate connection
-              try {
-                  // Accept interest ?
-                  if (selectorData.channel instanceof ServerSocketChannel) {
-                      ServerSocketChannel socketChannel =
-                          (ServerSocketChannel) selectorData.channel;
-                      selectorData.sel = this;
-                      selectorData.selKey =
-                        socketChannel.register(selector,
-                            SelectionKey.OP_ACCEPT, selectorData);
-
-                      selectorData.channel = socketChannel;
-                      synchronized (active) {
-                          active.add(selectorData);
-                      }
-                      if (debug) {
-                          log.info("Pending acceptor added: " + selectorData);
-                      }
-                  } else {
-                      SocketChannel socketChannel =
-                          (SocketChannel) selectorData.channel;
-                      selectorData.sel = this;
-                      selectorData.selKey =
-                        socketChannel.register(selector,
-                            SelectionKey.OP_CONNECT, selectorData);
-                      synchronized (active) {
-                          active.add(selectorData);
-                      }
-                      if (debug) {
-                          log.info("Pending connect added: " + selectorData);
-                      }
-                  }
-              } catch (Throwable e) {
-                  log.log(Level.SEVERE, "error registering connect/accept",
-                          e);
-              }
-          }
-          connectAcceptInterest.clear();
-      }
-  }
-
-  private void processPending() throws IOException {
-      if (closeInterest.size() > 0) {
-          synchronized (closeInterest) {
-              List<NioChannel> closeList = new ArrayList(closeInterest);
-              closeInterest.clear();
-
-              Iterator<NioChannel> ci = closeList.iterator();
-
-              while (ci.hasNext()) {
-                  try {
-                      NioChannel selectorData = ci.next();
-                      closeIOThread(selectorData, true);
-                  } catch (Throwable t) {
-                      t.printStackTrace();
-                  }
-              }
-          }
-      }
-      processPendingConnectAccept();
-      processPendingReadWrite();
-
-      if (runnableInterest.size() > 0) {
-          synchronized (runnableInterest) {
-              Iterator<Runnable> ci = runnableInterest.iterator();
-              while (ci.hasNext()) {
-                  Runnable cstate = ci.next();
-                  try {
-                      cstate.run();
-                  } catch (Throwable t) {
-                      t.printStackTrace();
-                  }
-                  if (debug) {
-                      log.info("Run in selthread: " + cstate);
-                  }
-              }
-              runnableInterest.clear();
-          }
-      }
-      //processPendingUpdateCallback();
-  }
-
-  private void processPendingReadWrite() throws IOException {
-      // Update interest
-      if (readInterest.size() > 0) {
-          synchronized (readInterest) {
-              Iterator<NioChannel> ci = readInterest.iterator();
-              while (ci.hasNext()) {
-                  NioChannel cstate = ci.next();
-                  selThreadReadInterest(cstate);
-                  if (debug) {
-                      log.info("Read interest added: " + cstate);
-                  }
-              }
-              readInterest.clear();
-          }
-      }
-      if (writeInterest.size() > 0) {
-          synchronized (writeInterest) {
-              Iterator<NioChannel> ci = writeInterest.iterator();
-              while (ci.hasNext()) {
-                  NioChannel cstate = ci.next();
-                  // Fake callback - will update as side effect
-                  handleDataWriteable(cstate);
-                  if (debug) {
-                      log.info("Write interest, calling dataWritable: " + cstate);
-                  }
-              }
-              writeInterest.clear();
-          }
-      }
-  }
-
-
-  protected boolean isSelectorThread() {
-      return Thread.currentThread() == selectorThread;
-  }
-
-  public static boolean isSelectorThread(IOChannel ch) {
-      SocketIOChannel sc = (SocketIOChannel) ch.getFirst();
-      return Thread.currentThread() == sc.ch.sel.selectorThread;
-  }
-
-}
\ No newline at end of file

==================================================
SocketIOChannel.java
deleted file mode 100644
index 283b947456..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/SocketConnector.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.util.Timer;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.lite.io.NioChannel.NioChannelCallback;
-
-/**
- * Class for handling sockets. It manages a pool of SelectorThreads, fully
- * non-blocking. There is no caching or buffer management. SelectorChannel
- * represents on connection.
- *
- * In the old types, the connector was socket-centric, and quite ugly. After
- * many refactoring the buffers ( buckets and brigade ) and callbacks are
- * used everywhere, and the sockets play a supporting role.
- *
- * TODO: discover if APR is available and use it, or fall back to NIO.
- *
- * @author Costin Manolache
- */
-public class SocketConnector extends IOConnector {
-    static Logger log = Logger.getLogger(SocketConnector.class.getName());
-    static boolean debug = false;
-
-    // TODO: pool, balanced usage
-    // TODO: bind into OM or callback when created
-
-    private NioThread selector;
-
-    // For resolving DNS ( i.e. connect )
-    Executor threadPool = Executors.newCachedThreadPool();
-
-    public SocketConnector() {
-        timer = new Timer(true);
-    }
-
-    public SocketConnector(int port) {
-        timer = new Timer(true);
-    }
-
-    /**
-     * This may be blocking - involves host resolution, connect.
-     * If the IP address is provided - it shouldn't block.
-     */
-    @Override
-    public void connect(final String host, final int port,
-                             final IOConnector.ConnectedCallback sc) throws IOException {
-        final SocketIOChannel ioch = new SocketIOChannel(this, null, host + ":" + port);
-        ioch.setConnectedCallback(sc);
-        threadPool.execute(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    getSelector().connect(new InetSocketAddress(host, port), ioch, null);
-                } catch (Throwable e) {
-                    e.printStackTrace();
-                    try {
-                        sc.handleConnected(ioch);
-                        ioch.close();
-                    } catch (Throwable e1) {
-                        e1.printStackTrace();
-                    }
-                }
-            }
-        });
-    }
-
-    /**
-     * Create a new server socket, register the callback.
-     * If port == 0 it'll use the inherited channel, i.e. inetd mode.
-     * TODO: if port == -1, detect a free port. May block.
-     */
-    public void acceptor(final IOConnector.ConnectedCallback sc,
-                         final CharSequence address, Object extra)
-        throws IOException
-    {
-        final int port = Integer.parseInt(address.toString());
-        NioChannelCallback acceptCb = new NioChannelCallback() {
-            @Override
-            public void handleClosed(NioChannel ch) throws IOException {
-            }
-
-            @Override
-            public void handleConnected(NioChannel ch) throws IOException {
-                SocketIOChannel ioch = new SocketIOChannel(SocketConnector.this,
-                        ch, ":" + port);
-                sc.handleConnected(ioch);
-            }
-
-            @Override
-            public void handleReadable(NioChannel ch) throws IOException {
-            }
-
-            @Override
-            public void handleWriteable(NioChannel ch) throws IOException {
-            }
-        };
-
-        if (port == -1) {
-            // TODO: find an unused port
-        } else if (port == 0) {
-            getSelector().inetdAcceptor(acceptCb);
-        }  else {
-            getSelector().acceptor(acceptCb, port, null, 200, 20000);
-        }
-    }
-
-    static int id = 0;
-
-    public synchronized NioThread getSelector() {
-        if (selector == null) {
-            String name = "SelectorThread-" + id++;
-            selector = new NioThread(name, true);
-        }
-
-        return selector;
-    }
-
-    public void stop() {
-        getSelector().stop();
-    }
-
-
-    // TODO: suspendAccept(boolean)
-
-}

==================================================
SslProvider.java
deleted file mode 100644
index c74ccc5240..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/SocketIOChannel.java
+++ /dev/null
@@ -1,271 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.nio.ByteBuffer;
-
-import org.apache.tomcat.lite.io.NioChannel.NioChannelCallback;
-
-/**
- * Buffered socket channel
- */
-public class SocketIOChannel extends IOChannel implements NioChannelCallback {
-    IOBuffer out;
-    IOBuffer in;
-
-    NioChannel ch;
-
-    SocketIOChannel(IOConnector connector, NioChannel data,
-            String target)
-            throws IOException {
-        this.connector = connector;
-        in = new IOBuffer(this);
-        out = new IOBuffer(this);
-        this.ch = data;
-        setOutBuffer(out);
-        setChannel(data);
-        this.target = target;
-    }
-
-    void setChannel(NioChannel data) {
-        this.ch = data;
-        if (ch != null) {
-            ch.callback = this;
-        }
-    }
-
-
-    @Override
-    public IOBuffer getIn() {
-        return in;
-    }
-
-    @Override
-    public IOBuffer getOut() {
-        return out;
-    }
-
-    /**
-     * Both in and out open
-     */
-    public boolean isOpen() {
-        if (ch == null) {
-            return false;
-        }
-        return ch.isOpen() && ch.channel != null &&
-            ch.channel.isOpen() && !getIn().isAppendClosed() &&
-            !getOut().isAppendClosed();
-    }
-
-    NioChannel getSelectorChannel() {
-        return ch;
-    }
-
-    public String toString() {
-        return ch.toString();
-    }
-
-    public void setOutBuffer(IOBuffer out) {
-        this.out = out;
-    }
-
-    ByteBuffer flushBuffer;
-
-    /**
-     * Send as much as possible.
-     *
-     * Adjust write interest so we can send more when possible.
-     */
-    private void flush(NioChannel ch) throws IOException {
-        synchronized (this) {
-            if (ch == null) {
-                if (out.isClosedAndEmpty()) {
-                    return;
-                }
-                throw new IOException("flush() with closed socket");
-            }
-            while (true) {
-                if (out.isClosedAndEmpty()) {
-                    ch.shutdownOutput();
-                    break;
-                }
-                BBucket bb = out.peekFirst();
-                if (bb == null) {
-                    break;
-                }
-                flushBuffer = getReadableBuffer(flushBuffer, bb);
-                int before = flushBuffer.position();
-
-                int done = 0;
-                while (flushBuffer.remaining() > 0) {
-                    try {
-                        done = ch.write(flushBuffer);
-                    } catch (IOException ex) {
-                        // can't write - was closed !
-                        done = -1;
-                    }
-
-                    if (done < 0) {
-                        ch.close();
-                        out.close();
-                        handleFlushed(this);
-                        //throw new IOException("Closed while writting ");
-                        return;
-                    }
-                    if (done == 0) {
-                        bb.position(flushBuffer.position());
-                        ch.writeInterest(); // it is cleared on next dataWriteable
-                        return;
-                    }
-                }
-                releaseReadableBuffer(flushBuffer, bb);
-            }
-            handleFlushed(this);
-
-        }
-    }
-
-    /**
-     * Data available for read, called from IO thread.
-     * You MUST read all data ( i.e. until read() returns 0).
-     *
-     * OP_READ remain active - call readInterest(false) to disable -
-     * for example to suspend reading if buffer is full.
-     */
-    public void handleReceived(IOChannel net) throws IOException {
-        // All data will go to currentReceiveBuffer, until it's full.
-        // Then a new buffer will be allocated/pooled.
-
-        // When we fill the buffers or finish this round of reading -
-        // we place the Buckets in the queue, as 'readable' buffers.
-        boolean newData = false;
-        try {
-            int read = 0;
-            synchronized(in) {
-                // data between 0 and position
-                int total = 0;
-                while (true) {
-                    if (in.isAppendClosed()) { // someone closed me ?
-                        ch.inputClosed(); // remove read interest.
-                        // if outClosed - close completely
-                        newData = true;
-                        break;
-                    }
-
-                    ByteBuffer bb = in.getWriteBuffer();
-                    read = ch.read(bb);
-                    in.releaseWriteBuffer(read);
-
-                    if (in == null) { // Detached.
-                        break;
-                    }
-
-                    if (read < 0) {
-                        // mark the in buffer as closed
-                        in.close();
-                        ch.inputClosed();
-                        newData = true;
-                        break;
-                    }
-                    if (read == 0) {
-                        break;
-                    }
-                    total += read;
-                    newData = true;
-                }
-            } // sync
-            if (newData) {
-                super.sendHandleReceivedCallback();
-            }
-
-        } catch (Throwable t) {
-            close();
-            if (t instanceof IOException) {
-                throw (IOException) t;
-            } else {
-                throw new IOException(t.toString());
-            }
-        }
-    }
-
-    public static final ByteBuffer getReadableBuffer(ByteBuffer orig, BBucket bucket) {
-        if (orig == null || orig.array() != bucket.array()) {
-            orig = ByteBuffer.wrap(bucket.array());
-        }
-        orig.position(bucket.position());
-        orig.limit(bucket.limit());
-        return orig;
-    }
-
-    public static final void releaseReadableBuffer(ByteBuffer bb, BBucket bucket) {
-        bucket.position(bb.position());
-    }
-
-
-    public void readInterest(boolean b) throws IOException {
-        ch.readInterest(b);
-    }
-
-    public InetAddress getAddress(boolean remote) {
-        return ch.getAddress(remote);
-    }
-
-    @Override
-    public Object getAttribute(String name) {
-        if (ATT_REMOTE_HOSTNAME.equals(name)) {
-            return getAddress(true).getHostName();
-        } else if (ATT_LOCAL_HOSTNAME.equals(name)) {
-            return getAddress(false).getHostName();
-        } else if (ATT_REMOTE_ADDRESS.equals(name)) {
-            return getAddress(true).getHostAddress();
-        } else if (ATT_LOCAL_ADDRESS.equals(name)) {
-            return getAddress(false).getHostAddress();
-        } else if (ATT_REMOTE_PORT.equals(name)) {
-            return ch.getPort(true);
-        } else if (ATT_LOCAL_PORT.equals(name)) {
-            return ch.getPort(false);
-        }
-        return null;
-    }
-
-    public void startSending() throws IOException {
-        flush(ch);
-    }
-
-    public void shutdownOutput() throws IOException {
-        getOut().close();
-        if (ch != null) {
-            startSending();
-        }
-    }
-
-    @Override
-    public void handleClosed(NioChannel ch) throws IOException {
-        lastException = ch.lastException;
-        closed(); // our callback.
-    }
-
-    public void closed() throws IOException {
-        getIn().close();
-        sendHandleReceivedCallback();
-        //super.closed();
-    }
-
-    @Override
-    public void handleConnected(NioChannel ch) throws IOException {
-        setChannel(ch);
-        connectedCallback.handleConnected(this);
-    }
-
-    @Override
-    public void handleReadable(NioChannel ch) throws IOException {
-        handleReceived(this);
-    }
-
-    @Override
-    public void handleWriteable(NioChannel ch) throws IOException {
-        flush(ch);
-    }
-}

==================================================
UrlEncoding.java
deleted file mode 100644
index 8c584b8756..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/SslProvider.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-
-public interface SslProvider {
-
-    public static final String ATT_SSL_CERT = "SslCert";
-    public static final String ATT_SSL_CIPHER = "SslCipher";
-    public static final String ATT_SSL_KEY_SIZE = "SslKeySize";
-    public static final String ATT_SSL_SESSION_ID = "SslSessionId";
-
-    /**
-     * Wrap channel with SSL.
-     *
-     * The result will start a handshake
-     */
-    public IOChannel channel(IOChannel net, String host, int port)
-        throws IOException;
-
-    public IOChannel serverChannel(IOChannel net) throws IOException;
-
-}

==================================================
WrappedException.java
deleted file mode 100644
index 09e4b539b6..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/UrlEncoding.java
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.lite.io;
-
-import java.io.CharConversionException;
-import java.io.IOException;
-import java.nio.charset.CharsetEncoder;
-import java.util.BitSet;
-
-
-/**
- * Support for %xx URL encoding.
- *
- * @author Costin Manolache
- */
-public final class UrlEncoding {
-
-    protected static final boolean ALLOW_ENCODED_SLASH =
-        Boolean.valueOf(
-                System.getProperty(
-                        "org.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH",
-                "false")).booleanValue();
-
-    public UrlEncoding() {
-    }
-
-    // Utilities for URL encoding.
-    static BitSet SAFE_CHARS_URL = new BitSet(128);
-    static BitSet SAFE_CHARS = new BitSet(128);
-    BBuffer tmpBuffer = BBuffer.allocate(1024);
-    CBuffer tmpCharBuffer = CBuffer.newInstance();
-
-    public void urlEncode(CBuffer url, CBuffer encoded, IOWriter enc) {
-        tmpBuffer.recycle();
-        urlEncode(url, tmpBuffer, encoded, enc.getEncoder("UTF-8"),
-                SAFE_CHARS_URL, true, enc);
-    }
-
-    public void urlEncode(String url, CBuffer encoded, IOWriter enc) {
-        tmpCharBuffer.recycle();
-        tmpCharBuffer.append(url);
-        urlEncode(tmpCharBuffer, encoded, enc);
-    }
-
-    /** Only works for UTF-8 or charsets preserving ascii.
-     *
-     * @param url
-     * @param tmpBuffer
-     * @param encoded
-     * @param utf8Enc
-     * @param safeChars
-     */
-    public void urlEncode(CBuffer url,
-            BBuffer tmpBuffer,
-            CBuffer encoded,
-            CharsetEncoder utf8Enc,
-            BitSet safeChars, boolean last, IOWriter enc) {
-        // tomcat charset-encoded each character first. I don't think
-        // this is needed.
-
-        // TODO: space to +
-        enc.encodeAll(url, tmpBuffer, utf8Enc, last);
-        byte[] array = tmpBuffer.array();
-        for (int i = tmpBuffer.position(); i < tmpBuffer.limit(); i++) {
-            int c = array[i];
-            if (safeChars.get(c)) {
-                encoded.append((char) c);
-            } else {
-                encoded.append('%');
-                char ch = Character.forDigit((c >> 4) & 0xF, 16);
-                encoded.append(ch);
-                ch = Character.forDigit(c & 0xF, 16);
-                encoded.append(ch);
-            }
-        }
-    }
-
-    static {
-        initSafeChars(SAFE_CHARS);
-        initSafeChars(SAFE_CHARS_URL);
-        SAFE_CHARS_URL.set('/');
-    }
-
-    private static void initSafeChars(BitSet safeChars) {
-        int i;
-        for (i = 'a'; i <= 'z'; i++) {
-            safeChars.set(i);
-        }
-        for (i = 'A'; i <= 'Z'; i++) {
-            safeChars.set(i);
-        }
-        for (i = '0'; i <= '9'; i++) {
-            safeChars.set(i);
-        }
-        // safe
-        safeChars.set('-');
-        safeChars.set('_');
-        safeChars.set('.');
-
-        // Dangerous: someone may treat this as " "
-        // RFC1738 does allow it, it's not reserved
-        // safeChars.set('+');
-        // extra
-        safeChars.set('*');
-        // tomcat has them - not sure if this is correct
-        safeChars.set('$'); // ?
-        safeChars.set('!'); // ?
-        safeChars.set('\''); // ?
-        safeChars.set('('); // ?
-        safeChars.set(')'); // ?
-        safeChars.set(','); // ?
-    }
-
-    public void urlDecode(BBuffer bb, CBuffer dest, boolean q,
-            IOReader charDec) throws IOException {
-        // Replace %xx
-        tmpBuffer.append(bb);
-        urlDecode(tmpBuffer, q);
-        charDec.decodeAll(bb, dest);
-    }
-
-
-    public void urlDecode(BBuffer bb, CBuffer dest,
-            IOReader charDec) throws IOException {
-        // Replace %xx
-        tmpBuffer.append(bb);
-        urlDecode(tmpBuffer, true);
-        charDec.decodeAll(bb, dest);
-    }
-
-
-    /**
-     * URLDecode, will modify the source. This is only at byte level -
-     * it needs conversion to chars using the right charset.
-     *
-     * @param query Converts '+' to ' ' and allow '/'
-     */
-    public void urlDecode(BBuffer mb, boolean query) throws IOException {
-        int start = mb.getOffset();
-        byte buff[] = mb.array();
-        int end = mb.getEnd();
-
-        int idx = BBuffer.indexOf(buff, start, end, '%');
-        int idx2 = -1;
-        if (query)
-            idx2 = BBuffer.indexOf(buff, start, end, '+');
-        if (idx < 0 && idx2 < 0) {
-            return;
-        }
-
-        // idx will be the smallest positive inxes ( first % or + )
-        if (idx2 >= 0 && idx2 < idx)
-            idx = idx2;
-        if (idx < 0)
-            idx = idx2;
-
-        //boolean noSlash = !query;
-
-        for (int j = idx; j < end; j++, idx++) {
-            if (buff[j] == '+' && query) {
-                buff[idx] = (byte) ' ';
-            } else if (buff[j] != '%') {
-                buff[idx] = buff[j];
-            } else {
-                // read next 2 digits
-                if (j + 2 >= end) {
-                    throw new CharConversionException("EOF");
-                }
-                byte b1 = buff[j + 1];
-                byte b2 = buff[j + 2];
-                if (!isHexDigit(b1) || !isHexDigit(b2))
-                    throw new CharConversionException("isHexDigit");
-
-                j += 2;
-                int res = x2c(b1, b2);
-//                if (noSlash && (res == '/')) {
-//                    throw new CharConversionException("noSlash " + mb);
-//                }
-                buff[idx] = (byte) res;
-            }
-        }
-
-        mb.setEnd(idx);
-
-        return;
-    }
-
-
-    private static boolean isHexDigit(int c) {
-        return ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'));
-    }
-
-    private static int x2c(byte b1, byte b2) {
-        int digit = (b1 >= 'A') ? ((b1 & 0xDF) - 'A') + 10 : (b1 - '0');
-        digit *= 16;
-        digit += (b2 >= 'A') ? ((b2 & 0xDF) - 'A') + 10 : (b2 - '0');
-        return digit;
-    }
-
-}

==================================================
JsseSslProvider.java
deleted file mode 100644
index 5d0897cb50..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/WrappedException.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-
-/**
- * For specific exceptions - also has cause ( good if compiling against
- * JDK1.5 )
- *
- * @author Costin Manolache
- */
-public class WrappedException extends IOException {
-
-    public WrappedException() {
-        super();
-    }
-
-    public WrappedException(String message) {
-        super(message);
-    }
-
-    public WrappedException(String message, Throwable cause) {
-        super(message);
-        initCause(cause);
-    }
-
-    public WrappedException(Throwable cause) {
-        super("");
-        initCause(cause);
-    }
-
-
-    public static class ClientAbortException extends WrappedException {
-        public ClientAbortException(Throwable throwable) {
-            super(null, throwable);
-        }
-    }
-
-}

==================================================
SslChannel.java
deleted file mode 100644
index aad716a62c..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/jsse/JsseSslProvider.java
+++ /dev/null
@@ -1,466 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io.jsse;
-
-import java.io.ByteArrayInputStream;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.Socket;
-import java.security.Key;
-import java.security.KeyFactory;
-import java.security.KeyManagementException;
-import java.security.KeyPair;
-import java.security.KeyPairGenerator;
-import java.security.KeyStore;
-import java.security.KeyStoreException;
-import java.security.NoSuchAlgorithmException;
-import java.security.Principal;
-import java.security.PrivateKey;
-import java.security.UnrecoverableKeyException;
-import java.security.cert.Certificate;
-import java.security.cert.CertificateException;
-import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
-import java.security.spec.PKCS8EncodedKeySpec;
-import java.security.spec.RSAKeyGenParameterSpec;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509ExtendedKeyManager;
-import javax.net.ssl.X509TrustManager;
-
-import org.apache.tomcat.lite.io.BBuffer;
-import org.apache.tomcat.lite.io.DumpChannel;
-import org.apache.tomcat.lite.io.IOChannel;
-import org.apache.tomcat.lite.io.IOConnector;
-import org.apache.tomcat.lite.io.SocketConnector;
-import org.apache.tomcat.lite.io.SslProvider;
-import org.apache.tomcat.lite.io.WrappedException;
-import org.apache.tomcat.lite.io.IOConnector.ConnectedCallback;
-
-
-public class JsseSslProvider implements SslProvider {
-
-    /**
-     * TODO: option to require validation.
-     * TODO: remember cert signature. This is needed to support self-signed
-     * certs, like those used by the test.
-     *
-     */
-    public static class BasicTrustManager implements X509TrustManager {
-
-        private X509Certificate[] chain;
-
-        public void checkClientTrusted(X509Certificate[] chain, String authType)
-                throws CertificateException {
-            this.chain = chain;
-        }
-
-        public void checkServerTrusted(X509Certificate[] chain, String authType)
-                throws CertificateException {
-            this.chain = chain;
-        }
-
-        public X509Certificate[] getAcceptedIssuers() {
-            return new X509Certificate[0];
-        }
-    }
-
-    public static TrustManager[] trustAllCerts = new TrustManager[] {
-        new BasicTrustManager() };
-
-    static String[] enabledCiphers;
-
-    static final boolean debug = false;
-
-    IOConnector net;
-    private KeyManager[] keyManager;
-    SSLContext sslCtx;
-    boolean server;
-    private TrustManager[] trustManagers;
-
-    public AtomicInteger handshakeCount = new AtomicInteger();
-    public AtomicInteger handshakeOk = new AtomicInteger();
-    public AtomicInteger handshakeErr = new AtomicInteger();
-    public AtomicInteger handshakeTime = new AtomicInteger();
-
-    Executor handshakeExecutor = Executors.newCachedThreadPool();
-    static int id = 0;
-
-    public JsseSslProvider() {
-    }
-
-    public static void setEnabledCiphers(String[] enabled) {
-        enabledCiphers = enabled;
-    }
-
-    public void start() {
-
-    }
-
-    SSLContext getSSLContext() {
-        if (sslCtx == null) {
-            try {
-                sslCtx = SSLContext.getInstance("TLS");
-                if (trustManagers == null) {
-                    trustManagers =
-                        new TrustManager[] {new BasicTrustManager()};
-
-                }
-                sslCtx.init(keyManager, trustManagers, null);
-            } catch (NoSuchAlgorithmException e) {
-                throw new RuntimeException(e);
-            } catch (KeyManagementException e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            }
-        }
-        return sslCtx;
-    }
-
-    public IOConnector getNet() {
-        if (net == null) {
-            getSSLContext();
-            net = new SocketConnector();
-        }
-        return net;
-    }
-
-    @Override
-    public IOChannel channel(IOChannel net, String host, int port) throws IOException {
-      if (debug) {
-          net = DumpChannel.wrap("S-ENC-" + id, net);
-        }
-        SslChannel ch = new SslChannel()
-            .setTarget(host, port)
-            .setSslContext(getSSLContext())
-            .setSslProvider(this);
-        net.setHead(ch);
-        return ch;
-    }
-
-    @Override
-    public SslChannel serverChannel(IOChannel net) throws IOException {
-        SslChannel ch = new SslChannel()
-            .setSslContext(getSSLContext())
-            .setSslProvider(this).withServer();
-        ch.setSink(net);
-        return ch;
-    }
-
-    public void acceptor(final ConnectedCallback sc, CharSequence port, Object extra)
-            throws IOException {
-        getNet().acceptor(new ConnectedCallback() {
-            @Override
-            public void handleConnected(IOChannel ch) throws IOException {
-                IOChannel first = ch;
-                if (debug) {
-                    first = DumpChannel.wrap("S-ENC-" + id, ch);
-                }
-
-                IOChannel sslch = serverChannel(first);
-                sslch.setSink(first);
-                first.setHead(sslch);
-
-                if (debug) {
-                    sslch = DumpChannel.wrap("S-CLR-" + id, sslch);
-                    id++;
-                }
-
-                sc.handleConnected(sslch);
-            }
-        }, port, extra);
-    }
-
-    public void connect(final String host, final int port, final ConnectedCallback sc)
-            throws IOException {
-        getNet().connect(host, port, new ConnectedCallback() {
-
-            @Override
-            public void handleConnected(IOChannel ch) throws IOException {
-                IOChannel first = ch;
-                if (debug) {
-                    first = DumpChannel.wrap("ENC-" + id, first);
-                }
-
-                IOChannel sslch = channel(first, host, port);
-//                first.setHead(sslch);
-
-                if (debug) {
-                    sslch = DumpChannel.wrap("CLR-" + id, sslch);
-                    id++;
-                }
-
-                sc.handleConnected(sslch);
-            }
-
-        });
-    }
-
-    public JsseSslProvider withKeyManager(KeyManager[] kms) {
-        this.keyManager = kms;
-        return this;
-    }
-
-    public JsseSslProvider setKeystoreFile(String file, String pass) throws IOException {
-        return setKeystore(new FileInputStream(file), pass);
-    }
-
-    public JsseSslProvider setKeystoreResource(String res, String pass) throws IOException {
-        return setKeystore(this.getClass().getClassLoader().getResourceAsStream(res),
-                pass);
-    }
-
-    public JsseSslProvider setKeystore(InputStream file, String pass) {
-        char[] passphrase = pass.toCharArray();
-        KeyStore ks;
-        try {
-            String type = KeyStore.getDefaultType();
-            System.err.println("Keystore: " + type);
-            // Java: JKS
-            // Android: BKS
-            ks = KeyStore.getInstance(type);
-            ks.load(file, passphrase);
-            KeyManagerFactory kmf =
-                KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
-            kmf.init(ks, passphrase);
-
-            TrustManagerFactory tmf =
-                TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
-            tmf.init(ks);
-
-            keyManager = kmf.getKeyManagers();
-            trustManagers = tmf.getTrustManagers();
-        } catch (KeyStoreException e) {
-            // No JKS keystore ?
-            // TODO Auto-generated catch block
-        }catch (NoSuchAlgorithmException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        } catch (CertificateException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        } catch (FileNotFoundException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        } catch (IOException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        } catch (UnrecoverableKeyException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        }
-
-        return this;
-    }
-
-    public JsseSslProvider setKeys(X509Certificate cert, PrivateKey privKey) {
-        keyManager = new KeyManager[] {
-                new TestKeyManager(cert, privKey)
-        };
-        return this;
-    }
-
-    public JsseSslProvider setKeyFiles(String certPem, String keyFile)
-            throws IOException {
-
-
-        return this;
-    }
-
-    public JsseSslProvider setKeyRes(String certPem, String keyFile)
-            throws IOException {
-        setKeys(this.getClass().getClassLoader().getResourceAsStream(certPem),
-                this.getClass().getClassLoader().getResourceAsStream(keyFile));
-        return this;
-    }
-
-    private void setKeys(InputStream certPem,
-            InputStream keyDer) throws IOException {
-        BBuffer keyB = BBuffer.allocate(2048);
-        keyB.readAll(keyDer);
-        byte[] key = new byte[keyB.remaining()];
-        keyB.getByteBuffer().get(key);
-
-        setKeys(certPem, key);
-    }
-
-    public JsseSslProvider setKeys(String certPem, byte[] keyBytes) throws IOException{
-        InputStream is = new ByteArrayInputStream(certPem.getBytes());
-        return setKeys(is, keyBytes);
-    }
-
-    /**
-     * Initialize using a PEM certificate and key bytes.
-     * ( TODO: base64 dep to set the key as PEM )
-     *
-     *  openssl genrsa 1024 > host.key
-     *  openssl pkcs8 -topk8 -nocrypt -in host.key -inform PEM
-     *     -out host.der -outform DER
-     *  openssl req -new -x509 -nodes -sha1 -days 365 -key host.key > host.cert
-     *
-     */
-    public JsseSslProvider setKeys(InputStream certPem, byte[] keyBytes) throws IOException{
-        // convert key
-        try {
-            KeyFactory kf = KeyFactory.getInstance("RSA");
-            PKCS8EncodedKeySpec keysp = new PKCS8EncodedKeySpec(keyBytes);
-            PrivateKey priv = kf.generatePrivate (keysp);
-
-            // Convert cert pem to certificate
-            CertificateFactory cf = CertificateFactory.getInstance("X.509");
-            final X509Certificate cert =  (X509Certificate) cf.generateCertificate(certPem);
-
-            setKeys(cert, priv);
-        } catch (Throwable t) {
-            throw new WrappedException(t);
-        }
-        return this;
-    }
-
-    public class TestKeyManager extends X509ExtendedKeyManager {
-        X509Certificate cert;
-        PrivateKey privKey;
-
-        public TestKeyManager(X509Certificate cert2, PrivateKey privKey2) {
-            cert = cert2;
-            privKey = privKey2;
-        }
-
-        public String chooseEngineClientAlias(String[] keyType,
-                java.security.Principal[] issuers, javax.net.ssl.SSLEngine engine) {
-            return "client";
-        }
-
-        public String chooseEngineServerAlias(String keyType,
-                java.security.Principal[] issuers, javax.net.ssl.SSLEngine engine) {
-            return "server";
-        }
-
-        public String chooseClientAlias(String[] keyType,
-                                        Principal[] issuers, Socket socket) {
-            return "client";
-        }
-
-        public String chooseServerAlias(String keyType,
-                                        Principal[] issuers, Socket socket) {
-            return "server";
-        }
-
-        public X509Certificate[] getCertificateChain(String alias) {
-            return new X509Certificate[] {cert};
-        }
-
-        public String[] getClientAliases(String keyType, Principal[] issuers) {
-            return null;
-        }
-
-        public PrivateKey getPrivateKey(String alias) {
-
-            return privKey;
-        }
-
-        public String[] getServerAliases(String keyType, Principal[] issuers) {
-            return null;
-        }
-    }
-
-    // TODO: add a mode that trust a defined list of certs, like SSH
-
-    /**
-     * Make URLConnection accept all certificates.
-     * Use only for testing !
-     */
-    public static void testModeURLConnection() {
-        try {
-            SSLContext sc = SSLContext.getInstance("TLS");
-            sc.init(null, JsseSslProvider.trustAllCerts, null);
-
-            javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(
-                    sc.getSocketFactory());
-            javax.net.ssl.HttpsURLConnection.setDefaultHostnameVerifier(
-                    new HostnameVerifier() {
-
-                        @Override
-                        public boolean verify(String hostname,
-                                SSLSession session) {
-                            try {
-                                Certificate[] certs = session.getPeerCertificates();
-                                // TODO...
-                                // see org/apache/http/conn/ssl/AbstractVerifier
-                            } catch (SSLPeerUnverifiedException e) {
-                                e.printStackTrace();
-                            }
-                            return true;
-                        }
-
-                    });
-
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-
-    // Utilities
-    public static byte[] getPrivateKeyFromStore(String file, String pass)
-            throws Exception {
-        KeyStore store = KeyStore.getInstance("JKS");
-        store.load(new FileInputStream(file), pass.toCharArray());
-        Key key = store.getKey("tomcat", "changeit".toCharArray());
-        PrivateKey pk = (PrivateKey) key;
-        byte[] encoded = pk.getEncoded();
-        return encoded;
-    }
-
-    public static byte[] getCertificateFromStore(String file, String pass)
-            throws Exception {
-        KeyStore store = KeyStore.getInstance("JKS");
-        store.load(new FileInputStream(file), pass.toCharArray());
-        Certificate certificate = store.getCertificate("tomcat");
-
-        return certificate.getEncoded();
-    }
-
-    public static KeyPair generateRsaOrDsa(boolean rsa) throws Exception {
-        if (rsa) {
-            KeyPairGenerator keyPairGen =
-                KeyPairGenerator.getInstance("RSA");
-            keyPairGen.initialize(1024);
-
-            RSAKeyGenParameterSpec keySpec = new RSAKeyGenParameterSpec(1024,
-                    RSAKeyGenParameterSpec.F0);
-            keyPairGen.initialize(keySpec);
-
-            KeyPair rsaKeyPair = keyPairGen.generateKeyPair();
-
-            return rsaKeyPair;
-        } else {
-            KeyPairGenerator keyPairGen =
-                KeyPairGenerator.getInstance("DSA");
-            keyPairGen.initialize(1024);
-
-            KeyPair pair = keyPairGen.generateKeyPair();
-
-            return pair;
-        }
-    }
-
-    /**
-     * I know 2 ways to generate certs:
-     *  - keytool
-     *  - openssl req -x509 -nodes -days 365 \
-     *    -newkey rsa:1024 -keyout mycert.pem -out mycert.pem
-     *  openssl s_server -accept 9443 -cert mycert.pem -debug -msg -state -www
-     */
-}
\ No newline at end of file

==================================================
CopyCallback.java
deleted file mode 100644
index 07a0f305c1..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/io/package.html
+++ /dev/null
@@ -1,7 +0,0 @@
-IO layer based on tomcat coyote connector and utils.
-
-There are many big changes:
-<ul>
-  <li>
-  <li>
-</ul>
\ No newline at end of file

==================================================
HttpProxyService.java
deleted file mode 100644
index cfb499d249..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/proxy/CopyCallback.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.proxy;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
-import org.apache.tomcat.lite.http.HttpChannel;
-import org.apache.tomcat.lite.io.IOBuffer;
-import org.apache.tomcat.lite.io.IOChannel;
-import org.apache.tomcat.lite.io.IOConnector;
-
-/**
- *  Used by socks and http proxy. Will copy received data to a different
- *  channel.
- */
-public class CopyCallback implements IOConnector.DataReceivedCallback {
-        IOChannel mOutBuffer;
-
-        public CopyCallback(IOChannel sc) {
-            mOutBuffer = sc;
-        }
-
-        @Override
-        public void handleReceived(IOChannel ch) throws IOException {
-            IOBuffer inBuffer = ch.getIn();
-            IOChannel outBuffer = mOutBuffer;
-            if (outBuffer == null &&
-                    ch instanceof HttpChannel) {
-                outBuffer =
-                    (IOChannel) ((HttpChannel)ch).getRequest().getAttribute("P");
-            }
-            // body.
-            while (true) {
-                if (outBuffer == null || outBuffer.getOut() == null) {
-                    return;
-                }
-                if (outBuffer.getOut().isAppendClosed()) {
-                    return;
-                }
-
-                ByteBuffer bb = outBuffer.getOut().getWriteBuffer();
-                int rd = inBuffer.read(bb);
-                outBuffer.getOut().releaseWriteBuffer(rd);
-
-                if (rd == 0) {
-                    outBuffer.startSending();
-                    return;
-                }
-                if (rd < 0) {
-                    outBuffer.getOut().close();
-                    outBuffer.startSending();
-                    return;
-                }
-            }
-        }
-    }
\ No newline at end of file

==================================================
ProxyFlushedCallback.java
deleted file mode 100644
index 6c426b78a0..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/proxy/HttpProxyService.java
+++ /dev/null
@@ -1,368 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.proxy;
-
-import java.io.IOException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.lite.http.HttpChannel;
-import org.apache.tomcat.lite.http.HttpConnector;
-import org.apache.tomcat.lite.http.HttpRequest;
-import org.apache.tomcat.lite.http.HttpResponse;
-import org.apache.tomcat.lite.http.MultiMap;
-import org.apache.tomcat.lite.http.HttpChannel.HttpService;
-import org.apache.tomcat.lite.http.HttpChannel.RequestCompleted;
-import org.apache.tomcat.lite.io.CBuffer;
-import org.apache.tomcat.lite.io.IOChannel;
-import org.apache.tomcat.lite.io.IOConnector;
-import org.apache.tomcat.lite.io.CBuffer;
-import org.apache.tomcat.lite.io.SocketConnector;
-
-/**
- * Http callback for the server-side. Will forward all requests to
- * a remote http server - either using proxy mode ( GET http://... ) or
- * forward requests ( GET /foo -> will be served by the remote server ).
- *
- * This is not blocking (except the connect, which currenly blocks on dns).
- */
-public class HttpProxyService implements HttpService {
-
-    // target - when used in forwarding mode.
-    String target = "localhost";
-    int port = 8802;
-
-    static Logger log = Logger.getLogger("HttpProxy");
-    public static boolean debug = false;
-    boolean keepOpen = true;
-
-    // client side - this connect to the real server that generates the resp.
-    ProxyClientCallback clientHeadersReceived = new ProxyClientCallback();
-
-    HttpConnector httpConnector;
-    IOConnector ioConnector;
-
-    public HttpProxyService withSelector(IOConnector pool) {
-        this.ioConnector = pool;
-        return this;
-    }
-
-    public HttpProxyService withHttpClient(HttpConnector pool) {
-        this.httpConnector = pool;
-        return this;
-    }
-
-    public HttpProxyService withTarget(String host, int port) {
-        this.target = host;
-        this.port = port;
-        return this;
-    }
-
-    private IOConnector getSelector() {
-        if (ioConnector == null) {
-            ioConnector = new SocketConnector();
-        }
-        return ioConnector;
-    }
-
-    private HttpConnector getHttpConnector() {
-        if (httpConnector == null) {
-            httpConnector = new HttpConnector(getSelector());
-        }
-        return httpConnector;
-    }
-
-    // Connects to the target CONNECT server, as client, forwards
-    static class ProxyConnectClientConnection implements IOConnector.ConnectedCallback {
-
-        IOChannel serverNet;
-        private HttpChannel serverHttp;
-
-        public ProxyConnectClientConnection(HttpChannel sproc) throws IOException {
-            this.serverNet = sproc.getSink();
-            this.serverHttp = sproc;
-        }
-
-        @Override
-        public void handleConnected(IOChannel ioch) throws IOException {
-            if (!ioch.isOpen()) {
-                serverNet.close();
-                log.severe("Connection failed");
-                return;
-            }
-            afterClientConnect(ioch);
-
-            ioch.setDataReceivedCallback(new CopyCallback(serverNet));
-            //ioch.setDataFlushedCallback(new ProxyFlushedCallback(serverNet, ioch));
-            serverNet.setDataReceivedCallback(new CopyCallback(ioch));
-            //serverNet.setDataFlushedCallback(new ProxyFlushedCallback(ioch, serverNet));
-
-            ioch.sendHandleReceivedCallback();
-        }
-
-        static byte[] OK = "HTTP/1.1 200 OK\r\n\r\n".getBytes();
-
-        protected void afterClientConnect(IOChannel clientCh) throws IOException {
-            serverNet.getOut().queue(OK);
-            serverNet.startSending();
-
-            serverHttp.release(); // no longer used
-        }
-    }
-
-    /**
-     * Parse the req, dispatch the connection.
-     */
-    @Override
-    public void service(HttpRequest serverHttpReq, HttpResponse serverHttpRes)
-            throws IOException {
-
-        String dstHost = target; // default target ( for normal req ).
-        int dstPort = port;
-
-        // TODO: more flexibility/callbacks on selecting the target, acl, etc
-        if (serverHttpReq.method().equals("CONNECT")) {
-            // SSL proxy - just connect and forward all packets
-            // TODO: optimize, add error checking
-            String[] hostPort = serverHttpReq.requestURI().toString().split(":");
-            String host = hostPort[0];
-            int port = 443;
-            if (hostPort.length > 1) {
-                port = Integer.parseInt(hostPort[1]);
-            }
-            if (log.isLoggable(Level.FINE)) {
-                HttpChannel server = serverHttpReq.getHttpChannel();
-                log.info("NEW: " + server.getId() + " " + dstHost + " "  +
-                        server.getRequest().getMethod() +
-                        " " + server.getRequest().getRequestURI() + " " +
-                        server.getIn());
-            }
-
-            try {
-                getSelector().connect(host, port,
-                        new ProxyConnectClientConnection(serverHttpReq.getHttpChannel()));
-            } catch (IOException e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            }
-            return;
-        }
-
-
-        CBuffer origURIx = serverHttpReq.requestURI();
-//        String origURI = origURIx.toString();
-//        if (origURI.startsWith("http://")) {
-//            // Real proxy - extract client address, modify the uri.
-//            // TODO: optimize the strings.
-//            int start = origURI.indexOf('/', 7);
-//            String hostPortS = (start == -1) ?
-//                    origURI.subSequence(7, origURI.length()).toString() :
-//                    origURI.subSequence(7, start).toString();
-//            String[] hostPort = hostPortS.split(":");
-//
-//            dstHost = hostPort[0];
-//            dstPort = (hostPort.length > 1) ? Integer.parseInt(hostPort[1]) :
-//                80;
-//
-//            if (start >= 0) {
-//                serverHttpReq.requestURI().set(origURI.substring(start));
-//            } else {
-//                serverHttpReq.requestURI().set("/");
-//            }
-//        } else {
-            // Adjust the host header.
-            CBuffer hostHdr =
-                serverHttpReq.getMimeHeaders().getHeader("host");
-            if (hostHdr != null) {
-                hostHdr.recycle();
-                CBuffer cb = hostHdr;
-                cb.append(dstHost);
-                if (dstPort != 80) {
-                    cb.append(':');
-                    cb.appendInt(dstPort);
-                }
-            }
-//        }
-        if (debug) {
-            HttpChannel server = serverHttpReq.getHttpChannel();
-            log.info("START: " + server.getId() + " " + dstHost + " "  +
-                    server.getRequest().getMethod() +
-                    " " + server.getRequest().getRequestURI() + " " +
-                    server.getIn());
-        }
-
-        // Send the request with a non-blocking write
-        HttpChannel serverHttp = serverHttpReq.getHttpChannel();
-
-        // Client connection
-        HttpChannel httpClient = getHttpConnector().get(dstHost, dstPort);
-
-        serverHttp.getRequest().setAttribute("CLIENT", httpClient);
-        httpClient.getRequest().setAttribute("SERVER", serverHttp);
-        serverHttp.getRequest().setAttribute("P", httpClient);
-        httpClient.getRequest().setAttribute("P", serverHttp);
-
-        httpClient.setHttpService(clientHeadersReceived);
-
-        // Will send the original request (TODO: small changes)
-        // Response is not affected ( we use the callback )
-        httpClient.getRequest().method().set(serverHttp.getRequest().method());
-        httpClient.getRequest().requestURI().set(serverHttp.getRequest().requestURI());
-        if (serverHttp.getRequest().queryString().length() != 0) {
-            httpClient.getRequest().queryString().set(serverHttp.getRequest().queryString());
-        }
-
-        httpClient.getRequest().protocol().set(serverHttp.getRequest().protocol());
-
-        //cstate.reqHeaders.addValue(name)
-        copyHeaders(serverHttp.getRequest().getMimeHeaders(),
-                httpClient.getRequest().getMimeHeaders() /*dest*/);
-
-        // For debug
-        httpClient.getRequest().getMimeHeaders().remove("Accept-Encoding");
-
-        if (!keepOpen) {
-            httpClient.getRequest().getMimeHeaders().setValue("Connection").set("Close");
-        }
-
-        // Any data
-        serverHttp.setDataReceivedCallback(copy);
-        copy.handleReceived(serverHttp);
-
-        httpClient.send();
-
-
-        //serverHttp.handleReceived(serverHttp.getSink());
-        //httpClient.flush(); // send any data still there
-
-        httpClient.setCompletedCallback(done);
-        // Will call release()
-        serverHttp.setCompletedCallback(done);
-
-        serverHttpReq.async();
-    }
-
-    static HttpDoneCallback done = new HttpDoneCallback();
-    static CopyCallback copy = new CopyCallback(null);
-    // POST: after sendRequest(ch) we need to forward the body !!
-
-
-    static void copyHeaders(MultiMap mimeHeaders, MultiMap dest)
-            throws IOException {
-        for (int i = 0; i < mimeHeaders.size(); i++) {
-            CBuffer name = mimeHeaders.getName(i);
-            CBuffer val = dest.addValue(name.toString());
-            val.set(mimeHeaders.getValue(i));
-        }
-    }
-
-    /**
-     * HTTP _CLIENT_ callback - from tomcat to final target.
-     */
-    public class ProxyClientCallback implements HttpService {
-        /**
-         * Headers received from the client (content http server).
-         * TODO: deal with version missmatches.
-         */
-        @Override
-        public void service(HttpRequest clientHttpReq, HttpResponse clientHttpRes) throws IOException {
-            HttpChannel serverHttp = (HttpChannel) clientHttpReq.getAttribute("SERVER");
-
-            try {
-                serverHttp.getResponse().setStatus(clientHttpRes.getStatus());
-                serverHttp.getResponse().getMessageBuffer().set(clientHttpRes.getMessageBuffer());
-                copyHeaders(clientHttpRes.getMimeHeaders(),
-                        serverHttp.getResponse().getMimeHeaders());
-
-                serverHttp.getResponse().getMimeHeaders().addValue("TomcatProxy").set("True");
-
-                clientHttpReq.getHttpChannel().setDataReceivedCallback(copy);
-                copy.handleReceived(clientHttpReq.getHttpChannel());
-
-                serverHttp.startSending();
-
-
-                //clientHttpReq.flush(); // send any data still there
-
-                //  if (clientHttpReq.getHttpChannel().getIn().isClosedAndEmpty()) {
-                //     serverHttp.getOut().close(); // all data from client already in buffers
-                //  }
-
-            } catch (IOException e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            }
-        }
-    }
-
-    static final class HttpDoneCallback implements RequestCompleted {
-
-        public HttpDoneCallback() {
-        }
-
-        @Override
-        public void handle(HttpChannel doneCh, Object extraData) throws IOException {
-            HttpChannel serverCh =
-                (HttpChannel) doneCh.getRequest().getAttribute("SERVER");
-            HttpChannel clientCh = doneCh;
-            String tgt = "C";
-            if (serverCh == null) {
-                 serverCh = doneCh;
-                 clientCh =
-                    (HttpChannel) doneCh.getRequest().getAttribute("CLIENT");
-                 tgt = "S";
-            }
-            if (serverCh == null || clientCh == null) {
-                return;
-            }
-            if (doneCh.getError()) {
-                serverCh.abort("Proxy error");
-                clientCh.abort("Proxy error");
-                return;
-            }
-
-            if (log.isLoggable(Level.FINE)) {
-                HttpChannel peerCh =
-                    (HttpChannel) doneCh.getRequest().getAttribute("SERVER");
-                if (peerCh == null) {
-                    peerCh =
-                        (HttpChannel) doneCh.getRequest().getAttribute("CLIENT");
-                } else {
-
-                }
-                log.info(tgt + " " + peerCh.getId() + " " +
-                        doneCh.getTarget() + " " +
-                        doneCh.getRequest().getMethod() +
-                        " " + doneCh.getRequest().getRequestURI() + " " +
-                        doneCh.getResponse().getStatus() + " IN:" + doneCh.getIn()
-                        + " OUT:" + doneCh.getOut() +
-                        " SIN:" + peerCh.getIn() +
-                        " SOUT:" + peerCh.getOut() );
-            }
-            // stop forwarding. After this call the client object will be
-            // recycled
-            //clientCB.outBuffer = null;
-
-            // We must releaes both at same time
-            synchronized (this) {
-
-                serverCh.complete();
-
-                if (clientCh.getRequest().getAttribute("SERVER") == null) {
-                    return;
-                }
-                if (clientCh.isDone() && serverCh.isDone()) {
-                    clientCh.getRequest().setAttribute("SERVER", null);
-                    serverCh.getRequest().setAttribute("CLIENT", null);
-                    clientCh.getRequest().setAttribute("P", null);
-                    serverCh.getRequest().setAttribute("P", null);
-                    // Reuse the objects.
-                    serverCh.release();
-                    clientCh.release();
-                }
-            }
-        }
-    }
-
-
-}

==================================================
SocksServer.java
deleted file mode 100644
index 63fb18ba90..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/proxy/ProxyFlushedCallback.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.proxy;
-
-import java.io.IOException;
-
-import org.apache.tomcat.lite.io.IOChannel;
-import org.apache.tomcat.lite.io.IOConnector;
-
-public final class ProxyFlushedCallback implements IOConnector.DataFlushedCallback {
-    IOChannel peerCh;
-
-    public ProxyFlushedCallback(IOChannel ch2, IOChannel clientChannel2) {
-        peerCh = ch2;
-    }
-
-    @Override
-    public void handleFlushed(IOChannel ch) throws IOException {
-        if (ch.getOut().isClosedAndEmpty()) {
-            if (!peerCh.getOut().isAppendClosed()) {
-                peerCh.close();
-            }
-        }
-    }
-}
\ No newline at end of file

==================================================
StaticContentService.java
deleted file mode 100644
index ad683459de..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/proxy/SocksServer.java
+++ /dev/null
@@ -1,448 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.proxy;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.SocketAddress;
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-import java.util.Timer;
-import java.util.TimerTask;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.lite.io.IOBuffer;
-import org.apache.tomcat.lite.io.IOChannel;
-import org.apache.tomcat.lite.io.IOConnector;
-import org.apache.tomcat.lite.io.SocketConnector;
-
-/**
- * A test for the selector package, and helper for the proxy -
- * a SOCKS4a server.
- *
- * Besides the connection initialization, it's almost the
- *  same as the CONNECT method in http proxy.
- *
- * http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol
- * http://www.smartftp.com/Products/SmartFTP/RFC/socks4a.protocol
- * http://www.faqs.org/rfcs/rfc1928.html
- * https://svn.torproject.org/svn/tor/trunk/doc/spec/socks-extensions.txt
- *
- * In firefox, set network.proxy.socks_remote_dns = true to do DNS via proxy.
- *
- * Also interesting:
- * http://transocks.sourceforge.net/
- *
- * @author Costin Manolache
- */
-public class SocksServer implements Runnable, IOConnector.ConnectedCallback {
-    protected int port = 2080;
-
-    protected IOConnector ioConnector;
-    protected static Logger log = Logger.getLogger("SocksServer");
-
-    protected long idleTimeout = 10 * 60000; // 10 min
-
-    protected long lastConnection = 0;
-    protected long totalConTime = 0;
-    protected AtomicInteger totalConnections = new AtomicInteger();
-
-    protected AtomicInteger active = new AtomicInteger();
-
-    protected long inBytes;
-    protected long outBytes;
-    protected static int sockets;
-
-    public int getPort() {
-        return port;
-    }
-
-    public int getActive() {
-        return active.get();
-    }
-
-    public int getTotal() {
-        return totalConnections.get();
-    }
-
-    public void setPort(int port) {
-        this.port = port;
-    }
-
-    public void handleAccepted(IOChannel accepted) throws IOException {
-        lastConnection = System.currentTimeMillis();
-        active.incrementAndGet();
-        totalConnections.incrementAndGet();
-        sockets++;
-
-        final SocksServerConnection socksCon = new SocksServerConnection(accepted);
-        socksCon.pool = ioConnector;
-        socksCon.server = this;
-
-        accepted.setDataReceivedCallback(socksCon);
-        socksCon.handleReceived(accepted);
-    }
-
-    /**
-     * Exit if no activity happens.
-     */
-    public void setIdleTimeout(long to) {
-        idleTimeout = to;
-    }
-
-    public long getIdleTimeout() {
-        return idleTimeout;
-    }
-
-    public void stop() {
-        ioConnector.stop();
-    }
-
-    public void initServer() throws IOException {
-        if (ioConnector == null) {
-            ioConnector = new SocketConnector();
-        }
-        ioConnector.acceptor(this, Integer.toString(port), null);
-
-        final Timer timer = new Timer(true /* daemon */);
-        timer.scheduleAtFixedRate(new TimerTask() {
-            @Override
-            public void run() {
-                try {
-                // if lastConnection == 0 - it'll terminate on first timer
-                float avg = (totalConnections.get() > 0) ?
-                        totalConTime / totalConnections.get() : 0;
-                System.err.println("Socks:"
-                        + "\ttotal=" + totalConnections
-                        + "\tin=" + inBytes
-                        + "\tout=" + outBytes
-                        + "\tavg=" + (int) avg);
-                if (active.get() <= 0
-                        && idleTimeout > 0
-                        && System.currentTimeMillis() - lastConnection > idleTimeout) {
-                    System.err.println("Idle timeout");
-                    stop();
-                    this.cancel();
-                    timer.cancel();
-                }
-                } catch (Throwable t) {
-                    log.log(Level.SEVERE, "Error in timer", t);
-                }
-            }
-        }, 5 * 60 * 1000, 5 * 60 * 1000); // 5
-
-
-    }
-
-
-    public static class SocksServerConnection implements IOConnector.DataReceivedCallback, IOConnector.ConnectedCallback {
-
-        protected SocksServer server;
-
-        boolean headReceived;
-        boolean head5Received = false;
-
-        ByteBuffer headBuffer = ByteBuffer.allocate(256);
-        ByteBuffer headReadBuffer = headBuffer.duplicate();
-
-        ByteBuffer headResBuffer = ByteBuffer.allocate(256);
-        IOConnector pool;
-        byte ver;
-        byte cmd;
-        long startTime = System.currentTimeMillis();
-
-        static final int CMD_CONNECT = 0;
-        static final byte CMD_RESOLVE = (byte) 0xF0;
-
-        int port;
-        byte[] hostB = new byte[4];
-        CharBuffer userId = CharBuffer.allocate(256);
-        CharBuffer hostName = CharBuffer.allocate(256);
-
-        SocketAddress sa = null;
-
-        private byte atyp;
-
-        IOChannel serverCh;
-
-        public SocksServerConnection(IOChannel accepted) {
-            this.serverCh = accepted;
-        }
-
-        protected void afterClientConnect(IOChannel clientCh) throws IOException {
-            headResBuffer.clear();
-            if (ver == 4) {
-                headResBuffer.put((byte) 0);
-                headResBuffer.put((byte) 90);
-                for (int i = 0; i < 6; i++ ) {
-                    headResBuffer.put((byte) 0);
-                }
-            } else {
-                headResBuffer.put((byte) 5);
-                headResBuffer.put((byte) 0);
-                headResBuffer.put((byte) 0);
-                headResBuffer.put((byte) 1); // ip
-
-                headResBuffer.put(hostB);
-                int port2 = (Integer) clientCh.getAttribute(IOChannel.ATT_REMOTE_PORT);
-                headResBuffer.putShort((short) port2);
-            }
-
-            headResBuffer.flip();
-
-            serverCh.getOut().queue(headResBuffer);
-            log.fine("Connected " + sa.toString());
-
-            if (headReadBuffer.remaining() > 0) {
-                serverCh.getOut().queue(headReadBuffer);
-            }
-            serverCh.startSending();
-        }
-
-        public void afterClose() {
-            long conTime = System.currentTimeMillis() - startTime;
-            int a = server.active.decrementAndGet();
-            if (a < 0) {
-                System.err.println("negative !!");
-                server.active.set(0);
-            }
-//            System.err.println(sa + "\tsR:" +
-//                    received
-//                    + "\tcR:" + clientReceived
-//                    + "\tactive:" + a
-//                    + "\ttotC:" + server.totalConnections
-//                    + "\ttime:" + conTime);
-//            server.inBytes += received;
-//            server.totalConTime += conTime;
-//            server.outBytes += clientReceived;
-        }
-
-
-        protected int parseHead() throws IOException {
-            // data is between 0 and pos.
-            int pos = headBuffer.position();
-            headReadBuffer.clear();
-            headReadBuffer.limit(pos);
-            if (headReadBuffer.remaining() < 2) {
-                return -1;
-            }
-
-            ByteBuffer bb = headReadBuffer;
-            ver = bb.get();
-            if (ver == 5) {
-                return parseHead5();
-            }
-            if (headReadBuffer.remaining() < 8) {
-                return -1;
-            }
-            cmd = bb.get();
-            port = bb.getShort();
-            bb.get(hostB);
-            userId.clear();
-            int rc = readStringZ(bb, userId);
-            // Mozilla userid: MOZ ...
-            if (rc == -1) {
-                return rc;
-            }
-            if (hostB[0] == 0 && hostB[1] == 0 && hostB[2] == 0) {
-                // 0.0.0.x
-                atyp = 3;
-                hostName.clear();
-                rc = readStringZ(bb, hostName);
-                if (rc == -1) {
-                    return rc;
-                }
-            } else {
-                atyp = 1;
-            }
-
-            headReceived = true;
-
-            return 4;
-        }
-
-        protected int parseHead5_2() throws IOException {
-            // data is between 0 and pos.
-            int pos = headBuffer.position();
-
-            headReadBuffer.clear();
-            headReadBuffer.limit(pos);
-
-            if (headReadBuffer.remaining() < 7) {
-                return -1;
-            }
-
-            ByteBuffer bb = headReadBuffer;
-            ver = bb.get();
-            cmd = bb.get();
-            bb.get(); // reserved
-            atyp = bb.get();
-            if (atyp == 1) {
-                bb.get(hostB);
-            } else if (atyp == 3) {
-                hostName.clear();
-                int rc = readStringN(bb, hostName);
-                if (rc == -1) {
-                    return rc;
-                }
-            } // ip6 not supported right now, easy to add
-
-            port = bb.getShort();
-
-            head5Received = true;
-
-            return 5;
-        }
-
-        private int parseHead5() {
-            ByteBuffer bb = headReadBuffer;
-            int nrMethods = ((int)bb.get()) & 0xFF;
-            if (bb.remaining() < nrMethods) {
-                return -1;
-            }
-            for (int i = 0; i < nrMethods; i++) {
-                // ignore
-                bb.get();
-            }
-            return 5;
-        }
-
-        private int readStringZ(ByteBuffer bb, CharBuffer bc) throws IOException {
-            bc.clear();
-            while (true) {
-                if (!bb.hasRemaining()) {
-                    return -1; // not complete
-                }
-                byte b = bb.get();
-                if (b == 0) {
-                    bc.flip();
-                    return 0;
-                } else {
-                    bc.put((char) b);
-                }
-            }
-        }
-
-        private int readStringN(ByteBuffer bb, CharBuffer bc) throws IOException {
-            bc.clear();
-            int len = ((int) bb.get()) & 0xff;
-            for (int i = 0; i < len; i++) {
-                if (!bb.hasRemaining()) {
-                    return -1; // not complete
-                }
-                byte b = bb.get();
-                bc.put((char) b);
-            }
-            bc.flip();
-            return len;
-        }
-
-        static ExecutorService connectTP = Executors.newCachedThreadPool();
-
-        protected void startClientConnection() throws IOException {
-            // TODO: use different thread ?
-            if (atyp == 3) {
-                connectTP.execute(new Runnable() {
-
-                    public void run() {
-                        try {
-                            sa = new InetSocketAddress(hostName.toString(), port);
-                            pool.connect(hostName.toString(), port,
-                                    SocksServerConnection.this);
-                        } catch (Exception ex) {
-                            log.severe("Error connecting");
-                        }
-                    }
-                });
-            } else {
-                InetAddress addr = InetAddress.getByAddress(hostB);
-                pool.connect(addr.toString(), port, this);
-            } // TODO: ip6
-        }
-
-        public void handleConnected(IOChannel ioch) throws IOException {
-            ioch.setDataReceivedCallback(new CopyCallback(serverCh));
-            //ioch.setDataFlushedCallback(new ProxyFlushedCallback(serverCh, ioch));
-
-            serverCh.setDataReceivedCallback(new CopyCallback(ioch));
-            //serverCh.setDataFlushedCallback(new ProxyFlushedCallback(ioch, serverCh));
-
-            afterClientConnect(ioch);
-
-            ioch.sendHandleReceivedCallback();
-        }
-
-
-        @Override
-        public void handleReceived(IOChannel net) throws IOException {
-            IOBuffer ch = net.getIn();
-            //SelectorChannel ch = (SelectorChannel) ioch;
-                if (!headReceived) {
-                    int rd = ch.read(headBuffer);
-                    if (rd == 0) {
-                        return;
-                    }
-                    if (rd == -1) {
-                        ch.close();
-                    }
-
-                    rd = parseHead();
-                    if (rd < 0) {
-                        return; // need more
-                    }
-                    if (rd == 5) {
-                        headResBuffer.clear();
-                        headResBuffer.put((byte) 5);
-                        headResBuffer.put((byte) 0);
-                        headResBuffer.flip();
-                        net.getOut().queue(headResBuffer);
-                        net.startSending();
-                        headReceived = true;
-                        headBuffer.clear();
-                        return;
-                    } else {
-                        headReceived = true;
-                        head5Received = true;
-                        startClientConnection();
-                    }
-                }
-
-                if (!head5Received) {
-                    int rd = ch.read(headBuffer);
-                    if (rd == 0) {
-                        return;
-                    }
-                    if (rd == -1) {
-                        ch.close();
-                    }
-
-                    rd = parseHead5_2();
-                    if (rd < 0) {
-                        return; // need more
-                    }
-
-                    startClientConnection();
-                }
-        }
-    }
-
-    @Override
-    public void run() {
-        try {
-            initServer();
-        } catch (IOException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        }
-    }
-
-    @Override
-    public void handleConnected(IOChannel ch) throws IOException {
-        handleAccepted(ch);
-    }
-}

==================================================
IOStatus.java
deleted file mode 100644
index e50e73e091..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/proxy/StaticContentService.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.lite.proxy;
-
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.lite.http.HttpRequest;
-import org.apache.tomcat.lite.http.HttpResponse;
-import org.apache.tomcat.lite.http.HttpChannel.HttpService;
-import org.apache.tomcat.lite.io.BBuffer;
-import org.apache.tomcat.lite.io.BBucket;
-import org.apache.tomcat.lite.io.IOBuffer;
-
-/*
- *
- * Serve static content, from memory.
- */
-public class StaticContentService implements HttpService  {
-    protected Logger log = Logger.getLogger("coyote.static");
-    protected BBucket mb;
-
-    protected boolean chunked = false;
-    int code = 200;
-
-    protected String contentType = "text/plain";
-
-
-    public StaticContentService() {
-    }
-
-    /**
-     * Used for testing chunked encoding.
-     * @return
-     */
-    public StaticContentService chunked() {
-      chunked = true;
-      return this;
-    }
-
-    public StaticContentService setData(byte[] data) {
-        mb = BBuffer.wrapper(data, 0, data.length);
-        return this;
-    }
-
-    public StaticContentService setStatus(int status) {
-        this.code = status;
-        return this;
-    }
-
-    public StaticContentService withLen(int len) {
-        byte[] data = new byte[len];
-        for (int i = 0; i < len; i++) {
-          data[i] = 'A';
-        }
-        mb = BBuffer.wrapper(data, 0, data.length);
-        return this;
-      }
-
-
-    public StaticContentService setData(CharSequence data) {
-      try {
-          IOBuffer tmp = new IOBuffer(null);
-          tmp.append(data);
-          mb = tmp.readAll(null);
-      } catch (IOException e) {
-      }
-      return this;
-    }
-
-    public StaticContentService setContentType(String ct) {
-      this.contentType = ct;
-      return this;
-    }
-
-    public void setFile(String path) {
-      try {
-        FileInputStream fis = new FileInputStream(path);
-        BBuffer bc = BBuffer.allocate(4096);
-
-        byte b[] = new byte[4096];
-        int rd = 0;
-        while ((rd = fis.read(b)) > 0) {
-            bc.append(b, 0, rd);
-        }
-        mb = bc;
-      } catch (IOException e) {
-        throw new RuntimeException(e);
-      }
-    }
-
-    @Override
-    public void service(HttpRequest httpReq, HttpResponse res) throws IOException {
-
-        res.setStatus(code);
-
-          if (!chunked) {
-            res.setContentLength(mb.remaining());
-          }
-          res.setContentType(contentType);
-
-          int len = mb.remaining();
-          int first = 0;
-
-          if (chunked) {
-              first = len / 2;
-              res.getBody()
-                  .queue(BBuffer.wrapper(mb, 0, first));
-              res.flush();
-          }
-
-          res.getBody().queue(BBuffer.wrapper(mb, 0, len - first));
-    }
-}
\ No newline at end of file

==================================================
LogConfig.java
deleted file mode 100644
index 0623e8d04f..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/service/IOStatus.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.service;
-
-import java.io.IOException;
-import java.util.List;
-
-import org.apache.tomcat.lite.http.HttpConnectionPool;
-import org.apache.tomcat.lite.http.HttpRequest;
-import org.apache.tomcat.lite.http.HttpResponse;
-import org.apache.tomcat.lite.http.HttpWriter;
-import org.apache.tomcat.lite.http.HttpChannel.HttpService;
-import org.apache.tomcat.lite.http.HttpConnectionPool.RemoteServer;
-import org.apache.tomcat.lite.http.HttpConnector.HttpConnection;
-import org.apache.tomcat.lite.io.IOChannel;
-
-/**
- * Dump status of a connection pool.
- */
-public class IOStatus implements HttpService {
-
-    private HttpConnectionPool pool;
-
-    public IOStatus(HttpConnectionPool pool) {
-        this.pool = pool;
-    }
-
-    @Override
-    public void service(HttpRequest httpReq, HttpResponse httpRes)
-            throws IOException {
-        HttpConnectionPool sc = pool;
-        HttpWriter out = httpRes.getBodyWriter();
-
-        httpRes.setContentType("text/plain");
-        // TODO: use JMX/DynamicObject to get all public info
-        out.println("hosts=" + sc.getTargetCount());
-        out.println("waiting=" + sc.getSocketCount());
-        out.println("closed=" + sc.getClosedSockets());
-        out.println();
-
-        for (RemoteServer remote: sc.getServers()) {
-            out.append(remote.target);
-            out.append("=");
-            List<HttpConnection> connections = remote.getConnections();
-            out.println(Integer.toString(connections.size()));
-
-            for (IOChannel ch: connections) {
-                out.println(ch.getId() +
-                        " " + ch.toString());
-            }
-            out.println();
-        }
-
-    }
-
-}

==================================================
FastHttpDateFormat.java
deleted file mode 100644
index b3b99a810f..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/service/LogConfig.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright 2004 Costin Manolache
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.tomcat.lite.service;
-
-import java.io.IOException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.lite.http.HttpRequest;
-import org.apache.tomcat.lite.http.HttpResponse;
-import org.apache.tomcat.lite.http.HttpChannel.HttpService;
-
-/**
- * Log configuration
- *
- */
-public class LogConfig implements HttpService {
-
-    /**
-     * Framework can set this attribute with comma separated
-     * list of loggers to set to debug level.
-     * This is used at startup.
-     */
-    public void setDebug(String debug) {
-        for (String log : debug.split(",")) {
-            Logger logger = Logger.getLogger(log);
-            logger.setLevel(Level.INFO);
-        }
-    }
-
-    /**
-     *
-     */
-    public void setWarn(String nodebug) {
-        for (String log : nodebug.split(",")) {
-            Logger logger = Logger.getLogger(log);
-            logger.setLevel(Level.WARNING);
-        }
-    }
-
-    @Override
-    public void service(HttpRequest httpReq, HttpResponse httpRes)
-            throws IOException {
-        String debug = httpReq.getParameter("debug");
-        setDebug(debug);
-        String warn = httpReq.getParameter("warn");
-        setWarn(warn);
-    }
-}

==================================================
LocaleParser.java
deleted file mode 100644
index 5f76152328..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/util/FastHttpDateFormat.java
+++ /dev/null
@@ -1,231 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.lite.util;
-
-import java.text.DateFormat;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-import java.util.TimeZone;
-import java.util.concurrent.ConcurrentHashMap;
-
-/**
- * Utility class to generate HTTP dates.
- *
- * @author Remy Maucherat
- */
-public final class FastHttpDateFormat {
-
-
-    // -------------------------------------------------------------- Variables
-
-
-    protected static final int CACHE_SIZE =
-        Integer.parseInt(System.getProperty("org.apache.tomcat.util.http.FastHttpDateFormat.CACHE_SIZE", "1000"));
-
-
-    /**
-     * HTTP date format.
-     */
-    protected static final SimpleDateFormat format =
-        new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-
-
-    /**
-     * The set of SimpleDateFormat formats to use in getDateHeader().
-     */
-    protected static final SimpleDateFormat formats[] = {
-        new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US),
-        new SimpleDateFormat("EEEEEE, dd-MMM-yy HH:mm:ss zzz", Locale.US),
-        new SimpleDateFormat("EEE MMMM d HH:mm:ss yyyy", Locale.US)
-    };
-
-
-    protected final static TimeZone gmtZone = TimeZone.getTimeZone("GMT");
-
-
-    /**
-     * GMT timezone - all HTTP dates are on GMT
-     */
-    static {
-
-        format.setTimeZone(gmtZone);
-
-        formats[0].setTimeZone(gmtZone);
-        formats[1].setTimeZone(gmtZone);
-        formats[2].setTimeZone(gmtZone);
-
-    }
-
-
-    /**
-     * Instant on which the currentDate object was generated.
-     */
-    protected static long currentDateGenerated = 0L;
-
-
-    /**
-     * Current formatted date.
-     */
-    protected static String currentDate = null;
-
-
-    /**
-     * Formatter cache.
-     */
-    protected static final ConcurrentHashMap<Long, String> formatCache =
-        new ConcurrentHashMap<Long, String>(CACHE_SIZE);
-
-
-    /**
-     * Parser cache.
-     */
-    protected static final ConcurrentHashMap<String, Long> parseCache =
-        new ConcurrentHashMap<String, Long>(CACHE_SIZE);
-
-
-    // --------------------------------------------------------- Public Methods
-
-
-    /**
-     * Get the current date in HTTP format.
-     */
-    public static final String getCurrentDate() {
-
-        long now = System.currentTimeMillis();
-        if ((now - currentDateGenerated) > 1000) {
-            synchronized (format) {
-                if ((now - currentDateGenerated) > 1000) {
-                    currentDateGenerated = now;
-                    currentDate = format.format(new Date(now));
-                }
-            }
-        }
-        return currentDate;
-
-    }
-
-
-    /**
-     * Get the HTTP format of the specified date.
-     */
-    public static final String formatDate
-        (long value, DateFormat threadLocalformat) {
-
-        Long longValue = new Long(value);
-        String cachedDate = formatCache.get(longValue);
-        if (cachedDate != null)
-            return cachedDate;
-
-        String newDate = null;
-        Date dateValue = new Date(value);
-        if (threadLocalformat != null) {
-            newDate = threadLocalformat.format(dateValue);
-            updateFormatCache(longValue, newDate);
-        } else {
-            synchronized (formatCache) {
-                synchronized (format) {
-                    newDate = format.format(dateValue);
-                }
-                updateFormatCache(longValue, newDate);
-            }
-        }
-        return newDate;
-
-    }
-
-
-    /**
-     * Try to parse the given date as a HTTP date.
-     */
-    public static final long parseDate(String value,
-                                       DateFormat[] threadLocalformats) {
-
-        Long cachedDate = parseCache.get(value);
-        if (cachedDate != null)
-            return cachedDate.longValue();
-
-        Long date = null;
-        if (threadLocalformats != null) {
-            date = internalParseDate(value, threadLocalformats);
-            updateParseCache(value, date);
-        } else {
-            synchronized (parseCache) {
-                date = internalParseDate(value, formats);
-                updateParseCache(value, date);
-            }
-        }
-        if (date == null) {
-            return (-1L);
-        } else {
-            return date.longValue();
-        }
-
-    }
-
-
-    /**
-     * Parse date with given formatters.
-     */
-    private static final Long internalParseDate
-        (String value, DateFormat[] formats) {
-        Date date = null;
-        for (int i = 0; (date == null) && (i < formats.length); i++) {
-            try {
-                date = formats[i].parse(value);
-            } catch (ParseException e) {
-                ;
-            }
-        }
-        if (date == null) {
-            return null;
-        }
-        return new Long(date.getTime());
-    }
-
-
-    /**
-     * Update cache.
-     */
-    private static void updateFormatCache(Long key, String value) {
-        if (value == null) {
-            return;
-        }
-        if (formatCache.size() > CACHE_SIZE) {
-            formatCache.clear();
-        }
-        formatCache.put(key, value);
-    }
-
-
-    /**
-     * Update cache.
-     */
-    private static void updateParseCache(String key, Long value) {
-        if (value == null) {
-            return;
-        }
-        if (parseCache.size() > CACHE_SIZE) {
-            parseCache.clear();
-        }
-        parseCache.put(key, value);
-    }
-
-
-}

==================================================
MimeMap.java
deleted file mode 100644
index cdd3718b80..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/util/LocaleParser.java
+++ /dev/null
@@ -1,394 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.tomcat.lite.util;
-
-import java.util.ArrayList;
-import java.util.Locale;
-import java.util.TreeMap;
-
-
-/**
- * Utility class for string parsing that is higher performance than
- * StringParser for simple delimited text cases.  Parsing is performed
- * by setting the string, and then using the <code>findXxxx()</code> and
- * <code>skipXxxx()</code> families of methods to remember significant
- * offsets.  To retrieve the parsed substrings, call the <code>extract()</code>
- * method with the appropriate saved offset values.
- *
- * @author Craig R. McClanahan
- */
-public final class LocaleParser {
-
-    public LocaleParser() {
-        this(null);
-    }
-
-    public LocaleParser(String string) {
-        setString(string);
-    }
-
-    public TreeMap parseLocale(String value) {
-      // Store the accumulated languages that have been requested in
-      // a local collection, sorted by the quality value (so we can
-      // add Locales in descending order).  The values will be ArrayLists
-      // containing the corresponding Locales to be added
-      TreeMap locales = new TreeMap();
-
-      // Preprocess the value to remove all whitespace
-      int white = value.indexOf(' ');
-      if (white < 0)
-          white = value.indexOf('\t');
-      if (white >= 0) {
-          StringBuilder sb = new StringBuilder();
-          int len = value.length();
-          for (int i = 0; i < len; i++) {
-              char ch = value.charAt(i);
-              if ((ch != ' ') && (ch != '\t'))
-                  sb.append(ch);
-          }
-          value = sb.toString();
-      }
-
-      LocaleParser parser = this;
-      // Process each comma-delimited language specification
-      parser.setString(value);        // ASSERT: parser is available to us
-      int length = parser.getLength();
-      while (true) {
-
-          // Extract the next comma-delimited entry
-          int start = parser.getIndex();
-          if (start >= length)
-              break;
-          int end = parser.findChar(',');
-          String entry = parser.extract(start, end).trim();
-          parser.advance();   // For the following entry
-
-          // Extract the quality factor for this entry
-          double quality = 1.0;
-          int semi = entry.indexOf(";q=");
-          if (semi >= 0) {
-              try {
-                  quality = Double.parseDouble(entry.substring(semi + 3));
-              } catch (NumberFormatException e) {
-                  quality = 0.0;
-              }
-              entry = entry.substring(0, semi);
-          }
-
-          // Skip entries we are not going to keep track of
-          if (quality < 0.00005)
-              continue;       // Zero (or effectively zero) quality factors
-          if ("*".equals(entry))
-              continue;       // FIXME - "*" entries are not handled
-
-          // Extract the language and country for this entry
-          String language = null;
-          String country = null;
-          String variant = null;
-          int dash = entry.indexOf('-');
-          if (dash < 0) {
-              language = entry;
-              country = "";
-              variant = "";
-          } else {
-              language = entry.substring(0, dash);
-              country = entry.substring(dash + 1);
-              int vDash = country.indexOf('-');
-              if (vDash > 0) {
-                  String cTemp = country.substring(0, vDash);
-                  variant = country.substring(vDash + 1);
-                  country = cTemp;
-              } else {
-                  variant = "";
-              }
-          }
-
-          // Add a new Locale to the list of Locales for this quality level
-          Locale locale = new Locale(language, country, variant);
-          Double key = new Double(-quality);  // Reverse the order
-          ArrayList values = (ArrayList) locales.get(key);
-          if (values == null) {
-              values = new ArrayList();
-              locales.put(key, values);
-          }
-          values.add(locale);
-
-      }
-
-      return locales;
-    }
-
-    /**
-     * The characters of the current string, as a character array.  Stored
-     * when the string is first specified to speed up access to characters
-     * being compared during parsing.
-     */
-    private char chars[] = null;
-
-
-    /**
-     * The zero-relative index of the current point at which we are
-     * positioned within the string being parsed.  <strong>NOTE</strong>:
-     * the value of this index can be one larger than the index of the last
-     * character of the string (i.e. equal to the string length) if you
-     * parse off the end of the string.  This value is useful for extracting
-     * substrings that include the end of the string.
-     */
-    private int index = 0;
-
-
-    /**
-     * The length of the String we are currently parsing.  Stored when the
-     * string is first specified to avoid repeated recalculations.
-     */
-    private int length = 0;
-
-
-    /**
-     * The String we are currently parsing.
-     */
-    private String string = null;
-
-
-    // ------------------------------------------------------------- Properties
-
-
-    /**
-     * Return the zero-relative index of our current parsing position
-     * within the string being parsed.
-     */
-    public int getIndex() {
-
-        return (this.index);
-
-    }
-
-
-    /**
-     * Return the length of the string we are parsing.
-     */
-    public int getLength() {
-
-        return (this.length);
-
-    }
-
-
-    /**
-     * Return the String we are currently parsing.
-     */
-    public String getString() {
-
-        return (this.string);
-
-    }
-
-
-    /**
-     * Set the String we are currently parsing.  The parser state is also reset
-     * to begin at the start of this string.
-     *
-     * @param string The string to be parsed.
-     */
-    public void setString(String string) {
-
-        this.string = string;
-        if (string != null) {
-            this.length = string.length();
-            chars = this.string.toCharArray();
-        } else {
-            this.length = 0;
-            chars = new char[0];
-        }
-        reset();
-
-    }
-
-
-    // --------------------------------------------------------- Public Methods
-
-
-    /**
-     * Advance the current parsing position by one, if we are not already
-     * past the end of the string.
-     */
-    public void advance() {
-
-        if (index < length)
-            index++;
-
-    }
-
-
-    /**
-     * Extract and return a substring that starts at the specified position,
-     * and extends to the end of the string being parsed.  If this is not
-     * possible, a zero-length string is returned.
-     *
-     * @param start Starting index, zero relative, inclusive
-     */
-    public String extract(int start) {
-
-        if ((start < 0) || (start >= length))
-            return ("");
-        else
-            return (string.substring(start));
-
-    }
-
-
-    /**
-     * Extract and return a substring that starts at the specified position,
-     * and ends at the character before the specified position.  If this is
-     * not possible, a zero-length string is returned.
-     *
-     * @param start Starting index, zero relative, inclusive
-     * @param end Ending index, zero relative, exclusive
-     */
-    public String extract(int start, int end) {
-
-        if ((start < 0) || (start >= end) || (end > length))
-            return ("");
-        else
-            return (string.substring(start, end));
-
-    }
-
-
-    /**
-     * Return the index of the next occurrence of the specified character,
-     * or the index of the character after the last position of the string
-     * if no more occurrences of this character are found.  The current
-     * parsing position is updated to the returned value.
-     *
-     * @param ch Character to be found
-     */
-    public int findChar(char ch) {
-
-        while ((index < length) && (ch != chars[index]))
-            index++;
-        return (index);
-
-    }
-
-
-    /**
-     * Return the index of the next occurrence of a non-whitespace character,
-     * or the index of the character after the last position of the string
-     * if no more non-whitespace characters are found.  The current
-     * parsing position is updated to the returned value.
-     */
-    public int findText() {
-
-        while ((index < length) && isWhite(chars[index]))
-            index++;
-        return (index);
-
-    }
-
-
-    /**
-     * Return the index of the next occurrence of a whitespace character,
-     * or the index of the character after the last position of the string
-     * if no more whitespace characters are found.  The current parsing
-     * position is updated to the returned value.
-     */
-    public int findWhite() {
-
-        while ((index < length) && !isWhite(chars[index]))
-            index++;
-        return (index);
-
-    }
-
-
-    /**
-     * Reset the current state of the parser to the beginning of the
-     * current string being parsed.
-     */
-    public void reset() {
-
-        index = 0;
-
-    }
-
-
-    /**
-     * Advance the current parsing position while it is pointing at the
-     * specified character, or until it moves past the end of the string.
-     * Return the final value.
-     *
-     * @param ch Character to be skipped
-     */
-    public int skipChar(char ch) {
-
-        while ((index < length) && (ch == chars[index]))
-            index++;
-        return (index);
-
-    }
-
-
-    /**
-     * Advance the current parsing position while it is pointing at a
-     * non-whitespace character, or until it moves past the end of the string.
-     * Return the final value.
-     */
-    public int skipText() {
-
-        while ((index < length) && !isWhite(chars[index]))
-            index++;
-        return (index);
-
-    }
-
-
-    /**
-     * Advance the current parsing position while it is pointing at a
-     * whitespace character, or until it moves past the end of the string.
-     * Return the final value.
-     */
-    public int skipWhite() {
-
-        while ((index < length) && isWhite(chars[index]))
-            index++;
-        return (index);
-
-    }
-
-
-    // ------------------------------------------------------ Protected Methods
-
-
-    /**
-     * Is the specified character considered to be whitespace?
-     *
-     * @param ch Character to be checked
-     */
-    protected boolean isWhite(char ch) {
-
-        if ((ch == ' ') || (ch == '\t') || (ch == '\r') || (ch == '\n'))
-            return (true);
-        else
-            return (false);
-
-    }
-
-
-}

==================================================
Range.java
deleted file mode 100644
index 11828ba739..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/util/MimeMap.java
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.lite.util;
-
-import java.net.FileNameMap;
-import java.util.Enumeration;
-import java.util.Hashtable;
-
-
-/**
- * A mime type map that implements the java.net.FileNameMap interface.
- *
- * @author James Duncan Davidson [duncan@eng.sun.com]
- * @author Jason Hunter [jch@eng.sun.com]
- */
-public class MimeMap implements FileNameMap {
-
-    // Defaults - all of them are "well-known" types,
-    // you can add using normal web.xml.
-
-    public static Hashtable<String,String> defaultMap =
-        new Hashtable<String,String>(101);
-    static {
-        defaultMap.put("txt", "text/plain");
-        defaultMap.put("css", "text/css");
-        defaultMap.put("html","text/html");
-        defaultMap.put("htm", "text/html");
-        defaultMap.put("gif", "image/gif");
-        defaultMap.put("jpg", "image/jpeg");
-        defaultMap.put("jpe", "image/jpeg");
-        defaultMap.put("jpeg", "image/jpeg");
-        defaultMap.put("png", "image/png");
-                defaultMap.put("java", "text/plain");
-        defaultMap.put("body", "text/html");
-        defaultMap.put("rtx", "text/richtext");
-        defaultMap.put("tsv", "text/tab-separated-values");
-        defaultMap.put("etx", "text/x-setext");
-        defaultMap.put("ps", "application/x-postscript");
-        defaultMap.put("class", "application/java");
-        defaultMap.put("csh", "application/x-csh");
-        defaultMap.put("sh", "application/x-sh");
-        defaultMap.put("tcl", "application/x-tcl");
-        defaultMap.put("tex", "application/x-tex");
-        defaultMap.put("texinfo", "application/x-texinfo");
-        defaultMap.put("texi", "application/x-texinfo");
-        defaultMap.put("t", "application/x-troff");
-        defaultMap.put("tr", "application/x-troff");
-        defaultMap.put("roff", "application/x-troff");
-        defaultMap.put("man", "application/x-troff-man");
-        defaultMap.put("me", "application/x-troff-me");
-        defaultMap.put("ms", "application/x-wais-source");
-        defaultMap.put("src", "application/x-wais-source");
-        defaultMap.put("zip", "application/zip");
-        defaultMap.put("bcpio", "application/x-bcpio");
-        defaultMap.put("cpio", "application/x-cpio");
-        defaultMap.put("gtar", "application/x-gtar");
-        defaultMap.put("shar", "application/x-shar");
-        defaultMap.put("sv4cpio", "application/x-sv4cpio");
-        defaultMap.put("sv4crc", "application/x-sv4crc");
-        defaultMap.put("tar", "application/x-tar");
-        defaultMap.put("ustar", "application/x-ustar");
-        defaultMap.put("dvi", "application/x-dvi");
-        defaultMap.put("hdf", "application/x-hdf");
-        defaultMap.put("latex", "application/x-latex");
-        defaultMap.put("bin", "application/octet-stream");
-        defaultMap.put("oda", "application/oda");
-        defaultMap.put("pdf", "application/pdf");
-        defaultMap.put("ps", "application/postscript");
-        defaultMap.put("eps", "application/postscript");
-        defaultMap.put("ai", "application/postscript");
-        defaultMap.put("rtf", "application/rtf");
-        defaultMap.put("nc", "application/x-netcdf");
-        defaultMap.put("cdf", "application/x-netcdf");
-        defaultMap.put("cer", "application/x-x509-ca-cert");
-        defaultMap.put("exe", "application/octet-stream");
-        defaultMap.put("gz", "application/x-gzip");
-        defaultMap.put("Z", "application/x-compress");
-        defaultMap.put("z", "application/x-compress");
-        defaultMap.put("hqx", "application/mac-binhex40");
-        defaultMap.put("mif", "application/x-mif");
-        defaultMap.put("ief", "image/ief");
-        defaultMap.put("tiff", "image/tiff");
-        defaultMap.put("tif", "image/tiff");
-        defaultMap.put("ras", "image/x-cmu-raster");
-        defaultMap.put("pnm", "image/x-portable-anymap");
-        defaultMap.put("pbm", "image/x-portable-bitmap");
-        defaultMap.put("pgm", "image/x-portable-graymap");
-        defaultMap.put("ppm", "image/x-portable-pixmap");
-        defaultMap.put("rgb", "image/x-rgb");
-        defaultMap.put("xbm", "image/x-xbitmap");
-        defaultMap.put("xpm", "image/x-xpixmap");
-        defaultMap.put("xwd", "image/x-xwindowdump");
-        defaultMap.put("au", "audio/basic");
-        defaultMap.put("snd", "audio/basic");
-        defaultMap.put("aif", "audio/x-aiff");
-        defaultMap.put("aiff", "audio/x-aiff");
-        defaultMap.put("aifc", "audio/x-aiff");
-        defaultMap.put("wav", "audio/x-wav");
-        defaultMap.put("mpeg", "video/mpeg");
-        defaultMap.put("mpg", "video/mpeg");
-        defaultMap.put("mpe", "video/mpeg");
-        defaultMap.put("qt", "video/quicktime");
-        defaultMap.put("mov", "video/quicktime");
-        defaultMap.put("avi", "video/x-msvideo");
-        defaultMap.put("movie", "video/x-sgi-movie");
-        defaultMap.put("avx", "video/x-rad-screenplay");
-        defaultMap.put("wrl", "x-world/x-vrml");
-        defaultMap.put("mpv2", "video/mpeg2");
-
-        /* Add XML related MIMEs */
-
-        defaultMap.put("xml", "text/xml");
-        defaultMap.put("xsl", "text/xml");
-        defaultMap.put("svg", "image/svg+xml");
-        defaultMap.put("svgz", "image/svg+xml");
-        defaultMap.put("wbmp", "image/vnd.wap.wbmp");
-        defaultMap.put("wml", "text/vnd.wap.wml");
-        defaultMap.put("wmlc", "application/vnd.wap.wmlc");
-        defaultMap.put("wmls", "text/vnd.wap.wmlscript");
-        defaultMap.put("wmlscriptc", "application/vnd.wap.wmlscriptc");
-    }
-
-
-    private Hashtable<String,String> map = new Hashtable<String,String>();
-
-    public void addContentType(String extn, String type) {
-        map.put(extn, type.toLowerCase());
-    }
-
-    public Enumeration getExtensions() {
-        return map.keys();
-    }
-
-    public String getMimeType(String ext) {
-        return getContentTypeFor(ext);
-    }
-
-    public String getContentType(String extn) {
-        String type = (String)map.get(extn.toLowerCase());
-        if( type == null ) type=(String)defaultMap.get( extn );
-        return type;
-    }
-
-    public void removeContentType(String extn) {
-        map.remove(extn.toLowerCase());
-    }
-
-    /** Get extension of file, without fragment id
-     */
-    public static String getExtension( String fileName ) {
-        // play it safe and get rid of any fragment id
-        // that might be there
-        int length=fileName.length();
-
-        int newEnd = fileName.lastIndexOf('#');
-        if( newEnd== -1 ) newEnd=length;
-        // Instead of creating a new string.
-        //         if (i != -1) {
-        //             fileName = fileName.substring(0, i);
-        //         }
-        int i = fileName.lastIndexOf('.', newEnd );
-        if (i != -1) {
-             return  fileName.substring(i + 1, newEnd );
-        } else {
-            // no extension, no content type
-            return null;
-        }
-    }
-
-    public String getContentTypeFor(String fileName) {
-        String extn=getExtension( fileName );
-        if (extn!=null) {
-            return getContentType(extn);
-        } else {
-            // no extension, no content type
-            return null;
-        }
-    }
-
-}

==================================================
URLEncoder.java
deleted file mode 100644
index 210a8277fc..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/util/Range.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.lite.util;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.StringTokenizer;
-
-/**
- * Utils to process HTTP/1.1 ranges. Used by default servlet, could
- * be used by any servlet that needs to deal with ranges.
- *
- * It is very good to support ranges if you have large content. In most
- * cases supporting one range is enough - getting multiple ranges doesn't
- * seem very common, and it's complex (multipart response).
- *
- * @author Costin Manolache
- * @author Remy Maucherat
- * @author - see DefaultServlet in Catalin for other contributors
- */
-public class Range {
-
-    public long start;
-    public long end;
-    public long length;
-
-    /**
-     * Validate range.
-     */
-    public boolean validate() {
-        if (end >= length)
-            end = length - 1;
-        return ( (start >= 0) && (end >= 0) && (start <= end)
-                 && (length > 0) );
-    }
-
-    public void recycle() {
-        start = 0;
-        end = 0;
-        length = 0;
-    }
-
-    /** Parse ranges.
-     *
-     * @return null if the range is invalid or can't be parsed
-     */
-    public static ArrayList parseRanges(long fileLength,
-                                        String rangeHeader) throws IOException {
-        ArrayList result = new ArrayList();
-        StringTokenizer commaTokenizer = new StringTokenizer(rangeHeader, ",");
-
-        // Parsing the range list
-        while (commaTokenizer.hasMoreTokens()) {
-            String rangeDefinition = commaTokenizer.nextToken().trim();
-
-            Range currentRange = new Range();
-            currentRange.length = fileLength;
-
-            int dashPos = rangeDefinition.indexOf('-');
-
-            if (dashPos == -1) {
-                return null;
-            }
-
-            if (dashPos == 0) {
-                try {
-                    long offset = Long.parseLong(rangeDefinition);
-                    currentRange.start = fileLength + offset;
-                    currentRange.end = fileLength - 1;
-                } catch (NumberFormatException e) {
-                    return null;
-                }
-            } else {
-
-                try {
-                    currentRange.start = Long.parseLong
-                        (rangeDefinition.substring(0, dashPos));
-                    if (dashPos < rangeDefinition.length() - 1)
-                        currentRange.end = Long.parseLong
-                            (rangeDefinition.substring
-                             (dashPos + 1, rangeDefinition.length()));
-                    else
-                        currentRange.end = fileLength - 1;
-                } catch (NumberFormatException e) {
-                    return null;
-                }
-
-            }
-            if (!currentRange.validate()) {
-                return null;
-            }
-            result.add(currentRange);
-        }
-        return result;
-    }
-
-
-    /**
-     * Parse the Content-Range header. Used with PUT or in response.
-     *
-     * @return Range
-     */
-    public static Range parseContentRange(String rangeHeader)
-            throws IOException {
-        if (rangeHeader == null)
-            return null;
-
-        // bytes is the only range unit supported
-        if (!rangeHeader.startsWith("bytes")) {
-            return null;
-        }
-
-        rangeHeader = rangeHeader.substring(6).trim();
-
-        int dashPos = rangeHeader.indexOf('-');
-        int slashPos = rangeHeader.indexOf('/');
-
-        if (dashPos == -1) {
-            return null;
-        }
-
-        if (slashPos == -1) {
-            return null;
-        }
-
-        Range range = new Range();
-
-        try {
-            range.start = Long.parseLong(rangeHeader.substring(0, dashPos));
-            range.end =
-                Long.parseLong(rangeHeader.substring(dashPos + 1, slashPos));
-            range.length = Long.parseLong
-                (rangeHeader.substring(slashPos + 1, rangeHeader.length()));
-        } catch (NumberFormatException e) {
-            return null;
-        }
-
-        if (!range.validate()) {
-            return null;
-        }
-
-        return range;
-    }
-
-}
\ No newline at end of file

==================================================
UrlUtils.java
deleted file mode 100644
index f946e56456..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/lite/util/URLEncoder.java
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.lite.util;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.OutputStreamWriter;
-import java.io.UnsupportedEncodingException;
-import java.util.BitSet;
-
-/**
- *
- * This class is very similar to the java.net.URLEncoder class.
- *
- * Unfortunately, with java.net.URLEncoder there is no way to specify to the
- * java.net.URLEncoder which characters should NOT be encoded.
- *
- * This code was moved from DefaultServlet.java
- *
- * @author Craig R. McClanahan
- * @author Remy Maucherat
- */
-public class URLEncoder {
-    protected static final char[] hexadecimal =
-    {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
-     'A', 'B', 'C', 'D', 'E', 'F'};
-
-    //Array containing the safe characters set.
-    protected BitSet safeChars = new BitSet(128);
-
-    public URLEncoder() {
-        for (char i = 'a'; i <= 'z'; i++) {
-            addSafeCharacter(i);
-        }
-        for (char i = 'A'; i <= 'Z'; i++) {
-            addSafeCharacter(i);
-        }
-        for (char i = '0'; i <= '9'; i++) {
-            addSafeCharacter(i);
-        }
-        //safe
-        safeChars.set('$');
-        safeChars.set('-');
-        safeChars.set('_');
-        safeChars.set('.');
-
-        // Dangerous: someone may treat this as " "
-        // RFC1738 does allow it, it's not reserved
-        //    safeChars.set('+');
-        //extra
-        safeChars.set('!');
-        safeChars.set('*');
-        safeChars.set('\'');
-        safeChars.set('(');
-        safeChars.set(')');
-        safeChars.set(',');
-    }
-
-    public void addSafeCharacter( char c ) {
-        safeChars.set( c );
-    }
-
-    public String encodeURL(String path) {
-        return encodeURL(path, "UTF-8", true);
-    }
-
-    public String encodeURL(String path, String enc, boolean allowSlash) {
-        int maxBytesPerChar = 10;
-
-        StringBuffer rewrittenPath = new StringBuffer(path.length());
-        ByteArrayOutputStream buf = new ByteArrayOutputStream(maxBytesPerChar);
-        OutputStreamWriter writer = null;
-        try {
-            writer = new OutputStreamWriter(buf, enc);
-        } catch (UnsupportedEncodingException e1) {
-            // shouldn't happen.
-        }
-
-        for (int i = 0; i < path.length(); i++) {
-            int c = (int) path.charAt(i);
-            if (c < 128 && safeChars.get(c) || allowSlash && c == '/') {
-                rewrittenPath.append((char)c);
-            } else {
-                // convert to external encoding before hex conversion
-                try {
-                    writer.write((char)c);
-                    if (c >= 0xD800 && c <= 0xDBFF) {
-                        if ( (i+1) < path.length()) {
-                            int d = path.charAt(i+1);
-                            if (d >= 0xDC00 && d <= 0xDFFF) {
-                                writer.write((char) d);
-                                i++;
-                            }
-                        }
-                    }
-                    writer.flush();
-                } catch(IOException e) {
-                    buf.reset();
-                    continue;
-                }
-                byte[] ba = buf.toByteArray();
-                for (int j = 0; j < ba.length; j++) {
-                    // Converting each byte in the buffer
-                    byte toEncode = ba[j];
-                    rewrittenPath.append('%');
-                    int low = (int) (toEncode & 0x0f);
-                    int high = (int) ((toEncode & 0xf0) >> 4);
-                    rewrittenPath.append(hexadecimal[high]);
-                    rewrittenPath.append(hexadecimal[low]);
-                }
-                buf.reset();
-            }
-        }
-        return rewrittenPath.toString();
-    }
-
-    /**
-     * Decode and return the specified URL-encoded String.
-     *
-     * @param str The url-encoded string
-     * @param enc The encoding to use; if null, the default encoding is used
-     * @exception IllegalArgumentException if a '%' character is not followed
-     * by a valid 2-digit hexadecimal number
-     */
-    public static String URLDecode(String str, String enc) {
-
-        if (str == null)
-            return (null);
-
-        // use the specified encoding to extract bytes out of the
-        // given string so that the encoding is not lost. If an
-        // encoding is not specified, let it use platform default
-        byte[] bytes = null;
-        try {
-            if (enc == null) {
-                bytes = str.getBytes();
-            } else {
-                bytes = str.getBytes(enc);
-            }
-        } catch (UnsupportedEncodingException uee) {}
-
-        return URLDecode(bytes, enc);
-
-    }
-
-
-    /**
-     * Decode and return the specified URL-encoded String.
-     * When the byte array is converted to a string, the system default
-     * character encoding is used...  This may be different than some other
-     * servers.
-     *
-     * @param str The url-encoded string
-     *
-     * @exception IllegalArgumentException if a '%' character is not followed
-     * by a valid 2-digit hexadecimal number
-     */
-    public static String URLDecode(String str) {
-
-        return URLDecode(str, null);
-
-    }
-
-    /**
-     * Decode and return the specified URL-encoded byte array.
-     *
-     * @param bytes The url-encoded byte array
-     * @param enc The encoding to use; if null, the default encoding is used
-     * @exception IllegalArgumentException if a '%' character is not followed
-     * by a valid 2-digit hexadecimal number
-     */
-    private static String URLDecode(byte[] bytes, String enc) {
-
-        if (bytes == null)
-            return (null);
-
-        int len = bytes.length;
-        int ix = 0;
-        int ox = 0;
-        while (ix < len) {
-            byte b = bytes[ix++];     // Get byte to test
-            if (b == '+') {
-                b = (byte)' ';
-            } else if (b == '%') {
-                b = (byte) ((convertHexDigit(bytes[ix++]) << 4)
-                            + convertHexDigit(bytes[ix++]));
-            }
-            bytes[ox++] = b;
-        }
-        if (enc != null) {
-            try {
-                return new String(bytes, 0, ox, enc);
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-        }
-        return new String(bytes, 0, ox);
-
-    }
-
-    /**
-     * Convert a byte character value to hexidecimal digit value.
-     *
-     * @param b the character value byte
-     */
-    private static byte convertHexDigit( byte b ) {
-        if ((b >= '0') && (b <= '9')) return (byte)(b - '0');
-        if ((b >= 'a') && (b <= 'f')) return (byte)(b - 'a' + 10);
-        if ((b >= 'A') && (b <= 'F')) return (byte)(b - 'A' + 10);
-        return 0;
-    }
-
-}

==================================================
ServletTests.java
deleted file mode 100644
index 742ae8dfd1..0000000000
--- a/modules/tomcat-lite/pom.xml
+++ /dev/null
@@ -1,118 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <groupId>org.apache.tomcat.lite</groupId>
-  <artifactId>lite</artifactId>
-
-  <version>0.0.1-SNAPSHOT</version>
-
-  <dependencies>
-        <dependency>
-                <groupId>com.jcraft</groupId>
-                <artifactId>jzlib</artifactId>
-                <version>1.0.7</version>
-                <type>jar</type>
-                <scope>compile</scope>
-        </dependency>
-        <dependency>
-                <groupId>javax.servlet</groupId>
-                <artifactId>servlet-api</artifactId>
-                <version>2.5</version>
-        </dependency>
-        <dependency>
-                <groupId>junit</groupId>
-                <artifactId>junit</artifactId>
-                <version>3.8.2</version>
-                <type>jar</type>
-                <scope>compile</scope>
-        </dependency>
-        <dependency>
-                <groupId>commons-codec</groupId>
-                <artifactId>commons-codec</artifactId>
-                <version>1.4</version>
-                <type>jar</type>
-                <scope>compile</scope>
-        </dependency>
-        <dependency>
-                <groupId>org.apache.tomcat</groupId>
-                <artifactId>jasper</artifactId>
-                <version>6.0.20</version>
-                <type>jar</type>
-                <scope>compile</scope>
-        </dependency>
-        <dependency>
-                <groupId>org.apache.tomcat</groupId>
-                <artifactId>jasper-jdt</artifactId>
-                <version>6.0.20</version>
-                <type>jar</type>
-                <scope>compile</scope>
-        </dependency>
-        <dependency>
-                <groupId>org.apache.tomcat</groupId>
-                <artifactId>jasper-el</artifactId>
-                <version>6.0.20</version>
-                <type>jar</type>
-                <scope>compile</scope>
-        </dependency>
-        <dependency>
-                <groupId>asm</groupId>
-                <artifactId>asm</artifactId>
-                <version>3.1</version>
-                <type>jar</type>
-                <scope>compile</scope>
-        </dependency>
-        <dependency>
-                <groupId>asm</groupId>
-                <artifactId>asm-tree</artifactId>
-                <version>3.1</version>
-                <type>jar</type>
-                <scope>compile</scope>
-        </dependency>
-        <dependency>
-        	<groupId>org.apache.tomcat</groupId>
-        	<artifactId>coyote</artifactId>
-        	<version>6.0.20</version>
-        </dependency>
-        <dependency>
-        	<groupId>org.apache.ant</groupId>
-        	<artifactId>ant</artifactId>
-        	<version>1.7.1</version>
-        </dependency>
-  </dependencies>
-
-   <build>
-
-    <sourceDirectory>java</sourceDirectory>
-
-    <testSourceDirectory>test</testSourceDirectory>
-
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <configuration>
-          <source>1.6</source>
-          <target>1.6</target>
-          <excludes>
-            <exclude>org/apache/coyote/servlet/**</exclude>
-            <exclude>**/ServletApi30.java</exclude>
-          </excludes>
-          <testExcludes>
-            <exclude>org/apache/coyote/servlet/**</exclude>
-            <exclude>**/ServletApi30.java</exclude>
-          </testExcludes>
-        </configuration>
-      </plugin>
-    </plugins>
-
-    <testResources>
-      <testResource>
-        <directory>test</directory>
-        <excludes>
-          <exclude>**/*.java</exclude>
-        </excludes>
-       </testResource>
-   </testResources>
-
-  </build>
-</project>

==================================================
Tomcat.java
deleted file mode 100644
index 71b6bce411..0000000000
--- a/modules/tomcat-lite/test/org/apache/coyote/lite/ServletTests.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- */
-package org.apache.coyote.lite;
-
-import java.io.File;
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-
-import org.apache.catalina.LifecycleException;
-import org.apache.tomcat.test.watchdog.WatchdogClient;
-
-import junit.framework.Test;
-
-/**
- * Wrapper to run watchdog.
- *
- */
-public class ServletTests extends WatchdogClient {
-
-
-    public ServletTests() {
-        super();
-        goldenDir = getWatchdogdir() + "/src/clients/org/apache/jcheck/servlet/client/";
-        testMatch =
-            //"HttpServletResponseWrapperSetStatusMsgTest";
-            //"ServletContextAttributeAddedEventTest";
-            null;
-            // ex: "ServletToJSP";
-        file = getWatchdogdir() + "/src/conf/servlet-gtest.xml";
-        targetMatch = "gtestservlet-test";
-
-        port = 8883;
-        exclude = new String[] {
-                "DoInit1Test", // tomcat returns 404 if perm. unavailable
-                "HttpServletDoInit1Test",
-                "GetMajorVersionTest", // tomcat7
-                "GetMinorVersionTest",
-                "ServletToJSPErrorPageTest",
-                "ServletToJSPError502PageTest",
-        };
-    }
-
-    public ServletTests(String name) {
-       this();
-       super.single = name;
-       port = 8883;
-    }
-
-    protected void beforeSuite() {
-        // required for the tests
-        System.setProperty("org.apache.coyote.USE_CUSTOM_STATUS_MSG_IN_HEADER",
-                "true");
-
-        try {
-            initServerWithWatchdog(getWatchdogdir());
-        } catch (ServletException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        } catch (IOException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        }
-    }
-
-    public void initServerWithWatchdog(String wdDir) throws ServletException,
-            IOException {
-        Tomcat tomcat = new Tomcat();
-        tomcat.setPort(port);
-
-        File f = new File(wdDir + "/build/webapps");
-        tomcat.setBaseDir(f.getAbsolutePath());
-
-        for (String s : new String[] {
-                "servlet-compat",
-                "servlet-tests",
-                "jsp-tests"} ) {
-            tomcat.addWebapp("/" + s, f.getCanonicalPath() + "/" + s);
-        }
-
-        TomcatStandaloneMain.setUp(tomcat, port);
-
-        try {
-            tomcat.start();
-        } catch (LifecycleException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        }
-        System.err.println("Init done");
-    }
-
-    /**
-     * Magic JUnit method
-     */
-    public static Test suite() {
-        return new ServletTests().getSuite();
-    }
-}

==================================================
TomcatLiteCoyoteTest.java
deleted file mode 100644
index ae723450fb..0000000000
--- a/modules/tomcat-lite/test/org/apache/coyote/lite/Tomcat.java
+++ /dev/null
@@ -1,911 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.coyote.lite;
-
-import java.io.File;
-import java.io.IOException;
-import java.security.Principal;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import javax.servlet.Servlet;
-import javax.servlet.ServletException;
-
-import org.apache.catalina.Container;
-import org.apache.catalina.Context;
-import org.apache.catalina.Lifecycle;
-import org.apache.catalina.LifecycleEvent;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.LifecycleListener;
-import org.apache.catalina.Realm;
-import org.apache.catalina.connector.Connector;
-import org.apache.catalina.core.StandardContext;
-import org.apache.catalina.core.StandardEngine;
-import org.apache.catalina.core.StandardHost;
-import org.apache.catalina.core.StandardServer;
-import org.apache.catalina.core.StandardService;
-import org.apache.catalina.core.StandardWrapper;
-import org.apache.catalina.realm.RealmBase;
-import org.apache.catalina.session.StandardManager;
-import org.apache.catalina.startup.ContextConfig;
-
-// This class is here for compat with Tomcat6.
-
-// TODO: lazy init for the temp dir - only when a JSP is compiled or
-// get temp dir is called we need to create it. This will avoid the
-// need for the baseDir
-
-// TODO: allow contexts without a base dir - i.e.
-// only programmatic. This would disable the default servlet.
-
-/**
- * Minimal tomcat starter for embedding/unit tests.
- *
- * Tomcat supports multiple styles of configuration and
- * startup - the most common and stable is server.xml-based,
- * implemented in org.apache.catalina.startup.Bootstrap.
- *
- * This class is for use in apps that embed tomcat.
- * Requirements:
- *
- * - all tomcat classes and possibly servlets are in the classpath.
- * ( for example all is in one big jar, or in eclipse CP, or in any other
- * combination )
- *
- * - we need one temporary directory for work files
- *
- * - no config file is required. This class provides methods to
- * use if you have a webapp with a web.xml file, but it is
- * optional - you can use your own servlets.
- *
- * This class provides a main() and few simple CLI arguments,
- * see setters for doc. It can be used for simple tests and
- * demo.
- *
- * @see TestTomcat for examples on how to use this
- * @author Costin Manolache
- */
-public class Tomcat {
-    // Single engine, service, server, connector - few cases need more,
-    // they can use server.xml
-    protected StandardServer server;
-    protected StandardService service;
-    protected StandardEngine engine;
-    protected Connector connector; // for more - customize the classes
-
-    boolean started = false;
-    // To make it a bit easier to config for the common case
-    // ( one host, one context ).
-    protected StandardHost host;
-
-    // TODO: it's easy to add support for more hosts - but is it
-    // really needed ?
-
-    // TODO: allow use of in-memory connector
-
-    protected int port = 8080;
-    protected String hostname = "localhost";
-    protected String basedir;
-
-    // Default in-memory realm, will be set by default on
-    // created contexts. Can be replaced with setRealm() on
-    // the context.
-    protected Realm defaultRealm;
-    private Map<String, String> userPass = new HashMap<String, String>();
-    private Map<String, List<String>> userRoles =
-            new HashMap<String, List<String>>();
-    private Map<String, Principal> userPrincipals = new HashMap<String, Principal>();
-
-    public Tomcat() {
-        // NOOP
-    }
-
-    /**
-     * Tomcat needs a directory for temp files. This should be the
-     * first method called.
-     *
-     * By default, if this method is not called, we use:
-     *  - system properties - catalina.base, catalina.home
-     *  - $HOME/tomcat.$PORT
-     * ( /tmp doesn't seem a good choice for security ).
-     *
-     *
-     * TODO: better default ? Maybe current dir ?
-     * TODO: disable work dir if not needed ( no jsp, etc ).
-     */
-    public void setBaseDir(String basedir) {
-        this.basedir = basedir;
-    }
-
-    /**
-     * Set the port for the default connector. Must
-     * be called before start().
-     */
-    public void setPort(int port) {
-        this.port = port;
-    }
-
-    /**
-     * The the hostname of the default host, default is
-     * 'localhost'.
-     */
-    public void setHostname(String s) {
-        hostname = s;
-    }
-
-    /**
-     * Add a webapp using normal WEB-INF/web.xml if found.
-     *
-     * @param contextPath
-     * @param baseDir
-     * @return new StandardContext
-     * @throws ServletException
-     */
-    public StandardContext addWebapp(String contextPath,
-                                     String baseDir) throws ServletException {
-
-        return addWebapp(getHost(), contextPath, baseDir);
-    }
-
-
-    /**
-     * Add a context - programmatic mode, no web.xml used.
-     *
-     * API calls equivalent with web.xml:
-     *
-     * context-param
-     *  ctx.addParameter("name", "value");
-     *
-     *
-     * error-page
-     *    ErrorPage ep = new ErrorPage();
-     *    ep.setErrorCode(500);
-     *    ep.setLocation("/error.html");
-     *    ctx.addErrorPage(ep);
-     *
-     * ctx.addMimeMapping("ext", "type");
-     *
-     * Note: If you reload the Context, all your configuration will be lost. If
-     * you need reload support, consider using a LifecycleListener to provide
-     * your configuration.
-     *
-     * TODO: add the rest
-     *
-     *  @param contextPath "/" for root context.
-     *  @param baseDir base dir for the context, for static files. Must exist,
-     *  relative to the server home
-     */
-    public StandardContext addContext(String contextPath,
-                                      String baseDir) {
-        return addContext(getHost(), contextPath, baseDir);
-    }
-
-    /**
-     * Equivalent with
-     *  <servlet><servlet-name><servlet-class>.
-     *
-     * In general it is better/faster to use the method that takes a
-     * Servlet as param - this one can be used if the servlet is not
-     * commonly used, and want to avoid loading all deps.
-     * ( for example: jsp servlet )
-     *
-     * You can customize the returned servlet, ex:
-     *
-     *    wrapper.addInitParameter("name", "value");
-     *
-     * @param contextPath   Context to add Servlet to
-     * @param servletName   Servlet name (used in mappings)
-     * @param servletClass  The class to be used for the Servlet
-     * @return The wrapper for the servlet
-     */
-    public StandardWrapper addServlet(String contextPath,
-            String servletName,
-            String servletClass) {
-        Container ctx = getHost().findChild(contextPath);
-        return addServlet((StandardContext) ctx,
-                servletName, servletClass);
-    }
-
-    /**
-     * Static version of {@link #addServlet(String, String, String)}
-     * @param ctx           Context to add Servlet to
-     * @param servletName   Servlet name (used in mappings)
-     * @param servletClass  The class to be used for the Servlet
-     * @return The wrapper for the servlet
-     */
-    public static StandardWrapper addServlet(StandardContext ctx,
-                                      String servletName,
-                                      String servletClass) {
-        // will do class for name and set init params
-        StandardWrapper sw = (StandardWrapper)ctx.createWrapper();
-        sw.setServletClass(servletClass);
-        sw.setName(servletName);
-        ctx.addChild(sw);
-
-        return sw;
-    }
-
-    /**
-     * Add an existing Servlet to the context with no class.forName or
-     * initialisation.
-     * @param contextPath   Context to add Servlet to
-     * @param servletName   Servlet name (used in mappings)
-     * @param servlet       The Servlet to add
-     * @return The wrapper for the servlet
-     */
-    public StandardWrapper addServlet(String contextPath,
-            String servletName,
-            Servlet servlet) {
-        Container ctx = getHost().findChild(contextPath);
-        return addServlet((StandardContext) ctx,
-                servletName, servlet);
-    }
-
-    /**
-     * Static version of {@link #addServlet(String, String, Servlet)}.
-     * @param ctx           Context to add Servlet to
-     * @param servletName   Servlet name (used in mappings)
-     * @param servlet       The Servlet to add
-     * @return The wrapper for the servlet
-     */
-    public static StandardWrapper addServlet(StandardContext ctx,
-                                      String servletName,
-                                      Servlet servlet) {
-        // will do class for name and set init params
-        StandardWrapper sw = new ExistingStandardWrapper(servlet);
-        sw.setName(servletName);
-        ctx.addChild(sw);
-
-        return sw;
-    }
-
-
-    /**
-     * Initialize and start the server.
-     * @throws LifecycleException
-     */
-    public void start() throws LifecycleException {
-        if (started) {
-            return;
-        }
-        started = true;
-        getServer();
-        getConnector();
-        server.start();
-    }
-
-    /**
-     * Stop the server.
-     * @throws LifecycleException
-     */
-    public void stop() throws LifecycleException {
-        getServer().stop();
-    }
-
-
-    /**
-     * Add a user for the in-memory realm. All created apps use this
-     * by default, can be replaced using setRealm().
-     *
-     */
-    public void addUser(String user, String pass) {
-        userPass.put(user, pass);
-    }
-
-    /**
-     * @see #addUser(String, String)
-     */
-    public void addRole(String user, String role) {
-        List<String> roles = userRoles.get(user);
-        if (roles == null) {
-            roles = new ArrayList<String>();
-            userRoles.put(user, roles);
-        }
-        roles.add(role);
-    }
-
-    // ------- Extra customization -------
-    // You can tune individual tomcat objects, using internal APIs
-
-    /**
-     * Get the default http connector. You can set more
-     * parameters - the port is already initialized.
-     *
-     * Alternatively, you can construct a Connector and set any params,
-     * then call addConnector(Connector)
-     *
-     * @return A connector object that can be customized
-     */
-    public Connector getConnector() {
-        getServer();
-        if (connector != null) {
-            return connector;
-        }
-        // This will load Apr connector if available,
-        // default to nio. I'm having strange problems with apr
-        // and for the use case the speed benefit wouldn't matter.
-
-        //connector = new Connector("HTTP/1.1");
-        try {
-            connector = new Connector("org.apache.coyote.http11.Http11Protocol");
-            connector.setPort(port);
-            service.addConnector( connector );
-        } catch (Exception e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        }
-        return connector;
-    }
-
-    public void setConnector(Connector connector) {
-        this.connector = connector;
-    }
-
-    /**
-     * Get the service object. Can be used to add more
-     * connectors and few other global settings.
-     */
-    public StandardService getService() {
-        getServer();
-        return service;
-    }
-
-    /**
-     * Sets the current host - all future webapps will
-     * be added to this host. When tomcat starts, the
-     * host will be the default host.
-     *
-     * @param host
-     */
-    public void setHost(StandardHost host) {
-        this.host = host;
-    }
-
-    public StandardHost getHost() {
-        if (host == null) {
-            host = new StandardHost();
-            host.setName(hostname);
-
-            getEngine().addChild( host );
-        }
-        return host;
-    }
-
-    /**
-     * Set a custom realm for auth. If not called, a simple
-     * default will be used, using an internal map.
-     *
-     * Must be called before adding a context.
-     */
-    public void setDefaultRealm(Realm realm) {
-        defaultRealm = realm;
-    }
-
-
-    /**
-     * Access to the engine, for further customization.
-     */
-    public StandardEngine getEngine() {
-        if(engine == null ) {
-            getServer();
-            engine = new StandardEngine();
-            engine.setName( "Tomcat" );
-            engine.setDefaultHost(hostname);
-            service.setContainer(engine);
-        }
-        return engine;
-    }
-
-    /**
-     * Get the server object. You can add listeners and few more
-     * customizations. JNDI is disabled by default.
-     */
-    public StandardServer getServer() {
-
-        if (server != null) {
-            return server;
-        }
-
-        initBaseDir();
-
-        System.setProperty("catalina.useNaming", "false");
-
-        server = new StandardServer();
-        server.setPort( -1 );
-
-        service = new StandardService();
-        service.setName("Tomcat");
-        server.addService( service );
-        return server;
-    }
-
-    public StandardContext addContext(StandardHost host,
-                                      String contextPath,
-                                      String dir) {
-        silence(contextPath);
-        StandardContext ctx = new StandardContext();
-        ctx.setPath( contextPath );
-        ctx.setDocBase(dir);
-        ctx.addLifecycleListener(new FixContextListener());
-
-        if (host == null) {
-            getHost().addChild(ctx);
-        } else {
-            host.addChild(ctx);
-        }
-        return ctx;
-    }
-
-    public StandardContext addWebapp(StandardHost host,
-                                     String url, String path) {
-        silence(url);
-
-        StandardContext ctx = new StandardContext();
-        ctx.setPath( url );
-        ctx.setDocBase(path);
-        if (defaultRealm == null) {
-            initSimpleAuth();
-        }
-        ctx.setRealm(defaultRealm);
-        ctx.addLifecycleListener(new DefaultWebXmlListener());
-
-        ContextConfig ctxCfg = new ContextConfig();
-        ctx.addLifecycleListener( ctxCfg );
-        // prevent it from looking ( if it finds one - it'll have dup error )
-        ctxCfg.setDefaultWebXml("org/apache/catalin/startup/NO_DEFAULT_XML");
-
-        if (host == null) {
-            getHost().addChild(ctx);
-        } else {
-            host.addChild(ctx);
-        }
-
-        return ctx;
-    }
-
-
-    // ---------- Helper methods and classes -------------------
-
-    /**
-     * Initialize an in-memory realm. You can replace it
-     * for contexts with a real one.
-     */
-    protected void initSimpleAuth() {
-        defaultRealm = new RealmBase() {
-            @Override
-            protected String getName() {
-                return "Simple";
-            }
-
-            @Override
-            protected String getPassword(String username) {
-                return userPass.get(username);
-            }
-
-            @Override
-            protected Principal getPrincipal(final String username) {
-                Principal p = userPrincipals.get(username);
-                if (p == null) {
-                    String pass = userPass.get(username);
-                    if (pass != null) {
-                        p = new Principal() {
-
-                            @Override
-                            public String getName() {
-                                return username;
-                            }
-
-                        };
-                    }
-                }
-                return p;
-            }
-
-        };
-    }
-
-    protected void initBaseDir() {
-        if (basedir == null) {
-            basedir = System.getProperty("catalina.base");
-        }
-        if (basedir == null) {
-            basedir = System.getProperty("catalina.home");
-        }
-        if (basedir == null) {
-            // Create a temp dir.
-            basedir = System.getProperty("user.dir") +
-                "/tomcat." + port;
-            File home = new File(basedir);
-            home.mkdir();
-            if (!home.isAbsolute()) {
-                try {
-                    basedir = home.getCanonicalPath();
-                } catch (IOException e) {
-                    basedir = home.getAbsolutePath();
-                }
-            }
-        }
-        System.setProperty("catalina.home", basedir);
-        System.setProperty("catalina.base", basedir);
-    }
-
-    static String[] silences = new String[] {
-        "org.apache.coyote.http11.Http11Protocol",
-        "org.apache.catalina.core.StandardService",
-        "org.apache.catalina.core.StandardEngine",
-        "org.apache.catalina.startup.ContextConfig",
-        "org.apache.catalina.core.ApplicationContext",
-        "org.apache.catalina.core.AprLifecycleListener"
-    };
-
-    /**
-     * Controls if the loggers will be silenced or not.
-     * @param silent    <code>true</code> sets the log level to WARN for the
-     *                  loggers that log information on Tomcat start up. This
-     *                  prevents the usual startup information being logged.
-     *                  <code>false</code> sets the log level to the default
-     *                  level of INFO.
-     */
-    public void setSilent(boolean silent) {
-        for (String s : silences) {
-            if (silent) {
-                Logger.getLogger(s).setLevel(Level.WARNING);
-            } else {
-                Logger.getLogger(s).setLevel(Level.INFO);
-            }
-        }
-    }
-
-    private void silence(String ctx) {
-        String base = "org.apache.catalina.core.ContainerBase.[default].[";
-        base += getHost().getName();
-        base += "].[";
-        base += ctx;
-        base += "]";
-        Logger.getLogger(base).setLevel(Level.WARNING);
-    }
-
-    /**
-     * Enables JNDI naming which is disabled by default.
-     */
-    public void enableNaming() {
-        // Make sure getServer() has been called as that is where naming is
-        // disabled
-        getServer();
-
-        System.setProperty("catalina.useNaming", "true");
-        String value = "org.apache.naming";
-        String oldValue =
-            System.getProperty(javax.naming.Context.URL_PKG_PREFIXES);
-        if (oldValue != null) {
-            value = value + ":" + oldValue;
-        }
-        System.setProperty(javax.naming.Context.URL_PKG_PREFIXES, value);
-        value = System.getProperty
-            (javax.naming.Context.INITIAL_CONTEXT_FACTORY);
-        if (value == null) {
-            System.setProperty
-                (javax.naming.Context.INITIAL_CONTEXT_FACTORY,
-                 "org.apache.naming.java.javaURLContextFactory");
-        }
-    }
-
-    /**
-     * Provide default configuration for a context. This is the programmatic
-     * equivalent of the default web.xml.
-     *
-     *  TODO: in normal tomcat, if default-web.xml is not found, use this
-     *  method
-     *
-     * @param contextPath   The context to set the defaults for
-     */
-    public void initWebappDefaults(String contextPath) {
-        Container ctx = getHost().findChild(contextPath);
-        initWebappDefaults((StandardContext) ctx);
-    }
-
-    /**
-     * Static version of {@link #initWebappDefaults(String)}
-     * @param ctx   The context to set the defaults for
-     */
-    public static void initWebappDefaults(StandardContext ctx) {
-        // Default servlet
-        StandardWrapper servlet = addServlet(
-                ctx, "default", "org.apache.catalina.servlets.DefaultServlet");
-        servlet.setLoadOnStartup(1);
-
-        // JSP servlet (by class name - to avoid loading all deps)
-        servlet = addServlet(
-                ctx, "jsp", "org.apache.jasper.servlet.JspServlet");
-        servlet.addInitParameter("fork", "false");
-        servlet.setLoadOnStartup(3);
-
-        // Servlet mappings
-        ctx.addServletMapping("/", "default");
-        ctx.addServletMapping("*.jsp", "jsp");
-        ctx.addServletMapping("*.jspx", "jsp");
-
-        // Sessions
-        ctx.setManager( new StandardManager());
-        ctx.setSessionTimeout(30);
-
-        // MIME mappings
-        for (int i = 0; i < DEFAULT_MIME_MAPPINGS.length; ) {
-            ctx.addMimeMapping(DEFAULT_MIME_MAPPINGS[i++],
-                    DEFAULT_MIME_MAPPINGS[i++]);
-        }
-
-        // Welcome files
-        ctx.addWelcomeFile("index.html");
-        ctx.addWelcomeFile("index.htm");
-        ctx.addWelcomeFile("index.jsp");
-    }
-
-
-    /**
-     * Fix startup sequence - required if you don't use web.xml.
-     *
-     * The start() method in context will set 'configured' to false - and
-     * expects a listener to set it back to true.
-     */
-    public static class FixContextListener implements LifecycleListener {
-
-        public void lifecycleEvent(LifecycleEvent event) {
-            try {
-                Context context = (Context) event.getLifecycle();
-                if (event.getType().equals(Lifecycle.START_EVENT)) {
-                    context.setConfigured(true);
-                }
-            } catch (ClassCastException e) {
-                return;
-            }
-        }
-
-    }
-
-
-    /**
-     * Fix reload - required if reloading and using programmatic configuration.
-     * When a context is reloaded, any programmatic configuration is lost. This
-     * listener sets the equivalent of conf/web.xml when the context starts. The
-     * context needs to be an instance of StandardContext for this listener to
-     * have any effect.
-     */
-    public static class DefaultWebXmlListener implements LifecycleListener {
-        public void lifecycleEvent(LifecycleEvent event) {
-            if (Lifecycle.BEFORE_START_EVENT.equals(event.getType()) &&
-                    event.getLifecycle() instanceof StandardContext) {
-                initWebappDefaults((StandardContext) event.getLifecycle());
-            }
-        }
-    }
-
-
-    /**
-     * Helper class for wrapping existing servlets. This disables servlet
-     * lifecycle and normal reloading, but also reduces overhead and provide
-     * more direct control over the servlet.
-     */
-    public static class ExistingStandardWrapper extends StandardWrapper {
-        private Servlet existing;
-        boolean init = false;
-
-        public ExistingStandardWrapper( Servlet existing ) {
-            this.existing = existing;
-        }
-        @Override
-        public synchronized Servlet loadServlet() throws ServletException {
-            if (!init) {
-                existing.init(facade);
-                init = true;
-            }
-            return existing;
-
-        }
-        @Override
-        public long getAvailable() {
-            return 0;
-        }
-        @Override
-        public boolean isUnavailable() {
-            return false;
-        }
-    }
-
-    /**
-     * TODO: would a properties resource be better ? Or just parsing
-     * /etc/mime.types ?
-     * This is needed because we don't use the default web.xml, where this
-     * is encoded.
-     */
-    public static final String[] DEFAULT_MIME_MAPPINGS = {
-        "abs", "audio/x-mpeg",
-        "ai", "application/postscript",
-        "aif", "audio/x-aiff",
-        "aifc", "audio/x-aiff",
-        "aiff", "audio/x-aiff",
-        "aim", "application/x-aim",
-        "art", "image/x-jg",
-        "asf", "video/x-ms-asf",
-        "asx", "video/x-ms-asf",
-        "au", "audio/basic",
-        "avi", "video/x-msvideo",
-        "avx", "video/x-rad-screenplay",
-        "bcpio", "application/x-bcpio",
-        "bin", "application/octet-stream",
-        "bmp", "image/bmp",
-        "body", "text/html",
-        "cdf", "application/x-cdf",
-        "cer", "application/pkix-cert",
-        "class", "application/java",
-        "cpio", "application/x-cpio",
-        "csh", "application/x-csh",
-        "css", "text/css",
-        "dib", "image/bmp",
-        "doc", "application/msword",
-        "dtd", "application/xml-dtd",
-        "dv", "video/x-dv",
-        "dvi", "application/x-dvi",
-        "eps", "application/postscript",
-        "etx", "text/x-setext",
-        "exe", "application/octet-stream",
-        "gif", "image/gif",
-        "gtar", "application/x-gtar",
-        "gz", "application/x-gzip",
-        "hdf", "application/x-hdf",
-        "hqx", "application/mac-binhex40",
-        "htc", "text/x-component",
-        "htm", "text/html",
-        "html", "text/html",
-        "ief", "image/ief",
-        "jad", "text/vnd.sun.j2me.app-descriptor",
-        "jar", "application/java-archive",
-        "java", "text/x-java-source",
-        "jnlp", "application/x-java-jnlp-file",
-        "jpe", "image/jpeg",
-        "jpeg", "image/jpeg",
-        "jpg", "image/jpeg",
-        "js", "application/javascript",
-        "jsf", "text/plain",
-        "jspf", "text/plain",
-        "kar", "audio/midi",
-        "latex", "application/x-latex",
-        "m3u", "audio/x-mpegurl",
-        "mac", "image/x-macpaint",
-        "man", "text/troff",
-        "mathml", "application/mathml+xml",
-        "me", "text/troff",
-        "mid", "audio/midi",
-        "midi", "audio/midi",
-        "mif", "application/x-mif",
-        "mov", "video/quicktime",
-        "movie", "video/x-sgi-movie",
-        "mp1", "audio/mpeg",
-        "mp2", "audio/mpeg",
-        "mp3", "audio/mpeg",
-        "mp4", "video/mp4",
-        "mpa", "audio/mpeg",
-        "mpe", "video/mpeg",
-        "mpeg", "video/mpeg",
-        "mpega", "audio/x-mpeg",
-        "mpg", "video/mpeg",
-        "mpv2", "video/mpeg2",
-        "nc", "application/x-netcdf",
-        "oda", "application/oda",
-        "odb", "application/vnd.oasis.opendocument.database",
-        "odc", "application/vnd.oasis.opendocument.chart",
-        "odf", "application/vnd.oasis.opendocument.formula",
-        "odg", "application/vnd.oasis.opendocument.graphics",
-        "odi", "application/vnd.oasis.opendocument.image",
-        "odm", "application/vnd.oasis.opendocument.text-master",
-        "odp", "application/vnd.oasis.opendocument.presentation",
-        "ods", "application/vnd.oasis.opendocument.spreadsheet",
-        "odt", "application/vnd.oasis.opendocument.text",
-        "otg", "application/vnd.oasis.opendocument.graphics-template",
-        "oth", "application/vnd.oasis.opendocument.text-web",
-        "otp", "application/vnd.oasis.opendocument.presentation-template",
-        "ots", "application/vnd.oasis.opendocument.spreadsheet-template ",
-        "ott", "application/vnd.oasis.opendocument.text-template",
-        "ogx", "application/ogg",
-        "ogv", "video/ogg",
-        "oga", "audio/ogg",
-        "ogg", "audio/ogg",
-        "spx", "audio/ogg",
-        "flac", "audio/flac",
-        "anx", "application/annodex",
-        "axa", "audio/annodex",
-        "axv", "video/annodex",
-        "xspf", "application/xspf+xml",
-        "pbm", "image/x-portable-bitmap",
-        "pct", "image/pict",
-        "pdf", "application/pdf",
-        "pgm", "image/x-portable-graymap",
-        "pic", "image/pict",
-        "pict", "image/pict",
-        "pls", "audio/x-scpls",
-        "png", "image/png",
-        "pnm", "image/x-portable-anymap",
-        "pnt", "image/x-macpaint",
-        "ppm", "image/x-portable-pixmap",
-        "ppt", "application/vnd.ms-powerpoint",
-        "pps", "application/vnd.ms-powerpoint",
-        "ps", "application/postscript",
-        "psd", "image/vnd.adobe.photoshop",
-        "qt", "video/quicktime",
-        "qti", "image/x-quicktime",
-        "qtif", "image/x-quicktime",
-        "ras", "image/x-cmu-raster",
-        "rdf", "application/rdf+xml",
-        "rgb", "image/x-rgb",
-        "rm", "application/vnd.rn-realmedia",
-        "roff", "text/troff",
-        "rtf", "application/rtf",
-        "rtx", "text/richtext",
-        "sh", "application/x-sh",
-        "shar", "application/x-shar",
-        /*"shtml", "text/x-server-parsed-html",*/
-        "sit", "application/x-stuffit",
-        "snd", "audio/basic",
-        "src", "application/x-wais-source",
-        "sv4cpio", "application/x-sv4cpio",
-        "sv4crc", "application/x-sv4crc",
-        "svg", "image/svg+xml",
-        "svgz", "image/svg+xml",
-        "swf", "application/x-shockwave-flash",
-        "t", "text/troff",
-        "tar", "application/x-tar",
-        "tcl", "application/x-tcl",
-        "tex", "application/x-tex",
-        "texi", "application/x-texinfo",
-        "texinfo", "application/x-texinfo",
-        "tif", "image/tiff",
-        "tiff", "image/tiff",
-        "tr", "text/troff",
-        "tsv", "text/tab-separated-values",
-        "txt", "text/plain",
-        "ulw", "audio/basic",
-        "ustar", "application/x-ustar",
-        "vxml", "application/voicexml+xml",
-        "xbm", "image/x-xbitmap",
-        "xht", "application/xhtml+xml",
-        "xhtml", "application/xhtml+xml",
-        "xls", "application/vnd.ms-excel",
-        "xml", "application/xml",
-        "xpm", "image/x-xpixmap",
-        "xsl", "application/xml",
-        "xslt", "application/xslt+xml",
-        "xul", "application/vnd.mozilla.xul+xml",
-        "xwd", "image/x-xwindowdump",
-        "vsd", "application/vnd.visio",
-        "wav", "audio/x-wav",
-        "wbmp", "image/vnd.wap.wbmp",
-        "wml", "text/vnd.wap.wml",
-        "wmlc", "application/vnd.wap.wmlc",
-        "wmls", "text/vnd.wap.wmlsc",
-        "wmlscriptc", "application/vnd.wap.wmlscriptc",
-        "wmv", "video/x-ms-wmv",
-        "wrl", "model/vrml",
-        "wspolicy", "application/wspolicy+xml",
-        "Z", "application/x-compress",
-        "z", "application/x-compress",
-        "zip", "application/zip"
-    };
-}

==================================================
TomcatStandaloneMain.java
deleted file mode 100644
index a995076e02..0000000000
--- a/modules/tomcat-lite/test/org/apache/coyote/lite/TomcatLiteCoyoteTest.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- */
-package org.apache.coyote.lite;
-
-import java.io.IOException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import junit.framework.TestCase;
-
-import org.apache.tomcat.lite.http.HttpClient;
-import org.apache.tomcat.lite.http.HttpChannel;
-import org.apache.tomcat.lite.http.HttpConnector;
-import org.apache.tomcat.lite.io.BBuffer;
-
-/**
- * Very simple test.
- */
-public class TomcatLiteCoyoteTest extends TestCase {
-    static int port = 8884;
-    static {
-        Logger.getLogger("org.apache.catalina.core.StandardService").setLevel(Level.WARNING);
-        Logger.getLogger("org.apache.catalina.core.StandardEngine").setLevel(Level.WARNING);
-        Logger.getLogger("org.apache.catalina.startup.ContextConfig").setLevel(Level.WARNING);
-    }
-    static Tomcat main = TomcatStandaloneMain.setUp(port);
-
-    public void testSimple() throws IOException {
-        HttpConnector clientCon = HttpClient.newClient();
-
-        HttpChannel ch = clientCon.get("localhost", port);
-        ch.getRequest().setRequestURI("/index.html");
-        ch.getRequest().send();
-
-        BBuffer res = ch.readAll(null, 0);
-
-        assertTrue(res.toString(),
-                res.toString().indexOf("<title>Apache Tomcat</title>") >= 0);
-    }
-
-
-}

==================================================
TestMain.java
deleted file mode 100644
index 98cf16e828..0000000000
--- a/modules/tomcat-lite/test/org/apache/coyote/lite/TomcatStandaloneMain.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- */
-package org.apache.coyote.lite;
-
-import javax.servlet.ServletException;
-
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.connector.Connector;
-import org.apache.tomcat.lite.TestMain;
-
-/**
- * Startup tomcat + coyote lite connector.
- * No config files used.
- *
- * @author Costin Manolache
- */
-public class TomcatStandaloneMain {
-
-    public static Tomcat setUp(int port) {
-        try {
-            Tomcat tomcat = new Tomcat();
-
-            tomcat.setPort(port);
-            String base = TestMain.findDir("/output/build");
-            tomcat.setBaseDir(base);
-            // Absolute path - tomcat6 and 7 are different,
-            // 7 adds webapps.
-            tomcat.addWebapp("/", base + "/webapps/ROOT");
-
-            LiteProtocolHandler litePH = setUp(tomcat, port);
-
-            tomcat.start();
-            return tomcat;
-        } catch (LifecycleException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        } catch (ServletException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        }
-        return null;
-    }
-
-    public static LiteProtocolHandler setUp(Tomcat tomcat, int port) {
-        Connector connector;
-        try {
-            connector = new Connector(LiteProtocolHandler.class.getName());
-            tomcat.getService().addConnector(connector);
-            connector.setPort(port);
-            tomcat.setConnector(connector);
-            LiteProtocolHandler ph =
-                (LiteProtocolHandler) connector.getProtocolHandler();
-            return ph;
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-}

==================================================
ClientTest.java
deleted file mode 100644
index d81aa7ccbf..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/TestMain.java
+++ /dev/null
@@ -1,313 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite;
-
-import java.io.BufferedInputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.Constructor;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.lite.http.BaseMapper;
-import org.apache.tomcat.lite.http.HttpClient;
-import org.apache.tomcat.lite.http.Dispatcher;
-import org.apache.tomcat.lite.http.HttpConnector;
-import org.apache.tomcat.lite.http.HttpRequest;
-import org.apache.tomcat.lite.http.HttpResponse;
-import org.apache.tomcat.lite.http.HttpServer;
-import org.apache.tomcat.lite.http.HttpChannel.HttpService;
-import org.apache.tomcat.lite.http.services.EchoCallback;
-import org.apache.tomcat.lite.http.services.SleepCallback;
-import org.apache.tomcat.lite.io.BBuffer;
-import org.apache.tomcat.lite.io.jsse.JsseSslProvider;
-import org.apache.tomcat.lite.proxy.HttpProxyService;
-import org.apache.tomcat.lite.proxy.StaticContentService;
-import org.apache.tomcat.lite.service.IOStatus;
-
-/**
- * Laucher for tomcat-lite standalone, configured with test handlers.
- *
- * Used in tests - one is running for the entire suite.
- *
- * @author Costin Manolache
- */
-public class TestMain {
-
-    static {
-        JsseSslProvider.testModeURLConnection();
-    }
-
-    static TestMain defaultServer;
-
-    private boolean init = false;
-
-    HttpConnector testClient;
-    HttpConnector testServer;
-    HttpConnector testProxy;
-    HttpConnector sslServer;
-    HttpProxyService proxy;
-
-    public TestMain() {
-        init();
-    }
-
-    protected void init() {
-        testClient = HttpClient.newClient();
-    }
-
-    /**
-     * A single instance used for all tests.
-     */
-    public static TestMain shared() {
-        if (defaultServer == null) {
-            defaultServer = new TestMain();
-            defaultServer.run();
-        }
-        return defaultServer;
-    }
-
-    public static HttpConnector getTestServer() {
-        return shared().testServer;
-    }
-
-    public HttpConnector getClient() {
-        return shared().testClient;
-    }
-
-    public static BaseMapper.Context initTestContext(Dispatcher d) throws IOException {
-        BaseMapper.Context mCtx = d.addContext(null, "", null, null, null, null);
-
-        mCtx.addWrapper("/", new StaticContentService()
-            .setContentType("text/html")
-            .setData("<a href='/proc/cpool/client'>Client pool</a><br>" +
-                    "<a href='/proc/cpool/server'>Server pool</a><br>" +
-                    "<a href='/proc/cpool/proxy'>Proxy pool</a><br>" +
-                    ""));
-
-        mCtx.addWrapper("/favicon.ico",
-                new StaticContentService().setStatus(404).setData("Not found"));
-
-        mCtx.addWrapper("/hello", new StaticContentService().setData("Hello world"));
-        mCtx.addWrapper("/2nd", new StaticContentService().setData("Hello world2"));
-        mCtx.addWrapper("/echo/*", new EchoCallback());
-
-        mCtx.addWrapper("/sleep/1", new SleepCallback().setData("sleep 1"));
-        mCtx.addWrapper("/sleep/10", new SleepCallback().sleep(10000).setData(
-                "sleep 1"));
-
-        mCtx.addWrapper("/chunked/*", new StaticContentService().setData("AAAA")
-                .chunked());
-        mCtx.addWrapper("/helloClose", new HttpService() {
-            @Override
-            public void service(HttpRequest httpReq, HttpResponse httpRes)
-                    throws IOException {
-                httpRes.setHeader("Connection", "close");
-                httpRes.getBodyWriter().write("Hello");
-            }
-        });
-        return mCtx;
-    }
-
-    public void initTestCallback(Dispatcher d) throws IOException {
-        BaseMapper.Context mCtx = initTestContext(d);
-        mCtx.addWrapper("/proc/cpool/client", new IOStatus(testClient.cpool));
-        mCtx.addWrapper("/proc/cpool/proxy", new IOStatus(testProxy.cpool));
-        mCtx.addWrapper("/proc/cpool/server", new IOStatus(testServer.cpool));
-    }
-
-    public void run() {
-        try {
-            startAll();
-            // TODO(costin): clean up
-            // Hook in JMX and debug properties
-            try {
-                Class c = Class.forName("org.apache.tomcat.lite.TomcatLiteJmx");
-                Constructor constructor = c.getConstructor(TestMain.class);
-                constructor.newInstance(this);
-            } catch (Throwable t) {
-                // ignore
-            }
-        } catch (Throwable t) {
-            t.printStackTrace();
-        }
-    }
-
-    public static String findDir(String dir) {
-        String path = ".";
-        for (int i = 0; i < 5; i++) {
-            File f = new File(path + dir);
-            if (f.exists()) {
-                try {
-                    return f.getCanonicalPath();
-                } catch (IOException e) {
-                    return f.getAbsolutePath();
-                }
-            }
-            path = path + "/..";
-        }
-        return null;
-    }
-
-    public int getServerPort() {
-        return 8802;
-    }
-
-    public int getProxyPort() {
-        return 8903;
-    }
-
-    public int getSslServerPort() {
-        return 8443;
-    }
-
-    static String PRIVATE_KEY =
-    "MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALsz2milZGHliWte61TfMTSwpAdq" +
-"9uJkMTqgpSVtwxxOe8kT84QtIzhdAsQYjRz9ZtQn9DYWhJQs/cs/R3wWsjWwgiFHLzGalvsmMYJ3" +
-"vBO8VMj762fAWu7GjUApIXcxMJoK4sQUpZKbqTuXpwzVUeeqBcspsIDgOLCo233G7/fBAgMBAAEC" +
-"gYAWEaDX4VeaKuMuYzw+/yjf20sbDMMaIVGkZbfSV8Q+nAn/xHhaxq92P5DJ6VMJbd4neKZTkggD" +
-"J+KriUQ2Hr7XXd/nM+sllaDWGmUnMYFI4txaNkikMA3ZyE/Xa79eDpTnSst8Nm11vrX9oF/hDNo4" +
-"dhbU1krjAwVl/WijzSk4gQJBANvSmsmdjPlzvGNE11Aq3Ffb9/SqAOdE8NevMFeVKtBEKHIe1WlO" +
-"ThRyWv3I8bUKTQMNULruSFVghTh6Hkt/CBkCQQDaAuxaXjv2voYozkOviXMpt0X5LZJMQu2gFc2x" +
-"6UgBqYP2pNGDdRVWpbxF65PpXcLNKllCss2WB8i8kdeixYHpAkEAnIrzfia7sR2RiCQLLWUIe20D" +
-"vHGgqRG4bfCtfYGV9rDDGNoKYq7H/dmeIOML9kA6rbS6zBRK4LoWxSx6DIuPaQJAL2c3USbwTuR6" +
-"c2D2IrL2UXnCQz3/c4mR9Z8IDMk2mPXs9bI8xCKvMxnyaBmjHbj/ZHDy26fZP+gNY8MqagAcEQJA" +
-"SidPwFV6cO8LCIA43wSVHlKZt4yU5wa9EWfzqVZxj7VSav7431kuxktW/YlwwxO4Pn8hgpPqD+W1" +
-"E+Ssocxi8A==";
-		
-    static String CERTIFICATE = "-----BEGIN CERTIFICATE-----\n" +
-"MIIC5DCCAk2gAwIBAgIJAMa8ioWQMpEZMA0GCSqGSIb3DQEBBQUAMFYxCzAJBgNV" +
-"BAYTAlVTMQswCQYDVQQIEwJDQTESMBAGA1UEChMJbG9jYWxob3N0MRIwEAYDVQQL" +
-"Ewlsb2NhbGhvc3QxEjAQBgNVBAMTCWxvY2FsaG9zdDAeFw0xMDAyMjYyMzIxNDBa" +
-"Fw0xMTAyMjYyMzIxNDBaMFYxCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTESMBAG" +
-"A1UEChMJbG9jYWxob3N0MRIwEAYDVQQLEwlsb2NhbGhvc3QxEjAQBgNVBAMTCWxv" +
-"Y2FsaG9zdDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAuzPaaKVkYeWJa17r" +
-"VN8xNLCkB2r24mQxOqClJW3DHE57yRPzhC0jOF0CxBiNHP1m1Cf0NhaElCz9yz9H" +
-"fBayNbCCIUcvMZqW+yYxgne8E7xUyPvrZ8Ba7saNQCkhdzEwmgrixBSlkpupO5en" +
-"DNVR56oFyymwgOA4sKjbfcbv98ECAwEAAaOBuTCBtjAdBgNVHQ4EFgQUj3OnBK8R" +
-"UN2CcmPvfQ1/IBeFwn8wgYYGA1UdIwR/MH2AFI9zpwSvEVDdgnJj730NfyAXhcJ/" +
-"oVqkWDBWMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExEjAQBgNVBAoTCWxvY2Fs" +
-"aG9zdDESMBAGA1UECxMJbG9jYWxob3N0MRIwEAYDVQQDEwlsb2NhbGhvc3SCCQDG" +
-"vIqFkDKRGTAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4GBAKcJWWZbHRuG" +
-"77ir1ETltxNIsAFvuhDD6E68eBwpviWfKhFxiOdD1vmAGqWWDYpmgORBGxFMZxTq" +
-"c82iSbM0LseFeHwxAfeNXosSShMFtQzKt2wKZLLQB/Oqrea32m4hU//NP8rNbTux" +
-"dcAHeNQEDB5EUUSewAlh+fUE6HB6c8j0\n" +
-"-----END CERTIFICATE-----\n\n";
-
-    protected synchronized void startAll() throws IOException {
-        if (init) {
-            System.err.println("2x init ???");
-        } else {
-            init = true;
-            boolean debug = false;
-            if (debug) {
-                System.setProperty("javax.net.debug", "ssl");
-                System.setProperty("jsse", "conn_state,alert,engine,record,ssocket,socket,prf");
-                Logger.getLogger("SSL").setLevel(Level.FINEST);
-                testClient.setDebug(true);
-                testClient.setDebugHttp(true);
-            }
-
-            proxy = new HttpProxyService()
-                .withHttpClient(testClient);
-            testProxy = HttpServer.newServer(getProxyPort());
-
-            if (debug) {
-                testProxy.setDebugHttp(true);
-                testProxy.setDebug(true);
-            }
-
-            // dispatcher rejects 'http://'
-            testProxy.setHttpService(proxy);
-            try {
-                testProxy.start();
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-
-            testServer = HttpServer.newServer(getServerPort());
-            if (debug) {
-                testServer.setDebugHttp(true);
-                testServer.setDebug(true);
-            }
-            initTestCallback(testServer.getDispatcher());
-            try {
-                testServer.start();
-            } catch (IOException e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            }
-
-//            Base64 b64 = new Base64();
-//            byte[] keyBytes = b64.decode(PRIVATE_KEY);
-
-            sslServer = HttpServer.newSslServer(getSslServerPort());
-
-            if (debug) {
-                sslServer.setDebug(true);
-                sslServer.setDebugHttp(true);
-            }
-            JsseSslProvider sslCon = (JsseSslProvider) sslServer.getSslProvider();
-
-            sslCon = sslCon
-                .setKeyRes("org/apache/tomcat/lite/http/genrsa_512.cert",
-                        "org/apache/tomcat/lite/http/genrsa_512.der");
-            initTestCallback(sslServer.getDispatcher());
-            sslServer.start();
-        }
-
-        Runtime.getRuntime().addShutdownHook(new Thread() {
-            public void run() {
-                System.err.println("Done");
-            }
-            public void start() {
-                System.err.println("Done1");
-            }
-        });
-    }
-
-    /**
-     * Blocking get, returns when the body has been read.
-     */
-    public static BBuffer get(String url) throws IOException {
-
-        BBuffer out = BBuffer.allocate();
-
-        HttpRequest aclient = HttpClient.newClient().request(url);
-        aclient.send();
-        aclient.readAll(out,
-                //Long.MAX_VALUE);//
-                2000000);
-        aclient.release(); // return connection to pool
-        return out;
-    }
-
-    public static BBuffer getUrl(String path) throws IOException {
-        BBuffer out = BBuffer.allocate();
-        getUrl(path, out);
-        return out;
-    }
-
-    public static HttpURLConnection getUrl(String path,
-                             BBuffer out) throws IOException {
-        URL url = new URL(path);
-        HttpURLConnection connection =
-            (HttpURLConnection) url.openConnection();
-        connection.setReadTimeout(10000);
-        connection.connect();
-        int rc = connection.getResponseCode();
-        InputStream is = connection.getInputStream();
-        BufferedInputStream bis = new BufferedInputStream(is);
-        byte[] buf = new byte[2048];
-        int rd = 0;
-        while((rd = bis.read(buf)) > 0) {
-            out.append(buf, 0, rd);
-        }
-        return connection;
-    }
-
-
-}

==================================================
CompressFilterTest.java
deleted file mode 100644
index 226cad3581..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/ClientTest.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-
-import org.apache.tomcat.lite.TestMain;
-
-import junit.framework.TestCase;
-
-/**
- * Examples and tests for Tomcat-lite in client mode.
- *
- */
-public class ClientTest extends TestCase {
-
-    /**
-     * All connectors created this way will share a single
-     * IO thread. Each connector will have its keep-alive
-     * pool - so it's better to share them.
-     *
-     * Since I want to test keep-alive works, I use a static one
-     */
-    static HttpConnector httpCon = HttpClient.newClient();
-
-    /**
-     * Start a http server, runs on 8802 - shared by all tests.
-     * Will use /echo handler.
-     */
-    static HttpConnector testServer = TestMain.getTestServer();
-
-
-    public void testSimpleBlocking() throws IOException {
-        HttpRequest req = httpCon.request("http://localhost:8802/echo/test1");
-        HttpResponse res = req.waitResponse();
-
-        assertEquals(200, res.getStatus());
-        //assertEquals("", res.getHeader(""));
-
-        BufferedReader reader = res.getReader();
-        String line1 = reader.readLine();
-        assertEquals("REQ HEAD:", line1);
-    }
-
-    public void testSimpleCallback() throws IOException {
-
-    }
-
-    public void testGetParams() throws IOException {
-    }
-
-    public void testPostParams() throws IOException {
-    }
-
-    public void testPostBody() throws IOException {
-    }
-
-
-}

==================================================
DispatcherTest.java
deleted file mode 100644
index 0ec3b82d27..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/CompressFilterTest.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import java.util.Random;
-
-import junit.framework.TestCase;
-
-import org.apache.tomcat.lite.io.IOBuffer;
-
-public class CompressFilterTest extends TestCase {
-
-    CompressFilter cf = new CompressFilter();
-
-    private void check(String clear, String xtra) throws Exception {
-        IOBuffer in = new IOBuffer();
-        IOBuffer out = new IOBuffer();
-
-        in.append(clear);
-        in.close();
-
-        cf.compress(in, out);
-
-//        BBuffer bb = out.copyAll(null);
-//        String hd = Hex.getHexDump(bb.array(), bb.position(),
-//                bb.remaining(), true);
-//        System.err.println(hd);
-
-        if (xtra != null) {
-            out.append(xtra);
-        }
-        in.recycle();
-        out.close();
-        cf.decompress(out, in);
-
-        assertEquals(in.copyAll(null).toString(), clear);
-        assertTrue(in.isAppendClosed());
-
-        if (xtra != null) {
-            assertEquals(out.copyAll(null).toString(), xtra);
-        }
-    }
-
-    public void test1() throws Exception {
-        check("X1Y2Z3", null);
-    }
-
-    public void testXtra() throws Exception {
-        check("X1Y2Z3", "GET /");
-    }
-
-    public void testLarge() throws Exception {
-        StringBuffer sb = new StringBuffer();
-        for (int i = 0; i < 2 * 1024; i++) {
-            sb.append("0123456789012345");
-        }
-        check(sb.toString(), null);
-    }
-
-    public void testLarge10() throws Exception {
-        for (int i = 0; i < 10; i++) {
-            testLargeIn();
-            cf.recycle();
-        }
-    }
-
-    public void testLargeIn() throws Exception {
-        StringBuffer sb = new StringBuffer();
-        Random r = new Random();
-        for (int i = 0; i < 16 * 2 * 1024; i++) {
-            sb.append(' ' + r.nextInt(32));
-        }
-        check(sb.toString(), null);
-    }
-
-
-    public void testSpdy() throws Exception {
-        cf.setDictionary(SpdyConnection.SPDY_DICT, SpdyConnection.DICT_ID);
-        check("connection: close\n", null);
-    }
-
-}

==================================================
HttpChannelInMemoryTest.java
deleted file mode 100644
index f4740073c2..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/DispatcherTest.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import org.apache.tomcat.lite.io.CBuffer;
-
-import junit.framework.TestCase;
-
-public class DispatcherTest extends TestCase {
-
-    public void testMapper() throws Exception {
-        BaseMapper mapper = new BaseMapper();
-
-        String[] welcomes = new String[2];
-        welcomes[0] = "index.html";
-        welcomes[1] = "foo.html";
-
-        mapper.addContext("test1.com", "", "context0", new String[0], null, null);
-        mapper.addContext("test1.com", "/foo", "context1", new String[0], null, null);
-        mapper.addContext("test1.com", "/foo/bar", "context2", welcomes, null, null);
-        mapper.addContext("test1.com", "/foo/bar/bla", "context3", new String[0], null, null);
-
-        mapper.addWrapper("test1.com", "/foo/bar", "/fo/*", "wrapper0");
-        mapper.addWrapper("test1.com", "/foo/bar", "/", "wrapper1");
-        mapper.addWrapper("test1.com", "/foo/bar", "/blh", "wrapper2");
-        mapper.addWrapper("test1.com", "/foo/bar", "*.jsp", "wrapper3");
-        mapper.addWrapper("test1.com", "/foo/bar", "/blah/bou/*", "wrapper4");
-        mapper.addWrapper("test1.com", "/foo/bar", "/blah/bobou/*", "wrapper5");
-        mapper.addWrapper("test1.com", "/foo/bar", "*.htm", "wrapper6");
-
-        mapper.addContext("asdf.com", "", "context0", new String[0], null, null);
-
-        MappingData mappingData = new MappingData();
-
-        CBuffer host = CBuffer.newInstance();
-        host.set("test1.com");
-
-        CBuffer uri = CBuffer.newInstance();
-        uri.set("/foo/bar/blah/bobou/foo");
-
-        mapper.map(host, uri, mappingData);
-
-        assertEquals("context2", mappingData.context.toString());
-        assertEquals("/foo/bar", mappingData.contextPath.toString());
-    }
-}

==================================================
HttpChannelTest.java
deleted file mode 100644
index f0b2cf2570..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/HttpChannelInMemoryTest.java
+++ /dev/null
@@ -1,384 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-
-import junit.framework.TestCase;
-
-import org.apache.tomcat.lite.http.HttpChannel.HttpService;
-import org.apache.tomcat.lite.http.HttpChannel.RequestCompleted;
-import org.apache.tomcat.lite.io.BBuffer;
-import org.apache.tomcat.lite.io.CBuffer;
-import org.apache.tomcat.lite.io.IOBuffer;
-import org.apache.tomcat.lite.io.IOChannel;
-import org.apache.tomcat.lite.io.IOConnector;
-import org.apache.tomcat.lite.io.MemoryIOConnector;
-import org.apache.tomcat.lite.io.MemoryIOConnector.MemoryIOChannel;
-
-// TODO: rename to Http11ConnectionTest
-public class HttpChannelInMemoryTest extends TestCase {
-    /**
-     *  Connection under test
-     */
-    Http11Connection conn;
-
-    /**
-     * Last http channel created by the connection
-     */
-    volatile HttpChannel http;
-
-    // Input/output for the connection
-    MemoryIOConnector.MemoryIOChannel net = new MemoryIOChannel();
-
-    HttpConnector serverConnector = new HttpConnector(null);
-
-    // Callback results for callback tests
-    boolean hasBody = false;
-    boolean bodyDone = false;
-    boolean bodySentDone = false;
-    boolean headersDone = false;
-    boolean allDone = false;
-
-    public void setUp() throws IOException {
-        // Requests will not be serviced - you must manually generate
-        // the response.
-        serverConnector.setHttpService(null);
-
-        conn = new Http11Connection(serverConnector) {
-            protected HttpChannel checkHttpChannel() throws IOException {
-                return http = super.checkHttpChannel();
-            }
-        }.serverMode();
-        conn.setSink(net);
-    }
-
-
-    public void test2Req() throws IOException {
-        String req = "GET /index.html?q=b&c=d HTTP/1.1\r\n" +
-        "Host:  Foo.com \n" +
-        "H2:Bar\r\n" +
-        "H3: Foo \r\n" +
-        " Bar\r\n" +
-        "H4: Foo\n" +
-        "    Bar\n" +
-        "\r\n" +
-        "HEAD /r2? HTTP/1.1\n" +
-        "Host: Foo.com\r\n" +
-        "H3: Foo \r\n" +
-        "       Bar\r\n" +
-        "H4: Foo\n" +
-        " Bar\n" +
-        "\r\n";
-        net.getIn().append(req);
-
-        //http = lastServer.get(0);
-        assertTrue(http.getRequest().method().equals("GET"));
-        assertTrue(http.getRequest().protocol().equals("HTTP/1.1"));
-        assertEquals(http.getRequest().getMimeHeaders().size(), 4);
-        assertEquals(http.getRequest().getMimeHeaders().getHeader("Host").toString(),
-                "Foo.com");
-        assertEquals(http.getRequest().getMimeHeaders().getHeader("H2").toString(),
-                "Bar");
-
-        http.getOut().append("Response1");
-        http.getOut().close();
-        http.startSending();
-        http.release();
-
-        // now second response must be in.
-        // the connector will create a new http channel
-
-        //http = lastServer.get(1);
-
-        assertTrue(http.getRequest().method().equals("HEAD"));
-        assertTrue(http.getRequest().protocol().equals("HTTP/1.1"));
-        assertTrue(http.getRequest().getMimeHeaders().size() == 3);
-        assertTrue(http.getRequest().getMimeHeaders().getHeader("Host")
-                .equals("Foo.com"));
-    }
-
-    public void testHttp11Close() throws IOException {
-        String req = "GET /index.html?q=b&c=d HTTP/1.1\r\n" +
-        "Host:  Foo.com\n" +
-        "Connection: close\n" +
-        "\n";
-        net.getIn().append(req);
-
-        assertTrue(http.getRequest().method().equals("GET"));
-        assertTrue(http.getRequest().protocol().equals("HTTP/1.1"));
-
-        http.getOut().append("Response1");
-        http.getOut().close();
-        http.startSending();
-        http.release();
-
-        assertTrue(net.out.indexOf("connection:close") > 0);
-        assertFalse(net.isOpen());
-    }
-
-    public void testHttp10Close() throws IOException {
-        String req = "GET /index.html?q=b&c=d HTTP/1.0\r\n" +
-        "Host:  Foo.com \n" +
-        "\r\n";
-        net.getIn().append(req);
-
-        assertTrue(http.getRequest().method().equals("GET"));
-        assertTrue(http.getRequest().protocol().equals("HTTP/1.0"));
-
-        http.getOut().append("Response1");
-        http.getOut().close();
-        http.startSending();
-
-        assertTrue(net.out.indexOf("connection:close") > 0);
-        assertFalse(net.isOpen());
-    }
-
-    public void testHttp10KA() throws IOException {
-        String req = "GET /index.html?q=b&c=d HTTP/1.0\r\n" +
-        "Connection: Keep-Alive\n" +
-        "Host:  Foo.com \n" +
-        "\r\n";
-        net.getIn().append(req);
-
-        assertTrue(http.getRequest().method().equals("GET"));
-        assertTrue(http.getRequest().protocol().equals("HTTP/1.0"));
-
-        http.getOut().append("Hi");
-        http.getOut().close();
-        http.startSending();
-
-        // after request
-        assertEquals(conn.activeHttp, null);
-
-        assertTrue(net.out.indexOf("connection:keep-alive") > 0);
-        assertTrue(net.isOpen());
-        // inserted since we can calculate the response
-        assertEquals(http.getResponse().getHeader("Content-Length"),
-                   "2");
-    }
-
-    public void testHttp10KANoCL() throws IOException {
-        String req = "GET /index.html?q=b&c=d HTTP/1.0\r\n" +
-        "Connection: Keep-Alive\n" +
-        "Host:  Foo.com \n" +
-        "\r\n";
-        net.getIn().append(req);
-
-        assertTrue(http.getRequest().method().equals("GET"));
-        assertTrue(http.getRequest().protocol().equals("HTTP/1.0"));
-
-        http.getOut().append("Hi");
-        http.startSending();
-
-        http.getOut().append("After");
-        http.getOut().close();
-        http.startSending();
-
-        // after request
-        assertEquals(conn.activeHttp, null);
-
-        assertFalse(net.out.indexOf("connection:keep-alive") > 0);
-        assertFalse(net.isOpen());
-        // inserted since we can calculate the response
-        assertEquals(http.getResponse().getHeader("Content-Length"),
-                null);
-        assertEquals(http.getResponse().getHeader("Transfer-Encoding"),
-                null);
-    }
-
-    public void testMultiLineHead() throws IOException {
-        net.getIn().append("GET / HTTP/1.0\n" +
-                "Cookie: 1234\n" +
-                "  456 \n" +
-                "Connection:   Close\n\n");
-        net.getIn().close();
-
-        MultiMap headers = http.getRequest().getMimeHeaders();
-        CBuffer cookie = headers.getHeader("Cookie");
-        CBuffer conn = headers.getHeader("Connection");
-        assertEquals(conn.toString(), "close");
-        assertEquals(cookie.toString(), "1234 456");
-
-        assertEquals(http.conn.headRecvBuf.toString(),
-                "GET / HTTP/1.0\n" +
-                "Cookie: 1234 456   \n" + // \n -> trailing space
-                "Connection:   Close\n\n");
-    }
-
-    public void testCloseSocket() throws IOException {
-        net.getIn().append("GET / HTTP/1.1\n"
-                + "Host: localhost\n"
-                + "\n");
-        assertTrue(((Http11Connection)http.conn).keepAlive());
-
-        net.getIn().close();
-        assertFalse(((Http11Connection)http.conn).keepAlive());
-    }
-
-    public void test2ReqByte2Byte() throws IOException {
-        String req = "GET /index.html?q=b&c=d HTTP/1.1\r\n" +
-        "Host:  Foo.com \n" +
-        "H2:Bar\r\n" +
-        "H3: Foo \r\n" +
-        " Bar\r\n" +
-        "H4: Foo\n" +
-        "    Bar\n" +
-        "\r\n" +
-        "HEAD /r2? HTTP/1.1\n" +
-        "Host: Foo1.com\n" +
-        "H3: Foo \r\n" +
-        "       Bar\r\n" +
-        "\r\n";
-        for (int i = 0; i < req.length(); i++) {
-            net.getIn().append(req.charAt(i));
-        }
-
-        assertTrue(http.getRequest().method().equals("GET"));
-        assertTrue(http.getRequest().protocol().equals("HTTP/1.1"));
-        assertTrue(http.getRequest().getMimeHeaders().size() == 4);
-        assertTrue(http.getRequest().getMimeHeaders().getHeader("Host")
-                .equals("Foo.com"));
-
-        // send a response
-        http.sendBody.append("Response1");
-        http.getOut().close();
-
-        http.startSending(); // This will trigger a pipelined request
-
-        http.release(); // now second response must be in
-
-        assertTrue(http.getRequest().method().equals("HEAD"));
-        assertTrue(http.getRequest().protocol().equals("HTTP/1.1"));
-        assertTrue(http.getRequest().getMimeHeaders().size() == 2);
-        assertTrue(http.getRequest().getMimeHeaders().getHeader("Host")
-                .equals("Foo1.com"));
-
-        // send a response - service method will be called
-        http.sendBody.append("Response2");
-        http.getOut().close();
-        http.release(); // now second response must be in
-
-
-    }
-
-    public void testEndWithoutFlushCallbacks() throws IOException {
-
-        net.getIn().append(POST);
-
-        net.getIn().close();
-        http.setCompletedCallback(new RequestCompleted() {
-            public void handle(HttpChannel data, Object extra)
-            throws IOException {
-                allDone = true;
-            }
-        });
-
-        http.sendBody.queue("Hi");
-        http.getOut().close();
-        http.startSending(); // will call handleEndSend
-
-        assertTrue(allDone);
-
-    }
-
-    public void testCallbacks() throws IOException {
-        // already accepted - will change
-        serverConnector.setHttpService(new HttpService() {
-            public void service(HttpRequest httpReq, HttpResponse httpRes)
-                    throws IOException {
-
-                headersDone = true;
-                HttpChannel http = httpReq.getHttpChannel();
-
-                http.setCompletedCallback(new RequestCompleted() {
-                    public void handle(HttpChannel data, Object extra)
-                    throws IOException {
-                        allDone = true;
-                    }
-                });
-                http.setDataReceivedCallback(new IOConnector.DataReceivedCallback() {
-                    @Override
-                    public void handleReceived(IOChannel ch) throws IOException {
-                        if (ch.getIn().isAppendClosed()) {
-                            bodyDone = true;
-                        }
-                    }
-                });
-                http.setDataFlushedCallback(new IOConnector.DataFlushedCallback() {
-                    @Override
-                    public void handleFlushed(IOChannel ch) throws IOException {
-                        if (ch.getOut().isAppendClosed()) {
-                            bodySentDone = true;
-                        }
-                    }
-                });
-            }
-        });
-
-        // Inject the request
-        net.getIn().append("POST / HTTP/1.0\n" +
-                "Connection: Close\n" +
-                "Content-Length: 4\n\n" +
-                "1");
-        assertTrue(headersDone);
-        net.getIn().append("234");
-
-        net.getIn().close();
-        assertTrue(bodyDone);
-
-
-        http.sendBody.queue("Hi");
-        http.getOut().close();
-        http.startSending();
-        assertTrue(bodySentDone);
-
-        assertTrue(allDone);
-
-    }
-
-    public static String POST = "POST / HTTP/1.0\n" +
-        "Connection: Close\n" +
-        "Content-Length: 4\n\n" +
-        "1234";
-
-    public void testClose() throws IOException {
-        net.getIn().append(POST);
-        net.getIn().close();
-
-        IOBuffer receiveBody = http.receiveBody;
-        IOBuffer appData = receiveBody;
-        BBuffer res = BBuffer.allocate(1000);
-        appData.readAll(res);
-
-        assertEquals(res.toString(), "1234");
-        assertFalse(((Http11Connection)http.conn).keepAlive());
-
-        http.sendBody.queue(res);
-        http.getOut().close();
-        http.startSending();
-
-        assertTrue(net.getOut().isAppendClosed());
-        assertTrue(net.out.toString().indexOf("\n1234") > 0);
-
-    }
-
-    public void testReadLine() throws Exception {
-        net.getIn().append("POST / HTTP/1.0\n" +
-        		"Content-Length: 28\n\n" +
-                "Line 1\n" +
-                "Line 2\r\n" +
-                "Line 3\r" +
-                "Line 4");
-        net.getIn().close();
-
-        BufferedReader r = http.getRequest().getReader();
-        assertEquals("Line 1", r.readLine());
-        assertEquals("Line 2", r.readLine());
-        assertEquals("Line 3", r.readLine());
-        assertEquals("Line 4", r.readLine());
-        assertEquals(null, r.readLine());
-
-    }
-}

==================================================
HttpsTest.java
deleted file mode 100644
index ad13187995..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/HttpChannelTest.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import java.io.IOException;
-
-import junit.framework.TestCase;
-
-import org.apache.tomcat.lite.io.BBuffer;
-
-public class HttpChannelTest extends TestCase {
-
-    HttpChannel ch = new HttpChannel().serverMode(true);
-    Http11Connection con = new Http11Connection(null).serverMode();
-    HttpRequest req = ch.getRequest();
-
-
-    BBuffer head = BBuffer.allocate();
-    BBuffer line = BBuffer.wrapper();
-    BBuffer name = BBuffer.wrapper();
-    BBuffer value = BBuffer.wrapper();
-
-    BBuffer statusB = BBuffer.wrapper();
-    BBuffer msgB = BBuffer.wrapper();
-    BBuffer methodB = BBuffer.wrapper();
-    BBuffer queryB = BBuffer.wrapper("");
-    BBuffer requestB = BBuffer.wrapper();
-    BBuffer protoB = BBuffer.wrapper();
-
-    BBuffer l7 = BBuffer.wrapper("GET \n");
-    BBuffer l8 = BBuffer.wrapper("GET /\n");
-    BBuffer l9 = BBuffer.wrapper("GET /a?b\n");
-    BBuffer l10 = BBuffer.wrapper("GET /a?b HTTP/1.0\n");
-    BBuffer l11 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b");
-    BBuffer l12 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\n");
-
-    BBuffer f1 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\n\n");
-    BBuffer f2 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\r\n\r\n");
-    BBuffer f3 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\r\r");
-    BBuffer f4 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\r\n\r");
-
-    public void reqTest(String lineS, String method, String req,
-            String qry, String proto) throws IOException {
-        BBuffer line = BBuffer.wrapper(lineS);
-        queryB.recycle();
-        protoB.recycle();
-        requestB.recycle();
-        methodB.recycle();
-        con.parseRequestLine(line, methodB, requestB, queryB, protoB);
-        assertEquals(proto, protoB.toString());
-        assertEquals(req, requestB.toString());
-        assertEquals(qry, queryB.toString());
-        assertEquals(method, methodB.toString());
-    }
-
-    public void testParams() throws IOException {
-        MultiMap params = processQry("a=b&c=d");
-        assertEquals("b", params.getString("a"));
-    }
-
-    private MultiMap processQry(String qry) throws IOException {
-        BBuffer head = BBuffer.wrapper("GET /a?" + qry + " HTTP/1.0\n" +
-        		"Host: a\n\n");
-        con.parseMessage(ch, head);
-        MultiMap params = req.getParameters();
-        return params;
-    }
-
-    public void testParseReq() throws IOException {
-        reqTest("GET / HTTP/1.0", "GET", "/", "", "HTTP/1.0");
-        reqTest("GET", "GET", "", "", "");
-        reqTest("GET   / HTTP/1.0", "GET", "/", "", "HTTP/1.0");
-        reqTest("GET /     HTTP/1.0", "GET", "/", "", "HTTP/1.0");
-        reqTest("GET /?b HTTP/1.0", "GET", "/", "b", "HTTP/1.0");
-        reqTest("GET ?a HTTP/1.0", "GET", "", "a", "HTTP/1.0");
-        reqTest("GET a HTTP/1.0", "GET", "a", "", "HTTP/1.0");
-        reqTest("GET a? HTTP/1.0", "GET", "a", "", "HTTP/1.0");
-    }
-
-    public void headTest(String headS, String expName, String expValue,
-            String expLine, String expRest) throws IOException {
-        head = BBuffer.wrapper(headS);
-        head.readLine(line);
-        con.parseHeader(ch, head, line, name, value);
-
-        assertEquals(expName, name.toString());
-        assertEquals(expValue, value.toString());
-
-        assertEquals(expLine, line.toString());
-        assertEquals(expRest, head.toString());
-    }
-
-    public void testParseHeader() throws IOException {
-        headTest("a:b\n", "a", "b", "", "");
-        headTest("a :b\n", "a", "b", "", "");
-        headTest("a : b\n", "a", "b", "", "");
-        headTest("a :  b\n", "a", "b", "", "");
-        headTest("a :  b c \n", "a", "b c", "", "");
-        headTest("a :  b c\n", "a", "b c", "", "");
-        headTest("a :  b  c\n", "a", "b c", "", "");
-        headTest("a :  b  \n c\n", "a", "b c", "", "");
-        headTest("a :  b  \n  c\n", "a", "b c", "", "");
-        headTest("a :  b  \n  c\nd:", "a", "b c", "", "d:");
-
-    }
-
-    public void responseTest(String lineS, String proto, String status,
-            String msg) throws IOException {
-        protoB.recycle();
-        statusB.recycle();
-        msgB.recycle();
-        BBuffer line = BBuffer.wrapper(lineS);
-        con.parseResponseLine(line,
-                protoB, statusB, msgB);
-        assertEquals(proto, protoB.toString());
-        assertEquals(status, statusB.toString());
-        assertEquals(msg, msgB.toString());
-    }
-
-    public void testResponse() throws Exception {
-        responseTest("HTTP/1.1 200 OK", "HTTP/1.1", "200", "OK");
-        responseTest("HTTP/1.1  200 OK", "HTTP/1.1", "200", "OK");
-        responseTest("HTTP/1.1  200", "HTTP/1.1", "200", "");
-        responseTest("HTTP/1.1", "HTTP/1.1", "", "");
-    }
-
-
-}

==================================================
LiveHttp1Test.java
deleted file mode 100644
index bc42b3b3ad..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/HttpsTest.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.tomcat.lite.http;
-
-import junit.framework.TestCase;
-
-import org.apache.tomcat.lite.TestMain;
-import org.apache.tomcat.lite.io.BBuffer;
-
-public class HttpsTest extends TestCase {
-
-    static int port = 8443;
-
-    public void testSimpleClient() throws Exception {
-        final HttpConnector httpClient = TestMain.shared().getClient();
-        checkResponse(httpClient);
-    }
-
-    public void testSimpleServer() throws Exception {
-        final HttpConnector httpClient = TestMain.shared().getClient();
-        BBuffer res = TestMain.getUrl("https://localhost:8443/hello");
-        assertTrue(res.toString().indexOf("Hello") >= 0);
-    }
-
-
-    private void checkResponse(HttpConnector httpCon) throws Exception {
-        HttpRequest ch = httpCon.request("localhost", port).setSecure(true);
-
-        ch.setRequestURI("/hello");
-        ch.setProtocol("HTTP/1.0"); // to force close
-        ch.send();
-        BBuffer res = ch.readAll();
-
-        assertTrue(res.toString().indexOf("Hello") >= 0);
-    }
-
-    public void testSimpleClient20() throws Exception {
-        final HttpConnector httpClient = TestMain.shared().getClient();
-        for (int i = 0; i < 10; i++) {
-            checkResponse(httpClient);
-        }
-    }
-
-    public void testSimpleRequestGoogle() throws Exception {
-        for (int i = 0; i < 40; i++) {
-        final HttpConnector httpClient = TestMain.shared().getClient();
-        HttpRequest client = httpClient.request("www.google.com", 443).
-            setSecure(true);
-        client.getHttpChannel().setIOTimeout(2000000);
-        client.setRequestURI("/accounts/ServiceLogin");
-        client.send();
-
-        BBuffer res = client.readAll();
-        assertTrue(res.toString().indexOf("<title>Google Accounts</title>") > 0);
-        }
-    }
-
-
-}

==================================================
MultiMapTest.java
deleted file mode 100644
index 00e4eac2f7..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/LiveHttp1Test.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.lite.http;
-
-import java.io.IOException;
-
-import junit.framework.TestCase;
-
-import org.apache.tomcat.lite.TestMain;
-import org.apache.tomcat.lite.io.BBuffer;
-
-public class LiveHttp1Test extends TestCase {
-    // Proxy tests extend this class, run same tests via proxy on 8903
-    protected int clientPort = 8802;
-
-    HttpRequest httpReq;
-
-    BBuffer bodyRecvBuffer = BBuffer.allocate(1024);
-
-    int to = 1000000;
-
-    public void setUp() throws IOException {
-        // DefaultHttpConnector.get().setDebug(true);
-        // DefaultHttpConnector.get().setDebugHttp(true);
-        TestMain.getTestServer();
-
-        httpReq = HttpClient.newClient().request("localhost",
-                clientPort);
-
-        bodyRecvBuffer.recycle();
-    }
-
-    public void tearDown() throws Exception {
-        if (httpReq != null) {
-            httpReq.release(); // async
-            httpReq = null;
-        }
-    }
-
-    public void testSimpleRequest() throws Exception {
-        httpReq.requestURI().set("/hello");
-
-        httpReq.send();
-        httpReq.readAll(bodyRecvBuffer, to);
-        assertEquals("Hello world", bodyRecvBuffer.toString());
-    }
-
-    public void testSimpleRequestClose() throws Exception {
-        httpReq.requestURI().set("/hello");
-        httpReq.setHeader("Connection", "close");
-
-        httpReq.send();
-        httpReq.readAll(bodyRecvBuffer, to);
-        assertEquals("Hello world", bodyRecvBuffer.toString());
-    }
-
-    public void testPoolGetRelease() throws Exception {
-        HttpConnector con = HttpClient.newClient();
-        con.setMaxHttpPoolSize(10);
-        HttpChannel httpCh = con.get("localhost", clientPort);
-        httpCh.release();
-
-        httpCh = con.get("localhost", clientPort);
-        httpCh.release();
-
-        httpCh = con.get("localhost", clientPort);
-        httpCh.release();
-
-    }
-
-    public void testSimpleChunkedRequest() throws Exception {
-        httpReq.requestURI().set("/chunked/foo");
-        httpReq.send();
-        httpReq.readAll(bodyRecvBuffer, to);
-        assertTrue(bodyRecvBuffer.toString(), bodyRecvBuffer.toString().indexOf("AAA") >= 0);
-    }
-
-    // Check waitResponseHead()
-    public void testRequestHead() throws Exception {
-        httpReq.requestURI().set("/echo/foo");
-
-        // Send the request, wait response
-        httpReq.send();
-
-        httpReq.readAll(bodyRecvBuffer, to);
-        assertTrue(bodyRecvBuffer.toString().indexOf("GET /echo/foo") > 0);
-    }
-
-    public void test10() throws Exception {
-        for (int i = 0; i < 10; i++) {
-            testSimpleRequest();
-            tearDown();
-            setUp();
-
-            notFound();
-            tearDown();
-            setUp();
-
-            testSimpleRequest();
-            tearDown();
-            setUp();
-        }
-    }
-
-    public void notFound() throws Exception {
-        httpReq.requestURI().set("/foo");
-        httpReq.send();
-        httpReq.readAll(bodyRecvBuffer, to);
-    }
-
-    // compression not implemented
-    public void testGzipRequest() throws Exception {
-        httpReq.requestURI().set("/hello");
-        httpReq.setHeader("accept-encoding",
-            "gzip");
-
-        // Send the request, wait response
-        httpReq.send();
-        // cstate.waitResponseHead(10000); // headers are received
-        // ByteChunk data = new ByteChunk(1024);
-        // acstate.serializeResponse(acstate.res, data);
-
-        // System.err.println(bodyRecvBuffer.toString());
-
-        httpReq.readAll(bodyRecvBuffer, to);
-        // Done
-    }
-
-    public void testWrongPort() throws Exception {
-        httpReq = HttpClient.newClient().request("localhost", 18904);
-        httpReq.requestURI().set("/hello");
-
-        httpReq.send();
-
-        httpReq.readAll(bodyRecvBuffer, to);
-        assertEquals(0, bodyRecvBuffer.remaining());
-    }
-}

==================================================
SpdyTest.java
deleted file mode 100644
index e222f36d3c..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/MultiMapTest.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.http;
-
-import org.apache.tomcat.lite.http.MultiMap.Entry;
-
-import junit.framework.TestCase;
-
-public class MultiMapTest extends TestCase {
-
-    MultiMap map = new MultiMap();
-    MultiMap lmap = new MultiMap().insensitive();
-
-    public void testAdd() {
-        map.add("foo", "bar");
-        assertEquals("bar", map.get("foo").toString());
-    }
-
-    public void testRemove() {
-        map.add("foo", "bar");
-        map.add("foo", "bar");
-        map.add("foo1", "bar");
-        assertEquals(3, map.count);
-        map.remove("foo");
-        assertEquals(1, map.count);
-    }
-
-    public void testRemove1() {
-        map.add("foo", "bar");
-        map.add("foo1", "bar");
-        map.add("foo", "bar");
-        assertEquals(3, map.count);
-        map.remove("foo");
-        assertEquals(1, map.count);
-        map.remove("foo1");
-        assertEquals(0, map.count);
-    }
-
-    public void testCase() {
-        lmap.add("foo", "bar1");
-        lmap.add("Foo", "bar2");
-        lmap.add("a", "bar3");
-        lmap.add("B", "bar4");
-        assertEquals(4, lmap.count);
-        assertEquals(3, lmap.map.size());
-
-        assertEquals("bar3", lmap.getString("a"));
-        assertEquals("bar3", lmap.getString("A"));
-        assertEquals("bar1", lmap.getString("Foo"));
-        Entry entry = lmap.getEntry("FOO");
-        assertEquals(2, entry.values.size());
-    }
-
-}

==================================================
EchoCallback.java
deleted file mode 100644
index 75ef44938c..0000000000
Binary files a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/genrsa_512.der and /dev/null differ

==================================================
SleepCallback.java
deleted file mode 100644
index bd614ec707..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/services/EchoCallback.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.tomcat.lite.http.services;
-
-import java.io.IOException;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.lite.http.Http11Connection;
-import org.apache.tomcat.lite.http.HttpChannel;
-import org.apache.tomcat.lite.http.HttpRequest;
-import org.apache.tomcat.lite.http.HttpResponse;
-import org.apache.tomcat.lite.http.HttpChannel.HttpService;
-import org.apache.tomcat.lite.io.IOBuffer;
-
-/**
- * Response is plain/text, copy of the received request
- */
-public class EchoCallback implements HttpService {
-    Logger log = Logger.getLogger("coyote.static");
-
-    String contentType = "text/plain";
-
-
-    public EchoCallback() {
-    }
-
-    @Override
-    public void service(HttpRequest req, HttpResponse res) throws IOException {
-        HttpChannel sproc = req.getHttpChannel();
-        res.setStatus(200);
-        res.setContentType(contentType);
-
-        IOBuffer tmp = new IOBuffer(null);
-        Http11Connection.serialize(req, tmp);
-
-        sproc.getOut().append("REQ HEAD:\n");
-        sproc.getOut().append(tmp.readAll(null));
-        IOBuffer reqBuf = sproc.getOut();
-
-        reqBuf.append("\nCONTENT_LENGTH:")
-            .append(Long.toString(req.getContentLength()))
-            .append("\n");
-//
-//        sproc.release();
-    }
-
-
-}
\ No newline at end of file

==================================================
BBufferTest.java
deleted file mode 100644
index 3507ff91c1..0000000000
Binary files a/modules/tomcat-lite/test/org/apache/tomcat/lite/http/spdyreqCompressed.bin and /dev/null differ

==================================================
CBufferTest.java
deleted file mode 100644
index ec7c9e9240..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/io/BBufferTest.java
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import org.apache.tomcat.lite.io.BBuffer;
-
-import junit.framework.TestCase;
-
-public class BBufferTest extends TestCase {
-    BBuffer res = BBuffer.wrapper("");
-
-    BBuffer l1 = BBuffer.wrapper("");
-    BBuffer l1a = BBuffer.wrapper("a");
-
-    BBuffer l2 = BBuffer.wrapper("\r");
-    BBuffer l3 = BBuffer.wrapper("\n");
-    BBuffer l4 = BBuffer.wrapper("\r\n");
-    BBuffer l5 = BBuffer.wrapper("\r\na");
-    BBuffer l5_a = BBuffer.wrapper("\ra");
-    BBuffer l5_b = BBuffer.wrapper("\na");
-    BBuffer l6 = BBuffer.wrapper("a\n");
-    BBuffer l7 = BBuffer.wrapper("GET \n");
-    BBuffer l8 = BBuffer.wrapper("GET /\n");
-    BBuffer l9 = BBuffer.wrapper("GET /a?b\n");
-    BBuffer l10 = BBuffer.wrapper("GET /a?b HTTP/1.0\n");
-    BBuffer l11 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b");
-    BBuffer l12 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\n");
-
-    BBuffer f1 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\n\n");
-    BBuffer f2 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\r\n\r\n");
-    BBuffer f3 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\r\r");
-    BBuffer f4 = BBuffer.wrapper("GET /a?b HTTP/1.0\na:b\r\n\r");
-
-    BBuffer s1 = BBuffer.wrapper(" \n");
-    BBuffer s2 = BBuffer.wrapper(" a");
-    BBuffer s3 = BBuffer.wrapper("  ");
-    BBuffer s4 = BBuffer.wrapper("   a");
-
-    BBuffer h1 = BBuffer.wrapper("a");
-    BBuffer h2 = BBuffer.wrapper("a?b");
-    BBuffer h3 = BBuffer.wrapper("a b");
-
-    public void hashTest(String s) {
-        assertEquals(s.hashCode(), BBuffer.wrapper(s).hashCode());
-    }
-
-    public void testHash() {
-        hashTest("");
-        hashTest("a");
-        hashTest("123abc");
-        hashTest("123abc\0");
-        // Fails for UTF chars - only ascii hashTest("123abc\u12345;");
-    }
-
-    public void testReadToSpace() {
-        assertEquals(3, l8.readToSpace(res));
-        assertEquals("GET", res.toString());
-        assertEquals(" /\n", l8.toString());
-
-        assertEquals(0, l1.readToSpace(res));
-        assertEquals("", res.toString());
-        assertEquals("", l1.toString());
-    }
-
-    public void testReadToDelim() {
-        assertEquals(1, h1.readToDelimOrSpace((byte)'?', res));
-        assertEquals("a", res.toString());
-        assertEquals("", h1.toString());
-
-        assertEquals(1, h2.readToDelimOrSpace((byte)'?', res));
-        assertEquals("a", res.toString());
-        assertEquals("?b", h2.toString());
-
-        assertEquals(1, h3.readToDelimOrSpace((byte)'?', res));
-        assertEquals("a", res.toString());
-        assertEquals(" b", h3.toString());
-    }
-
-    public void testGet() {
-        assertEquals(0x20, s1.get(0));
-        assertEquals(0x0a, s1.get(1));
-        try {
-            s1.get(2);
-        } catch(ArrayIndexOutOfBoundsException ex) {
-            return;
-        }
-        fail("Exception");
-    }
-
-    public void testSkipSpace() {
-        assertEquals(1, s1.skipSpace());
-        assertEquals("\n", s1.toString());
-
-        assertEquals(1, s2.skipSpace());
-        assertEquals("a", s2.toString());
-
-        assertEquals(2, s3.skipSpace());
-        assertEquals("", s3.toString());
-
-        assertEquals(3, s4.skipSpace());
-        assertEquals("a", s4.toString());
-
-        assertEquals(0, l1.skipSpace());
-        assertEquals("", l1.toString());
-    }
-
-    public void testLFLF() {
-        assertTrue(f1.hasLFLF());
-        assertTrue(f2.hasLFLF());
-        assertTrue(f3.hasLFLF());
-
-        assertFalse(f4.hasLFLF());
-        assertFalse(l1.hasLFLF());
-        assertFalse(l2.hasLFLF());
-        assertFalse(l3.hasLFLF());
-
-        assertFalse(l10.hasLFLF());
-        assertFalse(l11.hasLFLF());
-        assertFalse(l12.hasLFLF());
-    }
-
-    public void testReadLine() {
-        assertEquals(-1, l1.readLine(res));
-        assertEquals("", res.toString());
-        assertEquals("", l1.toString());
-
-        assertEquals(-1, l1a.readLine(res));
-        assertEquals("", res.toString());
-        assertEquals("a", l1a.toString());
-
-        assertEquals(0, l2.readLine(res));
-        assertEquals("", l2.toString());
-        assertEquals("", res.toString());
-        assertEquals(0, l3.readLine(res));
-        assertEquals("", l3.toString());
-        assertEquals("", res.toString());
-        assertEquals(0, l4.readLine(res));
-        assertEquals("", res.toString());
-
-        assertEquals(0, l5.readLine(res));
-        assertEquals("", res.toString());
-        assertEquals("a", l5.toString());
-        assertEquals(0, l5_b.readLine(res));
-        assertEquals("", res.toString());
-        assertEquals("a", l5_b.toString());
-        assertEquals(0, l5_a.readLine(res));
-        assertEquals("", res.toString());
-        assertEquals("a", l5_a.toString());
-
-        assertEquals(1, l6.readLine(res));
-        assertEquals("a", res.toString());
-
-        assertEquals(4, l7.readLine(res));
-        assertEquals("GET ", res.toString());
-        assertEquals(5, l8.readLine(res));
-        assertEquals("GET /", res.toString());
-
-    }
-}

==================================================
OneTest.java
deleted file mode 100644
index ab064d9434..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/io/CBufferTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import junit.framework.TestCase;
-
-public class CBufferTest extends TestCase {
-
-    CBuffer ext = CBuffer.newInstance();
-
-    public void extTest(String path, String exp) {
-        CBuffer.newInstance().append(path).getExtension(ext, '/', '.');
-        assertEquals(exp, ext.toString());
-    }
-
-    public void testExt() {
-        extTest("foo.jsp", "jsp");
-        extTest("foo.j", "j");
-        extTest("/foo.j", "j");
-        extTest("//foo.j", "j");
-        extTest(".j", "j");
-        extTest(".", "");
-        extTest("/abc", "");
-        extTest("/abc.", "");
-        extTest("/abc/", "");
-        extTest("/abc/d", "");
-    }
-
-    public void testLastIndexOf() {
-
-    }
-}

==================================================
SocksTest.java
deleted file mode 100644
index eb5202a7e4..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/io/OneTest.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-
-import org.apache.tomcat.lite.TestMain;
-import org.apache.tomcat.lite.http.HttpChannel;
-import org.apache.tomcat.lite.io.MemoryIOConnector;
-import org.apache.tomcat.lite.io.MemoryIOConnector.MemoryIOChannel;
-
-import junit.framework.TestCase;
-
-public class OneTest extends TestCase {
-
-    public void setUp() throws Exception {
-        TestMain.getTestServer();
-    }
-
-    public void tearDown() throws IOException {
-    }
-
-
-    public void testOne() throws Exception {
-
-    }
-}

==================================================
UEncoderTest.java
deleted file mode 100644
index 3a1443d1c3..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/io/SocksTest.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.io;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.tomcat.lite.proxy.SocksServer;
-
-
-import junit.framework.TestCase;
-
-public class SocksTest extends TestCase {
-
-    public void setUp() {
-//        SocksServer socks = new SocksServer();
-//        try {
-//            socks.initServer();
-//        } catch (IOException e1) {
-//            // TODO Auto-generated catch block
-//            e1.printStackTrace();
-//        }
-//
-//        ProxySelector.setDefault(new ProxySelector() {
-//
-//            @Override
-//            public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-//            }
-//
-//            @Override
-//            public List<Proxy> select(URI uri) {
-//
-//                List<Proxy> res = new ArrayList<Proxy>();
-//                try {
-//                    res.add(new Proxy(Proxy.Type.SOCKS,
-//                            new InetSocketAddress(InetAddress.getLocalHost(), 1080)));
-//                } catch (UnknownHostException e) {
-//                    // TODO Auto-generated catch block
-//                    e.printStackTrace();
-//                }
-//                return res;
-//            }
-//
-//        });
-    }
-
-    public void testSocks() {
-
-    }
-}

==================================================
LiveHttp5Test.java
deleted file mode 100644
index 19ee5e4afc..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/io/test.properties
+++ /dev/null
@@ -1,33 +0,0 @@
-RUN=Log,JMXProxy,Socks
-
-Log.(class)=org.apache.tomcat.integration.simple.LogConfig
-Log.debug=org.apache.tomcat.async.AsyncHttpConnector
-Log.debug=Proxy
-
-JMXProxy.(class)=org.apache.tomcat.integration.simple.JMXProxy
-JMXProxy.port=8003
-
-Socks.(class)=org.apache.tomcat.async.callbacks.SocksServer
-Socks.port=2080
-Socks.idleTimeout=0
-
-HttpConnector-TestServer.debug=true
-#HttpConnector-TestServer.debugHttp=true
-HttpConnector-TestServer.clientKeepAlive=true
-HttpConnector-TestServer.serverKeepAlive=true
-HttpConnector-TestServer.maxHttpPoolSize=10
-
-HttpConnector.debug=true
-#HttpConnector.debugHttp=true
-HttpConnector.clientKeepAlive=true
-HttpConnector.serverKeepAlive=true
-HttpConnector.maxHttpPoolSize=10
-
-HttpConnector-Proxy.debug=true
-#HttpConnector-Proxy.debugHttp=true
-HttpConnector-Proxy.clientKeepAlive=true
-HttpConnector-Proxy.serverKeepAlive=true
-HttpConnector-Proxy.maxHttpPoolSize=10
-
-
-#IOConnector.debug=true

==================================================
LiveHttpThreadedTest.java
deleted file mode 100644
index d167a5dea9..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/load/LiveHttp5Test.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.load;
-
-import org.apache.tomcat.lite.http.LiveHttp1Test;
-
-import junit.framework.TestSuite;
-
-public class LiveHttp5Test extends LiveHttp1Test {
-
-    /**
-     * Want to run the same tests few times.
-     */
-    public static TestSuite suite() {
-        TestSuite s = new TestSuite();
-        for (int i = 0; i < 5; i++) {
-            s.addTestSuite(LiveHttp1Test.class);
-        }
-        return s;
-    }
-
-    public void test100() throws Exception {
-        for (int i = 0; i < 100; i++) {
-            testSimpleRequest();
-            tearDown();
-            setUp();
-
-            notFound();
-            tearDown();
-            setUp();
-
-            testSimpleRequest();
-            tearDown();
-            setUp();
-        }
-    }
-
-}

==================================================
MicroTest.java
deleted file mode 100644
index 7849f49abb..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/load/LiveHttpThreadedTest.java
+++ /dev/null
@@ -1,292 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.lite.load;
-
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import junit.framework.TestCase;
-
-import org.apache.tomcat.lite.TestMain;
-import org.apache.tomcat.lite.http.HttpClient;
-import org.apache.tomcat.lite.http.HttpChannel;
-import org.apache.tomcat.lite.http.HttpConnector;
-import org.apache.tomcat.lite.http.HttpRequest;
-import org.apache.tomcat.lite.http.HttpChannel.RequestCompleted;
-import org.apache.tomcat.lite.io.BBuffer;
-import org.apache.tomcat.lite.io.SocketConnector;
-
-/*
-  Notes on memory use ( from heap dumps ):
-    - buffers are not yet recycled ( the BBuffers used in channels )
-
-    - each active connection consumes at least 26k - 2 buffers + head buffer
-     ( 8k each )
-     TODO: could 'peak' in the In buffer and move headRecv to HttpChannel
-
-
-    - HttpChannel keeps about 64K ( for the hello world ).
-    -- res is 25k
-    -- req is 32k, BufferedIOReader 16k,
-
-   TODO:
-    - leak in NioThread.active - closed sockets not removed
-    - need to rate-limit and queue requests - OOM
-    - timeouts
-    - seems few responses missing on large async requests (URL works)
- */
-
-/**
- * Long running test - async tests are failing since rate control
- * is not implemented ( too many outstanding requests - OOM ),
- * it seems there is a bug as well.
- */
-public class LiveHttpThreadedTest extends TestCase {
-    HttpConnector clientCon = TestMain.shared().getClient();
-    HttpConnector serverCon = TestMain.shared().getTestServer();
-
-    HttpConnector spdyClient =
-        HttpClient.newClient().setCompression(false);
-
-    HttpConnector spdyClientCompress =
-        HttpClient.newClient();
-
-    HttpConnector spdyClientCompressSsl =
-        HttpClient.newClient();
-
-    ThreadRunner tr;
-    static boolean dumpHeap = true;
-
-    AtomicInteger ok = new AtomicInteger();
-    int reqCnt;
-
-    Map<HttpRequest, HttpRequest> active = new HashMap();
-
-    public void tearDown() throws IOException {
-        clientCon.cpool.clear();
-    }
-
-    public void test1000Async() throws Exception {
-//        try {
-            asyncRequest(10, 100, false, false, clientCon, "AsyncHttp");
-//          } finally {
-//          dumpHeap("heapAsync.bin");
-//      }
-
-    }
-
-    public void test10000Async() throws Exception {
-        asyncRequest(20, 500, false, false, clientCon, "AsyncHttp");
-    }
-
-
-    public void test1000AsyncSsl() throws Exception {
-        asyncRequest(20, 50, false, true, clientCon, "AsyncHttpSsl");
-    }
-
-    public void test10000AsyncSsl() throws Exception {
-        asyncRequest(20, 500, false, true, clientCon, "AsyncHttpSsl");
-    }
-
-    public void test1000AsyncSpdy() throws Exception {
-        asyncRequest(10, 100, true, false, spdyClient, "AsyncSpdy");
-    }
-
-    public void test10000AsyncSpdy() throws Exception {
-        asyncRequest(20, 500, true, false, spdyClient, "AsyncSpdy");
-    }
-
-    public void test1000AsyncSpdyComp() throws Exception {
-            asyncRequest(10, 100, true, false, spdyClientCompress, "AsyncSpdyComp");
-    }
-
-    public void test10000AsyncSpdyComp() throws Exception {
-        asyncRequest(20, 500, true, false, spdyClientCompress, "AsyncSpdyComp");
-    }
-
-    public void xtest1000AsyncSpdySsl() throws Exception {
-        asyncRequest(10, 100, true, true, spdyClient, "AsyncSpdySsl");
-    }
-
-    public void xtest1000AsyncSpdyCompSsl() throws Exception {
-        asyncRequest(10, 100, true, true, spdyClientCompress, "AsyncSpdyCompSsl");
-    }
-
-    public void xtest10000AsyncSpdyCompSsl() throws Exception {
-        asyncRequest(20, 500, true, true, spdyClientCompress, "AsyncSpdyCompSsl");
-    }
-
-    Object thrlock = new Object();
-    Object lock = new Object();
-
-    public void asyncRequest(final int thr, int perthr,
-            final boolean spdy, final boolean ssl,
-            final HttpConnector clientCon, String test) throws Exception {
-        clientCon.getConnectionPool().clear();
-        reqCnt = thr * perthr;
-        long t0 = System.currentTimeMillis();
-
-        tr = new ThreadRunner(thr, perthr) {
-            public void makeRequest(int i) throws Exception {
-                HttpRequest cstate = clientCon.request("localhost",
-                        ssl ? 8443 : 8802);
-                synchronized (active) {
-                    active.put(cstate, cstate);
-                }
-                if (spdy) {
-                    // Magic way to force spdy - will be replaced with
-                    // a negotiation.
-                    cstate.setProtocol("SPDY/1.0");
-                }
-                if (ssl) {
-                    cstate.setSecure(true);
-                }
-                cstate.requestURI().set("/hello");
-                cstate.setCompletedCallback(reqCallback);
-                // no body
-                cstate.getBody().close();
-
-                cstate.send();
-
-                while (active.size() >= thr) {
-                    synchronized(thrlock) {
-                        thrlock.wait();
-                    }
-                }
-            }
-        };
-        tr.run();
-        synchronized (lock) {
-            if (ok.get() < reqCnt) {
-                lock.wait(reqCnt * 100);
-            }
-        }
-        long time = (System.currentTimeMillis() - t0);
-
-        System.err.println("====== " + test +
-                " threads: " + thr + ", req: " +
-                reqCnt + ", sendTime" + tr.time +
-                ", time: " + time +
-                ", connections: " + clientCon.getConnectionPool().getSocketCount() +
-                ", avg: " + (time / reqCnt));
-
-        assertEquals(reqCnt, ok.get());
-        assertEquals(0, tr.errors.get());
-    }
-
-    RequestCompleted reqCallback = new RequestCompleted() {
-        @Override
-        public void handle(HttpChannel data, Object extraData)
-        throws IOException {
-            String out = data.getIn().copyAll(null).toString();
-            if (200 != data.getResponse().getStatus()) {
-                System.err.println("Wrong status");
-                tr.errors.incrementAndGet();
-            } else if (!"Hello world".equals(out)) {
-                tr.errors.incrementAndGet();
-                System.err.println("bad result " + out);
-            }
-            synchronized (active) {
-                active.remove(data.getRequest());
-            }
-            synchronized (thrlock) {
-                thrlock.notify();
-            }
-            data.release();
-            int okres = ok.incrementAndGet();
-            if (okres >= reqCnt) {
-                synchronized (lock) {
-                    lock.notify();
-                }
-            }
-        }
-    };
-
-
-
-    public void testURLRequest1000() throws Exception {
-        urlRequest(10, 100, false, "HttpURLConnection");
-    }
-
-    public void xtestURLRequest10000() throws Exception {
-        urlRequest(20, 500, false, "HttpURLConnection");
-
-    }
-
-    // I can't seem to get 1000 requests to all complete...
-    public void xtestURLRequestSsl100() throws Exception {
-        urlRequest(10, 10, true, "HttpURLConnectionSSL");
-    }
-
-    public void xtestURLRequestSsl10000() throws Exception {
-        urlRequest(20, 500, true, "HttpURLConnectionSSL");
-
-    }
-
-    /**
-     * HttpURLConnection client against lite.http server.
-     */
-    public void urlRequest(int thr, int cnt, final boolean ssl, String test)
-            throws Exception {
-        long t0 = System.currentTimeMillis();
-
-
-        try {
-            HttpConnector testServer = TestMain.getTestServer();
-
-            tr = new ThreadRunner(thr, cnt) {
-
-                public void makeRequest(int i) throws Exception {
-                    try {
-                        BBuffer out = BBuffer.allocate();
-                        String url = ssl ? "https://localhost:8443/hello" :
-                            "http://localhost:8802/hello";
-                        HttpURLConnection con =
-                            TestMain.getUrl(url, out);
-                        if (con.getResponseCode() != 200) {
-                            errors.incrementAndGet();
-                        }
-                        if (!"Hello world".equals(out.toString())) {
-                            errors.incrementAndGet();
-                            System.err.println("bad result " + out);
-                        }
-                    } catch(Throwable t) {
-                        t.printStackTrace();
-                        errors.incrementAndGet();
-                    }
-                }
-            };
-            tr.run();
-            assertEquals(0, tr.errors.get());
-            long time = (System.currentTimeMillis() - t0);
-
-            System.err.println("====== " + test + " threads: " + thr + ", req: " +
-                    (thr * cnt) + ", time: " + time + ", avg: " +
-                    (time / (thr * cnt)));
-        } finally {
-            //dumpHeap("heapURLReq.bin");
-        }
-    }
-
-    // TODO: move to a servlet
-
-
-}

==================================================
ThreadRunner.java
deleted file mode 100644
index 732205e518..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/load/MicroTest.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.load;
-
-import org.apache.tomcat.lite.http.BaseMapper;
-import org.apache.tomcat.lite.http.MappingData;
-import org.apache.tomcat.lite.io.CBuffer;
-
-import junit.framework.TestCase;
-
-public class MicroTest extends TestCase {
-
-    public void testMapper() throws Exception {
-        BaseMapper mapper = new BaseMapper();
-
-        MappingData mappingData = new MappingData();
-        CBuffer host = CBuffer.newInstance();
-        host.set("test1.com");
-
-        CBuffer uri = CBuffer.newInstance();
-        uri.set("/foo/bar/blah/bobou/foo");
-
-        String[] welcomes = new String[2];
-        welcomes[0] = "index.html";
-        welcomes[1] = "foo.html";
-
-        for (int i = 0; i < 100; i++) {
-            String hostN = "test" + i + ".com";
-            mapper.addContext(hostN, "", "context0", new String[0], null, null);
-            mapper.addContext(hostN, "/foo", "context1", new String[0], null, null);
-            mapper.addContext(hostN, "/foo/bar", "context2", welcomes, null, null);
-            mapper.addContext(hostN, "/foo/bar/bla", "context3", new String[0], null, null);
-
-            mapper.addWrapper(hostN, "/foo/bar", "/fo/*", "wrapper0");
-        }
-        int N = 10000;
-        for (int i = 0; i < N; i++) {
-            mappingData.recycle();
-            mapper.map(host, uri, mappingData);
-        }
-
-        long time = System.currentTimeMillis();
-        for (int i = 0; i < N; i++) {
-            mappingData.recycle();
-            mapper.map(host, uri, mappingData);
-        }
-        // TODO: asserts
-        //System.out.println("Elapsed:" + (System.currentTimeMillis() - time));
-    }
-}

==================================================
LiveProxyHttp1Test.java
deleted file mode 100644
index 098f5b8bfb..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/load/ThreadRunner.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.load;
-
-import java.util.concurrent.atomic.AtomicInteger;
-
-public class ThreadRunner {
-    int tCount = 10;
-    int rCount = 100;
-    Thread[] threads;
-    int[] ok;
-
-    int sleepTime = 0;
-
-    long time;
-    protected AtomicInteger errors = new AtomicInteger();
-
-    public ThreadRunner(int threads, int count) {
-        tCount = threads;
-        rCount = count;
-        this.threads = new Thread[tCount];
-        ok = new int[tCount];
-    }
-
-    public void run() {
-        long t0 = System.currentTimeMillis();
-        for (int i = 0; i < tCount; i++) {
-          final int j = i;
-          threads[i] = new Thread(new Runnable() {
-            public void run() {
-              makeRequests(j);
-            }
-          });
-          threads[i].start();
-        }
-
-        int res = 0;
-        for (int i = 0; i < tCount; i++) {
-          try {
-            threads[i].join();
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }
-          res += ok[i];
-        }
-        long t1 = System.currentTimeMillis();
-        time = t1 - t0;
-    }
-
-    public void makeRequests(int cnt) {
-        for (int i = 0; i < rCount ; i++) {
-            try {
-              //System.err.println("MakeReq " + t + " " + i);
-              makeRequest(cnt);
-            } catch (Exception e) {
-              e.printStackTrace();
-            }
-          }
-    }
-
-    public void makeRequest(int i) throws Exception {
-
-    }
-}
\ No newline at end of file

==================================================
ProxyTest.java
deleted file mode 100644
index d04d624de6..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/proxy/LiveProxyHttp1Test.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.lite.proxy;
-
-
-import java.io.IOException;
-
-import org.apache.tomcat.lite.http.LiveHttp1Test;
-
-
-public class LiveProxyHttp1Test extends LiveHttp1Test {
-    public void setUp() throws IOException {
-        // All tests in super, but with client pointing to
-        // the proxy server, which in turn hits the real server.
-        clientPort = 8903;
-        super.setUp();
-  }
-
-}

==================================================
SmallProxyTest.java
deleted file mode 100644
index 9d3181c8bb..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/proxy/ProxyTest.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
-n * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.lite.proxy;
-
-import java.io.IOException;
-
-import org.apache.tomcat.lite.TestMain;
-
-import junit.framework.TestCase;
-
-
-public class ProxyTest extends TestCase {
-
-  String resStr;
-
-  public void setUp() throws Exception {
-      TestMain.getTestServer();
-  }
-
-  public void tearDown() throws IOException {
-  }
-
-  public void xtestRequestSlowChunked() throws Exception {
-      resStr =
-          TestMain.get("http://localhost:8903/sleep/1c").toString();
-      assertEquals("sleep 1csleep 1c", resStr);
-  }
-
-  public void testSingleRequest() throws Exception {
-      String resStr =
-          TestMain.get("http://localhost:8903/hello").toString();
-      assertEquals("Hello world", resStr);
-  }
-
-
-  public void test2Requests() throws Exception {
-      String resStr =
-          TestMain.get("http://localhost:8903/hello").toString();
-      assertEquals("Hello world", resStr);
-      resStr =
-          TestMain.get("http://localhost:8903/hello?a=b").toString();
-      assertEquals("Hello world", resStr);
-  }
-
-  public void testRequestSimple() throws Exception {
-      resStr =
-          TestMain.get("http://localhost:8903/hello").toString();
-      assertEquals("Hello world", resStr);
-      resStr =
-          TestMain.get("http://localhost:8903/hello").toString();
-      assertEquals("Hello world", resStr);
-      resStr =
-          TestMain.get("http://localhost:8903/hello").toString();
-      assertEquals(resStr, "Hello world");
-
-  }
-
-  public void testExtAdapter() throws Exception {
-      String res =
-              TestMain.get("http://www.apache.org/").toString();
-      assertTrue(res.indexOf("Apache") > 0);
-
-      Thread.currentThread().sleep(100);
-      // second time - are we reusing ?
-      res =
-          TestMain.get("http://www.apache.org/").toString();
-
-      assertTrue(res.indexOf("Apache") > 0);
-
-  }
-
-  public void testStaticAdapter() throws Exception {
-
-      assertEquals("Hello world",
-          TestMain.get("http://localhost:8802/hello").toString());
-      assertEquals("Hello world2",
-          TestMain.get("http://localhost:8802/2nd").toString());
-
-    }
-
-  public void testRequestParams() throws Exception {
-      // qry string
-      String resStr =
-          TestMain.get("http://localhost:8903/echo/foo?q=a&b")
-          .toString();
-      assertTrue(resStr, resStr.indexOf("foo?q=a&b") > 0);
-  }
-
-
-  public void testRequestChunked() throws Exception {
-      // Chunked encoding
-      String resStr =
-          TestMain.get("http://localhost:8903/chunked/test")
-          .toString();
-      assertEquals(4, resStr.length());
-      assertTrue(resStr.indexOf("AAA") >= 0);
-  }
-
-
-  public void testRequestSlow() throws Exception {
-      // Slow
-      String resStr =
-          TestMain.get("http://localhost:8903/sleep/1").toString();
-      assertEquals("sleep 1sleep 1", resStr.toString());
-  }
-}

==================================================
UEncoderTest.java
deleted file mode 100644
index bc8bac9f72..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/proxy/SmallProxyTest.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- */
-package org.apache.tomcat.lite.proxy;
-
-import java.io.IOException;
-
-import junit.framework.TestCase;
-
-import org.apache.tomcat.lite.http.HttpChannel;
-import org.apache.tomcat.lite.http.HttpConnector;
-import org.apache.tomcat.lite.http.HttpConnector.HttpConnection;
-import org.apache.tomcat.lite.io.MemoryIOConnector;
-import org.apache.tomcat.lite.io.MemoryIOConnector.MemoryIOChannel;
-
-public class SmallProxyTest extends TestCase {
-
-    MemoryIOConnector memoryServerConnector =
-        new MemoryIOConnector();
-
-    MemoryIOConnector memoryClientConnector =
-        new MemoryIOConnector().withServer(memoryServerConnector);
-
-
-    HttpConnector httpCon = new HttpConnector(memoryServerConnector) {
-        @Override
-        public HttpChannel get(CharSequence target) throws IOException {
-            throw new IOException();
-        }
-        public HttpChannel getServer() {
-            lastServer = new HttpChannel().serverMode(true);
-            lastServer.setConnector(this);
-            //lastServer.withIOConnector(memoryServerConnector);
-            return lastServer;
-        }
-    };
-
-    HttpConnector httpClient = new HttpConnector(memoryClientConnector) {
-        @Override
-        public HttpChannel get(CharSequence target) throws IOException {
-            lastClient = new HttpChannel();
-            lastClient.setConnector(this);
-            return lastClient;
-        }
-        public HttpChannel get(String host, int port) throws IOException {
-            lastClient = new HttpChannel();
-            lastClient.setConnector(this);
-            return lastClient;
-        }
-        public HttpChannel getServer() {
-            throw new RuntimeException();
-        }
-    };
-
-    HttpChannel lastServer;
-    HttpChannel lastClient;
-
-    boolean hasBody = false;
-    boolean bodyDone = false;
-    boolean bodySentDone = false;
-    boolean headersDone = false;
-    boolean allDone = false;
-
-
-    //MemoryIOChannel clientNet = new MemoryIOChannel();
-
-    MemoryIOConnector.MemoryIOChannel net = new MemoryIOChannel();
-    HttpChannel http;
-
-    HttpConnection serverConnection;
-
-    public void setUp() throws IOException {
-        http = httpCon.getServer();
-        serverConnection = httpCon.handleAccepted(net);
-    }
-
-    /**
-     * More complicated test..
-     * @throws IOException
-     */
-    public void testProxy() throws IOException {
-        httpCon.setHttpService(new HttpProxyService()
-            .withSelector(memoryClientConnector)
-            .withHttpClient(httpClient));
-
-        net.getIn().append("GET http://www.apache.org/ HTTP/1.0\n" +
-                "Connection: Close\n\n");
-        net.getIn().close();
-
-        // lastClient.rawSendBuffers has the request sent by proxy
-        lastClient.getNet().getIn()
-            .append("HTTP/1.0 200 OK\n\nHi\n");
-        lastClient.getNet().getIn()
-            .append("world\n");
-
-        // TODO: check what the proxy sent
-        // lastClient.getOut();
-
-        // will also trigger 'release' - both sides are closed.
-        lastClient.getNet().getIn().close();
-
-        // wait response...
-        // http.sendBody.close();
-        String res = net.out.toString();
-        assertTrue(res.indexOf("Hi\nworld\n") > 0);
-        assertTrue(res.indexOf("HTTP/1.0 200 OK") == 0);
-        assertTrue(res.indexOf("tomcatproxy") > 0);
-
-    }
-}

==================================================
AntProperties.java
deleted file mode 100644
index ba606f09c6..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/lite/util/UEncoderTest.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.lite.util;
-
-import junit.framework.TestCase;
-
-public class UEncoderTest extends TestCase {
-    URLEncoder enc=new URLEncoder();
-
-    /*
-     *
-     * Test method for 'org.apache.tomcat.util.buf.UEncoder.encodeURL(String)'
-     * TODO: find the relevant rfc and apache tests and add more
-     */
-    public void testEncodeURL() {
-
-        String eurl1=enc.encodeURL("test");
-        assertEquals("test", eurl1);
-
-        eurl1=enc.encodeURL("/test");
-        assertEquals("/test", eurl1);
-
-        // safe ranges
-        eurl1=enc.encodeURL("test$-_.");
-        assertEquals("test$-_.", eurl1);
-
-        eurl1=enc.encodeURL("test$-_.!*'(),");
-        assertEquals("test$-_.!*'(),", eurl1);
-
-        eurl1=enc.encodeURL("//test");
-        assertEquals("//test", eurl1);
-
-
-    }
-
-}

==================================================
CookieController.java
deleted file mode 100644
index 7e1b03b072..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/AntProperties.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- */
-package org.apache.tomcat.test.watchdog;
-
-import java.util.Hashtable;
-
-/**
- * Extracted from IntrospectionHelper - a simple utility class to
- * do ant style ${property} replacements on a string, using a map
- * holding properties. Also allows a hook for dynamic, on-demand
- * properties.
- *
- * @author Costin Manolache
- */
-public class AntProperties {
-    public static interface PropertySource {
-        public String getProperty(String key);
-    }
-
-    /**
-     * Replace ${NAME} with the property value
-     */
-    public static String replaceProperties(String value,
-            Hashtable<Object,Object> staticProp, PropertySource dynamicProp[]) {
-        if (value.indexOf("$") < 0) {
-            return value;
-        }
-        StringBuffer sb = new StringBuffer();
-        int prev = 0;
-        // assert value!=nil
-        int pos;
-        while ((pos = value.indexOf("$", prev)) >= 0) {
-            if (pos > 0) {
-                sb.append(value.substring(prev, pos));
-            }
-            if (pos == (value.length() - 1)) {
-                sb.append('$');
-                prev = pos + 1;
-            } else if (value.charAt(pos + 1) != '{') {
-                sb.append('$');
-                prev = pos + 1; // XXX
-            } else {
-                int endName = value.indexOf('}', pos);
-                if (endName < 0) {
-                    sb.append(value.substring(pos));
-                    prev = value.length();
-                    continue;
-                }
-                String n = value.substring(pos + 2, endName);
-                String v = null;
-                if (staticProp != null) {
-                    v = (String) staticProp.get(n);
-                }
-                if (v == null && dynamicProp != null) {
-                    for (int i = 0; i < dynamicProp.length; i++) {
-                        v = dynamicProp[i].getProperty(n);
-                        if (v != null) {
-                            break;
-                        }
-                    }
-                }
-                if (v == null)
-                    v = "${" + n + "}";
-
-                sb.append(v);
-                prev = endName + 1;
-            }
-        }
-        if (prev < value.length())
-            sb.append(value.substring(prev));
-        return sb.toString();
-    }
-
-
-}

==================================================
DynamicObject.java
deleted file mode 100644
index 0c7e64c586..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/CookieController.java
+++ /dev/null
@@ -1,636 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.test.watchdog;
-
-import java.io.BufferedReader;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.FileReader;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.net.URL;
-import java.util.Enumeration;
-import java.util.Hashtable;
-import java.util.Properties;
-import java.util.Vector;
-
-
-/**
- * Represents a collection of Cookie instances.
- * <p>
- * Fires events when the cookies have been changed internally. Deals
- * with management of cookies in terms of saving and loading them,
- * and disabling them.
- *
- * @author	Ramesh.Mandava
- */
-public class CookieController {
-
-//    private VetoableChangeSupport vceListeners;
-
-    private static Hashtable cookieJar = new Hashtable();
-
-    /* public no arg constructor for bean */
-    public CookieController() {
-    }
-
-/////////////////////////////////////////////////////////////
- /**
-     * Records any cookies which have been sent as part of an HTTP response.
-     * The connection parameter must be already have been opened, so that
-     * the response headers are available.  It's ok to pass a non-HTTP
-     * URL connection, or one which does not have any set-cookie headers.
-     */
-    public void recordAnyCookies(Vector rcvVectorOfCookies , URL url ) {
-
-	if ((rcvVectorOfCookies == null) || ( rcvVectorOfCookies.size()== 0) ) {
-	    // no headers here
-	    return;
-	}	
-	try {
-	/*
-        Properties properties = new Properties();
-	FileInputStream fin = new FileInputStream("ServerAutoRun.properties");
-	properties.load(fin);
-
-	String cookiepolicy = properties.getProperty("cookie.acceptpolicy");
-	if (cookiepolicy == null || cookiepolicy.equals("none")) {
-	    return;
-	}
-	*/
-
-
-	for (int hi = 0; hi<rcvVectorOfCookies.size(); hi++) {
-
-		String cookieValue = (String)rcvVectorOfCookies.elementAt(hi) ;
-		recordCookie(url, cookieValue); // What to do here
-	    }
-
-	}
-	catch( Exception e )
-	{
-		System.out.println("exception : " + e );
-	}
-    }
-
-
-    /**
-     * Create a cookie from the cookie, and use the HttpURLConnection to
-     * fill in unspecified values in the cookie with defaults.
-     */
-    public void recordCookie(URL url,
-				     String cookieValue) {
-	HttpCookie cookie = new HttpCookie(url, cookieValue);
-	
-	// First, check to make sure the cookie's domain matches the
-	// server's, and has the required number of '.'s
-	String twodot[]=
-	    {"com", "edu", "net", "org", "gov", "mil", "int"};
-	String domain = cookie.getDomain();
-	if( domain == null )
-	    return;
-	int index = domain.indexOf(':');
-	if (index != -1) {
-	    int portCookie;
-	    try {
-		portCookie = (Integer.valueOf(domain.substring(index+1,domain.length()))).intValue();
-	    } catch (Exception e) {
-		return;
-	    }
-	    portCookie = ( portCookie == -1 ) ? 80 : portCookie;
-	    domain=domain.substring(0,index);
-	}
-	domain.toLowerCase();
-	
-	String host = url.getHost();
-	host.toLowerCase();
-
-	boolean domainOK = host.equals(domain);
-	if( !domainOK && host.endsWith( domain ) ) {
-	    int dotsNeeded = 2;
-	    for( int i = 0; i < twodot.length; i++ ) {
-		if( domain.endsWith( twodot[i] ) ) {
-		    dotsNeeded = 1;
-		}
-	    }
-
-	    int lastChar = domain.length();
-	    for( ; lastChar > 0 && dotsNeeded > 0; dotsNeeded-- ) {
-		lastChar = domain.lastIndexOf( '.', lastChar-1 );
-	    }
-
-	    if( lastChar > 0 )
-		domainOK = true;
-	}
-
-	if( domainOK ) {
-	    recordCookie(cookie);
-
-	}
-    }
-
-
-    /**
-     * Record the cookie in the in-memory container of cookies.  If there
-     * is already a cookie which is in the exact same domain with the
-     * exact same
-     */
-    public void recordCookie(HttpCookie cookie) {
-	if (!checkIfCookieOK(cookie)) {
-	    return;
-	}
-	synchronized (cookieJar) {
-	
-	    String domain = cookie.getDomain().toLowerCase();
-
-	    Vector cookieList = (Vector)cookieJar.get(domain);
-	    if (cookieList == null) {
-		cookieList = new Vector();
-	    }
-
-	    addOrReplaceCookie(cookieList, cookie);
-	    cookieJar.put(domain, cookieList);
-	
-	}
-
-    }
-
-    public boolean checkIfCookieOK(HttpCookie cookie) {
-	return true;
-    }
-
-    /**
-     * Scans the vector of cookies looking for an exact match with the
-     * given cookie.  Replaces it if there is one, otherwise adds
-     * one at the end.  The vector is presumed to have cookies which all
-     * have the same domain, so the domain of the cookie is not checked.
-     * <p>
-     * <p>
-     * If this is called, it is assumed that the cookie jar is exclusively
-     * held by the current thread.
-     *
-     */
-    private void addOrReplaceCookie(Vector cookies,
-				       HttpCookie cookie) {
-	int numCookies = cookies.size();
-
-	String path = cookie.getPath();
-	String name = cookie.getName();
-	HttpCookie replaced = null;
-	int replacedIndex = -1;
-
-	for (int i = 0; i < numCookies; i++) {
-	    HttpCookie existingCookie = (HttpCookie)cookies.elementAt(i);
-	
-	    String existingPath = existingCookie.getPath();
-	    if (path.equals(existingPath)) {
-		String existingName = existingCookie.getName();
-		if (name.equals(existingName)) {
-		    // need to replace this one!
-		    replaced = existingCookie;
-		    replacedIndex = i;
-		    break;
-		}
-	    }
-	}
-	
-	
-	// Do the replace - if cookie has already expired, remove
-	// the replaced cookie.
-	if (replaced != null) {
-	    if (cookie.isSaveableInMemory()) {
-		cookies.setElementAt(cookie, replacedIndex);
-		//System.out.println("REPLACED existing cookie with " + cookie);
-	    } else {
-		cookies.removeElementAt(replacedIndex);
-		//System.out.println("Removed cookie b/c or expr " + cookie);
-	    }
-
-	} else { // only save the cookie in memory if it is non persistent
-          	 // or not expired.
-	    if (cookie.isSaveableInMemory()) {
-		cookies.addElement(cookie);
-		//System.out.println("RECORDED new cookie " + cookie);
-	    }
-
-	}
-
-    }
-
-    public String applyRelevantCookies(URL url ) {
-
-       try {	
-		/*
-		Properties properties = new Properties();
-		FileInputStream fin = new FileInputStream("ServerAutoRun.properties");
-		properties.load(fin);
-		// check current accept policy instead enableCookies
-		String cookiepolicy = properties.getProperty("cookie.acceptpolicy");
-		if (cookiepolicy == null || cookiepolicy.equals("none")) {
-		    return null;
-		}
-
-		*/
-
-		return applyCookiesForHost(url);
-
-	}
-	catch ( Exception e )
-	{
-		System.out.println("Exception : " +e );
-		return null;
-	}
-
-
-    }
-
-
-   /**
-     * Host may be a FQDN, or a partial domain name starting with a dot.
-     * Adds any cookies which match the host and path to the
-     * cookie set on the URL connection.
-     */
-    private String applyCookiesForHost(URL url ){
-	String cookieString = null;
-	Vector cookieVector = getAllRelevantCookies(url);
-	
-	if (cookieVector != null) {
-
-	    for (Enumeration e = cookieVector.elements(); e.hasMoreElements();) {
-		HttpCookie cookie = (HttpCookie)e.nextElement();
-		if( cookieString == null ) {
-		    cookieString = cookie.getNameValue();
-		} else {
-		    cookieString = cookieString + "; " + cookie.getNameValue();
-		}
-	    }
-	
-	 /*
-
-	    if( cookieString != null ) {
-		httpConn.setRequestProperty("Cookie", cookieString);
-	
-//		System.out.println("Returned cookie string: " + cookieString + " for HOST = " + host);
-	     }
-
-	  */
-
-
-	}
-//		System.out.println("Returned cookie string: " + cookieString + " for HOST = " + host);
-	return cookieString;
-	
-    }
-
-    private Vector getAllRelevantCookies(URL url) {
-	String host = url.getHost();
-	Vector cookieVector = getSubsetRelevantCookies(host, url);
-
-	Vector tempVector;
-	int index;
-
-	while ((index = host.indexOf('.', 1)) >= 0) {
-	    // trim off everything up to, and including the dot.
-	    host = host.substring(index+1);
-	
-            // add onto cookieVector
-	    tempVector = getSubsetRelevantCookies(host,url);
-	    if (tempVector != null ) {
-		for (Enumeration e = tempVector.elements(); e.hasMoreElements(); ) {
-		    if (cookieVector == null) {
-			cookieVector = new Vector(2);
-		    }
-
-		    cookieVector.addElement(e.nextElement());
-
-		}
-	    }
-	}
-	return cookieVector;
-    }
-
-    private Vector getSubsetRelevantCookies(String host, URL url) {
-
-	Vector cookieList = (Vector)cookieJar.get(host);
-	
-//	System.out.println("getRelevantCookies() .. for host, url " + host +", "+url);
-	Vector cookiePortList = (Vector)cookieJar.get(host+":"+((url.getPort() == -1) ? 80 : url.getPort()));
-	if (cookiePortList != null) {
-	    if (cookieList == null) {
-		cookieList = new Vector(10);
-	    }
-	    Enumeration cookies = cookiePortList.elements();
-	    while (cookies.hasMoreElements()) {
-		cookieList.addElement(cookies.nextElement());
-	    }
-	}
-	
-	
-	if (cookieList == null) {
-	    return null;
-	}
-
-	String path = url.getFile();
-//	System.out.println("        path is " + path + "; protocol = " + url.getProtocol());
-
-
-	int queryInd = path.indexOf('?');
-	if (queryInd > 0) {
-	    // strip off the part following the ?
-	    path = path.substring(0, queryInd);
-	}
-
-	Enumeration cookies = cookieList.elements();
-	Vector cookiesToSend = new Vector(10);
-
-	while (cookies.hasMoreElements()) {
-	    HttpCookie cookie = (HttpCookie)cookies.nextElement();
-	
-	    String cookiePath = cookie.getPath();
-
-	    if (path.startsWith(cookiePath)) {
-		// larrylf: Actually, my documentation (from Netscape)
-		// says that /foo should
-		// match /foobar and /foo/bar.  Yuck!!!
-
-		if (!cookie.hasExpired()) {
-		    cookiesToSend.addElement(cookie);
-		}
-
-/*
-   We're keeping this piece of commented out code around just in
-   case we decide to put it back.  the spec does specify the above,
-   but it is so disgusting!
-
-		int cookiePathLen = cookiePath.length();
-
-		// verify that /foo does not match /foobar by mistake
-		if ((path.length() == cookiePathLen)
-		    || (path.length() > cookiePathLen &&
-			path.charAt(cookiePathLen) == '/')) {
-		
-		    // We have a matching cookie!
-
-		    if (!cookie.hasExpired()) {
-			cookiesToSend.addElement(cookie);
-		    }
-		}
-*/
-	    }
-	}
-
-	// Now, sort the cookies in most to least specific order
-	// Yes, its the deaded bubblesort!! Wah Ha-ha-ha-ha....
-	// (it should be a small vector, so perf is not an issue...)
-	if( cookiesToSend.size() > 1 ) {
-	    for( int i = 0; i < cookiesToSend.size()-1; i++ ) {
-		HttpCookie headC = (HttpCookie)cookiesToSend.elementAt(i);
-		String head = headC.getPath();
-		// This little excercise is a cheap way to get
-		// '/foo' to read more specfic then '/'
-		if( !head.endsWith("/") ) {
-		    head = head + "/";
-		}
-		for( int j = i+1; j < cookiesToSend.size(); j++ ) {
-		    HttpCookie scanC = (HttpCookie)cookiesToSend.elementAt(j);
-		    String scan = scanC.getPath();
-		    if( !scan.endsWith("/") ) {
-			scan = scan + "/";
-		    }
-
-		    int headCount = 0;
-		    int index = -1;
-		    while( (index=head.indexOf('/', index+1)) != -1 ) {
-			headCount++;
-		    }
-		    index = -1;
-
-		    int scanCount = 0;
-		    while( (index=scan.indexOf('/', index+1)) != -1 ) {
-			scanCount++;
-		    }
-
-		    if( scanCount > headCount ) {
-			cookiesToSend.setElementAt(headC, j);
-			cookiesToSend.setElementAt(scanC, i);
-			headC = scanC;
-			head = scan;
-		    }
-		}
-	    }
-	}
-
-
-    return cookiesToSend;
-
-    }
-
-    /*
-     * Writes cookies out to PrintWriter if they are persistent
-     * (i.e. have a expr date)
-     * and haven't expired. Will remove cookies that have expired as well
-     */
-    private void saveCookiesToStream(PrintWriter pw) {
-
-	Enumeration cookieLists = cookieJar.elements();
-		
-	while (cookieLists.hasMoreElements()) {
-	    Vector cookieList = (Vector)cookieLists.nextElement();
-
-	    Enumeration cookies = cookieList.elements();
-
-	    while (cookies.hasMoreElements()) {
-		HttpCookie cookie = (HttpCookie)cookies.nextElement();
-		
-		if (cookie.getExpirationDate() != null) {
-		    if (cookie.isSaveable()) {
-			pw.println(cookie);
-		    } else { // the cookie must have expired,
-			//remove from Vector cookieList
-			cookieList.removeElement(cookie);
-		    }
-		
-		}
-	    }
-	}
-        // Must print something to the printwriter in the case that
-	// the cookieJar has been cleared - otherwise the old cookie
-	// file will continue to exist.
-	pw.print("");
-    }
-/////////////////////////////////////////////////////////////
-    /* adds cookieList to the existing cookie jar*/
-    public void addToCookieJar(HttpCookie[] cookieList) {
-
-	if (cookieList != null) {
-	    for (int i = 0; i < cookieList.length; i++) {
-		
-		recordCookie(cookieList[i]);
-	    }
-	}
-
-    }
-
-    /*adds one cookie to the Cookie Jar */
-    public void addToCookieJar(String cookieString, URL docURL) {
-	recordCookie(new HttpCookie(docURL, cookieString));
-    }
-
-    /* loads the cookies from the given filename */
-    public void loadCookieJarFromFile(String cookieFileName) {
-	try {
-	    FileReader fr = new FileReader(cookieFileName);
-	
-	    BufferedReader in = new BufferedReader(fr);
-
-	    try {
-		String cookieString;
-		while ((cookieString = in.readLine()) != null) {
-		    HttpCookie cookie = new HttpCookie(cookieString);
-		    // Record the cookie, without notification.  We don't
-		    // do a notification for cookies that are read at
-		    // program start-up.
-		    recordCookie(cookie);
-		}
-	    } finally {
-		in.close();
-	    }
-
-	
-	} catch (IOException e) {
-	    // do nothing; it's not an error not to have persistent cookies
-	}
-
-    }
-
-    /* saves the cookies to the given file specified by fname */
-    public void saveCookieJarToFile(String cookieFileName) {
-	try {
-	    FileWriter fw = new FileWriter(cookieFileName);
-	    PrintWriter pw = new PrintWriter(fw, false);
-
-	    try {
-		saveCookiesToStream(pw);
-	    } finally {
-		pw.close();
-	    }
-
-	} catch (IOException e) {
-	    // REMIND: I18N
-	    System.err.println("Saving cookies failed " + e.getMessage());
-	}
-    }
-
-    /**
-     * Return an array with all of the cookies represented by this
-     * jar.  This is useful when the bean is shutting down, and the client
-     * wants to make the cookie jar persist.
-     */
-    public HttpCookie[] getAllCookies() {
-
-	Vector result = new Vector();
-	Hashtable jar;
-	jar = (Hashtable) cookieJar.clone();
-	
-	synchronized (jar) {
-	
-	    for (Enumeration e = jar.elements(); e.hasMoreElements() ;) {
-		Vector v = (Vector) e.nextElement();
-		for (int i = 0; i < v.size(); i++) {
-		    HttpCookie hc = (HttpCookie) v.elementAt(i);
-		    result.addElement(hc);
-		
-		}
-		
-	    }
-	}
-
-	HttpCookie[] resultA = new HttpCookie[result.size()];
-	for (int i = 0; i < result.size(); i++) {
-	    resultA[i] = (HttpCookie) result.elementAt(i);
-	}
-	return resultA;
-    }
-
-    /* Gets all cookies that applies for the URL */
-    public HttpCookie[] getCookiesForURL(URL url) {
-
-	Vector cookieVector = getAllRelevantCookies(url);
-
-	if (cookieVector == null) {
-	    return null;
-	}
-
-	int i = 0;
-	HttpCookie[] cookieArr = new HttpCookie[cookieVector.size()];
-
-	for (Enumeration e = cookieVector.elements(); e.hasMoreElements(); ) {
-
-	    cookieArr[i++] = (HttpCookie)e.nextElement();
-//	    System.out.println("cookieArr["+(i-1)+"] = " +cookieArr[i-1].toString());
-	}
-	
-	return cookieArr;
-    }
-
-    /* this will set the property of enableCookies to isDisabled */
-    public void setCookieDisable(boolean isDisabled) {
-
-	// Pending visit back this again
-	try {
-	Properties properties = new Properties();
-	properties.load(new FileInputStream("ServerAutoRun.properties") );
-	
-	
-	properties.put("enableCookies", isDisabled ? "false" : "true");
-	properties.store(new FileOutputStream("ServerAutoRun.properties"),"comments");
-	}
-	catch ( Exception e )
-	{
-		System.out.println("Exception : " + e );
-	}
-    }
-
-    public void discardAllCookies() {
-	cookieJar.clear();
-	
-    }
-
-    /*
-     * purges any expired cookies in the Cookie hashtable.
-     */
-    public void purgeExpiredCookies() {
-	Enumeration cookieLists = cookieJar.elements();
-		
-	while (cookieLists.hasMoreElements()) {
-	    Vector cookieList = (Vector)cookieLists.nextElement();
-
-	    Enumeration cookies = cookieList.elements();
-
-	    while (cookies.hasMoreElements()) {
-		HttpCookie cookie = (HttpCookie)cookies.nextElement();
-		
-		if (cookie.hasExpired()) {
-		    cookieList.removeElement(cookie);
-		}
-	    }
-	}
-
-    }
-
-}

==================================================
HttpCookie.java
deleted file mode 100644
index c01b5bedbb..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/DynamicObject.java
+++ /dev/null
@@ -1,385 +0,0 @@
-/*
- */
-package org.apache.tomcat.test.watchdog;
-
-import java.lang.reflect.AccessibleObject;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-/**
- * Refactoring of IntrospectionUtils and modeler dynamic bean.
- *
- * Unlike IntrospectionUtils, the method informations can be cached.
- * Also I hope this class will be simpler to use.
- * There is no static cache.
- *
- * @author Costin Manolache
- */
-public class DynamicObject {
-    // Based on MbeansDescriptorsIntrospectionSource
-
-    private static Logger log = Logger.getLogger(DynamicObject.class.getName());
-
-    private static Class<?> NO_PARAMS[] = new Class[0];
-
-
-    private static String strArray[] = new String[0];
-
-    private static Class<?>[] supportedTypes = new Class[] { Boolean.class,
-            Boolean.TYPE, Byte.class, Byte.TYPE, Character.class,
-            Character.TYPE, Short.class, Short.TYPE, Integer.class,
-            Integer.TYPE, Long.class, Long.TYPE, Float.class, Float.TYPE,
-            Double.class, Double.TYPE, String.class, strArray.getClass(),
-            BigDecimal.class, BigInteger.class, AtomicInteger.class,
-            AtomicLong.class, java.io.File.class, };
-
-
-    private Class realClass;
-
-    // Method or Field
-    private Map<String, AccessibleObject> getAttMap;
-
-    public DynamicObject(Class beanClass) {
-        this.realClass = beanClass;
-        initCache();
-    }
-
-    private void initCache() {
-        Method methods[] = null;
-
-        getAttMap = new HashMap<String, AccessibleObject>();
-
-        methods = realClass.getMethods();
-        for (int j = 0; j < methods.length; ++j) {
-            if (ignorable(methods[j])) {
-                continue;
-            }
-            String name = methods[j].getName();
-
-            Class<?> params[] = methods[j].getParameterTypes();
-
-            if (name.startsWith("get") && params.length == 0) {
-                Class<?> ret = methods[j].getReturnType();
-                if (!supportedType(ret)) {
-                    if (log.isLoggable(Level.FINE))
-                        log.fine("Unsupported type " + methods[j]);
-                    continue;
-                }
-                name = unCapitalize(name.substring(3));
-
-                getAttMap.put(name, methods[j]);
-            } else if (name.startsWith("is") && params.length == 0) {
-                Class<?> ret = methods[j].getReturnType();
-                if (Boolean.TYPE != ret) {
-                    if (log.isLoggable(Level.FINE))
-                        log.fine("Unsupported type " + methods[j] + " " + ret);
-                    continue;
-                }
-                name = unCapitalize(name.substring(2));
-
-                getAttMap.put(name, methods[j]);
-            }
-        }
-        // non-private AtomicInteger and AtomicLong - stats
-        Field fields[] = realClass.getFields();
-        for (int j = 0; j < fields.length; ++j) {
-            if (fields[j].getType() == AtomicInteger.class) {
-                getAttMap.put(fields[j].getName(), fields[j]);
-            }
-        }
-
-    }
-
-    public List<String> attributeNames() {
-        return new ArrayList<String>(getAttMap.keySet());
-    }
-
-
-    public Object invoke(Object proxy, String method) throws Exception {
-        Method executeM = null;
-        Class<?> c = proxy.getClass();
-        executeM = c.getMethod(method, NO_PARAMS);
-        if (executeM == null) {
-            throw new RuntimeException("No execute in " + proxy.getClass());
-        }
-        return executeM.invoke(proxy, (Object[]) null);
-    }
-
-    // TODO
-//    public Object invoke(String method, Object[] params) {
-//        return null;
-//    }
-
-    public Object getAttribute(Object o, String att) {
-        AccessibleObject m = getAttMap.get(att);
-        if (m instanceof Method) {
-            try {
-                return ((Method) m).invoke(o);
-            } catch (Throwable e) {
-                log.log(Level.INFO, "Error getting attribute " + realClass + " "
-                        + att, e);
-                return null;
-            }
-        } if (m instanceof Field) {
-            if (((Field) m).getType() == AtomicInteger.class) {
-                try {
-                    Object value = ((Field) m).get(o);
-                    return ((AtomicInteger) value).get();
-                } catch (Throwable e) {
-                    return null;
-                }
-            } else {
-                return null;
-            }
-        } else {
-            return null;
-        }
-    }
-
-    /**
-     * Set an object-type attribute.
-     *
-     * Use setProperty to use a string value and convert it to the
-     * specific (primitive) type.
-     */
-    public boolean setAttribute(Object proxy, String name, Object value) {
-        // TODO: use the cache...
-        String methodName = "set" + capitalize(name);
-        Method[] methods = proxy.getClass().getMethods();
-        for (Method m : methods) {
-            Class<?>[] paramT = m.getParameterTypes();
-            if (methodName.equals(m.getName())
-                    && paramT.length == 1
-                    && (value == null || paramT[0].isAssignableFrom(value
-                            .getClass()))) {
-                try {
-                    m.invoke(proxy, value);
-                    return true;
-                } catch (IllegalArgumentException e) {
-                    log.severe("Error setting: " + name + " "
-                            + proxy.getClass().getName() + " " + e);
-                } catch (IllegalAccessException e) {
-                    log.severe("Error setting: " + name + " "
-                            + proxy.getClass().getName() + " " + e);
-                } catch (InvocationTargetException e) {
-                    log.severe("Error setting: " + name + " "
-                            + proxy.getClass().getName() + " " + e);
-                }
-            }
-        }
-        return false;
-    }
-
-    public boolean setProperty(Object proxy, String name, String value) {
-        // TODO: use the cache...
-        String setter = "set" + capitalize(name);
-
-        try {
-            Method methods[] = proxy.getClass().getMethods();
-
-            Method setPropertyMethod = null;
-
-            // First, the ideal case - a setFoo( String ) method
-            for (int i = 0; i < methods.length; i++) {
-                if (ignorable(methods[i])) {
-                    continue;
-                }
-                Class<?> paramT[] = methods[i].getParameterTypes();
-                if (setter.equals(methods[i].getName()) && paramT.length == 1) {
-                    if ("java.lang.String".equals(paramT[0].getName())) {
-                        methods[i].invoke(proxy, new Object[] { value });
-                        return true;
-                    } else {
-                        // match - find the type and invoke it
-                        Class<?> paramType = methods[i].getParameterTypes()[0];
-                        Object params[] = new Object[1];
-                        params[0] = convert(value, paramType);
-                        if (params[0] != null) {
-                            methods[i].invoke(proxy, params);
-                            return true;
-                        }
-                    }
-                }
-                // save "setProperty" for later
-                if ("setProperty".equals(methods[i].getName()) &&
-                        paramT.length == 2 &&
-                        paramT[0] == String.class &&
-                        paramT[1] == String.class) {
-                    setPropertyMethod = methods[i];
-                }
-            }
-
-            try {
-                Field field = proxy.getClass().getField(name);
-                if (field != null) {
-                    Object conv = convert(value, field.getType());
-                    if (conv != null) {
-                        field.set(proxy, conv);
-                        return true;
-                    }
-                }
-            } catch (NoSuchFieldException e) {
-                // ignore
-            }
-
-            // Ok, no setXXX found, try a setProperty("name", "value")
-            if (setPropertyMethod != null) {
-                Object params[] = new Object[2];
-                params[0] = name;
-                params[1] = value;
-                setPropertyMethod.invoke(proxy, params);
-                return true;
-            }
-
-        } catch (Throwable ex2) {
-            log.log(Level.WARNING, "IAE " + proxy + " " + name + " " + value,
-                    ex2);
-        }
-        return false;
-    }
-
-    // ----------- Helpers ------------------
-
-    static Object convert(String object, Class<?> paramType) {
-        Object result = null;
-        if ("java.lang.String".equals(paramType.getName())) {
-            result = object;
-        } else if ("java.lang.Long".equals(paramType.getName())
-                || "long".equals(paramType.getName())) {
-            try {
-                result = Long.parseLong(object);
-            } catch (NumberFormatException ex) {
-            }
-            // Try a setFoo ( boolean )
-        } else if ("java.lang.Integer".equals(paramType.getName())
-                || "int".equals(paramType.getName())) {
-            try {
-                result = new Integer(object);
-            } catch (NumberFormatException ex) {
-            }
-            // Try a setFoo ( boolean )
-        } else if ("java.lang.Boolean".equals(paramType.getName())
-                || "boolean".equals(paramType.getName())) {
-            result = new Boolean(object);
-        } else {
-            log.info("Unknown type " + paramType.getName());
-        }
-        if (result == null) {
-            throw new IllegalArgumentException("Can't convert argument: "
-                    + object +  " to " + paramType );
-        }
-        return result;
-    }
-
-    /**
-     * Converts the first character of the given String into lower-case.
-     *
-     * @param name
-     *            The string to convert
-     * @return String
-     */
-    static String unCapitalize(String name) {
-        if (name == null || name.length() == 0) {
-            return name;
-        }
-        char chars[] = name.toCharArray();
-        chars[0] = Character.toLowerCase(chars[0]);
-        return new String(chars);
-    }
-
-    /**
-     * Check if this class is one of the supported types. If the class is
-     * supported, returns true. Otherwise, returns false.
-     *
-     * @param ret
-     *            The class to check
-     * @return boolean True if class is supported
-     */
-    static boolean supportedType(Class<?> ret) {
-        for (int i = 0; i < supportedTypes.length; i++) {
-            if (ret == supportedTypes[i]) {
-                return true;
-            }
-        }
-        if (isBeanCompatible(ret)) {
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Check if this class conforms to JavaBeans specifications. If the class is
-     * conformant, returns true.
-     *
-     * @param javaType
-     *            The class to check
-     * @return boolean True if the class is compatible.
-     */
-    static boolean isBeanCompatible(Class<?> javaType) {
-        // Must be a non-primitive and non array
-        if (javaType.isArray() || javaType.isPrimitive()) {
-            return false;
-        }
-
-        // Anything in the java or javax package that
-        // does not have a defined mapping is excluded.
-        if (javaType.getName().startsWith("java.")
-                || javaType.getName().startsWith("javax.")) {
-            return false;
-        }
-
-        try {
-            javaType.getConstructor(new Class[] {});
-        } catch (java.lang.NoSuchMethodException e) {
-            return false;
-        }
-
-        // Make sure superclass is compatible
-        Class<?> superClass = javaType.getSuperclass();
-        if (superClass != null && superClass != java.lang.Object.class
-                && superClass != java.lang.Exception.class
-                && superClass != java.lang.Throwable.class) {
-            if (!isBeanCompatible(superClass)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Reverse of Introspector.decapitalize
-     */
-    static String capitalize(String name) {
-        if (name == null || name.length() == 0) {
-            return name;
-        }
-        char chars[] = name.toCharArray();
-        chars[0] = Character.toUpperCase(chars[0]);
-        return new String(chars);
-    }
-
-    private boolean ignorable(Method method) {
-        if (Modifier.isStatic(method.getModifiers()))
-            return true;
-        if (!Modifier.isPublic(method.getModifiers())) {
-            return true;
-        }
-        if (method.getDeclaringClass() == Object.class)
-            return true;
-        return false;
-    }
-
-
-}

==================================================
RfcDateParser.java
deleted file mode 100644
index 0a7e9c9b8f..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/HttpCookie.java
+++ /dev/null
@@ -1,290 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.tomcat.test.watchdog;
-
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.net.URL;
-import java.util.Date;
-import java.util.Properties;
-import java.util.StringTokenizer;
-
-/**
- * An object which represents an HTTP cookie.  Can be constructed by
- * parsing a string from the set-cookie: header.
- *
- * Syntax: Set-Cookie: NAME=VALUE; expires=DATE;
- *             path=PATH; domain=DOMAIN_NAME; secure
- *
- * All but the first field are optional.
- *
- * @author	Ramesh.Mandava
- */
-
-public class HttpCookie {
-    private Date expirationDate = null;
-    private String nameAndValue;
-    private String path;
-    private String domain;
-    private boolean isSecure = false;
-    private static boolean defaultSet = true;
-    private static long defExprTime = 100;
-
-    public HttpCookie(String cookieString) {
-	/*
-	System.out.println("Calling default expiration :");
-	getDefaultExpiration();
-	*/
-	parseCookieString(cookieString);
-    }
-
-    //
-    // Constructor for use by the bean
-    //
-    public HttpCookie(Date expirationDate,
-		      String nameAndValue,
-		      String path,
-		      String domain,
-		      boolean isSecure) {
-	this.expirationDate = expirationDate;
-	this.nameAndValue = nameAndValue;
-	this.path = path;
-	this.domain = domain;
-	this.isSecure = isSecure;
-    }
-
-    public HttpCookie(URL url, String cookieString) {
-	parseCookieString(cookieString);
-	applyDefaults(url);
-    }
-
-    /**
-     * Fills in default values for domain, path, etc. from the URL
-     * after creation of the cookie.
-     */
-    private void applyDefaults(URL url) {
-	if (domain == null) {
-	    domain = url.getHost()+":"+((url.getPort() == -1) ? 80 : url.getPort());
-	}
-
-	if (path == null) {
-	    path = url.getFile();
-
-	    // larrylf: The documentation for cookies say that the path is
-	    // by default, the path of the document, not the filename of the
-	    // document.  This could be read as not including that document
-	    // name itself, just its path (this is how NetScape intrprets it)
-	    // so amputate the document name!
-	    int last = path.lastIndexOf("/");
-	    if( last > -1 ) {
-		path = path.substring(0, last);
-	    }
-	}
-    }
-
-
-    /**
-     * Parse the given string into its individual components, recording them
-     * in the member variables of this object.
-     */
-    private void parseCookieString(String cookieString) {
-	StringTokenizer tokens = new StringTokenizer(cookieString, ";");
-
-	if (!tokens.hasMoreTokens()) {
-	    // REMIND: make this robust against parse errors
-	    nameAndValue="=";
-	    return;
-	}
-
-	nameAndValue = tokens.nextToken().trim();
-	
-	while (tokens.hasMoreTokens()) {
-	    String token = tokens.nextToken().trim();
-	
-	    if (token.equalsIgnoreCase("secure")) {
-		isSecure = true;
-	    } else {
-		int equIndex = token.indexOf("=");
-		
-		if (equIndex < 0) {
-		    continue;
-		    // REMIND: malformed cookie
-		}
-		
-		String attr = token.substring(0, equIndex);
-		String val = token.substring(equIndex+1);
-		
-		if (attr.equalsIgnoreCase("path")) {
-		    path = val;
-		} else if (attr.equalsIgnoreCase("domain")) {
-		    if( val.indexOf(".") == 0 ) {
-			// spec seems to allow for setting the domain in
-			// the form 'domain=.eng.sun.com'.  We want to
-			// trim off the leading '.' so we can allow for
-			// both leading dot and non leading dot forms
-			// without duplicate storage.
-			domain = val.substring(1);
-		    } else {
-			domain = val;
-		    }
-		} else if (attr.equalsIgnoreCase("expires")) {
-		    expirationDate = parseExpireDate(val);
-		} else {
-		    // unknown attribute -- do nothing
-		}
-	    }
-	}
-
-	// commented the following out, b/c ok to have no expirationDate
-	// that means that the cookie should last only for that particular
-	// session.
-	//	if (expirationDate == null) {
-	//     	    expirationDate = getDefaultExpiration();
-	//	}
-    }
-
-    /* Returns the default expiration, which is the current time + default
-       expiration as specified in the properties file.
-       This uses reflection to get at the properties file, since Globals is
-       not in the utils/ directory
-       */
-    private Date getDefaultExpiration() {
-	if (defaultSet == false) {
-	    Properties props = new Properties();
-	
-	    try {
-		FileInputStream fin = new FileInputStream("ServerAutoRun.properties");
-		props.load( fin );
-		
-		System.out.println("Got properties from ServerAutoRun.properties");
-		props.list(System.out);
-		
-	    } catch (IOException ex) {
-		System.out.println("HttpCookie getDefaultExpiration : ServerAutoRun.properties not found!" + ex);
-	    }
-	
-		 // defExprTime = props.getProperty("cookies.default.expiration");
-		 defExprTime = Long.parseLong( props.getProperty("cookies.default.expiration") );
-
-	    }
-	    defaultSet = true;
-	
-	return (new Date(System.currentTimeMillis() + defExprTime));
-	
-    }
-
-    //======================================================================
-    //
-    // Accessor functions
-    //
-
-
-
-     public String getNameValue() {
-	return nameAndValue;
-    }
-
-    /**
-     * Returns just the name part of the cookie
-     */
-     public String getName() {
-
-	 // it probably can't have null value, but doesn't hurt much
-	 // to check.
-	 if (nameAndValue == null) {
-	     return "=";
-	 }
-	 int index = nameAndValue.indexOf("=");
-	 return (index < 0) ? "=" : nameAndValue.substring(0, index);
-     }
-
-
-    /**
-     * Returns the domain of the cookie as it was presented
-     */
-     public String getDomain() {
-	// REMIND: add port here if appropriate
-	return domain;
-    }
-
-     public String getPath() {
-	return path;
-    }
-
-     public Date getExpirationDate() {
-	return expirationDate;
-    }
-
-    public boolean hasExpired() {
-	if(expirationDate == null) {
-	    return false;
-	}
-	return (expirationDate.getTime() <= System.currentTimeMillis());
-    }
-
-    /**
-     * Returns true if the cookie has an expiration date (meaning it's
-     * persistent), and if the date nas not expired;
-     */
-    public boolean isSaveable() {
-	return (expirationDate != null)
-	    && (expirationDate.getTime() > System.currentTimeMillis());
-    }
-
-    public boolean isSaveableInMemory() {
-	return ((expirationDate == null) ||
-		(expirationDate != null && expirationDate.getTime() > System.currentTimeMillis()));
-    }
-		
-     public boolean isSecure() {
-	return isSecure;
-    }
-
-    private Date parseExpireDate(String dateString) {
-	// format is wdy, DD-Mon-yyyy HH:mm:ss GMT
-	RfcDateParser parser = new RfcDateParser(dateString);
-	Date theDate = parser.getDate();
-	if (theDate == null) {
-	    // Expire in some intelligent default time
-	    theDate = getDefaultExpiration();
-	}
-	return theDate;
-    }
-
-    public String toString() {
-
-	String result = (nameAndValue == null) ? "=" : nameAndValue;
-	if (expirationDate != null) {
-	    result += "; expires=" + expirationDate;
-	}
-	
-	if (path != null) {
-	    result += "; path=" + path;
-	}
-
-	if (domain != null) {
-	    result += "; domain=" + domain;
-	}
-
-	if (isSecure) {
-	    result += "; secure";
-	}
-
-	return result;
-    }
-}

==================================================
WatchdogClient.java
deleted file mode 100644
index 9a7f604b02..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/RfcDateParser.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.test.watchdog;
-
-import java.util.Date;
-import java.util.Locale;
-import java.util.TimeZone;
-
-/**
- * A parser for date strings commonly found in http and email headers that
- * follow various RFC conventions.  Given a date-string, the parser will
- * attempt to parse it by trying matches with a set of patterns, returning
- * null on failure, a Date object on success.
- *
- * @author Ramesh.Mandava
- */
-public class RfcDateParser {
-
-    private boolean isGMT = false;
-
-    static final String[] standardFormats = {
-	"EEEE', 'dd-MMM-yy HH:mm:ss z",   // RFC 850 (obsoleted by 1036)
-	"EEEE', 'dd-MMM-yy HH:mm:ss",     // ditto but no tz. Happens too often
-	"EEE', 'dd-MMM-yyyy HH:mm:ss z",  // RFC 822/1123
-	"EEE', 'dd MMM yyyy HH:mm:ss z",  // REMIND what rfc? Apache/1.1
-	"EEEE', 'dd MMM yyyy HH:mm:ss z", // REMIND what rfc? Apache/1.1
-	"EEE', 'dd MMM yyyy hh:mm:ss z",  // REMIND what rfc? Apache/1.1
-	"EEEE', 'dd MMM yyyy hh:mm:ss z", // REMIND what rfc? Apache/1.1
-	"EEE MMM dd HH:mm:ss z yyyy",      // Date's string output format
-	"EEE MMM dd HH:mm:ss yyyy",	  // ANSI C asctime format()
-	"EEE', 'dd-MMM-yy HH:mm:ss",      // No time zone 2 digit year RFC 1123
- 	"EEE', 'dd-MMM-yyyy HH:mm:ss"     // No time zone RFC 822/1123
-    };
-
-    /* because there are problems with JDK1.1.6/SimpleDateFormat with
-     * recognizing GMT, we have to create this workaround with the following
-     * hardcoded strings */
-    static final String[] gmtStandardFormats = {
-	"EEEE',' dd-MMM-yy HH:mm:ss 'GMT'",   // RFC 850 (obsoleted by 1036)
-	"EEE',' dd-MMM-yyyy HH:mm:ss 'GMT'",  // RFC 822/1123
-	"EEE',' dd MMM yyyy HH:mm:ss 'GMT'",  // REMIND what rfc? Apache/1.1
-	"EEEE',' dd MMM yyyy HH:mm:ss 'GMT'", // REMIND what rfc? Apache/1.1
-	"EEE',' dd MMM yyyy hh:mm:ss 'GMT'",  // REMIND what rfc? Apache/1.1
-	"EEEE',' dd MMM yyyy hh:mm:ss 'GMT'", // REMIND what rfc? Apache/1.1
-	"EEE MMM dd HH:mm:ss 'GMT' yyyy"      // Date's string output format
-    };
-
-    String dateString;
-
-    public RfcDateParser(String dateString) {
-	this.dateString = dateString.trim();
-	if (this.dateString.indexOf("GMT") != -1) {
-	    isGMT = true;
-	}
-    }
-
-    public Date getDate() {
-
-        int arrayLen = isGMT ? gmtStandardFormats.length : standardFormats.length;
-        for (int i = 0; i < arrayLen; i++) {
-            Date d = null;
-
-            if (isGMT) {
-                d = tryParsing(gmtStandardFormats[i]);
-            } else {
-                d = tryParsing(standardFormats[i]);
-            }
-            if (d != null) {
-                return d;
-            }
-
-        }
-
-        return null;
-    }
-
-    private Date tryParsing(String format) {
-
-	java.text.SimpleDateFormat df = new java.text.SimpleDateFormat(format, Locale.US);
-	if (isGMT) {
-	    df.setTimeZone(TimeZone.getTimeZone("GMT"));
-	}
-	try {
-		return df.parse(dateString);
-	} catch (Exception e) {
-	    return null;
-	}
-    }
-} /* class RfcDateParser */

==================================================
WatchdogHttpClient.java
deleted file mode 100644
index 05b481c0c4..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/WatchdogClient.java
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.test.watchdog;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.StringReader;
-import java.util.Properties;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-
-import junit.framework.Test;
-import junit.framework.TestResult;
-import junit.framework.TestSuite;
-
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
-import org.w3c.dom.NodeList;
-import org.xml.sax.EntityResolver;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-
-public class WatchdogClient {
-
-  protected String goldenDir;
-  protected String testMatch;
-  protected String file;
-  protected String[] exclude = null;
-  protected String[] slow =
-  {
-      "SingleModelTest" // slow
-  };
-
-  protected String targetMatch;
-
-  protected int port;
-
-  Properties props = new Properties();
-
-  protected void beforeSuite() {
-  }
-
-  protected void afterSuite(TestResult res) {
-  }
-
-  public Test getSuite() {
-      return getSuite(port);
-  }
-
-  public static class NullResolver implements EntityResolver {
-      public InputSource resolveEntity (String publicId,
-                                                 String systemId)
-          throws SAXException, IOException
-      {
-          return new InputSource(new StringReader(""));
-      }
-  }
-
-  /** Read XML as DOM.
-   */
-  public static Document readXml(InputStream is)
-      throws SAXException, IOException, ParserConfigurationException
-  {
-      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
-      dbf.setValidating(false);
-      dbf.setIgnoringComments(false);
-      dbf.setIgnoringElementContentWhitespace(true);
-      DocumentBuilder db = null;
-      db = dbf.newDocumentBuilder();
-      db.setEntityResolver( new NullResolver() );
-      Document doc = db.parse(is);
-      return doc;
-  }
-
-  /**
-   * Return a test suite for running a watchdog-like
-   * test file.
-   *
-   * @param base base dir for the watchdog dir
-   * @param testMatch Prefix of tests to be run
-   * @return
-   */
-  public Test getSuite(int port) {
-    TestSuite tests = new WatchdogTests();
-    tests.setName(this.getClass().getSimpleName());
-
-    props.setProperty("port", Integer.toString(port));
-    props.setProperty("host", "localhost");
-    props.setProperty("wgdir",
-        goldenDir);
-
-
-    try {
-      Document doc = readXml(new FileInputStream(file));
-      Element docE = doc.getDocumentElement();
-      NodeList targetsL = docE.getElementsByTagName("target");
-      for (int i = 0; i < targetsL.getLength(); i++) {
-        Element target = (Element) targetsL.item(i);
-        String targetName = target.getAttribute("name");
-        if (targetMatch != null && !targetName.equals(targetMatch)) {
-            continue;
-        }
-
-        // Tests are duplicated
-        //TestSuite targetSuite = new TestSuite(targetName);
-
-        NodeList watchDogL = target.getElementsByTagName("watchdog");
-        for (int j = 0; j < watchDogL.getLength(); j++) {
-          Element watchE = (Element) watchDogL.item(j);
-          String testName = watchE.getAttribute("testName");
-          if (single != null && !testName.equals(single)) {
-              continue;
-          }
-          if (testMatch != null) {
-              if (!testName.startsWith(testMatch)) {
-                  continue;
-              }
-          }
-          if (exclude != null) {
-              boolean found = false;
-              for (String e: exclude) {
-                  if (e.equals(testName)) {
-                      found = true;
-                      break;
-                  }
-              }
-              if (found) {
-                  continue;
-              }
-          }
-          testName = testName + "(" + this.getClass().getName() + ")";
-          WatchdogTestCase test = new WatchdogTestCase(watchE, props, testName);
-          tests.addTest(test);
-          if (single != null) {
-              singleTest = test;
-              break;
-          }
-        }
-      }
-
-    } catch (IOException e) {
-        e.printStackTrace();
-    } catch (SAXException e) {
-        e.printStackTrace();
-    } catch (ParserConfigurationException e) {
-        e.printStackTrace();
-    }
-    return tests;
-  }
-
-  // --------- Inner classes -------------
-
-  protected String getWatchdogdir() {
-      String path = System.getProperty("watchdog.home");
-      if (path != null) {
-          return path;
-      }
-      path = "..";
-      for (int i = 0; i < 10; i++) {
-          File f = new File(path + "/watchdog");
-          if (f.exists()) {
-              return f.getAbsolutePath();
-          }
-          path = path + "/..";
-      }
-      return null;
-  }
-
-  public class WatchdogTests extends TestSuite {
-      public void run(TestResult res) {
-          beforeSuite();
-          super.run(res);
-          afterSuite(res);
-      }
-  }
-
-  // Support for running a single test in the suite
-
-  protected String single;
-  WatchdogTestCase singleTest;
-
-  public int countTestCases() {
-      return 1;
-  }
-
-  public void run(TestResult result) {
-      getSuite();
-      if (singleTest != null) {
-          beforeSuite();
-          singleTest.run(result);
-          afterSuite(result);
-      }
-  }
-
-}

==================================================
WatchdogTestCase.java
deleted file mode 100644
index 2464f3398e..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/WatchdogHttpClient.java
+++ /dev/null
@@ -1,411 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.tomcat.test.watchdog;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Socket;
-import java.net.SocketException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Vector;
-
-
-public class WatchdogHttpClient {
-    private static final String CRLF         = "\r\n";
-    private static final int LINE_FEED       = 10;
-
-    static int debug = 0;
-
-    public static void dispatch(WatchdogTestImpl client) throws Exception {
-        HashMap requestHeaders = client.requestHeaders;
-        String host = client.host;
-        int port = client.port;
-        String content = client.content;
-        String request = client.request;
-
-        // XXX headers are ignored
-        Socket socket;
-        try {
-            socket = new Socket( host, port );
-        } catch (IOException ex) {
-            System.out.println( " Socket Exception: " + ex );
-            return;
-        }
-        socket.setSoTimeout(10000);
-
-        //socket obtained, rebuild the request.
-        rebuildRequest(client, client.request, socket);
-
-        InputStream in = new CRBufferedInputStream( socket.getInputStream() );
-
-        // Write the request
-        socket.setSoLinger( true, 1000 );
-
-        OutputStream out = new BufferedOutputStream(
-                               socket.getOutputStream() );
-        StringBuffer reqbuf = new StringBuffer( 128 );
-
-        // set the Host header
-        client.setHeaderDetails( "Host:" + host + ":" + port, requestHeaders, true );
-
-        // set the Content-Length header
-        if ( content != null ) {
-            client.setHeaderDetails( "Content-Length:" + content.length(),
-                              requestHeaders, true );
-        }
-
-        // set the Cookie header
-        if ( client.testSession != null ) {
-            client.cookieController = ( CookieController ) client.sessionHash.get( client.testSession );
-
-            if ( client.cookieController != null ) {
-
-                String releventCookieString = client.cookieController.applyRelevantCookies( client.requestURL );
-
-                if ( ( releventCookieString != null ) && ( !releventCookieString.trim().equals( "" ) ) ) {
-                    client.setHeaderDetails( "Cookie:" + releventCookieString, requestHeaders, true );
-                }
-            }
-        }
-
-        if ( debug > 0 ) {
-            System.out.println( " REQUEST: " + request );
-        }
-        reqbuf.append( client.request ).append( CRLF );
-
-        // append all request headers
-        if ( !requestHeaders.isEmpty() ) {
-            Iterator iter = requestHeaders.keySet().iterator();
-
-            while ( iter.hasNext() ) {
-                StringBuffer tmpBuf = new StringBuffer(32);
-                String headerKey = ( String ) iter.next();
-                        ArrayList values = (ArrayList) requestHeaders.get( headerKey );
-                        String[] value = (String[]) values.toArray( new String[ values.size() ] );
-                tmpBuf.append( headerKey ).append(": ");
-                        for ( int i = 0; i < value.length; i++ ) {
-                    if ((i + 1) == value.length) {
-                                    tmpBuf.append( value[ i ] );
-                    } else {
-                        tmpBuf.append( value[ i ] ).append(", ");
-                    }
-                        }
-                            if ( debug > 0 ) {
-                                System.out.println( " REQUEST HEADER: " + tmpBuf.toString());
-                            }
-                tmpBuf.append( CRLF );
-                reqbuf.append(tmpBuf.toString());
-            }
-        }
-
-        /*
-
-        if ( ( testSession != null ) && ( sessionHash.get( testSession ) != null ) ) {
-            System.out.println("Sending Session Id : " + (String)sessionHash.get( testSession ) );
-            pw.println("JSESSIONID:" + (String)sessionHash.get( testSession) );
-        }
-
-        */
-
-        if ( request.indexOf( "HTTP/1." ) > -1 ) {
-            reqbuf.append( "" ).append( CRLF );
-        }
-
-        // append request content
-        if ( content != null ) {
-            reqbuf.append( content );
-            // XXX no CRLF at the end -see HTTP specs!
-        }
-
-        byte[] reqbytes = reqbuf.toString().getBytes();
-
-        try {
-            // write the request
-            out.write( reqbytes, 0, reqbytes.length );
-            out.flush();
-        } catch ( Exception ex1 ) {
-            System.out.println( " Error writing request " + ex1 );
-                if ( debug > 0 ) {
-                        System.out.println( "Message: " + ex1.getMessage() );
-                        ex1.printStackTrace();
-                }
-        }
-
-        // read the response
-        try {
-
-                client.responseLine = read( in );
-
-                if ( debug > 0 ) {
-                        System.out.println( " RESPONSE STATUS-LINE: " + client.responseLine );
-                }
-
-                client.headers = parseHeaders( client, in );
-
-            byte[] result = readBody( in );
-
-            if ( result != null ) {
-                client.responseBody = result;
-                        if ( debug > 0 ) {
-                            System.out.println( " RESPONSE BODY:\n" + new String( client.responseBody ) );
-                        }
-                }
-
-        } catch ( SocketException ex ) {
-            System.out.println( " Socket Exception: " + ex );
-        } finally {
-                if ( debug > 0 ) {
-                        System.out.println( " closing socket" );
-                }
-                socket.close();
-                socket = null;
-            }
-
-    }
-
-    /**
-     * <code>readBody</code> reads the body of the response
-     * from the InputStream.
-     *
-     * @param input an <code>InputStream</code>
-     * @return a <code>byte[]</code> representation of the response
-     */
-    private static byte[] readBody( InputStream input ) {
-        StringBuffer sb = new StringBuffer( 255 );
-        while ( true ) {
-            try {
-                int ch = input.read();
-
-                if ( ch < 0 ) {
-                    if ( sb.length() == 0 ) {
-                        return ( null );
-                    } else {
-                        break;
-                    }
-                }
-                sb.append( ( char ) ch );
-
-            } catch ( IOException ex ) {
-                return null;
-            }
-        }
-        return sb.toString().getBytes();
-    }
-
-
-    /**
-     * Read a line from the specified servlet input stream, and strip off
-     * the trailing carriage return and newline (if any).  Return the remaining
-     * characters that were read as a string.7
-     *
-     * @returns The line that was read, or <code>null</code> if end of file
-     *  was encountered
-     *
-     * @exception IOException if an input/output error occurred
-     */
-    private static String read( InputStream input ) throws IOException {
-        // Read the next line from the input stream
-        StringBuffer sb = new StringBuffer();
-
-        while ( true ) {
-            try {
-                int ch = input.read();
-                //              System.out.println("XXX " + (char)ch );
-                if ( ch < 0 ) {
-                    if ( sb.length() == 0 ) {
-                        if ( debug > 0 )
-                            System.out.println( " Error reading line " + ch + " " + sb.toString() );
-                        return "";
-                    } else {
-                        break;
-                    }
-                } else if ( ch == LINE_FEED ) {
-                    break;
-                }
-
-                sb.append( ( char ) ch );
-            } catch ( IOException ex ) {
-                System.out.println( " Error reading : " + ex );
-                debug = 1;
-
-                if ( debug > 0 ) {
-                    System.out.println( "Partial read: " + sb.toString() );
-                    ex.printStackTrace();
-                }
-                input.close();
-                break;
-            }
-        }
-        return  sb.toString();
-    }
-
-
-    // ==================== Code from JSERV !!! ====================
-    /**
-     * Parse the incoming HTTP request headers, and set the corresponding
-     * request properties.
-     *
-     *
-     * @exception IOException if an input/output error occurs
-     */
-    private static HashMap parseHeaders( WatchdogTestImpl client, InputStream is ) throws IOException {
-        HashMap headers = new HashMap();
-        client.cookieVector = new Vector();
-
-        while ( true ) {
-            // Read the next header line
-            String line = read( is );
-
-            if ( ( line == null ) || ( line.length() < 1 ) ) {
-                break;
-            }
-
-            client.parseHeader( line, headers, false );
-
-            if ( debug > 0 ) {
-                System.out.println( " RESPONSE HEADER: " + line );
-            }
-
-        }
-
-        if ( client.testSession != null ) {
-            client.cookieController = ( CookieController ) client.sessionHash.get( client.testSession );
-
-            if ( client.cookieController != null ) {
-                client.cookieController.recordAnyCookies( client.cookieVector, client.requestURL );
-            }
-        }
-
-        return headers;
-    }
-
-
-    /**
-     * Private utility method to 'massage' a request string that
-     * may or may not have replacement markers for the request parameters.
-     *
-     * @param req the request to manipulate
-     * @param socket local socket.  Used to rebuild specified query strings.
-     *
-     * @exception Exception if an error occurs
-     */
-    private static void rebuildRequest(WatchdogTestImpl client, String req, Socket socket) throws Exception {
-        client.request = client.replaceMarkers(req, socket );
-        String addressString = client.request.substring( client.request.indexOf( "/" ), client.request.indexOf( "HTTP" ) ).trim();
-
-        if ( addressString.indexOf( "?" ) > -1 ) {
-            addressString = addressString.substring( 0, addressString.indexOf( "?" ) ) ;
-        }
-
-        client.requestURL = new URL( "http", client.host, client.port, addressString );
-    }
-
-
-    /**
-     * <code>CRBufferedInputStream</code> is a modified version of
-     * the java.io.BufferedInputStream class.  The fill code is
-     * the same, but the read is modified in that if a carriage return
-     * is found in the response stream from the target server,
-     * it will skip that byte and return the next in the stream.
-     */
-    private static class CRBufferedInputStream extends BufferedInputStream {
-        private static final int CARRIAGE_RETURN = 13;
-
-        private static final int DEFAULT_BUFFER = 2048;
-
-        /**
-         * Creates a new <code>CRBufferedInputStream</code> instance.
-         *
-         * @param in an <code>InputStream</code> value
-         */
-        public CRBufferedInputStream( InputStream in ) {
-            super( in, DEFAULT_BUFFER );
-        }
-
-        /**
-         * <code>read</code> reads a single byte value per call.
-         * If, the byte read, is a carriage return, the next byte
-         * in the stream in returned instead.
-         *
-         * @return an <code>int</code> value
-         * @exception IOException if an error occurs
-         */
-        public int read() throws IOException {
-            if ( in == null ) {
-                throw new IOException ( "Stream closed" );
-            }
-            if ( pos >= count ) {
-                fill();
-                if ( pos >= count ) {
-                    return -1;
-                }
-            }
-            int val = buf[pos++] & 0xff;
-            if ( val == CARRIAGE_RETURN ) {
-                if (pos >= count) {
-                    fill();
-                    if (pos >= count) {
-                       return -1;
-                    }
-                }
-                return buf[pos++] & 0xff;
-            }
-            return val;
-        }
-
-        /**
-         * <code>fill</code> is used to fill the internal
-         * buffer used by this BufferedInputStream class.
-         *
-         * @exception IOException if an error occurs
-         */
-        private void fill() throws IOException {
-            if (markpos < 0) {
-                pos = 0;        /* no mark: throw away the buffer */
-            } else if (pos >= buf.length)  {/* no room left in buffer */
-                if (markpos > 0) {  /* can throw away early part of the buffer */
-                    int sz = pos - markpos;
-                    System.arraycopy(buf, markpos, buf, 0, sz);
-                    pos = sz;
-                    markpos = 0;
-                } else if (buf.length >= marklimit) {
-                    markpos = -1;   /* buffer got too big, invalidate mark */
-                    pos = 0;    /* drop buffer contents */
-                } else {        /* grow buffer */
-                    int nsz = pos * 2;
-                    if (nsz > marklimit)
-                        nsz = marklimit;
-                    byte nbuf[] = new byte[nsz];
-                    System.arraycopy(buf, 0, nbuf, 0, pos);
-                    buf = nbuf;
-                }
-            }
-            count = pos;
-            int n = in.read(buf, pos, buf.length - pos);
-            if (n > 0) {
-                count = n + pos;
-            }
-        }
-    }
-
-}

==================================================
WatchdogTestImpl.java
deleted file mode 100644
index 8da9b35aec..0000000000
--- a/modules/tomcat-lite/test/org/apache/tomcat/test/watchdog/WatchdogTestCase.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- */
-package org.apache.tomcat.test.watchdog;
-
-import java.util.Properties;
-
-import junit.framework.AssertionFailedError;
-import junit.framework.Test;
-import junit.framework.TestResult;
-
-import org.w3c.dom.Element;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-
-public class WatchdogTestCase implements Test {
-    String testName;
-
-    Element watchE;
-
-    private Properties props;
-
-    private WatchdogClient wc;
-
-    public WatchdogTestCase() {
-
-    }
-
-    public WatchdogTestCase(Element watchE, Properties props, String testName) {
-        this.testName = testName;
-        this.watchE = watchE;
-        this.props = props;
-    }
-
-    public int countTestCases() {
-        return 1;
-    }
-
-    public String getName() {
-        return testName == null ? "WatchdogTest" : testName;
-    }
-
-    public String toString() {
-        return getName();
-    }
-
-    public void testDummy() {
-    }
-
-    public void run(TestResult res) {
-        if (watchE == null) {
-            res.endTest(this);
-            return;
-        }
-        WatchdogTestImpl test = new WatchdogTestImpl();
-        NamedNodeMap attrs = watchE.getAttributes();
-
-        for (int i = 0; i < attrs.getLength(); i++) {
-            Node n = attrs.item(i);
-            String name = n.getNodeName();
-            String value = n.getNodeValue();
-            value = AntProperties.replaceProperties(value, props, null);
-            try {
-                new DynamicObject(test.getClass()).setProperty(test,
-                        name, value);
-            } catch (Exception e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            }
-        }
-
-        try {
-            res.startTest(this);
-            new DynamicObject(test.getClass()).invoke(test, "execute");
-        } catch (Throwable e) {
-            res.addError(this, e);
-            // res.stop();
-        }
-
-        if (test.passCount == 1) {
-            res.endTest(this);
-            return;
-        } else {
-            if (test.lastError == null) {
-                res.addFailure(this, new AssertionFailedError(test.request
-                        + " " + test.description + "\n" + test.resultOut));
-            } else {
-                res.addError(this, test.lastError);
-            }
-        }
-        res.endTest(this);
-    }
-
-}

==================================================
