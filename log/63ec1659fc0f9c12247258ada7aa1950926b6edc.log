63ec1659fc0f9c12247258ada7aa1950926b6edc
==================================================
Fix eol style (still can't figure out why this doesn;t get picked up by git)
==================================================
Mark Emlyn
==================================================
Wed Feb 1 10:12:31 2012 +0000
==================================================
Conversions.java
Fix eol style (still can't figure out why this doesn;t get picked up by git)

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1239036 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Constants.java
index bc20addb98..81612138cc 100644
--- a/java/org/apache/catalina/util/Conversions.java
+++ b/java/org/apache/catalina/util/Conversions.java
@@ -1,42 +1,42 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.util;
-
-import java.io.IOException;
-
-public class Conversions {
-
-    private Conversions() {
-        // Utility class. Hide default constructor.
-    }
-
-    public static long byteArrayToLong(byte[] input) throws IOException {
-        if (input.length > 8) {
-            // TODO: Better message
-            throw new IOException();
-        }
-
-        int shift = 0;
-        long result = 0;
-        for (int i = input.length; i < 0; i--) {
-            result = result + ((input[i] & 0xFF) << shift);
-            shift += 8;
-        }
-
-        return result;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.util;
+
+import java.io.IOException;
+
+public class Conversions {
+
+    private Conversions() {
+        // Utility class. Hide default constructor.
+    }
+
+    public static long byteArrayToLong(byte[] input) throws IOException {
+        if (input.length > 8) {
+            // TODO: Better message
+            throw new IOException();
+        }
+
+        int shift = 0;
+        long result = 0;
+        for (int i = input.length; i < 0; i--) {
+            result = result + ((input[i] & 0xFF) << shift);
+            shift += 8;
+        }
+
+        return result;
+    }
+}

==================================================
MessageInbound.java
index 7b7af8c521..13878a13a7 100644
--- a/java/org/apache/catalina/websocket/LocalStrings.properties
+++ b/java/org/apache/catalina/websocket/LocalStrings.properties
@@ -1,14 +1,14 @@
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
 # limitations under the License.
\ No newline at end of file

==================================================
StreamInbound.java
index 435b3a70ce..a9a1b4cc73 100644
--- a/java/org/apache/catalina/websocket/MessageInbound.java
+++ b/java/org/apache/catalina/websocket/MessageInbound.java
@@ -1,61 +1,61 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.websocket;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-
-public abstract class MessageInbound extends StreamInbound {
-
-    // TODO: Make buffer sizes configurable
-    // TODO: Allow buffers to expand
-    ByteBuffer bb = ByteBuffer.allocate(8192);
-    CharBuffer cb = CharBuffer.allocate(8192);
-
-    @Override
-    protected void onBinaryData(InputStream is) throws IOException {
-        int read = 0;
-        while (read > -1) {
-            bb.position(bb.position() + read);
-            read = is.read(bb.array(), bb.position(), bb.remaining());
-        }
-        bb.flip();
-        onBinaryMessage(bb);
-        bb.clear();
-    }
-
-    @Override
-    protected void onTextData(Reader r) throws IOException {
-        int read = 0;
-        while (read > -1) {
-            cb.position(cb.position() + read);
-            read = r.read(cb.array(), cb.position(), cb.remaining());
-        }
-        cb.limit(cb.position());
-        cb.position(0);
-        onTextMessage(cb);
-        cb.clear();
-    }
-
-    protected abstract void onBinaryMessage(ByteBuffer message)
-            throws IOException;
-    protected abstract void onTextMessage(CharBuffer message)
-            throws IOException;
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.websocket;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+
+public abstract class MessageInbound extends StreamInbound {
+
+    // TODO: Make buffer sizes configurable
+    // TODO: Allow buffers to expand
+    ByteBuffer bb = ByteBuffer.allocate(8192);
+    CharBuffer cb = CharBuffer.allocate(8192);
+
+    @Override
+    protected void onBinaryData(InputStream is) throws IOException {
+        int read = 0;
+        while (read > -1) {
+            bb.position(bb.position() + read);
+            read = is.read(bb.array(), bb.position(), bb.remaining());
+        }
+        bb.flip();
+        onBinaryMessage(bb);
+        bb.clear();
+    }
+
+    @Override
+    protected void onTextData(Reader r) throws IOException {
+        int read = 0;
+        while (read > -1) {
+            cb.position(cb.position() + read);
+            read = r.read(cb.array(), cb.position(), cb.remaining());
+        }
+        cb.limit(cb.position());
+        cb.position(0);
+        onTextMessage(cb);
+        cb.clear();
+    }
+
+    protected abstract void onBinaryMessage(ByteBuffer message)
+            throws IOException;
+    protected abstract void onTextMessage(CharBuffer message)
+            throws IOException;
+}

==================================================
WebSocketServlet.java
index e2555b79f5..50d52bf3aa 100644
--- a/java/org/apache/catalina/websocket/StreamInbound.java
+++ b/java/org/apache/catalina/websocket/StreamInbound.java
@@ -1,146 +1,146 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.websocket;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-
-import org.apache.catalina.util.Conversions;
-import org.apache.coyote.http11.UpgradeInbound;
-import org.apache.coyote.http11.UpgradeOutbound;
-import org.apache.tomcat.util.buf.B2CConverter;
-import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
-
-public abstract class StreamInbound implements UpgradeInbound {
-
-    // These attributes apply to the current frame being processed
-    private boolean fin = true;
-    private boolean rsv1 = false;
-    private boolean rsv2 = false;
-    private boolean rsv3 = false;
-    private int opCode = -1;
-    private long payloadLength = -1;
-
-    // These attributes apply to the message that may be spread over multiple
-    // frames
-    // TODO
-
-    private InputStream is = null;
-    private WsOutbound outbound;
-
-    @Override
-    public void setUpgradeOutbound(UpgradeOutbound upgradeOutbound) {
-        outbound = new WsOutbound(upgradeOutbound);
-    }
-
-
-    @Override
-    public void setInputStream(InputStream is) {
-        this.is = is;
-    }
-
-    public WsOutbound getStreamOutbound() {
-        return outbound;
-    }
-
-    @Override
-    public SocketState onData() throws IOException {
-        // Must be start the start of a frame
-
-        // Read the first byte
-        int i = is.read();
-
-        fin = (i & 0x80) > 0;
-
-        rsv1 = (i & 0x40) > 0;
-        rsv2 = (i & 0x20) > 0;
-        rsv3 = (i & 0x10) > 0;
-
-        if (rsv1 || rsv2 || rsv3) {
-            // TODO: Not supported.
-        }
-
-        opCode = (i & 0x0F);
-        validateOpCode(opCode);
-
-        // Read the next byte
-        i = is.read();
-
-        // Client data must be masked and this isn't
-        if ((i & 0x80) == 0) {
-            // TODO: Better message
-            throw new IOException();
-        }
-
-        payloadLength = i & 0x7F;
-        if (payloadLength == 126) {
-            byte[] extended = new byte[2];
-            is.read(extended);
-            payloadLength = Conversions.byteArrayToLong(extended);
-        } else if (payloadLength == 127) {
-            byte[] extended = new byte[8];
-            is.read(extended);
-            payloadLength = Conversions.byteArrayToLong(extended);
-        }
-
-        byte[] mask = new byte[4];
-        is.read(mask);
-
-        if (opCode == 1 || opCode == 2) {
-            WsInputStream wsIs = new WsInputStream(is, mask, payloadLength);
-            if (opCode == 2) {
-                onBinaryData(wsIs);
-            } else {
-                InputStreamReader r =
-                        new InputStreamReader(wsIs, B2CConverter.UTF_8);
-                onTextData(r);
-            }
-        }
-
-        // TODO: Doesn't currently handle multi-frame messages. That will need
-        //       some refactoring.
-
-        // TODO: Per frame extension handling is not currently supported.
-
-        // TODO: Handle other control frames.
-
-        // TODO: Handle control frames appearing in the middle of a multi-frame
-        //       message
-
-        return SocketState.UPGRADE;
-    }
-
-    protected abstract void onBinaryData(InputStream is) throws IOException;
-    protected abstract void onTextData(Reader r) throws IOException;
-
-    private void validateOpCode(int opCode) throws IOException {
-        switch (opCode) {
-        case 0:
-        case 1:
-        case 2:
-        case 8:
-        case 9:
-        case 10:
-            break;
-        default:
-            // TODO: Message
-            throw new IOException();
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.websocket;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+
+import org.apache.catalina.util.Conversions;
+import org.apache.coyote.http11.UpgradeInbound;
+import org.apache.coyote.http11.UpgradeOutbound;
+import org.apache.tomcat.util.buf.B2CConverter;
+import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
+
+public abstract class StreamInbound implements UpgradeInbound {
+
+    // These attributes apply to the current frame being processed
+    private boolean fin = true;
+    private boolean rsv1 = false;
+    private boolean rsv2 = false;
+    private boolean rsv3 = false;
+    private int opCode = -1;
+    private long payloadLength = -1;
+
+    // These attributes apply to the message that may be spread over multiple
+    // frames
+    // TODO
+
+    private InputStream is = null;
+    private WsOutbound outbound;
+
+    @Override
+    public void setUpgradeOutbound(UpgradeOutbound upgradeOutbound) {
+        outbound = new WsOutbound(upgradeOutbound);
+    }
+
+
+    @Override
+    public void setInputStream(InputStream is) {
+        this.is = is;
+    }
+
+    public WsOutbound getStreamOutbound() {
+        return outbound;
+    }
+
+    @Override
+    public SocketState onData() throws IOException {
+        // Must be start the start of a frame
+
+        // Read the first byte
+        int i = is.read();
+
+        fin = (i & 0x80) > 0;
+
+        rsv1 = (i & 0x40) > 0;
+        rsv2 = (i & 0x20) > 0;
+        rsv3 = (i & 0x10) > 0;
+
+        if (rsv1 || rsv2 || rsv3) {
+            // TODO: Not supported.
+        }
+
+        opCode = (i & 0x0F);
+        validateOpCode(opCode);
+
+        // Read the next byte
+        i = is.read();
+
+        // Client data must be masked and this isn't
+        if ((i & 0x80) == 0) {
+            // TODO: Better message
+            throw new IOException();
+        }
+
+        payloadLength = i & 0x7F;
+        if (payloadLength == 126) {
+            byte[] extended = new byte[2];
+            is.read(extended);
+            payloadLength = Conversions.byteArrayToLong(extended);
+        } else if (payloadLength == 127) {
+            byte[] extended = new byte[8];
+            is.read(extended);
+            payloadLength = Conversions.byteArrayToLong(extended);
+        }
+
+        byte[] mask = new byte[4];
+        is.read(mask);
+
+        if (opCode == 1 || opCode == 2) {
+            WsInputStream wsIs = new WsInputStream(is, mask, payloadLength);
+            if (opCode == 2) {
+                onBinaryData(wsIs);
+            } else {
+                InputStreamReader r =
+                        new InputStreamReader(wsIs, B2CConverter.UTF_8);
+                onTextData(r);
+            }
+        }
+
+        // TODO: Doesn't currently handle multi-frame messages. That will need
+        //       some refactoring.
+
+        // TODO: Per frame extension handling is not currently supported.
+
+        // TODO: Handle other control frames.
+
+        // TODO: Handle control frames appearing in the middle of a multi-frame
+        //       message
+
+        return SocketState.UPGRADE;
+    }
+
+    protected abstract void onBinaryData(InputStream is) throws IOException;
+    protected abstract void onTextData(Reader r) throws IOException;
+
+    private void validateOpCode(int opCode) throws IOException {
+        switch (opCode) {
+        case 0:
+        case 1:
+        case 2:
+        case 8:
+        case 9:
+        case 10:
+            break;
+        default:
+            // TODO: Message
+            throw new IOException();
+        }
+    }
+}

==================================================
WsInputStream.java
index 4215b1feb8..7e9f761352 100644
--- a/java/org/apache/catalina/websocket/WebSocketServlet.java
+++ b/java/org/apache/catalina/websocket/WebSocketServlet.java
@@ -1,147 +1,147 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.websocket;
-
-import java.io.IOException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.Collections;
-import java.util.Enumeration;
-import java.util.List;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.catalina.connector.RequestFacade;
-import org.apache.catalina.util.Base64;
-import org.apache.tomcat.util.buf.B2CConverter;
-
-/**
- * Provides the base implementation of a Servlet for processing WebSocket
- * connections as per RFC6455. It is expected that applications will extend this
- * implementation and provide application specific functionality.
- */
-public abstract class WebSocketServlet extends HttpServlet {
-
-    private static final long serialVersionUID = 1L;
-    private static final byte[] WS_ACCEPT =
-            "258EAFA5-E914-47DA-95CA-C5AB0DC85B11".getBytes(
-                    B2CConverter.ISO_8859_1);
-
-    private MessageDigest sha1Helper;
-
-
-    @Override
-    public void init() throws ServletException {
-        super.init();
-
-        try {
-            sha1Helper = MessageDigest.getInstance("SHA1");
-        } catch (NoSuchAlgorithmException e) {
-            throw new ServletException(e);
-        }
-    }
-
-
-    @Override
-    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
-            throws ServletException, IOException {
-
-        // Information required to send the server handshake message
-        String key;
-        String subProtocol = null;
-        List<String> extensions = Collections.emptyList();
-
-        if (!headerContains(req, "upgrade", "websocket")) {
-            resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
-            return;
-        }
-
-        if (!headerContains(req, "connection", "upgrade")) {
-            resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
-            return;
-        }
-
-        if (!headerContains(req, "sec-websocket-version", "13")) {
-            resp.setStatus(426);
-            resp.setHeader("Sec-WebSocket-Version", "13");
-            return;
-        }
-
-        key = req.getHeader("Sec-WebSocket-Key");
-        if (key == null) {
-            resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
-            return;
-        }
-
-        // TODO Read client handshake - Origin
-        //                              Sec-WebSocket-Protocol
-        //                              Sec-WebSocket-Extensions
-
-        // TODO Extensions require the ability to specify something (API TBD)
-        //      that can be passed to the Tomcat internals and process extension
-        //      data present when the frame is fragmented.
-
-        // If we got this far, all is good. Accept the connection.
-        resp.setHeader("upgrade", "websocket");
-        resp.setHeader("connection", "upgrade");
-        resp.setHeader("Sec-WebSocket-Accept", getWebSocketAccept(key));
-        if (subProtocol != null) {
-            // TODO
-        }
-        if (!extensions.isEmpty()) {
-            // TODO
-        }
-
-        // Small hack until the Servlet API provides a way to do this.
-        StreamInbound inbound = createWebSocketInbound();
-        ((RequestFacade) req).doUpgrade(inbound);
-    }
-
-
-    private boolean headerContains(HttpServletRequest req, String headerName,
-            String target) {
-        Enumeration<String> headers = req.getHeaders(headerName);
-        while (headers.hasMoreElements()) {
-            String header = headers.nextElement();
-            // TODO Splitting headers into tokens isn't quite this simple but
-            //      this should be OK in this case. It is tempting to change the
-            //      header parsing code so there is a one to one mapping between
-            //      token and enumeration entry.
-            String[] tokens = header.split(",");
-            for (String token : tokens) {
-                if (target.equalsIgnoreCase(token.trim())) {
-                    return true;
-                }
-            }
-        }
-        return true;
-    }
-
-
-    private String getWebSocketAccept(String key) {
-        synchronized (sha1Helper) {
-            sha1Helper.reset();
-            sha1Helper.update(key.getBytes(B2CConverter.ISO_8859_1));
-            return Base64.encode(sha1Helper.digest(WS_ACCEPT));
-        }
-    }
-
-    protected abstract StreamInbound createWebSocketInbound();
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.websocket;
+
+import java.io.IOException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.List;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.catalina.connector.RequestFacade;
+import org.apache.catalina.util.Base64;
+import org.apache.tomcat.util.buf.B2CConverter;
+
+/**
+ * Provides the base implementation of a Servlet for processing WebSocket
+ * connections as per RFC6455. It is expected that applications will extend this
+ * implementation and provide application specific functionality.
+ */
+public abstract class WebSocketServlet extends HttpServlet {
+
+    private static final long serialVersionUID = 1L;
+    private static final byte[] WS_ACCEPT =
+            "258EAFA5-E914-47DA-95CA-C5AB0DC85B11".getBytes(
+                    B2CConverter.ISO_8859_1);
+
+    private MessageDigest sha1Helper;
+
+
+    @Override
+    public void init() throws ServletException {
+        super.init();
+
+        try {
+            sha1Helper = MessageDigest.getInstance("SHA1");
+        } catch (NoSuchAlgorithmException e) {
+            throw new ServletException(e);
+        }
+    }
+
+
+    @Override
+    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+            throws ServletException, IOException {
+
+        // Information required to send the server handshake message
+        String key;
+        String subProtocol = null;
+        List<String> extensions = Collections.emptyList();
+
+        if (!headerContains(req, "upgrade", "websocket")) {
+            resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
+            return;
+        }
+
+        if (!headerContains(req, "connection", "upgrade")) {
+            resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
+            return;
+        }
+
+        if (!headerContains(req, "sec-websocket-version", "13")) {
+            resp.setStatus(426);
+            resp.setHeader("Sec-WebSocket-Version", "13");
+            return;
+        }
+
+        key = req.getHeader("Sec-WebSocket-Key");
+        if (key == null) {
+            resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
+            return;
+        }
+
+        // TODO Read client handshake - Origin
+        //                              Sec-WebSocket-Protocol
+        //                              Sec-WebSocket-Extensions
+
+        // TODO Extensions require the ability to specify something (API TBD)
+        //      that can be passed to the Tomcat internals and process extension
+        //      data present when the frame is fragmented.
+
+        // If we got this far, all is good. Accept the connection.
+        resp.setHeader("upgrade", "websocket");
+        resp.setHeader("connection", "upgrade");
+        resp.setHeader("Sec-WebSocket-Accept", getWebSocketAccept(key));
+        if (subProtocol != null) {
+            // TODO
+        }
+        if (!extensions.isEmpty()) {
+            // TODO
+        }
+
+        // Small hack until the Servlet API provides a way to do this.
+        StreamInbound inbound = createWebSocketInbound();
+        ((RequestFacade) req).doUpgrade(inbound);
+    }
+
+
+    private boolean headerContains(HttpServletRequest req, String headerName,
+            String target) {
+        Enumeration<String> headers = req.getHeaders(headerName);
+        while (headers.hasMoreElements()) {
+            String header = headers.nextElement();
+            // TODO Splitting headers into tokens isn't quite this simple but
+            //      this should be OK in this case. It is tempting to change the
+            //      header parsing code so there is a one to one mapping between
+            //      token and enumeration entry.
+            String[] tokens = header.split(",");
+            for (String token : tokens) {
+                if (target.equalsIgnoreCase(token.trim())) {
+                    return true;
+                }
+            }
+        }
+        return true;
+    }
+
+
+    private String getWebSocketAccept(String key) {
+        synchronized (sha1Helper) {
+            sha1Helper.reset();
+            sha1Helper.update(key.getBytes(B2CConverter.ISO_8859_1));
+            return Base64.encode(sha1Helper.digest(WS_ACCEPT));
+        }
+    }
+
+    protected abstract StreamInbound createWebSocketInbound();
+}

==================================================
WsOutbound.java
index 37063f3c8b..0dc0292df6 100644
--- a/java/org/apache/catalina/websocket/WsInputStream.java
+++ b/java/org/apache/catalina/websocket/WsInputStream.java
@@ -1,49 +1,49 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.websocket;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-public class WsInputStream extends java.io.InputStream {
-
-    private InputStream wrapped;
-    private byte[] mask;
-    private long remaining;
-    private long read;
-
-    public WsInputStream(InputStream wrapped, byte[] mask, long remaining) {
-        this.wrapped = wrapped;
-        this.mask = mask;
-        this.remaining = remaining;
-        this.read = 0;
-    }
-
-    @Override
-    public int read() throws IOException {
-        if (remaining == 0) {
-            return -1;
-        }
-
-        remaining--;
-        read++;
-
-        int masked = wrapped.read();
-        return masked ^ mask[(int) ((read - 1) % 4)];
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.websocket;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+public class WsInputStream extends java.io.InputStream {
+
+    private InputStream wrapped;
+    private byte[] mask;
+    private long remaining;
+    private long read;
+
+    public WsInputStream(InputStream wrapped, byte[] mask, long remaining) {
+        this.wrapped = wrapped;
+        this.mask = mask;
+        this.remaining = remaining;
+        this.read = 0;
+    }
+
+    @Override
+    public int read() throws IOException {
+        if (remaining == 0) {
+            return -1;
+        }
+
+        remaining--;
+        read++;
+
+        int masked = wrapped.read();
+        return masked ^ mask[(int) ((read - 1) % 4)];
+    }
+
+}

==================================================
UpgradeInbound.java
index 4d5399dd75..0f68ae6a2b 100644
--- a/java/org/apache/catalina/websocket/WsOutbound.java
+++ b/java/org/apache/catalina/websocket/WsOutbound.java
@@ -1,178 +1,178 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.websocket;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-
-import org.apache.coyote.http11.UpgradeOutbound;
-import org.apache.tomcat.util.buf.B2CConverter;
-
-public class WsOutbound {
-
-    private static final int DEFAULT_BUFFER_SIZE = 2048;
-
-    private UpgradeOutbound upgradeOutbound;
-    private ByteBuffer bb;
-    private CharBuffer cb;
-    protected Boolean text = null;
-    protected boolean firstFrame = true;
-
-
-    public WsOutbound(UpgradeOutbound upgradeOutbound) {
-        this.upgradeOutbound = upgradeOutbound;
-        // TODO: Make buffer size configurable
-        // Byte buffer needs to be 4* char buffer to be sure that char buffer
-        // can always we written into Byte buffer
-        this.bb = ByteBuffer.allocate(DEFAULT_BUFFER_SIZE * 4);
-        this.cb = CharBuffer.allocate(DEFAULT_BUFFER_SIZE);
-    }
-
-
-    public void writeBinaryData(int b) throws IOException {
-        if (bb.position() == bb.capacity()) {
-            doFlush(false);
-        }
-        if (text == null) {
-            text = Boolean.FALSE;
-        } else if (text == Boolean.TRUE) {
-            // Flush the character data
-            flush();
-            text = Boolean.FALSE;
-        }
-        bb.put((byte) (b & 0xFF));
-    }
-
-
-    public void writeTextData(char c) throws IOException {
-        if (cb.position() == cb.capacity()) {
-            doFlush(false);
-        }
-
-        if (text == null) {
-            text = Boolean.TRUE;
-        } else if (text == Boolean.FALSE) {
-            // Flush the binary data
-            flush();
-            text = Boolean.TRUE;
-        }
-        cb.append(c);
-    }
-
-
-    public void writeBinaryMessage(ByteBuffer msgBb) throws IOException {
-        if (text != null) {
-            // Empty the buffer
-            flush();
-        }
-        text = Boolean.FALSE;
-        doWriteBinary(msgBb, true);
-    }
-
-
-    public void writeTextMessage(CharBuffer msgCb) throws IOException {
-        if (text != null) {
-            // Empty the buffer
-            flush();
-        }
-        text = Boolean.TRUE;
-        doWriteText(msgCb, true);
-    }
-
-
-    public void flush() throws IOException {
-        doFlush(true);
-    }
-
-    private void doFlush(boolean finalFragment) throws IOException {
-        if (text == null) {
-            // No data
-            return;
-        }
-        if (text.booleanValue()) {
-            doWriteText(cb, finalFragment);
-        } else {
-            doWriteBinary(bb, finalFragment);
-        }
-    }
-
-
-    public void close() throws IOException {
-        doFlush(true);
-
-        // TODO: Send a close message
-        bb = null;
-        cb = null;
-        upgradeOutbound = null;
-    }
-
-
-    protected void doWriteBinary(ByteBuffer buffer, boolean finalFragment)
-            throws IOException {
-
-        // Prepare to write
-        buffer.flip();
-
-        // Work out the first byte
-        int first = 0x00;
-        if (finalFragment) {
-            first = first + 0x80;
-        }
-        if (firstFrame) {
-            if (text.booleanValue()) {
-                first = first + 0x1;
-            } else {
-                first = first + 0x2;
-            }
-        }
-        // Continuation frame is OpCode 0
-        upgradeOutbound.write(first);
-
-        // Note: buffer will never be more than 2^16 in length
-        if (buffer.limit() < 126) {
-            upgradeOutbound.write(buffer.limit());
-        } else {
-            upgradeOutbound.write(126);
-            upgradeOutbound.write(buffer.limit() >>> 8);
-            upgradeOutbound.write(buffer.limit() & 0xFF);
-        }
-
-        // Write the content
-        upgradeOutbound.write(buffer.array(), 0, buffer.limit());
-        upgradeOutbound.flush();
-
-        // Reset
-        if (finalFragment) {
-            text = null;
-            firstFrame = true;
-        } else {
-            firstFrame = false;
-        }
-        bb.clear();
-    }
-
-
-    protected void doWriteText(CharBuffer buffer, boolean finalFragment)
-            throws IOException {
-        buffer.flip();
-        B2CConverter.UTF_8.newEncoder().encode(buffer, bb, true);
-        doWriteBinary(bb, finalFragment);
-        // Reset
-        cb.clear();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.catalina.websocket;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+
+import org.apache.coyote.http11.UpgradeOutbound;
+import org.apache.tomcat.util.buf.B2CConverter;
+
+public class WsOutbound {
+
+    private static final int DEFAULT_BUFFER_SIZE = 2048;
+
+    private UpgradeOutbound upgradeOutbound;
+    private ByteBuffer bb;
+    private CharBuffer cb;
+    protected Boolean text = null;
+    protected boolean firstFrame = true;
+
+
+    public WsOutbound(UpgradeOutbound upgradeOutbound) {
+        this.upgradeOutbound = upgradeOutbound;
+        // TODO: Make buffer size configurable
+        // Byte buffer needs to be 4* char buffer to be sure that char buffer
+        // can always we written into Byte buffer
+        this.bb = ByteBuffer.allocate(DEFAULT_BUFFER_SIZE * 4);
+        this.cb = CharBuffer.allocate(DEFAULT_BUFFER_SIZE);
+    }
+
+
+    public void writeBinaryData(int b) throws IOException {
+        if (bb.position() == bb.capacity()) {
+            doFlush(false);
+        }
+        if (text == null) {
+            text = Boolean.FALSE;
+        } else if (text == Boolean.TRUE) {
+            // Flush the character data
+            flush();
+            text = Boolean.FALSE;
+        }
+        bb.put((byte) (b & 0xFF));
+    }
+
+
+    public void writeTextData(char c) throws IOException {
+        if (cb.position() == cb.capacity()) {
+            doFlush(false);
+        }
+
+        if (text == null) {
+            text = Boolean.TRUE;
+        } else if (text == Boolean.FALSE) {
+            // Flush the binary data
+            flush();
+            text = Boolean.TRUE;
+        }
+        cb.append(c);
+    }
+
+
+    public void writeBinaryMessage(ByteBuffer msgBb) throws IOException {
+        if (text != null) {
+            // Empty the buffer
+            flush();
+        }
+        text = Boolean.FALSE;
+        doWriteBinary(msgBb, true);
+    }
+
+
+    public void writeTextMessage(CharBuffer msgCb) throws IOException {
+        if (text != null) {
+            // Empty the buffer
+            flush();
+        }
+        text = Boolean.TRUE;
+        doWriteText(msgCb, true);
+    }
+
+
+    public void flush() throws IOException {
+        doFlush(true);
+    }
+
+    private void doFlush(boolean finalFragment) throws IOException {
+        if (text == null) {
+            // No data
+            return;
+        }
+        if (text.booleanValue()) {
+            doWriteText(cb, finalFragment);
+        } else {
+            doWriteBinary(bb, finalFragment);
+        }
+    }
+
+
+    public void close() throws IOException {
+        doFlush(true);
+
+        // TODO: Send a close message
+        bb = null;
+        cb = null;
+        upgradeOutbound = null;
+    }
+
+
+    protected void doWriteBinary(ByteBuffer buffer, boolean finalFragment)
+            throws IOException {
+
+        // Prepare to write
+        buffer.flip();
+
+        // Work out the first byte
+        int first = 0x00;
+        if (finalFragment) {
+            first = first + 0x80;
+        }
+        if (firstFrame) {
+            if (text.booleanValue()) {
+                first = first + 0x1;
+            } else {
+                first = first + 0x2;
+            }
+        }
+        // Continuation frame is OpCode 0
+        upgradeOutbound.write(first);
+
+        // Note: buffer will never be more than 2^16 in length
+        if (buffer.limit() < 126) {
+            upgradeOutbound.write(buffer.limit());
+        } else {
+            upgradeOutbound.write(126);
+            upgradeOutbound.write(buffer.limit() >>> 8);
+            upgradeOutbound.write(buffer.limit() & 0xFF);
+        }
+
+        // Write the content
+        upgradeOutbound.write(buffer.array(), 0, buffer.limit());
+        upgradeOutbound.flush();
+
+        // Reset
+        if (finalFragment) {
+            text = null;
+            firstFrame = true;
+        } else {
+            firstFrame = false;
+        }
+        bb.clear();
+    }
+
+
+    protected void doWriteText(CharBuffer buffer, boolean finalFragment)
+            throws IOException {
+        buffer.flip();
+        B2CConverter.UTF_8.newEncoder().encode(buffer, bb, true);
+        doWriteBinary(bb, finalFragment);
+        // Reset
+        cb.clear();
+    }
+}

==================================================
UpgradeInputStream.java
index 21eee21b40..c2ff58addc 100644
--- a/java/org/apache/coyote/http11/UpgradeInbound.java
+++ b/java/org/apache/coyote/http11/UpgradeInbound.java
@@ -1,37 +1,37 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.coyote.http11;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
-
-/**
- * Receives notification that there is data to be read on the upgraded
- * connection and processes it.
- *
- * TODO: Move this to a more appropriate package (TBD).
- */
-public interface UpgradeInbound {
-
-    void setInputStream(InputStream is);
-
-    SocketState onData() throws IOException;
-
-    void setUpgradeOutbound(UpgradeOutbound upgradeOutbound);
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.coyote.http11;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
+
+/**
+ * Receives notification that there is data to be read on the upgraded
+ * connection and processes it.
+ *
+ * TODO: Move this to a more appropriate package (TBD).
+ */
+public interface UpgradeInbound {
+
+    void setInputStream(InputStream is);
+
+    SocketState onData() throws IOException;
+
+    void setUpgradeOutbound(UpgradeOutbound upgradeOutbound);
+}

==================================================
UpgradeOutbound.java
index 0abd354b61..fbeb32f823 100644
--- a/java/org/apache/coyote/http11/UpgradeInputStream.java
+++ b/java/org/apache/coyote/http11/UpgradeInputStream.java
@@ -1,55 +1,55 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.coyote.http11;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-import org.apache.coyote.InputBuffer;
-import org.apache.tomcat.util.buf.ByteChunk;
-import org.apache.tomcat.util.buf.ByteChunk.ByteInputChannel;
-
-/**
- * Provides a buffered {@link InputStream} to read data from the upgraded
- * connection.
- *
- * TODO: Override a few more {@link InputStream} methods for efficiency.
- *
- * Based on a combination of {@link org.apache.catalina.connector.InputBuffer}
- * and (@link CoyoteInputStream}.
- */
-public class UpgradeInputStream extends InputStream
-        implements ByteInputChannel {
-
-    private InputBuffer ib = null;
-    private ByteChunk bb = new ByteChunk(8192);
-
-    public UpgradeInputStream(InputBuffer ib) {
-        this.ib = ib;
-        bb.setByteInputChannel(this);
-    }
-
-    @Override
-    public int read() throws IOException {
-        return bb.substract();
-    }
-
-    @Override
-    public int realReadBytes(byte[] cbuf, int off, int len) throws IOException {
-        return ib.doRead(bb, null);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.coyote.http11;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import org.apache.coyote.InputBuffer;
+import org.apache.tomcat.util.buf.ByteChunk;
+import org.apache.tomcat.util.buf.ByteChunk.ByteInputChannel;
+
+/**
+ * Provides a buffered {@link InputStream} to read data from the upgraded
+ * connection.
+ *
+ * TODO: Override a few more {@link InputStream} methods for efficiency.
+ *
+ * Based on a combination of {@link org.apache.catalina.connector.InputBuffer}
+ * and (@link CoyoteInputStream}.
+ */
+public class UpgradeInputStream extends InputStream
+        implements ByteInputChannel {
+
+    private InputBuffer ib = null;
+    private ByteChunk bb = new ByteChunk(8192);
+
+    public UpgradeInputStream(InputBuffer ib) {
+        this.ib = ib;
+        bb.setByteInputChannel(this);
+    }
+
+    @Override
+    public int read() throws IOException {
+        return bb.substract();
+    }
+
+    @Override
+    public int realReadBytes(byte[] cbuf, int off, int len) throws IOException {
+        return ib.doRead(bb, null);
+    }
+}

==================================================
UpgradeOutputStream.java
index 8345efa56c..e4853d66f1 100644
--- a/java/org/apache/coyote/http11/UpgradeOutbound.java
+++ b/java/org/apache/coyote/http11/UpgradeOutbound.java
@@ -1,46 +1,46 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.coyote.http11;
-
-import java.io.IOException;
-import java.io.OutputStream;
-
-/**
- * Allows data to be written to the upgraded connection.
- *
- * TODO: Move this to a more appropriate package (TBD).
- *
- * TODO: Override more methods for efficiency.
- */
-public class UpgradeOutbound extends OutputStream {
-
-    @Override
-    public void flush() throws IOException {
-        os.flush();
-    }
-
-    private OutputStream os;
-
-    public UpgradeOutbound(OutputStream os) {
-        this.os = os;
-    }
-
-    @Override
-    public void write(int b) throws IOException {
-        os.write(b);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.coyote.http11;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * Allows data to be written to the upgraded connection.
+ *
+ * TODO: Move this to a more appropriate package (TBD).
+ *
+ * TODO: Override more methods for efficiency.
+ */
+public class UpgradeOutbound extends OutputStream {
+
+    @Override
+    public void flush() throws IOException {
+        os.flush();
+    }
+
+    private OutputStream os;
+
+    public UpgradeOutbound(OutputStream os) {
+        this.os = os;
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+        os.write(b);
+    }
+}

==================================================
