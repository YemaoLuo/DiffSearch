a9662cf1899c4c550d31d1023e5bb1393c8d3e56
==================================================
Last cleanup of unused code for today. Still more todo.
==================================================
Mark Emlyn
==================================================
Sun Dec 6 01:03:55 2009 +0000
==================================================
Constants.java
Last cleanup of unused code for today. Still more todo.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@887625 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AccessFlags.java
index 6bc5051381..63be196297 100644
--- a/java/org/apache/tomcat/util/bcel/Constants.java
+++ b/java/org/apache/tomcat/util/bcel/Constants.java
@@ -24,13 +24,9 @@ package org.apache.tomcat.util.bcel;
  */
 public interface Constants {
 
-  /** Maximum value for an unsigned short.
-   */
-  public final static int MAX_SHORT = 65535; // 2^16 - 1
+  
 
-  /** Maximum value for an unsigned byte.
-   */
-  public final static int MAX_BYTE  = 255; // 2^8 - 1
+  
 
   /** One of the access flags for fields, methods, or classes.
    *  @see #ACC_PUBLIC
@@ -135,29 +131,6 @@ public interface Constants {
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short ALOAD            = 25;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ILOAD_0          = 26;
-  
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short LLOAD_0          = 30;
-  
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short FLOAD_0          = 34;
-  
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short DLOAD_0          = 38;
-  
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ALOAD_0          = 42;
-  
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ALOAD_3          = 45;
 
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
@@ -174,29 +147,6 @@ public interface Constants {
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short ASTORE           = 58;
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ISTORE_0         = 59;
-  
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short LSTORE_0         = 63;
-  
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short FSTORE_0         = 67;
-  
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short DSTORE_0         = 71;
-  
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ASTORE_0         = 75;
-  
-  /** Java VM opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
-  public static final short ASTORE_3         = 78;
   
   /** Java VM opcode.
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
@@ -321,16 +271,10 @@ public interface Constants {
    * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc.html">Opcode definitions in The Java Virtual Machine Specification</a> */
   public static final short JSR_W            = 201;
 
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions.doc.html#60105">Reserved opcodes in the Java Virtual Machine Specification</a> */
-  public static final short BREAKPOINT                = 202;
   
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions.doc.html#60105">Reserved opcodes in the Java Virtual Machine Specification</a> */
-  public static final short IMPDEP1                   = 254;
-  /** JVM internal opcode.
-   * @see <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Instructions.doc.html#60105">Reserved opcodes in the Java Virtual Machine Specification</a> */
-  public static final short IMPDEP2                   = 255;
+  
+  
+  
 
   /** Illegal opcode. */
   public static final short  UNDEFINED      = -1;
@@ -362,16 +306,13 @@ public interface Constants {
 
   /** Void data type (non-standard). */
   public static final byte T_VOID      = 12; // Non-standard
-  /** Array data type. */
-  public static final byte T_ARRAY     = 13;
+  
   /** Object data type. */
   public static final byte T_OBJECT    = 14;
-  /** Reference data type (deprecated). */
-  public static final byte T_REFERENCE = 14; // Deprecated
+  
   /** Unknown data type. */
   public static final byte T_UNKNOWN   = 15;
-  /** Address data type. */
-  public static final byte T_ADDRESS   = 16;
+  
 
   /** The primitive type names corresponding to the T_XX constants,
    * e.g., TYPE_NAMES[T_INT] = "int"
@@ -578,117 +519,9 @@ public interface Constants {
     ILLEGAL_OPCODE, "impdep1", "impdep2"
   };
 
-  /**
-   * Number of words consumed on operand stack by instructions.
-   * Indexed by opcode.  CONSUME_STACK[FALOAD] = number of words
-   * consumed from the stack by a faload instruction.
-   */ 
-  public static final int[] CONSUME_STACK = {
-    0/*nop*/, 0/*aconst_null*/, 0/*iconst_m1*/, 0/*iconst_0*/, 0/*iconst_1*/,
-    0/*iconst_2*/, 0/*iconst_3*/, 0/*iconst_4*/, 0/*iconst_5*/, 0/*lconst_0*/,
-    0/*lconst_1*/, 0/*fconst_0*/, 0/*fconst_1*/, 0/*fconst_2*/, 0/*dconst_0*/,
-    0/*dconst_1*/, 0/*bipush*/, 0/*sipush*/, 0/*ldc*/, 0/*ldc_w*/, 0/*ldc2_w*/, 0/*iload*/,
-    0/*lload*/, 0/*fload*/, 0/*dload*/, 0/*aload*/, 0/*iload_0*/, 0/*iload_1*/, 0/*iload_2*/,
-    0/*iload_3*/, 0/*lload_0*/, 0/*lload_1*/, 0/*lload_2*/, 0/*lload_3*/, 0/*fload_0*/,
-    0/*fload_1*/, 0/*fload_2*/, 0/*fload_3*/, 0/*dload_0*/, 0/*dload_1*/, 0/*dload_2*/,
-    0/*dload_3*/, 0/*aload_0*/, 0/*aload_1*/, 0/*aload_2*/, 0/*aload_3*/, 2/*iaload*/,
-    2/*laload*/, 2/*faload*/, 2/*daload*/, 2/*aaload*/, 2/*baload*/, 2/*caload*/, 2/*saload*/,
-    1/*istore*/, 2/*lstore*/, 1/*fstore*/, 2/*dstore*/, 1/*astore*/, 1/*istore_0*/,
-    1/*istore_1*/, 1/*istore_2*/, 1/*istore_3*/, 2/*lstore_0*/, 2/*lstore_1*/,
-    2/*lstore_2*/, 2/*lstore_3*/, 1/*fstore_0*/, 1/*fstore_1*/, 1/*fstore_2*/,
-    1/*fstore_3*/, 2/*dstore_0*/, 2/*dstore_1*/, 2/*dstore_2*/, 2/*dstore_3*/,
-    1/*astore_0*/, 1/*astore_1*/, 1/*astore_2*/, 1/*astore_3*/, 3/*iastore*/, 4/*lastore*/,
-    3/*fastore*/, 4/*dastore*/, 3/*aastore*/, 3/*bastore*/, 3/*castore*/, 3/*sastore*/,
-    1/*pop*/, 2/*pop2*/, 1/*dup*/, 2/*dup_x1*/, 3/*dup_x2*/, 2/*dup2*/, 3/*dup2_x1*/,
-    4/*dup2_x2*/, 2/*swap*/, 2/*iadd*/, 4/*ladd*/, 2/*fadd*/, 4/*dadd*/, 2/*isub*/, 4/*lsub*/,
-    2/*fsub*/, 4/*dsub*/, 2/*imul*/, 4/*lmul*/, 2/*fmul*/, 4/*dmul*/, 2/*idiv*/, 4/*ldiv*/,
-    2/*fdiv*/, 4/*ddiv*/, 2/*irem*/, 4/*lrem*/, 2/*frem*/, 4/*drem*/, 1/*ineg*/, 2/*lneg*/,
-    1/*fneg*/, 2/*dneg*/, 2/*ishl*/, 3/*lshl*/, 2/*ishr*/, 3/*lshr*/, 2/*iushr*/, 3/*lushr*/,
-    2/*iand*/, 4/*land*/, 2/*ior*/, 4/*lor*/, 2/*ixor*/, 4/*lxor*/, 0/*iinc*/,
-    1/*i2l*/, 1/*i2f*/, 1/*i2d*/, 2/*l2i*/, 2/*l2f*/, 2/*l2d*/, 1/*f2i*/, 1/*f2l*/,
-    1/*f2d*/, 2/*d2i*/, 2/*d2l*/, 2/*d2f*/, 1/*i2b*/, 1/*i2c*/, 1/*i2s*/, 
-    4/*lcmp*/, 2/*fcmpl*/, 2/*fcmpg*/, 4/*dcmpl*/, 4/*dcmpg*/, 1/*ifeq*/, 1/*ifne*/,
-    1/*iflt*/, 1/*ifge*/, 1/*ifgt*/, 1/*ifle*/, 2/*if_icmpeq*/, 2/*if_icmpne*/, 2/*if_icmplt*/,
-    2 /*if_icmpge*/, 2/*if_icmpgt*/, 2/*if_icmple*/, 2/*if_acmpeq*/, 2/*if_acmpne*/,
-    0/*goto*/, 0/*jsr*/, 0/*ret*/, 1/*tableswitch*/, 1/*lookupswitch*/, 1/*ireturn*/,
-    2/*lreturn*/, 1/*freturn*/, 2/*dreturn*/, 1/*areturn*/, 0/*return*/, 0/*getstatic*/,
-    UNPREDICTABLE/*putstatic*/, 1/*getfield*/, UNPREDICTABLE/*putfield*/,
-    UNPREDICTABLE/*invokevirtual*/, UNPREDICTABLE/*invokespecial*/,
-    UNPREDICTABLE/*invokestatic*/,
-    UNPREDICTABLE/*invokeinterface*/, UNDEFINED, 0/*new*/, 1/*newarray*/, 1/*anewarray*/,
-    1/*arraylength*/, 1/*athrow*/, 1/*checkcast*/, 1/*instanceof*/, 1/*monitorenter*/,
-    1/*monitorexit*/, 0/*wide*/, UNPREDICTABLE/*multianewarray*/, 1/*ifnull*/, 1/*ifnonnull*/,
-    0/*goto_w*/, 0/*jsr_w*/, 0/*breakpoint*/, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNPREDICTABLE/*impdep1*/, UNPREDICTABLE/*impdep2*/
-  };
+  
 
-  /**
-   * Number of words produced onto operand stack by instructions.
-   * Indexed by opcode.  CONSUME_STACK[DALOAD] = number of words
-   * consumed from the stack by a daload instruction.
-   */ 
-  public static final int[] PRODUCE_STACK = {
-    0/*nop*/, 1/*aconst_null*/, 1/*iconst_m1*/, 1/*iconst_0*/, 1/*iconst_1*/,
-    1/*iconst_2*/, 1/*iconst_3*/, 1/*iconst_4*/, 1/*iconst_5*/, 2/*lconst_0*/,
-    2/*lconst_1*/, 1/*fconst_0*/, 1/*fconst_1*/, 1/*fconst_2*/, 2/*dconst_0*/,
-    2/*dconst_1*/, 1/*bipush*/, 1/*sipush*/, 1/*ldc*/, 1/*ldc_w*/, 2/*ldc2_w*/, 1/*iload*/,
-    2/*lload*/, 1/*fload*/, 2/*dload*/, 1/*aload*/, 1/*iload_0*/, 1/*iload_1*/, 1/*iload_2*/,
-    1/*iload_3*/, 2/*lload_0*/, 2/*lload_1*/, 2/*lload_2*/, 2/*lload_3*/, 1/*fload_0*/,
-    1/*fload_1*/, 1/*fload_2*/, 1/*fload_3*/, 2/*dload_0*/, 2/*dload_1*/, 2/*dload_2*/,
-    2/*dload_3*/, 1/*aload_0*/, 1/*aload_1*/, 1/*aload_2*/, 1/*aload_3*/, 1/*iaload*/,
-    2/*laload*/, 1/*faload*/, 2/*daload*/, 1/*aaload*/, 1/*baload*/, 1/*caload*/, 1/*saload*/,
-    0/*istore*/, 0/*lstore*/, 0/*fstore*/, 0/*dstore*/, 0/*astore*/, 0/*istore_0*/,
-    0/*istore_1*/, 0/*istore_2*/, 0/*istore_3*/, 0/*lstore_0*/, 0/*lstore_1*/,
-    0/*lstore_2*/, 0/*lstore_3*/, 0/*fstore_0*/, 0/*fstore_1*/, 0/*fstore_2*/,
-    0/*fstore_3*/, 0/*dstore_0*/, 0/*dstore_1*/, 0/*dstore_2*/, 0/*dstore_3*/,
-    0/*astore_0*/, 0/*astore_1*/, 0/*astore_2*/, 0/*astore_3*/, 0/*iastore*/, 0/*lastore*/,
-    0/*fastore*/, 0/*dastore*/, 0/*aastore*/, 0/*bastore*/, 0/*castore*/, 0/*sastore*/,
-    0/*pop*/, 0/*pop2*/, 2/*dup*/, 3/*dup_x1*/, 4/*dup_x2*/, 4/*dup2*/, 5/*dup2_x1*/,
-    6/*dup2_x2*/, 2/*swap*/, 1/*iadd*/, 2/*ladd*/, 1/*fadd*/, 2/*dadd*/, 1/*isub*/, 2/*lsub*/,
-    1/*fsub*/, 2/*dsub*/, 1/*imul*/, 2/*lmul*/, 1/*fmul*/, 2/*dmul*/, 1/*idiv*/, 2/*ldiv*/,
-    1/*fdiv*/, 2/*ddiv*/, 1/*irem*/, 2/*lrem*/, 1/*frem*/, 2/*drem*/, 1/*ineg*/, 2/*lneg*/,
-    1/*fneg*/, 2/*dneg*/, 1/*ishl*/, 2/*lshl*/, 1/*ishr*/, 2/*lshr*/, 1/*iushr*/, 2/*lushr*/,
-    1/*iand*/, 2/*land*/, 1/*ior*/, 2/*lor*/, 1/*ixor*/, 2/*lxor*/,
-    0/*iinc*/, 2/*i2l*/, 1/*i2f*/, 2/*i2d*/, 1/*l2i*/, 1/*l2f*/, 2/*l2d*/, 1/*f2i*/,
-    2/*f2l*/, 2/*f2d*/, 1/*d2i*/, 2/*d2l*/, 1/*d2f*/,
-    1/*i2b*/, 1/*i2c*/, 1/*i2s*/, 1/*lcmp*/, 1/*fcmpl*/, 1/*fcmpg*/,
-    1/*dcmpl*/, 1/*dcmpg*/, 0/*ifeq*/, 0/*ifne*/, 0/*iflt*/, 0/*ifge*/, 0/*ifgt*/, 0/*ifle*/,
-    0/*if_icmpeq*/, 0/*if_icmpne*/, 0/*if_icmplt*/, 0/*if_icmpge*/, 0/*if_icmpgt*/,
-    0/*if_icmple*/, 0/*if_acmpeq*/, 0/*if_acmpne*/, 0/*goto*/, 1/*jsr*/, 0/*ret*/,
-    0/*tableswitch*/, 0/*lookupswitch*/, 0/*ireturn*/, 0/*lreturn*/, 0/*freturn*/,
-    0/*dreturn*/, 0/*areturn*/, 0/*return*/, UNPREDICTABLE/*getstatic*/, 0/*putstatic*/,
-    UNPREDICTABLE/*getfield*/, 0/*putfield*/, UNPREDICTABLE/*invokevirtual*/,
-    UNPREDICTABLE/*invokespecial*/, UNPREDICTABLE/*invokestatic*/,
-    UNPREDICTABLE/*invokeinterface*/, UNDEFINED, 1/*new*/, 1/*newarray*/, 1/*anewarray*/,
-    1/*arraylength*/, 1/*athrow*/, 1/*checkcast*/, 1/*instanceof*/, 0/*monitorenter*/,
-    0/*monitorexit*/, 0/*wide*/, 1/*multianewarray*/, 0/*ifnull*/, 0/*ifnonnull*/,
-    0/*goto_w*/, 1/*jsr_w*/, 0/*breakpoint*/, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,
-    UNDEFINED, UNPREDICTABLE/*impdep1*/, UNPREDICTABLE/*impdep2*/
-  };
+  
 
   /** Attributes and their corresponding names.
    */

==================================================
Annotations.java
index 2370b5594b..8d74a5b87e 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/AccessFlags.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/AccessFlags.java
@@ -16,8 +16,6 @@
  */
 package org.apache.tomcat.util.bcel.classfile;
 
-import org.apache.tomcat.util.bcel.Constants;
-
 /**
  * Super class for all objects that have modifiers like private, final, ...
  * I.e. classes, fields, and methods.
@@ -103,9 +101,7 @@ public abstract class AccessFlags implements java.io.Serializable {
     
 
 
-    public final boolean isInterface() {
-        return (access_flags & Constants.ACC_INTERFACE) != 0;
-    }
+    
 
 
     

==================================================
ClassParser.java
index a9947a02dd..e6ee0c371b 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Annotations.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Annotations.java
@@ -42,7 +42,7 @@ public abstract class Annotations extends Attribute {
      */
     public Annotations(byte annotation_type, int name_index, int length, DataInputStream file,
             ConstantPool constant_pool, boolean isRuntimeVisible) throws IOException {
-        this(annotation_type, name_index, length, (AnnotationEntry[]) null, constant_pool, isRuntimeVisible);
+        this(annotation_type, name_index, length, (AnnotationEntry[]) null, constant_pool);
         annotation_table_length = (file.readUnsignedShort());
         annotation_table = new AnnotationEntry[annotation_table_length];
         for (int i = 0; i < annotation_table_length; i++) {
@@ -59,7 +59,7 @@ public abstract class Annotations extends Attribute {
      * @param constant_pool Array of constants
      */
     public Annotations(byte annotation_type, int name_index, int length,
-            AnnotationEntry[] annotation_table, ConstantPool constant_pool , boolean isRuntimeVisible) {
+            AnnotationEntry[] annotation_table, ConstantPool constant_pool) {
         super(annotation_type, name_index, length, constant_pool);
         setAnnotationTable(annotation_table);
     }

==================================================
JavaClass.java
index 0e6d0f9ee6..72f9012e38 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ClassParser.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ClassParser.java
@@ -159,9 +159,7 @@ public final class ClassParser {
         }
         // Return the information we have gathered in a new object
         return new JavaClass(class_name_index, superclass_name_index, file_name, major, minor,
-                access_flags, constant_pool, interfaces, fields, methods, attributes, is_zip
-                        ? JavaClass.ZIP
-                        : JavaClass.FILE);
+                access_flags, constant_pool, interfaces, fields, methods, attributes);
     }
 
 

==================================================
StackMapEntry.java
index f5a24dac8b..30d913836b 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/JavaClass.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/JavaClass.java
@@ -18,13 +18,9 @@ package org.apache.tomcat.util.bcel.classfile;
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Set;
 import java.util.StringTokenizer;
-import java.util.TreeSet;
 import org.apache.tomcat.util.bcel.Constants;
 import org.apache.tomcat.util.bcel.util.BCELComparator;
-import org.apache.tomcat.util.bcel.util.ClassQueue;
-import org.apache.tomcat.util.bcel.util.SyntheticRepository;
 
 /**
  * Represents a Java class, i.e., the data structures, constant pool,
@@ -75,13 +71,6 @@ public class JavaClass extends AccessFlags implements Cloneable, Comparable {
             return THIS.getClassName().hashCode();
         }
     };
-    /**
-     * In cases where we go ahead and create something,
-     * use the default SyntheticRepository, because we
-     * don't know any better.
-     */
-    private transient org.apache.tomcat.util.bcel.util.Repository repository = SyntheticRepository
-            .getInstance();
 
 
     /**
@@ -104,7 +93,7 @@ public class JavaClass extends AccessFlags implements Cloneable, Comparable {
      */
     public JavaClass(int class_name_index, int superclass_name_index, String file_name, int major,
             int minor, int access_flags, ConstantPool constant_pool, int[] interfaces,
-            Field[] fields, Method[] methods, Attribute[] attributes, byte source) {
+            Field[] fields, Method[] methods, Attribute[] attributes) {
         if (interfaces == null) {
             interfaces = new int[0];
         }
@@ -213,55 +202,6 @@ public class JavaClass extends AccessFlags implements Cloneable, Comparable {
     }
 
 
-    
-
-
-    
-
-
-    
-
-
-    
-
-
-    
-
-
-    /**
-     * @return Names of implemented interfaces.
-     */
-    public String[] getInterfaceNames() {
-        return interface_names;
-    }
-
-
-    
-
-
-    
-
-
-    
-
-
-    
-
-
-    
-
-
-    
-
-
-    /**
-     * @return Superclass name.
-     */
-    public String getSuperclassName() {
-        return superclass_name;
-    }
-
-
     /**
      * @return String representing class contents.
      */
@@ -334,120 +274,6 @@ public class JavaClass extends AccessFlags implements Cloneable, Comparable {
         return (access_flags & Constants.ACC_SUPER) != 0;
     }
 
-
-    
-    
-    
-    
-    
-    
-    /**
-     * Sets the ClassRepository which loaded the JavaClass.
-     * Should be called immediately after parsing is done.
-     */
-    public void setRepository( org.apache.tomcat.util.bcel.util.Repository repository ) {
-        this.repository = repository;
-    }
-
-
-    
-
-
-    /**
-     * @return true, if this class is an implementation of interface inter
-     * @throws ClassNotFoundException if superclasses or superinterfaces
-     *   of this class can't be found
-     */
-    public boolean implementationOf( JavaClass inter ) throws ClassNotFoundException {
-        if (!inter.isInterface()) {
-            throw new IllegalArgumentException(inter.getClassName() + " is no interface");
-        }
-        if (this.equals(inter)) {
-            return true;
-        }
-        JavaClass[] super_interfaces = getAllInterfaces();
-        for (int i = 0; i < super_interfaces.length; i++) {
-            if (super_interfaces[i].equals(inter)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-
-    /**
-     * @return the superclass for this JavaClass object, or null if this
-     * is java.lang.Object
-     * @throws ClassNotFoundException if the superclass can't be found
-     */
-    public JavaClass getSuperClass() throws ClassNotFoundException {
-        if ("java.lang.Object".equals(getClassName())) {
-            return null;
-        }
-        return repository.loadClass(getSuperclassName());
-    }
-
-
-    /**
-     * @return list of super classes of this class in ascending order, i.e.,
-     * java.lang.Object is always the last element
-     * @throws ClassNotFoundException if any of the superclasses can't be found
-     */
-    public JavaClass[] getSuperClasses() throws ClassNotFoundException {
-        JavaClass clazz = this;
-        List allSuperClasses = new ArrayList();
-        for (clazz = clazz.getSuperClass(); clazz != null; clazz = clazz.getSuperClass()) {
-            allSuperClasses.add(clazz);
-        }
-        return (JavaClass[]) allSuperClasses.toArray(new JavaClass[allSuperClasses.size()]);
-    }
-
-
-    /**
-     * Get interfaces directly implemented by this JavaClass.
-     */
-    public JavaClass[] getInterfaces() throws ClassNotFoundException {
-        String[] _interfaces = getInterfaceNames();
-        JavaClass[] classes = new JavaClass[_interfaces.length];
-        for (int i = 0; i < _interfaces.length; i++) {
-            classes[i] = repository.loadClass(_interfaces[i]);
-        }
-        return classes;
-    }
-
-
-    /**
-     * Get all interfaces implemented by this JavaClass (transitively).
-     */
-    public JavaClass[] getAllInterfaces() throws ClassNotFoundException {
-        ClassQueue queue = new ClassQueue();
-        Set allInterfaces = new TreeSet();
-        queue.enqueue(this);
-        while (!queue.empty()) {
-            JavaClass clazz = queue.dequeue();
-            JavaClass souper = clazz.getSuperClass();
-            JavaClass[] _interfaces = clazz.getInterfaces();
-            if (clazz.isInterface()) {
-                allInterfaces.add(clazz);
-            } else {
-                if (souper != null) {
-                    queue.enqueue(souper);
-                }
-            }
-            for (int i = 0; i < _interfaces.length; i++) {
-                queue.enqueue(_interfaces[i]);
-            }
-        }
-        return (JavaClass[]) allInterfaces.toArray(new JavaClass[allInterfaces.size()]);
-    }
-
-
-    
-
-
-    
-
-
     /**
      * Return value as defined by given BCELComparator strategy.
      * By default two JavaClass objects are said to be equal when

==================================================
StackMapTableEntry.java
index a5ce2b4120..2ff99cc2be 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/StackMapEntry.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/StackMapEntry.java
@@ -45,7 +45,7 @@ public final class StackMapEntry implements Cloneable {
      * @throws IOException
      */
     StackMapEntry(DataInputStream file, ConstantPool constant_pool) throws IOException {
-        this(file.readShort(), file.readShort(), null, -1, null, constant_pool);
+        this(file.readShort(), file.readShort(), null, -1, null);
         types_of_locals = new StackMapType[number_of_locals];
         for (int i = 0; i < number_of_locals; i++) {
             types_of_locals[i] = new StackMapType(file, constant_pool);
@@ -60,7 +60,7 @@ public final class StackMapEntry implements Cloneable {
 
     public StackMapEntry(int byte_code_offset, int number_of_locals,
             StackMapType[] types_of_locals, int number_of_stack_items,
-            StackMapType[] types_of_stack_items, ConstantPool constant_pool) {
+            StackMapType[] types_of_stack_items) {
         this.byte_code_offset = byte_code_offset;
         this.number_of_locals = number_of_locals;
         this.types_of_locals = types_of_locals;

==================================================
Utility.java
index 76d79bcbf4..778f3568d3 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/StackMapTableEntry.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/StackMapTableEntry.java
@@ -48,7 +48,7 @@ public final class StackMapTableEntry implements Cloneable {
      * @throws IOException
      */
     StackMapTableEntry(DataInputStream file, ConstantPool constant_pool) throws IOException {
-        this(file.read(), -1, -1, null, -1, null, constant_pool);
+        this(file.read(), -1, -1, null, -1, null);
         
         if (frame_type >= Constants.SAME_FRAME && frame_type <= Constants.SAME_FRAME_MAX) {
         	byte_code_offset_delta = frame_type - Constants.SAME_FRAME;
@@ -94,7 +94,7 @@ public final class StackMapTableEntry implements Cloneable {
 
     public StackMapTableEntry(int tag, int byte_code_offset_delta, int number_of_locals,
             StackMapType[] types_of_locals, int number_of_stack_items,
-            StackMapType[] types_of_stack_items, ConstantPool constant_pool) {
+            StackMapType[] types_of_stack_items) {
     	this.frame_type = tag;
         this.byte_code_offset_delta = byte_code_offset_delta;
         this.number_of_locals = number_of_locals;

==================================================
ArrayType.java
index 3ec73ed500..a53ec7a2ed 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Utility.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Utility.java
@@ -705,45 +705,7 @@ public abstract class Utility {
     
 
 
-    /**
-     * Return type of signature as a byte value as defined in <em>Constants</em>
-     *
-     * @param  signature in format described above
-     * @return type of signature
-     * @see    Constants
-     */
-    public static final byte typeOfSignature( String signature ) throws ClassFormatException {
-        try {
-            switch (signature.charAt(0)) {
-                case 'B':
-                    return Constants.T_BYTE;
-                case 'C':
-                    return Constants.T_CHAR;
-                case 'D':
-                    return Constants.T_DOUBLE;
-                case 'F':
-                    return Constants.T_FLOAT;
-                case 'I':
-                    return Constants.T_INT;
-                case 'J':
-                    return Constants.T_LONG;
-                case 'L':
-                    return Constants.T_REFERENCE;
-                case '[':
-                    return Constants.T_ARRAY;
-                case 'V':
-                    return Constants.T_VOID;
-                case 'Z':
-                    return Constants.T_BOOLEAN;
-                case 'S':
-                    return Constants.T_SHORT;
-                default:
-                    throw new ClassFormatException("Invalid method signature: " + signature);
-            }
-        } catch (StringIndexOutOfBoundsException e) {
-            throw new ClassFormatException("Invalid method signature: " + signature, e);
-        }
-    }
+    
 
 
     
@@ -834,12 +796,7 @@ public abstract class Utility {
     
 
 
-    /** @return true, if character is one of (a, ... z, A, ... Z, 0, ... 9, _)
-     */
-    public static boolean isJavaIdentifierPart( char ch ) {
-        return ((ch >= 'a') && (ch <= 'z')) || ((ch >= 'A') && (ch <= 'Z'))
-                || ((ch >= '0') && (ch <= '9')) || (ch == '_');
-    }
+    
 
 
     

==================================================
BasicType.java
deleted file mode 100644
index 36ab2ad170..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ArrayType.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import org.apache.tomcat.util.bcel.Constants;
-
-/** 
- * Denotes array type, such as int[][]
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public final class ArrayType extends ReferenceType {
-
-    private int dimensions;
-    private Type basic_type;
-
-
-    
-
-
-    
-
-
-    /**
-     * Constructor for array of given type
-     *
-     * @param type type of array (may be an array itself)
-     */
-    public ArrayType(Type type, int dimensions) {
-        super(Constants.T_ARRAY, "<dummy>");
-        if ((dimensions < 1) || (dimensions > Constants.MAX_BYTE)) {
-            throw new ClassGenException("Invalid number of dimensions: " + dimensions);
-        }
-        switch (type.getType()) {
-            case Constants.T_ARRAY:
-                ArrayType array = (ArrayType) type;
-                this.dimensions = dimensions + array.dimensions;
-                basic_type = array.basic_type;
-                break;
-            case Constants.T_VOID:
-                throw new ClassGenException("Invalid type: void[]");
-            default: // Basic type or reference
-                this.dimensions = dimensions;
-                basic_type = type;
-                break;
-        }
-        StringBuffer buf = new StringBuffer();
-        for (int i = 0; i < this.dimensions; i++) {
-            buf.append('[');
-        }
-        buf.append(basic_type.getSignature());
-        signature = buf.toString();
-    }
-
-
-    
-
-
-    
-
-
-    
-
-
-    /** @return a hash code value for the object.
-     */
-    public int hashCode() {
-        return basic_type.hashCode() ^ dimensions;
-    }
-
-
-    /** @return true if both type objects refer to the same array type.
-     */
-    public boolean equals( Object _type ) {
-        if (_type instanceof ArrayType) {
-            ArrayType array = (ArrayType) _type;
-            return (array.dimensions == dimensions) && array.basic_type.equals(basic_type);
-        }
-        return false;
-    }
-}

==================================================
BranchHandle.java
index 8445f6a5f8..7a32aae3e2 100644
--- a/java/org/apache/tomcat/util/bcel/generic/BasicType.java
+++ b/java/org/apache/tomcat/util/bcel/generic/BasicType.java
@@ -40,30 +40,7 @@ public final class BasicType extends Type {
     }
 
 
-    public static final BasicType getType( byte type ) {
-        switch (type) {
-            case Constants.T_VOID:
-                return VOID;
-            case Constants.T_BOOLEAN:
-                return BOOLEAN;
-            case Constants.T_BYTE:
-                return BYTE;
-            case Constants.T_SHORT:
-                return SHORT;
-            case Constants.T_CHAR:
-                return CHAR;
-            case Constants.T_INT:
-                return INT;
-            case Constants.T_LONG:
-                return LONG;
-            case Constants.T_DOUBLE:
-                return DOUBLE;
-            case Constants.T_FLOAT:
-                return FLOAT;
-            default:
-                throw new ClassGenException("Invalid type: " + type);
-        }
-    }
+    
 
 
     /** @return a hash code value for the object.

==================================================
BranchInstruction.java
index cfc7d42d64..e0bab1d113 100644
--- a/java/org/apache/tomcat/util/bcel/generic/BranchHandle.java
+++ b/java/org/apache/tomcat/util/bcel/generic/BranchHandle.java
@@ -68,22 +68,6 @@ public final class BranchHandle extends InstructionHandle {
     }
 
 
-    protected int updatePosition( int offset, int max_offset ) {
-        int x = bi.updatePosition(offset, max_offset);
-        i_position = bi.position;
-        return x;
-    }
-
-
-    
-
-
-    
-
-
-    
-
-
     /** 
      * Set new contents. Old instruction is disposed and may not be used anymore.
      */

==================================================
CPInstruction.java
index b36b8821e4..2e48b98c96 100644
--- a/java/org/apache/tomcat/util/bcel/generic/BranchInstruction.java
+++ b/java/org/apache/tomcat/util/bcel/generic/BranchInstruction.java
@@ -18,7 +18,6 @@ package org.apache.tomcat.util.bcel.generic;
 
 import java.io.DataOutputStream;
 import java.io.IOException;
-import org.apache.tomcat.util.bcel.util.ByteSequence;
 
 /** 
  * Abstract super class for branching instructions like GOTO, IFEQ, etc..
@@ -94,22 +93,6 @@ public abstract class BranchInstruction extends Instruction implements Instructi
     }
 
 
-    /**
-     * Called by InstructionList.setPositions when setting the position for every
-     * instruction. In the presence of variable length instructions `setPositions'
-     * performs multiple passes over the instruction list to calculate the
-     * correct (byte) positions and offsets by calling this function.
-     *
-     * @param offset additional offset caused by preceding (variable length) instructions
-     * @param max_offset the maximum offset that may be caused by these instructions
-     * @return additional offset caused by possible change of this instruction's length
-     */
-    protected int updatePosition( int offset, int max_offset ) {
-        position += offset;
-        return 0;
-    }
-
-
     /**
      * Long output format:
      *
@@ -144,31 +127,6 @@ public abstract class BranchInstruction extends Instruction implements Instructi
     }
 
 
-    /**
-     * Read needed data (e.g. index) from file. Conversion to a InstructionHandle
-     * is done in InstructionList(byte[]).
-     *
-     * @param bytes input stream
-     * @param wide wide prefix?
-     * @see InstructionList
-     */
-    protected void initFromFile( ByteSequence bytes, boolean wide ) throws IOException {
-        length = 3;
-        index = bytes.readShort();
-    }
-
-
-    
-
-
-    /**
-     * @return target of branch instruction
-     */
-    public InstructionHandle getTarget() {
-        return target;
-    }
-
-
     /**
      * Set branch target
      * @param target branch target

==================================================
ConstantPoolGen.java
deleted file mode 100644
index 7043e2d892..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/CPInstruction.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import org.apache.tomcat.util.bcel.classfile.Constant;
-import org.apache.tomcat.util.bcel.classfile.ConstantClass;
-import org.apache.tomcat.util.bcel.classfile.ConstantPool;
-import org.apache.tomcat.util.bcel.util.ByteSequence;
-
-/** 
- * Abstract super class for instructions that use an index into the 
- * constant pool such as LDC, INVOKEVIRTUAL, etc.
- *
- * @see ConstantPoolGen
- * @see LDC
- * @see INVOKEVIRTUAL
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class CPInstruction extends Instruction implements TypedInstruction,
-        IndexedInstruction {
-
-    protected int index; // index to constant pool
-
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    CPInstruction() {
-    }
-
-
-    
-
-
-    /**
-     * Dump instruction as byte code to stream out.
-     * @param out Output stream
-     */
-    public void dump( DataOutputStream out ) throws IOException {
-        out.writeByte(opcode);
-        out.writeShort(index);
-    }
-
-
-    /**
-     * Long output format:
-     *
-     * &lt;name of opcode&gt; "["&lt;opcode number&gt;"]" 
-     * "("&lt;length of instruction&gt;")" "&lt;"&lt; constant pool index&gt;"&gt;"
-     *
-     * @param verbose long/short format switch
-     * @return mnemonic for instruction
-     */
-    public String toString( boolean verbose ) {
-        return super.toString(verbose) + " " + index;
-    }
-
-
-    /**
-     * @return mnemonic for instruction with symbolic references resolved
-     */
-    public String toString( ConstantPool cp ) {
-        Constant c = cp.getConstant(index);
-        String str = cp.constantToString(c);
-        if (c instanceof ConstantClass) {
-            str = str.replace('.', '/');
-        }
-        return org.apache.tomcat.util.bcel.Constants.OPCODE_NAMES[opcode] + " " + str;
-    }
-
-
-    /**
-     * Read needed data (i.e., index) from file.
-     * @param bytes input stream
-     * @param wide wide prefix?
-     */
-    protected void initFromFile( ByteSequence bytes, boolean wide ) throws IOException {
-        setIndex(bytes.readUnsignedShort());
-        length = 3;
-    }
-
-
-    /**
-     * @return index in constant pool referred by this instruction.
-     */
-    public final int getIndex() {
-        return index;
-    }
-
-
-    /**
-     * Set the index to constant pool.
-     * @param index in  constant pool.
-     */
-    public void setIndex( int index ) {
-        if (index < 0) {
-            throw new ClassGenException("Negative index value: " + index);
-        }
-        this.index = index;
-    }
-
-
-    /** @return type related with this instruction.
-     */
-    public Type getType( ConstantPoolGen cpg ) {
-        ConstantPool cp = cpg.getConstantPool();
-        String name = cp.getConstantString(index, org.apache.tomcat.util.bcel.Constants.CONSTANT_Class);
-        if (!name.startsWith("[")) {
-            name = "L" + name + ";";
-        }
-        return Type.getType(name);
-    }
-}

==================================================
FieldInstruction.java
index b7a3d4fd97..e0a9884024 100644
--- a/java/org/apache/tomcat/util/bcel/generic/ConstantPoolGen.java
+++ b/java/org/apache/tomcat/util/bcel/generic/ConstantPoolGen.java
@@ -45,7 +45,6 @@ public class ConstantPoolGen implements java.io.Serializable {
     protected int size; 
     protected Constant[] constants;
     protected int index = 1; // First entry (0) used by JVM
-    private static final String NAT_DELIM = "%";
 
     private static class Index implements java.io.Serializable {
 
@@ -84,21 +83,6 @@ public class ConstantPoolGen implements java.io.Serializable {
         }
     }
 
-    private Map class_table = new HashMap();
-
-
-    /**
-     * Look for ConstantClass in ConstantPool named `str'.
-     *
-     * @param str String to search for
-     * @return index on success, -1 otherwise
-     */
-    public int lookupClass( String str ) {
-        Index index = (Index) class_table.get(str.replace('.', '/'));
-        return (index != null) ? index.index : -1;
-    }
-
-
     /** 
      * Look for ConstantInteger in ConstantPool.
      *
@@ -285,22 +269,6 @@ public class ConstantPoolGen implements java.io.Serializable {
         return ret;
     }
 
-    private Map n_a_t_table = new HashMap();
-
-
-    /** 
-     * Look for ConstantNameAndType in ConstantPool.
-     *
-     * @param name of variable/method
-     * @param signature of variable/method
-     * @return index on success, -1 otherwise
-     */
-    public int lookupNameAndType( String name, String signature ) {
-        Index _index = (Index) n_a_t_table.get(name + NAT_DELIM + signature);
-        return (_index != null) ? _index.index : -1;
-    }
-
-    
     /**
      * @param i index in constant pool
      * @return constant pool entry at index i

==================================================
FieldOrMethod.java
deleted file mode 100644
index f32325c4eb..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FieldInstruction.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import org.apache.tomcat.util.bcel.classfile.ConstantPool;
-
-/**
- * Super class for the GET/PUTxxx family of instructions.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class FieldInstruction extends FieldOrMethod implements TypedInstruction {
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    FieldInstruction() {
-    }
-
-
-    
-
-
-    /**
-     * @return mnemonic for instruction with symbolic references resolved
-     */
-    public String toString( ConstantPool cp ) {
-        return org.apache.tomcat.util.bcel.Constants.OPCODE_NAMES[opcode] + " "
-                + cp.constantToString(index, org.apache.tomcat.util.bcel.Constants.CONSTANT_Fieldref);
-    }
-
-
-    /** @return size of field (1 or 2)
-     */
-    protected int getFieldSize( ConstantPoolGen cpg ) {
-    	return Type.getTypeSize(getSignature(cpg));
-    }
-
-
-    /** @return return type of referenced field
-     */
-    public Type getType( ConstantPoolGen cpg ) {
-        return getFieldType(cpg);
-    }
-
-
-    /** @return type of field
-     */
-    public Type getFieldType( ConstantPoolGen cpg ) {
-        return Type.getType(getSignature(cpg));
-    }
-
-
-    
-}

==================================================
GotoInstruction.java
deleted file mode 100644
index 56a6721b39..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/FieldOrMethod.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import org.apache.tomcat.util.bcel.classfile.ConstantCP;
-import org.apache.tomcat.util.bcel.classfile.ConstantNameAndType;
-import org.apache.tomcat.util.bcel.classfile.ConstantPool;
-import org.apache.tomcat.util.bcel.classfile.ConstantUtf8;
-
-/**
- * Super class for InvokeInstruction and FieldInstruction, since they have
- * some methods in common!
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class FieldOrMethod extends CPInstruction implements LoadClass {
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    FieldOrMethod() {
-    }
-
-
-    
-
-
-    /** @return signature of referenced method/field.
-     */
-    public String getSignature( ConstantPoolGen cpg ) {
-        ConstantPool cp = cpg.getConstantPool();
-        ConstantCP cmr = (ConstantCP) cp.getConstant(index);
-        ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());
-        return ((ConstantUtf8) cp.getConstant(cnat.getSignatureIndex())).getBytes();
-    }
-
-
-    
-
-
-    
-
-
-    
-
-
-    
-
-
-    
-}

==================================================
IndexedInstruction.java
deleted file mode 100644
index 53a7a76016..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/GotoInstruction.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * Super class for GOTO
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class GotoInstruction extends BranchInstruction implements UnconditionalBranch {
-
-    
-
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    GotoInstruction() {
-    }
-}

==================================================
Instruction.java
index be50d6317e..632f957714 100644
--- a/java/org/apache/tomcat/util/bcel/generic/IndexedInstruction.java
+++ b/java/org/apache/tomcat/util/bcel/generic/IndexedInstruction.java
@@ -28,5 +28,5 @@ public interface IndexedInstruction {
     public int getIndex();
 
 
-    public void setIndex( int index );
+    
 }

==================================================
InstructionHandle.java
index 3cd4f689bc..5ebe2f2201 100644
--- a/java/org/apache/tomcat/util/bcel/generic/Instruction.java
+++ b/java/org/apache/tomcat/util/bcel/generic/Instruction.java
@@ -20,8 +20,6 @@ import java.io.DataOutputStream;
 import java.io.IOException;
 import java.io.Serializable;
 import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.classfile.ConstantPool;
-import org.apache.tomcat.util.bcel.util.ByteSequence;
 
 /** 
  * Abstract super class for all Java byte codes.
@@ -92,61 +90,6 @@ public abstract class Instruction implements Cloneable, Serializable {
     }
 
 
-    /**
-     * @return mnemonic for instruction with sumbolic references resolved
-     */
-    public String toString( ConstantPool cp ) {
-        return toString(false);
-    }
-
-
-    
-
-
-    /**
-     * Read needed data (e.g. index) from file.
-     *
-     * @param bytes byte sequence to read from
-     * @param wide "wide" instruction flag
-     */
-    protected void initFromFile( ByteSequence bytes, boolean wide ) throws IOException {
-    }
-
-
-    
-
-    /**
-     * This method also gives right results for instructions whose
-     * effect on the stack depends on the constant pool entry they
-     * reference.
-     *  @return Number of words consumed from stack by this instruction,
-     * or Constants.UNPREDICTABLE, if this can not be computed statically
-     */
-    public int consumeStack( ConstantPoolGen cpg ) {
-        return Constants.CONSUME_STACK[opcode];
-    }
-
-
-    /**
-     * This method also gives right results for instructions whose
-     * effect on the stack depends on the constant pool entry they
-     * reference.
-     * @return Number of words produced onto stack by this instruction,
-     * or Constants.UNPREDICTABLE, if this can not be computed statically
-     */
-    public int produceStack( ConstantPoolGen cpg ) {
-        return Constants.PRODUCE_STACK[opcode];
-    }
-
-
-    /**
-     * @return this instructions opcode
-     */
-    public short getOpcode() {
-        return opcode;
-    }
-
-
     /**
      * @return length (in bytes) of instruction
      */
@@ -160,13 +103,6 @@ public abstract class Instruction implements Cloneable, Serializable {
     void dispose() {
     }
 
-
-    
-
-
-    
-
-
     /** Check for equality, delegated to comparator
      * @return true if that is an Instruction and has the same opcode
      */

==================================================
InstructionList.java
index 5c1be76cd9..885dc25274 100644
--- a/java/org/apache/tomcat/util/bcel/generic/InstructionHandle.java
+++ b/java/org/apache/tomcat/util/bcel/generic/InstructionHandle.java
@@ -40,20 +40,16 @@ import org.apache.tomcat.util.bcel.classfile.Utility;
  */
 public class InstructionHandle implements java.io.Serializable {
 
-    InstructionHandle next, prev; // Will be set from the outside
+    InstructionHandle next; // Will be set from the outside
     Instruction instruction;
     protected int i_position = -1; // byte code offset of instruction
     private Set targeters;
 
 
-    public final InstructionHandle getNext() {
-        return next;
-    }
+    
 
 
-    public final InstructionHandle getPrev() {
-        return prev;
-    }
+    
 
 
     public final Instruction getInstruction() {
@@ -88,26 +84,6 @@ public class InstructionHandle implements java.io.Serializable {
 
     private static InstructionHandle ih_list = null; // List of reusable handles
 
-
-    
-
-
-    /**
-     * Called by InstructionList.setPositions when setting the position for every
-     * instruction. In the presence of variable length instructions `setPositions()'
-     * performs multiple passes over the instruction list to calculate the
-     * correct (byte) positions and offsets by calling this function.
-     *
-     * @param offset additional offset caused by preceding (variable length) instructions
-     * @param max_offset the maximum offset that may be caused by these instructions
-     * @return additional offset caused by possible change of this instruction's length
-     */
-    protected int updatePosition( int offset, int max_offset ) {
-        i_position += offset;
-        return 0;
-    }
-
-
     /** @return the position, i.e., the byte code offset of the contained
      * instruction. This is accurate only after
      * InstructionList.setPositions() has been called.

==================================================
InvokeInstruction.java
index 94dd0cac63..6e4a8216c3 100644
--- a/java/org/apache/tomcat/util/bcel/generic/InstructionList.java
+++ b/java/org/apache/tomcat/util/bcel/generic/InstructionList.java
@@ -51,30 +51,6 @@ public class InstructionList implements Serializable {
     
 
 
-    /**
-     * Search for given Instruction reference, start at beginning of list.
-     *
-     * @param i instruction to search for
-     * @return instruction found on success, null otherwise
-     */
-    private InstructionHandle findInstruction1( Instruction i ) {
-        for (InstructionHandle ih = start; ih != null; ih = ih.next) {
-            if (ih.instruction == i) {
-                return ih;
-            }
-        }
-        return null;
-    }
-
-
-    public boolean contains( Instruction i ) {
-        return findInstruction1(i) != null;
-    }
-
-
-    
-
-
     public String toString() {
         return toString(true);
     }

==================================================
JsrInstruction.java
deleted file mode 100644
index b4f3863ad1..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/InvokeInstruction.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import java.util.StringTokenizer;
-import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.classfile.Constant;
-import org.apache.tomcat.util.bcel.classfile.ConstantPool;
-
-/**
- * Super class for the INVOKExxx family of instructions.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class InvokeInstruction extends FieldOrMethod implements ExceptionThrower,
-        TypedInstruction, StackConsumer, StackProducer {
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    InvokeInstruction() {
-    }
-
-
-    
-
-
-    /**
-     * @return mnemonic for instruction with symbolic references resolved
-     */
-    public String toString( ConstantPool cp ) {
-        Constant c = cp.getConstant(index);
-        StringTokenizer tok = new StringTokenizer(cp.constantToString(c));
-        return Constants.OPCODE_NAMES[opcode] + " " + tok.nextToken().replace('.', '/')
-                + tok.nextToken();
-    }
-
-
-    /**
-     * Also works for instructions whose stack effect depends on the
-     * constant pool entry they reference.
-     * @return Number of words consumed from stack by this instruction
-     */
-    public int consumeStack( ConstantPoolGen cpg ) {
-        int sum;
-        if (opcode == Constants.INVOKESTATIC) {
-            sum = 0;
-        } else {
-            sum = 1; // this reference
-        }
-        
-        String signature = getSignature(cpg);
-        sum += Type.getArgumentTypesSize(signature);
-        return sum;
-    }
-
-
-    /**
-     * Also works for instructions whose stack effect depends on the
-     * constant pool entry they reference.
-     * @return Number of words produced onto stack by this instruction
-     */
-    public int produceStack( ConstantPoolGen cpg ) {
-    	String signature = getSignature(cpg);
-    	return Type.getReturnTypeSize(signature);
-    }
-
-
-    /** @return return type of referenced method.
-     */
-    public Type getType( ConstantPoolGen cpg ) {
-        return getReturnType(cpg);
-    }
-
-
-    
-
-
-    /** @return return type of referenced method.
-     */
-    public Type getReturnType( ConstantPoolGen cpg ) {
-        return Type.getReturnType(getSignature(cpg));
-    }
-
-
-    
-}

==================================================
LDC.java
deleted file mode 100644
index 667e5d9cae..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/JsrInstruction.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/** 
- * Super class for JSR - Jump to subroutine
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class JsrInstruction extends BranchInstruction implements UnconditionalBranch,
-        TypedInstruction, StackProducer {
-
-    
-
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    JsrInstruction() {
-    }
-
-
-    
-
-
-    
-}

==================================================
LoadClass.java
deleted file mode 100644
index c50c911188..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LDC.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import org.apache.tomcat.util.bcel.util.ByteSequence;
-
-/** 
- * LDC - Push item from constant pool.
- *
- * <PRE>Stack: ... -&gt; ..., item</PRE>
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class LDC extends CPInstruction implements PushInstruction, ExceptionThrower,
-        TypedInstruction {
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     */
-    LDC() {
-    }
-
-
-    
-
-
-    // Adjust to proper size
-    protected final void setSize() {
-        if (index <= org.apache.tomcat.util.bcel.Constants.MAX_BYTE) { // Fits in one byte?
-            opcode = org.apache.tomcat.util.bcel.Constants.LDC;
-            length = 2;
-        } else {
-            opcode = org.apache.tomcat.util.bcel.Constants.LDC_W;
-            length = 3;
-        }
-    }
-
-
-    /**
-     * Dump instruction as byte code to stream out.
-     * @param out Output stream
-     */
-    public void dump( DataOutputStream out ) throws IOException {
-        out.writeByte(opcode);
-        if (length == 2) {
-            out.writeByte(index);
-        } else {
-            out.writeShort(index);
-        }
-    }
-
-
-    /**
-     * Set the index to constant pool and adjust size.
-     */
-    public final void setIndex( int index ) {
-        super.setIndex(index);
-        setSize();
-    }
-
-
-    /**
-     * Read needed data (e.g. index) from file.
-     */
-    protected void initFromFile( ByteSequence bytes, boolean wide ) throws IOException {
-        length = 2;
-        index = bytes.readUnsignedByte();
-    }
-
-
-    
-
-
-    public Type getType( ConstantPoolGen cpg ) {
-        switch (cpg.getConstantPool().getConstant(index).getTag()) {
-            case org.apache.tomcat.util.bcel.Constants.CONSTANT_String:
-                return Type.STRING;
-            case org.apache.tomcat.util.bcel.Constants.CONSTANT_Float:
-                return Type.FLOAT;
-            case org.apache.tomcat.util.bcel.Constants.CONSTANT_Integer:
-                return Type.INT;
-            case org.apache.tomcat.util.bcel.Constants.CONSTANT_Class:
-                return Type.CLASS;
-            default: // Never reached
-                throw new RuntimeException("Unknown or invalid constant type at " + index);
-        }
-    }
-
-
-    
-}

==================================================
LoadInstruction.java
deleted file mode 100644
index f40ba91437..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LoadClass.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Denotes that an instruction may start the process of loading and resolving 
- * the referenced class in the Virtual Machine.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public interface LoadClass {
-
-    
-
-
-    
-}

==================================================
LocalVariableInstruction.java
deleted file mode 100644
index 5a4f361f40..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LoadInstruction.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Denotes an unparameterized instruction to load a value from a local
- * variable, e.g. ILOAD.
- *
- * @version $Id$
- * @author <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class LoadInstruction extends LocalVariableInstruction implements PushInstruction {
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     * tag and length are defined in readInstruction and initFromFile, respectively.
-     */
-    LoadInstruction(short canon_tag, short c_tag) {
-        super(canon_tag, c_tag);
-    }
-
-
-    /**
-     * @param opcode Instruction opcode
-     * @param c_tag Instruction number for compact version, ALOAD_0, e.g.
-     * @param n local variable index (unsigned short)
-     */
-    protected LoadInstruction(short opcode, short c_tag, int n) {
-        super(opcode, c_tag, n);
-    }
-}

==================================================
NEWARRAY.java
deleted file mode 100644
index 0f14ec653b..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/LocalVariableInstruction.java
+++ /dev/null
@@ -1,198 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.util.ByteSequence;
-
-/**
- * Abstract super class for instructions dealing with local variables.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class LocalVariableInstruction extends Instruction implements TypedInstruction,
-        IndexedInstruction {
-
-    protected int n = -1; // index of referenced variable
-    private short c_tag = -1; // compact version, such as ILOAD_0
-    private short canon_tag = -1; // canonical tag such as ILOAD
-
-
-    private final boolean wide() {
-        return n > Constants.MAX_BYTE;
-    }
-
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     * tag and length are defined in readInstruction and initFromFile, respectively.
-     */
-    LocalVariableInstruction(short canon_tag, short c_tag) {
-        super();
-        this.canon_tag = canon_tag;
-        this.c_tag = c_tag;
-    }
-
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Also used by IINC()!
-     */
-    LocalVariableInstruction() {
-    }
-
-
-    /**
-     * @param opcode Instruction opcode
-     * @param c_tag Instruction number for compact version, ALOAD_0, e.g.
-     * @param n local variable index (unsigned short)
-     */
-    protected LocalVariableInstruction(short opcode, short c_tag, int n) {
-        super(opcode, (short) 2);
-        this.c_tag = c_tag;
-        canon_tag = opcode;
-        setIndex(n);
-    }
-
-
-    /**
-     * Dump instruction as byte code to stream out.
-     * @param out Output stream
-     */
-    public void dump( DataOutputStream out ) throws IOException {
-        if (wide()) {
-            out.writeByte(Constants.WIDE);
-        }
-        out.writeByte(opcode);
-        if (length > 1) { // Otherwise ILOAD_n, instruction, e.g.
-            if (wide()) {
-                out.writeShort(n);
-            } else {
-                out.writeByte(n);
-            }
-        }
-    }
-
-
-    /**
-     * Long output format:
-     *
-     * &lt;name of opcode&gt; "["&lt;opcode number&gt;"]" 
-     * "("&lt;length of instruction&gt;")" "&lt;"&lt; local variable index&gt;"&gt;"
-     *
-     * @param verbose long/short format switch
-     * @return mnemonic for instruction
-     */
-    public String toString( boolean verbose ) {
-        if (((opcode >= Constants.ILOAD_0) && (opcode <= Constants.ALOAD_3))
-                || ((opcode >= Constants.ISTORE_0) && (opcode <= Constants.ASTORE_3))) {
-            return super.toString(verbose);
-        } else {
-            return super.toString(verbose) + " " + n;
-        }
-    }
-
-
-    /**
-     * Read needed data (e.g. index) from file.
-     * PRE: (ILOAD <= tag <= ALOAD_3) || (ISTORE <= tag <= ASTORE_3)
-     */
-    protected void initFromFile( ByteSequence bytes, boolean wide ) throws IOException {
-        if (wide) {
-            n = bytes.readUnsignedShort();
-            length = 4;
-        } else if (((opcode >= Constants.ILOAD) && (opcode <= Constants.ALOAD))
-                || ((opcode >= Constants.ISTORE) && (opcode <= Constants.ASTORE))) {
-            n = bytes.readUnsignedByte();
-            length = 2;
-        } else if (opcode <= Constants.ALOAD_3) { // compact load instruction such as ILOAD_2
-            n = (opcode - Constants.ILOAD_0) % 4;
-            length = 1;
-        } else { // Assert ISTORE_0 <= tag <= ASTORE_3
-            n = (opcode - Constants.ISTORE_0) % 4;
-            length = 1;
-        }
-    }
-
-
-    /**
-     * @return local variable index  referred by this instruction.
-     */
-    public final int getIndex() {
-        return n;
-    }
-
-
-    /**
-     * Set the local variable index
-     */
-    public void setIndex( int n ) {
-        if ((n < 0) || (n > Constants.MAX_SHORT)) {
-            throw new ClassGenException("Illegal value: " + n);
-        }
-        this.n = n;
-        if (n >= 0 && n <= 3) { // Use more compact instruction xLOAD_n
-            opcode = (short) (c_tag + n);
-            length = 1;
-        } else {
-            opcode = canon_tag;
-            if (wide()) {
-                length = 4;
-            } else {
-                length = 2;
-            }
-        }
-    }
-
-
-    
-
-
-    /**
-     * Returns the type associated with the instruction - 
-     * in case of ALOAD or ASTORE Type.OBJECT is returned.
-     * This is just a bit incorrect, because ALOAD and ASTORE
-     * may work on every ReferenceType (including Type.NULL) and
-     * ASTORE may even work on a ReturnaddressType .
-     * @return type associated with the instruction
-     */
-    public Type getType( ConstantPoolGen cp ) {
-        switch (canon_tag) {
-            case Constants.ILOAD:
-            case Constants.ISTORE:
-                return Type.INT;
-            case Constants.LLOAD:
-            case Constants.LSTORE:
-                return Type.LONG;
-            case Constants.DLOAD:
-            case Constants.DSTORE:
-                return Type.DOUBLE;
-            case Constants.FLOAD:
-            case Constants.FSTORE:
-                return Type.FLOAT;
-            case Constants.ALOAD:
-            case Constants.ASTORE:
-                return Type.OBJECT;
-            default:
-                throw new ClassGenException("Oops: unknown case in switch" + canon_tag);
-        }
-    }
-}

==================================================
ObjectType.java
index 4019358d62..c1bca1b843 100644
--- a/java/org/apache/tomcat/util/bcel/generic/NEWARRAY.java
+++ b/java/org/apache/tomcat/util/bcel/generic/NEWARRAY.java
@@ -18,7 +18,6 @@ package org.apache.tomcat.util.bcel.generic;
 
 import java.io.DataOutputStream;
 import java.io.IOException;
-import org.apache.tomcat.util.bcel.util.ByteSequence;
 
 /** 
  * NEWARRAY -  Create new array of basic type (int, short, ...)
@@ -75,16 +74,4 @@ public class NEWARRAY extends Instruction implements AllocationInstruction, Exce
     public String toString( boolean verbose ) {
         return super.toString(verbose) + " " + org.apache.tomcat.util.bcel.Constants.TYPE_NAMES[type];
     }
-
-
-    /**
-     * Read needed data (e.g. index) from file.
-     */
-    protected void initFromFile( ByteSequence bytes, boolean wide ) throws IOException {
-        type = bytes.readByte();
-        length = 2;
-    }
-
-
-    
 }

==================================================
PopInstruction.java
deleted file mode 100644
index e1a5065bb4..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/ObjectType.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-import org.apache.tomcat.util.bcel.Constants;
-
-/** 
- * Denotes reference such as java.lang.String.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class ObjectType extends ReferenceType {
-
-    private String class_name; // Class name of type
-
-
-    /**
-     * @param class_name fully qualified class name, e.g. java.lang.String
-     */
-    public ObjectType(String class_name) {
-        super(Constants.T_REFERENCE, "L" + class_name.replace('.', '/') + ";");
-        this.class_name = class_name.replace('/', '.');
-    }
-
-
-    
-
-
-    /** @return a hash code value for the object.
-     */
-    public int hashCode() {
-        return class_name.hashCode();
-    }
-
-
-    /** @return true if both type objects refer to the same class.
-     */
-    public boolean equals( Object type ) {
-        return (type instanceof ObjectType)
-                ? ((ObjectType) type).class_name.equals(class_name)
-                : false;
-    }
-
-
-    
-
-
-    
-
-
-    
-
-
-    
-
-
-    
-
-
-    
-}

==================================================
ReferenceType.java
deleted file mode 100644
index d3f5d708d8..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/PopInstruction.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Denotes an unparameterized instruction to pop a value on top from the stack,
- * such as ISTORE, POP, PUTSTATIC.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- * @see ISTORE
- * @see POP
- */
-public interface PopInstruction extends StackConsumer {
-}

==================================================
Select.java
index 74d05276aa..e0a6b11e84 100644
--- a/java/org/apache/tomcat/util/bcel/generic/ReferenceType.java
+++ b/java/org/apache/tomcat/util/bcel/generic/ReferenceType.java
@@ -26,9 +26,7 @@ import org.apache.tomcat.util.bcel.Constants;
  */
 public abstract class ReferenceType extends Type {
 
-    protected ReferenceType(byte t, String s) {
-        super(t, s);
-    }
+    
 
 
     /** Class is non-abstract but not instantiable from the outside

==================================================
StoreInstruction.java
index d08d6a912e..4240f9e999 100644
--- a/java/org/apache/tomcat/util/bcel/generic/Select.java
+++ b/java/org/apache/tomcat/util/bcel/generic/Select.java
@@ -18,7 +18,6 @@ package org.apache.tomcat.util.bcel.generic;
 
 import java.io.DataOutputStream;
 import java.io.IOException;
-import org.apache.tomcat.util.bcel.util.ByteSequence;
 
 /** 
  * Select - Abstract super class for LOOKUPSWITCH and TABLESWITCH instructions.
@@ -51,32 +50,6 @@ public abstract class Select extends BranchInstruction implements VariableLength
 
 
     
-
-
-    /**
-     * Since this is a variable length instruction, it may shift the following
-     * instructions which then need to update their position.
-     *
-     * Called by InstructionList.setPositions when setting the position for every
-     * instruction. In the presence of variable length instructions `setPositions'
-     * performs multiple passes over the instruction list to calculate the
-     * correct (byte) positions and offsets by calling this function.
-     *
-     * @param offset additional offset caused by preceding (variable length) instructions
-     * @param max_offset the maximum offset that may be caused by these instructions
-     * @return additional offset caused by possible change of this instruction's length
-     */
-    protected int updatePosition( int offset, int max_offset ) {
-        position += offset; // Additional offset caused by preceding SWITCHs, GOTOs, etc.
-        short old_length = length;
-        /* Alignment on 4-byte-boundary, + 1, because of tag byte.
-         */
-        padding = (4 - ((position + 1) % 4)) % 4;
-        length = (short) (fixed_length + padding); // Update length
-        return length - old_length;
-    }
-
-
     /**
      * Dump instruction as byte code to stream out.
      * @param out Output stream
@@ -91,19 +64,6 @@ public abstract class Select extends BranchInstruction implements VariableLength
     }
 
 
-    /**
-     * Read needed data (e.g. index) from file.
-     */
-    protected void initFromFile( ByteSequence bytes, boolean wide ) throws IOException {
-        padding = (4 - (bytes.getIndex() % 4)) % 4; // Compute number of pad bytes
-        for (int i = 0; i < padding; i++) {
-            bytes.readByte();
-        }
-        // Default branch target common for both cases (TABLESWITCH, LOOKUPSWITCH)
-        index = bytes.readInt();
-    }
-
-
     /**
      * @return mnemonic for instruction
      */

==================================================
Type.java
deleted file mode 100644
index bf4d42620e..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/StoreInstruction.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Denotes an unparameterized instruction to store a value into a local variable,
- * e.g. ISTORE.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public abstract class StoreInstruction extends LocalVariableInstruction implements PopInstruction {
-
-    /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise.
-     * tag and length are defined in readInstruction and initFromFile, respectively.
-     */
-    StoreInstruction(short canon_tag, short c_tag) {
-        super(canon_tag, c_tag);
-    }
-
-
-    /**
-     * @param opcode Instruction opcode
-     * @param c_tag Instruction number for compact version, ASTORE_0, e.g.
-     * @param n local variable index (unsigned short)
-     */
-    protected StoreInstruction(short opcode, short c_tag, int n) {
-        super(opcode, c_tag, n);
-    }
-}

==================================================
UnconditionalBranch.java
index bc6b1d92ef..69d19d6ff2 100644
--- a/java/org/apache/tomcat/util/bcel/generic/Type.java
+++ b/java/org/apache/tomcat/util/bcel/generic/Type.java
@@ -17,7 +17,6 @@
 package org.apache.tomcat.util.bcel.generic;
 
 import org.apache.tomcat.util.bcel.Constants;
-import org.apache.tomcat.util.bcel.classfile.ClassFormatException;
 import org.apache.tomcat.util.bcel.classfile.Utility;
 
 /** 
@@ -31,20 +30,15 @@ public abstract class Type implements java.io.Serializable {
 
     protected byte type;
     protected String signature; // signature for the type
-    /** Predefined constants
-     */
-    public static final BasicType VOID = new BasicType(Constants.T_VOID);
-    public static final BasicType BOOLEAN = new BasicType(Constants.T_BOOLEAN);
-    public static final BasicType INT = new BasicType(Constants.T_INT);
-    public static final BasicType SHORT = new BasicType(Constants.T_SHORT);
-    public static final BasicType BYTE = new BasicType(Constants.T_BYTE);
-    public static final BasicType LONG = new BasicType(Constants.T_LONG);
-    public static final BasicType DOUBLE = new BasicType(Constants.T_DOUBLE);
-    public static final BasicType FLOAT = new BasicType(Constants.T_FLOAT);
-    public static final BasicType CHAR = new BasicType(Constants.T_CHAR);
-    public static final ObjectType OBJECT = new ObjectType("java.lang.Object");
-    public static final ObjectType CLASS = new ObjectType("java.lang.Class");
-    public static final ObjectType STRING = new ObjectType("java.lang.String");
+    
+    
+    
+    
+    
+    
+    
+    
+    
     
     
     
@@ -87,28 +81,10 @@ public abstract class Type implements java.io.Serializable {
     }
 
 
-    /**
-     * @return type as defined in Constants
-     */
-    public byte getType() {
-        return type;
-    }
+    
 
 
-    /**
-     * @return stack size of this type (2 for long and double, 0 for void, 1 otherwise)
-     */
-    public int getSize() {
-        switch (type) {
-            case Constants.T_DOUBLE:
-            case Constants.T_LONG:
-                return 2;
-            case Constants.T_VOID:
-                return 0;
-            default:
-                return 1;
-        }
-    }
+    
 
 
     /**
@@ -139,142 +115,4 @@ public abstract class Type implements java.io.Serializable {
         return buf.toString();
     }
 
-    private static ThreadLocal consumed_chars = new ThreadLocal() {
-
-        protected Object initialValue() {
-            return new Integer(0);
-        }
-    };//int consumed_chars=0; // Remember position in string, see getArgumentTypes
-
-
-    private static int unwrap( ThreadLocal tl ) {
-        return ((Integer) tl.get()).intValue();
-    }
-
-
-    private static void wrap( ThreadLocal tl, int value ) {
-        tl.set(new Integer(value));
-    }
-
-
-    /**
-     * Convert signature to a Type object.
-     * @param signature signature string such as Ljava/lang/String;
-     * @return type object
-     */
-    public static final Type getType( String signature ) throws StringIndexOutOfBoundsException {
-        byte type = Utility.typeOfSignature(signature);
-        if (type <= Constants.T_VOID) {
-            //corrected concurrent private static field acess
-            wrap(consumed_chars, 1);
-            return BasicType.getType(type);
-        } else if (type == Constants.T_ARRAY) {
-            int dim = 0;
-            do { // Count dimensions
-                dim++;
-            } while (signature.charAt(dim) == '[');
-            // Recurse, but just once, if the signature is ok
-            Type t = getType(signature.substring(dim));
-            //corrected concurrent private static field acess
-            //  consumed_chars += dim; // update counter - is replaced by
-            int _temp = unwrap(consumed_chars) + dim;
-            wrap(consumed_chars, _temp);
-            return new ArrayType(t, dim);
-        } else { // type == T_REFERENCE
-            int index = signature.indexOf(';'); // Look for closing `;'
-            if (index < 0) {
-                throw new ClassFormatException("Invalid signature: " + signature);
-            }
-            //corrected concurrent private static field acess
-            wrap(consumed_chars, index + 1); // "Lblabla;" `L' and `;' are removed
-            return new ObjectType(signature.substring(1, index).replace('/', '.'));
-        }
-    }
-
-
-    /**
-     * Convert return value of a method (signature) to a Type object.
-     *
-     * @param signature signature string such as (Ljava/lang/String;)V
-     * @return return type
-     */
-    public static Type getReturnType( String signature ) {
-        try {
-            // Read return type after `)'
-            int index = signature.lastIndexOf(')') + 1;
-            return getType(signature.substring(index));
-        } catch (StringIndexOutOfBoundsException e) { // Should never occur
-            throw new ClassFormatException("Invalid method signature: " + signature, e);
-        }
-    }
-
-
-    
-
-
-    
-
-
-    
-
-
-    
-    
-    private static int size(int coded) {
-    	return coded & 3;
-    }
-    
-    private static int consumed(int coded) {
-    	return coded >> 2;
-    }
-    
-    private static int encode(int size, int consumed) {
-    	return consumed << 2 | size;
-    }
-    
-    static int getArgumentTypesSize( String signature ) {
-        int res = 0;
-        int index;
-        try { // Read all declarations between for `(' and `)'
-            if (signature.charAt(0) != '(') {
-                throw new ClassFormatException("Invalid method signature: " + signature);
-            }
-            index = 1; // current string position
-            while (signature.charAt(index) != ')') {
-                int coded = getTypeSize(signature.substring(index));
-                res += size(coded);
-                index += consumed(coded);
-            }
-        } catch (StringIndexOutOfBoundsException e) { // Should never occur
-            throw new ClassFormatException("Invalid method signature: " + signature, e);
-        }
-        return res;
-    }
-    
-    static final int getTypeSize( String signature ) throws StringIndexOutOfBoundsException {
-        byte type = Utility.typeOfSignature(signature);
-        if (type <= Constants.T_VOID) {
-            return encode(BasicType.getType(type).getSize(), 1);
-        } else if (type == Constants.T_ARRAY) {
-            int dim = 0;
-            do { // Count dimensions
-                dim++;
-            } while (signature.charAt(dim) == '[');
-            // Recurse, but just once, if the signature is ok
-            int consumed = consumed(getTypeSize(signature.substring(dim)));
-            return encode(1, dim + consumed);
-        } else { // type == T_REFERENCE
-            int index = signature.indexOf(';'); // Look for closing `;'
-            if (index < 0) {
-                throw new ClassFormatException("Invalid signature: " + signature);
-            }
-            return encode(1, index + 1);
-        }
-    }
-
-
-	static int getReturnTypeSize(String signature) {
-		int index = signature.lastIndexOf(')') + 1;
-        return getTypeSize(signature.substring(index));
-	}
 }

==================================================
ClassPath.java
deleted file mode 100644
index 710f893c70..0000000000
--- a/java/org/apache/tomcat/util/bcel/generic/UnconditionalBranch.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.generic;
-
-/**
- * Denotes an instruction to perform an unconditional branch, i.e., GOTO, JSR.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
-
- * @see GOTO
- * @see JSR
- */
-public interface UnconditionalBranch {
-}

==================================================
ClassQueue.java
deleted file mode 100644
index 56eb79cc4f..0000000000
--- a/java/org/apache/tomcat/util/bcel/util/ClassPath.java
+++ /dev/null
@@ -1,340 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.util;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FilenameFilter;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Serializable;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.StringTokenizer;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
-
-/**
- * Responsible for loading (class) files from the CLASSPATH. Inspired by
- * sun.tools.ClassPath.
- *
- * @version $Id$
- * @author  <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- */
-public class ClassPath implements Serializable {
-
-    public static final ClassPath SYSTEM_CLASS_PATH = new ClassPath();
-    private PathEntry[] paths;
-    private String class_path;
-
-
-    /**
-     * Search for classes in given path.
-     */
-    public ClassPath(String class_path) {
-        this.class_path = class_path;
-        List vec = new ArrayList();
-        for (StringTokenizer tok = new StringTokenizer(class_path, System
-                .getProperty("path.separator")); tok.hasMoreTokens();) {
-            String path = tok.nextToken();
-            if (!path.equals("")) {
-                File file = new File(path);
-                try {
-                    if (file.exists()) {
-                        if (file.isDirectory()) {
-                            vec.add(new Dir(path));
-                        } else {
-                            vec.add(new Zip(new ZipFile(file)));
-                        }
-                    }
-                } catch (IOException e) {
-                    System.err.println("CLASSPATH component " + file + ": " + e);
-                }
-            }
-        }
-        paths = new PathEntry[vec.size()];
-        vec.toArray(paths);
-    }
-
-
-    /**
-     * Search for classes in CLASSPATH.
-     * @deprecated Use SYSTEM_CLASS_PATH constant
-     */
-    public ClassPath() {
-        this(getClassPath());
-    }
-
-
-    /** @return used class path string
-     */
-    public String toString() {
-        return class_path;
-    }
-
-
-    public int hashCode() {
-        return class_path.hashCode();
-    }
-
-
-    public boolean equals( Object o ) {
-        if (o instanceof ClassPath) {
-            return class_path.equals(((ClassPath) o).class_path);
-        }
-        return false;
-    }
-
-
-    private static final void getPathComponents( String path, List list ) {
-        if (path != null) {
-            StringTokenizer tok = new StringTokenizer(path, File.pathSeparator);
-            while (tok.hasMoreTokens()) {
-                String name = tok.nextToken();
-                File file = new File(name);
-                if (file.exists()) {
-                    list.add(name);
-                }
-            }
-        }
-    }
-
-
-    /** Checks for class path components in the following properties:
-     * "java.class.path", "sun.boot.class.path", "java.ext.dirs"
-     *
-     * @return class path as used by default by BCEL
-     */
-    public static final String getClassPath() {
-        String class_path = System.getProperty("java.class.path");
-        String boot_path = System.getProperty("sun.boot.class.path");
-        String ext_path = System.getProperty("java.ext.dirs");
-        List list = new ArrayList();
-        getPathComponents(class_path, list);
-        getPathComponents(boot_path, list);
-        List dirs = new ArrayList();
-        getPathComponents(ext_path, dirs);
-        for (Iterator e = dirs.iterator(); e.hasNext();) {
-            File ext_dir = new File((String) e.next());
-            String[] extensions = ext_dir.list(new FilenameFilter() {
-
-                public boolean accept( File dir, String name ) {
-                    name = name.toLowerCase(Locale.ENGLISH);
-                    return name.endsWith(".zip") || name.endsWith(".jar");
-                }
-            });
-            if (extensions != null) {
-                for (int i = 0; i < extensions.length; i++) {
-                    list.add(ext_dir.getPath() + File.separatorChar + extensions[i]);
-                }
-            }
-        }
-        StringBuffer buf = new StringBuffer();
-        for (Iterator e = list.iterator(); e.hasNext();) {
-            buf.append((String) e.next());
-            if (e.hasNext()) {
-                buf.append(File.pathSeparatorChar);
-            }
-        }
-        return buf.toString().intern();
-    }
-
-
-    /**
-     * @param name fully qualified class name, e.g. java.lang.String
-     * @return input stream for class
-     */
-    public InputStream getInputStream( String name ) throws IOException {
-        return getInputStream(name.replace('.', '/'), ".class");
-    }
-
-
-    /**
-     * Return stream for class or resource on CLASSPATH.
-     *
-     * @param name fully qualified file name, e.g. java/lang/String
-     * @param suffix file name ends with suff, e.g. .java
-     * @return input stream for file on class path
-     */
-    public InputStream getInputStream( String name, String suffix ) throws IOException {
-        InputStream is = null;
-        try {
-            is = getClass().getClassLoader().getResourceAsStream(name + suffix);
-        } catch (Exception e) {
-        }
-        if (is != null) {
-            return is;
-        }
-        return getClassFile(name, suffix).getInputStream();
-    }
-
-    
-    
-    
-
-    
-
-    /**
-     * @param name fully qualified file name, e.g. java/lang/String
-     * @param suffix file name ends with suff, e.g. .java
-     * @return class file for the java class
-     */
-    public ClassFile getClassFile( String name, String suffix ) throws IOException {
-        for (int i = 0; i < paths.length; i++) {
-            ClassFile cf;
-            if ((cf = paths[i].getClassFile(name, suffix)) != null) {
-                return cf;
-            }
-        }
-        throw new IOException("Couldn't find: " + name + suffix);
-    }
-
-
-    
-
-
-    
-
-
-    
-
-
-    
-
-
-    
-
-    private static abstract class PathEntry implements Serializable {
-
-        abstract ClassFile getClassFile( String name, String suffix ) throws IOException;
-        abstract URL getResource(String name);
-        abstract InputStream getResourceAsStream(String name);
-    }
-
-    /** Contains information about file/ZIP entry of the Java class.
-     */
-    public interface ClassFile {
-
-        /** @return input stream for class file.
-         */
-        public abstract InputStream getInputStream() throws IOException;
-
-
-        
-
-
-        
-
-
-        
-
-
-        
-    }
-
-    private static class Dir extends PathEntry {
-
-        private String dir;
-
-
-        Dir(String d) {
-            dir = d;
-        }
-
-        URL getResource(String name) {
-            // Resource specification uses '/' whatever the platform
-            final File file = new File(dir + File.separatorChar + name.replace('/', File.separatorChar));
-            try {
-                return file.exists() ? file.toURL() : null;
-            } catch (MalformedURLException e) {
-               return null;
-            }
-        }
-        
-        InputStream getResourceAsStream(String name) {
-            // Resource specification uses '/' whatever the platform
-            final File file = new File(dir + File.separatorChar + name.replace('/', File.separatorChar));
-            try {
-               return file.exists() ? new FileInputStream(file) : null;
-            } catch (IOException e) {
-               return null;
-            }
-        }
-
-        ClassFile getClassFile( String name, String suffix ) throws IOException {
-            final File file = new File(dir + File.separatorChar
-                    + name.replace('.', File.separatorChar) + suffix);
-            return file.exists() ? new ClassFile() {
-
-                public InputStream getInputStream() throws IOException {
-                    return new FileInputStream(file);
-                }
-            } : null;
-        }
-
-
-        public String toString() {
-            return dir;
-        }
-    }
-
-    private static class Zip extends PathEntry {
-
-        private ZipFile zip;
-
-
-        Zip(ZipFile z) {
-            zip = z;
-        }
-
-        URL getResource(String name) {
-            final ZipEntry entry = zip.getEntry(name);
-            try {
-                return (entry != null) ? new URL("jar:file:" + zip.getName() + "!/" + name) : null;
-            } catch (MalformedURLException e) {
-                return null;
-           }
-        }
-        
-        InputStream getResourceAsStream(String name) {
-            final ZipEntry entry = zip.getEntry(name);
-            try {
-                return (entry != null) ? zip.getInputStream(entry) : null;
-            } catch (IOException e) {
-                return null;
-            }
-        }
-        	
-        ClassFile getClassFile( String name, String suffix ) throws IOException {
-            final ZipEntry entry = zip.getEntry(name.replace('.', '/') + suffix);
-            
-            if (entry == null)
-            	return null;
-            
-            return new ClassFile() {
-
-                public InputStream getInputStream() throws IOException {
-                    return zip.getInputStream(entry);
-                }
-            };
-        }
-    }
-}

==================================================
Repository.java
deleted file mode 100644
index 0f5239efa2..0000000000
--- a/java/org/apache/tomcat/util/bcel/util/ClassQueue.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.util;
-
-import java.util.LinkedList;
-import org.apache.tomcat.util.bcel.classfile.JavaClass;
-
-/** 
- * Utility class implementing a (typesafe) queue of JavaClass
- * objects.
- *
- * @version $Id$
- * @author <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A> 
- */
-public class ClassQueue implements java.io.Serializable {
-
-    protected LinkedList vec = new LinkedList();
-
-
-    public void enqueue( JavaClass clazz ) {
-        vec.addLast(clazz);
-    }
-
-
-    public JavaClass dequeue() {
-        return (JavaClass) vec.removeFirst();
-    }
-
-
-    public boolean empty() {
-        return vec.isEmpty();
-    }
-
-
-    public String toString() {
-        return vec.toString();
-    }
-}

==================================================
SyntheticRepository.java
deleted file mode 100644
index 2e38ab58b9..0000000000
--- a/java/org/apache/tomcat/util/bcel/util/Repository.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright  2000-2009 The Apache Software Foundation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License"); 
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License. 
- *
- */
-package org.apache.tomcat.util.bcel.util;
-
-import org.apache.tomcat.util.bcel.classfile.JavaClass;
-
-/**
- * Abstract definition of a class repository. Instances may be used
- * to load classes from different sources and may be used in the
- * Repository.setRepository method.
- *
- * @see org.apache.tomcat.util.bcel.Repository
- * @version $Id$
- * @author <A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>
- * @author David Dixon-Peugh
- */
-public interface Repository extends java.io.Serializable {
-
-    /**
-     * Store the provided class under "clazz.getClassName()" 
-     */
-    public void storeClass( JavaClass clazz );
-
-
-    
-
-
-    /**
-     * Find the class with the name provided, if the class
-     * isn't there, return NULL.
-     */
-    public JavaClass findClass( String className );
-
-
-    /**
-     * Find the class with the name provided, if the class
-     * isn't there, make an attempt to load it.
-     */
-    public JavaClass loadClass( String className ) throws java.lang.ClassNotFoundException;
-
-
-    
-
-
-    
-
-
-    
-}

==================================================
