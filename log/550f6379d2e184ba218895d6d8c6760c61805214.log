550f6379d2e184ba218895d6d8c6760c61805214
==================================================
- Reduce the number of JARs.
==================================================
Remy Maucherat
==================================================
Thu Mar 30 00:55:22 2006 +0000
==================================================
JMXAccessorQueryTask.java
index 093c4826d5..d530c105f4 100644
--- a/build.xml
+++ b/build.xml
@@ -35,27 +35,17 @@
   <property name="compile.source" value="1.5"/>
   
   <!-- JAR artifacts -->
+  <property name="bootstrap.jar" value="${tomcat.build}/bin/bootstrap.jar"/>
+
   <property name="servlet-api.jar" value="${tomcat.build}/lib/servlet-api.jar"/>
   <property name="jsp-api.jar" value="${tomcat.build}/lib/jsp-api.jar"/>
   <property name="el-api.jar" value="${tomcat.build}/lib/el-api.jar"/>
   <property name="catalina.jar" value="${tomcat.build}/lib/catalina.jar"/>
   <property name="catalina-ant.jar" value="${tomcat.build}/lib/catalina-ant.jar"/>
   <property name="catalina-ant-jmx.jar" value="${tomcat.build}/lib/catalina-ant-jmx.jar"/>
-  <property name="naming-factory.jar" value="${tomcat.build}/lib/naming-factory.jar"/>
-  <property name="naming-resources.jar" value="${tomcat.build}/lib/naming-resources.jar"/>
-  <property name="servlets-cgi.jar" value="${tomcat.build}/lib/servlets-cgi.renametojar"/>
-  <property name="servlets-default.jar" value="${tomcat.build}/lib/servlets-default.jar"/>
-  <property name="servlets-invoker.jar" value="${tomcat.build}/lib/servlets-invoker.jar"/>
-  <property name="servlets-ssi.jar" value="${tomcat.build}/lib/servlets-ssi.renametojar"/>
-  <property name="servlets-webdav.jar" value="${tomcat.build}/lib/servlets-webdav.jar"/>
-  <property name="tomcat-util.jar" value="${tomcat.build}/lib/tomcat-util.jar"/>
   <property name="tomcat-coyote.jar" value="${tomcat.build}/lib/tomcat-coyote.jar"/>
-  <property name="tomcat-apr.jar" value="${tomcat.build}/lib/tomcat-apr.jar"/>
-  <property name="tomcat-ajp.jar" value="${tomcat.build}/lib/tomcat-ajp.jar"/>
-  <property name="tomcat-http.jar" value="${tomcat.build}/lib/tomcat-http.jar"/>
 
-  <property name="jasper-compiler.jar" value="${tomcat.build}/lib/jasper-compiler.jar"/>
-  <property name="jasper-runtime.jar" value="${tomcat.build}/lib/jasper-runtime.jar"/>
+  <property name="jasper.jar" value="${tomcat.build}/lib/jasper.jar"/>
   <property name="jasper-el.jar" value="${tomcat.build}/lib/jasper-el.jar"/>
   
   <!-- Classpath -->
@@ -63,7 +53,6 @@
     <pathelement location="${ant.jar}"/>
     <pathelement location="${jdt.jar}"/>
     <pathelement location="${commons-logging.jar}"/>
-    <pathelement location="${commons-modeler.jar}"/>
   </path>
 
   <!-- Just build Tomcat -->
@@ -77,6 +66,7 @@
     <mkdir dir="${tomcat.build}/bin"/>
     <mkdir dir="${tomcat.build}/conf"/>
     <mkdir dir="${tomcat.build}/lib"/>
+    <mkdir dir="${tomcat.build}/webapps"/>
 
   </target>
 
@@ -95,10 +85,12 @@
       <exclude name="org/apache/naming/factory/SendMailFactory.java"/>
     </javac>
     <!-- Copy static resource files -->
-    <copy todir="${tomcat.classes}">
+    <filter token="VERSION" value="${version}"/>
+    <copy todir="${tomcat.classes}" filtering="true">
       <fileset dir="java">
         <include name="**/*.properties"/>
         <include name="**/*.dtd"/>
+        <include name="**/*.xsd"/>
       </fileset>
     </copy>
 
@@ -109,7 +101,7 @@
   <target name="package" >  
 
     <!-- Servlet 2.5 Implementation JAR File -->
-    <jar  jarfile="${servlet-api.jar}" index="true">
+    <jar  jarfile="${servlet-api.jar}">
       <fileset dir="${tomcat.classes}">
         <include name="javax/servlet/*" />
         <include name="javax/servlet/http/*" />
@@ -121,7 +113,7 @@
     </jar>
 
     <!-- JSP 2.1 Implementation JAR File -->
-    <jar  jarfile="${jsp-api.jar}" index="true">
+    <jar  jarfile="${jsp-api.jar}">
       <fileset dir="${tomcat.classes}">
         <include name="javax/servlet/jsp/**" />
         <!-- Javadoc and i18n exclusions -->
@@ -131,7 +123,7 @@
     </jar>
 
     <!-- JSP 2.1 EL Implementation JAR File -->
-    <jar  jarfile="${el-api.jar}" index="true">
+    <jar  jarfile="${el-api.jar}">
       <fileset dir="${tomcat.classes}">
         <include name="javax/el/**" />
         <!-- Javadoc and i18n exclusions -->
@@ -140,10 +132,32 @@
       </fileset>
     </jar>
 
+    <!-- Bootstrap JAR File -->
+    <jar jarfile="${bootstrap.jar}" 
+        manifest="res/bootstrap.jar.manifest">
+      <fileset dir="${tomcat.classes}">
+        <include name="org/apache/catalina/startup/Bootstrap.class" />
+        <include name="org/apache/catalina/startup/catalina.properties" />
+        <include name="org/apache/catalina/startup/CatalinaProperties.class" />
+        <include name="org/apache/catalina/startup/ClassLoaderFactory.class" />
+        <include name="org/apache/catalina/startup/Tool.class" />
+        <include name="org/apache/catalina/loader/StandardClassLoader*.class" />
+        <include name="org/apache/catalina/loader/Extension.class" />
+        <include name="org/apache/catalina/loader/Reloader.class" />
+        <include name="org/apache/catalina/security/SecurityClassLoad.class" />
+        <include name="org/apache/naming/JndiPermission.class" />
+        <include name="org/apache/tomcat/util/compat/*" />
+      	<!-- Javadoc and i18n exclusions -->
+        <exclude name="**/package.html" />
+        <exclude name="**/LocalStrings_*" />
+      </fileset>
+    </jar>
+
     <!-- Catalina Main JAR File -->
-    <jar jarfile="${catalina.jar}" index="true" manifest="res/bootstrap.jar.manifest">
+    <jar jarfile="${catalina.jar}">
       <fileset dir="${tomcat.classes}">
         <include name="org/apache/catalina/**" />
+        <include name="org/apache/naming/**" />
         <!-- Javadoc and i18n exclusions -->
         <exclude name="**/package.html" />
         <exclude name="**/LocalStrings_*" />
@@ -151,14 +165,12 @@
         <exclude name="org/apache/catalina/ant/**" />
         <exclude name="org/apache/catalina/cluster/**" />
         <exclude name="org/apache/catalina/launcher/**" />
-        <exclude name="org/apache/catalina/servlets/**" />
         <exclude name="org/apache/catalina/storeconfig/**" />
-        <exclude name="org/apache/catalina/ssi/**" />
       </fileset>
     </jar>
 
     <!-- Catalina Ant Tasks JAR File -->
-    <jar jarfile="${catalina-ant.jar}" index="true">
+    <jar jarfile="${catalina-ant.jar}">
       <fileset dir="${tomcat.classes}">
       	<include name="org/apache/catalina/ant/*" />
         <include name="org/apache/catalina/util/Base64.class" />
@@ -169,7 +181,7 @@
     </jar>
 
   	<!-- Catalina JMX Accessor Ant Tasks JAR File -->
-    <jar jarfile="${catalina-ant-jmx.jar}" index="true">
+    <jar jarfile="${catalina-ant-jmx.jar}">
       <fileset dir="${tomcat.classes}">
       	<include name="org/apache/catalina/ant/jmx/*" />
       	<!-- Javadoc and i18n exclusions -->
@@ -178,179 +190,31 @@
       </fileset>
     </jar>
 
-  	<!-- Naming - Factory JAR File -->
-    <jar jarfile="${naming-factory.jar}" index="true">
-      <fileset dir="${tomcat.classes}">
-        <include name="org/apache/naming/**" />
-        <exclude name="org/apache/naming/resources/**" />
-        <exclude name="org/apache/naming/JndiPermission.class" />
-      	<exclude name="org/apache/naming/NameParserImpl.class" />
-      	<exclude name="org/apache/naming/NamingContextBindingsEnumeration.class" />
-      	<exclude name="org/apache/naming/NamingContextEnumeration.class" />
-      	<exclude name="org/apache/naming/NamingEntry.class" />
-      	<exclude name="org/apache/naming/StringManager.class" />
-        <!-- Javadoc and i18n exclusions -->
-        <exclude name="**/package.html" />
-        <exclude name="**/LocalStrings_*" />
-      </fileset>
-    </jar>
-
-    <!-- Naming - Resources JAR File -->
-    <jar jarfile="${naming-resources.jar}" index="true">
-      <fileset dir="${tomcat.classes}">
-        <include name="org/apache/naming/JndiPermission.class" />
-      	<include name="org/apache/naming/NameParserImpl.class" />
-      	<include name="org/apache/naming/NamingContextBindingsEnumeration.class" />
-      	<include name="org/apache/naming/NamingContextEnumeration.class" />
-      	<include name="org/apache/naming/NamingEntry.class" />
-      	<include name="org/apache/naming/StringManager.class" />
-        <include name="org/apache/naming/resources/**" />
-        <!-- Javadoc and i18n exclusions -->
-        <exclude name="**/package.html" />
-        <exclude name="**/LocalStrings_*" />
-      </fileset>
-    </jar>
-
-    <!-- Servlets - CGI Servlet -->
-    <jar jarfile="${servlets-cgi.jar}" index="true">
-      <fileset dir="${tomcat.classes}">
-        <include name="org/apache/catalina/servlets/CGI*" />
-        <!-- Javadoc and i18n exclusions -->
-        <exclude name="**/package.html" />
-        <exclude name="**/LocalStrings_*" />
-      </fileset>
-    </jar>
-
-    <!-- Servlets - Default File-Serving Servlet -->
-    <jar jarfile="${servlets-default.jar}" index="true">
-      <fileset dir="${tomcat.classes}">
-        <include name="org/apache/catalina/servlets/Default*" />
-        <include name="org/apache/catalina/servlets/Constants.class" />
-        <include name="org/apache/catalina/servlets/LocalStrings.properties" />
-        <!-- Javadoc and i18n exclusions -->
-        <exclude name="**/package.html" />
-        <exclude name="**/LocalStrings_*" />
-      </fileset>
-    </jar>
-
-    <!-- Servlets - Invoker Servlet -->
-    <jar jarfile="${servlets-invoker.jar}" index="true">
-      <fileset dir="${tomcat.classes}">
-        <include name="org/apache/catalina/servlets/Invoker*" />
-        <!-- Javadoc and i18n exclusions -->
-        <exclude name="**/package.html" />
-        <exclude name="**/LocalStrings_*" />
-      </fileset>
-    </jar>
-
-    <!-- Servlets - SSI Servlet -->
-    <jar jarfile="${servlets-ssi.jar}" index="true">
-      <fileset dir="${tomcat.classes}">
-        <include name="org/apache/catalina/ssi/**" />
-        <!-- Javadoc and i18n exclusions -->
-        <exclude name="**/package.html" />
-        <exclude name="**/LocalStrings_*" />
-      </fileset>
-    </jar>
-
-    <!-- Servlets - Webdav Servlet -->
-    <jar jarfile="${servlets-webdav.jar}" index="true">
-      <fileset dir="${tomcat.classes}">
-        <include name="org/apache/catalina/servlets/Webdav*" />
-        <!-- Javadoc and i18n exclusions -->
-        <exclude name="**/package.html" />
-        <exclude name="**/LocalStrings_*" />
-      </fileset>
-    </jar>
-
     <!-- Protocol handlers - Coyote -->
-    <jar jarfile="${tomcat-coyote.jar}" index="true">
-      <fileset dir="${tomcat.classes}">
-        <include name="org/apache/coyote/*" />
-        <include name="org/apache/coyote/memory/*" />
-        <!-- Javadoc and i18n exclusions -->
-        <exclude name="**/package.html" />
-        <exclude name="**/LocalStrings_*" />
-      </fileset>
-    </jar>
-
-    <!-- Protocol handlers - APR -->
-    <jar jarfile="${tomcat-apr.jar}" index="true">
+    <jar jarfile="${tomcat-coyote.jar}">
       <fileset dir="${tomcat.classes}">
+        <include name="org/apache/coyote/**" />
         <include name="org/apache/tomcat/jni/**" />
-        <!-- Javadoc and i18n exclusions -->
-        <exclude name="**/package.html" />
-        <exclude name="**/LocalStrings_*" />
-      </fileset>
-    </jar>
-
-    <!-- Protocol handlers - HTTP -->
-    <jar jarfile="${tomcat-http.jar}" index="true">
-      <fileset dir="${tomcat.classes}">
-        <include name="org/apache/coyote/http11/**" />
-        <!-- Javadoc and i18n exclusions -->
-        <exclude name="**/package.html" />
-        <exclude name="**/LocalStrings_*" />
-      </fileset>
-    </jar>
-
-    <!-- Protocol handlers - AJP -->
-    <jar jarfile="${tomcat-ajp.jar}" index="true">
-      <fileset dir="${tomcat.classes}">
-        <include name="org/apache/coyote/ajp/**" />
         <include name="org/apache/jk/**" />
-        <exclude name="org/apache/jk/ant/**" />
+        <include name="org/apache/tomcat/util/**" />
         <!-- Javadoc and i18n exclusions -->
         <exclude name="**/package.html" />
         <exclude name="**/LocalStrings_*" />
       </fileset>
     </jar>
 
-    <!-- Util JAR File -->
-    <jar jarfile="${tomcat-util.jar}" index="true">
+    <!-- Jasper Implementation JAR File -->
+    <jar  jarfile="${jasper.jar}">
       <fileset dir="${tomcat.classes}">
-        <include name="org/apache/tomcat/util/**" />
+        <include name="org/apache/jasper/**" />
         <!-- Javadoc and i18n exclusions -->
         <exclude name="**/package.html" />
         <exclude name="**/LocalStrings_*" />
       </fileset>
     </jar>
 
-    <!-- Jasper Compiler JAR File -->
-    <jar  jarfile="${jasper-compiler.jar}" index="true">
-       <fileset dir="${tomcat.classes}">
-         <include name="org/apache/jasper/compiler/**" />
-         <include name="org/apache/jasper/xmlparser/**" />
-         <include name="org/apache/jasper/servlet/**" />
-         <include name="org/apache/jasper/tagplugins/**" />
-         <exclude name="org/apache/jasper/Constants.class" />
-         <exclude name="org/apache/jasper/JasperException.class" />
-         <include name="org/apache/jasper/*.class" />
-         <!-- Javadoc and i18n exclusions -->
-         <exclude name="**/package.html" />
-         <exclude name="**/LocalStrings_*" />
-       </fileset>
-     </jar>
-
-     <!-- Jasper Runtime JAR File -->
-     <jar  jarfile="${jasper-runtime.jar}" index="true">
-       <fileset dir="${tomcat.classes}">
-         <include name="org/apache/jasper/Constants.class" />
-         <include name="org/apache/jasper/JasperException.class" />
-         <include name="org/apache/jasper/compiler/Localizer.class" />
-         <include name="org/apache/jasper/el/**" />
-         <include name="org/apache/jasper/resources/**" />
-         <include name="org/apache/jasper/runtime/**" />
-         <include name="org/apache/jasper/security/**" />
-         <include name="org/apache/jasper/util/**" />
-         <!-- Javadoc and i18n exclusions -->
-         <exclude name="**/package.html" />
-         <exclude name="**/LocalStrings_*" />
-       </fileset>
-     </jar>
-
      <!-- Jasper EL Implementation JAR File -->
-     <jar  jarfile="${jasper-el.jar}" index="true">
+     <jar  jarfile="${jasper-el.jar}">
        <fileset dir="${tomcat.classes}">
          <include name="org/apache/el/**" />
          <!-- Javadoc and i18n exclusions -->
@@ -363,7 +227,7 @@
 
   <target name="deploy" depends="build-only">
 
-    <copy file="${commons-logging-api.jar}" todir="${tomcat.build}/lib" />
+    <copy file="${commons-logging-api.jar}" todir="${tomcat.build}/bin" />
 
     <!-- Copy static resource files -->
     <copy todir="${tomcat.build}/conf">
@@ -373,6 +237,13 @@
       </fileset>
     </copy>
 
+    <!-- Temp: Copy webapps -->
+    <copy todir="${tomcat.build}/webapps">
+      <fileset dir="webapps">
+        <include name="ROOT/**"/>
+      </fileset>
+    </copy>
+
   </target>
 
   <target name="clean">

==================================================
Connector.java
index 8aa749b4f5..31bbbfa407 100644
--- a/java/org/apache/catalina/ant/jmx/JMXAccessorQueryTask.java
+++ b/java/org/apache/catalina/ant/jmx/JMXAccessorQueryTask.java
@@ -174,7 +174,7 @@ public class JMXAccessorQueryTask extends JMXAccessorTask {
             try {
                 MBeanInfo minfo = jmxServerConnection.getMBeanInfo(oname);
                 String code = minfo.getClassName();
-                if ("org.apache.commons.modeler.BaseModelMBean".equals(code)) {
+                if ("org.apache.tomcat.util.modeler.BaseModelMBean".equals(code)) {
                     code = (String) jmxServerConnection.getAttribute(oname,
                             "modelerType");
                 }

==================================================
MapperListener.java
index 234771cf67..2e32c82636 100644
--- a/java/org/apache/catalina/connector/Connector.java
+++ b/java/org/apache/catalina/connector/Connector.java
@@ -36,11 +36,11 @@ import org.apache.catalina.util.LifecycleSupport;
 import org.apache.catalina.util.StringManager;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.commons.modeler.Registry;
 import org.apache.coyote.Adapter;
 import org.apache.coyote.ProtocolHandler;
 import org.apache.tomcat.util.IntrospectionUtils;
 import org.apache.tomcat.util.http.mapper.Mapper;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 /**

==================================================
ContainerBase.java
index 80ebe95dd8..8e06b644cd 100644
--- a/java/org/apache/catalina/connector/MapperListener.java
+++ b/java/org/apache/catalina/connector/MapperListener.java
@@ -28,9 +28,9 @@ import javax.management.ObjectName;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
-import org.apache.commons.modeler.Registry;
 
 import org.apache.tomcat.util.http.mapper.Mapper;
+import org.apache.tomcat.util.modeler.Registry;
 
 import org.apache.tomcat.util.res.StringManager;
 

==================================================
NamingContextListener.java
index bf604d2798..bf34aec54a 100644
--- a/java/org/apache/catalina/core/ContainerBase.java
+++ b/java/org/apache/catalina/core/ContainerBase.java
@@ -54,8 +54,8 @@ import org.apache.catalina.util.LifecycleSupport;
 import org.apache.catalina.util.StringManager;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.commons.modeler.Registry;
 import org.apache.naming.resources.ProxyDirContext;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 /**

==================================================
StandardContext.java
index 996265886f..c5a9d35c73 100644
--- a/java/org/apache/catalina/core/NamingContextListener.java
+++ b/java/org/apache/catalina/core/NamingContextListener.java
@@ -54,7 +54,6 @@ import org.apache.catalina.deploy.NamingResources;
 import org.apache.catalina.util.StringManager;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.commons.modeler.Registry;
 import org.apache.naming.ContextAccessController;
 import org.apache.naming.ContextBindings;
 import org.apache.naming.EjbRef;
@@ -63,6 +62,7 @@ import org.apache.naming.ResourceEnvRef;
 import org.apache.naming.ResourceLinkRef;
 import org.apache.naming.ResourceRef;
 import org.apache.naming.TransactionRef;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 /**

==================================================
StandardEngine.java
index e2d8c1be55..b4875b13ce 100644
--- a/java/org/apache/catalina/core/StandardContext.java
+++ b/java/org/apache/catalina/core/StandardContext.java
@@ -90,7 +90,6 @@ import org.apache.catalina.util.RequestUtil;
 import org.apache.catalina.util.URLEncoder;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.commons.modeler.Registry;
 import org.apache.naming.ContextBindings;
 import org.apache.naming.resources.BaseDirContext;
 import org.apache.naming.resources.DirContextURLStreamHandler;
@@ -98,6 +97,7 @@ import org.apache.naming.resources.FileDirContext;
 import org.apache.naming.resources.ProxyDirContext;
 import org.apache.naming.resources.WARDirContext;
 import org.apache.tomcat.util.compat.JdkCompat;
+import org.apache.tomcat.util.modeler.Registry;
 
 /**
  * Standard implementation of the <b>Context</b> interface.  Each

==================================================
StandardHost.java
index 976597eb05..98cace689e 100644
--- a/java/org/apache/catalina/core/StandardEngine.java
+++ b/java/org/apache/catalina/core/StandardEngine.java
@@ -35,8 +35,8 @@ import org.apache.catalina.realm.JAASRealm;
 import org.apache.catalina.util.ServerInfo;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.commons.modeler.Registry;
-import org.apache.commons.modeler.modules.MbeansSource;
+import org.apache.tomcat.util.modeler.Registry;
+import org.apache.tomcat.util.modeler.modules.MbeansSource;
 
 /**
  * Standard implementation of the <b>Engine</b> interface.  Each

==================================================
StandardPipeline.java
index 2b1505faf4..5b9d8e3593 100644
--- a/java/org/apache/catalina/core/StandardHost.java
+++ b/java/org/apache/catalina/core/StandardHost.java
@@ -28,7 +28,7 @@ import org.apache.catalina.LifecycleException;
 import org.apache.catalina.Valve;
 import org.apache.catalina.startup.HostConfig;
 import org.apache.catalina.valves.ValveBase;
-import org.apache.commons.modeler.Registry;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 /**

==================================================
StandardServer.java
index 819b21fbab..d0499f02c1 100644
--- a/java/org/apache/catalina/core/StandardPipeline.java
+++ b/java/org/apache/catalina/core/StandardPipeline.java
@@ -34,7 +34,7 @@ import org.apache.catalina.util.StringManager;
 import org.apache.catalina.valves.ValveBase;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.commons.modeler.Registry;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 /**

==================================================
StandardService.java
index fb6594de3f..908b3791f1 100644
--- a/java/org/apache/catalina/core/StandardServer.java
+++ b/java/org/apache/catalina/core/StandardServer.java
@@ -45,8 +45,8 @@ import org.apache.catalina.util.StringManager;
 import org.apache.catalina.util.ServerInfo;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.commons.modeler.Registry;
 import org.apache.tomcat.util.buf.StringCache;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 

==================================================
StandardWrapper.java
index 4ffce27ff5..707c823ccd 100644
--- a/java/org/apache/catalina/core/StandardService.java
+++ b/java/org/apache/catalina/core/StandardService.java
@@ -36,7 +36,7 @@ import org.apache.catalina.util.LifecycleSupport;
 import org.apache.catalina.util.StringManager;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.commons.modeler.Registry;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 /**

==================================================
WebappLoader.java
index 4bbea6af32..96b8734c57 100644
--- a/java/org/apache/catalina/core/StandardWrapper.java
+++ b/java/org/apache/catalina/core/StandardWrapper.java
@@ -57,7 +57,7 @@ import org.apache.catalina.util.Enumerator;
 import org.apache.catalina.util.InstanceSupport;
 import org.apache.tomcat.util.IntrospectionUtils;
 import org.apache.tomcat.util.log.SystemLogHandler;
-import org.apache.commons.modeler.Registry;
+import org.apache.tomcat.util.modeler.Registry;
 
 /**
  * Standard implementation of the <b>Wrapper</b> interface that represents

==================================================
ClassNameMBean.java
index 81d4cee27d..7d9bf3b4bd 100644
--- a/java/org/apache/catalina/loader/WebappLoader.java
+++ b/java/org/apache/catalina/loader/WebappLoader.java
@@ -57,10 +57,10 @@ import org.apache.catalina.Loader;
 import org.apache.catalina.core.StandardContext;
 import org.apache.catalina.util.LifecycleSupport;
 import org.apache.catalina.util.StringManager;
-import org.apache.commons.modeler.Registry;
 import org.apache.naming.resources.DirContextURLStreamHandler;
 import org.apache.naming.resources.DirContextURLStreamHandlerFactory;
 import org.apache.naming.resources.Resource;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 /**

==================================================
ContextEnvironmentMBean.java
index dc93fe115f..9e132d6d97 100644
--- a/java/org/apache/catalina/mbeans/ClassNameMBean.java
+++ b/java/org/apache/catalina/mbeans/ClassNameMBean.java
@@ -19,7 +19,8 @@ package org.apache.catalina.mbeans;
 
 import javax.management.MBeanException;
 import javax.management.RuntimeOperationsException;
-import org.apache.commons.modeler.BaseModelMBean;
+
+import org.apache.tomcat.util.modeler.BaseModelMBean;
 
 
 /**

==================================================
ContextResourceLinkMBean.java
index f498102c40..6b59ddf5a2 100644
--- a/java/org/apache/catalina/mbeans/ContextEnvironmentMBean.java
+++ b/java/org/apache/catalina/mbeans/ContextEnvironmentMBean.java
@@ -27,7 +27,7 @@ import javax.management.modelmbean.InvalidTargetObjectTypeException;
 
 import org.apache.catalina.deploy.ContextEnvironment;
 import org.apache.catalina.deploy.NamingResources;
-import org.apache.commons.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
 
 
 /**

==================================================
ContextResourceMBean.java
index a1a3b594d5..322fc80ed2 100644
--- a/java/org/apache/catalina/mbeans/ContextResourceLinkMBean.java
+++ b/java/org/apache/catalina/mbeans/ContextResourceLinkMBean.java
@@ -27,7 +27,7 @@ import javax.management.modelmbean.InvalidTargetObjectTypeException;
 
 import org.apache.catalina.deploy.ContextResourceLink;
 import org.apache.catalina.deploy.NamingResources;
-import org.apache.commons.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
 
 
 /**

==================================================
DefaultContextMBean.java
index e86bd6dc7e..ed15b9c512 100644
--- a/java/org/apache/catalina/mbeans/ContextResourceMBean.java
+++ b/java/org/apache/catalina/mbeans/ContextResourceMBean.java
@@ -27,7 +27,7 @@ import javax.management.modelmbean.InvalidTargetObjectTypeException;
 
 import org.apache.catalina.deploy.ContextResource;
 import org.apache.catalina.deploy.NamingResources;
-import org.apache.commons.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
 
 
 /**

==================================================
GlobalResourcesLifecycleListener.java
index 7460a2b340..767c526649 100644
--- a/java/org/apache/catalina/mbeans/DefaultContextMBean.java
+++ b/java/org/apache/catalina/mbeans/DefaultContextMBean.java
@@ -28,10 +28,10 @@ import org.apache.catalina.deploy.ContextEnvironment;
 import org.apache.catalina.deploy.ContextResource;
 import org.apache.catalina.deploy.ContextResourceLink;
 import org.apache.catalina.deploy.NamingResources;
-import org.apache.commons.modeler.BaseModelMBean;
-import org.apache.commons.modeler.ManagedBean;
-import org.apache.commons.modeler.Registry;
 import org.apache.tomcat.util.compat.JdkCompat;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.Registry;
 
 /**
  * <p>A <strong>ModelMBean</strong> implementation for the

==================================================
GroupMBean.java
index ab40612d33..07476652de 100644
--- a/java/org/apache/catalina/mbeans/GlobalResourcesLifecycleListener.java
+++ b/java/org/apache/catalina/mbeans/GlobalResourcesLifecycleListener.java
@@ -31,9 +31,9 @@ import org.apache.catalina.LifecycleListener;
 import org.apache.catalina.Role;
 import org.apache.catalina.User;
 import org.apache.catalina.UserDatabase;
-import org.apache.commons.modeler.Registry;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 /**

==================================================
MBeanFactory.java
index 63f9298799..15b28efeec 100644
--- a/java/org/apache/catalina/mbeans/GroupMBean.java
+++ b/java/org/apache/catalina/mbeans/GroupMBean.java
@@ -29,10 +29,10 @@ import javax.management.RuntimeOperationsException;
 import org.apache.catalina.Group;
 import org.apache.catalina.Role;
 import org.apache.catalina.User;
-import org.apache.commons.modeler.BaseModelMBean;
-import org.apache.commons.modeler.ManagedBean;
-import org.apache.commons.modeler.Registry;
 import org.apache.tomcat.util.compat.JdkCompat;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.Registry;
 
 /**
  * <p>A <strong>ModelMBean</strong> implementation for the

==================================================
MBeanUtils.java
index 2664d857f3..5c6592b95b 100644
--- a/java/org/apache/catalina/mbeans/MBeanFactory.java
+++ b/java/org/apache/catalina/mbeans/MBeanFactory.java
@@ -52,8 +52,8 @@ import org.apache.catalina.valves.RemoteAddrValve;
 import org.apache.catalina.valves.RemoteHostValve;
 import org.apache.catalina.valves.RequestDumperValve;
 import org.apache.catalina.valves.ValveBase;
-import org.apache.commons.modeler.BaseModelMBean;
-import org.apache.commons.modeler.Registry;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 /**

==================================================
MemoryUserDatabaseMBean.java
index a7d6a95dd6..3f142f0036 100644
--- a/java/org/apache/catalina/mbeans/MBeanUtils.java
+++ b/java/org/apache/catalina/mbeans/MBeanUtils.java
@@ -48,9 +48,9 @@ import org.apache.catalina.deploy.NamingResources;
 import org.apache.catalina.valves.ValveBase;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.commons.modeler.ManagedBean;
-import org.apache.commons.modeler.Registry;
 import org.apache.tomcat.util.IntrospectionUtils;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 /**

==================================================
NamingResourcesMBean.java
index 38cdcbb460..ce2ab05011 100644
--- a/java/org/apache/catalina/mbeans/MemoryUserDatabaseMBean.java
+++ b/java/org/apache/catalina/mbeans/MemoryUserDatabaseMBean.java
@@ -28,10 +28,10 @@ import org.apache.catalina.Group;
 import org.apache.catalina.Role;
 import org.apache.catalina.User;
 import org.apache.catalina.UserDatabase;
-import org.apache.commons.modeler.BaseModelMBean;
-import org.apache.commons.modeler.ManagedBean;
-import org.apache.commons.modeler.Registry;
 import org.apache.tomcat.util.compat.JdkCompat;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.Registry;
 
 /**
  * <p>A <strong>ModelMBean</strong> implementation for the

==================================================
RoleMBean.java
index e8cb7bffb8..2020509669 100644
--- a/java/org/apache/catalina/mbeans/NamingResourcesMBean.java
+++ b/java/org/apache/catalina/mbeans/NamingResourcesMBean.java
@@ -27,10 +27,10 @@ import org.apache.catalina.deploy.ContextEnvironment;
 import org.apache.catalina.deploy.ContextResource;
 import org.apache.catalina.deploy.ContextResourceLink;
 import org.apache.catalina.deploy.NamingResources;
-import org.apache.commons.modeler.BaseModelMBean;
-import org.apache.commons.modeler.ManagedBean;
-import org.apache.commons.modeler.Registry;
 import org.apache.tomcat.util.compat.JdkCompat;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.Registry;
 
 /**
  * <p>A <strong>ModelMBean</strong> implementation for the

==================================================
StandardContextMBean.java
index a0aa3576b8..541c57af93 100644
--- a/java/org/apache/catalina/mbeans/RoleMBean.java
+++ b/java/org/apache/catalina/mbeans/RoleMBean.java
@@ -21,9 +21,9 @@ import javax.management.MBeanException;
 import javax.management.MBeanServer;
 import javax.management.RuntimeOperationsException;
 
-import org.apache.commons.modeler.BaseModelMBean;
-import org.apache.commons.modeler.ManagedBean;
-import org.apache.commons.modeler.Registry;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 /**

==================================================
StandardEngineMBean.java
index 9000af6c48..a4c414709f 100644
--- a/java/org/apache/catalina/mbeans/StandardContextMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardContextMBean.java
@@ -28,10 +28,10 @@ import org.apache.catalina.deploy.ContextEnvironment;
 import org.apache.catalina.deploy.ContextResource;
 import org.apache.catalina.deploy.ContextResourceLink;
 import org.apache.catalina.deploy.NamingResources;
-import org.apache.commons.modeler.BaseModelMBean;
-import org.apache.commons.modeler.ManagedBean;
-import org.apache.commons.modeler.Registry;
 import org.apache.tomcat.util.compat.JdkCompat;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.Registry;
 
 /**
  * <p>A <strong>ModelMBean</strong> implementation for the

==================================================
StandardHostMBean.java
index 23e677cebc..6e4e6a87e7 100644
--- a/java/org/apache/catalina/mbeans/StandardEngineMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardEngineMBean.java
@@ -21,7 +21,7 @@ import javax.management.MBeanException;
 import javax.management.MBeanServer;
 import javax.management.RuntimeOperationsException;
 
-import org.apache.commons.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
 
 
 /**

==================================================
StandardServerMBean.java
index 8a73359a83..4555710e54 100644
--- a/java/org/apache/catalina/mbeans/StandardHostMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardHostMBean.java
@@ -23,9 +23,9 @@ import javax.management.RuntimeOperationsException;
 
 import org.apache.catalina.Valve;
 import org.apache.catalina.core.StandardHost;
-import org.apache.commons.modeler.BaseModelMBean;
-import org.apache.commons.modeler.ManagedBean;
-import org.apache.commons.modeler.Registry;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 /**

==================================================
StandardServiceMBean.java
index 2a22ce1c86..94b8547bc1 100644
--- a/java/org/apache/catalina/mbeans/StandardServerMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardServerMBean.java
@@ -24,7 +24,7 @@ import javax.management.RuntimeOperationsException;
 import org.apache.catalina.Server;
 import org.apache.catalina.ServerFactory;
 import org.apache.catalina.core.StandardServer;
-import org.apache.commons.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
 
 
 /**

==================================================
UserMBean.java
index 83f506976c..503996d9d7 100644
--- a/java/org/apache/catalina/mbeans/StandardServiceMBean.java
+++ b/java/org/apache/catalina/mbeans/StandardServiceMBean.java
@@ -21,7 +21,7 @@ import javax.management.MBeanException;
 import javax.management.MBeanServer;
 import javax.management.RuntimeOperationsException;
 
-import org.apache.commons.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
 
 
 /**

==================================================
RealmBase.java
index 07a97a5d3d..ee315f74a6 100644
--- a/java/org/apache/catalina/mbeans/UserMBean.java
+++ b/java/org/apache/catalina/mbeans/UserMBean.java
@@ -29,10 +29,10 @@ import javax.management.RuntimeOperationsException;
 import org.apache.catalina.Group;
 import org.apache.catalina.Role;
 import org.apache.catalina.User;
-import org.apache.commons.modeler.BaseModelMBean;
-import org.apache.commons.modeler.ManagedBean;
-import org.apache.commons.modeler.Registry;
 import org.apache.tomcat.util.compat.JdkCompat;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.Registry;
 
 /**
  * <p>A <strong>ModelMBean</strong> implementation for the

==================================================
ManagerBase.java
index 25d3740615..4a0e3b707a 100644
--- a/java/org/apache/catalina/realm/RealmBase.java
+++ b/java/org/apache/catalina/realm/RealmBase.java
@@ -52,7 +52,7 @@ import org.apache.catalina.util.MD5Encoder;
 import org.apache.catalina.util.StringManager;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.commons.modeler.Registry;
+import org.apache.tomcat.util.modeler.Registry;
 
 /**
  * Simple implementation of <b>Realm</b> that reads an XML file to configure

==================================================
HostConfig.java
index 7213a0f44a..a033ce6152 100644
--- a/java/org/apache/catalina/session/ManagerBase.java
+++ b/java/org/apache/catalina/session/ManagerBase.java
@@ -48,7 +48,7 @@ import org.apache.catalina.core.StandardHost;
 import org.apache.catalina.util.StringManager;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.commons.modeler.Registry;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 /**

==================================================
AjpAprProtocol.java
index ab20c5ee17..fae2224755 100644
--- a/java/org/apache/catalina/startup/HostConfig.java
+++ b/java/org/apache/catalina/startup/HostConfig.java
@@ -41,8 +41,8 @@ import org.apache.catalina.LifecycleListener;
 import org.apache.catalina.core.ContainerBase;
 import org.apache.catalina.core.StandardHost;
 import org.apache.catalina.util.StringManager;
-import org.apache.commons.modeler.Registry;
 import org.apache.tomcat.util.digester.Digester;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 /**

==================================================
Http11AprProtocol.java
index 3fb2c3915d..9e3ebfcf9f 100644
--- a/java/org/apache/coyote/ajp/AjpAprProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpAprProtocol.java
@@ -25,13 +25,13 @@ import javax.management.MBeanRegistration;
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
-import org.apache.commons.modeler.Registry;
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.ActionHook;
 import org.apache.coyote.Adapter;
 import org.apache.coyote.ProtocolHandler;
 import org.apache.coyote.RequestGroupInfo;
 import org.apache.coyote.RequestInfo;
+import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.net.AprEndpoint;
 import org.apache.tomcat.util.net.AprEndpoint.Handler;
 import org.apache.tomcat.util.res.StringManager;

==================================================
Http11Protocol.java
index c6b4e29a00..8c71250e5b 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -25,13 +25,13 @@ import javax.management.MBeanRegistration;
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
-import org.apache.commons.modeler.Registry;
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.ActionHook;
 import org.apache.coyote.Adapter;
 import org.apache.coyote.ProtocolHandler;
 import org.apache.coyote.RequestGroupInfo;
 import org.apache.coyote.RequestInfo;
+import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.net.AprEndpoint;
 import org.apache.tomcat.util.net.AprEndpoint.Handler;
 import org.apache.tomcat.util.res.StringManager;

==================================================
ChannelNioSocket.java
index 96323c20c7..95cd8d83aa 100644
--- a/java/org/apache/coyote/http11/Http11Protocol.java
+++ b/java/org/apache/coyote/http11/Http11Protocol.java
@@ -20,8 +20,8 @@ import javax.management.MBeanRegistration;
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
-import org.apache.commons.modeler.Registry;
 import org.apache.coyote.RequestInfo;
+import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.threads.ThreadPool;
 import org.apache.tomcat.util.threads.ThreadWithAttributes;
 

==================================================
ChannelSocket.java
index b51b350e0c..9302d5a05b 100644
--- a/java/org/apache/jk/common/ChannelNioSocket.java
+++ b/java/org/apache/jk/common/ChannelNioSocket.java
@@ -45,7 +45,6 @@ import javax.management.NotificationFilter;
 import javax.management.NotificationListener;
 import javax.management.ObjectName;
 
-import org.apache.commons.modeler.Registry;
 import org.apache.jk.core.JkHandler;
 import org.apache.jk.core.Msg;
 import org.apache.jk.core.MsgContext;
@@ -54,6 +53,7 @@ import org.apache.jk.core.WorkerEnv;
 import org.apache.coyote.Request;
 import org.apache.coyote.RequestGroupInfo;
 import org.apache.coyote.RequestInfo;
+import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.threads.ThreadPool;
 import org.apache.tomcat.util.threads.ThreadPoolRunnable;
 

==================================================
ChannelUn.java
index 5b71530048..c49833d7d8 100644
--- a/java/org/apache/jk/common/ChannelSocket.java
+++ b/java/org/apache/jk/common/ChannelSocket.java
@@ -36,7 +36,6 @@ import javax.management.NotificationFilter;
 import javax.management.NotificationListener;
 import javax.management.ObjectName;
 
-import org.apache.commons.modeler.Registry;
 import org.apache.jk.core.JkHandler;
 import org.apache.jk.core.Msg;
 import org.apache.jk.core.MsgContext;
@@ -45,6 +44,7 @@ import org.apache.jk.core.WorkerEnv;
 import org.apache.coyote.Request;
 import org.apache.coyote.RequestGroupInfo;
 import org.apache.coyote.RequestInfo;
+import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.threads.ThreadPool;
 import org.apache.tomcat.util.threads.ThreadPoolRunnable;
 

==================================================
JniHandler.java
index 281fa816fc..1253db91db 100644
--- a/java/org/apache/jk/common/ChannelUn.java
+++ b/java/org/apache/jk/common/ChannelUn.java
@@ -22,7 +22,6 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import javax.management.ObjectName;
 
-import org.apache.commons.modeler.Registry;
 import org.apache.jk.core.JkHandler;
 import org.apache.jk.core.Msg;
 import org.apache.jk.core.MsgContext;
@@ -31,6 +30,7 @@ import org.apache.jk.core.WorkerEnv;
 import org.apache.coyote.Request;
 import org.apache.coyote.RequestGroupInfo;
 import org.apache.coyote.RequestInfo;
+import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.threads.ThreadPool;
 import org.apache.tomcat.util.threads.ThreadPoolRunnable;
 

==================================================
ModJkMX.java
index 27824a6984..46e176a9af 100644
--- a/java/org/apache/jk/common/JniHandler.java
+++ b/java/org/apache/jk/common/JniHandler.java
@@ -20,7 +20,6 @@ import java.io.IOException;
 
 import javax.management.ObjectName;
 
-import org.apache.commons.modeler.Registry;
 import org.apache.jk.apr.AprImpl;
 import org.apache.jk.core.JkHandler;
 import org.apache.jk.core.Msg;
@@ -29,6 +28,7 @@ import org.apache.jk.core.JkChannel;
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.buf.C2BConverter;
 import org.apache.tomcat.util.buf.MessageBytes;
+import org.apache.tomcat.util.modeler.Registry;
 
 
 /**

==================================================
JkHandler.java
index 4220784f86..7fa732e9d0 100644
--- a/java/org/apache/jk/common/ModJkMX.java
+++ b/java/org/apache/jk/common/ModJkMX.java
@@ -33,11 +33,11 @@ import javax.management.Attribute;
 import javax.management.ObjectName;
 
 import org.apache.jk.core.JkHandler;
-import org.apache.commons.modeler.Registry;
-import org.apache.commons.modeler.BaseModelMBean;
-import org.apache.commons.modeler.ManagedBean;
-import org.apache.commons.modeler.AttributeInfo;
-import org.apache.commons.modeler.OperationInfo;
+import org.apache.tomcat.util.modeler.AttributeInfo;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.OperationInfo;
+import org.apache.tomcat.util.modeler.Registry;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 

==================================================
JkCoyoteHandler.java
index 939e2ece97..db089315e2 100644
--- a/java/org/apache/jk/core/JkHandler.java
+++ b/java/org/apache/jk/core/JkHandler.java
@@ -25,7 +25,7 @@ import javax.management.Notification;
 import javax.management.NotificationListener;
 import javax.management.ObjectName;
 
-import org.apache.commons.modeler.Registry;
+import org.apache.tomcat.util.modeler.Registry;
 
 /**
  *

==================================================
JkMain.java
index 045d964c8d..91a1cda84d 100644
--- a/java/org/apache/jk/server/JkCoyoteHandler.java
+++ b/java/org/apache/jk/server/JkCoyoteHandler.java
@@ -22,7 +22,6 @@ import java.util.Iterator;
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
-import org.apache.commons.modeler.Registry;
 import org.apache.coyote.Adapter;
 import org.apache.coyote.ProtocolHandler;
 import org.apache.coyote.Request;
@@ -41,6 +40,7 @@ import org.apache.tomcat.util.buf.C2BConverter;
 import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.http.HttpMessages;
 import org.apache.tomcat.util.http.MimeHeaders;
+import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.net.SSLSupport;
 
 /** Plugs Jk into Coyote. Must be named "type=JkHandler,name=container"

==================================================
DomUtil.java
index 1ac6385e69..bd44782593 100644
--- a/java/org/apache/jk/server/JkMain.java
+++ b/java/org/apache/jk/server/JkMain.java
@@ -31,10 +31,10 @@ import javax.management.MBeanRegistration;
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
-import org.apache.commons.modeler.Registry;
 import org.apache.jk.core.JkHandler;
 import org.apache.jk.core.WorkerEnv;
 import org.apache.tomcat.util.IntrospectionUtils;
+import org.apache.tomcat.util.modeler.Registry;
 
 /** Main class used to startup and configure jk. It manages the conf/jk2.properties file
  *  and is the target of JMX proxy.

==================================================
AttributeInfo.java
new file mode 100644
index 0000000000..3cac8a7069
--- /dev/null
+++ b/java/org/apache/tomcat/util/DomUtil.java
@@ -0,0 +1,269 @@
+/*
+ * Copyright 1999,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.StringReader;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.OutputKeys;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.transform.stream.StreamResult;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+import org.xml.sax.EntityResolver;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
+
+/**
+ *  Few simple utils to read DOM
+ *
+ * @author Costin Manolache
+ */
+public class DomUtil {
+    private static org.apache.commons.logging.Log log=
+        org.apache.commons.logging.LogFactory.getLog( DomUtil.class );
+
+    // -------------------- DOM utils --------------------
+
+    /** Get the trimed text content of a node or null if there is no text
+     */
+    public static String getContent(Node n ) {
+        if( n==null ) return null;
+        Node n1=DomUtil.getChild(n, Node.TEXT_NODE);
+
+        if( n1==null ) return null;
+
+        String s1=n1.getNodeValue();
+        return s1.trim();
+    }
+
+    /** Get the first element child.
+     * @param parent lookup direct childs
+     * @param name name of the element. If null return the first element.
+     */
+    public static Node getChild( Node parent, String name ) {
+        if( parent==null ) return null;
+        Node first=parent.getFirstChild();
+        if( first==null ) return null;
+
+        for (Node node = first; node != null;
+             node = node.getNextSibling()) {
+            //System.out.println("getNode: " + name + " " + node.getNodeName());
+            if( node.getNodeType()!=Node.ELEMENT_NODE)
+                continue;
+            if( name != null &&
+                name.equals( node.getNodeName() ) ) {
+                return node;
+            }
+            if( name == null ) {
+                return node;
+            }
+        }
+        return null;
+    }
+
+    public static String getAttribute(Node element, String attName ) {
+        NamedNodeMap attrs=element.getAttributes();
+        if( attrs==null ) return null;
+        Node attN=attrs.getNamedItem(attName);
+        if( attN==null ) return null;
+        return attN.getNodeValue();
+    }
+
+    public static void setAttribute(Node node, String attName, String val) {
+        NamedNodeMap attributes=node.getAttributes();
+        Node attNode=node.getOwnerDocument().createAttribute(attName);
+        attNode.setNodeValue( val );
+        attributes.setNamedItem(attNode);
+    }
+    
+    public static void removeAttribute( Node node, String attName ) {
+        NamedNodeMap attributes=node.getAttributes();
+        attributes.removeNamedItem(attName);                
+    }
+    
+    
+    /** Set or replace the text value 
+     */ 
+    public static void setText(Node node, String val) {
+        Node chld=DomUtil.getChild(node, Node.TEXT_NODE);
+        if( chld == null ) {
+            Node textN=node.getOwnerDocument().createTextNode(val);
+            node.appendChild(textN);
+            return;
+        }
+        // change the value
+        chld.setNodeValue(val);           
+    }
+
+    /** Find the first direct child with a given attribute.
+     * @param parent
+     * @param elemName name of the element, or null for any 
+     * @param attName attribute we're looking for
+     * @param attVal attribute value or null if we just want any
+     */ 
+    public static Node findChildWithAtt(Node parent, String elemName,
+                                        String attName, String attVal) {
+        
+        Node child=DomUtil.getChild(parent, Node.ELEMENT_NODE);
+        if( attVal== null ) {
+            while( child!= null &&
+                    ( elemName==null || elemName.equals( child.getNodeName())) && 
+                    DomUtil.getAttribute(child, attName) != null ) {
+                child=getNext(child, elemName, Node.ELEMENT_NODE );
+            }
+        } else {
+            while( child!= null && 
+                    ( elemName==null || elemName.equals( child.getNodeName())) && 
+                    ! attVal.equals( DomUtil.getAttribute(child, attName)) ) {
+                child=getNext(child, elemName, Node.ELEMENT_NODE );
+            }
+        }
+        return child;        
+    }    
+    
+
+    /** Get the first child's content ( ie it's included TEXT node ).
+     */
+    public static String getChildContent( Node parent, String name ) {
+        Node first=parent.getFirstChild();
+        if( first==null ) return null;
+        for (Node node = first; node != null;
+             node = node.getNextSibling()) {
+            //System.out.println("getNode: " + name + " " + node.getNodeName());
+            if( name.equals( node.getNodeName() ) ) {
+                return getContent( node );
+            }
+        }
+        return null;
+    }
+
+    /** Get the first direct child with a given type
+     */
+    public static Node getChild( Node parent, int type ) {
+        Node n=parent.getFirstChild();
+        while( n!=null && type != n.getNodeType() ) {
+            n=n.getNextSibling();
+        }
+        if( n==null ) return null;
+        return n;
+    }
+
+    /** Get the next sibling with the same name and type
+     */
+    public static Node getNext( Node current ) {
+        String name=current.getNodeName();
+        int type=current.getNodeType();
+        return getNext( current, name, type);
+    }
+
+    /** Return the next sibling with a given name and type
+     */ 
+    public static Node getNext( Node current, String name, int type) {
+        Node first=current.getNextSibling();
+        if( first==null ) return null;
+
+        for (Node node = first; node != null;
+             node = node.getNextSibling()) {
+            
+            if( type >= 0 && node.getNodeType() != type ) continue;
+            //System.out.println("getNode: " + name + " " + node.getNodeName());
+            if( name==null )
+                return node;
+            if( name.equals( node.getNodeName() ) ) {
+                return node;
+            }
+        }
+        return null;
+    }
+
+    public static class NullResolver implements EntityResolver {
+        public InputSource resolveEntity (String publicId,
+                                                   String systemId)
+            throws SAXException, IOException
+        {
+            if( log.isTraceEnabled())
+                log.trace("ResolveEntity: " + publicId + " " + systemId);
+            return new InputSource(new StringReader(""));
+        }
+    }
+
+    public static void setAttributes( Object o, Node parent)
+    {
+        NamedNodeMap attrs=parent.getAttributes();
+        if( attrs==null ) return;
+
+        for (int i=0; i<attrs.getLength(); i++ ) {
+            Node n=attrs.item(i);
+            String name=n.getNodeName();
+            String value=n.getNodeValue();
+
+            if( log.isTraceEnabled() )
+                log.trace("Attribute " + parent.getNodeName() + " " +
+                            name + "=" + value);
+            try {
+                IntrospectionUtils.setProperty(o, name, value);
+            } catch( Exception ex ) {
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    /** Read XML as DOM.
+     */
+    public static Document readXml(InputStream is)
+        throws SAXException, IOException, ParserConfigurationException
+    {
+        DocumentBuilderFactory dbf =
+            DocumentBuilderFactory.newInstance();
+
+        dbf.setValidating(false);
+        dbf.setIgnoringComments(false);
+        dbf.setIgnoringElementContentWhitespace(true);
+        //dbf.setCoalescing(true);
+        //dbf.setExpandEntityReferences(true);
+
+        DocumentBuilder db = null;
+        db = dbf.newDocumentBuilder();
+        db.setEntityResolver( new NullResolver() );
+
+        // db.setErrorHandler( new MyErrorHandler());
+
+        Document doc = db.parse(is);
+        return doc;
+    }
+
+    public static void writeXml( Node n, OutputStream os )
+            throws TransformerException
+    {
+        TransformerFactory tf=TransformerFactory.newInstance();
+        //identity
+        Transformer t=tf.newTransformer();
+        t.setOutputProperty(OutputKeys.INDENT, "yes");
+        t.transform(new DOMSource( n ), new StreamResult( os ));
+    }
+}

==================================================
BaseAttributeFilter.java
new file mode 100644
index 0000000000..f806a1d483
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/AttributeInfo.java
@@ -0,0 +1,317 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler;
+
+
+import java.io.Serializable;
+import java.lang.reflect.Method;
+
+import javax.management.Descriptor;
+import javax.management.modelmbean.ModelMBeanAttributeInfo;
+
+
+/**
+ * <p>Internal configuration information for an <code>Attribute</code>
+ * descriptor.</p>
+ *
+ * @author Craig R. McClanahan
+ * @version $Revision: 155428 $ $Date: 2005-02-26 14:12:25 +0100 (sam., 26 févr. 2005) $
+ */
+
+public class AttributeInfo extends FeatureInfo implements Serializable {
+    static final long serialVersionUID = -2511626862303972143L;
+
+    // ----------------------------------------------------- Instance Variables
+
+
+    /**
+     * The <code>ModelMBeanAttributeInfo</code> object that corresponds
+     * to this <code>AttributeInfo</code> instance.
+     */
+    protected transient ModelMBeanAttributeInfo info = null;
+    protected String displayName = null;
+    protected String getMethod = null;
+    protected String setMethod = null;
+
+    protected transient Method getMethodObj = null;
+    protected transient Method setMethodObj = null;
+
+    protected boolean readable = true;
+    protected boolean writeable = true;
+
+    protected boolean is = false;
+    protected String type = null;
+
+    protected String persist;
+    protected String defaultStringValue;
+    // ------------------------------------------------------------- Properties
+
+
+    /**
+     * Override the <code>description</code> property setter.
+     *
+     * @param description The new description
+     */
+    public void setDescription(String description) {
+        super.setDescription(description);
+        this.info = null;
+    }
+
+    /**
+     * Override the <code>name</code> property setter.
+     *
+     * @param name The new name
+     */
+    public void setName(String name) {
+        super.setName(name);
+        this.info = null;
+    }
+
+    /**
+     * The display name of this attribute.
+     */
+    public String getDisplayName() {
+        return (this.displayName);
+    }
+
+    public void setDisplayName(String displayName) {
+        this.displayName = displayName;
+    }
+
+    /**
+     * The name of the property getter method, if non-standard.
+     */
+    public String getGetMethod() {
+        return (this.getMethod);
+    }
+
+    public void setGetMethod(String getMethod) {
+        this.getMethod = getMethod;
+        this.info = null;
+    }
+
+    public Method getGetMethodObj() {
+        return getMethodObj;
+    }
+
+    public void setGetMethodObj(Method getMethodObj) {
+        this.getMethodObj = getMethodObj;
+    }
+
+    public Method getSetMethodObj() {
+        return setMethodObj;
+    }
+
+    public void setSetMethodObj(Method setMethodObj) {
+        this.setMethodObj = setMethodObj;
+    }
+
+    /**
+     * Is this a boolean attribute with an "is" getter?
+     */
+    public boolean isIs() {
+        return (this.is);
+    }
+
+    public void setIs(boolean is) {
+        this.is = is;
+        this.info = null;
+    }
+
+
+    /**
+     * Is this attribute readable by management applications?
+     */
+    public boolean isReadable() {
+        return (this.readable);
+    }
+
+    public void setReadable(boolean readable) {
+        this.readable = readable;
+        this.info = null;
+    }
+
+
+    /**
+     * The name of the property setter method, if non-standard.
+     */
+    public String getSetMethod() {
+        return (this.setMethod);
+    }
+
+    public void setSetMethod(String setMethod) {
+        this.setMethod = setMethod;
+        this.info = null;
+    }
+
+
+    /**
+     * The fully qualified Java class name of this attribute.
+     */
+    public String getType() {
+        return (this.type);
+    }
+
+    public void setType(String type) {
+        this.type = type;
+        this.info = null;
+    }
+
+
+    /**
+     * Is this attribute writeable by management applications?
+     */
+    public boolean isWriteable() {
+        return (this.writeable);
+    }
+
+    public void setWriteable(boolean writeable) {
+        this.writeable = writeable;
+        this.info = null;
+    }
+
+    /** Persistence policy.
+     * All persistent attributes should have this attribute set.
+     * Valid values:
+     *   ???
+     */
+    public String getPersist() {
+        return persist;
+    }
+
+    public void setPersist(String persist) {
+        this.persist = persist;
+    }
+
+    /** Default value. If set, it can provide info to the user and
+     * it can be used by persistence mechanism to generate a more compact
+     * representation ( a value may not be saved if it's default )
+     */
+    public String getDefault() {
+        return defaultStringValue;
+    }
+
+    public void setDefault(String defaultStringValue) {
+        this.defaultStringValue = defaultStringValue;
+    }
+
+
+    // --------------------------------------------------------- Public Methods
+
+
+    /**
+     * Create and return a <code>ModelMBeanAttributeInfo</code> object that
+     * corresponds to the attribute described by this instance.
+     */
+    public ModelMBeanAttributeInfo createAttributeInfo() {
+        // Return our cached information (if any)
+        if (info != null)
+            return (info);
+        if((getMethodObj != null) || (setMethodObj != null) ) {
+            try {
+                info=new ModelMBeanAttributeInfo(getName(), getDescription(),
+                                        getMethodObj,  setMethodObj);
+                return info;
+            } catch( Exception ex) {
+                ex.printStackTrace();
+            }
+        }
+
+        // Create and return a new information object
+        info = new ModelMBeanAttributeInfo
+            (getName(), getType(), getDescription(),
+             isReadable(), isWriteable(), false);
+        Descriptor descriptor = info.getDescriptor();
+        if (getDisplayName() != null)
+            descriptor.setField("displayName", getDisplayName());
+        if (isReadable()) {
+            if (getGetMethod() != null)
+                descriptor.setField("getMethod", getGetMethod());
+            else
+                descriptor.setField("getMethod",
+                                    getMethodName(getName(), true, isIs()));
+        }
+        if (isWriteable()) {
+            if (getSetMethod() != null)
+                descriptor.setField("setMethod", getSetMethod());
+            else
+                descriptor.setField("setMethod",
+                                    getMethodName(getName(), false, false));
+        }
+        addFields(descriptor);
+        info.setDescriptor(descriptor);
+        return (info);
+
+    }
+
+
+    /**
+     * Return a string representation of this attribute descriptor.
+     */
+    public String toString() {
+
+        StringBuffer sb = new StringBuffer("AttributeInfo[");
+        sb.append("name=");
+        sb.append(name);
+        sb.append(", description=");
+        sb.append(description);
+        if (!readable) {
+            sb.append(", readable=");
+            sb.append(readable);
+        }
+        sb.append(", type=");
+        sb.append(type);
+        if (!writeable) {
+            sb.append(", writeable=");
+            sb.append(writeable);
+        }
+        sb.append("]");
+        return (sb.toString());
+
+    }
+
+
+    // -------------------------------------------------------- Private Methods
+
+
+    /**
+     * Create and return the name of a default property getter or setter
+     * method, according to the specified values.
+     *
+     * @param name Name of the property itself
+     * @param getter Do we want a get method (versus a set method)?
+     * @param is If returning a getter, do we want the "is" form?
+     */
+    private String getMethodName(String name, boolean getter, boolean is) {
+
+        StringBuffer sb = new StringBuffer();
+        if (getter) {
+            if (is)
+                sb.append("is");
+            else
+                sb.append("get");
+        } else
+            sb.append("set");
+        sb.append(Character.toUpperCase(name.charAt(0)));
+        sb.append(name.substring(1));
+        return (sb.toString());
+
+    }
+
+
+}

==================================================
BaseModelMBean.java
new file mode 100644
index 0000000000..0701f6c703
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/BaseAttributeFilter.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright 1999,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler;
+
+
+import java.util.HashSet;
+
+import javax.management.AttributeChangeNotification;
+import javax.management.Notification;
+import javax.management.NotificationFilter;
+
+
+/**
+ * <p>Implementation of <code>NotificationFilter</code> for attribute change
+ * notifications.  This class is used by <code>BaseModelMBean</code> to
+ * construct attribute change notification event filters when a filter is not
+ * supplied by the application.</p>
+ *
+ * @author Craig R. McClanahan
+ * @version $Revision: 155428 $ $Date: 2005-02-26 14:12:25 +0100 (sam., 26 févr. 2005) $
+ */
+
+public class BaseAttributeFilter implements NotificationFilter {
+
+
+    // ----------------------------------------------------------- Constructors
+
+
+    /**
+     * Construct a new filter that accepts only the specified attribute
+     * name.
+     *
+     * @param name Name of the attribute to be accepted by this filter, or
+     *  <code>null</code> to accept all attribute names
+     */
+    public BaseAttributeFilter(String name) {
+
+        super();
+        if (name != null)
+            addAttribute(name);
+
+    }
+
+
+    // ----------------------------------------------------- Instance Variables
+
+
+    /**
+     * The set of attribute names that are accepted by this filter.  If this
+     * list is empty, all attribute names are accepted.
+     */
+    private HashSet names = new HashSet();
+
+
+    // --------------------------------------------------------- Public Methods
+
+
+    /**
+     * Add a new attribute name to the set of names accepted by this filter.
+     *
+     * @param name Name of the attribute to be accepted
+     */
+    public void addAttribute(String name) {
+
+        synchronized (names) {
+            names.add(name);
+        }
+
+    }
+
+
+    /**
+     * Clear all accepted names from this filter, so that it will accept
+     * all attribute names.
+     */
+    public void clear() {
+
+        synchronized (names) {
+            names.clear();
+        }
+
+    }
+
+
+    /**
+     * Return the set of names that are accepted by this filter.  If this
+     * filter accepts all attribute names, a zero length array will be
+     * returned.
+     */
+    public String[] getNames() {
+
+        synchronized (names) {
+            return ((String[]) names.toArray(new String[names.size()]));
+        }
+
+    }
+
+
+    /**
+     * <p>Test whether notification enabled for this event.
+     * Return true if:</p>
+     * <ul>
+     * <li>This is an attribute change notification</li>
+     * <li>Either the set of accepted names is empty (implying that all
+     *     attribute names are of interest) or the set of accepted names
+     *     includes the name of the attribute in this notification</li>
+     * </ul>
+     */
+    public boolean isNotificationEnabled(Notification notification) {
+
+        if (notification == null)
+            return (false);
+        if (!(notification instanceof AttributeChangeNotification))
+            return (false);
+        AttributeChangeNotification acn =
+            (AttributeChangeNotification) notification;
+        if (!AttributeChangeNotification.ATTRIBUTE_CHANGE.equals(acn.getType()))
+            return (false);
+        synchronized (names) {
+            if (names.size() < 1)
+                return (true);
+            else
+                return (names.contains(acn.getAttributeName()));
+        }
+
+    }
+
+
+    /**
+     * Remove an attribute name from the set of names accepted by this
+     * filter.
+     *
+     * @param name Name of the attribute to be removed
+     */
+    public void removeAttribute(String name) {
+
+        synchronized (names) {
+            names.remove(name);
+        }
+
+    }
+
+
+}

==================================================
BaseNotification.java
new file mode 100644
index 0000000000..f633beb1cf
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/BaseModelMBean.java
@@ -0,0 +1,1416 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler;
+
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.Iterator;
+
+import javax.management.Attribute;
+import javax.management.AttributeChangeNotification;
+import javax.management.AttributeList;
+import javax.management.AttributeNotFoundException;
+import javax.management.Descriptor;
+import javax.management.DynamicMBean;
+import javax.management.InstanceNotFoundException;
+import javax.management.InvalidAttributeValueException;
+import javax.management.ListenerNotFoundException;
+import javax.management.MBeanException;
+import javax.management.MBeanInfo;
+import javax.management.MBeanNotificationInfo;
+import javax.management.MBeanRegistration;
+import javax.management.MBeanServer;
+import javax.management.Notification;
+import javax.management.NotificationFilter;
+import javax.management.NotificationListener;
+import javax.management.ObjectName;
+import javax.management.ReflectionException;
+import javax.management.RuntimeErrorException;
+import javax.management.RuntimeOperationsException;
+import javax.management.ServiceNotFoundException;
+import javax.management.modelmbean.DescriptorSupport;
+import javax.management.modelmbean.InvalidTargetObjectTypeException;
+import javax.management.modelmbean.ModelMBean;
+import javax.management.modelmbean.ModelMBeanAttributeInfo;
+import javax.management.modelmbean.ModelMBeanInfo;
+import javax.management.modelmbean.ModelMBeanInfoSupport;
+import javax.management.modelmbean.ModelMBeanNotificationInfo;
+import javax.management.modelmbean.ModelMBeanOperationInfo;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.tomcat.util.modeler.modules.ModelerSource;
+
+// TODO: enable ant-like substitutions ? ( or at least discuss it )
+
+/**
+ * <p>Basic implementation of the <code>ModelMBean</code> interface, which
+ * supports the minimal requirements of the interface contract.</p>
+ *
+ * <p>This can be used directly to wrap an existing java bean, or inside
+ * an mlet or anywhere an MBean would be used. The String parameter
+ * passed to the constructor will be used to construct an instance of the
+ * real object that we wrap.
+ *
+ * Limitations:
+ * <ul>
+ * <li>Only managed resources of type <code>objectReference</code> are
+ *     supportd.</li>
+ * <li>Caching of attribute values and operation results is not supported.
+ *     All calls to <code>invoke()</code> are immediately executed.</li>
+ * <li>Logging (under control of descriptors) is not supported.</li>
+ * <li>Persistence of MBean attributes and operations is not supported.</li>
+ * <li>All classes referenced as attribute types, operation parameters, or
+ *     operation return values must be one of the following:
+ *     <ul>
+ *     <li>One of the Java primitive types (boolean, byte, char, double,
+ *         float, integer, long, short).  Corresponding value will be wrapped
+ *         in the appropriate wrapper class automatically.</li>
+ *     <li>Operations that return no value should declare a return type of
+ *         <code>void</code>.</li>
+ *     </ul>
+ * <li>Attribute caching is not supported</li>
+ * </ul>
+ *
+ * @author Craig R. McClanahan
+ * @author Costin Manolache
+ * @version $Revision: 383269 $ $Date: 2006-03-05 03:22:41 +0100 (dim., 05 mars 2006) $
+ */
+
+public class BaseModelMBean implements ModelMBean, MBeanRegistration {
+    private static Log log = LogFactory.getLog(BaseModelMBean.class);
+
+    // ----------------------------------------------------------- Constructors
+
+    /**
+     * Construct a <code>ModelMBean</code> with default
+     * <code>ModelMBeanInfo</code> information.
+     *
+     * @exception MBeanException if the initializer of an object
+     *  throws an exception
+     * @exception RuntimeOperationsException if an IllegalArgumentException
+     *  occurs
+     */
+    public BaseModelMBean() throws MBeanException, RuntimeOperationsException {
+
+        super();
+        if( log.isDebugEnabled()) log.debug("default constructor");
+        setModelMBeanInfo(createDefaultModelMBeanInfo());
+    }
+
+
+    /**
+     * Construct a <code>ModelMBean</code> associated with the specified
+     * <code>ModelMBeanInfo</code> information.
+     *
+     * @param info ModelMBeanInfo for this MBean
+     *
+     * @exception MBeanException if the initializer of an object
+     *  throws an exception
+     * @exception RuntimeOperationsException if an IllegalArgumentException
+     *  occurs
+     */
+    public BaseModelMBean(ModelMBeanInfo info)
+        throws MBeanException, RuntimeOperationsException {
+        // XXX should be deprecated - just call setInfo
+        super();
+        setModelMBeanInfo(info);
+        if( log.isDebugEnabled()) log.debug("ModelMBeanInfo constructor");
+    }
+
+    /** Construct a ModelMBean of a specified type.
+     *  The type can be a class name or the key used in one of the descriptors.
+     *
+     * If no descriptor is available, we'll first try to locate one in
+     * the same package with the class, then use introspection.
+     *
+     * The mbean resource will be created.
+     *
+     * @param type Class name or the type key used in the descriptor.
+     * @throws MBeanException
+     * @throws RuntimeOperationsException
+     */
+    public BaseModelMBean( String type )
+        throws MBeanException, RuntimeOperationsException
+    {
+        try {
+            // This constructor is used from <mlet>, it should create
+            // the resource
+            setModeledType(type);
+        } catch( Throwable ex ) {
+            log.error( "Error creating mbean ", ex);
+        }
+    }
+
+    public BaseModelMBean( String type, ModelerSource source )
+        throws MBeanException, RuntimeOperationsException
+    {
+        try {
+            setModeledType(type);
+        } catch( Throwable ex ) {
+            log.error( "Error creating mbean ", ex);
+        }
+        this.source=source;
+    }
+
+    // ----------------------------------------------------- Instance Variables
+
+
+    /**
+     * Notification broadcaster for attribute changes.
+     */
+    protected BaseNotificationBroadcaster attributeBroadcaster = null;
+
+    /** Registry we are associated with
+     */
+    protected Registry registry=null;
+
+    /**
+     * Notification broadcaster for general notifications.
+     */
+    protected BaseNotificationBroadcaster generalBroadcaster = null;
+
+    protected ObjectName oname=null;
+
+    /**
+     * The <code>ModelMBeanInfo</code> object that controls our activity.
+     */
+    protected ModelMBeanInfo info = null;
+
+
+    /**
+     * The managed resource this MBean is associated with (if any).
+     */
+    protected Object resource = null;
+    protected String resourceType = null;
+
+    /** Source object used to read this mbean. Can be used to
+     * persist the mbean
+     */
+    protected ModelerSource source=null;
+
+    /** Attribute values. XXX That can be stored in the value Field
+     */
+    protected HashMap attributes=new HashMap();
+
+    // --------------------------------------------------- DynamicMBean Methods
+    static final Object[] NO_ARGS_PARAM=new Object[0];
+    static final Class[] NO_ARGS_PARAM_SIG=new Class[0];
+    // key: attribute val: getter method
+    private Hashtable getAttMap=new Hashtable();
+
+    // key: attribute val: setter method
+    private Hashtable setAttMap=new Hashtable();
+
+    // key: operation val: invoke method
+    private Hashtable invokeAttMap=new Hashtable();
+
+    /**
+     * Obtain and return the value of a specific attribute of this MBean.
+     *
+     * @param name Name of the requested attribute
+     *
+     * @exception AttributeNotFoundException if this attribute is not
+     *  supported by this MBean
+     * @exception MBeanException if the initializer of an object
+     *  throws an exception
+     * @exception ReflectionException if a Java reflection exception
+     *  occurs when invoking the getter
+     */
+    public Object getAttribute(String name)
+        throws AttributeNotFoundException, MBeanException,
+            ReflectionException {
+        // Validate the input parameters
+        if (name == null)
+            throw new RuntimeOperationsException
+                (new IllegalArgumentException("Attribute name is null"),
+                 "Attribute name is null");
+
+        if( (resource instanceof DynamicMBean) && 
+             ! ( resource instanceof BaseModelMBean )) {
+            return ((DynamicMBean)resource).getAttribute(name);
+        }
+        
+        // Extract the method from cache
+        Method m=(Method)getAttMap.get( name );
+
+        if( m==null ) {
+            // Look up the actual operation to be used
+            ModelMBeanAttributeInfo attrInfo = info.getAttribute(name);
+            if (attrInfo == null)
+                throw new AttributeNotFoundException(" Cannot find attribute " + name);
+            Descriptor attrDesc = attrInfo.getDescriptor();
+            if (attrDesc == null)
+                throw new AttributeNotFoundException("Cannot find attribute " + name + " descriptor");
+            String getMethod = (String) attrDesc.getFieldValue("getMethod");
+
+            if (getMethod == null)
+                throw new AttributeNotFoundException("Cannot find attribute " + name + " get method name");
+
+            Object object = null;
+            NoSuchMethodException exception = null;
+            try {
+                object = this;
+                m = object.getClass().getMethod(getMethod, NO_ARGS_PARAM_SIG);
+            } catch (NoSuchMethodException e) {
+                exception = e;;
+            }
+            if( m== null && resource != null ) {
+                try {
+                    object = resource;
+                    m = object.getClass().getMethod(getMethod, NO_ARGS_PARAM_SIG);
+                    exception=null;
+                } catch (NoSuchMethodException e) {
+                    exception = e;
+                }
+            }
+            if( exception != null )
+                throw new ReflectionException(exception,
+                                              "Cannot find getter method " + getMethod);
+            getAttMap.put( name, m );
+        }
+
+        Object result = null;
+        try {
+            Class declaring=m.getDeclaringClass();
+            // workaround for catalina weird mbeans - the declaring class is BaseModelMBean.
+            // but this is the catalina class.
+            if( declaring.isAssignableFrom(this.getClass()) ) {
+                result = m.invoke(this, NO_ARGS_PARAM );
+            } else {
+                result = m.invoke(resource, NO_ARGS_PARAM );
+            }
+        } catch (InvocationTargetException e) {
+            Throwable t = e.getTargetException();
+            if (t == null)
+                t = e;
+            if (t instanceof RuntimeException)
+                throw new RuntimeOperationsException
+                    ((RuntimeException) t, "Exception invoking method " + name);
+            else if (t instanceof Error)
+                throw new RuntimeErrorException
+                    ((Error) t, "Error invoking method " + name);
+            else
+                throw new MBeanException
+                    (e, "Exception invoking method " + name);
+        } catch (Exception e) {
+            throw new MBeanException
+                (e, "Exception invoking method " + name);
+        }
+
+        // Return the results of this method invocation
+        // FIXME - should we validate the return type?
+        return (result);
+    }
+
+
+    /**
+     * Obtain and return the values of several attributes of this MBean.
+     *
+     * @param names Names of the requested attributes
+     */
+    public AttributeList getAttributes(String names[]) {
+
+        // Validate the input parameters
+        if (names == null)
+            throw new RuntimeOperationsException
+                (new IllegalArgumentException("Attribute names list is null"),
+                 "Attribute names list is null");
+
+        // Prepare our response, eating all exceptions
+        AttributeList response = new AttributeList();
+        for (int i = 0; i < names.length; i++) {
+            try {
+                response.add(new Attribute(names[i],getAttribute(names[i])));
+            } catch (Exception e) {
+                ; // Not having a particular attribute in the response
+                ; // is the indication of a getter problem
+            }
+        }
+        return (response);
+
+    }
+
+
+    /**
+     * Return the <code>MBeanInfo</code> object for this MBean.
+     */
+    public MBeanInfo getMBeanInfo() {
+        // XXX Why do we have to clone ?
+        if( info== null ) return null;
+        return ((MBeanInfo) info.clone());
+    }
+
+
+    /**
+     * Invoke a particular method on this MBean, and return any returned
+     * value.
+     *
+     * <p><strong>IMPLEMENTATION NOTE</strong> - This implementation will
+     * attempt to invoke this method on the MBean itself, or (if not
+     * available) on the managed resource object associated with this
+     * MBean.</p>
+     *
+     * @param name Name of the operation to be invoked
+     * @param params Array containing the method parameters of this operation
+     * @param signature Array containing the class names representing
+     *  the signature of this operation
+     *
+     * @exception MBeanException if the initializer of an object
+     *  throws an exception
+     * @exception ReflectioNException if a Java reflection exception
+     *  occurs when invoking a method
+     */
+    public Object invoke(String name, Object params[], String signature[])
+        throws MBeanException, ReflectionException 
+    {
+        if( (resource instanceof DynamicMBean) && 
+             ! ( resource instanceof BaseModelMBean )) {
+            return ((DynamicMBean)resource).invoke(name, params, signature);
+        }
+    
+        // Validate the input parameters
+        if (name == null)
+            throw new RuntimeOperationsException
+                (new IllegalArgumentException("Method name is null"),
+                 "Method name is null");
+
+        if( log.isDebugEnabled()) log.debug("Invoke " + name);
+	MethodKey mkey = new MethodKey(name, signature);
+        Method method=(Method)invokeAttMap.get(mkey);
+        if( method==null ) {
+            if (params == null)
+                params = new Object[0];
+            if (signature == null)
+                signature = new String[0];
+            if (params.length != signature.length)
+                throw new RuntimeOperationsException
+                    (new IllegalArgumentException("Inconsistent arguments and signature"),
+                     "Inconsistent arguments and signature");
+
+            // Acquire the ModelMBeanOperationInfo information for
+            // the requested operation
+            ModelMBeanOperationInfo opInfo = info.getOperation(name);
+            if (opInfo == null)
+                throw new MBeanException
+                    (new ServiceNotFoundException("Cannot find operation " + name),
+                     "Cannot find operation " + name);
+
+            // Prepare the signature required by Java reflection APIs
+            // FIXME - should we use the signature from opInfo?
+            Class types[] = new Class[signature.length];
+            for (int i = 0; i < signature.length; i++) {
+                types[i]=getAttributeClass( signature[i] );
+            }
+
+            // Locate the method to be invoked, either in this MBean itself
+            // or in the corresponding managed resource
+            // FIXME - Accessible methods in superinterfaces?
+            Object object = null;
+            Exception exception = null;
+            try {
+                object = this;
+                method = object.getClass().getMethod(name, types);
+            } catch (NoSuchMethodException e) {
+                exception = e;;
+            }
+            try {
+                if ((method == null) && (resource != null)) {
+                    object = resource;
+                    method = object.getClass().getMethod(name, types);
+                }
+            } catch (NoSuchMethodException e) {
+                exception = e;
+            }
+            if (method == null) {
+                throw new ReflectionException(exception,
+                                              "Cannot find method " + name +
+                                              " with this signature");
+            }
+            invokeAttMap.put( mkey, method );
+        }
+
+        // Invoke the selected method on the appropriate object
+        Object result = null;
+        try {
+            if( method.getDeclaringClass().isAssignableFrom( this.getClass()) ) {
+                result = method.invoke(this, params );
+            } else {
+                result = method.invoke(resource, params);
+            }
+        } catch (InvocationTargetException e) {
+            Throwable t = e.getTargetException();
+            log.error("Exception invoking method " + name , t );
+            if (t == null)
+                t = e;
+            if (t instanceof RuntimeException)
+                throw new RuntimeOperationsException
+                    ((RuntimeException) t, "Exception invoking method " + name);
+            else if (t instanceof Error)
+                throw new RuntimeErrorException
+                    ((Error) t, "Error invoking method " + name);
+            else
+                throw new MBeanException
+                    ((Exception)t, "Exception invoking method " + name);
+        } catch (Exception e) {
+            log.error("Exception invoking method " + name , e );
+            throw new MBeanException
+                (e, "Exception invoking method " + name);
+        }
+
+        // Return the results of this method invocation
+        // FIXME - should we validate the return type?
+        return (result);
+
+    }
+
+    private Class getAttributeClass(String signature)
+        throws ReflectionException
+    {
+        if (signature.equals(Boolean.TYPE.getName()))
+            return Boolean.TYPE;
+        else if (signature.equals(Byte.TYPE.getName()))
+            return Byte.TYPE;
+        else if (signature.equals(Character.TYPE.getName()))
+            return Character.TYPE;
+        else if (signature.equals(Double.TYPE.getName()))
+            return Double.TYPE;
+        else if (signature.equals(Float.TYPE.getName()))
+            return Float.TYPE;
+        else if (signature.equals(Integer.TYPE.getName()))
+            return Integer.TYPE;
+        else if (signature.equals(Long.TYPE.getName()))
+            return Long.TYPE;
+        else if (signature.equals(Short.TYPE.getName()))
+            return Short.TYPE;
+        else {
+            try {
+                ClassLoader cl=Thread.currentThread().getContextClassLoader();
+                if( cl!=null )
+                    return cl.loadClass(signature); 
+            } catch( ClassNotFoundException e ) {
+            }
+            try {
+                return Class.forName(signature);
+            } catch (ClassNotFoundException e) {
+                throw new ReflectionException
+                    (e, "Cannot find Class for " + signature);
+            }
+        }
+    }
+
+    /**
+     * Set the value of a specific attribute of this MBean.
+     *
+     * @param attribute The identification of the attribute to be set
+     *  and the new value
+     *
+     * @exception AttributeNotFoundException if this attribute is not
+     *  supported by this MBean
+     * @exception MBeanException if the initializer of an object
+     *  throws an exception
+     * @exception ReflectionException if a Java reflection exception
+     *  occurs when invoking the getter
+     */
+    public void setAttribute(Attribute attribute)
+        throws AttributeNotFoundException, MBeanException,
+        ReflectionException
+    {
+        if( log.isDebugEnabled() )
+            log.debug("Setting attribute " + this + " " + attribute );
+
+        if( (resource instanceof DynamicMBean) && 
+             ! ( resource instanceof BaseModelMBean )) {
+            try {
+                ((DynamicMBean)resource).setAttribute(attribute);
+            } catch (InvalidAttributeValueException e) {
+                throw new MBeanException(e);                
+            }
+            return;
+        }
+        
+        // Validate the input parameters
+        if (attribute == null)
+            throw new RuntimeOperationsException
+                (new IllegalArgumentException("Attribute is null"),
+                 "Attribute is null");
+
+        String name = attribute.getName();
+        Object value = attribute.getValue();
+
+        if (name == null)
+            throw new RuntimeOperationsException
+                (new IllegalArgumentException("Attribute name is null"),
+                 "Attribute name is null");
+
+        ModelMBeanAttributeInfo attrInfo=info.getAttribute(name);
+        if (attrInfo == null)
+            throw new AttributeNotFoundException("Cannot find attribute " + name);
+
+        Descriptor attrDesc=attrInfo.getDescriptor();
+        if (attrDesc == null)
+            throw new AttributeNotFoundException("Cannot find attribute " + name + " descriptor");
+
+        Object oldValue=null;
+        if( getAttMap.get(name) != null )
+            oldValue=getAttribute( name );
+
+
+        // Extract the method from cache
+        Method m=(Method)setAttMap.get( name );
+
+        if( m==null ) {
+            // Look up the actual operation to be used
+            String setMethod = (String) attrDesc.getFieldValue("setMethod");
+            if (setMethod == null)
+                throw new AttributeNotFoundException("Cannot find attribute " + name + " set method name");
+
+            String argType=attrInfo.getType();
+
+            Class signature[] = new Class[] { getAttributeClass( argType ) };
+
+            Object object = null;
+            NoSuchMethodException exception = null;
+            try {
+                object = this;
+                m = object.getClass().getMethod(setMethod, signature);
+            } catch (NoSuchMethodException e) {
+                exception = e;;
+            }
+            if( m== null && resource != null ) {
+                try {
+                    object = resource;
+                    m = object.getClass().getMethod(setMethod, signature);
+                    exception=null;
+                } catch (NoSuchMethodException e) {
+                    if( log.isDebugEnabled())
+                        log.debug("Method not found in resource " +resource);
+                    exception = e;
+                }
+            }
+            if( exception != null )
+                throw new ReflectionException(exception,
+                                              "Cannot find setter method " + setMethod +
+                        " " + resource);
+            setAttMap.put( name, m );
+        }
+
+        Object result = null;
+        try {
+            if( m.getDeclaringClass().isAssignableFrom( this.getClass()) ) {
+                result = m.invoke(this, new Object[] { value });
+            } else {
+                result = m.invoke(resource, new Object[] { value });
+            }
+        } catch (InvocationTargetException e) {
+            Throwable t = e.getTargetException();
+            if (t == null)
+                t = e;
+            if (t instanceof RuntimeException)
+                throw new RuntimeOperationsException
+                    ((RuntimeException) t, "Exception invoking method " + name);
+            else if (t instanceof Error)
+                throw new RuntimeErrorException
+                    ((Error) t, "Error invoking method " + name);
+            else
+                throw new MBeanException
+                    (e, "Exception invoking method " + name);
+        } catch (Exception e) {
+            log.error("Exception invoking method " + name , e );
+            throw new MBeanException
+                (e, "Exception invoking method " + name);
+        }
+        try {
+            sendAttributeChangeNotification(new Attribute( name, oldValue),
+                    attribute);
+        } catch(Exception ex) {
+            log.error("Error sending notification " + name, ex);
+        }
+        attributes.put( name, value );
+        if( source != null ) {
+            // this mbean is asscoiated with a source - maybe we want to persist
+            source.updateField(oname, name, value);
+        }
+    }
+
+    public String toString() {
+        if( resource==null ) 
+            return "BaseModelMbean[" + resourceType + "]";
+        return resource.toString();
+    }
+
+    /**
+     * Set the values of several attributes of this MBean.
+     *
+     * @param attributes THe names and values to be set
+     *
+     * @return The list of attributes that were set and their new values
+     */
+    public AttributeList setAttributes(AttributeList attributes) {
+
+        // Validate the input parameters
+        if (attributes == null)
+            throw new RuntimeOperationsException
+                (new IllegalArgumentException("Attributes list is null"),
+                 "Attributes list is null");
+
+        // Prepare and return our response, eating all exceptions
+        AttributeList response = new AttributeList();
+        String names[] = new String[attributes.size()];
+        int n = 0;
+        Iterator items = attributes.iterator();
+        while (items.hasNext()) {
+            Attribute item = (Attribute) items.next();
+            names[n++] = item.getName();
+            try {
+                setAttribute(item);
+            } catch (Exception e) {
+                ; // Ignore all exceptions
+            }
+        }
+
+        return (getAttributes(names));
+
+    }
+
+
+    // ----------------------------------------------------- ModelMBean Methods
+
+
+    /**
+     * Get the instance handle of the object against which we execute
+     * all methods in this ModelMBean management interface.
+     *
+     * @exception InstanceNotFoundException if the managed resource object
+     *  cannot be found
+     * @exception MBeanException if the initializer of the object throws
+     *  an exception
+     * @exception RuntimeOperationsException if the managed resource or the
+     *  resource type is <code>null</code> or invalid
+     */
+    public Object getManagedResource()
+        throws InstanceNotFoundException, InvalidTargetObjectTypeException,
+        MBeanException, RuntimeOperationsException {
+
+        if (resource == null)
+            throw new RuntimeOperationsException
+                (new IllegalArgumentException("Managed resource is null"),
+                 "Managed resource is null");
+
+        return resource;
+
+    }
+
+
+    /**
+     * Set the instance handle of the object against which we will execute
+     * all methods in this ModelMBean management interface.
+     *
+     * This method will detect and call "setModelMbean" method. A resource
+     * can implement this method to get a reference to the model mbean.
+     * The reference can be used to send notification and access the
+     * registry.
+     *
+     * @param resource The resource object to be managed
+     * @param type The type of reference for the managed resource
+     *  ("ObjectReference", "Handle", "IOR", "EJBHandle", or
+     *  "RMIReference")
+     *
+     * @exception InstanceNotFoundException if the managed resource object
+     *  cannot be found
+     * @exception InvalidTargetObjectTypeException if this ModelMBean is
+     *  asked to handle a reference type it cannot deal with
+     * @exception MBeanException if the initializer of the object throws
+     *  an exception
+     * @exception RuntimeOperationsException if the managed resource or the
+     *  resource type is <code>null</code> or invalid
+     */
+    public void setManagedResource(Object resource, String type)
+        throws InstanceNotFoundException, InvalidTargetObjectTypeException,
+        MBeanException, RuntimeOperationsException
+    {
+        if (resource == null)
+            throw new RuntimeOperationsException
+                (new IllegalArgumentException("Managed resource is null"),
+                 "Managed resource is null");
+
+        if (!"objectreference".equalsIgnoreCase(type))
+            throw new InvalidTargetObjectTypeException(type);
+
+        this.resource = resource;
+        this.resourceType = resource.getClass().getName();
+        
+        // Make the resource aware of the model mbean.
+        try {
+            Method m=resource.getClass().getMethod("setModelMBean",
+                    new Class[] {ModelMBean.class});
+            if( m!= null ) {
+                m.invoke(resource, new Object[] {this});
+            }
+        } catch( NoSuchMethodException t ) {
+            // ignore
+        } catch( Throwable t ) {
+            log.error( "Can't set model mbean ", t );
+        }
+    }
+
+
+    /**
+     * Initialize the <code>ModelMBeanInfo</code> associated with this
+     * <code>ModelMBean</code>.  After the information and associated
+     * descriptors have been customized, the <code>ModelMBean</code> should
+     * be registered with the associated <code>MBeanServer</code>.
+     *
+     * Currently the model can be set after registration. This behavior is
+     * deprecated and won't be supported in future versions.
+     *
+     * @param info The ModelMBeanInfo object to be used by this ModelMBean
+     *
+     * @exception MBeanException If an exception occurs recording this
+     *  ModelMBeanInfo information
+     * @exception RuntimeOperations if the specified parameter is
+     *  <code>null</code> or invalid
+     */
+    public void setModelMBeanInfo(ModelMBeanInfo info)
+        throws MBeanException, RuntimeOperationsException {
+
+        if (info == null)
+            throw new RuntimeOperationsException
+                (new IllegalArgumentException("ModelMBeanInfo is null"),
+                 "ModelMBeanInfo is null");
+
+        if (!isModelMBeanInfoValid(info))
+            throw new RuntimeOperationsException
+                (new IllegalArgumentException("ModelMBeanInfo is invalid"),
+                 "ModelMBeanInfo is invalid");
+
+        this.info = (ModelMBeanInfo) info.clone();
+
+    }
+
+
+    // ------------------------------ ModelMBeanNotificationBroadcaster Methods
+
+
+    /**
+     * Add an attribute change notification event listener to this MBean.
+     *
+     * @param listener Listener that will receive event notifications
+     * @param name Name of the attribute of interest, or <code>null</code>
+     *  to indicate interest in all attributes
+     * @param handback Handback object to be sent along with event
+     *  notifications
+     *
+     * @exception IllegalArgumentException if the listener parameter is null
+     */
+    public void addAttributeChangeNotificationListener
+        (NotificationListener listener, String name, Object handback)
+        throws IllegalArgumentException {
+
+        if (listener == null)
+            throw new IllegalArgumentException("Listener is null");
+        if (attributeBroadcaster == null)
+            attributeBroadcaster = new BaseNotificationBroadcaster();
+
+        if( log.isDebugEnabled() )
+            log.debug("addAttributeNotificationListener " + listener);
+
+        BaseAttributeFilter filter = new BaseAttributeFilter(name);
+        attributeBroadcaster.addNotificationListener
+            (listener, filter, handback);
+
+    }
+
+
+    /**
+     * Remove an attribute change notification event listener from
+     * this MBean.
+     *
+     * @param listener The listener to be removed
+     * @param name The attribute name for which no more events are required
+     *
+     *
+     * @exception ListenerNotFoundException if this listener is not
+     *  registered in the MBean
+     */
+    public void removeAttributeChangeNotificationListener
+        (NotificationListener listener, String name)
+        throws ListenerNotFoundException {
+
+        if (listener == null)
+            throw new IllegalArgumentException("Listener is null");
+        if (attributeBroadcaster == null)
+            attributeBroadcaster = new BaseNotificationBroadcaster();
+
+        // FIXME - currently this removes *all* notifications for this listener
+        attributeBroadcaster.removeNotificationListener(listener);
+
+    }
+
+
+    /**
+     * Remove an attribute change notification event listener from
+     * this MBean.
+     *
+     * @param listener The listener to be removed
+     * @param attributeName The attribute name for which no more events are required
+     * @param handback Handback object to be sent along with event
+     *  notifications
+     *
+     *
+     * @exception ListenerNotFoundException if this listener is not
+     *  registered in the MBean
+     */
+    public void removeAttributeChangeNotificationListener
+        (NotificationListener listener, String attributeName, Object handback)
+        throws ListenerNotFoundException {
+
+        removeAttributeChangeNotificationListener(listener, attributeName);
+
+    }
+
+
+    /**
+     * Send an <code>AttributeChangeNotification</code> to all registered
+     * listeners.
+     *
+     * @param notification The <code>AttributeChangeNotification</code>
+     *  that will be passed
+     *
+     * @exception MBeanException if an object initializer throws an
+     *  exception
+     * @exception RuntimeOperationsException wraps IllegalArgumentException
+     *  when the specified notification is <code>null</code> or invalid
+     */
+    public void sendAttributeChangeNotification
+        (AttributeChangeNotification notification)
+        throws MBeanException, RuntimeOperationsException {
+
+        if (notification == null)
+            throw new RuntimeOperationsException
+                (new IllegalArgumentException("Notification is null"),
+                 "Notification is null");
+        if (attributeBroadcaster == null)
+            return; // This means there are no registered listeners
+        if( log.isDebugEnabled() )
+            log.debug( "AttributeChangeNotification " + notification );
+        attributeBroadcaster.sendNotification(notification);
+
+    }
+
+
+    /**
+     * Send an <code>AttributeChangeNotification</code> to all registered
+     * listeners.
+     *
+     * @param oldValue The original value of the <code>Attribute</code>
+     * @param newValue The new value of the <code>Attribute</code>
+     *
+     * @exception MBeanException if an object initializer throws an
+     *  exception
+     * @exception RuntimeOperationsException wraps IllegalArgumentException
+     *  when the specified notification is <code>null</code> or invalid
+     */
+    public void sendAttributeChangeNotification
+        (Attribute oldValue, Attribute newValue)
+        throws MBeanException, RuntimeOperationsException {
+
+        // Calculate the class name for the change notification
+        String type = null;
+        if (newValue.getValue() != null)
+            type = newValue.getValue().getClass().getName();
+        else if (oldValue.getValue() != null)
+            type = oldValue.getValue().getClass().getName();
+        else
+            return;  // Old and new are both null == no change
+
+        AttributeChangeNotification notification =
+            new AttributeChangeNotification
+            (this, 1, System.currentTimeMillis(),
+             "Attribute value has changed",
+             oldValue.getName(), type,
+             oldValue.getValue(), newValue.getValue());
+        sendAttributeChangeNotification(notification);
+
+    }
+
+
+
+
+    /**
+     * Send a <code>Notification</code> to all registered listeners as a
+     * <code>jmx.modelmbean.general</code> notification.
+     *
+     * @param notification The <code>Notification</code> that will be passed
+     *
+     * @exception MBeanException if an object initializer throws an
+     *  exception
+     * @exception RuntimeOperationsException wraps IllegalArgumentException
+     *  when the specified notification is <code>null</code> or invalid
+     */
+    public void sendNotification(Notification notification)
+        throws MBeanException, RuntimeOperationsException {
+
+        if (notification == null)
+            throw new RuntimeOperationsException
+                (new IllegalArgumentException("Notification is null"),
+                 "Notification is null");
+        if (generalBroadcaster == null)
+            return; // This means there are no registered listeners
+        generalBroadcaster.sendNotification(notification);
+
+    }
+
+
+    /**
+     * Send a <code>Notification</code> which contains the specified string
+     * as a <code>jmx.modelmbean.generic</code> notification.
+     *
+     * @param message The message string to be passed
+     *
+     * @exception MBeanException if an object initializer throws an
+     *  exception
+     * @exception RuntimeOperationsException wraps IllegalArgumentException
+     *  when the specified notification is <code>null</code> or invalid
+     */
+    public void sendNotification(String message)
+        throws MBeanException, RuntimeOperationsException {
+
+        if (message == null)
+            throw new RuntimeOperationsException
+                (new IllegalArgumentException("Message is null"),
+                 "Message is null");
+        Notification notification = new Notification
+            ("jmx.modelmbean.generic", this, 1, message);
+        sendNotification(notification);
+
+    }
+
+
+
+
+    // ---------------------------------------- NotificationBroadcaster Methods
+
+
+    /**
+     * Add a notification event listener to this MBean.
+     *
+     * @param listener Listener that will receive event notifications
+     * @param filter Filter object used to filter event notifications
+     *  actually delivered, or <code>null</code> for no filtering
+     * @param handback Handback object to be sent along with event
+     *  notifications
+     *
+     * @exception IllegalArgumentException if the listener parameter is null
+     */
+    public void addNotificationListener(NotificationListener listener,
+                                        NotificationFilter filter,
+                                        Object handback)
+        throws IllegalArgumentException {
+
+        if (listener == null)
+            throw new IllegalArgumentException("Listener is null");
+
+        if( log.isDebugEnabled() ) log.debug("addNotificationListener " + listener);
+
+        if (generalBroadcaster == null)
+            generalBroadcaster = new BaseNotificationBroadcaster();
+        generalBroadcaster.addNotificationListener
+            (listener, filter, handback);
+
+        // We'll send the attribute change notifications to all listeners ( who care )
+        // The normal filtering can be used.
+        // The problem is that there is no other way to add attribute change listeners
+        // to a model mbean ( AFAIK ). I suppose the spec should be fixed.
+        if (attributeBroadcaster == null)
+            attributeBroadcaster = new BaseNotificationBroadcaster();
+
+        if( log.isDebugEnabled() )
+            log.debug("addAttributeNotificationListener " + listener);
+
+        attributeBroadcaster.addNotificationListener
+                (listener, filter, handback);
+    }
+
+
+    /**
+     * Return an <code>MBeanNotificationInfo</code> object describing the
+     * notifications sent by this MBean.
+     */
+    public MBeanNotificationInfo[] getNotificationInfo() {
+
+        // Acquire the set of application notifications
+        MBeanNotificationInfo current[] = info.getNotifications();
+        if (current == null)
+            current = new MBeanNotificationInfo[0];
+        MBeanNotificationInfo response[] =
+            new MBeanNotificationInfo[current.length + 2];
+        Descriptor descriptor = null;
+
+        // Fill in entry for general notifications
+        descriptor = new DescriptorSupport
+            (new String[] { "name=GENERIC",
+                            "descriptorType=notification",
+                            "log=T",
+                            "severity=5",
+                            "displayName=jmx.modelmbean.generic" });
+        response[0] = new ModelMBeanNotificationInfo
+            (new String[] { "jmx.modelmbean.generic" },
+             "GENERIC",
+             "Text message notification from the managed resource",
+             descriptor);
+
+        // Fill in entry for attribute change notifications
+        descriptor = new DescriptorSupport
+            (new String[] { "name=ATTRIBUTE_CHANGE",
+                            "descriptorType=notification",
+                            "log=T",
+                            "severity=5",
+                            "displayName=jmx.attribute.change" });
+        response[1] = new ModelMBeanNotificationInfo
+            (new String[] { "jmx.attribute.change" },
+             "ATTRIBUTE_CHANGE",
+             "Observed MBean attribute value has changed",
+             descriptor);
+
+        // Copy remaining notifications as reported by the application
+        System.arraycopy(current, 0, response, 2, current.length);
+        return (response);
+
+    }
+
+
+    /**
+     * Remove a notification event listener from this MBean.
+     *
+     * @param listener The listener to be removed (any and all registrations
+     *  for this listener will be eliminated)
+     *
+     * @exception ListenerNotFoundException if this listener is not
+     *  registered in the MBean
+     */
+    public void removeNotificationListener(NotificationListener listener)
+        throws ListenerNotFoundException {
+
+        if (listener == null)
+            throw new IllegalArgumentException("Listener is null");
+        if (generalBroadcaster == null)
+            generalBroadcaster = new BaseNotificationBroadcaster();
+        generalBroadcaster.removeNotificationListener(listener);
+
+
+    }
+
+
+    /**
+     * Remove a notification event listener from this MBean.
+     *
+     * @param listener The listener to be removed (any and all registrations
+     *  for this listener will be eliminated)
+     * @param handback Handback object to be sent along with event
+     *  notifications
+     *
+     * @exception ListenerNotFoundException if this listener is not
+     *  registered in the MBean
+     */
+    public void removeNotificationListener(NotificationListener listener,
+                                           Object handback)
+        throws ListenerNotFoundException {
+
+        removeNotificationListener(listener);
+
+    }
+
+
+    /**
+     * Remove a notification event listener from this MBean.
+     *
+     * @param listener The listener to be removed (any and all registrations
+     *  for this listener will be eliminated)
+     * @param filter Filter object used to filter event notifications
+     *  actually delivered, or <code>null</code> for no filtering
+     * @param handback Handback object to be sent along with event
+     *  notifications
+     *
+     * @exception ListenerNotFoundException if this listener is not
+     *  registered in the MBean
+     */
+    public void removeNotificationListener(NotificationListener listener,
+                                           NotificationFilter filter,
+                                           Object handback)
+        throws ListenerNotFoundException {
+
+        removeNotificationListener(listener);
+
+    }
+
+
+    // ------------------------------------------------ PersistentMBean Methods
+
+
+    /**
+     * Instantiates this MBean instance from data found in the persistent
+     * store.  The data loaded could include attribute and operation values.
+     * This method should be called during construction or initialization
+     * of the instance, and before the MBean is registered with the
+     * <code>MBeanServer</code>.
+     *
+     * <p><strong>IMPLEMENTATION NOTE</strong> - This implementation does
+     * not support persistence.</p>
+     *
+     * @exception InstanceNotFoundException if the managed resource object
+     *  cannot be found
+     * @exception MBeanException if the initializer of the object throws
+     *  an exception
+     * @exception RuntimeOperationsException if an exception is reported
+     *  by the persistence mechanism
+     */
+    public void load() throws InstanceNotFoundException,
+        MBeanException, RuntimeOperationsException {
+        // XXX If a context was set, use it to load the data
+        throw new MBeanException
+            (new IllegalStateException("Persistence is not supported"),
+             "Persistence is not supported");
+
+    }
+
+
+    /**
+     * Capture the current state of this MBean instance and write it out
+     * to the persistent store.  The state stored could include attribute
+     * and operation values.  If one of these methods of persistence is not
+     * supported, a "service not found" exception will be thrown.
+     *
+     * <p><strong>IMPLEMENTATION NOTE</strong> - This implementation does
+     * not support persistence.</p>
+     *
+     * @exception InstanceNotFoundException if the managed resource object
+     *  cannot be found
+     * @exception MBeanException if the initializer of the object throws
+     *  an exception, or persistence is not supported
+     * @exception RuntimeOperationsException if an exception is reported
+     *  by the persistence mechanism
+     */
+    public void store() throws InstanceNotFoundException,
+        MBeanException, RuntimeOperationsException {
+
+        // XXX if a context was set, use it to store the data
+        throw new MBeanException
+            (new IllegalStateException("Persistence is not supported"),
+             "Persistence is not supported");
+
+    }
+
+    // --------------------  BaseModelMBean methods --------------------
+
+    /** Set the type of the mbean. This is used as a key to locate
+     * the description in the Registry.
+     *
+     * @param type the type of classname of the modeled object
+     */
+    public void setModeledType( String type ) {
+        initModelInfo(type);
+        createResource();
+    }
+    /** Set the type of the mbean. This is used as a key to locate
+     * the description in the Registry.
+     *
+     * @param type the type of classname of the modeled object
+     */
+    protected void initModelInfo( String type ) {
+        try {
+            if( log.isDebugEnabled())
+                log.debug("setModeledType " + type);
+
+            log.debug( "Set model Info " + type);
+            if(type==null) {
+                return;
+            }
+            resourceType=type;
+            //Thread.currentThread().setContextClassLoader(BaseModelMBean.class.getClassLoader());
+            Class c=null;
+            try {
+                c=Class.forName( type);
+            } catch( Throwable t ) {
+                log.debug( "Error creating class " + t);
+            }
+
+            // The class c doesn't need to exist
+            ManagedBean descriptor=getRegistry().findManagedBean(c, type);
+            if( descriptor==null ) 
+                return;
+            this.setModelMBeanInfo(descriptor.createMBeanInfo());
+        } catch( Throwable ex) {
+            log.error( "TCL: " + Thread.currentThread().getContextClassLoader(),
+                    ex);
+        }
+    }
+
+    /** Set the type of the mbean. This is used as a key to locate
+     * the description in the Registry.
+     */
+    protected void createResource() {
+        try {
+            //Thread.currentThread().setContextClassLoader(BaseModelMBean.class.getClassLoader());
+            Class c=null;
+            try {
+                c=Class.forName( resourceType );
+                resource = c.newInstance();
+            } catch( Throwable t ) {
+                log.error( "Error creating class " + t);
+            }
+        } catch( Throwable ex) {
+            log.error( "TCL: " + Thread.currentThread().getContextClassLoader(),
+                    ex);
+        }
+    }
+
+
+    public String getModelerType() {
+        return resourceType;
+    }
+
+    public String getClassName() {
+        return getModelerType();
+    }
+
+    public ObjectName getJmxName() {
+        return oname;
+    }
+
+    public String getObjectName() {
+        if (oname != null) {
+            return oname.toString();
+        } else {
+            return null;
+        }
+    }
+
+    public void setRegistry(Registry registry) {
+        this.registry = registry;
+    }
+
+    public Registry getRegistry() {
+        // XXX Need a better solution - to avoid the static
+        if( registry == null )
+            registry=Registry.getRegistry();
+
+        return registry;
+    }
+
+    // ------------------------------------------------------ Protected Methods
+
+
+    /**
+     * Create and return a default <code>ModelMBeanInfo</code> object.
+     */
+    protected ModelMBeanInfo createDefaultModelMBeanInfo() {
+
+        return (new ModelMBeanInfoSupport(this.getClass().getName(),
+                                          "Default ModelMBean",
+                                          null, null, null, null));
+
+    }
+
+    /**
+     * Is the specified <code>ModelMBeanInfo</code> instance valid?
+     *
+     * <p><strong>IMPLEMENTATION NOTE</strong> - This implementation
+     * does not check anything, but this method can be overridden
+     * as required.</p>
+     *
+     * @param info The <code>ModelMBeanInfo object to check
+     */
+    protected boolean isModelMBeanInfoValid(ModelMBeanInfo info) {
+        return (true);
+    }
+
+    // -------------------- Registration  --------------------
+    // XXX We can add some method patterns here- like setName() and
+    // setDomain() for code that doesn't implement the Registration
+
+    public ObjectName preRegister(MBeanServer server,
+                                  ObjectName name)
+            throws Exception
+    {
+        if( log.isDebugEnabled())
+            log.debug("preRegister " + resource + " " + name );
+        oname=name;
+        if( resource instanceof MBeanRegistration ) {
+            oname = ((MBeanRegistration)resource).preRegister(server, name );
+        }
+        return oname;
+    }
+
+    public void postRegister(Boolean registrationDone) {
+        if( resource instanceof MBeanRegistration ) {
+            ((MBeanRegistration)resource).postRegister(registrationDone);
+        }
+    }
+
+    public void preDeregister() throws Exception {
+        if( resource instanceof MBeanRegistration ) {
+            ((MBeanRegistration)resource).preDeregister();
+        }
+    }
+
+    public void postDeregister() {
+        if( resource instanceof MBeanRegistration ) {
+            ((MBeanRegistration)resource).postDeregister();
+        }
+    }
+
+    static class MethodKey {
+	private String name;
+	private String[] signature;
+
+	MethodKey(String name, String[] signature) {
+	    this.name = name;
+	    if(signature == null) {
+		signature = new String[0];
+	    }
+	    this.signature = signature;
+	}
+
+	public boolean equals(Object other) {
+	    if(!(other instanceof MethodKey)) {
+		return false;
+	    }
+	    MethodKey omk = (MethodKey)other;
+	    if(!name.equals(omk.name)) {
+		return false;
+	    }
+	    if(signature.length != omk.signature.length) {
+		return false;
+	    }
+	    for(int i=0; i < signature.length; i++) {
+		if(!signature[i].equals(omk.signature[i])) {
+		    return false;
+		}
+	    }
+	    return true;
+	}
+
+	public int hashCode() {
+	    return name.hashCode();
+	}
+    }
+}

==================================================
BaseNotificationBroadcaster.java
new file mode 100644
index 0000000000..d6a5e27154
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/BaseNotification.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright 1999,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */ 
+package org.apache.tomcat.util.modeler;
+
+import javax.management.Notification;
+
+
+/**
+ * Base JMX Notification. Supports in int code and notes - for faster 
+ * access and dispatching. 
+ *
+ * @author Costin Manolache
+ */
+public final class BaseNotification extends Notification {
+
+    // ----------------------------------------------------------- Constructors
+    private int code;
+    private String type;
+    private Object source;
+    private long seq;
+    private long tstamp;
+
+    /**
+     * Private constructor.
+     */
+    private BaseNotification(String type,
+                             Object source,
+                             long seq,
+                             long tstamp,
+                             int code) {
+        super(type, source, seq, tstamp);
+        init( type, source, seq, tstamp, code );
+        this.code=code;
+    }
+
+    public void recycle() {
+
+    }
+
+    public void init( String type, Object source,
+                      long seq, long tstamp, int code )
+    {
+        this.type=type;
+        this.source = source;
+        this.seq=seq;
+        this.tstamp=tstamp;
+        this.code = code;
+    }
+
+    // -------------------- Override base methods  --------------------
+    // All base methods need to be overriden - in order to support recycling.
+
+
+    // -------------------- Information associated with the notification  ----
+    // Like events ( which Notification extends ), notifications may store
+    // informations related with the event that trigered it. Source and type is
+    // one piece, but it is common to store more info.
+
+    /** Action id, useable in switches and table indexes
+     */
+    public int getCode() {
+        return code;
+    }
+
+    // XXX Make it customizable - or grow it
+    private Object notes[]=new Object[32];
+
+    public final Object getNote(int i ) {
+        return notes[i];
+    }
+
+    public final void setNote(int i, Object o ) {
+        notes[i]=o;
+    }
+}

==================================================
ConstructorInfo.java
new file mode 100644
index 0000000000..197b9e69a6
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/BaseNotificationBroadcaster.java
@@ -0,0 +1,264 @@
+/*
+ * Copyright 1999,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler;
+
+
+import java.util.ArrayList;
+import java.util.Iterator;
+
+import javax.management.ListenerNotFoundException;
+import javax.management.MBeanNotificationInfo;
+import javax.management.Notification;
+import javax.management.NotificationBroadcaster;
+import javax.management.NotificationFilter;
+import javax.management.NotificationListener;
+
+
+/**
+ * <p>Implementation of <code>NotificationBroadcaster</code> for attribute
+ * change notifications.  This class is used by <code>BaseModelMBean</code> to
+ * handle notifications of attribute change events to interested listeners.
+ *</p>
+ *
+ * @author Craig R. McClanahan
+ * @author Costin Manolache
+ */
+
+public class BaseNotificationBroadcaster implements NotificationBroadcaster {
+
+
+    // ----------------------------------------------------------- Constructors
+
+
+    // ----------------------------------------------------- Instance Variables
+
+
+    /**
+     * The set of registered <code>BaseNotificationBroadcasterEntry</code>
+     * entries.
+     */
+    protected ArrayList entries = new ArrayList();
+
+
+    // --------------------------------------------------------- Public Methods
+
+
+    /**
+     * Add a notification event listener to this MBean.
+     *
+     * @param listener Listener that will receive event notifications
+     * @param filter Filter object used to filter event notifications
+     *  actually delivered, or <code>null</code> for no filtering
+     * @param handback Handback object to be sent along with event
+     *  notifications
+     *
+     * @exception IllegalArgumentException if the listener parameter is null
+     */
+    public void addNotificationListener(NotificationListener listener,
+                                        NotificationFilter filter,
+                                        Object handback)
+        throws IllegalArgumentException {
+
+        synchronized (entries) {
+
+            // Optimization to coalesce attribute name filters
+            if (filter instanceof BaseAttributeFilter) {
+                BaseAttributeFilter newFilter = (BaseAttributeFilter) filter;
+                Iterator items = entries.iterator();
+                while (items.hasNext()) {
+                    BaseNotificationBroadcasterEntry item =
+                        (BaseNotificationBroadcasterEntry) items.next();
+                    if ((item.listener == listener) &&
+                        (item.filter != null) &&
+                        (item.filter instanceof BaseAttributeFilter) &&
+                        (item.handback == handback)) {
+                        BaseAttributeFilter oldFilter =
+                            (BaseAttributeFilter) item.filter;
+                        String newNames[] = newFilter.getNames();
+                        String oldNames[] = oldFilter.getNames();
+                        if (newNames.length == 0) {
+                            oldFilter.clear();
+                        } else {
+                            if (oldNames.length != 0) {
+                                for (int i = 0; i < newNames.length; i++)
+                                    oldFilter.addAttribute(newNames[i]);
+                            }
+                        }
+                        return;
+                    }
+                }
+            }
+
+            // General purpose addition of a new entry
+            entries.add(new BaseNotificationBroadcasterEntry
+                        (listener, filter, handback));
+        }
+
+    }
+
+
+    /**
+     * Return an <code>MBeanNotificationInfo</code> object describing the
+     * notifications sent by this MBean.
+     */
+    public MBeanNotificationInfo[] getNotificationInfo() {
+
+        return (new MBeanNotificationInfo[0]);
+
+    }
+
+
+    /**
+     * Remove a notification event listener from this MBean.
+     *
+     * @param listener The listener to be removed (any and all registrations
+     *  for this listener will be eliminated)
+     *
+     * @exception ListenerNotFoundException if this listener is not
+     *  registered in the MBean
+     */
+    public void removeNotificationListener(NotificationListener listener)
+        throws ListenerNotFoundException {
+
+        synchronized (entries) {
+            Iterator items = entries.iterator();
+            while (items.hasNext()) {
+                BaseNotificationBroadcasterEntry item =
+                    (BaseNotificationBroadcasterEntry) items.next();
+                if (item.listener == listener)
+                    items.remove();
+            }
+        }
+
+    }
+
+
+    /**
+     * Remove a notification event listener from this MBean.
+     *
+     * @param listener The listener to be removed (any and all registrations
+     *  for this listener will be eliminated)
+     * @param handback Handback object to be sent along with event
+     *  notifications
+     *
+     * @exception ListenerNotFoundException if this listener is not
+     *  registered in the MBean
+     */
+    public void removeNotificationListener(NotificationListener listener,
+                                           Object handback)
+        throws ListenerNotFoundException {
+
+        removeNotificationListener(listener);
+
+    }
+
+
+    /**
+     * Remove a notification event listener from this MBean.
+     *
+     * @param listener The listener to be removed (any and all registrations
+     *  for this listener will be eliminated)
+     * @param filter Filter object used to filter event notifications
+     *  actually delivered, or <code>null</code> for no filtering
+     * @param handback Handback object to be sent along with event
+     *  notifications
+     *
+     * @exception ListenerNotFoundException if this listener is not
+     *  registered in the MBean
+     */
+    public void removeNotificationListener(NotificationListener listener,
+                                           NotificationFilter filter,
+                                           Object handback)
+        throws ListenerNotFoundException {
+
+        removeNotificationListener(listener);
+
+    }
+
+
+    /**
+     * Send the specified notification to all interested listeners.
+     *
+     * @param notification The notification to be sent
+     */
+    public void sendNotification(Notification notification) {
+
+        synchronized (entries) {
+            Iterator items = entries.iterator();
+            while (items.hasNext()) {
+                BaseNotificationBroadcasterEntry item =
+                    (BaseNotificationBroadcasterEntry) items.next();
+                if ((item.filter != null) &&
+                    (!item.filter.isNotificationEnabled(notification)))
+                    continue;
+                item.listener.handleNotification(notification, item.handback);
+            }
+        }
+
+    }
+
+
+    // -------------------- Internal Extensions   --------------------
+
+    // Fast access. First index is the hook type
+    // ( FixedNotificationFilter.getType() ).
+    NotificationListener hooks[][]=new NotificationListener[20][];
+    int hookCount[]=new int[20];
+
+    private synchronized void registerNotifications( FixedNotificationFilter filter ) {
+        String names[]=filter.getNames();
+        Registry reg=Registry.getRegistry();
+        for( int i=0; i<names.length; i++ ) {
+            int code=reg.getId(null, names[i]);
+            if( hooks.length < code ) {
+                // XXX reallocate
+                throw new RuntimeException( "Too many hooks " + code );
+            }
+            NotificationListener listeners[]=hooks[code];
+            if( listeners== null ) {
+
+            }
+
+
+        }
+    }
+
+}
+
+
+/**
+ * Utility class representing a particular registered listener entry.
+ */
+
+class BaseNotificationBroadcasterEntry {
+
+    public BaseNotificationBroadcasterEntry(NotificationListener listener,
+                                            NotificationFilter filter,
+                                            Object handback) {
+        this.listener = listener;
+        this.filter = filter;
+        this.handback = handback;
+    }
+
+    public NotificationFilter filter = null;
+
+    public Object handback = null;
+
+    public NotificationListener listener = null;
+
+}

==================================================
FeatureInfo.java
new file mode 100644
index 0000000000..13d0104a12
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/ConstructorInfo.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler;
+
+
+import java.io.Serializable;
+
+import javax.management.Descriptor;
+import javax.management.MBeanParameterInfo;
+import javax.management.modelmbean.ModelMBeanConstructorInfo;
+
+
+/**
+ * <p>Internal configuration information for a <code>Constructor</code>
+ * descriptor.</p>
+ *
+ * @author Craig R. McClanahan
+ * @version $Revision: 155428 $ $Date: 2005-02-26 14:12:25 +0100 (sam., 26 févr. 2005) $
+ */
+
+public class ConstructorInfo extends FeatureInfo implements Serializable {
+    static final long serialVersionUID = -5735336213417238238L;
+
+    // ----------------------------------------------------- Instance Variables
+
+
+    /**
+     * The <code>ModelMBeanConstructorInfo</code> object that corresponds
+     * to this <code>ConstructorInfo</code> instance.
+     */
+    transient ModelMBeanConstructorInfo info = null;
+    protected String displayName = null;
+    protected ParameterInfo parameters[] = new ParameterInfo[0];
+
+
+    // ------------------------------------------------------------- Properties
+
+
+    /**
+     * Override the <code>description</code> property setter.
+     *
+     * @param description The new description
+     */
+    public void setDescription(String description) {
+        super.setDescription(description);
+        this.info = null;
+    }
+
+
+    /**
+     * Override the <code>name</code> property setter.
+     *
+     * @param name The new name
+     */
+    public void setName(String name) {
+        super.setName(name);
+        this.info = null;
+    }
+
+
+    /**
+     * The display name of this attribute.
+     */
+    public String getDisplayName() {
+        return (this.displayName);
+    }
+
+    public void setDisplayName(String displayName) {
+        this.displayName = displayName;
+    }
+
+
+    /**
+     * The set of parameters for this constructor.
+     */
+    public ParameterInfo[] getSignature() {
+        return (this.parameters);
+    }
+
+
+    // --------------------------------------------------------- Public Methods
+
+
+    /**
+     * Add a new parameter to the set of parameters for this constructor.
+     *
+     * @param parameter The new parameter descriptor
+     */
+    public void addParameter(ParameterInfo parameter) {
+
+        synchronized (parameters) {
+            ParameterInfo results[] = new ParameterInfo[parameters.length + 1];
+            System.arraycopy(parameters, 0, results, 0, parameters.length);
+            results[parameters.length] = parameter;
+            parameters = results;
+            this.info = null;
+        }
+
+    }
+
+
+    /**
+     * Create and return a <code>ModelMBeanConstructorInfo</code> object that
+     * corresponds to the attribute described by this instance.
+     */
+    public ModelMBeanConstructorInfo createConstructorInfo() {
+
+        // Return our cached information (if any)
+        if (info != null)
+            return (info);
+
+        // Create and return a new information object
+        ParameterInfo params[] = getSignature();
+        MBeanParameterInfo parameters[] =
+            new MBeanParameterInfo[params.length];
+        for (int i = 0; i < params.length; i++)
+            parameters[i] = params[i].createParameterInfo();
+        info = new ModelMBeanConstructorInfo
+            (getName(), getDescription(), parameters);
+        Descriptor descriptor = info.getDescriptor();
+        descriptor.removeField("class");
+        if (getDisplayName() != null)
+            descriptor.setField("displayName", getDisplayName());
+        addFields(descriptor);
+        info.setDescriptor(descriptor);
+        return (info);
+
+    }
+
+
+    /**
+     * Return a string representation of this constructor descriptor.
+     */
+    public String toString() {
+
+        StringBuffer sb = new StringBuffer("ConstructorInfo[");
+        sb.append("name=");
+        sb.append(name);
+        sb.append(", description=");
+        sb.append(description);
+        sb.append(", parameters=");
+        sb.append(parameters.length);
+        sb.append("]");
+        return (sb.toString());
+
+    }
+
+
+}

==================================================
FieldInfo.java
new file mode 100644
index 0000000000..c23d96c7d9
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/FeatureInfo.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler;
+
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import javax.management.Descriptor;
+
+
+/**
+ * <p>Convenience base class for <code>AttributeInfo</code>,
+ * <code>ConstructorInfo</code>, and <code>OperationInfo</code> classes
+ * that will be used to collect configuration information for the
+ * <code>ModelMBean</code> beans exposed for management.</p>
+ *
+ * @author Craig R. McClanahan
+ * @version $Revision: 155428 $ $Date: 2005-02-26 14:12:25 +0100 (sam., 26 févr. 2005) $
+ */
+
+public class FeatureInfo implements Serializable {
+    static final long serialVersionUID = -911529176124712296L;
+    protected String description = null;
+    protected List fields = new ArrayList();
+    protected String name = null;
+
+    // ------------------------------------------------------------- Properties
+
+
+    /**
+     * The human-readable description of this feature.
+     */
+    public String getDescription() {
+        return (this.description);
+    }
+
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
+
+    /**
+     * The field information for this feature.
+     */
+    public List getFields() {
+        return (fields);
+    }
+
+
+    /**
+     * The name of this feature, which must be unique among features in the
+     * same collection.
+     */
+    public String getName() {
+        return (this.name);
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+
+    // --------------------------------------------------------- Public Methods
+
+
+    /**
+     * <p>Add a new field to the fields associated with the
+     * Descriptor that will be created from this metadata.</p>
+     *
+     * @param field The field to be added
+     */
+    public void addField(FieldInfo field) {
+        fields.add(field);
+    }
+
+
+    // ------------------------------------------------------ Protected Methods
+
+
+    /**
+     * <p>Add the name/value fields that have been stored into the
+     * specified <code>Descriptor</code> instance.</p>
+     *
+     * @param descriptor The <code>Descriptor</code> to add fields to
+     */
+    protected void addFields(Descriptor descriptor) {
+
+        Iterator items = getFields().iterator();
+        while (items.hasNext()) {
+            FieldInfo item = (FieldInfo) items.next();
+            descriptor.setField(item.getName(), item.getValue());
+        }
+
+    }
+
+
+}

==================================================
FixedNotificationFilter.java
new file mode 100644
index 0000000000..ddc6a3c825
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/FieldInfo.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler;
+
+
+import java.io.Serializable;
+
+
+/**
+ * <p>Simple JavaBean representing the contents of a <code>&lt;field&gt;</code>
+ * element in an MBeans descriptor file.
+ */
+
+public class FieldInfo implements Serializable {
+    static final long serialVersionUID = -8226401620640873691L;
+
+    /**
+     * <p>The field name for this field of a descriptor.</p>
+     */
+    protected String name = null;
+
+    public String getName() {
+        return (this.name);
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+
+    /**
+     * <p>The field value for this field of a descriptor.</p>
+     */
+    protected Object value = null;
+
+    public Object getValue() {
+        return (this.value);
+    }
+
+    public void setValue(Object value) {
+        this.value = value;
+    }
+
+
+}

==================================================
JndiJmx.java
new file mode 100644
index 0000000000..6fb1836c4a
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/FixedNotificationFilter.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright 1999,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler;
+
+
+import java.util.HashSet;
+
+import javax.management.Notification;
+import javax.management.NotificationFilter;
+
+
+/**
+ * Special NotificationFilter that allows modeler to optimize its notifications.
+ *
+ * This class is immutable - after you construct it it'll filter based on
+ * a fixed set of notification names.
+ *
+ * The JMX specification requires the filters to be called before the
+ * notifications are sent. We can call this filter well in advance, when
+ * the listener is added. Based on the result we can maintain separate
+ * channels for each notification - and reduce the overhead.
+ *
+ * @author Costin Manolache
+ */
+public class FixedNotificationFilter implements NotificationFilter {
+
+    /**
+     * The set of attribute names that are accepted by this filter.  If this
+     * list is empty, all attribute names are accepted.
+     */
+    private HashSet names = new HashSet();
+    String namesA[]=null;
+
+    /**
+     * Construct a new filter that accepts only the specified notification
+     * names.
+     *
+     * @param names Names of the notification types
+     */
+    public FixedNotificationFilter(String names[]) {
+        super();
+    }
+
+    /**
+     * Return the set of names that are accepted by this filter.  If this
+     * filter accepts all attribute names, a zero length array will be
+     * returned.
+     */
+    public String[] getNames() {
+        synchronized (names) {
+            return ((String[]) names.toArray(new String[names.size()]));
+        }
+    }
+
+
+    /**
+     * <p>Test whether notification enabled for this event.
+     * Return true if:</p>
+     * <ul>
+     * <li>Either the set of accepted names is empty (implying that all
+     *     attribute names are of interest) or the set of accepted names
+     *     includes the name of the attribute in this notification</li>
+     * </ul>
+     */
+    public boolean isNotificationEnabled(Notification notification) {
+
+        if (notification == null)
+            return (false);
+        synchronized (names) {
+            if (names.size() < 1)
+                return (true);
+            else
+                return (names.contains(notification.getType()));
+        }
+
+    }
+
+
+}

==================================================
ManagedBean.java
new file mode 100644
index 0000000000..988b5e14d7
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/JndiJmx.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright 2001-2002,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler;
+
+
+import java.util.Enumeration;
+import java.util.Hashtable;
+
+import javax.management.AttributeChangeNotification;
+import javax.management.InstanceNotFoundException;
+import javax.management.MBeanException;
+import javax.management.MBeanServer;
+import javax.management.MBeanServerNotification;
+import javax.management.Notification;
+import javax.management.NotificationBroadcaster;
+import javax.management.NotificationListener;
+import javax.management.ObjectName;
+import javax.naming.Context;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+// EXPERIMENTAL. It may fit better in tomcat jndi impl.
+
+
+/**
+ *
+ * Link between JNDI and JMX. JNDI can be used for persistence ( it is
+ * an API for storing hierarchical data and a perfect fit for that ), as
+ * well as an alternate view of the MBean registry.
+ *
+ * If this component is enabled, all MBeans will be registered in JNDI, and
+ * all attributes that are set via JMX can be stored in a DirContext.
+ *
+ * This acts as a "recorder" for creation of mbeans and attribute changes
+ * done via JMX.
+ *
+ * XXX How can we control ( filter ) which mbeans will be registere ? Or
+ * attributes ?
+ * XXX How can we get the beans and attributes loaded before jndijmx ?
+ *
+ * The intended use:
+ * - do whatever you want to start the application
+ * - load JndiJmx as an mbean
+ * - make changes via JMX. All changes are recorded
+ * - you can use JndiJmx to save the changes in a Jndi context.
+ * - you can use JndiJmx to load changes from a JndiContext and replay them.
+ *
+ * The main benefit is that only changed attributes are saved, and the Jndi
+ * layer can preserve most of the original structure of the config file. The
+ * alternative is to override the config files with config info extracted
+ * from the live objects - but it's very hard to save only what was actually
+ * changed and preserve structure and comments.
+ *
+ * @author Costin Manolache
+ */
+public class JndiJmx extends BaseModelMBean implements NotificationListener {
+
+
+    private static Log log= LogFactory.getLog(JndiJmx.class);
+
+    protected Context componentContext;
+    protected Context descriptorContext;
+    protected Context configContext;
+
+    MBeanServer mserver;
+
+    /**
+     * Protected constructor to require use of the factory create method.
+     */
+    public JndiJmx() throws MBeanException {
+        super(JndiJmx.class.getName());
+    }
+
+
+    /** If a JNDI context is set, all components
+     * will be registered in the context.
+     *
+     * @param ctx
+     */
+    public void setComponentContext(Context ctx) {
+        this.componentContext= ctx;
+    }
+
+    /** JNDI context for component descriptors ( metadata ).
+     *
+     * @param ctx
+     */
+    public void setDescriptorContext(Context ctx) {
+        this.descriptorContext= ctx;
+    }
+
+    /** JNDI context where attributes will be stored for persistence
+     *
+     */
+    public void setConfigContext( Context ctx ) {
+        this.configContext= ctx;
+    }
+
+    // --------------------  Registration/unregistration --------------------
+    // temp - will only set in the jndi contexts
+    Hashtable attributes=new Hashtable();
+    Hashtable instances=new Hashtable();
+
+    public void handleNotification(Notification notification, Object handback)
+    {
+        // register/unregister mbeans in jndi
+        if( notification instanceof MBeanServerNotification ) {
+            MBeanServerNotification msnot=(MBeanServerNotification)notification;
+
+            ObjectName oname=msnot.getMBeanName();
+
+            if( "jmx.mbean.created".equalsIgnoreCase( notification.getType() )) {
+                try {
+                    Object mbean=mserver.getObjectInstance(oname);
+
+                    if( log.isDebugEnabled() )
+                        log.debug( "MBean created " + oname + " " + mbean);
+
+                    // XXX add filter support
+                    if( mbean instanceof NotificationBroadcaster ) {
+                        // register for attribute changes
+                        NotificationBroadcaster nb=(NotificationBroadcaster)mbean;
+                        nb.addNotificationListener(this, null, null);
+                        if( log.isDebugEnabled() )
+                            log.debug( "Add attribute change listener");
+                    }
+
+                    instances.put( oname.toString(), mbean );
+                } catch( InstanceNotFoundException ex ) {
+                    log.error( "Instance not found for the created object", ex );
+                }
+            }
+            if( "jmx.mbean.deleted".equalsIgnoreCase( notification.getType() )) {
+                instances.remove(oname.toString());
+            }
+        }
+
+        // set attributes in jndi
+       //     if( "jmx.attribute.changed".equals( notification.getType() )) {
+        if( notification instanceof AttributeChangeNotification) {
+
+            AttributeChangeNotification anotif=(AttributeChangeNotification)notification;
+            String name=anotif.getAttributeName();
+            Object value=anotif.getNewValue();
+            Object source=anotif.getSource();
+            String mname=null;
+
+            Hashtable mbeanAtt=(Hashtable)attributes.get( source );
+            if( mbeanAtt==null ) {
+                mbeanAtt=new Hashtable();
+                attributes.put( source, mbeanAtt);
+                if( log.isDebugEnabled())
+                    log.debug("First attribute for " + source );
+            }
+            mbeanAtt.put( name, anotif );
+
+            log.debug( "Attribute change notification " + name + " " + value + " " + source );
+
+        }
+
+    }
+
+    public String dumpStatus() throws Exception
+    {
+        StringBuffer sb=new StringBuffer();
+        Enumeration en=instances.keys();
+        while (en.hasMoreElements()) {
+            String on = (String) en.nextElement();
+            Object mbean=instances.get(on);
+            Hashtable mbeanAtt=(Hashtable)attributes.get(mbean);
+
+            sb.append( "<mbean class=\"").append(on).append("\">");
+            sb.append( "\n");
+            Enumeration attEn=mbeanAtt.keys();
+            while (attEn.hasMoreElements()) {
+                String an = (String) attEn.nextElement();
+                AttributeChangeNotification anotif=
+                        (AttributeChangeNotification)mbeanAtt.get(an);
+                sb.append("  <attribute name=\"").append(an).append("\" ");
+                sb.append("value=\"").append(anotif.getNewValue()).append("\">");
+                sb.append( "\n");
+            }
+
+
+            sb.append( "</mbean>");
+            sb.append( "\n");
+        }
+        return sb.toString();
+    }
+
+    public void replay() throws Exception
+    {
+
+
+    }
+
+
+    public void init() throws Exception
+    {
+
+        MBeanServer mserver=(MBeanServer)Registry.getRegistry().getMBeanServer();
+        ObjectName delegate=new ObjectName("JMImplementation:type=MBeanServerDelegate");
+
+        // XXX need to extract info about previously loaded beans
+
+        // we'll know of all registered beans
+        mserver.addNotificationListener(delegate, this, null, null );
+
+    }
+
+}

==================================================
NotificationInfo.java
new file mode 100644
index 0000000000..a2c39a74de
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/ManagedBean.java
@@ -0,0 +1,508 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler;
+
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import javax.management.Descriptor;
+import javax.management.InstanceNotFoundException;
+import javax.management.MBeanException;
+import javax.management.RuntimeOperationsException;
+import javax.management.modelmbean.InvalidTargetObjectTypeException;
+import javax.management.modelmbean.ModelMBean;
+import javax.management.modelmbean.ModelMBeanAttributeInfo;
+import javax.management.modelmbean.ModelMBeanConstructorInfo;
+import javax.management.modelmbean.ModelMBeanInfo;
+import javax.management.modelmbean.ModelMBeanInfoSupport;
+import javax.management.modelmbean.ModelMBeanNotificationInfo;
+import javax.management.modelmbean.ModelMBeanOperationInfo;
+
+
+/**
+ * <p>Internal configuration information for a managed bean (MBean)
+ * descriptor.</p>
+ *
+ * @author Craig R. McClanahan
+ * @version $Revision: 383268 $ $Date: 2006-03-05 03:02:01 +0100 (dim., 05 mars 2006) $
+ */
+
+public class ManagedBean implements java.io.Serializable
+{
+    // ----------------------------------------------------- Instance Variables
+
+
+    /**
+     * The <code>ModelMBeanInfo</code> object that corresponds
+     * to this <code>ManagedBean</code> instance.
+     */
+    transient ModelMBeanInfo info = null;
+    protected AttributeInfo attributes[] = new AttributeInfo[0];
+    protected String className =
+            "org.apache.tomcat.util.modeler.BaseModelMBean";
+    protected ConstructorInfo constructors[] = new ConstructorInfo[0];
+    protected String description = null;
+    protected String domain = null;
+    protected String group = null;
+    protected String name = null;
+
+    protected List fields = new ArrayList();
+    protected NotificationInfo notifications[] = new NotificationInfo[0];
+    protected OperationInfo operations[] = new OperationInfo[0];
+    protected String type = null;
+
+    /** Constructor. Will add default attributes. 
+     *  
+     */ 
+    public ManagedBean() {
+        AttributeInfo ai=new AttributeInfo();
+        ai.setName("modelerType");
+        ai.setDescription("Type of the modeled resource. Can be set only once");
+        ai.setType("java.lang.String");
+        ai.setWriteable(false);
+        addAttribute(ai);
+    }
+    
+    // ------------------------------------------------------------- Properties
+
+
+    /**
+     * The collection of attributes for this MBean.
+     */
+    public AttributeInfo[] getAttributes() {
+        return (this.attributes);
+    }
+
+
+    /**
+     * The fully qualified name of the Java class of the MBean
+     * described by this descriptor.  If not specified, the standard JMX
+     * class (<code>javax.management.modelmbean.RequiredModeLMBean</code>)
+     * will be utilized.
+     */
+    public String getClassName() {
+        return (this.className);
+    }
+
+    public void setClassName(String className) {
+        this.className = className;
+        this.info = null;
+    }
+
+
+    /**
+     * The collection of constructors for this MBean.
+     */
+    public ConstructorInfo[] getConstructors() {
+        return (this.constructors);
+    }
+
+
+    /**
+     * The human-readable description of this MBean.
+     */
+    public String getDescription() {
+        return (this.description);
+    }
+
+    public void setDescription(String description) {
+        this.description = description;
+        this.info = null;
+    }
+
+
+    /**
+     * The (optional) <code>ObjectName</code> domain in which this MBean
+     * should be registered in the MBeanServer.
+     */
+    public String getDomain() {
+        return (this.domain);
+    }
+
+    public void setDomain(String domain) {
+        this.domain = domain;
+    }
+
+
+    /**
+     * <p>Return a <code>List</code> of the {@link FieldInfo} objects for
+     * the name/value pairs that should be
+     * added to the Descriptor created from this metadata.</p>
+     */
+    public List getFields() {
+        return (this.fields);
+    }
+
+
+    /**
+     * The (optional) group to which this MBean belongs.
+     */
+    public String getGroup() {
+        return (this.group);
+    }
+
+    public void setGroup(String group) {
+        this.group = group;
+    }
+
+
+    /**
+     * The name of this managed bean, which must be unique among all
+     * MBeans managed by a particular MBeans server.
+     */
+    public String getName() {
+        return (this.name);
+    }
+
+    public void setName(String name) {
+        this.name = name;
+        this.info = null;
+    }
+
+
+    /**
+     * The collection of notifications for this MBean.
+     */
+    public NotificationInfo[] getNotifications() {
+        return (this.notifications);
+    }
+
+
+    /**
+     * The collection of operations for this MBean.
+     */
+    public OperationInfo[] getOperations() {
+        return (this.operations);
+    }
+
+
+    /**
+     * The fully qualified name of the Java class of the resource
+     * implementation class described by the managed bean described
+     * by this descriptor.
+     */
+    public String getType() {
+        return (this.type);
+    }
+
+    public void setType(String type) {
+        this.type = type;
+        this.info = null;
+    }
+
+
+    // --------------------------------------------------------- Public Methods
+
+
+    /**
+     * Add a new attribute to the set of attributes for this MBean.
+     *
+     * @param attribute The new attribute descriptor
+     */
+    public void addAttribute(AttributeInfo attribute) {
+
+        synchronized (attributes) {
+            AttributeInfo results[] =
+                new AttributeInfo[attributes.length + 1];
+            System.arraycopy(attributes, 0, results, 0, attributes.length);
+            results[attributes.length] = attribute;
+            attributes = results;
+            this.info = null;
+        }
+
+    }
+
+
+    /**
+     * Add a new constructor to the set of constructors for this MBean.
+     *
+     * @param constructor The new constructor descriptor
+     */
+    public void addConstructor(ConstructorInfo constructor) {
+
+        synchronized (constructors) {
+            ConstructorInfo results[] =
+                new ConstructorInfo[constructors.length + 1];
+            System.arraycopy(constructors, 0, results, 0, constructors.length);
+            results[constructors.length] = constructor;
+            constructors = results;
+            this.info = null;
+        }
+
+    }
+
+
+    /**
+     * <p>Add a new field to the fields associated with the
+     * Descriptor that will be created from this metadata.</p>
+     *
+     * @param field The field to be added
+     */
+    public void addField(FieldInfo field) {
+        fields.add(field);
+    }
+
+
+    /**
+     * Add a new notification to the set of notifications for this MBean.
+     *
+     * @param notification The new notification descriptor
+     */
+    public void addNotification(NotificationInfo notification) {
+
+        synchronized (notifications) {
+            NotificationInfo results[] =
+                new NotificationInfo[notifications.length + 1];
+            System.arraycopy(notifications, 0, results, 0,
+                             notifications.length);
+            results[notifications.length] = notification;
+            notifications = results;
+            this.info = null;
+        }
+
+    }
+
+
+    /**
+     * Add a new operation to the set of operations for this MBean.
+     *
+     * @param operation The new operation descriptor
+     */
+    public void addOperation(OperationInfo operation) {
+        synchronized (operations) {
+            OperationInfo results[] =
+                new OperationInfo[operations.length + 1];
+            System.arraycopy(operations, 0, results, 0, operations.length);
+            results[operations.length] = operation;
+            operations = results;
+            this.info = null;
+        }
+
+    }
+
+
+    /**
+     * Create and return a <code>ModelMBean</code> that has been
+     * preconfigured with the <code>ModelMBeanInfo</code> information
+     * for this managed bean, but is not associated with any particular
+     * managed resource.  The returned <code>ModelMBean</code> will
+     * <strong>NOT</strong> have been registered with our
+     * <code>MBeanServer</code>.
+     *
+     * @exception InstanceNotFoundException if the managed resource
+     *  object cannot be found
+     * @exception InvalidTargetObjectTypeException if our MBean cannot
+     *  handle object references (should never happen)
+     * @exception MBeanException if a problem occurs instantiating the
+     *  <code>ModelMBean</code> instance
+     * @exception RuntimeOperationsException if a JMX runtime error occurs
+     */
+    public ModelMBean createMBean()
+        throws InstanceNotFoundException,
+        InvalidTargetObjectTypeException,
+        MBeanException, RuntimeOperationsException {
+
+        return (createMBean(null));
+
+    }
+
+
+    /**
+     * Create and return a <code>ModelMBean</code> that has been
+     * preconfigured with the <code>ModelMBeanInfo</code> information
+     * for this managed bean, and is associated with the specified
+     * managed object instance.  The returned <code>ModelMBean</code>
+     * will <strong>NOT</strong> have been registered with our
+     * <code>MBeanServer</code>.
+     *
+     * @param instance Instanced of the managed object, or <code>null</code>
+     *  for no associated instance
+     *
+     * @exception InstanceNotFoundException if the managed resource
+     *  object cannot be found
+     * @exception InvalidTargetObjectTypeException if our MBean cannot
+     *  handle object references (should never happen)
+     * @exception MBeanException if a problem occurs instantiating the
+     *  <code>ModelMBean</code> instance
+     * @exception RuntimeOperationsException if a JMX runtime error occurs
+     */
+    public ModelMBean createMBean(Object instance)
+        throws InstanceNotFoundException,
+        InvalidTargetObjectTypeException,
+        MBeanException, RuntimeOperationsException {
+
+        // Load the ModelMBean implementation class
+        Class clazz = null;
+        Exception ex = null;
+        try {
+            clazz = Class.forName(getClassName());
+        } catch (Exception e) {
+        }
+      
+        if( clazz==null ) {  
+            try {
+                ClassLoader cl= Thread.currentThread().getContextClassLoader();
+                if ( cl != null)
+                    clazz= cl.loadClass(getClassName());
+            } catch (Exception e) {
+                ex=e;
+            }
+        }
+
+        if( clazz==null) { 
+            throw new MBeanException
+                (ex, "Cannot load ModelMBean class " + getClassName());
+        }
+
+        // Create a new ModelMBean instance
+        ModelMBean mbean = null;
+        try {
+            mbean = (ModelMBean) clazz.newInstance();
+            mbean.setModelMBeanInfo(createMBeanInfo());
+        } catch (MBeanException e) {
+            throw e;
+        } catch (RuntimeOperationsException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new MBeanException
+                (e, "Cannot instantiate ModelMBean of class " +
+                 getClassName());
+        }
+
+        // Set the managed resource (if any)
+        try {
+            if (instance != null)
+                mbean.setManagedResource(instance, "ObjectReference");
+        } catch (InstanceNotFoundException e) {
+            throw e;
+        } catch (InvalidTargetObjectTypeException e) {
+            throw e;
+        }
+        return (mbean);
+
+    }
+
+
+    /**
+     * Create and return a <code>ModelMBeanInfo</code> object that
+     * describes this entire managed bean.
+     */
+    public ModelMBeanInfo createMBeanInfo() {
+
+        // Return our cached information (if any)
+        if (info != null)
+            return (info);
+
+        // Create subordinate information descriptors as required
+        AttributeInfo attrs[] = getAttributes();
+        ModelMBeanAttributeInfo attributes[] =
+            new ModelMBeanAttributeInfo[attrs.length];
+        for (int i = 0; i < attrs.length; i++)
+            attributes[i] = attrs[i].createAttributeInfo();
+        
+        ConstructorInfo consts[] = getConstructors();
+        ModelMBeanConstructorInfo constructors[] =
+            new ModelMBeanConstructorInfo[consts.length];
+        for (int i = 0; i < consts.length; i++)
+            constructors[i] = consts[i].createConstructorInfo();
+        NotificationInfo notifs[] = getNotifications();
+        ModelMBeanNotificationInfo notifications[] =
+            new ModelMBeanNotificationInfo[notifs.length];
+        for (int i = 0; i < notifs.length; i++)
+            notifications[i] = notifs[i].createNotificationInfo();
+        OperationInfo opers[] = getOperations();
+        ModelMBeanOperationInfo operations[] =
+            new ModelMBeanOperationInfo[opers.length];
+        for (int i = 0; i < opers.length; i++)
+            operations[i] = opers[i].createOperationInfo();
+
+        /*
+        // Add operations for attribute getters and setters as needed
+        ArrayList list = new ArrayList();
+        for (int i = 0; i < operations.length; i++)
+            list.add(operations[i]);
+        for (int i = 0; i < attributes.length; i++) {
+            Descriptor descriptor = attributes[i].getDescriptor();
+            String getMethod = (String) descriptor.getFieldValue("getMethod");
+            if (getMethod != null) {
+                OperationInfo oper =
+                    new OperationInfo(getMethod, true,
+                                      attributes[i].getType());
+                list.add(oper.createOperationInfo());
+            }
+            String setMethod = (String) descriptor.getFieldValue("setMethod");
+            if (setMethod != null) {
+                OperationInfo oper =
+                    new OperationInfo(setMethod, false,
+                                      attributes[i].getType());
+                list.add(oper.createOperationInfo());
+            }
+        }
+        if (list.size() > operations.length)
+            operations =
+                (ModelMBeanOperationInfo[]) list.toArray(operations);
+        */
+        
+        // Construct and return a new ModelMBeanInfo object
+        info = new ModelMBeanInfoSupport
+            (getClassName(), getDescription(),
+             attributes, constructors, operations, notifications);
+        try {
+            Descriptor descriptor = info.getMBeanDescriptor();
+            Iterator fields = getFields().iterator();
+            while (fields.hasNext()) {
+                FieldInfo field = (FieldInfo) fields.next();
+                descriptor.setField(field.getName(), field.getValue());
+            }
+            info.setMBeanDescriptor(descriptor);
+        } catch (MBeanException e) {
+            ;
+        }
+
+        return (info);
+
+    }
+
+
+    /**
+     * Return a string representation of this managed bean.
+     */
+    public String toString() {
+
+        StringBuffer sb = new StringBuffer("ManagedBean[");
+        sb.append("name=");
+        sb.append(name);
+        sb.append(", className=");
+        sb.append(className);
+        sb.append(", description=");
+        sb.append(description);
+        if (group != null) {
+            sb.append(", group=");
+            sb.append(group);
+        }
+        sb.append(", type=");
+        sb.append(type);
+        sb.append("]");
+        return (sb.toString());
+
+    }
+
+
+}

==================================================
OperationInfo.java
new file mode 100644
index 0000000000..98e65566d6
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/NotificationInfo.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright 1999,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler;
+
+
+import java.io.Serializable;
+
+import javax.management.Descriptor;
+import javax.management.modelmbean.ModelMBeanNotificationInfo;
+
+
+/**
+ * <p>Internal configuration information for a <code>Notification</code>
+ * descriptor.</p>
+ *
+ * @author Craig R. McClanahan
+ * @version $Revision: 155428 $ $Date: 2005-02-26 14:12:25 +0100 (sam., 26 févr. 2005) $
+ */
+
+public class NotificationInfo extends FeatureInfo implements Serializable {
+    static final long serialVersionUID = -6319885418912650856L;
+
+    // ----------------------------------------------------- Instance Variables
+
+
+    /**
+     * The <code>ModelMBeanNotificationInfo</code> object that corresponds
+     * to this <code>NotificationInfo</code> instance.
+     */
+    transient ModelMBeanNotificationInfo info = null;
+    protected String notifTypes[] = new String[0];
+
+    // ------------------------------------------------------------- Properties
+
+
+    /**
+     * Override the <code>description</code> property setter.
+     *
+     * @param description The new description
+     */
+    public void setDescription(String description) {
+        super.setDescription(description);
+        this.info = null;
+    }
+
+
+    /**
+     * Override the <code>name</code> property setter.
+     *
+     * @param name The new name
+     */
+    public void setName(String name) {
+        super.setName(name);
+        this.info = null;
+    }
+
+
+    /**
+     * The set of notification types for this MBean.
+     */
+    public String[] getNotifTypes() {
+        return (this.notifTypes);
+    }
+
+
+    // --------------------------------------------------------- Public Methods
+
+
+    /**
+     * Add a new notification type to the set managed by an MBean.
+     *
+     * @param notifType The new notification type
+     */
+    public void addNotifType(String notifType) {
+
+        synchronized (notifTypes) {
+            String results[] = new String[notifTypes.length + 1];
+            System.arraycopy(notifTypes, 0, results, 0, notifTypes.length);
+            results[notifTypes.length] = notifType;
+            notifTypes = results;
+            this.info = null;
+        }
+
+    }
+
+
+    /**
+     * Create and return a <code>ModelMBeanNotificationInfo</code> object that
+     * corresponds to the attribute described by this instance.
+     */
+    public ModelMBeanNotificationInfo createNotificationInfo() {
+
+        // Return our cached information (if any)
+        if (info != null)
+            return (info);
+
+        // Create and return a new information object
+        info = new ModelMBeanNotificationInfo
+            (getNotifTypes(), getName(), getDescription());
+        Descriptor descriptor = info.getDescriptor();
+        addFields(descriptor);
+        info.setDescriptor(descriptor);
+        return (info);
+
+    }
+
+
+    /**
+     * Return a string representation of this notification descriptor.
+     */
+    public String toString() {
+
+        StringBuffer sb = new StringBuffer("NotificationInfo[");
+        sb.append("name=");
+        sb.append(name);
+        sb.append(", description=");
+        sb.append(description);
+        sb.append(", notifTypes=");
+        sb.append(notifTypes.length);
+        sb.append("]");
+        return (sb.toString());
+
+    }
+
+
+}

==================================================
ParameterInfo.java
new file mode 100644
index 0000000000..6be9ea403d
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/OperationInfo.java
@@ -0,0 +1,246 @@
+/*
+ * Copyright 1999,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler;
+
+
+import java.io.Serializable;
+
+import javax.management.Descriptor;
+import javax.management.MBeanParameterInfo;
+import javax.management.modelmbean.ModelMBeanOperationInfo;
+
+
+/**
+ * <p>Internal configuration information for an <code>Operation</code>
+ * descriptor.</p>
+ *
+ * @author Craig R. McClanahan
+ * @version $Revision: 155428 $ $Date: 2005-02-26 14:12:25 +0100 (sam., 26 févr. 2005) $
+ */
+
+public class OperationInfo extends FeatureInfo implements Serializable {
+    static final long serialVersionUID = 4418342922072614875L;
+    // ----------------------------------------------------------- Constructors
+
+
+    /**
+     * Standard zero-arguments constructor.
+     */
+    public OperationInfo() {
+
+        super();
+
+    }
+
+
+    /**
+     * Special constructor for setting up getter and setter operations.
+     *
+     * @param name Name of this operation
+     * @param getter Is this a getter (as opposed to a setter)?
+     * @param type Data type of the return value (if this is a getter)
+     *  or the parameter (if this is a setter)
+     * 
+     */
+    public OperationInfo(String name, boolean getter, String type) {
+
+        super();
+        setName(name);
+        if (getter) {
+            setDescription("Attribute getter method");
+            setImpact("INFO");
+            setReturnType(type);
+            setRole("getter");
+        } else {
+            setDescription("Attribute setter method");
+            setImpact("ACTION");
+            setReturnType("void");
+            setRole("setter");
+            addParameter(new ParameterInfo("value", type,
+                                           "New attribute value"));
+        }
+
+    }
+
+
+    // ----------------------------------------------------- Instance Variables
+
+
+    /**
+     * The <code>ModelMBeanOperationInfo</code> object that corresponds
+     * to this <code>OperationInfo</code> instance.
+     */
+    transient ModelMBeanOperationInfo info = null;
+    protected String impact = "UNKNOWN";
+    protected String role = "operation";
+    protected String returnType = "void";    // FIXME - Validate
+    protected ParameterInfo parameters[] = new ParameterInfo[0];
+
+
+    // ------------------------------------------------------------- Properties
+
+
+    /**
+     * Override the <code>description</code> property setter.
+     *
+     * @param description The new description
+     */
+    public void setDescription(String description) {
+        super.setDescription(description);
+        this.info = null;
+    }
+
+
+    /**
+     * Override the <code>name</code> property setter.
+     *
+     * @param name The new name
+     */
+    public void setName(String name) {
+        super.setName(name);
+        this.info = null;
+    }
+
+
+    /**
+     * The "impact" of this operation, which should be a (case-insensitive)
+     * string value "ACTION", "ACTION_INFO", "INFO", or "UNKNOWN".
+     */
+    public String getImpact() {
+        return (this.impact);
+    }
+
+    public void setImpact(String impact) {
+        if (impact == null)
+            this.impact = null;
+        else
+            this.impact = impact.toUpperCase();
+    }
+
+
+    /**
+     * The role of this operation ("getter", "setter", "operation", or
+     * "constructor").
+     */
+    public String getRole() {
+        return (this.role);
+    }
+
+    public void setRole(String role) {
+        this.role = role;
+    }
+
+
+    /**
+     * The fully qualified Java class name of the return type for this
+     * operation.
+     */
+    public String getReturnType() {
+        return (this.returnType);
+    }
+
+    public void setReturnType(String returnType) {
+        this.returnType = returnType;
+    }
+
+    /**
+     * The set of parameters for this operation.
+     */
+    public ParameterInfo[] getSignature() {
+        return (this.parameters);
+    }
+
+    // --------------------------------------------------------- Public Methods
+
+
+    /**
+     * Add a new parameter to the set of arguments for this operation.
+     *
+     * @param parameter The new parameter descriptor
+     */
+    public void addParameter(ParameterInfo parameter) {
+
+        synchronized (parameters) {
+            ParameterInfo results[] = new ParameterInfo[parameters.length + 1];
+            System.arraycopy(parameters, 0, results, 0, parameters.length);
+            results[parameters.length] = parameter;
+            parameters = results;
+            this.info = null;
+        }
+
+    }
+
+
+    /**
+     * Create and return a <code>ModelMBeanOperationInfo</code> object that
+     * corresponds to the attribute described by this instance.
+     */
+    public ModelMBeanOperationInfo createOperationInfo() {
+
+        // Return our cached information (if any)
+        if (info != null)
+            return (info);
+
+        // Create and return a new information object
+        ParameterInfo params[] = getSignature();
+        MBeanParameterInfo parameters[] =
+            new MBeanParameterInfo[params.length];
+        for (int i = 0; i < params.length; i++)
+            parameters[i] = params[i].createParameterInfo();
+        int impact = ModelMBeanOperationInfo.UNKNOWN;
+        if ("ACTION".equals(getImpact()))
+            impact = ModelMBeanOperationInfo.ACTION;
+        else if ("ACTION_INFO".equals(getImpact()))
+            impact = ModelMBeanOperationInfo.ACTION_INFO;
+        else if ("INFO".equals(getImpact()))
+            impact = ModelMBeanOperationInfo.INFO;
+
+        info = new ModelMBeanOperationInfo
+            (getName(), getDescription(), parameters,
+             getReturnType(), impact);
+        Descriptor descriptor = info.getDescriptor();
+        descriptor.removeField("class");
+        descriptor.setField("role", getRole());
+        addFields(descriptor);
+        info.setDescriptor(descriptor);
+        return (info);
+
+    }
+
+
+    /**
+     * Return a string representation of this operation descriptor.
+     */
+    public String toString() {
+
+        StringBuffer sb = new StringBuffer("OperationInfo[");
+        sb.append("name=");
+        sb.append(name);
+        sb.append(", description=");
+        sb.append(description);
+        sb.append(", returnType=");
+        sb.append(returnType);
+        sb.append(", parameters=");
+        sb.append(parameters.length);
+        sb.append("]");
+        return (sb.toString());
+
+    }
+
+
+}

==================================================
Registry.java
new file mode 100644
index 0000000000..13717bdf0a
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/ParameterInfo.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright 1999,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler;
+
+
+import java.io.Serializable;
+
+import javax.management.MBeanParameterInfo;
+
+
+/**
+ * <p>Internal configuration information for a <code>Parameter</code>
+ * descriptor.</p>
+ *
+ * @author Craig R. McClanahan
+ * @version $Revision: 155428 $ $Date: 2005-02-26 14:12:25 +0100 (sam., 26 févr. 2005) $
+ */
+
+public class ParameterInfo extends FeatureInfo implements Serializable {
+    static final long serialVersionUID = 2222796006787664020L;
+    // ----------------------------------------------------------- Constructors
+
+
+    /**
+     * Standard zero-arguments constructor.
+     */
+    public ParameterInfo() {
+
+        super();
+
+    }
+
+
+    /**
+     * Special constructor for setting up parameters programatically.
+     *
+     * @param name Name of this parameter
+     * @param type Java class of this parameter
+     * @param description Description of this parameter
+     */
+    public ParameterInfo(String name, String type, String description) {
+
+        super();
+        setName(name);
+        setType(type);
+        setDescription(description);
+
+    }
+
+
+    // ----------------------------------------------------- Instance Variables
+
+
+    /**
+     * The <code>MBeanParameterInfo</code> object that corresponds
+     * to this <code>ParameterInfo</code> instance.
+     */
+    transient MBeanParameterInfo info = null;
+    protected String type = null;
+
+    // ------------------------------------------------------------- Properties
+
+
+    /**
+     * Override the <code>description</code> property setter.
+     *
+     * @param description The new description
+     */
+    public void setDescription(String description) {
+        super.setDescription(description);
+        this.info = null;
+    }
+
+
+    /**
+     * Override the <code>name</code> property setter.
+     *
+     * @param name The new name
+     */
+    public void setName(String name) {
+        super.setName(name);
+        this.info = null;
+    }
+
+
+    /**
+     * The fully qualified Java class name of this parameter.
+     */
+    public String getType() {
+        return (this.type);
+    }
+
+    public void setType(String type) {
+        this.type = type;
+        this.info = null;
+    }
+
+
+    // --------------------------------------------------------- Public Methods
+
+
+    /**
+     * Create and return a <code>MBeanParameterInfo</code> object that
+     * corresponds to the parameter described by this instance.
+     */
+    public MBeanParameterInfo createParameterInfo() {
+
+        // Return our cached information (if any)
+        if (info != null)
+            return (info);
+
+        // Create and return a new information object
+        info = new MBeanParameterInfo
+            (getName(), getType(), getDescription());
+        return (info);
+
+    }
+
+
+    /**
+     * Return a string representation of this parameter descriptor.
+     */
+    public String toString() {
+
+        StringBuffer sb = new StringBuffer("ParameterInfo[");
+        sb.append("name=");
+        sb.append(name);
+        sb.append(", description=");
+        sb.append(description);
+        sb.append(", type=");
+        sb.append(type);
+        sb.append("]");
+        return (sb.toString());
+
+    }
+}

==================================================
RegistryMBean.java
new file mode 100644
index 0000000000..1aac7dcaf0
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/Registry.java
@@ -0,0 +1,1083 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler;
+
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.Iterator;
+import java.util.List;
+
+import javax.management.DynamicMBean;
+import javax.management.MBeanAttributeInfo;
+import javax.management.MBeanInfo;
+import javax.management.MBeanOperationInfo;
+import javax.management.MBeanRegistration;
+import javax.management.MBeanServer;
+import javax.management.MBeanServerFactory;
+import javax.management.MalformedObjectNameException;
+import javax.management.ObjectName;
+import javax.management.modelmbean.ModelMBean;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.tomcat.util.modeler.modules.ModelerSource;
+
+/*
+   Issues:
+   - exceptions - too many "throws Exception"
+   - double check the interfaces 
+   - start removing the use of the experimental methods in tomcat, then remove
+     the methods ( before 1.1 final )
+   - is the security enough to prevent Registry beeing used to avoid the permission
+    checks in the mbean server ?
+*/ 
+
+/**
+ * Registry for modeler MBeans. 
+ *
+ * This is the main entry point into modeler. It provides methods to create
+ * and manipulate model mbeans and simplify their use.
+ *
+ * Starting with version 1.1, this is no longer a singleton and the static
+ * methods are strongly deprecated. In a container environment we can expect
+ * different applications to use different registries.
+ * 
+ * This class is itself an mbean.
+ * 
+ * IMPORTANT: public methods not marked with @since x.x are experimental or 
+ * internal. Should not be used.  
+ * 
+ * @author Craig R. McClanahan
+ * @author Costin Manolache
+ */
+public class Registry implements RegistryMBean, MBeanRegistration  {
+    /** Experimental support for manifest-based discovery.
+     */
+    public static String MODELER_MANIFEST="/META-INF/mbeans-descriptors.xml";
+
+    /**
+     * The Log instance to which we will write our log messages.
+     */
+    private static Log log = LogFactory.getLog(Registry.class);
+
+    // Support for the factory methods
+    
+    /** Will be used to isolate different apps and enhance security
+     */
+    private static HashMap perLoaderRegistries=null;
+
+    /**
+     * The registry instance created by our factory method the first time
+     * it is called.
+     */
+    private static Registry registry = null;
+
+    // Per registy fields
+    
+    /**
+     * The <code>MBeanServer</code> instance that we will use to register
+     * management beans.
+     */
+    private MBeanServer server = null;
+
+    /**
+     * The set of ManagedBean instances for the beans this registry
+     * knows about, keyed by name.
+     */
+    private HashMap descriptors = new HashMap();
+
+    /** List of managed byeans, keyed by class name
+     */
+    private HashMap descriptorsByClass = new HashMap();
+
+    // map to avoid duplicated searching or loading descriptors 
+    private HashMap searchedPaths=new HashMap();
+    
+    private Object key;
+    private Object guard;
+
+    // Id - small ints to use array access. No reset on stop()
+    private Hashtable idDomains=new Hashtable();
+    private Hashtable ids=new Hashtable();
+
+    
+    // ----------------------------------------------------------- Constructors
+
+    /**
+     */
+     public Registry() {
+        super();
+    }
+
+    // -------------------- Static methods  --------------------
+    // Factories
+    
+    /**
+     * Factory method to create (if necessary) and return our
+     * <code>Registry</code> instance.
+     *
+     * Use this method to obtain a Registry - all other static methods
+     * are deprecated and shouldn't be used.
+     *
+     * The current version uses a static - future versions could use
+     * the thread class loader.
+     * 
+     * @param key Support for application isolation. If null, the context class
+     * loader will be used ( if setUseContextClassLoader is called ) or the 
+     * default registry is returned. 
+     * @param guard Prevent access to the registry by untrusted components
+     *
+     * @since 1.1
+     */
+    public synchronized static Registry getRegistry(Object key, Object guard) {
+        Registry localRegistry;
+        if( perLoaderRegistries!=null ) {
+            if( key==null ) 
+                key=Thread.currentThread().getContextClassLoader();
+            if( key != null ) {
+                localRegistry=(Registry)perLoaderRegistries.get(key);
+                if( localRegistry == null ) {
+                    localRegistry=new Registry();
+                    localRegistry.key=key;
+                    localRegistry.guard=guard;
+                    perLoaderRegistries.put( key, localRegistry );
+                    return localRegistry;
+                }
+                if( localRegistry.guard != null &&
+                        localRegistry.guard != guard ) {
+                    return null; // XXX Should I throw a permission ex ? 
+                }
+                return localRegistry;
+            }
+        }
+
+        // static 
+        if (registry == null) {
+            registry = new Registry();
+        }
+        if( registry.guard != null &&
+                registry.guard != guard ) {
+            return null;
+        }
+        return (registry);
+    }
+    
+    /** Allow containers to isolate apps. Can be called only once.
+     * It  is highly recommended you call this method if using Registry in
+     * a container environment. The default is false for backward compatibility
+     * 
+     * @param enable
+     * @since 1.1
+     */
+    public static void setUseContextClassLoader( boolean enable ) {
+        if( enable ) {
+            perLoaderRegistries=new HashMap();
+        }
+    }
+    
+    // -------------------- Generic methods  --------------------
+
+    /** Set a guard object that will prevent access to this registry 
+     * by unauthorized components
+     * 
+     * @param guard
+     * 
+     * @since 1.1
+     */ 
+    public void setGuard( Object guard ) {
+        if( this.guard!=null ) {
+            return; // already set, only once
+        }
+        this.guard=guard;
+    }
+
+    /** Lifecycle method - clean up the registry metadata.
+     * 
+     * @since 1.1
+     */ 
+    public void stop() {
+        descriptorsByClass = new HashMap();
+        descriptors = new HashMap();
+        searchedPaths=new HashMap();
+    }
+    
+    /** 
+     * Load an extended mlet file. The source can be an URL, File or
+     * InputStream. 
+     * 
+     * All mbeans will be instantiated, registered and the attributes will be 
+     * set. The result is a list of ObjectNames.
+     *
+     * @param source InputStream or URL of the file
+     * @param cl ClassLoader to be used to load the mbeans, or null to use the
+     *        default JMX mechanism ( i.e. all registered loaders )
+     * @return List of ObjectName for the loaded mbeans
+     * @throws Exception
+     * 
+     * @since 1.1
+     */ 
+    public List loadMBeans( Object source, ClassLoader cl )
+            throws Exception
+    {
+        return load("MbeansSource", source, null );
+    }    
+
+
+    /** Load descriptors. The source can be a File or URL or InputStream for the 
+     * descriptors file. In the case of File and URL, if the extension is ".ser"
+     * a serialized version will be loaded. 
+     * 
+     * Also ( experimental for now ) a ClassLoader - in which case META-INF/ will
+     * be used.
+     * 
+     * This method should be used to explicitely load metadata - but this is not
+     * required in most cases. The registerComponent() method will find metadata
+     * in the same pacakge.
+     * 
+     * @param source
+     */ 
+    public void loadMetadata(Object source ) throws Exception {
+        if( source instanceof ClassLoader ) {
+            loadMetaInfDescriptors((ClassLoader)source);
+            return;
+        } else {
+            loadDescriptors( null, source, null );
+        }
+        
+    }
+
+    /** Register a bean by creating a modeler mbean and adding it to the 
+     * MBeanServer.
+     * 
+     * If metadata is not loaded, we'll look up and read a file named
+     * "mbeans-descriptors.ser" or "mbeans-descriptors.xml" in the same package
+     * or parent.
+     *
+     * If the bean is an instance of DynamicMBean. it's metadata will be converted
+     * to a model mbean and we'll wrap it - so modeler services will be supported
+     *
+     * If the metadata is still not found, introspection will be used to extract
+     * it automatically. 
+     * 
+     * If an mbean is already registered under this name, it'll be first
+     * unregistered.
+     * 
+     * If the component implements MBeanRegistration, the methods will be called.
+     * If the method has a method "setRegistry" that takes a RegistryMBean as
+     * parameter, it'll be called with the current registry.
+     * 
+     *
+     * @param bean Object to be registered
+     * @param oname Name used for registration
+     * @param type The type of the mbean, as declared in mbeans-descriptors. If
+     * null, the name of the class will be used. This can be used as a hint or
+     * by subclasses.
+     *
+     * @since 1.1
+     */ 
+    public void registerComponent(Object bean, String oname, String type)
+           throws Exception
+    {
+        registerComponent(bean, new ObjectName(oname), type);        
+    }    
+
+    /** Unregister a component. We'll first check if it is registered,
+     * and mask all errors. This is mostly a helper.
+     * 
+     * @param oname
+     * 
+     * @since 1.1
+     */ 
+    public void unregisterComponent( String oname ) {
+        try {
+            unregisterComponent(new ObjectName(oname));
+        } catch (MalformedObjectNameException e) {
+            log.info("Error creating object name " + e );
+        }
+    }    
+    
+
+    /** Invoke a operation on a list of mbeans. Can be used to implement
+     * lifecycle operations.
+     *
+     * @param mbeans list of ObjectName on which we'll invoke the operations
+     * @param operation  Name of the operation ( init, start, stop, etc)
+     * @param failFirst  If false, exceptions will be ignored
+     * @throws Exception
+     * @since 1.1
+     */
+    public void invoke( List mbeans, String operation, boolean failFirst )
+            throws Exception
+    {
+        if( mbeans==null ) {
+            return;
+        }
+        Iterator itr=mbeans.iterator();
+        while(itr.hasNext()) {
+            Object current=itr.next();
+            ObjectName oN=null;
+            try {
+                if( current instanceof ObjectName) {
+                    oN=(ObjectName)current;
+                }
+                if( current instanceof String ) {
+                    oN=new ObjectName( (String)current );
+                }
+                if( oN==null ) {
+                    continue;
+                }
+                if( getMethodInfo(oN, operation) == null) {
+                    continue;
+                }
+                getMBeanServer().invoke(oN, operation,
+                        new Object[] {}, new String[] {});
+
+            } catch( Exception t ) {
+                if( failFirst ) throw t;
+                log.info("Error initializing " + current + " " + t.toString());
+            }
+        }
+    }
+
+    // -------------------- ID registry --------------------
+
+    /** Return an int ID for faster access. Will be used for notifications
+     * and for other operations we want to optimize. 
+     *
+     * @param domain Namespace 
+     * @param name  Type of the notification
+     * @return  An unique id for the domain:name combination
+     * @since 1.1
+     */
+    public synchronized int getId( String domain, String name) {
+        if( domain==null) {
+            domain="";
+        }
+        Hashtable domainTable=(Hashtable)idDomains.get( domain );
+        if( domainTable == null ) {
+            domainTable=new Hashtable();
+            idDomains.put( domain, domainTable); 
+        }
+        if( name==null ) {
+            name="";
+        }
+        Integer i=(Integer)domainTable.get(name);
+        
+        if( i!= null ) {
+            return i.intValue();
+        }
+
+        int id[]=(int [])ids.get( domain );
+        if( id == null ) {
+            id=new int[1];
+            ids.put( domain, id); 
+        }
+        int code=id[0]++;
+        domainTable.put( name, new Integer( code ));
+        return code;
+    }
+    
+    // -------------------- Metadata   --------------------
+    // methods from 1.0
+
+    /**
+     * Add a new bean metadata to the set of beans known to this registry.
+     * This is used by internal components.
+     *
+     * @param bean The managed bean to be added
+     * @since 1.0
+     */
+    public void addManagedBean(ManagedBean bean) {
+        // XXX Use group + name
+        descriptors.put(bean.getName(), bean);
+        if( bean.getType() != null ) {
+            descriptorsByClass.put( bean.getType(), bean );
+        }
+    }
+
+
+    /**
+     * Find and return the managed bean definition for the specified
+     * bean name, if any; otherwise return <code>null</code>.
+     *
+     * @param name Name of the managed bean to be returned. Since 1.1, both
+     *   short names or the full name of the class can be used.
+     * @since 1.0
+     */
+    public ManagedBean findManagedBean(String name) {
+        // XXX Group ?? Use Group + Type
+        ManagedBean mb=((ManagedBean) descriptors.get(name));
+        if( mb==null )
+            mb=(ManagedBean)descriptorsByClass.get(name);
+        return mb;
+    }
+    
+    /**
+     * Return the set of bean names for all managed beans known to
+     * this registry.
+     *
+     * @since 1.0
+     */
+    public String[] findManagedBeans() {
+        return ((String[]) descriptors.keySet().toArray(new String[0]));
+    }
+
+
+    /**
+     * Return the set of bean names for all managed beans known to
+     * this registry that belong to the specified group.
+     *
+     * @param group Name of the group of interest, or <code>null</code>
+     *  to select beans that do <em>not</em> belong to a group
+     * @since 1.0
+     */
+    public String[] findManagedBeans(String group) {
+
+        ArrayList results = new ArrayList();
+        Iterator items = descriptors.values().iterator();
+        while (items.hasNext()) {
+            ManagedBean item = (ManagedBean) items.next();
+            if ((group == null) && (item.getGroup() == null)) {
+                results.add(item.getName());
+            } else if (group.equals(item.getGroup())) {
+                results.add(item.getName());
+            }
+        }
+        String values[] = new String[results.size()];
+        return ((String[]) results.toArray(values));
+
+    }
+
+
+    /**
+     * Remove an existing bean from the set of beans known to this registry.
+     *
+     * @param bean The managed bean to be removed
+     * @since 1.0
+     */
+    public void removeManagedBean(ManagedBean bean) {
+       // TODO: change this to use group/name
+        descriptors.remove(bean.getName());
+        descriptorsByClass.remove( bean.getType());
+    }
+
+    // -------------------- Deprecated 1.0 methods  --------------------
+    
+    /**
+     * Factory method to create (if necessary) and return our
+     * <code>MBeanServer</code> instance.
+     *
+     * @since 1.0
+     * @deprecated Use the instance method
+     */
+    public static MBeanServer getServer() {
+        return Registry.getRegistry().getMBeanServer();
+    }
+
+    /**
+     * Set the <code>MBeanServer</code> to be utilized for our
+     * registered management beans.
+     *
+     * @param mbeanServer The new <code>MBeanServer</code> instance
+     * @since 1.0
+     * @deprecated Use the instance method
+     */
+    public static void setServer(MBeanServer mbeanServer) {
+        Registry.getRegistry().setMBeanServer(mbeanServer);
+    }
+
+    /**
+     * Load the registry from the XML input found in the specified input
+     * stream.
+     *
+     * @param stream InputStream containing the registry configuration
+     *  information
+     *
+     * @exception Exception if any parsing or processing error occurs
+     * @deprecated use normal class method instead
+     * @since 1.0
+     */
+    public static void loadRegistry(InputStream stream) throws Exception {
+        Registry registry = getRegistry();
+        registry.loadMetadata(stream);
+    }
+
+    /** Get a "singelton" registry, or one per thread if setUseContextLoader 
+     * was called 
+     * 
+     * @deprecated Not enough info - use the method that takes CL and domain
+     * @since 1.0 
+     */ 
+    public synchronized static Registry getRegistry() {
+        return getRegistry(null, null);
+    }    
+
+    // -------------------- Helpers  --------------------
+
+    /** Get the type of an attribute of the object, from the metadata.
+     *
+     * @param oname
+     * @param attName
+     * @return null if metadata about the attribute is not found
+     * @since 1.1
+     */
+    public String getType( ObjectName oname, String attName )
+    {
+        String type=null;
+        MBeanInfo info=null;
+        try {
+            info=server.getMBeanInfo(oname);
+        } catch (Exception e) {
+            log.info( "Can't find metadata for object" + oname );
+            return null;
+        }
+
+        MBeanAttributeInfo attInfo[]=info.getAttributes();
+        for( int i=0; i<attInfo.length; i++ ) {
+            if( attName.equals(attInfo[i].getName())) {
+                type=attInfo[i].getType();
+                return type;
+            }
+        }
+        return null;
+    }
+
+    /** Find the operation info for a method
+     * 
+     * @param oname
+     * @param opName
+     * @return the operation info for the specified operation
+     */ 
+    public MBeanOperationInfo getMethodInfo( ObjectName oname, String opName )
+    {
+        String type=null;
+        MBeanInfo info=null;
+        try {
+            info=server.getMBeanInfo(oname);
+        } catch (Exception e) {
+            log.info( "Can't find metadata " + oname );
+            return null;
+        }
+        MBeanOperationInfo attInfo[]=info.getOperations();
+        for( int i=0; i<attInfo.length; i++ ) {
+            if( opName.equals(attInfo[i].getName())) {
+                return attInfo[i];
+            }
+        }
+        return null;
+    }
+
+    /** Unregister a component. This is just a helper that
+     * avoids exceptions by checking if the mbean is already registered
+     *
+     * @param oname
+     */
+    public void unregisterComponent( ObjectName oname ) {
+        try {
+            if( getMBeanServer().isRegistered(oname)) {
+                getMBeanServer().unregisterMBean(oname);
+            }
+        } catch( Throwable t ) {
+            log.error( "Error unregistering mbean ", t);
+        }
+    }
+
+    /**
+     * Factory method to create (if necessary) and return our
+     * <code>MBeanServer</code> instance.
+     *
+     */
+    public synchronized MBeanServer getMBeanServer() {
+        long t1=System.currentTimeMillis();
+
+        if (server == null) {
+            if( MBeanServerFactory.findMBeanServer(null).size() > 0 ) {
+                server=(MBeanServer)MBeanServerFactory.findMBeanServer(null).get(0);
+                if( log.isDebugEnabled() ) {
+                    log.debug("Using existing MBeanServer " + (System.currentTimeMillis() - t1 ));
+                }
+            } else {
+                server=MBeanServerFactory.createMBeanServer();
+                if( log.isDebugEnabled() ) {
+                    log.debug("Creating MBeanServer"+ (System.currentTimeMillis() - t1 ));
+                }
+            }
+        }
+        return (server);
+    }
+
+    /** Find or load metadata. 
+     */ 
+    public ManagedBean findManagedBean(Object bean, Class beanClass, String type)
+        throws Exception
+    {
+        if( bean!=null && beanClass==null ) {
+            beanClass=bean.getClass();
+        }
+        
+        if( type==null ) {
+            type=beanClass.getName();
+        }
+        
+        // first look for existing descriptor
+        ManagedBean managed = findManagedBean(type);
+
+        // Search for a descriptor in the same package
+        if( managed==null ) {
+            // check package and parent packages
+            if( log.isDebugEnabled() ) {
+                log.debug( "Looking for descriptor ");
+            }
+            findDescriptor( beanClass, type );
+
+            managed=findManagedBean(type);
+        }
+        
+        if( bean instanceof DynamicMBean ) {
+            if( log.isDebugEnabled() ) {
+                log.debug( "Dynamic mbean support ");
+            }
+            // Dynamic mbean
+            loadDescriptors("MbeansDescriptorsDynamicMBeanSource",
+                    bean, type);
+
+            managed=findManagedBean(type);
+        }
+
+        // Still not found - use introspection
+        if( managed==null ) {
+            if( log.isDebugEnabled() ) {
+                log.debug( "Introspecting ");
+            }
+
+            // introspection
+            loadDescriptors("MbeansDescriptorsIntrospectionSource",
+                    beanClass, type);
+
+            managed=findManagedBean(type);
+            if( managed==null ) {
+                log.warn( "No metadata found for " + type );
+                return null;
+            }
+            managed.setName( type );
+            addManagedBean(managed);
+        }
+        return managed;
+    }
+    
+
+    /** EXPERIMENTAL Convert a string to object, based on type. Used by several
+     * components. We could provide some pluggability. It is here to keep
+     * things consistent and avoid duplication in other tasks 
+     * 
+     * @param type Fully qualified class name of the resulting value
+     * @param value String value to be converted
+     * @return Converted value
+     */ 
+    public Object convertValue(String type, String value)
+    {
+        Object objValue=value;
+        
+        if( type==null || "java.lang.String".equals( type )) {
+            // string is default
+            objValue=value;
+        } else if( "javax.management.ObjectName".equals( type ) ||
+                "ObjectName".equals( type )) {
+            try {
+                objValue=new ObjectName( value );
+            } catch (MalformedObjectNameException e) {
+                return null;
+            }
+        } else if( "java.lang.Integer".equals( type ) ||
+                "int".equals( type )) {
+            objValue=new Integer( value );
+        } else if( "java.lang.Boolean".equals( type ) ||
+                "boolean".equals( type )) {
+            objValue=new Boolean( value );
+        }
+        return objValue;
+    }
+    
+    /** Experimental.
+     *
+     * @param sourceType
+     * @param source
+     * @param param
+     * @return List of descriptors
+     * @throws Exception
+     * @deprecated bad interface, mixing of metadata and mbeans
+     */
+    public List load( String sourceType, Object source, String param)
+        throws Exception
+    {
+        if( log.isTraceEnabled()) {
+            log.trace("load " + source );
+        }
+        String location=null;
+        String type=null;
+        Object inputsource=null;
+
+        if( source instanceof DynamicMBean ) {
+            sourceType="MbeansDescriptorsDynamicMBeanSource";
+            inputsource=source;
+        } else if( source instanceof URL ) {
+            URL url=(URL)source;
+            location=url.toString();
+            type=param;
+            inputsource=url.openStream();
+            if( sourceType == null ) {
+                sourceType = sourceTypeFromExt(location);
+            }
+        } else if( source instanceof File ) {
+            location=((File)source).getAbsolutePath();
+            inputsource=new FileInputStream((File)source);            
+            type=param;
+            if( sourceType == null ) {
+                sourceType = sourceTypeFromExt(location);
+            }
+        } else if( source instanceof InputStream ) {
+            type=param;
+            inputsource=source;
+        } else if( source instanceof Class ) {
+            location=((Class)source).getName();
+            type=param;
+            inputsource=source;
+            if( sourceType== null ) {
+                sourceType="MbeansDescriptorsIntrospectionSource";
+            }
+        }
+        
+        if( sourceType==null ) {
+            sourceType="MbeansDescriptorsDOMSource";
+        }
+        ModelerSource ds=getModelerSource(sourceType);
+        List mbeans=ds.loadDescriptors(this, location, type, inputsource);
+
+        return mbeans;
+    }
+
+    private String sourceTypeFromExt( String s ) {
+        if( s.endsWith( ".ser")) {
+            return "MbeansDescriptorsSerSource";
+        }
+        else if( s.endsWith(".xml")) {
+            return "MbeansDescriptorsDOMSource";
+        }
+        return null;
+    }
+
+    /** Register a component 
+     * XXX make it private 
+     * 
+     * @param bean
+     * @param oname
+     * @param type
+     * @throws Exception
+     */ 
+    public void registerComponent(Object bean, ObjectName oname, String type)
+           throws Exception
+    {
+        if( log.isDebugEnabled() ) {
+            log.debug( "Managed= "+ oname);
+        }
+
+        if( bean ==null ) {
+            log.error("Null component " + oname );
+            return;
+        }
+
+        try {
+            if( type==null ) {
+                type=bean.getClass().getName();
+            }
+
+            ManagedBean managed = findManagedBean(bean.getClass(), type);
+
+            // The real mbean is created and registered
+            ModelMBean mbean = managed.createMBean(bean);
+
+            if(  getMBeanServer().isRegistered( oname )) {
+                if( log.isDebugEnabled()) {
+                    log.debug("Unregistering existing component " + oname );
+                }
+                getMBeanServer().unregisterMBean( oname );
+            }
+
+            getMBeanServer().registerMBean( mbean, oname);
+        } catch( Exception ex) {
+            log.error("Error registering " + oname, ex );
+            throw ex;
+        }
+    }
+
+    /** Lookup the component descriptor in the package and
+     * in the parent packages.
+     *
+     * @param packageName
+     */
+    public void loadDescriptors( String packageName, ClassLoader classLoader  ) {
+        String res=packageName.replace( '.', '/');
+
+        if( log.isTraceEnabled() ) {
+            log.trace("Finding descriptor " + res );
+        }
+
+        if( searchedPaths.get( packageName ) != null ) {
+            return;
+        }
+        String descriptors=res + "/mbeans-descriptors.ser";
+
+        URL dURL=classLoader.getResource( descriptors );
+
+        if( dURL == null ) {
+            descriptors=res + "/mbeans-descriptors.xml";
+            dURL=classLoader.getResource( descriptors );
+        }
+        if( dURL == null ) {
+            return;
+        }
+
+        log.debug( "Found " + dURL);
+        searchedPaths.put( packageName,  dURL );
+        try {
+            if( descriptors.endsWith(".xml" ))
+                loadDescriptors("MbeansDescriptorsDOMSource", dURL, null);
+            else
+                loadDescriptors("MbeansDescriptorsSerSource", dURL, null);
+            return;
+        } catch(Exception ex ) {
+            log.error("Error loading " + dURL);
+        }
+
+        return;
+    }
+
+    /** Experimental. Will become private, some code may still use it
+     *
+     * @param sourceType
+     * @param source
+     * @param param
+     * @throws Exception
+     * @deprecated
+     */
+    public void loadDescriptors( String sourceType, Object source, String param)
+        throws Exception
+    {
+        List mbeans=load( sourceType, source, param );
+        if( mbeans == null) return;
+
+        Iterator itr=mbeans.iterator();
+        while( itr.hasNext() ) {
+            Object mb=itr.next();
+            if( mb instanceof ManagedBean) {
+                addManagedBean((ManagedBean)mb);
+            }
+        }
+    }
+
+    /** Discover all META-INF/modeler.xml files in classpath and register
+     * the components
+     *
+     * @since EXPERIMENTAL
+     */
+    private void loadMetaInfDescriptors(ClassLoader cl) {
+        try {
+            Enumeration en=cl.getResources(MODELER_MANIFEST);
+            while( en.hasMoreElements() ) {
+                URL url=(URL)en.nextElement();
+                InputStream is=url.openStream();
+                if( log.isDebugEnabled()) log.debug("Loading " + url);
+                loadDescriptors("MBeansDescriptorDOMSource", is, null );
+            }
+        } catch( Exception ex ) {
+            ex.printStackTrace();
+        }
+    }
+
+    /** Lookup the component descriptor in the package and
+     * in the parent packages.
+     *
+     * @param beanClass
+     * @param type
+     */
+    private void findDescriptor( Class beanClass, String type ) {
+        if( type==null ) {
+            type=beanClass.getName();
+        }
+        ClassLoader classLoader=null;
+        if( beanClass!=null ) {
+            classLoader=beanClass.getClassLoader();
+        }
+        if( classLoader==null ) {
+            classLoader=Thread.currentThread().getContextClassLoader();
+        }
+        if( classLoader==null ) {
+            classLoader=this.getClass().getClassLoader();
+        }
+        
+        String className=type;
+        String pkg=className;
+        while( pkg.indexOf( ".") > 0 ) {
+            int lastComp=pkg.lastIndexOf( ".");
+            if( lastComp <= 0 ) return;
+            pkg=pkg.substring(0, lastComp);
+            if( searchedPaths.get( pkg ) != null ) {
+                return;
+            }
+            loadDescriptors(pkg, classLoader);
+        }
+        return;
+    }
+
+    private ModelerSource getModelerSource( String type )
+            throws Exception
+    {
+        if( type==null ) type="MbeansDescriptorsDOMSource";
+        if( type.indexOf( ".") < 0 ) {
+            type="org.apache.tomcat.util.modeler.modules." + type;
+        }
+
+        Class c=Class.forName( type );
+        ModelerSource ds=(ModelerSource)c.newInstance();
+        return ds;
+    }
+
+
+    // -------------------- Registration  --------------------
+    
+    public ObjectName preRegister(MBeanServer server,
+                                  ObjectName name) throws Exception 
+    {
+        this.server=server;
+        return name;
+    }
+
+    public void postRegister(Boolean registrationDone) {
+    }
+
+    public void preDeregister() throws Exception {
+    }
+
+    public void postDeregister() {
+    }
+
+    
+    
+    
+    // -------------------- DEPRECATED METHODS  --------------------
+    // May still be used in tomcat 
+    // Never part of an official release
+    
+    /** Called by a registry or by the container to unload a loader
+     * @param loader
+     */
+    public void unregisterRegistry(ClassLoader loader ) {
+        // XXX Cleanup ?
+        perLoaderRegistries.remove(loader);
+    }
+
+    public ManagedBean findManagedBean(Class beanClass, String type)
+        throws Exception
+    {
+        return findManagedBean(null, beanClass, type);        
+    }
+    
+    /**
+     * Set the <code>MBeanServer</code> to be utilized for our
+     * registered management beans.
+     *
+     * @param server The new <code>MBeanServer</code> instance
+     */
+    public void setMBeanServer( MBeanServer server ) {
+        this.server=server;
+    }
+
+    public void resetMetadata() {
+        stop();
+    }
+    /**
+     * Load the registry from the XML input found in the specified input
+     * stream.
+     *
+     * @param source Source to be used to load. Can be an InputStream or URL.
+     *
+     * @exception Exception if any parsing or processing error occurs
+     */
+    public void loadDescriptors( Object source )
+            throws Exception
+    {
+        loadDescriptors("MbeansDescriptorsDOMSource", source, null );
+    }
+
+    /** @deprecated - may still be used in code using pre-1.1 builds
+     */
+    public void registerComponent(Object bean, String domain, String type,
+                                  String name)
+            throws Exception
+    {
+        StringBuffer sb=new StringBuffer();
+        sb.append( domain ).append(":");
+        sb.append( name );
+        String nameStr=sb.toString();
+        ObjectName oname=new ObjectName( nameStr );
+        registerComponent(bean, oname, type );
+    }
+
+    
+
+    // should be removed
+    public void unregisterComponent( String domain, String name ) {
+        try {
+            ObjectName oname=new ObjectName( domain + ":" + name );
+
+            // XXX remove from our tables.
+            getMBeanServer().unregisterMBean( oname );
+        } catch( Throwable t ) {
+            log.error( "Error unregistering mbean ", t );
+        }
+    }
+    
+    public List loadMBeans( Object source )
+            throws Exception
+    {
+        return loadMBeans( source, null );
+    }
+
+
+    /**
+     * Load the registry from a cached .ser file. This is typically 2-3 times
+     * faster than parsing the XML.
+     *
+     * @param source Source to be used to load. Can be an InputStream or URL.
+     *
+     * @exception Exception if any parsing or processing error occurs
+     * @deprecated Loaded automatically or using a File or Url ending in .ser
+     */
+    public void loadCachedDescriptors( Object source )
+            throws Exception
+    {
+        loadDescriptors("MbeansDescriptorsSerSource", source, null );
+    }
+}

==================================================
MbeansDescriptorsDOMSource.java
new file mode 100644
index 0000000000..231203e8f2
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/mbeans-descriptors.dtd
@@ -0,0 +1,233 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+
+
+<!--
+     DTD for the Model MBeans Configuration File
+
+     To support validation of your configuration file, include the following
+     DOCTYPE element at the beginning (after the "xml" declaration):
+
+     <!DOCTYPE mbeans-descriptors PUBLIC
+      "-//Apache Software Foundation//DTD Model MBeans Configuration File"
+      "http://jakarta.apache.org/commons/dtds/mbeans-descriptors.dtd">
+
+     $Id: mbeans-descriptors.dtd 155428 2005-02-26 13:12:25Z dirkv $
+-->
+
+
+<!-- ========== Defined Types ============================================= -->
+
+
+<!-- A "Boolean" is the string representation of a boolean (true or false)
+     variable.
+-->
+<!ENTITY % Boolean "(true|false|yes|no)">
+
+
+<!-- A "ClassName" is the fully qualified name of a Java class that is
+     instantiated to provide the functionality of the enclosing element.
+-->
+<!ENTITY % ClassName "CDATA">
+
+
+<!-- A "MethodName" is the name of a constructor or method, which must
+     be legal according to the syntax requirements of the Java language.
+-->
+<!ENTITY % MethodName "CDATA">
+
+
+<!-- A "VariableName" is the name of a variable or parameter, which must
+     be legal according to the syntax requirements of the Java language.
+-->
+<!ENTITY % VariableName "CDATA">
+
+
+<!-- ========== Element Definitions ======================================= -->
+
+
+<!-- The "mbeans-descriptors" element is the root of the configuration file
+     hierarchy, and contains nested elements for all of the other
+     configuration settings.  Remaining element definitions are listed
+     in alphabetical order.
+-->
+<!ELEMENT mbeans-descriptors (mbean*)>
+<!ATTLIST mbeans-descriptors id          ID             #IMPLIED>
+
+
+<!-- The "attribute" element describes a JavaBeans property of an MBean.
+     The following attributes are supported:
+
+     description      Human-readable description of this attribute.
+
+     displayName      Display name of this attribute.
+
+     getMethod        Name of the property getter method, if it does
+                      not follow standard JavaBeans naming patterns.
+
+     is               Boolean value indicating whether or not this
+                      attribute is a boolean with an "is" getter method.
+                      By default, this is set to "false".
+
+     name             Name of this JavaBeans property, conforming to
+                      standard naming design patterns.
+
+     readable         Boolean value indicating whether or not this
+                      attribute is readable by management applications.
+                      By default, this is set to "true".
+
+     setMethod        Name of the property setter method, if it does
+                      not follow standard JavaBeans naming patterns.
+
+     type             Fully qualified Java class name of this attribute.
+
+     writeable        Boolean value indicating whether or not this
+                      attribute is writeable by management applications.
+                      By default, this is set to "true".
+-->
+<!ELEMENT attribute (descriptor?)>
+<!ATTLIST attribute         id           ID             #IMPLIED>
+<!ATTLIST attribute         description  CDATA          #IMPLIED>
+<!ATTLIST attribute         displayName  CDATA          #IMPLIED>
+<!ATTLIST attribute         getMethod    %MethodName;   #IMPLIED>
+<!ATTLIST attribute         is           %Boolean;      #IMPLIED>
+<!ATTLIST attribute         name         %VariableName; #IMPLIED>
+<!ATTLIST attribute         readable     %Boolean;      #IMPLIED>
+<!ATTLIST attribute         setMethod    %MethodName;   #IMPLIED>
+<!ATTLIST attribute         type         %ClassName;    #IMPLIED>
+<!ATTLIST attribute         writeable    %Boolean;      #IMPLIED>
+
+
+<!-- The "constructor" element describes a public constructor for the
+     underlying actual class.  It may contain nested "parameter" elements
+     for the various arguments to this constructor.  The following attributes
+     are supported:
+
+     displayName      Display name of this constructor.
+
+     name             Name of this constructor (by Java convention, this must
+                      be the same as the base class name).
+-->
+<!ELEMENT constructor (descriptor?, parameter*)>
+<!ATTLIST constructor       id           ID             #IMPLIED>
+<!ATTLIST constructor       displayName  CDATA          #IMPLIED>
+<!ATTLIST constructor       name         %VariableName; #IMPLIED>
+
+
+<!-- The "descriptor" element groups a set of descriptor fields whose
+     values will be included in the Descriptor for the corresponding
+     metatdata info classes.
+-->
+<!ELEMENT descriptor (field*)>
+<!ATTLIST descriptor        id           ID             #IMPLIED>
+
+
+<!-- The "field" element represents a single name/value pair that will
+     be included in the Descriptor corresponding to our enclosing
+     "descriptor" element.  The following attributes are supported:
+
+     name             Field name of the field to be included
+
+     value            Field value of the field to be included
+                      (will be stored as a String)
+-->
+<!ELEMENT field EMPTY>
+<!ATTLIST field             id           ID             #IMPLIED>
+<!ATTLIST field             name         CDATA          #REQUIRED>
+<!ATTLIST field             value        CDATA          #REQUIRED>
+
+
+
+<!-- The "mbean" element describes a particular JMX ModelMBean implementation,
+     including the information necessary to construct the corresponding
+     ModelMBeanInfo structures.  The following attributes are supported:
+
+     className        Fully qualified Java class name of the ModelMBean
+                      implementation class.  If not specified, the standard
+                      implementation provided by JMX will be utilized.
+
+     description      Human-readable description of this managed bean.
+
+     domain           The JMX MBeanServer domain in which the ModelMBean
+                      created by this managed bean should be registered,
+                      when creating its ObjectName.
+
+     group            Optional name of a "grouping classification" that can
+                      be used to select groups of similar MBean implementation
+                      classes.
+
+     name             Unique name of this MBean (normally corresponds to the
+                      base class name of the corresponding server component).
+
+     type             Fully qualified Java class name of the underlying
+                      managed resource implementation class.
+-->
+<!ELEMENT mbean (descriptor?, attribute*, constructor*, notification*, operation*)>
+<!ATTLIST mbean             id           ID             #IMPLIED>
+<!ATTLIST mbean             className    %ClassName;    #IMPLIED>
+<!ATTLIST mbean             description  CDATA          #IMPLIED>
+<!ATTLIST mbean             domain       CDATA          #IMPLIED>
+<!ATTLIST mbean             group        CDATA          #IMPLIED>
+<!ATTLIST mbean             name         %MethodName;   #IMPLIED>
+<!ATTLIST mbean             type         %ClassName;    #IMPLIED>
+
+
+<!-- The "notification" element describes the notification types that are
+     generated by a particular managed bean.  The following attributes
+     are supported:
+
+     description      Human-readable description of these notification events.
+
+     name             Name of this set of notification event types.
+-->
+<!ELEMENT notification (descriptor?, notification-type*)>
+<!ATTLIST notification      id           ID             #IMPLIED>
+<!ATTLIST notification      description  CDATA          #IMPLIED>
+<!ATTLIST notification      name         %VariableName; #IMPLIED>
+
+
+<!-- The nested content of the "notification-type" element is the event string
+     of an event that can be emitted by this MBean.
+-->
+<!ELEMENT notification-type (#PCDATA)>
+<!ATTLIST notification-type id           ID             #IMPLIED>
+
+
+<!-- The "operation" element describes a the signature of a public method
+     that is accessible to management applications.  The following attributes
+     are supported:
+
+     description      Human-readable description of this operation.
+
+     impact           Indication of the impact of this method:
+                      ACTION (write like), ACTION-INFO (write+read like)
+                      INFO (read like), or UNKNOWN.
+
+     name             Name of this public method.
+
+     returnType       Fully qualified Java class name of the return
+                      type of this method.
+-->
+<!ELEMENT operation   (descriptor?, parameter*)>
+<!ATTLIST operation         id           ID             #IMPLIED>
+<!ATTLIST operation         description  CDATA          #IMPLIED>
+<!ATTLIST operation         impact       CDATA          #IMPLIED>
+<!ATTLIST operation         name         %VariableName; #IMPLIED>
+<!ATTLIST operation         returnType   %ClassName;    #IMPLIED>
+
+
+<!-- The "parameter" element describes a single argument that will be passed
+     to a constructor or operation.  The following attributes are supported:
+
+     description      Human-readable description of this parameter.
+
+     name             Java language name of this parameter.
+
+     type             Fully qualified Java class name of this parameter.
+-->
+<!ELEMENT parameter EMPTY>
+<!ATTLIST parameter         id           ID             #IMPLIED>
+<!ATTLIST parameter         description  CDATA          #IMPLIED>
+<!ATTLIST parameter         name         %VariableName; #IMPLIED>
+<!ATTLIST parameter         type         %ClassName;    #IMPLIED>
+
+

==================================================
MbeansDescriptorsDigesterSource.java
new file mode 100644
index 0000000000..3b7314ccb9
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDOMSource.java
@@ -0,0 +1,302 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler.modules;
+
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.tomcat.util.DomUtil;
+import org.apache.tomcat.util.modeler.AttributeInfo;
+import org.apache.tomcat.util.modeler.ConstructorInfo;
+import org.apache.tomcat.util.modeler.FieldInfo;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.NotificationInfo;
+import org.apache.tomcat.util.modeler.OperationInfo;
+import org.apache.tomcat.util.modeler.ParameterInfo;
+import org.apache.tomcat.util.modeler.Registry;
+import org.w3c.dom.Document;
+import org.w3c.dom.Node;
+
+
+public class MbeansDescriptorsDOMSource extends ModelerSource
+{
+    private static Log log = LogFactory.getLog(MbeansDescriptorsDOMSource.class);
+
+    Registry registry;
+    String location;
+    String type;
+    Object source;
+    List mbeans=new ArrayList();
+
+    public void setRegistry(Registry reg) {
+        this.registry=reg;
+    }
+
+    public void setLocation( String loc ) {
+        this.location=loc;
+    }
+
+    /** Used if a single component is loaded
+     *
+     * @param type
+     */
+    public void setType( String type ) {
+       this.type=type;
+    }
+
+    public void setSource( Object source ) {
+        this.source=source;
+    }
+
+    public List loadDescriptors( Registry registry, String location,
+                                 String type, Object source)
+            throws Exception
+    {
+        setRegistry(registry);
+        setLocation(location);
+        setType(type);
+        setSource(source);
+        execute();
+        return mbeans;
+    }
+
+    public void execute() throws Exception {
+        if( registry==null ) registry=Registry.getRegistry();
+
+        try {
+            InputStream stream=(InputStream)source;
+            long t1=System.currentTimeMillis();
+            Document doc=DomUtil.readXml(stream);
+            // Ignore for now the name of the root element
+            Node descriptorsN=doc.getDocumentElement();
+            //Node descriptorsN=DomUtil.getChild(doc, "mbeans-descriptors");
+            if( descriptorsN == null ) {
+                log.error("No descriptors found");
+                return;
+            }
+
+            Node firstMbeanN=null;
+            if( "mbean".equals( descriptorsN.getNodeName() ) ) {
+                firstMbeanN=descriptorsN;
+            } else {
+                firstMbeanN=DomUtil.getChild(descriptorsN, "mbean");
+            }
+
+            if( firstMbeanN==null ) {
+                log.error(" No mbean tags ");
+                return;
+            }
+
+            // Process each <mbean> element
+            for (Node mbeanN = firstMbeanN; mbeanN != null;
+                 mbeanN= DomUtil.getNext(mbeanN))
+            {
+
+                // Create a new managed bean info
+                ManagedBean managed=new ManagedBean();
+                DomUtil.setAttributes(managed, mbeanN);
+                Node firstN;
+
+                // Process descriptor subnode
+                Node mbeanDescriptorN =
+                    DomUtil.getChild(mbeanN, "descriptor");
+                if (mbeanDescriptorN != null) {
+                    Node firstFieldN =
+                        DomUtil.getChild(mbeanDescriptorN, "field");
+                    for (Node fieldN = firstFieldN; fieldN != null;
+                         fieldN = DomUtil.getNext(fieldN)) {
+                        FieldInfo fi = new FieldInfo();
+                        DomUtil.setAttributes(fi, fieldN);
+                        managed.addField(fi);
+                    }
+                }
+
+                // process attribute nodes
+                firstN=DomUtil.getChild( mbeanN, "attribute");
+                for (Node descN = firstN; descN != null;
+                     descN = DomUtil.getNext( descN ))
+                {
+
+                    // Create new attribute info
+                    AttributeInfo ai=new AttributeInfo();
+                    DomUtil.setAttributes(ai, descN);
+
+                    // Process descriptor subnode
+                    Node descriptorN =
+                        DomUtil.getChild(descN, "descriptor");
+                    if (descriptorN != null) {
+                        Node firstFieldN =
+                            DomUtil.getChild(descriptorN, "field");
+                        for (Node fieldN = firstFieldN; fieldN != null;
+                             fieldN = DomUtil.getNext(fieldN)) {
+                            FieldInfo fi = new FieldInfo();
+                            DomUtil.setAttributes(fi, fieldN);
+                            ai.addField(fi);
+                        }
+                    }
+
+                    // Add this info to our managed bean info
+                    managed.addAttribute( ai );
+                    if (log.isTraceEnabled()) {
+                        log.trace("Create attribute " + ai);
+                    }
+
+                }
+
+                // process constructor nodes
+                firstN=DomUtil.getChild( mbeanN, "constructor");
+                for (Node descN = firstN; descN != null;
+                     descN = DomUtil.getNext( descN )) {
+
+                    // Create new constructor info
+                    ConstructorInfo ci=new ConstructorInfo();
+                    DomUtil.setAttributes(ci, descN);
+
+                    // Process descriptor subnode
+                    Node firstDescriptorN =
+                        DomUtil.getChild(descN, "descriptor");
+                    if (firstDescriptorN != null) {
+                        Node firstFieldN =
+                            DomUtil.getChild(firstDescriptorN, "field");
+                        for (Node fieldN = firstFieldN; fieldN != null;
+                             fieldN = DomUtil.getNext(fieldN)) {
+                            FieldInfo fi = new FieldInfo();
+                            DomUtil.setAttributes(fi, fieldN);
+                            ci.addField(fi);
+                        }
+                    }
+
+                    // Process parameter subnodes
+                    Node firstParamN=DomUtil.getChild( descN, "parameter");
+                    for (Node paramN = firstParamN;  paramN != null;
+                         paramN = DomUtil.getNext(paramN))
+                    {
+                        ParameterInfo pi=new ParameterInfo();
+                        DomUtil.setAttributes(pi, paramN);
+                        ci.addParameter( pi );
+                    }
+
+                    // Add this info to our managed bean info
+                    managed.addConstructor( ci );
+                    if (log.isTraceEnabled()) {
+                        log.trace("Create constructor " + ci);
+                    }
+
+                }
+
+                // process notification nodes
+                firstN=DomUtil.getChild( mbeanN, "notification");
+                for (Node descN = firstN; descN != null;
+                     descN = DomUtil.getNext( descN ))
+                {
+
+                    // Create new notification info
+                    NotificationInfo ni=new NotificationInfo();
+                    DomUtil.setAttributes(ni, descN);
+
+                    // Process descriptor subnode
+                    Node firstDescriptorN =
+                        DomUtil.getChild(descN, "descriptor");
+                    if (firstDescriptorN != null) {
+                        Node firstFieldN =
+                            DomUtil.getChild(firstDescriptorN, "field");
+                        for (Node fieldN = firstFieldN; fieldN != null;
+                             fieldN = DomUtil.getNext(fieldN)) {
+                            FieldInfo fi = new FieldInfo();
+                            DomUtil.setAttributes(fi, fieldN);
+                            ni.addField(fi);
+                        }
+                    }
+
+                    // Process notification-type subnodes
+                    Node firstParamN=DomUtil.getChild( descN, "notification-type");
+                    for (Node paramN = firstParamN;  paramN != null;
+                         paramN = DomUtil.getNext(paramN))
+                    {
+                        ni.addNotifType( DomUtil.getContent(paramN) );
+                    }
+
+                    // Add this info to our managed bean info
+                    managed.addNotification( ni );
+                    if (log.isTraceEnabled()) {
+                        log.trace("Created notification " + ni);
+                    }
+
+                }
+
+                // process operation nodes
+                firstN=DomUtil.getChild( mbeanN, "operation");
+                for (Node descN = firstN; descN != null;
+                     descN = DomUtil.getNext( descN ))
+
+                {
+
+                    // Create new operation info
+                    OperationInfo oi=new OperationInfo();
+                    DomUtil.setAttributes(oi, descN);
+
+                    // Process descriptor subnode
+                    Node firstDescriptorN =
+                        DomUtil.getChild(descN, "descriptor");
+                    if (firstDescriptorN != null) {
+                        Node firstFieldN =
+                            DomUtil.getChild(firstDescriptorN, "field");
+                        for (Node fieldN = firstFieldN; fieldN != null;
+                             fieldN = DomUtil.getNext(fieldN)) {
+                            FieldInfo fi = new FieldInfo();
+                            DomUtil.setAttributes(fi, fieldN);
+                            oi.addField(fi);
+                        }
+                    }
+
+                    // Process parameter subnodes
+                    Node firstParamN=DomUtil.getChild( descN, "parameter");
+                    for (Node paramN = firstParamN;  paramN != null;
+                         paramN = DomUtil.getNext(paramN))
+                    {
+                        ParameterInfo pi=new ParameterInfo();
+                        DomUtil.setAttributes(pi, paramN);
+                        if( log.isTraceEnabled())
+                            log.trace("Add param " + pi.getName());
+                        oi.addParameter( pi );
+                    }
+
+                    // Add this info to our managed bean info
+                    managed.addOperation( oi );
+                    if( log.isTraceEnabled()) {
+                        log.trace("Create operation " + oi);
+                    }
+
+                }
+
+                // Add the completed managed bean info to the registry
+                //registry.addManagedBean(managed);
+                mbeans.add( managed );
+
+            }
+
+            long t2=System.currentTimeMillis();
+            log.debug( "Reading descriptors ( dom ) " + (t2-t1));
+        } catch( Exception ex ) {
+            log.error( "Error reading descriptors ", ex);
+        }
+    }
+}

==================================================
MbeansDescriptorsDynamicMBeanSource.java
new file mode 100644
index 0000000000..901926a78e
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDigesterSource.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.modeler.modules;
+
+import java.io.InputStream;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.tomcat.util.digester.Digester;
+import org.apache.tomcat.util.modeler.Registry;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+public class MbeansDescriptorsDigesterSource extends ModelerSource
+{
+    private static Log log =
+            LogFactory.getLog(MbeansDescriptorsDigesterSource.class);
+
+    Registry registry;
+    String location;
+    String type;
+    Object source;
+    List mbeans=new ArrayList();
+
+    public void setRegistry(Registry reg) {
+        this.registry=reg;
+    }
+
+    public void setLocation( String loc ) {
+        this.location=loc;
+    }
+
+    /** Used if a single component is loaded
+     *
+     * @param type
+     */
+    public void setType( String type ) {
+       this.type=type;
+    }
+
+    public void setSource( Object source ) {
+        this.source=source;
+    }
+
+    public List loadDescriptors( Registry registry, String location,
+                                 String type, Object source)
+            throws Exception
+    {
+        setRegistry(registry);
+        setLocation(location);
+        setType(type);
+        setSource(source);
+        execute();
+        return mbeans;
+    }
+
+    public void execute() throws Exception {
+        if( registry==null ) registry=Registry.getRegistry();
+
+        InputStream stream=(InputStream)source;
+
+        long t1=System.currentTimeMillis();
+
+        Digester digester = new Digester();
+        digester.setNamespaceAware(false);
+        digester.setValidating(false);
+        URL url = registry.getClass().getResource
+                ("/org/apache/commons/modeler/mbeans-descriptors.dtd");
+        digester.register
+                ("-//Apache Software Foundation//DTD Model MBeans Configuration File",
+                        url.toString());
+
+        // Push our registry object onto the stack
+        digester.push(mbeans);
+
+        // Configure the parsing rules
+        digester.addObjectCreate
+                ("mbeans-descriptors/mbean",
+                        "org.apache.tomcat.util.modeler.ManagedBean");
+        digester.addSetProperties
+                ("mbeans-descriptors/mbean");
+        digester.addSetNext
+                ("mbeans-descriptors/mbean",
+                        "add",
+                        "java.lang.Object");
+
+        digester.addObjectCreate
+                ("mbeans-descriptors/mbean/attribute",
+                        "org.apache.tomcat.util.modeler.AttributeInfo");
+        digester.addSetProperties
+                ("mbeans-descriptors/mbean/attribute");
+        digester.addSetNext
+                ("mbeans-descriptors/mbean/attribute",
+                        "addAttribute",
+                        "org.apache.tomcat.util.modeler.AttributeInfo");
+
+        digester.addObjectCreate
+            ("mbeans-descriptors/mbean/attribute/descriptor/field",
+             "org.apache.tomcat.util.modeler.FieldInfo");
+        digester.addSetProperties
+            ("mbeans-descriptors/mbean/attribute/descriptor/field");
+        digester.addSetNext
+            ("mbeans-descriptors/mbean/attribute/descriptor/field",
+             "addField",
+             "org.apache.tomcat.util.modeler.FieldInfo");
+
+        digester.addObjectCreate
+                ("mbeans-descriptors/mbean/constructor",
+                        "org.apache.tomcat.util.modeler.ConstructorInfo");
+        digester.addSetProperties
+                ("mbeans-descriptors/mbean/constructor");
+        digester.addSetNext
+                ("mbeans-descriptors/mbean/constructor",
+                        "addConstructor",
+                        "org.apache.tomcat.util.modeler.ConstructorInfo");
+
+        digester.addObjectCreate
+            ("mbeans-descriptors/mbean/constructor/descriptor/field",
+             "org.apache.tomcat.util.modeler.FieldInfo");
+        digester.addSetProperties
+            ("mbeans-descriptors/mbean/constructor/descriptor/field");
+        digester.addSetNext
+            ("mbeans-descriptors/mbean/constructor/descriptor/field",
+             "addField",
+             "org.apache.tomcat.util.modeler.FieldInfo");
+
+        digester.addObjectCreate
+                ("mbeans-descriptors/mbean/constructor/parameter",
+                        "org.apache.tomcat.util.modeler.ParameterInfo");
+        digester.addSetProperties
+                ("mbeans-descriptors/mbean/constructor/parameter");
+        digester.addSetNext
+                ("mbeans-descriptors/mbean/constructor/parameter",
+                        "addParameter",
+                        "org.apache.tomcat.util.modeler.ParameterInfo");
+
+        digester.addObjectCreate
+            ("mbeans-descriptors/mbean/descriptor/field",
+             "org.apache.tomcat.util.modeler.FieldInfo");
+        digester.addSetProperties
+            ("mbeans-descriptors/mbean/descriptor/field");
+        digester.addSetNext
+            ("mbeans-descriptors/mbean/descriptor/field",
+             "addField",
+             "org.apache.tomcat.util.modeler.FieldInfo");
+
+        digester.addObjectCreate
+                ("mbeans-descriptors/mbean/notification",
+                        "org.apache.tomcat.util.modeler.NotificationInfo");
+        digester.addSetProperties
+                ("mbeans-descriptors/mbean/notification");
+        digester.addSetNext
+                ("mbeans-descriptors/mbean/notification",
+                        "addNotification",
+                        "org.apache.tomcat.util.modeler.NotificationInfo");
+
+        digester.addObjectCreate
+            ("mbeans-descriptors/mbean/notification/descriptor/field",
+             "org.apache.tomcat.util.modeler.FieldInfo");
+        digester.addSetProperties
+            ("mbeans-descriptors/mbean/notification/descriptor/field");
+        digester.addSetNext
+            ("mbeans-descriptors/mbean/notification/descriptor/field",
+             "addField",
+             "org.apache.tomcat.util.modeler.FieldInfo");
+
+        digester.addCallMethod
+                ("mbeans-descriptors/mbean/notification/notification-type",
+                        "addNotifType", 0);
+
+        digester.addObjectCreate
+                ("mbeans-descriptors/mbean/operation",
+                        "org.apache.tomcat.util.modeler.OperationInfo");
+        digester.addSetProperties
+                ("mbeans-descriptors/mbean/operation");
+        digester.addSetNext
+                ("mbeans-descriptors/mbean/operation",
+                        "addOperation",
+                        "org.apache.tomcat.util.modeler.OperationInfo");
+
+        digester.addObjectCreate
+            ("mbeans-descriptors/mbean/operation/descriptor/field",
+             "org.apache.tomcat.util.modeler.FieldInfo");
+        digester.addSetProperties
+            ("mbeans-descriptors/mbean/operation/descriptor/field");
+        digester.addSetNext
+            ("mbeans-descriptors/mbean/operation/descriptor/field",
+             "addField",
+             "org.apache.tomcat.util.modeler.FieldInfo");
+
+        digester.addObjectCreate
+                ("mbeans-descriptors/mbean/operation/parameter",
+                        "org.apache.tomcat.util.modeler.ParameterInfo");
+        digester.addSetProperties
+                ("mbeans-descriptors/mbean/operation/parameter");
+        digester.addSetNext
+                ("mbeans-descriptors/mbean/operation/parameter",
+                        "addParameter",
+                        "org.apache.tomcat.util.modeler.ParameterInfo");
+
+        // Process the input file to configure our registry
+        try {
+            digester.parse(stream);
+        } catch (Exception e) {
+            log.error("Error digesting Registry data", e);
+            throw e;
+        }
+        long t2=System.currentTimeMillis();
+//        if( t2-t1 > 500 )
+        log.info("Loaded registry information (digester) " + ( t2 - t1 ) + " ms");
+    }
+}

==================================================
MbeansDescriptorsIntrospectionSource.java
new file mode 100644
index 0000000000..5aa2ff75bc
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDynamicMBeanSource.java
@@ -0,0 +1,157 @@
+package org.apache.tomcat.util.modeler.modules;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.management.DynamicMBean;
+import javax.management.MBeanAttributeInfo;
+import javax.management.MBeanInfo;
+import javax.management.MBeanOperationInfo;
+import javax.management.MBeanParameterInfo;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.tomcat.util.modeler.AttributeInfo;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.OperationInfo;
+import org.apache.tomcat.util.modeler.ParameterInfo;
+import org.apache.tomcat.util.modeler.Registry;
+
+
+/** Extract metadata from a dynamic mbean.
+ * Used to wrap a dynamic mbean in order to implement persistence.
+ * 
+ * This is really an ugly asspect of the JMX spec - we need to convery 
+ * from normal metainfo to model metainfo. The info is the same, but
+ * they use a different class. Just like the DOM spec - where all implementations
+ * get an order of unneeded complexity from the various types. 
+ * 
+ */ 
+public class MbeansDescriptorsDynamicMBeanSource extends ModelerSource
+{
+    private static Log log = LogFactory.getLog(MbeansDescriptorsDynamicMBeanSource.class);
+
+    Registry registry;
+    String location;
+    String type;
+    Object source;
+    List mbeans=new ArrayList();
+
+    public void setRegistry(Registry reg) {
+        this.registry=reg;
+    }
+
+    public void setLocation( String loc ) {
+        this.location=loc;
+    }
+
+    /** Used if a single component is loaded
+     *
+     * @param type
+     */
+    public void setType( String type ) {
+       this.type=type;
+    }
+
+    public void setSource( Object source ) {
+        this.source=source;
+    }
+
+    public List loadDescriptors( Registry registry, String location,
+                                 String type, Object source)
+            throws Exception
+    {
+        setRegistry(registry);
+        setLocation(location);
+        setType(type);
+        setSource(source);
+        execute();
+        return mbeans;
+    }
+
+    public void execute() throws Exception {
+        if( registry==null ) registry=Registry.getRegistry();
+        try {
+            ManagedBean managed=createManagedBean(registry, null, source, type);
+            if( managed==null ) return;
+            managed.setName( type );
+            
+            mbeans.add(managed);
+
+        } catch( Exception ex ) {
+            log.error( "Error reading descriptors ", ex);
+        }
+    }
+
+
+
+    // ------------ Implementation for non-declared introspection classes
+
+
+    /**
+     * XXX Find if the 'className' is the name of the MBean or
+     *       the real class ( I suppose first )
+     * XXX Read (optional) descriptions from a .properties, generated
+     *       from source
+     * XXX Deal with constructors
+     *
+     */
+    public ManagedBean createManagedBean(Registry registry, String domain,
+                                         Object realObj, String type)
+    {
+        if( ! ( realObj instanceof DynamicMBean )) {
+            return null;
+        }
+        DynamicMBean dmb=(DynamicMBean)realObj;
+        
+        ManagedBean mbean= new ManagedBean();
+        
+        MBeanInfo mbi=dmb.getMBeanInfo();
+        
+        try {
+            MBeanAttributeInfo attInfo[]=mbi.getAttributes();
+            for( int i=0; i<attInfo.length; i++ ) {
+                MBeanAttributeInfo mai=attInfo[i];
+                String name=mai.getName();
+
+                AttributeInfo ai=new AttributeInfo();
+                ai.setName( name );
+
+                ai.setType( mai.getType());
+                ai.setReadable( mai.isReadable());
+                ai.setWriteable( mai.isWritable());
+                                                
+                mbean.addAttribute(ai);
+            }
+
+            MBeanOperationInfo opInfo[]=mbi.getOperations();
+            for( int i=0; i<opInfo.length; i++ ) {
+                MBeanOperationInfo moi=opInfo[i];
+                OperationInfo op=new OperationInfo();
+
+                op.setName(moi.getName());
+                op.setReturnType(moi.getReturnType());
+                
+                MBeanParameterInfo parms[]=moi.getSignature();
+                for(int j=0; j<parms.length; j++ ) {
+                    ParameterInfo pi=new ParameterInfo();
+                    pi.setType(parms[i].getType());
+                    pi.setName(parms[i].getName());
+                    op.addParameter(pi);
+                }
+                mbean.addOperation(op);
+            }
+
+            if( log.isDebugEnabled())
+                log.debug("Setting name: " + type );
+
+            mbean.setName( type );
+
+            return mbean;
+        } catch( Exception ex ) {
+            ex.printStackTrace();
+            return null;
+        }
+    }
+
+}

==================================================
MbeansDescriptorsSerSource.java
new file mode 100644
index 0000000000..8c4dc34ade
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsIntrospectionSource.java
@@ -0,0 +1,418 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.util.modeler.modules;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.tomcat.util.modeler.AttributeInfo;
+import org.apache.tomcat.util.modeler.ConstructorInfo;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.OperationInfo;
+import org.apache.tomcat.util.modeler.ParameterInfo;
+import org.apache.tomcat.util.modeler.Registry;
+
+import javax.management.ObjectName;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.Constructor;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.Hashtable;
+import java.util.List;
+
+public class MbeansDescriptorsIntrospectionSource extends ModelerSource
+{
+    private static Log log = LogFactory.getLog(MbeansDescriptorsIntrospectionSource.class);
+
+    Registry registry;
+    String location;
+    String type;
+    Object source;
+    List mbeans=new ArrayList();
+
+    public void setRegistry(Registry reg) {
+        this.registry=reg;
+    }
+
+    public void setLocation( String loc ) {
+        this.location=loc;
+    }
+
+    /** Used if a single component is loaded
+     *
+     * @param type
+     */
+    public void setType( String type ) {
+       this.type=type;
+    }
+
+    public void setSource( Object source ) {
+        this.source=source;
+    }
+
+    public List loadDescriptors( Registry registry, String location,
+                                 String type, Object source)
+            throws Exception
+    {
+        setRegistry(registry);
+        setLocation(location);
+        setType(type);
+        setSource(source);
+        execute();
+        return mbeans;
+    }
+
+    public void execute() throws Exception {
+        if( registry==null ) registry=Registry.getRegistry();
+        try {
+            ManagedBean managed=createManagedBean(registry, null, (Class)source, type);
+            if( managed==null ) return;
+            managed.setName( type );
+
+            mbeans.add(managed);
+
+        } catch( Exception ex ) {
+            log.error( "Error reading descriptors ", ex);
+        }
+    }
+
+
+
+    // ------------ Implementation for non-declared introspection classes
+
+    static Hashtable specialMethods=new Hashtable();
+    static {
+        specialMethods.put( "preDeregister", "");
+        specialMethods.put( "postDeregister", "");
+    }
+
+    private static String strArray[]=new String[0];
+    private static ObjectName objNameArray[]=new ObjectName[0];
+    // createMBean == registerClass + registerMBean
+
+    private static Class[] supportedTypes  = new Class[] {
+        Boolean.class,
+        Boolean.TYPE,
+        Byte.class,
+        Byte.TYPE,
+        Character.class,
+        Character.TYPE,
+        Short.class,
+        Short.TYPE,
+        Integer.class,
+        Integer.TYPE,
+        Long.class,
+        Long.TYPE,
+        Float.class, 
+        Float.TYPE,
+        Double.class,
+        Double.TYPE,
+        String.class,
+        strArray.getClass(),
+        BigDecimal.class,
+        BigInteger.class,
+        ObjectName.class,
+        objNameArray.getClass(),
+        java.io.File.class,
+    };
+    
+    /**
+     * Check if this class is one of the supported types.
+     * If the class is supported, returns true.  Otherwise,
+     * returns false.
+     * @param ret The class to check
+     * @return boolean True if class is supported
+     */ 
+    private boolean supportedType(Class ret) {
+        for (int i = 0; i < supportedTypes.length; i++) {
+            if (ret == supportedTypes[i]) {
+                return true;
+            }
+        }
+        if (isBeanCompatible(ret)) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Check if this class conforms to JavaBeans specifications.
+     * If the class is conformant, returns true.
+     *
+     * @param javaType The class to check
+     * @return boolean True if the class is compatible.
+     */
+    protected boolean isBeanCompatible(Class javaType) {
+        // Must be a non-primitive and non array
+        if (javaType.isArray() || javaType.isPrimitive()) {
+            return false;
+        }
+
+        // Anything in the java or javax package that
+        // does not have a defined mapping is excluded.
+        if (javaType.getName().startsWith("java.") || 
+            javaType.getName().startsWith("javax.")) {
+            return false;
+        }
+
+        try {
+            javaType.getConstructor(new Class[]{});
+        } catch (java.lang.NoSuchMethodException e) {
+            return false;
+        }
+
+        // Make sure superclass is compatible
+        Class superClass = javaType.getSuperclass();
+        if (superClass != null && 
+            superClass != java.lang.Object.class && 
+            superClass != java.lang.Exception.class && 
+            superClass != java.lang.Throwable.class) {
+            if (!isBeanCompatible(superClass)) {
+                return false;
+            }
+        }
+        return true;
+    }
+    
+    /** 
+     * Process the methods and extract 'attributes', methods, etc
+     *
+     * @param realClass The class to process
+     * @param methods The methods to process
+     * @param attMap The attribute map (complete)
+     * @param getAttMap The readable attributess map
+     * @param setAttMap The settable attributes map
+     * @param invokeAttMap The invokable attributes map
+     */
+    private void initMethods(Class realClass,
+                             Method methods[],
+                             Hashtable attMap, Hashtable getAttMap,
+                             Hashtable setAttMap, Hashtable invokeAttMap)
+    {
+        for (int j = 0; j < methods.length; ++j) {
+            String name=methods[j].getName();
+
+            if( Modifier.isStatic(methods[j].getModifiers()))
+                continue;
+            if( ! Modifier.isPublic( methods[j].getModifiers() ) ) {
+                if( log.isDebugEnabled())
+                    log.debug("Not public " + methods[j] );
+                continue;
+            }
+            if( methods[j].getDeclaringClass() == Object.class )
+                continue;
+            Class params[]=methods[j].getParameterTypes();
+
+            if( name.startsWith( "get" ) && params.length==0) {
+                Class ret=methods[j].getReturnType();
+                if( ! supportedType( ret ) ) {
+                    if( log.isDebugEnabled() )
+                        log.debug("Unsupported type " + methods[j]);
+                    continue;
+                }
+                name=unCapitalize( name.substring(3));
+
+                getAttMap.put( name, methods[j] );
+                // just a marker, we don't use the value
+                attMap.put( name, methods[j] );
+            } else if( name.startsWith( "is" ) && params.length==0) {
+                Class ret=methods[j].getReturnType();
+                if( Boolean.TYPE != ret  ) {
+                    if( log.isDebugEnabled() )
+                        log.debug("Unsupported type " + methods[j] + " " + ret );
+                    continue;
+                }
+                name=unCapitalize( name.substring(2));
+
+                getAttMap.put( name, methods[j] );
+                // just a marker, we don't use the value
+                attMap.put( name, methods[j] );
+
+            } else if( name.startsWith( "set" ) && params.length==1) {
+                if( ! supportedType( params[0] ) ) {
+                    if( log.isDebugEnabled() )
+                        log.debug("Unsupported type " + methods[j] + " " + params[0]);
+                    continue;
+                }
+                name=unCapitalize( name.substring(3));
+                setAttMap.put( name, methods[j] );
+                attMap.put( name, methods[j] );
+            } else {
+                if( params.length == 0 ) {
+                    if( specialMethods.get( methods[j].getName() ) != null )
+                        continue;
+                    invokeAttMap.put( name, methods[j]);
+                } else {
+                    boolean supported=true;
+                    for( int i=0; i<params.length; i++ ) {
+                        if( ! supportedType( params[i])) {
+                            supported=false;
+                            break;
+                        }
+                    }
+                    if( supported )
+                        invokeAttMap.put( name, methods[j]);
+                }
+            }
+        }
+    }
+
+    /**
+     * XXX Find if the 'className' is the name of the MBean or
+     *       the real class ( I suppose first )
+     * XXX Read (optional) descriptions from a .properties, generated
+     *       from source
+     * XXX Deal with constructors
+     *
+     * @param registry The Bean registry (not used)
+     * @param domain The bean domain (not used)
+     * @param realClass The class to analyze
+     * @param type The bean type
+     * @return ManagedBean The create MBean
+     */
+    public ManagedBean createManagedBean(Registry registry, String domain,
+                                         Class realClass, String type)
+    {
+        ManagedBean mbean= new ManagedBean();
+
+        Method methods[]=null;
+
+        Hashtable attMap=new Hashtable();
+        // key: attribute val: getter method
+        Hashtable getAttMap=new Hashtable();
+        // key: attribute val: setter method
+        Hashtable setAttMap=new Hashtable();
+        // key: operation val: invoke method
+        Hashtable invokeAttMap=new Hashtable();
+
+        methods = realClass.getMethods();
+
+        initMethods(realClass, methods, attMap, getAttMap, setAttMap, invokeAttMap );
+
+        try {
+
+            Enumeration en=attMap.keys();
+            while( en.hasMoreElements() ) {
+                String name=(String)en.nextElement();
+                AttributeInfo ai=new AttributeInfo();
+                ai.setName( name );
+                Method gm=(Method)getAttMap.get(name);
+                if( gm!=null ) {
+                    //ai.setGetMethodObj( gm );
+                    ai.setGetMethod( gm.getName());
+                    Class t=gm.getReturnType();
+                    if( t!=null )
+                        ai.setType( t.getName() );
+                }
+                Method sm=(Method)setAttMap.get(name);
+                if( sm!=null ) {
+                    //ai.setSetMethodObj(sm);
+                    Class t=sm.getParameterTypes()[0];
+                    if( t!=null )
+                        ai.setType( t.getName());
+                    ai.setSetMethod( sm.getName());
+                }
+                ai.setDescription("Introspected attribute " + name);
+                if( log.isDebugEnabled()) log.debug("Introspected attribute " +
+                        name + " " + gm + " " + sm);
+                if( gm==null )
+                    ai.setReadable(false);
+                if( sm==null )
+                    ai.setWriteable(false);
+                if( sm!=null || gm!=null )
+                    mbean.addAttribute(ai);
+            }
+
+            en=invokeAttMap.keys();
+            while( en.hasMoreElements() ) {
+                String name=(String)en.nextElement();
+                Method m=(Method)invokeAttMap.get(name);
+                if( m!=null && name != null ) {
+                    OperationInfo op=new OperationInfo();
+                    op.setName(name);
+                    op.setReturnType(m.getReturnType().getName());
+                    op.setDescription("Introspected operation " + name);
+                    Class parms[]=m.getParameterTypes();
+                    for(int i=0; i<parms.length; i++ ) {
+                        ParameterInfo pi=new ParameterInfo();
+                        pi.setType(parms[i].getName());
+                        pi.setName( "param" + i);
+                        pi.setDescription("Introspected parameter param" + i);
+                        op.addParameter(pi);
+                    }
+                    mbean.addOperation(op);
+                } else {
+                    log.error("Null arg " + name + " " + m );
+                }
+            }
+
+            Constructor[] constructors = realClass.getConstructors();
+            for(int i=0;i<constructors.length;i++) {
+                ConstructorInfo info = new ConstructorInfo();
+                String className = realClass.getName();
+                int nIndex = -1;
+                if((nIndex = className.lastIndexOf('.'))!=-1) {
+                    className = className.substring(nIndex+1);
+                }
+                info.setName(className);
+                info.setDescription(constructors[i].getName());
+                Class classes[] = constructors[i].getParameterTypes();
+                for(int j=0;j<classes.length;j++) {
+                    ParameterInfo pi = new ParameterInfo();
+                    pi.setType(classes[j].getName());
+                    pi.setName("param" + j);
+                    pi.setDescription("Introspected parameter param" + j);
+                    info.addParameter(pi);
+                }
+                mbean.addConstructor(info);
+            }
+            
+            if( log.isDebugEnabled())
+                log.debug("Setting name: " + type );
+            mbean.setName( type );
+
+            return mbean;
+        } catch( Exception ex ) {
+            ex.printStackTrace();
+            return null;
+        }
+    }
+
+
+    // -------------------- Utils --------------------
+    /**
+     * Converts the first character of the given
+     * String into lower-case.
+     *
+     * @param name The string to convert
+     * @return String
+     */
+    private static String unCapitalize(String name) {
+        if (name == null || name.length() == 0) {
+            return name;
+        }
+        char chars[] = name.toCharArray();
+        chars[0] = Character.toLowerCase(chars[0]);
+        return new String(chars);
+    }
+
+}
+
+// End of class: MbeanDescriptorsIntrospectionSource

==================================================
MbeansSource.java
new file mode 100644
index 0000000000..6533f5a94d
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsSerSource.java
@@ -0,0 +1,88 @@
+package org.apache.tomcat.util.modeler.modules;
+
+import java.io.InputStream;
+import java.io.ObjectInputStream;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.Registry;
+
+
+public class MbeansDescriptorsSerSource extends ModelerSource
+{
+    private static Log log = LogFactory.getLog(MbeansDescriptorsSerSource.class);
+    Registry registry;
+    String location;
+    String type;
+    Object source;
+    List mbeans=new ArrayList();
+
+    public void setRegistry(Registry reg) {
+        this.registry=reg;
+    }
+
+    public void setLocation( String loc ) {
+        this.location=loc;
+    }
+
+    /** Used if a single component is loaded
+     *
+     * @param type
+     */
+    public void setType( String type ) {
+       this.type=type;
+    }
+
+    public void setSource( Object source ) {
+        this.source=source;
+    }
+
+    public List loadDescriptors( Registry registry, String location,
+                                 String type, Object source)
+            throws Exception
+    {
+        setRegistry(registry);
+        setLocation(location);
+        setType(type);
+        setSource(source);
+        execute();
+        return mbeans;
+    }
+
+    public void execute() throws Exception {
+        if( registry==null ) registry=Registry.getRegistry();
+        long t1=System.currentTimeMillis();
+        try {
+            InputStream stream=null;
+            if( source instanceof URL ) {
+                stream=((URL)source).openStream();
+            }
+            if( source instanceof InputStream ) {
+                stream=(InputStream)source;
+            }
+            if( stream==null ) {
+                throw new Exception( "Can't process "+ source);
+            }
+            ObjectInputStream ois=new ObjectInputStream(stream);
+            Thread.currentThread().setContextClassLoader(ManagedBean.class.getClassLoader());
+            Object obj=ois.readObject();
+            //log.info("Reading " + obj);
+            ManagedBean beans[]=(ManagedBean[])obj;
+            // after all are read without error
+            for( int i=0; i<beans.length; i++ ) {
+                mbeans.add(beans[i]);
+            }
+
+        } catch( Exception ex ) {
+            log.error( "Error reading descriptors " + source + " " +  ex.toString(),
+                    ex);
+            throw ex;
+        }
+        long t2=System.currentTimeMillis();
+        log.info( "Reading descriptors ( ser ) " + (t2-t1));
+    }
+}

==================================================
MbeansSourceMBean.java
new file mode 100644
index 0000000000..44f2164dba
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansSource.java
@@ -0,0 +1,350 @@
+package org.apache.tomcat.util.modeler.modules;
+
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import javax.management.Attribute;
+import javax.management.MBeanServer;
+import javax.management.ObjectName;
+import javax.management.loading.MLet;
+import javax.xml.transform.TransformerException;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.tomcat.util.DomUtil;
+import org.apache.tomcat.util.modeler.AttributeInfo;
+import org.apache.tomcat.util.modeler.BaseModelMBean;
+import org.apache.tomcat.util.modeler.ManagedBean;
+import org.apache.tomcat.util.modeler.Registry;
+import org.w3c.dom.Document;
+import org.w3c.dom.Node;
+
+
+/** This will create mbeans based on a config file.
+ *  The format is an extended version of MLET.
+ *
+ * Classloading. We don't support any explicit classloader tag. 
+ * A ClassLoader is just an mbean ( it can be the standard MLetMBean or
+ * a custom one ). 
+ * 
+ * XXX add a special attribute to reference the loader mbean,
+ * XXX figure out how to deal with private loaders
+ */
+public class MbeansSource extends ModelerSource implements MbeansSourceMBean
+{
+    private static Log log = LogFactory.getLog(MbeansSource.class);
+    Registry registry;
+    String type;
+
+    // true if we are during the original loading
+    boolean loading=true;
+    List mbeans=new ArrayList();
+    static boolean loaderLoaded=false;
+    private Document document;
+    private HashMap object2Node = new HashMap();
+
+    long lastUpdate;
+    long updateInterval=10000; // 10s
+
+    public void setRegistry(Registry reg) {
+        this.registry=reg;
+    }          
+
+    public void setLocation( String loc ) {
+        this.location=loc;
+    }
+
+    /** Used if a single component is loaded
+     *
+     * @param type
+     */
+    public void setType( String type ) {
+       this.type=type;
+    }
+
+    public void setSource( Object source ) {
+        this.source=source;
+    }
+
+    public Object getSource() {
+        return source;
+    }
+
+    public String getLocation() {
+        return location;
+    }
+    
+    /** Return the list of mbeans created by this source.
+     *  It can be used to implement runtime services.
+     */
+    public List getMBeans() {
+        return mbeans;
+    }
+
+    public List loadDescriptors( Registry registry, String location,
+                                 String type, Object source)
+            throws Exception
+    {
+        setRegistry(registry);
+        setLocation(location);
+        setType(type);
+        setSource(source);
+        execute();
+        return mbeans;
+    }
+    
+    public void start() throws Exception {
+        registry.invoke(mbeans, "start", false);        
+    }
+
+    public void stop() throws Exception {
+        registry.invoke(mbeans, "stop", false);        
+    }
+    
+    public void init() throws Exception {
+        if( mbeans==null) execute();
+        if( registry==null ) registry=Registry.getRegistry();
+        
+        registry.invoke(mbeans, "init", false);
+    }
+    
+    public void destroy() throws Exception {
+        registry.invoke(mbeans, "destroy", false);                
+    }
+    
+    public void load() throws Exception {
+        execute(); // backward compat
+    }
+
+    public void execute() throws Exception {
+        if( registry==null ) registry=Registry.getRegistry();
+        try {
+            InputStream stream=getInputStream();
+            long t1=System.currentTimeMillis();
+            document = DomUtil.readXml(stream);
+
+            // We don't care what the root node is.
+            Node descriptorsN=document.getDocumentElement();
+
+            if( descriptorsN == null ) {
+                log.error("No descriptors found");
+                return;
+            }
+
+            Node firstMbeanN=DomUtil.getChild(descriptorsN, null);
+
+            if( firstMbeanN==null ) {
+                // maybe we have a single mlet
+                if( log.isDebugEnabled() )
+                    log.debug("No child " + descriptorsN);
+                firstMbeanN=descriptorsN;
+            }
+
+            MBeanServer server=(MBeanServer)Registry.getServer();
+
+            // XXX Not very clean...  Just a workaround
+            if( ! loaderLoaded ) {
+                // Register a loader that will be find ant classes.
+                ObjectName defaultLoader= new ObjectName("modeler",
+                        "loader", "modeler");
+                MLet mlet=new MLet( new URL[0], this.getClass().getClassLoader());
+                server.registerMBean(mlet, defaultLoader);
+                loaderLoaded=true;
+            }
+        
+            // Process nodes
+            for (Node mbeanN = firstMbeanN; mbeanN != null;
+                 mbeanN= DomUtil.getNext(mbeanN, null, Node.ELEMENT_NODE))
+            {
+                String nodeName=mbeanN.getNodeName();
+
+                // mbean is the "official" name
+                if( "mbean".equals(nodeName) || "MLET".equals(nodeName) )
+                {
+                    String code=DomUtil.getAttribute( mbeanN, "code" );
+                    String objectName=DomUtil.getAttribute( mbeanN, "objectName" );
+                    if( objectName==null ) {
+                        objectName=DomUtil.getAttribute( mbeanN, "name" );
+                    }
+                    
+                    if( log.isDebugEnabled())
+                        log.debug( "Processing mbean objectName=" + objectName +
+                                " code=" + code);
+
+                    // args can be grouped in constructor or direct childs
+                    Node constructorN=DomUtil.getChild(mbeanN, "constructor");
+                    if( constructorN == null ) constructorN=mbeanN;
+
+                    processArg(constructorN);
+
+                    try {
+                        ObjectName oname=new ObjectName(objectName);
+                        if( ! server.isRegistered( oname )) {
+                            // We wrap everything in a model mbean.
+                            // XXX need to support "StandardMBeanDescriptorsSource"
+                            String modelMBean=BaseModelMBean.class.getName();                            
+                            server.createMBean(modelMBean, oname,
+                                    new Object[] { code, this},
+                                    new String[] { String.class.getName(),
+                                                  ModelerSource.class.getName() } 
+                                    );
+                            mbeans.add(oname);
+                        }
+                        object2Node.put( oname, mbeanN );
+                        // XXX Arguments, loader !!!
+                    } catch( Exception ex ) {
+                        log.error( "Error creating mbean " + objectName, ex);
+                    }
+
+                    Node firstAttN=DomUtil.getChild(mbeanN, "attribute");
+                    for (Node descN = firstAttN; descN != null;
+                         descN = DomUtil.getNext( descN ))
+                    {
+                        processAttribute(server, descN, objectName);
+                    }
+                } else if("jmx-operation".equals(nodeName) ) {
+                    String name=DomUtil.getAttribute(mbeanN, "objectName");
+                    if( name==null )
+                        name=DomUtil.getAttribute(mbeanN, "name");
+
+                    String operation=DomUtil.getAttribute(mbeanN, "operation");
+
+                    if( log.isDebugEnabled())
+                        log.debug( "Processing invoke objectName=" + name +
+                                " code=" + operation);
+                    try {
+                        ObjectName oname=new ObjectName(name);
+
+                        processArg( mbeanN );
+                        server.invoke( oname, operation, null, null);
+                    } catch (Exception e) {
+                        log.error( "Error in invoke " + name + " " + operation);
+                    }
+                }
+
+                ManagedBean managed=new ManagedBean();
+                DomUtil.setAttributes(managed, mbeanN);
+                Node firstN;
+
+                // process attribute info
+                firstN=DomUtil.getChild( mbeanN, "attribute");
+                for (Node descN = firstN; descN != null;
+                     descN = DomUtil.getNext( descN ))
+                {
+                    AttributeInfo ci=new AttributeInfo();
+                    DomUtil.setAttributes(ci, descN);
+                    managed.addAttribute( ci );
+                }
+
+            }
+
+            long t2=System.currentTimeMillis();
+            log.info( "Reading mbeans  " + (t2-t1));
+            loading=false;
+        } catch( Exception ex ) {
+            log.error( "Error reading mbeans ", ex);
+        }
+    }
+    
+    public void updateField( ObjectName oname, String name, 
+                             Object value )
+    {
+        if( loading ) return;
+        // nothing by default
+        //log.info( "XXX UpdateField " + oname + " " + name + " " + value);
+        Node n=(Node)object2Node.get( oname );
+        if( n == null ) {
+            log.info( "Node not found " + oname );
+            return;
+        }
+        Node attNode=DomUtil.findChildWithAtt(n, "attribute", "name", name);
+        if( attNode == null ) {
+            // found no existing attribute with this name
+            attNode=n.getOwnerDocument().createElement("attribute");
+            DomUtil.setAttribute(attNode, "name", name);
+            n.appendChild(attNode);
+        } 
+        String oldValue=DomUtil.getAttribute(attNode, "value");
+        if( oldValue != null ) {
+            // we'll convert all values to text content
+            DomUtil.removeAttribute( attNode, "value");
+        }
+        DomUtil.setText(attNode, value.toString());
+
+        //store();
+    }
+    
+    /** Store the mbeans. 
+     * XXX add a background thread to store it periodically 
+     */ 
+    public void save() {
+        // XXX customize no often than ( based on standard descriptor ), etc.
+        // It doesn't work very well if we call this on each set att - 
+        // the triger will work for the first att, but all others will be delayed
+        long time=System.currentTimeMillis();
+        if( location!=null &&
+                time - lastUpdate > updateInterval ) {
+            lastUpdate=time;
+            try {
+                FileOutputStream fos=new FileOutputStream(location);
+                DomUtil.writeXml(document, fos);
+            } catch (TransformerException e) {
+                log.error( "Error writing");
+            } catch (FileNotFoundException e) {
+                log.error( "Error writing" ,e );
+            }
+        }
+    }
+
+    private void processAttribute(MBeanServer server,
+                                  Node descN, String objectName ) {
+        String attName=DomUtil.getAttribute(descN, "name");
+        String value=DomUtil.getAttribute(descN, "value");
+        String type=null; // DomUtil.getAttribute(descN, "type");
+        if( value==null ) {
+            // The value may be specified as CDATA
+            value=DomUtil.getContent(descN);
+        }
+        try {
+            if( log.isDebugEnabled())
+                log.debug("Set attribute " + objectName + " " + attName +
+                        " " + value);
+            ObjectName oname=new ObjectName(objectName);
+            // find the type
+            if( type==null )
+                type=registry.getType(  oname, attName );
+
+            if( type==null ) {
+                log.info("Can't find attribute " + objectName + " " + attName );
+
+            } else {
+                Object valueO=registry.convertValue( type, value);
+                server.setAttribute(oname, new Attribute(attName, valueO));
+            }
+        } catch( Exception ex) {
+            log.error("Error processing attribute " + objectName + " " +
+                    attName + " " + value, ex);
+        }
+
+    }
+
+    private void processArg(Node mbeanN) {
+        Node firstArgN=DomUtil.getChild(mbeanN, "arg" );
+        // process all args
+        for (Node argN = firstArgN; argN != null;
+             argN = DomUtil.getNext( argN ))
+        {
+            String type=DomUtil.getAttribute(argN, "type");
+            String value=DomUtil.getAttribute(argN, "value");
+            if( value==null ) {
+                // The value may be specified as CDATA
+                value=DomUtil.getContent(argN);
+            }
+        }
+    }
+}

==================================================
ModelerSource.java
new file mode 100644
index 0000000000..c577d842ca
--- /dev/null
+++ b/java/org/apache/tomcat/util/modeler/modules/MbeansSourceMBean.java
@@ -0,0 +1,42 @@
+package org.apache.tomcat.util.modeler.modules;
+
+import java.util.List;
+
+
+/**
+ * This mbean will load an extended mlet file ( similar in syntax with jboss ).
+ * It'll keep track of all attribute changes and update the file when attributes
+ * change. 
+ */
+public interface MbeansSourceMBean 
+{
+    /** Set the source to be used to load the mbeans
+     * 
+     * @param source File or URL
+     */ 
+    public void setSource( Object source );
+    
+    public Object getSource();
+    
+    /** Return the list of loaded mbeans names
+     * 
+     * @return List of ObjectName
+     */ 
+    public List getMBeans();
+
+    /** Load the mbeans from the source. Called automatically on init() 
+     * 
+     * @throws Exception
+     */ 
+    public void load() throws Exception;
+    
+    /** Call the init method on all mbeans. Will call load if not done already
+     * 
+     * @throws Exception
+     */ 
+    public void init() throws Exception;
+
+    /** Save the file.
+     */ 
+    public void save();
+}

==================================================
