b5d26de8be048c734b2a0cdefd6bd4ccb662c8a3
==================================================
Allow Checkstyle's unused imports test to be used with the o.a.el package
==================================================
Mark Emlyn
==================================================
Sun Oct 24 11:55:10 2010 +0000
==================================================
MethodExpressionImpl.java
Allow Checkstyle's unused imports test to be used with the o.a.el package
Fix Eclipse warnings


git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1026769 13f79535-47bb-0310-9956-ffa450edef68



==================================================
MethodExpressionLiteral.java
index 1f45aca859..e3fea05d91 100644
--- a/java/org/apache/el/MethodExpressionImpl.java
+++ b/java/org/apache/el/MethodExpressionImpl.java
@@ -24,9 +24,6 @@ import java.io.ObjectOutput;
 
 import javax.el.ELContext;
 import javax.el.ELException;
-import javax.el.ELResolver;
-import javax.el.Expression;
-import javax.el.ExpressionFactory;
 import javax.el.FunctionMapper;
 import javax.el.MethodExpression;
 import javax.el.MethodInfo;
@@ -44,7 +41,7 @@ import org.apache.el.util.ReflectionUtil;
  * An <code>Expression</code> that refers to a method on an object.
  * 
  * <p>
- * <code>The {@link ExpressionFactory#createMethodExpression} method
+ * <code>The {@link javax.el.ExpressionFactory#createMethodExpression} method
  * can be used to parse an expression string and return a concrete instance
  * of <code>MethodExpression</code> that encapsulates the parsed expression.
  * The {@link FunctionMapper} is used at parse time, not evaluation time, 
@@ -52,13 +49,13 @@ import org.apache.el.util.ReflectionUtil;
  * However, the {@link ELContext} is needed at evaluation time.</p>
  *
  * <p>The {@link #getMethodInfo} and {@link #invoke} methods will evaluate the 
- * expression each time they are called. The {@link ELResolver} in the 
+ * expression each time they are called. The {@link javax.el.ELResolver} in the 
  * <code>ELContext</code> is used to resolve the top-level variables and to 
  * determine the behavior of the <code>.</code> and <code>[]</code> 
- * operators. For any of the two methods, the {@link ELResolver#getValue} 
- * method is used to resolve all properties up to but excluding the last 
- * one. This provides the <code>base</code> object on which the method
- * appears. If the <code>base</code> object is null, a 
+ * operators. For any of the two methods, the
+ * {@link javax.el.ELResolver#getValue} method is used to resolve all properties
+ * up to but excluding the last one. This provides the <code>base</code> object
+ * on which the method appears. If the <code>base</code> object is null, a 
  * <code>NullPointerException</code> must be thrown. At the last resolution, 
  * the final <code>property</code> is then coerced to a <code>String</code>,
  * which provides the name of the method to be found. A method matching the 
@@ -67,7 +64,7 @@ import org.apache.el.util.ReflectionUtil;
  * <code>MethodExpression</code>).</p>
  *
  * <p>See the notes about comparison, serialization and immutability in 
- * the {@link Expression} javadocs.
+ * the {@link javax.el.Expression} javadocs.
  *
  * @see javax.el.ELResolver
  * @see javax.el.Expression
@@ -286,6 +283,7 @@ public final class MethodExpressionImpl extends MethodExpression implements
      * 
      * @see java.io.Externalizable#readExternal(java.io.ObjectInput)
      */
+    @Override
     public void readExternal(ObjectInput in) throws IOException,
             ClassNotFoundException {
         this.expr = in.readUTF();
@@ -304,6 +302,7 @@ public final class MethodExpressionImpl extends MethodExpression implements
      * 
      * @see java.io.Externalizable#writeExternal(java.io.ObjectOutput)
      */
+    @Override
     public void writeExternal(ObjectOutput out) throws IOException {
         out.writeUTF(this.expr);
         out.writeUTF((this.expectedType != null) ? this.expectedType.getName()

==================================================
ValueExpressionImpl.java
index dc771e42da..ebe9856271 100644
--- a/java/org/apache/el/MethodExpressionLiteral.java
+++ b/java/org/apache/el/MethodExpressionLiteral.java
@@ -84,6 +84,7 @@ public class MethodExpressionLiteral extends MethodExpression implements Externa
         return true;
     }
 
+    @Override
     public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
         this.expr = in.readUTF();
         String type = in.readUTF();
@@ -94,6 +95,7 @@ public class MethodExpressionLiteral extends MethodExpression implements Externa
                 .readObject()));
     }
 
+    @Override
     public void writeExternal(ObjectOutput out) throws IOException {
         out.writeUTF(this.expr);
         out.writeUTF((this.expectedType != null) ? this.expectedType.getName()

==================================================
ValueExpressionLiteral.java
index 0550261071..873d29589d 100644
--- a/java/org/apache/el/ValueExpressionImpl.java
+++ b/java/org/apache/el/ValueExpressionImpl.java
@@ -24,9 +24,6 @@ import java.io.ObjectOutput;
 
 import javax.el.ELContext;
 import javax.el.ELException;
-import javax.el.ELResolver;
-import javax.el.Expression;
-import javax.el.ExpressionFactory;
 import javax.el.FunctionMapper;
 import javax.el.PropertyNotFoundException;
 import javax.el.PropertyNotWritableException;
@@ -58,7 +55,7 @@ import org.apache.el.util.ReflectionUtil;
  * </p>
  * 
  * <p>
- * <code>The {@link ExpressionFactory#createValueExpression} method
+ * <code>The {@link javax.el.ExpressionFactory#createValueExpression} method
  * can be used to parse an expression string and return a concrete instance
  * of <code>ValueExpression</code> that encapsulates the parsed expression.
  * The {@link FunctionMapper} is used at parse time, not evaluation time, 
@@ -67,20 +64,20 @@ import org.apache.el.util.ReflectionUtil;
  *
  * <p>The {@link #getValue}, {@link #setValue}, {@link #isReadOnly} and
  * {@link #getType} methods will evaluate the expression each time they are
- * called. The {@link ELResolver} in the <code>ELContext</code> is used to 
- * resolve the top-level variables and to determine the behavior of the
+ * called. The {@link javax.el.ELResolver} in the <code>ELContext</code> is used
+ * to resolve the top-level variables and to determine the behavior of the
  * <code>.</code> and <code>[]</code> operators. For any of the four methods,
- * the {@link ELResolver#getValue} method is used to resolve all properties 
- * up to but excluding the last one. This provides the <code>base</code> 
- * object. At the last resolution, the <code>ValueExpression</code> will 
- * call the corresponding {@link ELResolver#getValue}, 
- * {@link ELResolver#setValue}, {@link ELResolver#isReadOnly} or 
- * {@link ELResolver#getType} method, depending on which was called on 
- * the <code>ValueExpression</code>.
+ * the {@link javax.el.ELResolver#getValue} method is used to resolve all
+ * properties up to but excluding the last one. This provides the
+ * <code>base</code> object. At the last resolution, the
+ * <code>ValueExpression</code> will call the corresponding
+ * {@link javax.el.ELResolver#getValue}, {@link javax.el.ELResolver#setValue},
+ * {@link javax.el.ELResolver#isReadOnly} or {@link javax.el.ELResolver#getType}
+ * method, depending on which was called on the <code>ValueExpression</code>.
  * </p>
  *
  * <p>See the notes about comparison, serialization and immutability in 
- * the {@link Expression} javadocs.
+ * the {@link javax.el.Expression} javadocs.
  *
  * @see javax.el.ELResolver
  * @see javax.el.Expression
@@ -233,6 +230,7 @@ public final class ValueExpressionImpl extends ValueExpression implements
         return this.getNode().isReadOnly(ctx);
     }
 
+    @Override
     public void readExternal(ObjectInput in) throws IOException,
             ClassNotFoundException {
         this.expr = in.readUTF();
@@ -259,6 +257,7 @@ public final class ValueExpressionImpl extends ValueExpression implements
         this.getNode().setValue(ctx, value);
     }
 
+    @Override
     public void writeExternal(ObjectOutput out) throws IOException {
         out.writeUTF(this.expr);
         out.writeUTF((this.expectedType != null) ? this.expectedType.getName()

==================================================
