d57597db544f037729585774e56c43a881363144
==================================================
Refactor the connectors to allow lighter weight UpgradeProcessor
==================================================
Mark Emlyn
==================================================
Tue Feb 7 12:25:57 2012 +0000
==================================================
AbstractProcessor.java
Refactor the connectors to allow lighter weight UpgradeProcessor
implementations that do not depend on Http11Processors.
The main change is the expansion of the Processor interface and the
use of that interface rather than the AbstractProcessor.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1241441 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractProtocol.java
index 9b1a598248..f63b4b2680 100644
--- a/java/org/apache/coyote/AbstractProcessor.java
+++ b/java/org/apache/coyote/AbstractProcessor.java
@@ -29,10 +29,10 @@ import org.apache.tomcat.util.net.SocketWrapper;
  * Provides functionality and attributes common to all supported protocols
  * (currently HTTP and AJP).
  */
-public abstract class AbstractProcessor<S> implements ActionHook, Processor {
+public abstract class AbstractProcessor<S> implements ActionHook, Processor<S> {
 
     protected Adapter adapter;
-    protected AsyncStateMachine asyncStateMachine;
+    protected AsyncStateMachine<S> asyncStateMachine;
     protected AbstractEndpoint endpoint;
     protected Request request;
     protected Response response;
@@ -48,7 +48,7 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor {
 
     public AbstractProcessor(AbstractEndpoint endpoint) {
         this.endpoint = endpoint;
-        asyncStateMachine = new AsyncStateMachine(this);
+        asyncStateMachine = new AsyncStateMachine<S>(this);
 
         request = new Request();
 
@@ -70,6 +70,7 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor {
     /**
      * The request associated with this processor.
      */
+    @Override
     public Request getRequest() {
         return request;
     }
@@ -104,42 +105,51 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor {
     }
 
 
+    @Override
     public boolean isAsync() {
         return (asyncStateMachine != null && asyncStateMachine.isAsync());
     }
 
 
+    @Override
     public SocketState asyncPostProcess() {
         return asyncStateMachine.asyncPostProcess();
     }
 
-    protected abstract boolean isComet();
+    @Override
+    public abstract boolean isComet();
 
-    protected abstract boolean isUpgrade();
+    @Override
+    public abstract boolean isUpgrade();
 
     /**
      * Process HTTP requests. All requests are treated as HTTP requests to start
      * with although they may change type during processing.
      */
+    @Override
     public abstract SocketState process(SocketWrapper<S> socket)
         throws IOException;
 
     /**
      * Process in-progress Comet requests. These will start as HTTP requests.
      */
+    @Override
     public abstract SocketState event(SocketStatus status) throws IOException;
 
     /**
      * Process in-progress Servlet 3.0 Async requests. These will start as HTTP
      * requests.
      */
+    @Override
     public abstract SocketState asyncDispatch(SocketStatus status);
 
     /**
      * Processes data received on a connection that has been through an HTTP
      * upgrade.
      */
+    @Override
     public abstract SocketState upgradeDispatch() throws IOException;
 
+    @Override
     public abstract UpgradeInbound getUpgradeInbound();
 }

==================================================
AsyncStateMachine.java
index 7dbfc79def..d5dc66a530 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -502,7 +502,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
 
     // ------------------------------------------- Connection handler base class
 
-    protected abstract static class AbstractConnectionHandler<S,P extends AbstractProcessor<S>>
+    protected abstract static class AbstractConnectionHandler<S,P extends Processor<S>>
             implements AbstractEndpoint.Handler {
 
         protected abstract Log getLog();
@@ -510,8 +510,8 @@ public abstract class AbstractProtocol implements ProtocolHandler,
         protected RequestGroupInfo global = new RequestGroupInfo();
         protected AtomicLong registerCount = new AtomicLong(0);
 
-        protected ConcurrentHashMap<S,P> connections =
-            new ConcurrentHashMap<S,P>();
+        protected ConcurrentHashMap<S,Processor<S>> connections =
+            new ConcurrentHashMap<S,Processor<S>>();
 
         protected RecycledProcessors<P,S> recycledProcessors =
             new RecycledProcessors<P,S>(this);
@@ -533,7 +533,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
 
         public SocketState process(SocketWrapper<S> socket,
                 SocketStatus status) {
-            P processor = connections.remove(socket.getSocket());
+            Processor<S> processor = connections.remove(socket.getSocket());
 
             socket.setAsync(false);
 
@@ -619,13 +619,17 @@ public abstract class AbstractProtocol implements ProtocolHandler,
         }
 
         protected abstract P createProcessor();
-        protected abstract void initSsl(SocketWrapper<S> socket, P processor);
-        protected abstract void longPoll(SocketWrapper<S> socket, P processor);
+        protected abstract void initSsl(SocketWrapper<S> socket,
+                Processor<S> processor);
+        protected abstract void longPoll(SocketWrapper<S> socket,
+                Processor<S> processor);
         protected abstract void upgradePoll(SocketWrapper<S> socket,
-                P processor);
-        protected abstract void release(SocketWrapper<S> socket, P processor,
-                boolean socketClosing, boolean addToPoller);
-        protected abstract P createUpgradeProcessor(SocketWrapper<S> socket,
+                Processor<S> processor);
+        protected abstract void release(SocketWrapper<S> socket,
+                Processor<S> processor, boolean socketClosing,
+                boolean addToPoller);
+        protected abstract Processor<S> createUpgradeProcessor(
+                SocketWrapper<S> socket,
                 UpgradeInbound inbound) throws IOException;
 
         protected void register(AbstractProcessor<S> processor) {
@@ -655,7 +659,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
             }
         }
 
-        protected void unregister(AbstractProcessor<S> processor) {
+        protected void unregister(Processor<S> processor) {
             if (getProtocol().getDomain() != null) {
                 synchronized (this) {
                     try {
@@ -681,8 +685,8 @@ public abstract class AbstractProtocol implements ProtocolHandler,
         }
     }
 
-    protected static class RecycledProcessors<P extends AbstractProcessor<S>, S>
-            extends ConcurrentLinkedQueue<P> {
+    protected static class RecycledProcessors<P extends Processor<S>, S>
+            extends ConcurrentLinkedQueue<Processor<S>> {
 
         private static final long serialVersionUID = 1L;
         private transient AbstractConnectionHandler<S,P> handler;
@@ -693,7 +697,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
         }
 
         @Override
-        public boolean offer(P processor) {
+        public boolean offer(Processor<S> processor) {
             int cacheSize = handler.getProtocol().getProcessorCache();
             boolean offer = cacheSize == -1 ? true : size.get() < cacheSize;
             //avoid over growing our cache or add after we have stopped
@@ -709,8 +713,8 @@ public abstract class AbstractProtocol implements ProtocolHandler,
         }
 
         @Override
-        public P poll() {
-            P result = super.poll();
+        public Processor<S> poll() {
+            Processor<S> result = super.poll();
             if (result != null) {
                 size.decrementAndGet();
             }
@@ -719,7 +723,7 @@ public abstract class AbstractProtocol implements ProtocolHandler,
 
         @Override
         public void clear() {
-            P next = poll();
+            Processor<S> next = poll();
             while (next != null) {
                 handler.unregister(next);
                 next = poll();

==================================================
Processor.java
index 93e58598d1..418a2101ea 100644
--- a/java/org/apache/coyote/AsyncStateMachine.java
+++ b/java/org/apache/coyote/AsyncStateMachine.java
@@ -84,7 +84,7 @@ import org.apache.tomcat.util.res.StringManager;
  *                                 error()
  * </pre>
  */
-public class AsyncStateMachine {
+public class AsyncStateMachine<S> {
 
     /**
      * The string manager for this package.
@@ -131,10 +131,10 @@ public class AsyncStateMachine {
     private volatile AsyncState state = AsyncState.DISPATCHED;
     // Need this to fire listener on complete
     private AsyncContextCallback asyncCtxt = null;
-    private Processor processor;
+    private Processor<S> processor;
 
 
-    public AsyncStateMachine(Processor processor) {
+    public AsyncStateMachine(Processor<S> processor) {
         this.processor = processor;
     }
 

==================================================
AbstractAjpProcessor.java
index 11367b9307..71597dae04 100644
--- a/java/org/apache/coyote/Processor.java
+++ b/java/org/apache/coyote/Processor.java
@@ -17,12 +17,39 @@
 
 package org.apache.coyote;
 
+import java.io.IOException;
 import java.util.concurrent.Executor;
 
+import org.apache.coyote.http11.upgrade.UpgradeInbound;
+import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
+import org.apache.tomcat.util.net.SSLSupport;
+import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketWrapper;
+
 
 /**
  * Common interface for processors of all protocols.
  */
-public interface Processor {
+public interface Processor<S> {
     Executor getExecutor();
+
+    SocketState process(SocketWrapper<S> socketWrapper) throws IOException;
+
+    SocketState event(SocketStatus status) throws IOException;
+
+    SocketState asyncDispatch(SocketStatus status);
+    SocketState asyncPostProcess();
+
+    UpgradeInbound getUpgradeInbound();
+    SocketState upgradeDispatch() throws IOException;
+
+    boolean isComet();
+    boolean isAsync();
+    boolean isUpgrade();
+
+    Request getRequest();
+
+    void recycle(boolean socketClosing);
+
+    void setSslSupport(SSLSupport sslSupport);
 }

==================================================
AbstractAjpProtocol.java
index 3a0078266b..72fa79aff8 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
@@ -506,6 +506,14 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
     }
 
 
+    @Override
+    public void setSslSupport(SSLSupport sslSupport) {
+        // Should never reach this code but in case we do...
+        throw new IllegalStateException(
+                sm.getString("ajpprocessor.ssl.notsupported"));
+    }
+
+
     @Override
     public SocketState event(SocketStatus status) throws IOException {
         // Should never reach this code but in case we do...
@@ -538,6 +546,7 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
      *                      allowing the processor to perform any additional
      *                      clean-up that may be required
      */
+    @Override
     public void recycle(boolean socketClosing) {
         asyncStateMachine.recycle();
 
@@ -568,14 +577,14 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
 
 
     @Override
-    protected final boolean isComet() {
+    public final boolean isComet() {
         // AJP does not support Comet
         return false;
     }
 
 
     @Override
-    protected final boolean isUpgrade() {
+    public final boolean isUpgrade() {
         // AJP does not support HTTP upgrade
         return false;
     }

==================================================
AjpAprProtocol.java
index 8076509f92..e8ee43f41b 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProtocol.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProtocol.java
@@ -17,6 +17,7 @@
 package org.apache.coyote.ajp;
 
 import org.apache.coyote.AbstractProtocol;
+import org.apache.coyote.Processor;
 import org.apache.coyote.http11.upgrade.UpgradeInbound;
 import org.apache.tomcat.util.net.SocketWrapper;
 import org.apache.tomcat.util.res.StringManager;
@@ -77,19 +78,21 @@ public abstract class AbstractAjpProtocol extends AbstractProtocol {
             extends AbstractConnectionHandler<S, P> {
 
         @Override
-        protected void initSsl(SocketWrapper<S> socket, P processor) {
+        protected void initSsl(SocketWrapper<S> socket, Processor<S> processor) {
             // NOOP for AJP
         }
 
         @Override
-        protected void longPoll(SocketWrapper<S> socket, P processor) {
+        protected void longPoll(SocketWrapper<S> socket,
+                Processor<S> processor) {
             // Same requirements for all AJP connectors
             connections.put(socket.getSocket(), processor);
             socket.setAsync(true);
         }
 
         @Override
-        protected void upgradePoll(SocketWrapper<S> socket, P processor) {
+        protected void upgradePoll(SocketWrapper<S> socket,
+                Processor<S> processor) {
             // TODO Should never happen. ISE?
         }
 

==================================================
AjpNioProtocol.java
index 96f066b786..d81759fb27 100644
--- a/java/org/apache/coyote/ajp/AjpAprProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpAprProtocol.java
@@ -17,6 +17,7 @@
 package org.apache.coyote.ajp;
 
 import org.apache.coyote.AbstractProtocol;
+import org.apache.coyote.Processor;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.net.AbstractEndpoint;
@@ -120,7 +121,7 @@ public class AjpAprProtocol extends AbstractAjpProtocol {
          */
         @Override
         public void release(SocketWrapper<Long> socket,
-                AjpAprProcessor processor, boolean isSocketClosing,
+                Processor<Long> processor, boolean isSocketClosing,
                 boolean addToPoller) {
             processor.recycle(isSocketClosing);
             recycledProcessors.offer(processor);

==================================================
AjpProtocol.java
index f17a77eef5..78d94bddc6 100644
--- a/java/org/apache/coyote/ajp/AjpNioProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpNioProtocol.java
@@ -20,6 +20,7 @@ import java.nio.channels.SocketChannel;
 import java.util.Iterator;
 
 import org.apache.coyote.AbstractProtocol;
+import org.apache.coyote.Processor;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.net.AbstractEndpoint;
@@ -120,12 +121,12 @@ public class AjpNioProtocol extends AbstractAjpProtocol {
             if (log.isDebugEnabled())
                 log.debug("Iterating through our connections to release a socket channel:"+socket);
             boolean released = false;
-            Iterator<java.util.Map.Entry<NioChannel, AjpNioProcessor>> it = connections.entrySet().iterator();
+            Iterator<java.util.Map.Entry<NioChannel, Processor<NioChannel>>> it = connections.entrySet().iterator();
             while (it.hasNext()) {
-                java.util.Map.Entry<NioChannel, AjpNioProcessor> entry = it.next();
+                java.util.Map.Entry<NioChannel, Processor<NioChannel>> entry = it.next();
                 if (entry.getKey().getIOChannel()==socket) {
                     it.remove();
-                    AjpNioProcessor result = entry.getValue();
+                    Processor<NioChannel> result = entry.getValue();
                     result.recycle(true);
                     unregister(result);
                     released = true;
@@ -142,7 +143,7 @@ public class AjpNioProtocol extends AbstractAjpProtocol {
          */
         @Override
         public void release(SocketWrapper<NioChannel> socket) {
-            AjpNioProcessor processor = connections.remove(socket);
+            Processor<NioChannel> processor = connections.remove(socket);
             if (processor != null) {
                 processor.recycle(true);
                 recycledProcessors.offer(processor);
@@ -155,7 +156,7 @@ public class AjpNioProtocol extends AbstractAjpProtocol {
          */
         @Override
         public void release(SocketWrapper<NioChannel> socket,
-                AjpNioProcessor processor, boolean isSocketClosing,
+                Processor<NioChannel> processor, boolean isSocketClosing,
                 boolean addToPoller) {
             processor.recycle(isSocketClosing);
             recycledProcessors.offer(processor);

==================================================
AbstractHttp11Processor.java
index 1b5e04100e..49934bd315 100644
--- a/java/org/apache/coyote/ajp/LocalStrings.properties
+++ b/java/org/apache/coyote/ajp/LocalStrings.properties
@@ -32,6 +32,7 @@ ajpprocessor.request.prepare=Error preparing request
 ajpprocessor.request.process=Error processing request
 ajpprocessor.certs.fail=Certificate conversion failed
 ajpprocessor.comet.notsupported=The Comet protocol is not supported by this connector
+ajpprocessor.ssl.notsupported=The SSL protocol is not supported by this connector
 ajpprocessor.httpupgrade.notsupported=HTTP upgrades are not supported by this connector
 
 ajpmessage.null=Cannot append null value

==================================================
Http11AprProcessor.java
index 8d3c7e2030..d6a8b63645 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Processor.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Processor.java
@@ -1589,6 +1589,7 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
     }
 
 
+    @Override
     public UpgradeInbound getUpgradeInbound() {
         return upgradeInbound;
     }
@@ -1647,7 +1648,9 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
             SocketWrapper<S> socketWrapper);
 
 
-    public final void recycle() {
+
+    @Override
+    public final void recycle(boolean isSocketClosing) {
         if (getInputBuffer() != null) {
             getInputBuffer().recycle();
         }

==================================================
Http11AprProtocol.java
index bdf7aeb251..bd703753cc 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -266,6 +266,11 @@ public class Http11AprProcessor extends AbstractHttp11Processor<Long> {
     }
 
 
+    @Override
+    public void setSslSupport(SSLSupport sslSupport) {
+        // NOOP for APR
+    }
+
     // ----------------------------------------------------- ActionHook Methods
 
 

==================================================
Http11NioProcessor.java
index cfcf3b2485..8857eb2712 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -19,6 +19,7 @@ package org.apache.coyote.http11;
 import java.io.IOException;
 
 import org.apache.coyote.AbstractProtocol;
+import org.apache.coyote.Processor;
 import org.apache.coyote.http11.upgrade.UpgradeAprProcessor;
 import org.apache.coyote.http11.upgrade.UpgradeInbound;
 import org.apache.juli.logging.Log;
@@ -215,9 +216,9 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
          */
         @Override
         public void release(SocketWrapper<Long> socket,
-                Http11AprProcessor processor, boolean isSocketClosing,
+                Processor<Long> processor, boolean isSocketClosing,
                 boolean addToPoller) {
-            processor.recycle();
+            processor.recycle(isSocketClosing);
             recycledProcessors.offer(processor);
             if (addToPoller && proto.endpoint.isRunning()) {
                 ((AprEndpoint)proto.endpoint).getPoller().add(
@@ -227,18 +228,18 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
 
         @Override
         protected void initSsl(SocketWrapper<Long> socket,
-                Http11AprProcessor processor) {
+                Processor<Long> processor) {
             // NOOP for APR
         }
 
         @Override
         protected void longPoll(SocketWrapper<Long> socket,
-                Http11AprProcessor processor) {
+                Processor<Long> processor) {
             connections.put(socket.getSocket(), processor);
 
             if (processor.isAsync()) {
                 socket.setAsync(true);
-            } else if (processor.comet && proto.endpoint.isRunning()) {
+            } else if (processor.isComet() && proto.endpoint.isRunning()) {
                 ((AprEndpoint) proto.endpoint).getCometPoller().add(
                         socket.getSocket().longValue(), false);
             }
@@ -246,7 +247,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
 
         @Override
         protected void upgradePoll(SocketWrapper<Long> socket,
-                Http11AprProcessor processor) {
+                Processor<Long> processor) {
             connections.put(socket.getSocket(), processor);
             ((AprEndpoint) proto.endpoint).getPoller().add(
                     socket.getSocket().longValue(), false);
@@ -277,7 +278,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
         }
 
         @Override
-        protected Http11AprProcessor createUpgradeProcessor(
+        protected Processor<Long> createUpgradeProcessor(
                 SocketWrapper<Long> socket, UpgradeInbound inbound)
                 throws IOException {
             return new UpgradeAprProcessor(socket, inbound);

==================================================
Http11NioProtocol.java
index 9927116507..8791ca0ace 100644
--- a/java/org/apache/coyote/http11/Http11NioProcessor.java
+++ b/java/org/apache/coyote/http11/Http11NioProcessor.java
@@ -555,6 +555,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
     /**
      * Set the SSL information for this HTTP connection.
      */
+    @Override
     public void setSslSupport(SSLSupport sslSupport) {
         this.sslSupport = sslSupport;
     }

==================================================
Http11Processor.java
index f980a8f19b..432986a74d 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -22,6 +22,7 @@ import java.nio.channels.SocketChannel;
 import java.util.Iterator;
 
 import org.apache.coyote.AbstractProtocol;
+import org.apache.coyote.Processor;
 import org.apache.coyote.http11.upgrade.UpgradeInbound;
 import org.apache.coyote.http11.upgrade.UpgradeNioProcessor;
 import org.apache.juli.logging.Log;
@@ -172,13 +173,13 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
             if (log.isDebugEnabled())
                 log.debug("Iterating through our connections to release a socket channel:"+socket);
             boolean released = false;
-            Iterator<java.util.Map.Entry<NioChannel, Http11NioProcessor>> it = connections.entrySet().iterator();
+            Iterator<java.util.Map.Entry<NioChannel, Processor<NioChannel>>> it = connections.entrySet().iterator();
             while (it.hasNext()) {
-                java.util.Map.Entry<NioChannel, Http11NioProcessor> entry = it.next();
+                java.util.Map.Entry<NioChannel, Processor<NioChannel>> entry = it.next();
                 if (entry.getKey().getIOChannel()==socket) {
                     it.remove();
-                    Http11NioProcessor result = entry.getValue();
-                    result.recycle();
+                    Processor<NioChannel> result = entry.getValue();
+                    result.recycle(true);
                     unregister(result);
                     released = true;
                     break;
@@ -194,10 +195,10 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
          */
         @Override
         public void release(SocketWrapper<NioChannel> socket) {
-            Http11NioProcessor processor =
+            Processor<NioChannel> processor =
                 connections.remove(socket.getSocket());
             if (processor != null) {
-                processor.recycle();
+                processor.recycle(true);
                 recycledProcessors.offer(processor);
             }
         }
@@ -214,9 +215,9 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
          */
         @Override
         public void release(SocketWrapper<NioChannel> socket,
-                Http11NioProcessor processor, boolean isSocketClosing,
+                Processor<NioChannel> processor, boolean isSocketClosing,
                 boolean addToPoller) {
-            processor.recycle();
+            processor.recycle(isSocketClosing);
             recycledProcessors.offer(processor);
             if (addToPoller) {
                 socket.getSocket().getPoller().add(socket.getSocket());
@@ -226,7 +227,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
 
         @Override
         protected void initSsl(SocketWrapper<NioChannel> socket,
-                Http11NioProcessor processor) {
+                Processor<NioChannel> processor) {
             if (proto.isSSLEnabled() &&
                     (proto.sslImplementation != null)
                     && (socket.getSocket() instanceof SecureNioChannel)) {
@@ -242,7 +243,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
 
         @Override
         protected void longPoll(SocketWrapper<NioChannel> socket,
-                Http11NioProcessor processor) {
+                Processor<NioChannel> processor) {
             connections.put(socket.getSocket(), processor);
 
             if (processor.isAsync()) {
@@ -284,7 +285,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
         }
 
         @Override
-        protected Http11NioProcessor createUpgradeProcessor(
+        protected Processor<NioChannel> createUpgradeProcessor(
                 SocketWrapper<NioChannel> socket, UpgradeInbound inbound)
                 throws IOException {
             return new UpgradeNioProcessor(socket, inbound,
@@ -293,7 +294,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
 
         @Override
         protected void upgradePoll(SocketWrapper<NioChannel> socket,
-                Http11NioProcessor processor) {
+                Processor<NioChannel> processor) {
             connections.put(socket.getSocket(), processor);
 
             SelectionKey key = socket.getSocket().getIOChannel().keyFor(

==================================================
Http11Protocol.java
index 36e160f560..8bd9448b38 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -112,7 +112,8 @@ public class Http11Processor extends AbstractHttp11Processor<Socket> {
     /**
      * Set the SSL information for this HTTP connection.
      */
-    public void setSSLSupport(SSLSupport sslSupport) {
+    @Override
+    public void setSslSupport(SSLSupport sslSupport) {
         this.sslSupport = sslSupport;
     }
 

==================================================
Constants.java
index 5907e84774..262a548742 100644
--- a/java/org/apache/coyote/http11/Http11Protocol.java
+++ b/java/org/apache/coyote/http11/Http11Protocol.java
@@ -20,6 +20,7 @@ import java.io.IOException;
 import java.net.Socket;
 
 import org.apache.coyote.AbstractProtocol;
+import org.apache.coyote.Processor;
 import org.apache.coyote.http11.upgrade.UpgradeBioProcessor;
 import org.apache.coyote.http11.upgrade.UpgradeInbound;
 import org.apache.juli.logging.Log;
@@ -134,28 +135,28 @@ public class Http11Protocol extends AbstractHttp11JsseProtocol {
          */
         @Override
         public void release(SocketWrapper<Socket> socket,
-                Http11Processor processor, boolean isSocketClosing,
+                Processor<Socket> processor, boolean isSocketClosing,
                 boolean addToPoller) {
-            processor.recycle();
+            processor.recycle(isSocketClosing);
             recycledProcessors.offer(processor);
         }
 
         @Override
         protected void initSsl(SocketWrapper<Socket> socket,
-                Http11Processor processor) {
+                Processor<Socket> processor) {
             if (proto.isSSLEnabled() && (proto.sslImplementation != null)) {
-                processor.setSSLSupport(
+                processor.setSslSupport(
                         proto.sslImplementation.getSSLSupport(
                                 socket.getSocket()));
             } else {
-                processor.setSSLSupport(null);
+                processor.setSslSupport(null);
             }
 
         }
 
         @Override
         protected void longPoll(SocketWrapper<Socket> socket,
-                Http11Processor processor) {
+                Processor<Socket> processor) {
             connections.put(socket.getSocket(), processor);
         }
 
@@ -185,7 +186,7 @@ public class Http11Protocol extends AbstractHttp11JsseProtocol {
         }
 
         @Override
-        protected Http11Processor createUpgradeProcessor(
+        protected Processor<Socket> createUpgradeProcessor(
                 SocketWrapper<Socket> socket, UpgradeInbound inbound)
                 throws IOException {
             return new UpgradeBioProcessor(socket, inbound);
@@ -193,7 +194,7 @@ public class Http11Protocol extends AbstractHttp11JsseProtocol {
 
         @Override
         protected void upgradePoll(SocketWrapper<Socket> socket,
-                Http11Processor processor) {
+                Processor<Socket> processor) {
             connections.put(socket.getSocket(), processor);
         }
     }

==================================================
UpgradeAprProcessor.java
new file mode 100644
index 0000000000..c280a01207
--- /dev/null
+++ b/java/org/apache/coyote/http11/upgrade/LocalStrings.properties
@@ -0,0 +1,16 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+nio.eof.error=Unexpected EOF read on the socket

==================================================
UpgradeBioProcessor.java
index efb19c56d7..e484a9b77d 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeAprProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeAprProcessor.java
@@ -1,123 +1,73 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-
-import org.apache.coyote.http11.Http11AprProcessor;
-import org.apache.tomcat.jni.Socket;
-import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
-import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-/**
- * Implementation note: The need to extend Http11Processor could probably be
- * removed if the Processor interface was expanded to cover all of the methods
- * required by the AbstractProtocol. That would simplify the code and further
- * reduce the size of instances of this class.
- */
-public class UpgradeAprProcessor extends Http11AprProcessor
-        implements UpgradeProcessor {
-
-    long socket;
-
-    public UpgradeAprProcessor(SocketWrapper<Long> wrapper,
-            UpgradeInbound inbound) {
-        this.socket = wrapper.getSocket().longValue();
-
-        this.upgradeInbound = inbound;
-        upgradeInbound.setUpgradeProcessor(this);
-        upgradeInbound.setUpgradeOutbound(new UpgradeOutbound(this));
-        // Remove the default - no need for it here
-        this.compressableMimeTypes = null;
-    }
-
-
-    @Override
-    public SocketState upgradeDispatch() throws IOException {
-        return upgradeInbound.onData();
-    }
-
-
-    /*
-     * Output methods
-     */
-    @Override
-    public void flush() throws IOException {
-        // NOOP
-    }
-
-
-    @Override
-    public void write(int b) throws IOException {
-        Socket.send(socket, new byte[] {(byte) b}, 0, 1);
-    }
-
-
-    /*
-     * Input methods
-     */
-    @Override
-    public int read() throws IOException {
-        byte[] bytes = new byte[1];
-        Socket.recv(socket, bytes, 0, 1);
-        return bytes[0];
-    }
-
-
-    @Override
-    public int read(byte[] bytes) throws IOException {
-        return Socket.recv(socket, bytes, 0, bytes.length);
-    }
-
-
-    /*
-     * None of the following NO-OP methods are strictly necessary - assuming the
-     * there are no bugs in the connector code that cause upgraded connections
-     * to be treated as Http11, Comet or Async. These NO-OP methods are here for
-     * safety and to aid debugging during development.
-     */
-
-    @Override
-    public SocketState event(SocketStatus status) throws IOException {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState process(SocketWrapper<Long> socketWrapper)
-            throws IOException {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState asyncDispatch(SocketStatus status) {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState asyncPostProcess() {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.IOException;
+
+import org.apache.tomcat.jni.Socket;
+import org.apache.tomcat.util.net.SocketWrapper;
+
+/**
+ * Implementation note: The need to extend Http11Processor could probably be
+ * removed if the Processor interface was expanded to cover all of the methods
+ * required by the AbstractProtocol. That would simplify the code and further
+ * reduce the size of instances of this class.
+ */
+public class UpgradeAprProcessor extends UpgradeProcessor<Long> {
+
+    long socket;
+
+
+    public UpgradeAprProcessor(SocketWrapper<Long> wrapper,
+            UpgradeInbound upgradeInbound) {
+        super(upgradeInbound);
+
+        this.socket = wrapper.getSocket().longValue();
+    }
+
+
+    /*
+     * Output methods
+     */
+    @Override
+    public void flush() throws IOException {
+        // NOOP
+    }
+
+
+    @Override
+    public void write(int b) throws IOException {
+        Socket.send(socket, new byte[] {(byte) b}, 0, 1);
+    }
+
+
+    /*
+     * Input methods
+     */
+    @Override
+    public int read() throws IOException {
+        byte[] bytes = new byte[1];
+        Socket.recv(socket, bytes, 0, 1);
+        return bytes[0];
+    }
+
+
+    @Override
+    public int read(byte[] bytes) throws IOException {
+        return Socket.recv(socket, bytes, 0, bytes.length);
+    }
+}

==================================================
UpgradeNioProcessor.java
index 5e0ac162b9..e07b4f3b69 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeBioProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeBioProcessor.java
@@ -1,123 +1,74 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Socket;
-
-import org.apache.coyote.http11.Http11Processor;
-import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
-import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-/**
- * Implementation note: The need to extend Http11Processor could probably be
- * removed if the Processor interface was expanded to cover all of the methods
- * required by the AbstractProtocol. That would simplify the code and further
- * reduce the size of instances of this class.
- */
-public class UpgradeBioProcessor extends Http11Processor
-        implements UpgradeProcessor{
-
-    private InputStream inputStream;
-    private OutputStream outputStream;
-
-    public UpgradeBioProcessor(SocketWrapper<Socket> wrapper,
-            UpgradeInbound inbound) throws IOException {
-        this.inputStream = wrapper.getSocket().getInputStream();
-        this.outputStream = wrapper.getSocket().getOutputStream();
-        this.upgradeInbound = inbound;
-        upgradeInbound.setUpgradeProcessor(this);
-        upgradeInbound.setUpgradeOutbound(new UpgradeOutbound(this));
-        // Remove the default - no need for it here
-        this.compressableMimeTypes = null;
-    }
-
-
-    @Override
-    public SocketState upgradeDispatch() throws IOException {
-        return upgradeInbound.onData();
-    }
-
-
-    /*
-     * Output methods
-     */
-    @Override
-    public void flush() throws IOException {
-        outputStream.flush();
-    }
-
-
-    @Override
-    public void write(int b) throws IOException {
-        outputStream.write(b);
-    }
-
-
-    /*
-     * Input methods
-     */
-    @Override
-    public int read() throws IOException {
-        return inputStream.read();
-    }
-
-
-    @Override
-    public int read(byte[] bytes) throws IOException {
-        return inputStream.read(bytes);
-    }
-
-
-    /*
-     * None of the following NO-OP methods are strictly necessary - assuming the
-     * there are no bugs in the connector code that cause upgraded connections
-     * to be treated as Http11, Comet or Async. These NO-OP methods are here for
-     * safety and to aid debugging during development.
-     */
-
-    @Override
-    public SocketState event(SocketStatus status) throws IOException {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState process(SocketWrapper<Socket> socketWrapper)
-            throws IOException {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState asyncDispatch(SocketStatus status) {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState asyncPostProcess() {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.Socket;
+
+import org.apache.tomcat.util.net.SocketWrapper;
+
+/**
+ * Implementation note: The need to extend Http11Processor could probably be
+ * removed if the Processor interface was expanded to cover all of the methods
+ * required by the AbstractProtocol. That would simplify the code and further
+ * reduce the size of instances of this class.
+ */
+public class UpgradeBioProcessor extends UpgradeProcessor<Socket> {
+
+    private InputStream inputStream;
+    private OutputStream outputStream;
+
+    public UpgradeBioProcessor(SocketWrapper<Socket> wrapper,
+            UpgradeInbound upgradeInbound) throws IOException {
+        super(upgradeInbound);
+
+        this.inputStream = wrapper.getSocket().getInputStream();
+        this.outputStream = wrapper.getSocket().getOutputStream();
+    }
+
+
+    /*
+     * Output methods
+     */
+    @Override
+    public void flush() throws IOException {
+        outputStream.flush();
+    }
+
+
+    @Override
+    public void write(int b) throws IOException {
+        outputStream.write(b);
+    }
+
+
+    /*
+     * Input methods
+     */
+    @Override
+    public int read() throws IOException {
+        return inputStream.read();
+    }
+
+
+    @Override
+    public int read(byte[] bytes) throws IOException {
+        return inputStream.read(bytes);
+    }
+}

==================================================
UpgradeProcessor.java
index 8641ef3c9a..487235274b 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeNioProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeNioProcessor.java
@@ -1,228 +1,179 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.nio.channels.Selector;
-
-import org.apache.coyote.http11.Http11NioProcessor;
-import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
-import org.apache.tomcat.util.net.NioChannel;
-import org.apache.tomcat.util.net.NioEndpoint;
-import org.apache.tomcat.util.net.NioSelectorPool;
-import org.apache.tomcat.util.net.SocketStatus;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-/**
- * Implementation note: The need to extend Http11Processor could probably be
- * removed if the Processor interface was expanded to cover all of the methods
- * required by the AbstractProtocol. That would simplify the code and further
- * reduce the size of instances of this class.
- */
-public class UpgradeNioProcessor extends Http11NioProcessor
-        implements UpgradeProcessor {
-
-    private NioChannel nioChannel;
-    private NioSelectorPool pool;
-
-    public UpgradeNioProcessor(SocketWrapper<NioChannel> wrapper,
-            UpgradeInbound inbound, NioSelectorPool pool) {
-        this.nioChannel = wrapper.getSocket();
-        this.pool = pool;
-
-        this.upgradeInbound = inbound;
-        upgradeInbound.setUpgradeProcessor(this);
-        upgradeInbound.setUpgradeOutbound(new UpgradeOutbound(this));
-        // Remove the default - no need for it here
-        this.compressableMimeTypes = null;
-    }
-
-
-    @Override
-    public SocketState upgradeDispatch() throws IOException {
-        return upgradeInbound.onData();
-    }
-
-
-    /*
-     * Output methods
-     */
-    @Override
-    public void flush() throws IOException {
-        NioEndpoint.KeyAttachment att =
-                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
-        if (att == null) {
-            throw new IOException("Key must be cancelled");
-        }
-        long writeTimeout = att.getTimeout();
-        Selector selector = null;
-        try {
-            selector = pool.get();
-        } catch ( IOException x ) {
-            //ignore
-        }
-        try {
-            do {
-                if (nioChannel.flush(true, selector, writeTimeout)) {
-                    break;
-                }
-            } while (true);
-        } finally {
-            if (selector != null) {
-                pool.put(selector);
-            }
-        }
-    }
-
-    @Override
-    public void write(int b) throws IOException {
-        writeToSocket(new byte[] {(byte) b});
-    }
-
-    /*
-     * Input methods
-     */
-    @Override
-    public int read() throws IOException {
-        byte[] bytes = new byte[1];
-        readSocket(true, bytes, 0, 1);
-        return bytes[0];
-    }
-
-    @Override
-    public int read(byte[] bytes) throws IOException {
-        return readSocket(true, bytes, 0, bytes.length);
-    }
-
-
-    /*
-     * Adapted from the NioInputBuffer.
-     */
-    private int readSocket(boolean block, byte[] bytes, int offset, int len)
-            throws IOException {
-
-        int nRead = 0;
-        nioChannel.getBufHandler().getReadBuffer().clear();
-        nioChannel.getBufHandler().getReadBuffer().limit(len);
-        if (block) {
-            Selector selector = null;
-            try {
-                selector = pool.get();
-            } catch ( IOException x ) {
-                // Ignore
-            }
-            try {
-                NioEndpoint.KeyAttachment att =
-                        (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
-                if (att == null) {
-                    throw new IOException("Key must be cancelled.");
-                }
-                nRead = pool.read(nioChannel.getBufHandler().getReadBuffer(),
-                        nioChannel, selector, att.getTimeout());
-            } catch (EOFException eof) {
-                nRead = -1;
-            } finally {
-                if (selector != null) {
-                    pool.put(selector);
-                }
-            }
-        } else {
-            nRead = nioChannel.read(nioChannel.getBufHandler().getReadBuffer());
-        }
-        if (nRead > 0) {
-            nioChannel.getBufHandler().getReadBuffer().flip();
-            nioChannel.getBufHandler().getReadBuffer().limit(nRead);
-            nioChannel.getBufHandler().getReadBuffer().get(bytes, offset, nRead);
-            return nRead;
-        } else if (nRead == -1) {
-            //return false;
-            throw new EOFException(sm.getString("iib.eof.error"));
-        } else {
-            return 0;
-        }
-    }
-
-
-    /*
-     * Adapted from the NioOutputBuffer
-     */
-    private synchronized int writeToSocket(byte[] bytes) throws IOException {
-
-        nioChannel.getBufHandler().getWriteBuffer().clear();
-        nioChannel.getBufHandler().getWriteBuffer().put(bytes);
-        nioChannel.getBufHandler().getWriteBuffer().flip();
-
-        int written = 0;
-        NioEndpoint.KeyAttachment att =
-                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
-        if (att == null) {
-            throw new IOException("Key must be cancelled");
-        }
-        long writeTimeout = att.getTimeout();
-        Selector selector = null;
-        try {
-            selector = pool.get();
-        } catch ( IOException x ) {
-            //ignore
-        }
-        try {
-            written = pool.write(nioChannel.getBufHandler().getWriteBuffer(),
-                    nioChannel, selector, writeTimeout, true);
-        } finally {
-            if (selector != null) {
-                pool.put(selector);
-            }
-        }
-        return written;
-    }
-
-    /*
-     * None of the following NO-OP methods are strictly necessary - assuming the
-     * there are no bugs in the connector code that cause upgraded connections
-     * to be treated as Http11, Comet or Async. These NO-OP methods are here for
-     * safety and to aid debugging during development.
-     */
-
-    @Override
-    public SocketState event(SocketStatus status) throws IOException {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState process(SocketWrapper<NioChannel> socketWrapper)
-            throws IOException {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState asyncDispatch(SocketStatus status) {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-
-
-    @Override
-    public SocketState asyncPostProcess() {
-        // TODO Log an error
-        return SocketState.CLOSED;
-    }
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.channels.Selector;
+
+import org.apache.tomcat.util.net.NioChannel;
+import org.apache.tomcat.util.net.NioEndpoint;
+import org.apache.tomcat.util.net.NioSelectorPool;
+import org.apache.tomcat.util.net.SocketWrapper;
+
+/**
+ * Implementation note: The need to extend Http11Processor could probably be
+ * removed if the Processor interface was expanded to cover all of the methods
+ * required by the AbstractProtocol. That would simplify the code and further
+ * reduce the size of instances of this class.
+ */
+public class UpgradeNioProcessor extends UpgradeProcessor<NioChannel> {
+
+    private NioChannel nioChannel;
+    private NioSelectorPool pool;
+
+    public UpgradeNioProcessor(SocketWrapper<NioChannel> wrapper,
+            UpgradeInbound upgradeInbound, NioSelectorPool pool) {
+        super(upgradeInbound);
+
+        this.nioChannel = wrapper.getSocket();
+        this.pool = pool;
+    }
+
+
+    /*
+     * Output methods
+     */
+    @Override
+    public void flush() throws IOException {
+        NioEndpoint.KeyAttachment att =
+                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
+        if (att == null) {
+            throw new IOException("Key must be cancelled");
+        }
+        long writeTimeout = att.getTimeout();
+        Selector selector = null;
+        try {
+            selector = pool.get();
+        } catch ( IOException x ) {
+            //ignore
+        }
+        try {
+            do {
+                if (nioChannel.flush(true, selector, writeTimeout)) {
+                    break;
+                }
+            } while (true);
+        } finally {
+            if (selector != null) {
+                pool.put(selector);
+            }
+        }
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+        writeToSocket(new byte[] {(byte) b});
+    }
+
+    /*
+     * Input methods
+     */
+    @Override
+    public int read() throws IOException {
+        byte[] bytes = new byte[1];
+        readSocket(true, bytes, 0, 1);
+        return bytes[0];
+    }
+
+    @Override
+    public int read(byte[] bytes) throws IOException {
+        return readSocket(true, bytes, 0, bytes.length);
+    }
+
+
+    /*
+     * Adapted from the NioInputBuffer.
+     */
+    private int readSocket(boolean block, byte[] bytes, int offset, int len)
+            throws IOException {
+
+        int nRead = 0;
+        nioChannel.getBufHandler().getReadBuffer().clear();
+        nioChannel.getBufHandler().getReadBuffer().limit(len);
+        if (block) {
+            Selector selector = null;
+            try {
+                selector = pool.get();
+            } catch ( IOException x ) {
+                // Ignore
+            }
+            try {
+                NioEndpoint.KeyAttachment att =
+                        (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
+                if (att == null) {
+                    throw new IOException("Key must be cancelled.");
+                }
+                nRead = pool.read(nioChannel.getBufHandler().getReadBuffer(),
+                        nioChannel, selector, att.getTimeout());
+            } catch (EOFException eof) {
+                nRead = -1;
+            } finally {
+                if (selector != null) {
+                    pool.put(selector);
+                }
+            }
+        } else {
+            nRead = nioChannel.read(nioChannel.getBufHandler().getReadBuffer());
+        }
+        if (nRead > 0) {
+            nioChannel.getBufHandler().getReadBuffer().flip();
+            nioChannel.getBufHandler().getReadBuffer().limit(nRead);
+            nioChannel.getBufHandler().getReadBuffer().get(bytes, offset, nRead);
+            return nRead;
+        } else if (nRead == -1) {
+            //return false;
+            throw new EOFException(sm.getString("nio.eof.error"));
+        } else {
+            return 0;
+        }
+    }
+
+
+    /*
+     * Adapted from the NioOutputBuffer
+     */
+    private synchronized int writeToSocket(byte[] bytes) throws IOException {
+
+        nioChannel.getBufHandler().getWriteBuffer().clear();
+        nioChannel.getBufHandler().getWriteBuffer().put(bytes);
+        nioChannel.getBufHandler().getWriteBuffer().flip();
+
+        int written = 0;
+        NioEndpoint.KeyAttachment att =
+                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
+        if (att == null) {
+            throw new IOException("Key must be cancelled");
+        }
+        long writeTimeout = att.getTimeout();
+        Selector selector = null;
+        try {
+            selector = pool.get();
+        } catch ( IOException x ) {
+            //ignore
+        }
+        try {
+            written = pool.write(nioChannel.getBufHandler().getWriteBuffer(),
+                    nioChannel, selector, writeTimeout, true);
+        } finally {
+            if (selector != null) {
+                pool.put(selector);
+            }
+        }
+        return written;
+    }
+}

==================================================
