e12cc0093f24bfa029cc88eba59172b423811996
==================================================
Whitespace removal from /java/org/apache/catalina/tribes
==================================================
Mark Emlyn
==================================================
Sat Oct 22 21:09:52 2011 +0000
==================================================
ChannelException.java
Whitespace removal from /java/org/apache/catalina/tribes

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1187789 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ChannelInterceptor.java
index 886c462cd8..e097c21c05 100644
--- a/java/org/apache/catalina/tribes/ChannelException.java
+++ b/java/org/apache/catalina/tribes/ChannelException.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -40,7 +40,7 @@ public class ChannelException extends Exception {
      * Holds a list of faulty members
      */
     private ArrayList<FaultyMember> faultyMembers=null;
-    
+
     /**
      * Constructor, creates a ChannelException
      * @see java.lang.Exception#Exception()
@@ -75,7 +75,7 @@ public class ChannelException extends Exception {
     public ChannelException(Throwable cause) {
         super(cause);
     }
-    
+
     /**
      * Returns the message for this exception
      * @return String
@@ -96,7 +96,7 @@ public class ChannelException extends Exception {
         }
         return buf.toString();
     }
-    
+
     /**
      * Adds a faulty member, and the reason the member failed.
      * @param mbr Member
@@ -105,7 +105,7 @@ public class ChannelException extends Exception {
     public boolean addFaultyMember(Member mbr, Exception x ) {
         return addFaultyMember(new FaultyMember(mbr,x));
     }
-    
+
     /**
      * Adds a list of faulty members
      * @param mbrs FaultyMember[]
@@ -127,7 +127,7 @@ public class ChannelException extends Exception {
         if ( !faultyMembers.contains(mbr) ) return faultyMembers.add(mbr);
         else return false;
     }
-    
+
     /**
      * Returns an array of members that failed and the reason they failed.
      * @return FaultyMember[]
@@ -136,43 +136,43 @@ public class ChannelException extends Exception {
         if ( this.faultyMembers==null ) return EMPTY_LIST;
         return faultyMembers.toArray(new FaultyMember[faultyMembers.size()]);
     }
-    
+
     /**
-     * 
-     * <p>Title: FaultyMember class</p> 
-     * 
+     *
+     * <p>Title: FaultyMember class</p>
+     *
      * <p>Description: Represent a failure to a specific member when a message was sent
-     * to more than one member</p> 
-     * 
+     * to more than one member</p>
+     *
      * @author Filip Hanik
      * @version 1.0
      */
     public static class FaultyMember {
         protected Exception cause;
         protected Member member;
-        public FaultyMember(Member mbr, Exception x) { 
+        public FaultyMember(Member mbr, Exception x) {
             this.member = mbr;
             this.cause = x;
         }
-        
+
         public Member getMember() {
             return member;
         }
-        
+
         public Exception getCause() {
             return cause;
         }
-        
+
         @Override
         public String toString() {
             return "FaultyMember:"+member.toString();
         }
-        
+
         @Override
         public int hashCode() {
             return (member!=null)?member.hashCode():0;
         }
-        
+
         @Override
         public boolean equals(Object o) {
             if (member==null || (!(o instanceof FaultyMember)) || (((FaultyMember)o).member==null)) return false;

==================================================
ChannelListener.java
index 6860775efa..36d591fbb7 100644
--- a/java/org/apache/catalina/tribes/ChannelInterceptor.java
+++ b/java/org/apache/catalina/tribes/ChannelInterceptor.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,7 @@ package org.apache.catalina.tribes;
 import org.apache.catalina.tribes.group.InterceptorPayload;
 
 /**
- * A ChannelInterceptor is an interceptor that intercepts 
+ * A ChannelInterceptor is an interceptor that intercepts
  * messages and membership messages in the channel stack.
  * This allows interceptors to modify the message or perform
  * other actions when a message is sent or received.<br>
@@ -27,12 +27,12 @@ import org.apache.catalina.tribes.group.InterceptorPayload;
  * @see org.apache.catalina.tribes.group.ChannelInterceptorBase
  * @author Filip Hanik
  * @version $Id$
- */   
+ */
 
 public interface ChannelInterceptor extends MembershipListener, Heartbeat {
 
     /**
-     * An interceptor can react to a message based on a set bit on the 
+     * An interceptor can react to a message based on a set bit on the
      * message options. <br>
      * When a message is sent, the options can be retrieved from ChannelMessage.getOptions()
      * and if the bit is set, this interceptor will react to it.<br>
@@ -44,7 +44,7 @@ public interface ChannelInterceptor extends MembershipListener, Heartbeat {
      * @see ChannelMessage#getOptions()
      */
     public int getOptionFlag();
-    
+
     /**
      * Sets the option flag
      * @param flag int
@@ -80,11 +80,11 @@ public interface ChannelInterceptor extends MembershipListener, Heartbeat {
      * The <code>sendMessage</code> method is called when a message is being sent to one more destinations.
      * The interceptor can modify any of the parameters and then pass on the message down the stack by
      * invoking <code>getNext().sendMessage(destination,msg,payload)</code><br>
-     * Alternatively the interceptor can stop the message from being sent by not invoking 
+     * Alternatively the interceptor can stop the message from being sent by not invoking
      * <code>getNext().sendMessage(destination,msg,payload)</code><br>
-     * If the message is to be sent asynchronous the application can be notified of completion and 
+     * If the message is to be sent asynchronous the application can be notified of completion and
      * errors by passing in an error handler attached to a payload object.<br>
-     * The ChannelMessage.getAddress contains Channel.getLocalMember, and can be overwritten 
+     * The ChannelMessage.getAddress contains Channel.getLocalMember, and can be overwritten
      * to simulate a message sent from another node.<br>
      * @param destination Member[] - the destination for this message
      * @param msg ChannelMessage - the message to be sent
@@ -94,7 +94,7 @@ public interface ChannelInterceptor extends MembershipListener, Heartbeat {
      * @see InterceptorPayload
      */
     public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException;
-    
+
     /**
      * the <code>messageReceived</code> is invoked when a message is received.
      * <code>ChannelMessage.getAddress()</code> is the sender, or the reply-to address
@@ -102,15 +102,15 @@ public interface ChannelInterceptor extends MembershipListener, Heartbeat {
      * @param data ChannelMessage
      */
     public void messageReceived(ChannelMessage data);
-    
+
     /**
      * The <code>heartbeat()</code> method gets invoked periodically
-     * to allow interceptors to clean up resources, time out object and 
+     * to allow interceptors to clean up resources, time out object and
      * perform actions that are unrelated to sending/receiving data.
      */
     @Override
     public void heartbeat();
-    
+
     /**
      * Intercepts the <code>Channel.hasMembers()</code> method
      * @return boolean - if the channel has members in its membership group
@@ -140,7 +140,7 @@ public interface ChannelInterceptor extends MembershipListener, Heartbeat {
      * @see Channel#getMember(Member)
      */
     public Member getMember(Member mbr);
-    
+
     /**
      * Starts up the channel. This can be called multiple times for individual services to start
      * The svc parameter can be the logical or value of any constants
@@ -168,7 +168,7 @@ public interface ChannelInterceptor extends MembershipListener, Heartbeat {
      * @see Channel
      */
     public void stop(int svc) throws ChannelException;
-    
+
     public void fireInterceptorEvent(InterceptorEvent event);
 
     interface InterceptorEvent {
@@ -176,6 +176,6 @@ public interface ChannelInterceptor extends MembershipListener, Heartbeat {
         String getEventTypeDesc();
         ChannelInterceptor getInterceptor();
     }
-    
+
 
 }

==================================================
ChannelMessage.java
index 6dd619ead9..8af0437805 100644
--- a/java/org/apache/catalina/tribes/ChannelListener.java
+++ b/java/org/apache/catalina/tribes/ChannelListener.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,17 +18,17 @@ package org.apache.catalina.tribes;
 
 import java.io.Serializable;
 /**
- * 
- * <p>Title: ChannelListener</p> 
- * 
- * <p>Description: An interface to listens to incoming messages from a channel </p> 
+ *
+ * <p>Title: ChannelListener</p>
+ *
+ * <p>Description: An interface to listens to incoming messages from a channel </p>
  * When a message is received, the Channel will invoke the channel listener in a conditional sequence.
  * <code>if ( listener.accept(msg,sender) ) listener.messageReceived(msg,sender);</code><br>
  * A ChannelListener implementation MUST NOT return true on <code>accept(Serializable, Member)</code>
  * if it doesn't intend to process the message. The channel can this way track whether a message
  * was processed by an above application or if it was just received and forgot about, a feature required
  * to support message-response(RPC) calls<br>
- * 
+ *
  * @author Filip Hanik
  * @version 1.0
  */
@@ -51,7 +51,7 @@ public interface ChannelListener {
     public boolean accept(Serializable msg, Member sender);
 
     /**
-     * 
+     *
      * @param listener Object
      * @return boolean
      * @see Object#equals(Object)
@@ -60,7 +60,7 @@ public interface ChannelListener {
     public boolean equals(Object listener);
 
     /**
-     * 
+     *
      * @return int
      * @see Object#hashCode()
      */

==================================================
ChannelReceiver.java
index 4596b81b38..fb19f400f8 100644
--- a/java/org/apache/catalina/tribes/ChannelMessage.java
+++ b/java/org/apache/catalina/tribes/ChannelMessage.java
@@ -21,19 +21,19 @@ import java.io.Serializable;
 import org.apache.catalina.tribes.io.XByteBuffer;
 
 /**
- * Message that is passed through the interceptor stack after the 
- * data serialized in the Channel object and then passed down to the 
+ * Message that is passed through the interceptor stack after the
+ * data serialized in the Channel object and then passed down to the
  * interceptor and eventually down to the ChannelSender component
  * @author Filip Hanik
- * 
+ *
  */
 public interface ChannelMessage extends Serializable {
 
 
     /**
-     * Get the address that this message originated from.  
+     * Get the address that this message originated from.
      * Almost always <code>Channel.getLocalMember(boolean)</code><br>
-     * This would be set to a different address 
+     * This would be set to a different address
      * if the message was being relayed from a host other than the one
      * that originally sent it.
      * @return the source or reply-to address of this message
@@ -65,35 +65,35 @@ public interface ChannelMessage extends Serializable {
      * @return byte
      */
     public byte[] getUniqueId();
-    
+
     /**
      * The byte buffer that contains the actual message payload
      * @param buf XByteBuffer
      */
     public void setMessage(XByteBuffer buf);
-    
+
     /**
      * returns the byte buffer that contains the actual message payload
      * @return XByteBuffer
      */
     public XByteBuffer getMessage();
-    
+
     /**
      * The message options is a 32 bit flag set
      * that triggers interceptors and message behavior.
-     * @see Channel#send(Member[], Serializable, int) 
+     * @see Channel#send(Member[], Serializable, int)
      * @see ChannelInterceptor#getOptionFlag
      * @return int - the option bits set for this message
      */
     public int getOptions();
-    
+
     /**
      * sets the option bits for this message
      * @param options int
      * @see #getOptions()
      */
     public void setOptions(int options);
-    
+
     /**
      * Shallow clone, what gets cloned depends on the implementation
      * @return ChannelMessage

==================================================
ChannelSender.java
index d889ccfecd..d084ea0747 100644
--- a/java/org/apache/catalina/tribes/ChannelReceiver.java
+++ b/java/org/apache/catalina/tribes/ChannelReceiver.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -20,7 +20,7 @@ package org.apache.catalina.tribes;
 
 /**
  * ChannelReceiver Interface<br>
- * The <code>ChannelReceiver</code> interface is the data receiver component 
+ * The <code>ChannelReceiver</code> interface is the data receiver component
  * at the bottom layer, the IO layer (for layers see the javadoc for the {@link Channel} interface).
  * This class may optionally implement a thread pool for parallel processing of incoming messages.
  * @author Filip Hanik
@@ -28,7 +28,7 @@ package org.apache.catalina.tribes;
  */
 public interface ChannelReceiver extends Heartbeat {
     public static final int MAX_UDP_SIZE = 65535;
-    
+
     /**
      * Start listening for incoming messages on the host/port
      * @throws java.io.IOException
@@ -46,33 +46,33 @@ public interface ChannelReceiver extends Heartbeat {
      * @return the host that this receiver is listening to
      */
     public String getHost();
-    
-    
+
+
     /**
      * Returns the listening port
      * @return port
      */
     public int getPort();
-    
+
     /**
      * Returns the secure listening port
      * @return port, -1 if a secure port is not activated
      */
     public int getSecurePort();
-    
+
     /**
      * Returns the UDP port
      * @return port, -1 if the UDP port is not activated.
      */
     public int getUdpPort();
-    
+
     /**
      * Sets the message listener to receive notification of incoming
      * @param listener MessageListener
      * @see MessageListener
      */
     public void setMessageListener(MessageListener listener);
-    
+
     /**
      * Returns the message listener that is associated with this receiver
      * @return MessageListener

==================================================
Constants.java
index a818f1d61b..4e5135fc21 100644
--- a/java/org/apache/catalina/tribes/ChannelSender.java
+++ b/java/org/apache/catalina/tribes/ChannelSender.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,7 +22,7 @@ import java.io.IOException;
 
 /**
  * ChannelReceiver Interface<br>
- * The <code>ChannelSender</code> interface is the data sender component 
+ * The <code>ChannelSender</code> interface is the data sender component
  * at the bottom layer, the IO layer (for layers see the javadoc for the {@link Channel} interface).<br>
  * The channel sender must support "silent" members, ie, be able to send a message to a member
  * that is not in the membership, but is part of the destination parameter
@@ -43,7 +43,7 @@ public interface ChannelSender extends Heartbeat
      * @param member Member
      */
     public void remove(Member member);
-    
+
     /**
      * Start the channel sender
      * @throws IOException if preprocessing takes place and an error happens
@@ -54,13 +54,13 @@ public interface ChannelSender extends Heartbeat
      * Stop the channel sender
      */
     public void stop();
-    
+
     /**
      * A channel heartbeat, use this method to clean up resources
      */
     @Override
     public void heartbeat() ;
-    
+
     /**
      * Send a message to one or more recipients.
      * @param message ChannelMessage - the message to be sent

==================================================
ErrorHandler.java
index bb0d5b2a92..43c0b8927d 100644
--- a/java/org/apache/catalina/tribes/Constants.java
+++ b/java/org/apache/catalina/tribes/Constants.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
Heartbeat.java
index db5de4f31c..6ea95a6d1b 100644
--- a/java/org/apache/catalina/tribes/ErrorHandler.java
+++ b/java/org/apache/catalina/tribes/ErrorHandler.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -21,13 +21,13 @@ package org.apache.catalina.tribes;
 
 /**
  * The <code>ErrorHandler</code> class is used when sending messages
- * that are sent asynchronously and the application still needs to get 
+ * that are sent asynchronously and the application still needs to get
  * confirmation when the message was sent successfully or when a message errored out.
  * @author Filip Hanik
  * @version 1.0
  */
 public interface ErrorHandler {
-    
+
     /**
      * Invoked if the message is dispatched asynch, and an error occurs
      * @param x ChannelException - the error that happened
@@ -35,12 +35,12 @@ public interface ErrorHandler {
      * @see Channel#send(Member[], Serializable, int, ErrorHandler)
      */
     public void handleError(ChannelException x, UniqueId id);
-    
+
     /**
      * Invoked when the message has been sent successfully.
      * @param id - the unique id for the message
      * @see Channel#send(Member[], Serializable, int, ErrorHandler)
      */
     public void handleCompletion(UniqueId id);
-    
+
 }
\ No newline at end of file

==================================================
ManagedChannel.java
index 95065e5bb6..37b2d2f46b 100644
--- a/java/org/apache/catalina/tribes/Heartbeat.java
+++ b/java/org/apache/catalina/tribes/Heartbeat.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -25,7 +25,7 @@ package org.apache.catalina.tribes;
  * @see Channel#heartbeat()
  */
 public interface Heartbeat {
-    
+
     /**
      * Heartbeat invocation for resources cleanup etc
      */

==================================================
MembershipListener.java
index 1600538a0f..27745c96aa 100644
--- a/java/org/apache/catalina/tribes/ManagedChannel.java
+++ b/java/org/apache/catalina/tribes/ManagedChannel.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -40,7 +40,7 @@ public interface ManagedChannel extends Channel {
      * @see ChannelReceiver
      */
     public void setChannelReceiver(ChannelReceiver receiver);
-    
+
     /**
      * Sets the membership service
      * @param service MembershipService
@@ -54,14 +54,14 @@ public interface ManagedChannel extends Channel {
      * @see ChannelSender
      */
     public ChannelSender getChannelSender();
-    
+
     /**
      * returns the channel receiver
      * @return ChannelReceiver
      * @see ChannelReceiver
      */
     public ChannelReceiver getChannelReceiver();
-    
+
     /**
      * Returns the membership service
      * @return MembershipService

==================================================
MembershipService.java
index 95e36416df..8a4d637a22 100644
--- a/java/org/apache/catalina/tribes/MembershipListener.java
+++ b/java/org/apache/catalina/tribes/MembershipListener.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -33,7 +33,7 @@ public interface MembershipListener {
      * @param member Member - the member that was added
      */
     public void memberAdded(Member member);
-    
+
     /**
      * A member was removed from the group<br>
      * If the member left voluntarily, the Member.getCommand will contain the Member.SHUTDOWN_PAYLOAD data

==================================================
MessageListener.java
index cb6f49d00a..d0e31f459c 100644
--- a/java/org/apache/catalina/tribes/MembershipService.java
+++ b/java/org/apache/catalina/tribes/MembershipService.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -20,7 +20,7 @@ package org.apache.catalina.tribes;
 
 /**
  * MembershipService Interface<br>
- * The <code>MembershipService</code> interface is the membership component 
+ * The <code>MembershipService</code> interface is the membership component
  * at the bottom layer, the IO layer (for layers see the javadoc for the {@link Channel} interface).<br>
  * @author Filip Hanik
  * @version $Id$
@@ -28,10 +28,10 @@ package org.apache.catalina.tribes;
 
 
 public interface MembershipService {
-    
+
     public static final int MBR_RX = Channel.MBR_RX_SEQ;
     public static final int MBR_TX = Channel.MBR_TX_SEQ;
-    
+
     /**
      * Sets the properties for the membership service. This must be called before
      * the <code>start()</code> method is called.
@@ -54,7 +54,7 @@ public interface MembershipService {
     /**
      * Starts the membership service. If a membership listeners is added
      * the listener will start to receive membership events.
-     * @param level - level MBR_RX starts listening for members, level MBR_TX 
+     * @param level - level MBR_RX starts listening for members, level MBR_TX
      * starts broad casting the server
      * @throws java.lang.Exception if the service fails to start.
      * @throws java.lang.IllegalArgumentException if the level is incorrect.
@@ -65,22 +65,22 @@ public interface MembershipService {
     /**
      * Starts the membership service. If a membership listeners is added
      * the listener will start to receive membership events.
-     * @param level - level MBR_RX stops listening for members, level MBR_TX 
+     * @param level - level MBR_RX stops listening for members, level MBR_TX
      * stops broad casting the server
      * @throws java.lang.Exception if the service fails to stop
      * @throws java.lang.IllegalArgumentException if the level is incorrect.
      */
 
     public void stop(int level);
-    
+
     /**
      * @return true if the the group contains members
      */
     public boolean hasMembers();
-    
-    
+
+
     /**
-     * 
+     *
      * @param mbr Member
      * @return Member
      */
@@ -88,9 +88,9 @@ public interface MembershipService {
     /**
      * Returns a list of all the members in the cluster.
      */
-    
+
     public Member[] getMembers();
-    
+
     /**
      * Returns the member object that defines this member
      */
@@ -99,8 +99,8 @@ public interface MembershipService {
     /**
      * Return all members by name
      */
-    public String[] getMembersByName() ; 
-    
+    public String[] getMembersByName() ;
+
     /**
      * Return the member by name
      */
@@ -110,28 +110,28 @@ public interface MembershipService {
      * Sets the local member properties for broadcasting
      */
     public void setLocalMemberProperties(String listenHost, int listenPort, int securePort, int udpPort);
-    
+
     /**
      * Sets the membership listener, only one listener can be added.
      * If you call this method twice, the last listener will be used.
      * @param listener The listener
      */
     public void setMembershipListener(MembershipListener listener);
-    
+
     /**
      * removes the membership listener.
      */
     public void removeMembershipListener();
-    
+
     /**
-     * Set a payload to be broadcasted with each membership 
+     * Set a payload to be broadcasted with each membership
      * broadcast.
      * @param payload byte[]
      */
     public void setPayload(byte[] payload);
-    
+
     public void setDomain(byte[] domain);
-    
+
     /**
      * Broadcasts a message to all members
      * @param message

==================================================
UniqueId.java
index d57968ecdd..9d5dc0e185 100644
--- a/java/org/apache/catalina/tribes/MessageListener.java
+++ b/java/org/apache/catalina/tribes/MessageListener.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,28 +17,28 @@
 package org.apache.catalina.tribes;
 
 /**
- * 
- * <p>Title: MessageListener</p> 
- * 
- * <p>Description: The listener to be registered with the ChannelReceiver, internal Tribes component</p> 
- * 
+ *
+ * <p>Title: MessageListener</p>
+ *
+ * <p>Description: The listener to be registered with the ChannelReceiver, internal Tribes component</p>
+ *
  * @author Filip Hanik
  * @version 1.0
  */
 
 public interface MessageListener {
-    
+
     /**
      * Receive a message from the IO components in the Channel stack
      * @param msg ChannelMessage
      */
     public void messageReceived(ChannelMessage msg);
-    
+
     public boolean accept(ChannelMessage msg);
-    
+
     @Override
     public boolean equals(Object listener);
-    
+
     @Override
     public int hashCode();
 

==================================================
AbsoluteOrder.java
index 2bec537721..e62ed9257d 100644
--- a/java/org/apache/catalina/tribes/UniqueId.java
+++ b/java/org/apache/catalina/tribes/UniqueId.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -32,25 +32,25 @@ public final class UniqueId implements Serializable{
     private static final long serialVersionUID = 1L;
 
     protected byte[] id;
-    
+
     public UniqueId() {
     }
 
     public UniqueId(byte[] id) {
         this.id = id;
     }
-    
+
     public UniqueId(byte[] id, int offset, int length) {
         this.id = new byte[length];
         System.arraycopy(id,offset,this.id,0,length);
     }
-    
+
     @Override
     public int hashCode() {
         if ( id == null ) return 0;
         return Arrays.hashCode(id);
     }
-    
+
     @Override
     public boolean equals(Object other) {
         boolean result = (other instanceof UniqueId);
@@ -63,11 +63,11 @@ public final class UniqueId implements Serializable{
         }//end if
         return result;
     }
-    
+
     public byte[] getBytes() {
         return id;
     }
-    
+
     @Override
     public String toString() {
         StringBuilder buf = new StringBuilder("UniqueId");

==================================================
ChannelCoordinator.java
index e806a33fcd..9dfb66b7b4 100644
--- a/java/org/apache/catalina/tribes/group/AbsoluteOrder.java
+++ b/java/org/apache/catalina/tribes/group/AbsoluteOrder.java
@@ -31,14 +31,14 @@ import org.apache.catalina.tribes.Member;
  *    Ordering members can serve as a basis for electing a leader or coordinating efforts.<br>
  *    This is stinky simple, it works on the basis of the <code>Member</code> interface
  *    and orders members in the following format:
- * 
+ *
  *  <ol>
  *     <li>IP comparison - byte by byte, lower byte higher rank</li>
  *     <li>IPv4 addresses rank higher than IPv6, ie the lesser number of bytes, the higher rank</li>
  *     <li>Port comparison - lower port, higher rank</li>
  *     <li>UniqueId comparison- byte by byte, lower byte higher rank</li>
  *  </ol>
- *     
+ *
  * </p>
  *
  * @author Filip Hanik
@@ -47,7 +47,7 @@ import org.apache.catalina.tribes.Member;
  */
 public class AbsoluteOrder {
     public static final AbsoluteComparator comp = new AbsoluteComparator();
-    
+
     protected AbsoluteOrder() {
         super();
     }
@@ -57,15 +57,15 @@ public class AbsoluteOrder {
         if ( members == null || members.length <= 1 ) return;
         Arrays.sort(members,comp);
     }
-    
+
     public static void absoluteOrder(List<Member> members) {
         if ( members == null || members.size() <= 1 ) return;
         java.util.Collections.sort(members, comp);
     }
-    
+
     public static class AbsoluteComparator implements Comparator<Member>,
             Serializable {
-        
+
         private static final long serialVersionUID = 1L;
 
         @Override
@@ -75,19 +75,19 @@ public class AbsoluteOrder {
             if ( result == 0 ) result = compareIds(m1,m2);
             return result;
         }
-        
+
         public int compareIps(Member m1, Member m2) {
             return compareBytes(m1.getHost(),m2.getHost());
         }
-        
+
         public int comparePorts(Member m1, Member m2) {
             return compareInts(m1.getPort(),m2.getPort());
         }
-        
+
         public int compareIds(Member m1, Member m2) {
             return compareBytes(m1.getUniqueId(),m2.getUniqueId());
         }
-        
+
         protected int compareBytes(byte[] d1, byte[] d2) {
             int result = 0;
             if ( d1.length == d2.length ) {
@@ -101,11 +101,11 @@ public class AbsoluteOrder {
             }
             return result;
         }
-        
+
         protected int compareBytes(byte b1, byte b2) {
             return compareInts(b1,b2);
         }
-        
+
         protected int compareInts(int b1, int b2) {
             int result = 0;
             if ( b1 == b2 ) {
@@ -118,5 +118,5 @@ public class AbsoluteOrder {
             return result;
         }
     }
-    
+
 }

==================================================
ChannelInterceptorBase.java
index 3adc910424..927df73534 100644
--- a/java/org/apache/catalina/tribes/group/ChannelCoordinator.java
+++ b/java/org/apache/catalina/tribes/group/ChannelCoordinator.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -44,7 +44,7 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
     private ChannelReceiver clusterReceiver = new NioReceiver();
     private ChannelSender clusterSender = new ReplicationTransmitter();
     private MembershipService membershipService = new McastService();
-    
+
     private int startLevel = 0;
 
     public ChannelCoordinator() {
@@ -53,7 +53,7 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
                 Channel.SEND_OPTIONS_USE_ACK |
                 Channel.SEND_OPTIONS_SYNCHRONIZED_ACK;
     }
-    
+
     public ChannelCoordinator(ChannelReceiver receiver,
                               ChannelSender sender,
                               MembershipService service) {
@@ -62,7 +62,7 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
         this.setClusterSender(sender);
         this.setMembershipService(service);
     }
-    
+
     /**
      * Send a message to one or more members in the cluster
      * @param destination Member[] - the destinations, null or zero length means all
@@ -81,7 +81,7 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
             Logs.MESSAGES.trace("ChannelCoordinator - Sent msg:" + new UniqueId(msg.getUniqueId()) + " at " +new java.sql.Timestamp(System.currentTimeMillis())+ " to "+Arrays.toNameString(destination));
         }
     }
-    
+
 
     /**
      * Starts up the channel. This can be called multiple times for individual services to start
@@ -113,7 +113,7 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
     @Override
     public void stop(int svc) throws ChannelException {
         this.internalStop(svc);
-    }    
+    }
 
 
     /**
@@ -135,7 +135,7 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
 
             if (startLevel == Channel.DEFAULT) return; //we have already started up all components
             if (svc == 0 ) return;//nothing to start
-            
+
             if (svc == (svc & startLevel)) throw new ChannelException("Channel already started for level:"+svc);
 
             //must start the receiver first so that we can coordinate the port it
@@ -144,7 +144,7 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
                 clusterReceiver.setMessageListener(this);
                 clusterReceiver.start();
                 //synchronize, big time FIXME
-                membershipService.setLocalMemberProperties(getClusterReceiver().getHost(), 
+                membershipService.setLocalMemberProperties(getClusterReceiver().getHost(),
                                                            getClusterReceiver().getPort(),
                                                            getClusterReceiver().getSecurePort(),
                                                            getClusterReceiver().getUdpPort());
@@ -154,7 +154,7 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
                 clusterSender.start();
                 valid = true;
             }
-            
+
             if ( Channel.MBR_RX_SEQ==(svc & Channel.MBR_RX_SEQ) ) {
                 membershipService.setMembershipListener(this);
                 if (membershipService instanceof McastService) {
@@ -167,7 +167,7 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
                 membershipService.start(MembershipService.MBR_TX);
                 valid = true;
             }
-            
+
             if ( !valid) {
                 throw new IllegalArgumentException("Invalid start level, valid levels are:SND_RX_SEQ,SND_TX_SEQ,MBR_TX_SEQ,MBR_RX_SEQ");
             }
@@ -213,38 +213,38 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
                 membershipService.stop(MembershipService.MBR_RX);
                 membershipService.setMembershipListener(null);
                 valid = true;
-                
+
             }
             if ( Channel.MBR_TX_SEQ==(svc & Channel.MBR_TX_SEQ) ) {
                 valid = true;
                 membershipService.stop(MembershipService.MBR_TX);
-            }            
+            }
             if ( !valid) {
                 throw new IllegalArgumentException("Invalid start level, valid levels are:SND_RX_SEQ,SND_TX_SEQ,MBR_TX_SEQ,MBR_RX_SEQ");
             }
 
             startLevel = (startLevel & (~svc));
-            
+
         }catch ( Exception x ) {
             throw new ChannelException(x);
         } finally {
-            
+
         }
 
     }
-    
+
     @Override
     public void memberAdded(Member member){
         SenderState.getSenderState(member);
         super.memberAdded(member);
     }
-    
+
     @Override
     public void memberDisappeared(Member member){
         SenderState.removeSenderState(member);
         super.memberDisappeared(member);
     }
-    
+
     @Override
     public void messageReceived(ChannelMessage msg) {
         if ( Logs.MESSAGES.isTraceEnabled() ) {
@@ -283,13 +283,13 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
         this.membershipService = membershipService;
         this.membershipService.setMembershipListener(this);
     }
-    
+
     @Override
     public void heartbeat() {
         if ( clusterSender!=null ) clusterSender.heartbeat();
         super.heartbeat();
     }
-    
+
     /**
      * has members
      */
@@ -308,7 +308,7 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
     }
 
     /**
-     * 
+     *
      * @param mbr Member
      * @return Member
      */
@@ -328,5 +328,5 @@ public class ChannelCoordinator extends ChannelInterceptorBase implements Messag
         return this.getMembershipService().getLocalMember(incAlive);
     }
 
-   
+
 }

==================================================
ExtendedRpcCallback.java
index 1745a3940a..2b8bf07377 100644
--- a/java/org/apache/catalina/tribes/group/ChannelInterceptorBase.java
+++ b/java/org/apache/catalina/tribes/group/ChannelInterceptorBase.java
@@ -37,8 +37,8 @@ public abstract class ChannelInterceptorBase implements ChannelInterceptor {
     public ChannelInterceptorBase() {
 
     }
-    
-    public boolean okToProcess(int messageFlags) { 
+
+    public boolean okToProcess(int messageFlags) {
         if (this.optionFlag == 0 ) return true;
         return ((optionFlag&messageFlags) == optionFlag);
     }
@@ -145,7 +145,7 @@ public abstract class ChannelInterceptorBase implements ChannelInterceptor {
         if ( getNext()!=null ) return getNext().getLocalMember(incAlive);
         else return null;
     }
-    
+
     /**
      * Starts up the channel. This can be called multiple times for individual services to start
      * The svc parameter can be the logical or value of any constants
@@ -177,7 +177,7 @@ public abstract class ChannelInterceptorBase implements ChannelInterceptor {
     public void stop(int svc) throws ChannelException {
         if (getNext() != null) getNext().stop(svc);
     }
-    
+
     @Override
     public void fireInterceptorEvent(InterceptorEvent event) {
         //empty operation

==================================================
GroupChannel.java
index e24e484161..e03d43ddd4 100644
--- a/java/org/apache/catalina/tribes/group/ExtendedRpcCallback.java
+++ b/java/org/apache/catalina/tribes/group/ExtendedRpcCallback.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -21,23 +21,23 @@ import java.io.Serializable;
 import org.apache.catalina.tribes.Member;
 /**
  * Extension to the {@link RpcCallback} interface. Allows a RPC messenger to get a confirmation if the reply
- * was sent successfully to the original sender. 
+ * was sent successfully to the original sender.
  * @author fhanik
  *
  */
 public interface ExtendedRpcCallback extends RpcCallback {
-    
+
     /**
-     * The reply failed. 
+     * The reply failed.
      * @param request - the original message that requested the reply
      * @param response - the reply message to the original message
      * @param sender - the sender requested that reply
      * @param reason - the reason the reply failed
      */
     public void replyFailed(Serializable request, Serializable response, Member sender, Exception reason);
-    
+
     /**
-     * The reply succeeded 
+     * The reply succeeded
      * @param request - the original message that requested the reply
      * @param response - the reply message to the original message
      * @param sender - the sender requested that reply

==================================================
InterceptorPayload.java
index 0e32715115..96f6c5f34e 100644
--- a/java/org/apache/catalina/tribes/group/GroupChannel.java
+++ b/java/org/apache/catalina/tribes/group/GroupChannel.java
@@ -292,7 +292,7 @@ public class GroupChannel extends ChannelInterceptorBase implements ManagedChann
             }
 
         } catch ( Exception x ) {
-            //this could be the channel listener throwing an exception, we should log it 
+            //this could be the channel listener throwing an exception, we should log it
             //as a warning.
             if ( log.isWarnEnabled() ) log.warn("Error receiving message:",x);
             throw new RemoteProcessException("Exception:"+x.getMessage(),x);

==================================================
Response.java
index 27ef3e8c47..7d7124f0e6 100644
--- a/java/org/apache/catalina/tribes/group/InterceptorPayload.java
+++ b/java/org/apache/catalina/tribes/group/InterceptorPayload.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -24,7 +24,7 @@ import org.apache.catalina.tribes.ErrorHandler;
  */
 public class InterceptorPayload  {
     private ErrorHandler errorHandler;
-    
+
     public ErrorHandler getErrorHandler() {
         return errorHandler;
     }

==================================================
RpcCallback.java
index 16e01a8155..587bd97160 100644
--- a/java/org/apache/catalina/tribes/group/Response.java
+++ b/java/org/apache/catalina/tribes/group/Response.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -30,7 +30,7 @@ public class Response {
     private Serializable message;
     public Response() {
     }
-    
+
     public Response(Member source, Serializable message) {
         this.source = source;
         this.message = message;

==================================================
RpcChannel.java
index 93140db044..8201b2ced8 100644
--- a/java/org/apache/catalina/tribes/group/RpcCallback.java
+++ b/java/org/apache/catalina/tribes/group/RpcCallback.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -27,14 +27,14 @@ import org.apache.catalina.tribes.Member;
  * @version 1.0
  */
 public interface RpcCallback {
-    
+
     /**
-     * 
+     *
      * @param msg Serializable
      * @return Serializable - null if no reply should be sent
      */
     public Serializable replyRequest(Serializable msg, Member sender);
-    
+
     /**
      * If the reply has already been sent to the requesting thread,
      * the rpc callback can handle any data that comes in after the fact.
@@ -42,5 +42,5 @@ public interface RpcCallback {
      * @param sender Member
      */
     public void leftOver(Serializable msg, Member sender);
-    
+
 }
\ No newline at end of file

==================================================
RpcMessage.java
index 39c4c04534..9e4c284c76 100644
--- a/java/org/apache/catalina/tribes/group/RpcChannel.java
+++ b/java/org/apache/catalina/tribes/group/RpcChannel.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -37,12 +37,12 @@ import org.apache.juli.logging.LogFactory;
  */
 public class RpcChannel implements ChannelListener{
     private static final Log log = LogFactory.getLog(RpcChannel.class);
-    
+
     public static final int FIRST_REPLY = 1;
     public static final int MAJORITY_REPLY = 2;
     public static final int ALL_REPLY = 3;
     public static final int NO_REPLY = 4;
-    
+
     private Channel channel;
     private RpcCallback callback;
     private byte[] rpcId;
@@ -63,8 +63,8 @@ public class RpcChannel implements ChannelListener{
         this.rpcId = rpcId;
         channel.addChannelListener(this);
     }
-    
-    
+
+
     /**
      * Send a message and wait for the response.
      * @param destination Member[] - the destination for the message, and the members you request a reply from
@@ -75,18 +75,18 @@ public class RpcChannel implements ChannelListener{
      * @return Response[] - an array of response objects.
      * @throws ChannelException
      */
-    public Response[] send(Member[] destination, 
+    public Response[] send(Member[] destination,
                            Serializable message,
-                           int rpcOptions, 
+                           int rpcOptions,
                            int channelOptions,
                            long timeout) throws ChannelException {
-        
+
         if ( destination==null || destination.length == 0 ) return new Response[0];
-        
+
         //avoid dead lock
         int sendOptions =
             channelOptions & ~Channel.SEND_OPTIONS_SYNCHRONIZED_ACK;
-        
+
         RpcCollectorKey key = new RpcCollectorKey(UUIDGenerator.randomUUID(false));
         RpcCollector collector = new RpcCollector(key,rpcOptions,destination.length,timeout);
         try {
@@ -103,7 +103,7 @@ public class RpcChannel implements ChannelListener{
         }
         return collector.getResponses();
     }
-    
+
     @Override
     public void messageReceived(Serializable msg, Member sender) {
         RpcMessage rmsg = (RpcMessage)msg;
@@ -116,13 +116,13 @@ public class RpcChannel implements ChannelListener{
                 synchronized (collector) {
                     //make sure it hasn't been removed
                     if ( responseMap.containsKey(key) ) {
-                        if ( (rmsg instanceof RpcMessage.NoRpcChannelReply) ) 
+                        if ( (rmsg instanceof RpcMessage.NoRpcChannelReply) )
                             collector.destcnt--;
-                        else 
+                        else
                             collector.addResponse(rmsg.message, sender);
                         if (collector.isComplete()) collector.notifyAll();
                     } else {
-                        if (! (rmsg instanceof RpcMessage.NoRpcChannelReply) ) 
+                        if (! (rmsg instanceof RpcMessage.NoRpcChannelReply) )
                             callback.leftOver(rmsg.message, sender);
                     }
                 }//synchronized
@@ -169,16 +169,16 @@ public class RpcChannel implements ChannelListener{
             }
         }//end if
     }
-    
+
     public void breakdown() {
         channel.removeChannelListener(this);
     }
-    
+
     @Override
     public void finalize() {
         breakdown();
     }
-    
+
     @Override
     public boolean accept(Serializable msg, Member sender) {
         if ( msg instanceof RpcMessage ) {
@@ -186,7 +186,7 @@ public class RpcChannel implements ChannelListener{
             return Arrays.equals(rmsg.rpcId,rpcId);
         }else return false;
     }
-    
+
     public Channel getChannel() {
         return channel;
     }
@@ -218,32 +218,32 @@ public class RpcChannel implements ChannelListener{
     public void setReplyMessageOptions(int replyMessageOptions) {
         this.replyMessageOptions = replyMessageOptions;
     }
-        
+
     /**
-     * 
+     *
      * Class that holds all response.
      * @author not attributable
      * @version 1.0
      */
     public static class RpcCollector {
-        public ArrayList<Response> responses = new ArrayList<Response>(); 
+        public ArrayList<Response> responses = new ArrayList<Response>();
         public RpcCollectorKey key;
         public int options;
         public int destcnt;
         public long timeout;
-        
+
         public RpcCollector(RpcCollectorKey key, int options, int destcnt, long timeout) {
             this.key = key;
             this.options = options;
             this.destcnt = destcnt;
             this.timeout = timeout;
         }
-        
+
         public void addResponse(Serializable message, Member sender){
             Response resp = new Response(sender,message);
             responses.add(resp);
         }
-        
+
         public boolean isComplete() {
             if ( destcnt <= 0 ) return true;
             switch (options) {
@@ -260,12 +260,12 @@ public class RpcChannel implements ChannelListener{
                     return false;
             }
         }
-        
+
         @Override
         public int hashCode() {
             return key.hashCode();
         }
-        
+
         @Override
         public boolean equals(Object o) {
             if ( o instanceof RpcCollector ) {
@@ -273,18 +273,18 @@ public class RpcChannel implements ChannelListener{
                 return r.key.equals(this.key);
             } else return false;
         }
-        
+
         public Response[] getResponses() {
             return responses.toArray(new Response[responses.size()]);
         }
     }
-    
+
     public static class RpcCollectorKey {
         byte[] id;
         public RpcCollectorKey(byte[] id) {
             this.id = id;
         }
-        
+
         @Override
         public int hashCode() {
             return id[0]+id[1]+id[2]+id[3];
@@ -297,9 +297,9 @@ public class RpcChannel implements ChannelListener{
                 return Arrays.equals(id,r.id);
             } else return false;
         }
-        
+
     }
-    
+
     protected static String bToS(byte[] data) {
         StringBuilder buf = new StringBuilder(4*16);
         buf.append("{");

==================================================
DomainFilterInterceptor.java
index 54fe1ad699..7f9f38f9d3 100644
--- a/java/org/apache/catalina/tribes/group/RpcMessage.java
+++ b/java/org/apache/catalina/tribes/group/RpcMessage.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -73,7 +73,7 @@ public class RpcMessage implements Externalizable {
         out.write(rpcId, 0, rpcId.length);
         out.writeObject(message);
     }
-    
+
     @Override
     public String toString() {
         StringBuilder buf = new StringBuilder("RpcMessage[");
@@ -86,10 +86,10 @@ public class RpcMessage implements Externalizable {
         buf.append(message);
         return buf.toString();
     }
-    
+
     public static class NoRpcChannelReply extends RpcMessage {
         public NoRpcChannelReply() {
-            
+
         }
 
         public NoRpcChannelReply(byte[] rpcid, byte[] uuid) {
@@ -115,7 +115,7 @@ public class RpcMessage implements Externalizable {
             out.writeInt(rpcId.length);
             out.write(rpcId, 0, rpcId.length);
         }
-    }    
+    }
 
 
 }

==================================================
FragmentationInterceptor.java
index fc81f2ffca..537173e27d 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/DomainFilterInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/DomainFilterInterceptor.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -36,7 +36,7 @@ import org.apache.catalina.tribes.membership.Membership;
 public class DomainFilterInterceptor extends ChannelInterceptorBase {
 
     protected Membership membership = null;
-    
+
     protected byte[] domain = new byte[0];
 
     @Override

==================================================
GzipInterceptor.java
index f18ba4b493..b1291efab3 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -33,7 +33,7 @@ import org.apache.catalina.tribes.io.XByteBuffer;
  * The fragmentation interceptor splits up large messages into smaller messages and assembles them on the other end.
  * This is very useful when you don't want large messages hogging the sending sockets
  * and smaller messages can make it through.
- * 
+ *
  * <br><b>Configuration Options</b><br>
  * OrderInteceptor.expire=<milliseconds> - how long do we keep the fragments in memory and wait for the rest to arrive<b>default=60,000ms -> 60seconds</b>
  * This setting is useful to avoid OutOfMemoryErrors<br>
@@ -43,7 +43,7 @@ import org.apache.catalina.tribes.io.XByteBuffer;
  */
 public class FragmentationInterceptor extends ChannelInterceptorBase {
     private static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( FragmentationInterceptor.class );
-    
+
     protected HashMap<FragKey, FragCollection> fragpieces = new HashMap<FragKey, FragCollection>();
     private int maxSize = 1024*100;
     private long expire = 1000 * 60; //one minute expiration
@@ -61,7 +61,7 @@ public class FragmentationInterceptor extends ChannelInterceptorBase {
             super.sendMessage(destination, msg, payload);
         }
     }
-    
+
     @Override
     public void messageReceived(ChannelMessage msg) {
         boolean isFrag = XByteBuffer.toBoolean(msg.getMessage().getBytesDirect(),msg.getMessage().getLength()-1);
@@ -73,7 +73,7 @@ public class FragmentationInterceptor extends ChannelInterceptorBase {
         }
     }
 
-    
+
     public FragCollection getFragCollection(FragKey key, ChannelMessage msg) {
         FragCollection coll = fragpieces.get(key);
         if ( coll == null ) {
@@ -84,15 +84,15 @@ public class FragmentationInterceptor extends ChannelInterceptorBase {
                     fragpieces.put(key, coll);
                 }
             }
-        } 
+        }
         return coll;
     }
-    
+
     public void removeFragCollection(FragKey key) {
         fragpieces.remove(key);
     }
-    
-    public void defrag(ChannelMessage msg ) { 
+
+    public void defrag(ChannelMessage msg ) {
         FragKey key = new FragKey(msg.getUniqueId());
         FragCollection coll = getFragCollection(key,msg);
         coll.addMessage((ChannelMessage)msg.deepclone());
@@ -101,7 +101,7 @@ public class FragmentationInterceptor extends ChannelInterceptorBase {
             removeFragCollection(key);
             ChannelMessage complete = coll.assemble();
             super.messageReceived(complete);
-            
+
         }
     }
 
@@ -129,21 +129,21 @@ public class FragmentationInterceptor extends ChannelInterceptorBase {
             tmp.getMessage().append(true);
             messages[i] = tmp;
             remaining -= length;
-            
+
         }
         for ( int i=0; i<messages.length; i++ ) {
             super.sendMessage(destination,messages[i],payload);
         }
     }
-    
+
     @Override
     public void heartbeat() {
         try {
-            Set<FragKey> set = fragpieces.keySet(); 
+            Set<FragKey> set = fragpieces.keySet();
             Object[] keys = set.toArray();
             for ( int i=0; i<keys.length; i++ ) {
                 FragKey key = (FragKey)keys[i];
-                if ( key != null && key.expired(getExpire()) ) 
+                if ( key != null && key.expired(getExpire()) )
                     removeFragCollection(key);
             }
         }catch ( Exception x ) {
@@ -181,7 +181,7 @@ public class FragmentationInterceptor extends ChannelInterceptorBase {
             frags = new XByteBuffer[count];
             this.msg = msg;
         }
-        
+
         public void addMessage(ChannelMessage msg) {
             //remove the total messages
             msg.getMessage().trim(4);
@@ -190,15 +190,15 @@ public class FragmentationInterceptor extends ChannelInterceptorBase {
             //remove the msg nr
             msg.getMessage().trim(4);
             frags[nr] = msg.getMessage();
-            
+
         }
-        
+
         public boolean complete() {
             boolean result = true;
             for ( int i=0; (i<frags.length) && (result); i++ ) result = (frags[i] != null);
             return result;
         }
-        
+
         public ChannelMessage assemble() {
             if ( !complete() ) throw new IllegalStateException("Fragments are missing.");
             int buffersize = 0;
@@ -210,14 +210,14 @@ public class FragmentationInterceptor extends ChannelInterceptorBase {
             }
             return msg;
         }
-        
+
         public boolean expired(long expire) {
             return (System.currentTimeMillis()-received)>expire;
         }
 
 
     }
-    
+
     public static class FragKey {
         private byte[] uniqueId;
         private long received = System.currentTimeMillis();
@@ -228,7 +228,7 @@ public class FragmentationInterceptor extends ChannelInterceptorBase {
         public int hashCode() {
             return XByteBuffer.toInt(uniqueId,0);
         }
-        
+
         @Override
         public boolean equals(Object o ) {
             if ( o instanceof FragKey ) {
@@ -236,11 +236,11 @@ public class FragmentationInterceptor extends ChannelInterceptorBase {
         } else return false;
 
         }
-        
+
         public boolean expired(long expire) {
             return (System.currentTimeMillis()-received)>expire;
         }
 
     }
-    
+
 }
\ No newline at end of file

==================================================
MessageDispatch15Interceptor.java
index 25926c665b..09dce4e16b 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/GzipInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/GzipInterceptor.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -41,7 +41,7 @@ public class GzipInterceptor extends ChannelInterceptorBase {
     private static final Log log = LogFactory.getLog(GzipInterceptor.class);
 
     public static final int DEFAULT_BUFFER_SIZE = 2048;
-    
+
     @Override
     public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
         try {
@@ -66,7 +66,7 @@ public class GzipInterceptor extends ChannelInterceptorBase {
             log.error("Unable to decompress byte contents",x);
         }
     }
-    
+
     public static byte[] compress(byte[] data) throws IOException {
         ByteArrayOutputStream bout = new ByteArrayOutputStream();
         GZIPOutputStream gout = new GZIPOutputStream(bout);
@@ -75,7 +75,7 @@ public class GzipInterceptor extends ChannelInterceptorBase {
         gout.close();
         return bout.toByteArray();
     }
-    
+
     /**
      * @param data  Data to decompress
      * @return      Decompressed data

==================================================
MessageDispatchInterceptor.java
index 205f64476f..4256219361 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/MessageDispatch15Interceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/MessageDispatch15Interceptor.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -28,11 +28,11 @@ import org.apache.catalina.tribes.transport.bio.util.LinkObject;
 import org.apache.catalina.tribes.util.TcclThreadFactory;
 
 /**
- * 
+ *
  * Same implementation as the MessageDispatchInterceptor
  * except it uses an atomic long for the currentSize calculation
  * and uses a thread pool for message sending.
- * 
+ *
  * @author Filip Hanik
  * @version 1.0
  */
@@ -61,7 +61,7 @@ public class MessageDispatch15Interceptor extends MessageDispatchInterceptor {
         currentSize.set(value);
         return value;
     }
-    
+
     @Override
     public boolean addToQueue(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
         final LinkObject obj = new LinkObject(msg,destination,payload);

==================================================
NonBlockingCoordinator.java
index 55079a64bd..643ee8fa35 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -34,9 +34,9 @@ import org.apache.juli.logging.LogFactory;
  * The message dispatcher is a way to enable asynchronous communication
  * through a channel. The dispatcher will look for the <code>Channel.SEND_OPTIONS_ASYNCHRONOUS</code>
  * flag to be set, if it is, it will queue the message for delivery and immediately return to the sender.
- * 
- * 
- * 
+ *
+ *
+ *
  * @author Filip Hanik
  * @version 1.0
  */
@@ -77,15 +77,15 @@ public class MessageDispatchInterceptor extends ChannelInterceptorBase implement
             super.sendMessage(destination, msg, payload);
         }
     }
-    
+
     public boolean addToQueue(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {
         return queue.add(msg,destination,payload);
     }
-    
+
     public LinkObject removeFromQueue() {
         return queue.remove();
     }
-    
+
     public void startQueue() {
         msgDispatchThread = new Thread(this);
         msgDispatchThread.setName("MessageDispatchInterceptor.MessageDispatchThread");
@@ -95,15 +95,15 @@ public class MessageDispatchInterceptor extends ChannelInterceptorBase implement
         run = true;
         msgDispatchThread.start();
     }
-    
+
     public void stopQueue() {
         run = false;
         msgDispatchThread.interrupt();
         queue.setEnabled(false);
         setAndGetCurrentSize(0);
     }
-    
-    
+
+
     @Override
     public void setOptionFlag(int flag) {
         if ( flag != Channel.SEND_OPTIONS_ASYNCHRONOUS ) log.warn("Warning, you are overriding the asynchronous option flag, this will disable the Channel.SEND_OPTIONS_ASYNCHRONOUS that other apps might use.");
@@ -125,16 +125,16 @@ public class MessageDispatchInterceptor extends ChannelInterceptorBase implement
     public boolean getUseDeepClone() {
         return useDeepClone;
     }
-    
+
     public long getCurrentSize() {
         return currentSize;
     }
-    
+
     public synchronized long addAndGetCurrentSize(long inc) {
         currentSize += inc;
         return currentSize;
     }
-    
+
     public synchronized long setAndGetCurrentSize(long value) {
         currentSize = value;
         return value;
@@ -153,7 +153,7 @@ public class MessageDispatchInterceptor extends ChannelInterceptorBase implement
         super.start(svc);
     }
 
-    
+
     @Override
     public void stop(int svc) throws ChannelException {
         //stop the thread
@@ -185,7 +185,7 @@ public class MessageDispatchInterceptor extends ChannelInterceptorBase implement
         try {
             super.sendMessage(destination,msg,null);
             try {
-                if ( link.getHandler() != null ) link.getHandler().handleCompletion(new UniqueId(msg.getUniqueId())); 
+                if ( link.getHandler() != null ) link.getHandler().handleCompletion(new UniqueId(msg.getUniqueId()));
             } catch ( Exception ex ) {
                 log.error("Unable to report back completed message.",ex);
             }

==================================================
OrderInterceptor.java
index 8bb304fd82..8833b1f627 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -40,7 +40,7 @@ import org.apache.juli.logging.LogFactory;
  * <p>Title: Auto merging leader election algorithm</p>
  *
  * <p>Description: Implementation of a simple coordinator algorithm that not only selects a coordinator,
- *    it also merges groups automatically when members are discovered that werent part of the 
+ *    it also merges groups automatically when members are discovered that werent part of the
  *    </p>
  * <p>This algorithm is non blocking meaning it allows for transactions while the coordination phase is going on
  * </p>
@@ -48,7 +48,7 @@ import org.apache.juli.logging.LogFactory;
  * to pass a token ring of the current membership.<br>
  * This is not the same as just using AbsoluteOrder! Consider the following scenario:<br>
  * Nodes, A,B,C,D,E on a network, in that priority. AbsoluteOrder will only work if all
- * nodes are receiving pings from all the other nodes. 
+ * nodes are receiving pings from all the other nodes.
  * meaning, that node{i} receives pings from node{all}-node{i}<br>
  * but the following could happen if a multicast problem occurs.
  * A has members {B,C,D}<br>
@@ -56,7 +56,7 @@ import org.apache.juli.logging.LogFactory;
  * C has members {D,E}<br>
  * D has members {A,B,C,E}<br>
  * E has members {A,C,D}<br>
- * Because the default Tribes membership implementation, relies on the multicast packets to 
+ * Because the default Tribes membership implementation, relies on the multicast packets to
  * arrive at all nodes correctly, there is nothing guaranteeing that it will.<br>
  * <br>
  * To best explain how this algorithm works, lets take the above example:
@@ -83,7 +83,7 @@ import org.apache.juli.logging.LogFactory;
  * E - {A-ldr, mbrs-A,B,C,D,E, id=Y}<br>
  * <br>
  * A message doesn't stop until it reaches its original sender, unless its dropped by a higher leader.
- * As you can see, E still thinks the viewId=Y, which is not correct. But at this point we have 
+ * As you can see, E still thinks the viewId=Y, which is not correct. But at this point we have
  * arrived at the same membership and all nodes are informed of each other.<br>
  * To synchronize the rest we simply perform the following check at A when A receives X:<br>
  * Original X{A-ldr, A-src, mbrs-A,B,C,D} == Arrived X{A-ldr, A-src, mbrs-A,B,C,D,E}<br>
@@ -103,7 +103,7 @@ import org.apache.juli.logging.LogFactory;
  * A sends Z{A-ldr, A-src, mbrs-A,B,C,C1,D,E} to B and the chain continues until A receives the token again.
  * At that time A optionally sends out Z{A-ldr, A-src, mbrs-A,B,C,C1,D,E, confirmed} to A,B,C,C1,D,E
  * </p>
- * <p>To ensure that the view gets implemented at all nodes at the same time, 
+ * <p>To ensure that the view gets implemented at all nodes at the same time,
  *    A will send out a VIEW_CONF message, this is the 'confirmed' message that is optional above.
  * <p>Ideally, the interceptor below this one would be the TcpFailureDetector to ensure correct memberships</p>
  *
@@ -114,15 +114,15 @@ import org.apache.juli.logging.LogFactory;
  * <h2>State Diagrams</h2>
  * <a href="http://people.apache.org/~fhanik/tribes/docs/leader-election-initiate-election.jpg">Initiate an election</a><br><br>
  * <a href="http://people.apache.org/~fhanik/tribes/docs/leader-election-message-arrives.jpg">Receive an election message</a><br><br>
- * 
+ *
  * @author Filip Hanik
  * @version 1.0
- * 
- * 
- * 
+ *
+ *
+ *
  */
 public class NonBlockingCoordinator extends ChannelInterceptorBase {
-    
+
     private static final Log log = LogFactory.getLog(NonBlockingCoordinator.class);
 
     /**
@@ -137,7 +137,7 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
      * Coordination confirmation, for blocking installations
      */
     protected static final byte[] COORD_CONF = new byte[] {67, 88, 107, -86, 69, 23, 76, -70, -91, -23, -87, -25, -125, 86, 75, 20};
-    
+
     /**
      * Alive message
      */
@@ -162,29 +162,29 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
      * Our nonblocking membership
      */
     protected Membership membership = null;
-    
+
     /**
-     * indicates that we are running an election 
+     * indicates that we are running an election
      * and this is the one we are running
      */
     protected UniqueId suggestedviewId;
     protected Membership suggestedView;
-    
+
     protected boolean started = false;
     protected final int startsvc = 0xFFFF;
-    
+
     protected Object electionMutex = new Object();
-    
+
     protected AtomicBoolean coordMsgReceived = new AtomicBoolean(false);
-    
+
     public NonBlockingCoordinator() {
         super();
     }
-    
-//============================================================================================================    
+
+//============================================================================================================
 //              COORDINATION HANDLING
 //============================================================================================================
-    
+
     public void startElection(boolean force) throws ChannelException {
         synchronized (electionMutex) {
             MemberImpl local = (MemberImpl)getLocalMember(false);
@@ -197,7 +197,7 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
                 return; //the only member, no need for an election
             }
             if ( suggestedviewId != null ) {
-                
+
                 if ( view != null && Arrays.diff(view,suggestedView,local).length == 0 &&  Arrays.diff(suggestedView,view,local).length == 0) {
                     suggestedviewId = null;
                     suggestedView = null;
@@ -210,7 +210,7 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
             if ( view != null && Arrays.diff(view,membership,local).length == 0 &&  Arrays.diff(membership,view,local).length == 0) {
                 fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, view matches membership"));
                 return; //already have this view installed
-            }            
+            }
             int prio = AbsoluteOrder.comp.compare(local,others[0]);
             MemberImpl leader = ( prio < 0 )?local:others[0];//am I the leader in my view?
             if ( local.equals(leader) || force ) {
@@ -237,7 +237,7 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
                     fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, received a message"));
                 }
             }//end if
-            
+
         }
     }
 
@@ -245,7 +245,7 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
         Membership m = new Membership(local,AbsoluteOrder.comp,true);
         Arrays.fill(m,others);
         MemberImpl[] mbrs = m.getMembers();
-        m.reset(); 
+        m.reset();
         CoordinationMessage msg = new CoordinationMessage(leader, local, mbrs,new UniqueId(UUIDGenerator.randomUUID(true)), COORD_REQUEST);
         return msg;
     }
@@ -254,8 +254,8 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
         fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_SEND_MSG,this,"Sending election message to("+next.getName()+")"));
         super.sendMessage(new Member[] {next}, createData(msg, local), null);
     }
-    
-    protected void sendElectionMsgToNextInline(MemberImpl local, CoordinationMessage msg) throws ChannelException { 
+
+    protected void sendElectionMsgToNextInline(MemberImpl local, CoordinationMessage msg) throws ChannelException {
         int next = Arrays.nextIndex(local,msg.getMembers());
         int current = next;
         msg.leader = msg.getMembers()[0];
@@ -271,7 +271,7 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
             }
         }
     }
-    
+
     public ChannelData createData(CoordinationMessage msg, MemberImpl local) {
         msg.write();
         ChannelData data = new ChannelData(true);
@@ -281,7 +281,7 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
         data.setTimestamp(System.currentTimeMillis());
         return data;
     }
-    
+
     protected boolean alive(Member mbr) {
         return TcpFailureDetector.memberAlive(mbr,
                                               COORD_ALIVE,
@@ -291,7 +291,7 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
                                               waitForCoordMsgTimeout,
                                               getOptionFlag());
     }
-    
+
     protected Membership mergeOnArrive(CoordinationMessage msg) {
         fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_PRE_MERGE,this,"Pre merge"));
         MemberImpl local = (MemberImpl)getLocalMember(false);
@@ -306,18 +306,18 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
         fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_POST_MERGE,this,"Post merge"));
         return merged;
     }
-    
+
     protected void processCoordMessage(CoordinationMessage msg) throws ChannelException {
         if ( !coordMsgReceived.get() ) {
             coordMsgReceived.set(true);
             synchronized (electionMutex) { electionMutex.notifyAll();}
-        } 
+        }
         msg.timestamp = System.currentTimeMillis();
         Membership merged = mergeOnArrive(msg);
         if (isViewConf(msg)) handleViewConf(msg, merged);
         else handleToken(msg, merged);
     }
-    
+
     protected void handleToken(CoordinationMessage msg, Membership merged) throws ChannelException {
         MemberImpl local = (MemberImpl)getLocalMember(false);
         if ( local.equals(msg.getSource()) ) {
@@ -327,7 +327,7 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
             handleOtherToken(local, msg, merged);
         }
     }
-    
+
     protected void handleMyToken(MemberImpl local, CoordinationMessage msg, Membership merged) throws ChannelException {
         if ( local.equals(msg.getLeader()) ) {
             //no leadership change
@@ -351,7 +351,7 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
             sendElectionMsgToNextInline(local,msg);
         }
     }
-    
+
     protected void handleOtherToken(MemberImpl local, CoordinationMessage msg, Membership merged) throws ChannelException {
         if ( local.equals(msg.getLeader()) ) {
             //I am the new leader
@@ -361,44 +361,44 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
             sendElectionMsgToNextInline(local,msg);
         }
     }
-    
+
     protected void handleViewConf(CoordinationMessage msg, Membership merged) throws ChannelException {
         if ( viewId != null && msg.getId().equals(viewId) ) return;//we already have this view
         view = new Membership((MemberImpl)getLocalMember(false),AbsoluteOrder.comp,true);
         Arrays.fill(view,msg.getMembers());
         viewId = msg.getId();
-        
+
         if ( viewId.equals(suggestedviewId) ) {
             suggestedView = null;
             suggestedviewId = null;
         }
-        
+
         if (suggestedView != null && AbsoluteOrder.comp.compare(suggestedView.getMembers()[0],merged.getMembers()[0])<0 ) {
             suggestedView = null;
             suggestedviewId = null;
         }
-        
+
         fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_CONF_RX,this,"Accepted View"));
-        
+
         if ( suggestedviewId == null && hasHigherPriority(merged.getMembers(),membership.getMembers()) ) {
             startElection(false);
         }
     }
-    
+
     protected boolean isViewConf(CoordinationMessage msg) {
         return Arrays.contains(msg.getType(),0,COORD_CONF,0,COORD_CONF.length);
     }
-    
+
     protected boolean hasHigherPriority(Member[] complete, Member[] local) {
         if ( local == null || local.length == 0 ) return false;
         if ( complete == null || complete.length == 0 ) return true;
         AbsoluteOrder.absoluteOrder(complete);
         AbsoluteOrder.absoluteOrder(local);
         return (AbsoluteOrder.comp.compare(complete[0],local[0]) > 0);
-        
+
     }
 
-    
+
     /**
      * Returns coordinator if one is available
      * @return Member
@@ -406,15 +406,15 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
     public Member getCoordinator() {
         return (view != null && view.hasMembers()) ? view.getMembers()[0] : null;
     }
-    
+
     public Member[] getView() {
         return (view != null && view.hasMembers()) ? view.getMembers() : new Member[0];
     }
-    
+
     public UniqueId getViewId() {
         return viewId;
     }
-    
+
     /**
     * Block in/out messages while a election is going on
     */
@@ -436,9 +436,9 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
 
    }
 
-    
-//============================================================================================================    
-//              OVERRIDDEN METHODS FROM CHANNEL INTERCEPTOR BASE    
+
+//============================================================================================================
+//              OVERRIDDEN METHODS FROM CHANNEL INTERCEPTOR BASE
 //============================================================================================================
     @Override
     public void start(int svc) throws ChannelException {
@@ -472,8 +472,8 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
             release();
         }
     }
-    
-    
+
+
     @Override
     public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
         waitForRelease();
@@ -522,18 +522,18 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
             }
         }finally {
         }
-        
+
     }
 
     @Override
     public void memberDisappeared(Member member) {
         try {
-            
+
             membership.removeMember((MemberImpl)member);
             super.memberDisappeared(member);
             try {
                 fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MBR_DEL,this,"Member remove("+member.getName()+")"));
-                if ( started && (isCoordinator() || isHighest()) ) 
+                if ( started && (isCoordinator() || isHighest()) )
                     startElection(true); //to do, if a member disappears, only the coordinator can start
             }catch ( ChannelException x ) {
                 log.error("Unable to start election when member was removed.",x);
@@ -541,13 +541,13 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
         }finally {
         }
     }
-    
+
     public boolean isHighest() {
         Member local = getLocalMember(false);
         if ( membership.getMembers().length == 0 ) return true;
         else return AbsoluteOrder.comp.compare(local,membership.getMembers()[0])<=0;
     }
-    
+
     public boolean isCoordinator() {
         Member coord = getCoordinator();
         return coord != null && getLocalMember(false).equals(coord);
@@ -562,7 +562,7 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
                     fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START_ELECT, this,
                                                                "Heartbeat found inconsistency, restart election"));
                     startElection(true);
-                }            
+                }
             }
         } catch ( Exception x  ){
             log.error("Unable to perform heartbeat.",x);
@@ -576,7 +576,7 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
      */
     @Override
     public boolean hasMembers() {
-        
+
         return membership.hasMembers();
     }
 
@@ -586,7 +586,7 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
      */
     @Override
     public Member[] getMembers() {
-        
+
         return membership.getMembers();
     }
 
@@ -597,7 +597,7 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
      */
     @Override
     public Member getMember(Member mbr) {
-        
+
         return membership.getMember(mbr);
     }
 
@@ -612,15 +612,15 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
         if ( view == null && (local != null)) setupMembership();
         return local;
     }
-    
+
     protected synchronized void setupMembership() {
         if ( membership == null ) {
             membership  = new Membership((MemberImpl)super.getLocalMember(true),AbsoluteOrder.comp,false);
         }
     }
-    
-    
-//============================================================================================================    
+
+
+//============================================================================================================
 //              HELPER CLASSES FOR COORDINATION
 //============================================================================================================
 
@@ -634,14 +634,14 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
         protected UniqueId id;
         protected byte[] type;
         protected long timestamp = System.currentTimeMillis();
-        
+
         public CoordinationMessage(XByteBuffer buf) {
             this.buf = buf;
             parse();
         }
 
         public CoordinationMessage(MemberImpl leader,
-                                   MemberImpl source, 
+                                   MemberImpl source,
                                    MemberImpl[] view,
                                    UniqueId id,
                                    byte[] type) {
@@ -653,41 +653,41 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
             this.type = type;
             this.write();
         }
-        
+
 
         public byte[] getHeader() {
             return NonBlockingCoordinator.COORD_HEADER;
         }
-        
+
         public MemberImpl getLeader() {
             if ( leader == null ) parse();
             return leader;
         }
-        
+
         public MemberImpl getSource() {
             if ( source == null ) parse();
             return source;
         }
-        
+
         public UniqueId getId() {
             if ( id == null ) parse();
             return id;
         }
-        
+
         public MemberImpl[] getMembers() {
             if ( view == null ) parse();
             return view;
         }
-        
+
         public byte[] getType() {
             if (type == null ) parse();
             return type;
         }
-        
+
         public XByteBuffer getBuffer() {
             return this.buf;
         }
-        
+
         public void parse() {
             //header
             int offset = 16;
@@ -723,9 +723,9 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
             type = new byte[16];
             System.arraycopy(buf.getBytesDirect(), offset, type, 0, type.length);
             offset += 16;
-            
+
         }
-        
+
         public void write() {
             buf.reset();
             //header
@@ -752,14 +752,14 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
             buf.append(type,0,type.length);
         }
     }
-    
+
     @Override
     public void fireInterceptorEvent(InterceptorEvent event) {
         if (event instanceof CoordinationEvent &&
-            ((CoordinationEvent)event).type == CoordinationEvent.EVT_CONF_RX) 
+            ((CoordinationEvent)event).type == CoordinationEvent.EVT_CONF_RX)
             log.info(event);
     }
-    
+
     public static class CoordinationEvent implements InterceptorEvent {
         public static final int EVT_START = 1;
         public static final int EVT_MBR_ADD = 2;
@@ -774,10 +774,10 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
         public static final int EVT_STOP = 11;
         public static final int EVT_CONF_RX = 12;
         public static final int EVT_ELECT_ABANDONED = 13;
-        
+
         int type;
         ChannelInterceptor interceptor;
-        Member coord; 
+        Member coord;
         Member[] mbrs;
         String info;
         Membership view;
@@ -816,12 +816,12 @@ public class NonBlockingCoordinator extends ChannelInterceptorBase {
                 default: return "Unknown";
             }
         }
-        
+
         @Override
         public ChannelInterceptor getInterceptor() {
             return interceptor;
         }
-        
+
         @Override
         public String toString() {
             StringBuilder buf = new StringBuilder("CoordinationEvent[type=");

==================================================
SimpleCoordinator.java
index 831d09b348..f1b81654eb 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -31,25 +31,25 @@ import org.apache.catalina.tribes.io.XByteBuffer;
 
 /**
  *
- * The order interceptor guarantees that messages are received in the same order they were 
+ * The order interceptor guarantees that messages are received in the same order they were
  * sent.
  * This interceptor works best with the ack=true setting. <br>
- * There is no point in 
+ * There is no point in
  * using this with the replicationMode="fastasynchqueue" as this mode guarantees ordering.<BR>
  * If you are using the mode ack=false replicationMode=pooled, and have a lot of concurrent threads,
  * this interceptor can really slow you down, as many messages will be completely out of order
- * and the queue might become rather large. If this is the case, then you might want to set 
+ * and the queue might become rather large. If this is the case, then you might want to set
  * the value OrderInterceptor.maxQueue = 25 (meaning that we will never keep more than 25 messages in our queue)
  * <br><b>Configuration Options</b><br>
  * OrderInteceptor.expire=<milliseconds> - if a message arrives out of order, how long before we act on it <b>default=3000ms</b><br>
- * OrderInteceptor.maxQueue=<max queue size> - how much can the queue grow to ensure ordering. 
+ * OrderInteceptor.maxQueue=<max queue size> - how much can the queue grow to ensure ordering.
  *   This setting is useful to avoid OutOfMemoryErrors<b>default=Integer.MAX_VALUE</b><br>
- * OrderInterceptor.forwardExpired=<boolean> - this flag tells the interceptor what to 
+ * OrderInterceptor.forwardExpired=<boolean> - this flag tells the interceptor what to
  * do when a message has expired or the queue has grown larger than the maxQueue value.
  * true means that the message is sent up the stack to the receiver that will receive and out of order message
  * false means, forget the message and reset the message counter. <b>default=true</b>
- * 
- * 
+ *
+ *
  * @author Filip Hanik
  * @version 1.1
  */
@@ -60,7 +60,7 @@ public class OrderInterceptor extends ChannelInterceptorBase {
     private long expire = 3000;
     private boolean forwardExpired = true;
     private int maxQueue = Integer.MAX_VALUE;
-    
+
     final ReentrantReadWriteLock inLock = new ReentrantReadWriteLock(true);
     final ReentrantReadWriteLock outLock= new ReentrantReadWriteLock(true);
 
@@ -120,7 +120,7 @@ public class OrderInterceptor extends ChannelInterceptorBase {
         if ( tmp!= null ) processIncoming(tmp);
     }
     /**
-     * 
+     *
      * @param order MessageOrder
      * @return boolean - true if a message expired and was processed
      */
@@ -128,13 +128,13 @@ public class OrderInterceptor extends ChannelInterceptorBase {
         boolean result = false;
         Member member = order.getMessage().getAddress();
         Counter cnt = getInCounter(member);
-        
+
         MessageOrder tmp = incoming.get(member);
         if ( tmp != null ) {
             order = MessageOrder.add(tmp,order);
         }
-        
-        
+
+
         while ( (order!=null) && (order.getMsgNr() <= cnt.getCounter())  ) {
             //we are right on target. process orders
             if ( order.getMsgNr() == cnt.getCounter() ) cnt.inc();
@@ -154,11 +154,11 @@ public class OrderInterceptor extends ChannelInterceptorBase {
                 //reset the head
                 if ( tmp == head ) head = tmp.next;
                 cnt.setCounter(tmp.getMsgNr()+1);
-                if ( getForwardExpired() ) 
+                if ( getForwardExpired() )
                     super.messageReceived(tmp.getMessage());
                 tmp.setMessage(null);
                 tmp = tmp.next;
-                if ( prev != null ) prev.next = tmp;  
+                if ( prev != null ) prev.next = tmp;
                 result = true;
             } else {
                 prev = tmp;
@@ -169,7 +169,7 @@ public class OrderInterceptor extends ChannelInterceptorBase {
         else incoming.put(member, head);
         return result;
     }
-    
+
     @Override
     public void memberAdded(Member member) {
         //notify upwards
@@ -186,12 +186,12 @@ public class OrderInterceptor extends ChannelInterceptorBase {
         //notify upwards
         super.memberDisappeared(member);
     }
-    
-    protected int incCounter(Member mbr) { 
+
+    protected int incCounter(Member mbr) {
         Counter cnt = getOutCounter(mbr);
         return cnt.inc();
     }
-    
+
     protected Counter getInCounter(Member mbr) {
         Counter cnt = incounter.get(mbr);
         if ( cnt == null ) {
@@ -213,20 +213,20 @@ public class OrderInterceptor extends ChannelInterceptorBase {
 
     protected static class Counter {
         private AtomicInteger value = new AtomicInteger(0);
-        
+
         public int getCounter() {
             return value.get();
         }
-        
+
         public void setCounter(int counter) {
             this.value.set(counter);
         }
-        
+
         public int inc() {
             return value.addAndGet(1);
         }
     }
-    
+
     protected static class MessageOrder {
         private long received = System.currentTimeMillis();
         private MessageOrder next;
@@ -236,26 +236,26 @@ public class OrderInterceptor extends ChannelInterceptorBase {
             this.msgNr = msgNr;
             this.msg = msg;
         }
-        
+
         public boolean isExpired(long expireTime) {
             return (System.currentTimeMillis()-received) > expireTime;
         }
-        
+
         public ChannelMessage getMessage() {
             return msg;
         }
-        
+
         public void setMessage(ChannelMessage msg) {
             this.msg = msg;
         }
-        
+
         public void setNext(MessageOrder order) {
             this.next = order;
         }
         public MessageOrder getNext() {
             return next;
         }
-        
+
         public int getCount() {
             int counter = 1;
             MessageOrder tmp = next;
@@ -265,7 +265,7 @@ public class OrderInterceptor extends ChannelInterceptorBase {
             }
             return counter;
         }
-        
+
         public static MessageOrder add(MessageOrder head, MessageOrder add) {
             if ( head == null ) return add;
             if ( add == null ) return head;
@@ -275,7 +275,7 @@ public class OrderInterceptor extends ChannelInterceptorBase {
                 add.next = head;
                 return add;
             }
-            
+
             MessageOrder iter = head;
             MessageOrder prev = null;
             while ( iter.getMsgNr() < add.getMsgNr() && (iter.next !=null ) ) {
@@ -290,14 +290,14 @@ public class OrderInterceptor extends ChannelInterceptorBase {
                 //add before
                 prev.next = add;
                 add.next = iter;
-                
+
             } else {
                 throw new ArithmeticException("Message added has the same counter, synchronization bug. Disable the order interceptor");
             }
-            
+
             return head;
         }
-        
+
         public int getMsgNr() {
             return msgNr;
         }

==================================================
StaticMembershipInterceptor.java
index 8809026246..e32e7c06bb 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/SimpleCoordinator.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/SimpleCoordinator.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -27,9 +27,9 @@ import org.apache.catalina.tribes.group.ChannelInterceptorBase;
 
 /**
  * A dinky coordinator, just uses a sorted version of the member array.
- * 
+ *
  * @author rnewson
- * 
+ *
  */
 public class SimpleCoordinator extends ChannelInterceptorBase {
 
@@ -57,7 +57,7 @@ public class SimpleCoordinator extends ChannelInterceptorBase {
 
     /**
      * Override to receive view changes.
-     * 
+     *
      * @param view
      */
     protected void viewChange(final Member[] view) {

==================================================
TcpFailureDetector.java
index 0103964e8f..f40d97bafe 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/StaticMembershipInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/StaticMembershipInterceptor.java
@@ -97,7 +97,7 @@ public class StaticMembershipInterceptor
         if (this.localMember != null ) return localMember;
         else return super.getLocalMember(incAlive);
     }
-    
+
     /**
      * Send notifications upwards
      * @param svc int
@@ -105,8 +105,8 @@ public class StaticMembershipInterceptor
      */
     @Override
     public void start(int svc) throws ChannelException {
-        if ( (Channel.SND_RX_SEQ&svc)==Channel.SND_RX_SEQ ) super.start(Channel.SND_RX_SEQ); 
-        if ( (Channel.SND_TX_SEQ&svc)==Channel.SND_TX_SEQ ) super.start(Channel.SND_TX_SEQ); 
+        if ( (Channel.SND_RX_SEQ&svc)==Channel.SND_RX_SEQ ) super.start(Channel.SND_RX_SEQ);
+        if ( (Channel.SND_TX_SEQ&svc)==Channel.SND_TX_SEQ ) super.start(Channel.SND_TX_SEQ);
         final Member[] mbrs = members.toArray(new Member[members.size()]);
         final ChannelInterceptorBase base = this;
         Thread t = new Thread() {

==================================================
TcpPingInterceptor.java
index b4951d746e..ecd93a2a9d 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -51,38 +51,38 @@ import org.apache.catalina.tribes.membership.Membership;
  * <p>
  * The TcpFailureDetector works in two ways. <br>
  * 1. It intercepts memberDisappeared events
- * 2. It catches send errors 
+ * 2. It catches send errors
  * </p>
  *
  * @author Filip Hanik
  * @version 1.0
  */
 public class TcpFailureDetector extends ChannelInterceptorBase {
-    
+
     private static final org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog( TcpFailureDetector.class );
-    
+
     protected static byte[] TCP_FAIL_DETECT = new byte[] {
         79, -89, 115, 72, 121, -126, 67, -55, -97, 111, -119, -128, -95, 91, 7, 20,
         125, -39, 82, 91, -21, -15, 67, -102, -73, 126, -66, -113, -127, 103, 30, -74,
         55, 21, -66, -121, 69, 126, 76, -88, -65, 10, 77, 19, 83, 56, 21, 50,
-        85, -10, -108, -73, 58, -6, 64, 120, -111, 4, 125, -41, 114, -124, -64, -43};      
-    
+        85, -10, -108, -73, 58, -6, 64, 120, -111, 4, 125, -41, 114, -124, -64, -43};
+
     protected boolean performConnectTest = true;
 
     protected long connectTimeout = 1000;//1 second default
-    
+
     protected boolean performSendTest = true;
 
     protected boolean performReadTest = false;
-    
+
     protected long readTestTimeout = 5000;//5 seconds
-    
+
     protected Membership membership = null;
-    
+
     protected HashMap<Member, Long> removeSuspects = new HashMap<Member, Long>();
-    
+
     protected HashMap<Member, Long> addSuspects = new HashMap<Member, Long>();
-    
+
     @Override
     public void sendMessage(Member[] destination, ChannelMessage msg, InterceptorPayload payload) throws ChannelException {
         try {
@@ -90,7 +90,7 @@ public class TcpFailureDetector extends ChannelInterceptorBase {
         }catch ( ChannelException cx ) {
             FaultyMember[] mbrs = cx.getFaultyMembers();
             for ( int i=0; i<mbrs.length; i++ ) {
-                if ( mbrs[i].getCause()!=null &&  
+                if ( mbrs[i].getCause()!=null &&
                      (!(mbrs[i].getCause() instanceof RemoteProcessException)) ) {//RemoteProcessException's are ok
                     this.memberDisappeared(mbrs[i].getMember());
                 }//end if
@@ -101,20 +101,20 @@ public class TcpFailureDetector extends ChannelInterceptorBase {
 
     @Override
     public void messageReceived(ChannelMessage msg) {
-        //catch incoming 
+        //catch incoming
         boolean process = true;
         if ( okToProcess(msg.getOptions()) ) {
             //check to see if it is a testMessage, if so, process = false
             process = ( (msg.getMessage().getLength() != TCP_FAIL_DETECT.length) ||
                         (!Arrays.equals(TCP_FAIL_DETECT,msg.getMessage().getBytes()) ) );
         }//end if
-            
+
         //ignore the message, it doesnt have the flag set
         if ( process ) super.messageReceived(msg);
         else if ( log.isDebugEnabled() ) log.debug("Received a failure detector packet:"+msg);
     }//messageReceived
-    
-    
+
+
     @Override
     public void memberAdded(Member member) {
         if ( membership == null ) setupMembership();
@@ -142,7 +142,7 @@ public class TcpFailureDetector extends ChannelInterceptorBase {
         if ( membership == null ) setupMembership();
         boolean notify = false;
         boolean shutdown = Arrays.equals(member.getCommand(),Member.SHUTDOWN_PAYLOAD);
-        if ( !shutdown ) 
+        if ( !shutdown )
             if(log.isInfoEnabled())
                 log.info("Received memberDisappeared["+member+"] message. Will verify.");
         synchronized (membership) {
@@ -173,7 +173,7 @@ public class TcpFailureDetector extends ChannelInterceptorBase {
 
         }
     }
-    
+
     @Override
     public boolean hasMembers() {
         if ( membership == null ) setupMembership();
@@ -196,14 +196,14 @@ public class TcpFailureDetector extends ChannelInterceptorBase {
     public Member getLocalMember(boolean incAlive) {
         return super.getLocalMember(incAlive);
     }
-    
+
     @Override
     public void heartbeat() {
         super.heartbeat();
         checkMembers(false);
     }
     public void checkMembers(boolean checkAll) {
-        
+
         try {
             if (membership == null) setupMembership();
             synchronized (membership) {
@@ -213,10 +213,10 @@ public class TcpFailureDetector extends ChannelInterceptorBase {
         }catch ( Exception x ) {
             log.warn("Unable to perform heartbeat on the TcpFailureDetector.",x);
         } finally {
-            
+
         }
     }
-    
+
     protected void performForcedCheck() {
         //update all alive times
         Member[] members = super.getMembers();
@@ -278,26 +278,26 @@ public class TcpFailureDetector extends ChannelInterceptorBase {
             } //end if
         }
     }
-    
+
     protected synchronized void setupMembership() {
         if ( membership == null ) {
             membership = new Membership((MemberImpl)super.getLocalMember(true));
         }
-        
+
     }
-    
+
     protected boolean memberAlive(Member mbr) {
         return memberAlive(mbr,TCP_FAIL_DETECT,performSendTest,performReadTest,readTestTimeout,connectTimeout,getOptionFlag());
     }
-    
-    protected static boolean memberAlive(Member mbr, byte[] msgData, 
+
+    protected static boolean memberAlive(Member mbr, byte[] msgData,
                                          boolean sendTest, boolean readTest,
                                          long readTimeout, long conTimeout,
                                          int optionFlag) {
         //could be a shutdown notification
         if ( Arrays.equals(mbr.getCommand(),Member.SHUTDOWN_PAYLOAD) ) return false;
-        
-        Socket socket = new Socket();        
+
+        Socket socket = new Socket();
         try {
             InetAddress ia = InetAddress.getByAddress(mbr.getHost());
             InetSocketAddress addr = new InetSocketAddress(ia, mbr.getPort());

==================================================
ThroughputInterceptor.java
index 26d67620bb..afffa2ef9a 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -31,7 +31,7 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 
 /**
- * 
+ *
  * Sends a ping to all members.
  * Configure this interceptor with the TcpFailureDetector below it,
  * and the TcpFailureDetector will act as the membership guide.
@@ -40,14 +40,14 @@ import org.apache.juli.logging.LogFactory;
  */
 
 public class TcpPingInterceptor extends ChannelInterceptorBase {
-    
+
     private static final Log log = LogFactory.getLog(TcpPingInterceptor.class);
-    
+
     protected static byte[] TCP_PING_DATA = new byte[] {
         79, -89, 115, 72, 121, -33, 67, -55, -97, 111, -119, -128, -95, 91, 7, 20,
         125, -39, 82, 91, -21, -33, 67, -102, -73, 126, -66, -113, -127, 103, 30, -74,
         55, 21, -66, -121, 69, 33, 76, -88, -65, 10, 77, 19, 83, 56, 21, 50,
-        85, -10, -108, -73, 58, -33, 33, 120, -111, 4, 125, -41, 114, -124, -64, -43};  
+        85, -10, -108, -73, 58, -33, 33, 120, -111, 4, 125, -41, 114, -124, -64, -43};
 
     protected long interval = 1000; //1 second
 
@@ -56,10 +56,10 @@ public class TcpPingInterceptor extends ChannelInterceptorBase {
     protected volatile boolean running = true;
     protected PingThread thread = null;
     protected static AtomicInteger cnt = new AtomicInteger(0);
-    
+
     WeakReference<TcpFailureDetector> failureDetector = null;
     WeakReference<StaticMembershipInterceptor> staticMembers = null;
-    
+
     @Override
     public synchronized void start(int svc) throws ChannelException {
         super.start(svc);
@@ -70,19 +70,19 @@ public class TcpPingInterceptor extends ChannelInterceptorBase {
             thread.setName("TcpPingInterceptor.PingThread-"+cnt.addAndGet(1));
             thread.start();
         }
-        
+
         //acquire the interceptors to invoke on send ping events
         ChannelInterceptor next = getNext();
         while ( next != null ) {
-            if ( next instanceof TcpFailureDetector ) 
+            if ( next instanceof TcpFailureDetector )
                 failureDetector = new WeakReference<TcpFailureDetector>((TcpFailureDetector)next);
-            if ( next instanceof StaticMembershipInterceptor ) 
+            if ( next instanceof StaticMembershipInterceptor )
                 staticMembers = new WeakReference<StaticMembershipInterceptor>((StaticMembershipInterceptor)next);
             next = next.getNext();
         }
-        
+
     }
-    
+
     @Override
     public void stop(int svc) throws ChannelException {
         running = false;
@@ -90,7 +90,7 @@ public class TcpPingInterceptor extends ChannelInterceptorBase {
         thread = null;
         super.stop(svc);
     }
-    
+
     @Override
     public void heartbeat() {
         super.heartbeat();
@@ -147,10 +147,10 @@ public class TcpPingInterceptor extends ChannelInterceptorBase {
             log.warn("Unable to send TCP ping.",x);
         }
     }
-    
+
     @Override
     public void messageReceived(ChannelMessage msg) {
-        //catch incoming 
+        //catch incoming
         boolean process = true;
         if ( okToProcess(msg.getOptions()) ) {
             //check to see if it is a ping message, if so, process = false
@@ -162,7 +162,7 @@ public class TcpPingInterceptor extends ChannelInterceptorBase {
         if ( process ) super.messageReceived(msg);
         else if ( log.isDebugEnabled() ) log.debug("Received a TCP ping packet:"+msg);
     }//messageReceived
-    
+
     protected class PingThread extends Thread {
         @Override
         public void run() {

==================================================
TwoPhaseCommitInterceptor.java
index c1bb4c7cce..70009763e1 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/ThroughputInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/ThroughputInterceptor.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -66,7 +66,7 @@ public class ThroughputInterceptor extends ChannelInterceptorBase {
             msgTxErr.addAndGet(1);
             if ( access.get() == 1 ) access.addAndGet(-1);
             throw x;
-        } 
+        }
         mbTx += (bytes*destination.length)/(1024d*1024d);
         mbAppTx += bytes/(1024d*1024d);
         if ( access.addAndGet(-1) == 0 ) {
@@ -88,9 +88,9 @@ public class ThroughputInterceptor extends ChannelInterceptorBase {
         msgRxCnt.addAndGet(1);
         if ( msgRxCnt.get() % interval == 0 ) report(timeTx);
         super.messageReceived(msg);
-        
+
     }
-    
+
     public void report(double timeTx) {
         StringBuilder buf = new StringBuilder("ThroughputInterceptor Report[\n\tTx Msg:");
         buf.append(msgTxCnt).append(" messages\n\tSent:");
@@ -112,7 +112,7 @@ public class ThroughputInterceptor extends ChannelInterceptorBase {
         buf.append(df.format(mbRx)).append(" MB]\n");
         if ( log.isInfoEnabled() ) log.info(buf);
     }
-    
+
     public void setInterval(int interval) {
         this.interval = interval;
     }

==================================================
BufferPool.java
index 7c6b58498e..4da3117772 100644
--- a/java/org/apache/catalina/tribes/group/interceptors/TwoPhaseCommitInterceptor.java
+++ b/java/org/apache/catalina/tribes/group/interceptors/TwoPhaseCommitInterceptor.java
@@ -111,7 +111,7 @@ public class TwoPhaseCommitInterceptor extends ChannelInterceptorBase {
     public void setExpire(long expire) {
         this.expire = expire;
     }
-    
+
     @Override
     public void heartbeat() {
         try {
@@ -131,12 +131,12 @@ public class TwoPhaseCommitInterceptor extends ChannelInterceptorBase {
             super.heartbeat();
         }
     }
-    
+
     public static class MapEntry {
         public ChannelMessage msg;
         public UniqueId id;
         public long timestamp;
-        
+
         public MapEntry(ChannelMessage msg, UniqueId id, long timestamp) {
             this.msg = msg;
             this.id = id;

==================================================
ChannelData.java
index 6254d668f8..54ebd71ed2 100644
--- a/java/org/apache/catalina/tribes/io/BufferPool.java
+++ b/java/org/apache/catalina/tribes/io/BufferPool.java
@@ -23,7 +23,7 @@ import org.apache.juli.logging.LogFactory;
 /**
  *
  * @author Filip Hanik
- * 
+ *
  * @version 1.0
  */
 public class BufferPool {
@@ -88,5 +88,5 @@ public class BufferPool {
         public void returnBuffer(XByteBuffer buffer);
 
         public void clear();
-    }    
+    }
 }

==================================================
DirectByteArrayOutputStream.java
index f976e133fa..cb32f3be51 100644
--- a/java/org/apache/catalina/tribes/io/ChannelData.java
+++ b/java/org/apache/catalina/tribes/io/ChannelData.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -26,22 +26,22 @@ import org.apache.catalina.tribes.membership.MemberImpl;
 import org.apache.catalina.tribes.util.UUIDGenerator;
 
 /**
- * The <code>ChannelData</code> object is used to transfer a message through the 
- * channel interceptor stack and eventually out on a transport to be sent 
- * to another node. While the message is being processed by the different 
+ * The <code>ChannelData</code> object is used to transfer a message through the
+ * channel interceptor stack and eventually out on a transport to be sent
+ * to another node. While the message is being processed by the different
  * interceptors, the message data can be manipulated as each interceptor seems appropriate.
  * @author Peter Rossbach
  * @author Filip Hanik
  * @version $Id$
- * 
+ *
  */
 public class ChannelData implements ChannelMessage {
     private static final long serialVersionUID = 1L;
 
     public static final ChannelData[] EMPTY_DATA_ARRAY = new ChannelData[0];
-    
+
     public static volatile boolean USE_SECURE_RANDOM_FOR_UUID = false;
-    
+
     /**
      * The options this message was sent with
      */
@@ -70,7 +70,7 @@ public class ChannelData implements ChannelMessage {
     public ChannelData() {
         this(true);
     }
-    
+
     /**
      * Create an empty channel data object
      * @param generateUUID boolean - if true, a unique Id will be generated
@@ -91,7 +91,7 @@ public class ChannelData implements ChannelMessage {
         this.message = message;
         this.timestamp = timestamp;
     }
-    
+
     /**
      * @return Returns the message byte buffer
      */
@@ -134,9 +134,9 @@ public class ChannelData implements ChannelMessage {
         this.uniqueId = uniqueId;
     }
     /**
-     * @return returns the message options 
+     * @return returns the message options
      * see org.apache.catalina.tribes.Channel#sendMessage(org.apache.catalina.tribes.Member[], java.io.Serializable, int)
-     *                                                 
+     *
      */
     @Override
     public int getOptions() {
@@ -144,14 +144,14 @@ public class ChannelData implements ChannelMessage {
     }
     /**
      * Sets the message options.
-     * 
+     *
      * @param options the message options
      */
     @Override
     public void setOptions(int options) {
         this.options = options;
     }
-    
+
     /**
      * Returns the source or reply-to address
      * @return Member
@@ -169,7 +169,7 @@ public class ChannelData implements ChannelMessage {
     public void setAddress(Member address) {
         this.address = address;
     }
-    
+
     /**
      * Generates a UUID and invokes setUniqueId
      */
@@ -180,7 +180,7 @@ public class ChannelData implements ChannelMessage {
     }
 
     public int getDataPackageLength() {
-        int length = 
+        int length =
             4 + //options
             8 + //timestamp  off=4
             4 + //unique id length off=12
@@ -192,7 +192,7 @@ public class ChannelData implements ChannelMessage {
         return length;
 
     }
-    
+
     /**
      * Serializes the ChannelData object into a byte[] array
      * @return byte[]
@@ -224,7 +224,7 @@ public class ChannelData implements ChannelMessage {
         offset += message.getLength(); //message data
         return data;
     }
-    
+
     /**
      * Deserializes a ChannelData object from a byte array
      * @param xbuf byte[]
@@ -282,12 +282,12 @@ public class ChannelData implements ChannelMessage {
         offset += xsize; //message data
         return data;
     }
-    
+
     @Override
     public int hashCode() {
         return XByteBuffer.toInt(getUniqueId(),0);
     }
-    
+
     /**
      * Compares to ChannelData objects, only compares on getUniqueId().equals(o.getUniqueId())
      * @param o Object
@@ -299,7 +299,7 @@ public class ChannelData implements ChannelMessage {
             return Arrays.equals(getUniqueId(),((ChannelData)o).getUniqueId());
         } else return false;
     }
-    
+
     /**
      * Create a shallow clone, only the data gets recreated
      * @return ClusterData
@@ -316,7 +316,7 @@ public class ChannelData implements ChannelMessage {
         clone.address = this.address;
         return clone;
     }
-    
+
     /**
      * Complete clone
      * @return ClusterData
@@ -326,12 +326,12 @@ public class ChannelData implements ChannelMessage {
         byte[] d = this.getDataPackage();
         return ChannelData.getDataFromPackage(d);
     }
-    
+
     /**
      * Utility method, returns true if the options flag indicates that an ack
      * is to be sent after the message has been received and processed
      * @param options int - the options for the message
-     * @return boolean 
+     * @return boolean
      * @see org.apache.catalina.tribes.Channel#SEND_OPTIONS_USE_ACK
      * @see org.apache.catalina.tribes.Channel#SEND_OPTIONS_SYNCHRONIZED_ACK
      */
@@ -345,7 +345,7 @@ public class ChannelData implements ChannelMessage {
      * Utility method, returns true if the options flag indicates that an ack
      * is to be sent after the message has been received but not yet processed
      * @param options int - the options for the message
-     * @return boolean 
+     * @return boolean
      * @see org.apache.catalina.tribes.Channel#SEND_OPTIONS_USE_ACK
      * @see org.apache.catalina.tribes.Channel#SEND_OPTIONS_SYNCHRONIZED_ACK
      */
@@ -353,7 +353,7 @@ public class ChannelData implements ChannelMessage {
         return ( (Channel.SEND_OPTIONS_USE_ACK & options) == Channel.SEND_OPTIONS_USE_ACK) &&
             ( (Channel.SEND_OPTIONS_SYNCHRONIZED_ACK & options) != Channel.SEND_OPTIONS_SYNCHRONIZED_ACK);
     }
-    
+
     @Override
     public String toString() {
         StringBuilder buf = new StringBuilder();
@@ -363,7 +363,7 @@ public class ChannelData implements ChannelMessage {
         buf.append(new Timestamp(this.getTimestamp()).toString()).append("]");
         return buf.toString();
     }
-    
+
     public static String bToS(byte[] data) {
         StringBuilder buf = new StringBuilder(4*16);
         buf.append("{");
@@ -372,5 +372,5 @@ public class ChannelData implements ChannelMessage {
         return buf.toString();
     }
 
-    
+
 }

==================================================
ListenCallback.java
index c487d7e18d..ee1e85fcd9 100644
--- a/java/org/apache/catalina/tribes/io/DirectByteArrayOutputStream.java
+++ b/java/org/apache/catalina/tribes/io/DirectByteArrayOutputStream.java
@@ -27,9 +27,9 @@ import java.io.OutputStream;
  * @version 1.0
  */
 public class DirectByteArrayOutputStream extends OutputStream {
-    
+
     private XByteBuffer buffer;
-    
+
     public DirectByteArrayOutputStream(int size) {
         buffer = new XByteBuffer(size,false);
     }
@@ -47,15 +47,15 @@ public class DirectByteArrayOutputStream extends OutputStream {
     public void write(int b) throws IOException {
         buffer.append((byte)b);
     }
-    
+
     public int size() {
         return buffer.getLength();
     }
-    
+
     public byte[] getArrayDirect() {
         return buffer.getBytesDirect();
     }
-    
+
     public byte[] getArray() {
         return buffer.getBytes();
     }

==================================================
ReplicationStream.java
index c97989b5dd..55cb454767 100644
--- a/java/org/apache/catalina/tribes/io/ListenCallback.java
+++ b/java/org/apache/catalina/tribes/io/ListenCallback.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,7 +22,7 @@ import org.apache.catalina.tribes.ChannelMessage;
 
 
 /**
- * Internal interface, similar to the MessageListener but used 
+ * Internal interface, similar to the MessageListener but used
  * at the IO base
  * The listen callback interface is used by the replication system
  * when data has been received. The interface does not care about
@@ -38,5 +38,5 @@ public interface ListenCallback
      * @param data - the message bytes received from the cluster/replication system
      */
      public void messageDataReceived(ChannelMessage data);
-     
+
 }
\ No newline at end of file

==================================================
XByteBuffer.java
index 667f66b5b4..77de834031 100644
--- a/java/org/apache/catalina/tribes/io/ReplicationStream.java
+++ b/java/org/apache/catalina/tribes/io/ReplicationStream.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -38,12 +38,12 @@ import java.lang.reflect.Proxy;
 
 public final class ReplicationStream extends ObjectInputStream {
 
-    
+
     /**
      * The class loader we will use to resolve classes.
      */
     private ClassLoader[] classLoaders = null;
-    
+
     /**
      * Construct a new instance of CustomObjectInputStream
      *
@@ -79,7 +79,7 @@ public final class ReplicationStream extends ObjectInputStream {
             return super.resolveClass(classDesc);
         }
     }
-    
+
     public Class<?> resolveClass(String name) throws ClassNotFoundException {
 
         boolean tryRepFirst = name.startsWith("org.apache.catalina.tribes");
@@ -95,15 +95,15 @@ public final class ReplicationStream extends ObjectInputStream {
                 return findReplicationClass(name);
         }
     }
-    
+
     /**
-     * ObjectInputStream.resolveProxyClass has some funky way of using 
+     * ObjectInputStream.resolveProxyClass has some funky way of using
      * the incorrect class loader to resolve proxy classes, let's do it our way instead
      */
     @Override
     protected Class<?> resolveProxyClass(String[] interfaces)
             throws IOException, ClassNotFoundException {
-        
+
         ClassLoader latestLoader = (classLoaders!=null && classLoaders.length==0)?null:classLoaders[0];
         ClassLoader nonPublicLoader = null;
         boolean hasNonPublicInterface = false;
@@ -134,7 +134,7 @@ public final class ReplicationStream extends ObjectInputStream {
         }
     }
 
-    
+
     public Class<?> findReplicationClass(String name)
             throws ClassNotFoundException {
         Class<?> clazz = Class.forName(name, false, getClass().getClassLoader());
@@ -149,12 +149,12 @@ public final class ReplicationStream extends ObjectInputStream {
                 return clazz;
             } catch ( ClassNotFoundException x ) {
                 cnfe = x;
-            } 
+            }
         }
         if ( cnfe != null ) throw cnfe;
         else throw new ClassNotFoundException(name);
     }
-    
+
     @Override
     public void close() throws IOException  {
         this.classLoaders = null;

==================================================
Constants.java
index 9255134aba..794977900a 100644
--- a/java/org/apache/catalina/tribes/io/XByteBuffer.java
+++ b/java/org/apache/catalina/tribes/io/XByteBuffer.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -47,39 +47,39 @@ import java.util.concurrent.atomic.AtomicInteger;
  */
 public class XByteBuffer
 {
-    
+
     private static final org.apache.juli.logging.Log log =
         org.apache.juli.logging.LogFactory.getLog( XByteBuffer.class );
-    
+
     /**
      * This is a package header, 7 bytes (FLT2002)
      */
     private static final byte[] START_DATA = {70,76,84,50,48,48,50};
-    
+
     /**
      * This is the package footer, 7 bytes (TLF2003)
      */
     private static final byte[] END_DATA = {84,76,70,50,48,48,51};
- 
+
     /**
      * Variable to hold the data
      */
     protected byte[] buf = null;
-    
+
     /**
      * Current length of data in the buffer
      */
     protected int bufSize = 0;
-    
+
     /**
      * Flag for discarding invalid packages
      * If this flag is set to true, and append(byte[],...) is called,
-     * the data added will be inspected, and if it doesn't start with 
+     * the data added will be inspected, and if it doesn't start with
      * <code>START_DATA</code> it will be thrown away.
-     * 
+     *
      */
     protected boolean discard = true;
-    
+
     /**
      * Constructs a new XByteBuffer
      * @param size - the initial size of the byte buffer
@@ -89,11 +89,11 @@ public class XByteBuffer
         buf = new byte[size];
         this.discard = discard;
     }
-    
+
     public XByteBuffer(byte[] data,boolean discard) {
         this(data,data.length+128,discard);
     }
-    
+
     public XByteBuffer(byte[] data, int size,boolean discard) {
         int length = Math.max(data.length,size);
         buf = new byte[length];
@@ -101,7 +101,7 @@ public class XByteBuffer
         bufSize = data.length;
         this.discard = discard;
     }
-    
+
     public int getLength() {
         return bufSize;
     }
@@ -110,17 +110,17 @@ public class XByteBuffer
         if ( size > buf.length ) throw new ArrayIndexOutOfBoundsException("Size is larger than existing buffer.");
         bufSize = size;
     }
-    
+
     public void trim(int length) {
-        if ( (bufSize - length) < 0 ) 
+        if ( (bufSize - length) < 0 )
             throw new ArrayIndexOutOfBoundsException("Can't trim more bytes than are available. length:"+bufSize+" trim:"+length);
         bufSize -= length;
     }
-    
+
     public void reset() {
         bufSize = 0;
     }
-            
+
     public byte[] getBytesDirect() {
         return this.buf;
     }
@@ -154,9 +154,9 @@ public class XByteBuffer
             expand(newcount);
         }
         b.get(buf,bufSize,len);
-        
+
         bufSize = newcount;
-        
+
         if ( discard ) {
             if (bufSize > START_DATA.length && (firstIndexOf(buf, 0, START_DATA) == -1)) {
                 bufSize = 0;
@@ -167,7 +167,7 @@ public class XByteBuffer
         return true;
 
     }
-    
+
     public boolean append(byte i) {
         int newcount = bufSize + 1;
         if (newcount > buf.length) {
@@ -198,7 +198,7 @@ public class XByteBuffer
         bufSize = newcount;
         return true;
     }
-    
+
     public boolean append(int i) {
         int newcount = bufSize + 4;
         if (newcount > buf.length) {
@@ -240,7 +240,7 @@ public class XByteBuffer
         System.arraycopy(buf, 0, newbuf, 0, bufSize);
         buf = newbuf;
     }
-    
+
     public int getCapacity() {
         return buf.length;
     }
@@ -320,13 +320,13 @@ public class XByteBuffer
         return xbuf;
 
     }
-    
+
     public ChannelData extractPackage(boolean clearFromBuffer) {
         XByteBuffer xbuf = extractDataPackage(clearFromBuffer);
         ChannelData cdata = ChannelData.getDataFromPackage(xbuf);
         return cdata;
     }
-    
+
     /**
      * Creates a complete data package
      * @param cdata - the message data to be contained within the package
@@ -349,7 +349,7 @@ public class XByteBuffer
         offset += END_DATA.length;
         return data;
     }
-    
+
     public static byte[] createDataPackage(byte[] data, int doff, int dlength, byte[] buffer, int bufoff) {
         if ( (buffer.length-bufoff) > getDataPackageLength(dlength) ) {
             throw new ArrayIndexOutOfBoundsException("Unable to create data package, buffer is too small.");
@@ -361,9 +361,9 @@ public class XByteBuffer
         return buffer;
     }
 
-    
+
     public static int getDataPackageLength(int datalength) {
-        int length = 
+        int length =
             START_DATA.length + //header length
             4 + //data length indicator
             datalength + //actual data length
@@ -371,7 +371,7 @@ public class XByteBuffer
         return length;
 
     }
-    
+
     public static byte[] createDataPackage(byte[] data) {
         int length = getDataPackageLength(data.length);
         byte[] result = new byte[length];
@@ -417,7 +417,7 @@ public class XByteBuffer
             ( ( ( (long) b[off+0]) & 0xFF) << 56);
     }
 
-    
+
     /**
      * Converts a boolean to a 1-byte array
      * @param bool - the integer
@@ -430,12 +430,12 @@ public class XByteBuffer
         return toBytes(bool,b,0);
 
     }
-    
+
     public static byte[] toBytes(boolean bool, byte[] data, int offset) {
         data[offset] = (byte)(bool?1:0);
         return data;
     }
-    
+
     /**
      * Converts a byte array entry to boolean
      * @param b byte array
@@ -446,7 +446,7 @@ public class XByteBuffer
         return b[offset] != 0;
     }
 
-    
+
     /**
      * Converts an integer to four bytes
      * @param n - the integer
@@ -543,20 +543,20 @@ public class XByteBuffer
         return result;
     }
 
-    
-    public static Serializable deserialize(byte[] data) 
+
+    public static Serializable deserialize(byte[] data)
         throws IOException, ClassNotFoundException, ClassCastException {
         return deserialize(data,0,data.length);
     }
-    
-    public static Serializable deserialize(byte[] data, int offset, int length)  
+
+    public static Serializable deserialize(byte[] data, int offset, int length)
         throws IOException, ClassNotFoundException, ClassCastException {
-        return deserialize(data,offset,length,null);     
+        return deserialize(data,offset,length,null);
     }
-    
+
     private static AtomicInteger invokecount = new AtomicInteger(0);
-    
-    public static Serializable deserialize(byte[] data, int offset, int length, ClassLoader[] cls) 
+
+    public static Serializable deserialize(byte[] data, int offset, int length, ClassLoader[] cls)
         throws IOException, ClassNotFoundException, ClassCastException {
         invokecount.addAndGet(1);
         Object message = null;
@@ -581,7 +581,7 @@ public class XByteBuffer
     /**
      * Serializes a message into cluster data
      * @param msg ClusterMessage
-     * @return serialized content as byte[] array 
+     * @return serialized content as byte[] array
      * @throws IOException
      */
     public static byte[] serialize(Serializable msg) throws IOException {

==================================================
McastService.java
index 8529356f73..6cf710f2f0 100644
--- a/java/org/apache/catalina/tribes/membership/Constants.java
+++ b/java/org/apache/catalina/tribes/membership/Constants.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
McastServiceImpl.java
index c279b1b399..d1a570d8b7 100644
--- a/java/org/apache/catalina/tribes/membership/McastService.java
+++ b/java/org/apache/catalina/tribes/membership/McastService.java
@@ -231,7 +231,7 @@ public class McastService implements MembershipService,MembershipListener,Messag
     public void setRecoveryCounter(int recoveryCounter) {
         properties.setProperty("recoveryCounter", String.valueOf(recoveryCounter));
     }
-    
+
     public int getRecoveryCounter(){
         String p = properties.getProperty("recoveryCounter");
         if(p != null){
@@ -243,7 +243,7 @@ public class McastService implements MembershipService,MembershipListener,Messag
     public void setRecoveryEnabled(boolean recoveryEnabled) {
         properties.setProperty("recoveryEnabled", String.valueOf(recoveryEnabled));
     }
-    
+
     public boolean getRecoveryEnabled() {
         String p = properties.getProperty("recoveryEnabled");
         if(p != null){
@@ -255,7 +255,7 @@ public class McastService implements MembershipService,MembershipListener,Messag
     public void setRecoverySleepTime(long recoverySleepTime) {
         properties.setProperty("recoverySleepTime", String.valueOf(recoverySleepTime));
     }
-    
+
     public long getRecoverySleepTime(){
         String p = properties.getProperty("recoverySleepTime");
         if(p != null){
@@ -267,7 +267,7 @@ public class McastService implements MembershipService,MembershipListener,Messag
     public void setLocalLoopbackDisabled(boolean localLoopbackDisabled) {
         properties.setProperty("localLoopbackDisabled",String.valueOf(localLoopbackDisabled));
     }
-    
+
     public boolean getLocalLoopbackDisabled() {
         String p = properties.getProperty("localLoopbackDisabled");
         if(p != null){
@@ -512,11 +512,11 @@ public class McastService implements MembershipService,MembershipListener,Messag
     public void setMembershipListener(MembershipListener listener) {
         this.listener = listener;
     }
-    
+
     public void setMessageListener(MessageListener listener) {
         this.msglistener = listener;
     }
-    
+
     public void removeMessageListener() {
         this.msglistener = null;
     }
@@ -542,12 +542,12 @@ public class McastService implements MembershipService,MembershipListener,Messag
     {
         if ( listener!=null ) listener.memberDisappeared(member);
     }
-    
+
     @Override
     public void messageReceived(ChannelMessage msg) {
-        if (msglistener!=null && msglistener.accept(msg)) msglistener.messageReceived(msg); 
+        if (msglistener!=null && msglistener.accept(msg)) msglistener.messageReceived(msg);
     }
-    
+
     @Override
     public boolean accept(ChannelMessage msg) {
         return true;
@@ -556,7 +556,7 @@ public class McastService implements MembershipService,MembershipListener,Messag
     public void broadcast(ChannelMessage message) throws ChannelException {
         if (impl==null || (impl.startLevel & Channel.MBR_TX_SEQ)!=Channel.MBR_TX_SEQ )
             throw new ChannelException("Multicast send is not started or enabled.");
-        
+
         byte[] data = XByteBuffer.createDataPackage((ChannelData)message);
         if (data.length>McastServiceImpl.MAX_PACKET_SIZE) {
             throw new ChannelException("Packet length["+data.length+"] exceeds max packet size of "+McastServiceImpl.MAX_PACKET_SIZE+" bytes.");

==================================================
Membership.java
index 8569ed4608..ed2c475fd6 100644
--- a/java/org/apache/catalina/tribes/membership/McastServiceImpl.java
+++ b/java/org/apache/catalina/tribes/membership/McastServiceImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -52,7 +52,7 @@ public class McastServiceImpl
 {
     private static final org.apache.juli.logging.Log log =
         org.apache.juli.logging.LogFactory.getLog( McastService.class );
-    
+
     protected static int MAX_PACKET_SIZE = 65535;
     /**
      * Internal flag used for the listen thread that listens to the multicasting socket.
@@ -125,32 +125,32 @@ public class McastServiceImpl
      * bind address
      */
     protected InetAddress mcastBindAddress = null;
-    
+
     /**
      * nr of times the system has to fail before a recovery is initiated
      */
     protected int recoveryCounter = 10;
-    
+
     /**
      * The time the recovery thread sleeps between recovery attempts
      */
     protected long recoverySleepTime = 5000;
-    
+
     /**
      * Add the ability to turn on/off recovery
      */
     protected boolean recoveryEnabled = true;
-    
+
     /**
      * Dont interrupt the sender/receiver thread, but pass off to an executor
      */
     protected ExecutorService executor = ExecutorFactory.newThreadPool(0, 2, 2, TimeUnit.SECONDS);
-    
+
     /**
      * disable/enable local loopback message
      */
     protected boolean localLoopbackDisabled = false;
-    
+
     /**
      * Create a new mcast service impl
      * @param member - the local member
@@ -202,7 +202,7 @@ public class McastServiceImpl
         member.getData(true, true);
         if ( membership == null ) membership = new Membership(member);
     }
-    
+
     protected void setupSocket() throws IOException {
         if (mcastBindAddress != null) {
             try {
@@ -261,7 +261,7 @@ public class McastServiceImpl
             receiver.setDaemon(true);
             receiver.start();
             valid = true;
-        } 
+        }
         if ( (level & Channel.MBR_TX_SEQ)==Channel.MBR_TX_SEQ ) {
             if ( sender != null ) throw new IllegalStateException("McastService.send already running.");
             if ( receiver == null ) socket.joinGroup(address);
@@ -273,7 +273,7 @@ public class McastServiceImpl
             sender.start();
             //we have started the receiver, but not yet waited for membership to establish
             valid = true;
-        } 
+        }
         if (!valid) {
             throw new IllegalArgumentException("Invalid start level. Only acceptable levels are Channel.MBR_RX_SEQ and Channel.MBR_TX_SEQ");
         }
@@ -297,20 +297,20 @@ public class McastServiceImpl
      */
     public synchronized boolean stop(int level) throws IOException {
         boolean valid = false;
-        
+
         if ( (level & Channel.MBR_RX_SEQ)==Channel.MBR_RX_SEQ ) {
             valid = true;
             doRunReceiver = false;
             if ( receiver !=null ) receiver.interrupt();
             receiver = null;
-        } 
+        }
         if ( (level & Channel.MBR_TX_SEQ)==Channel.MBR_TX_SEQ ) {
             valid = true;
             doRunSender = false;
             if ( sender != null )sender.interrupt();
             sender = null;
-        } 
-        
+        }
+
         if (!valid) {
             throw new IllegalArgumentException("Invalid stop level. Only acceptable levels are Channel.MBR_RX_SEQ and Channel.MBR_TX_SEQ");
         }
@@ -336,7 +336,7 @@ public class McastServiceImpl
     public void receive() throws IOException {
         boolean checkexpired = true;
         try {
-            
+
             socket.receive(receivePacket);
             if(receivePacket.getLength() > MAX_PACKET_SIZE) {
                 log.error("Multicast packet received was too long, dropping package:"+receivePacket.getLength());
@@ -348,9 +348,9 @@ public class McastServiceImpl
                 } else {
                     memberBroadcastsReceived(data);
                 }
-                
+
             }
-        } catch (SocketTimeoutException x ) { 
+        } catch (SocketTimeoutException x ) {
             //do nothing, this is normal, we don't want to block forever
             //since the receive thread is the same thread
             //that does membership expiration
@@ -396,7 +396,7 @@ public class McastServiceImpl
             executor.execute(t);
         }
     }
-    
+
     private void memberBroadcastsReceived(final byte[] b) {
         if (log.isTraceEnabled()) log.trace("Mcast received broadcasts.");
         XByteBuffer buffer = new XByteBuffer(b,true);
@@ -459,7 +459,7 @@ public class McastServiceImpl
                             }finally {
                                 Thread.currentThread().setName(name);
                             }
-                            
+
                         }
                     };
                     executor.execute(t);
@@ -473,11 +473,11 @@ public class McastServiceImpl
     /**
      * Send a ping
      * @throws IOException
-     */ 
+     */
     public void send(boolean checkexpired) throws IOException{
         send(checkexpired,null);
     }
-    
+
     private final Object sendLock = new Object();
 
     public void send(boolean checkexpired, DatagramPacket packet) throws IOException{
@@ -588,11 +588,11 @@ public class McastServiceImpl
             if (running) return;
             if (!parent.isRecoveryEnabled())
                 return;
-            
+
             running = true;
-            
+
             Thread t = new RecoveryThread(parent);
-            
+
             t.setName("Tribes-MembershipRecovery");
             t.setDaemon(true);
             t.start();
@@ -603,7 +603,7 @@ public class McastServiceImpl
         public RecoveryThread(McastServiceImpl parent) {
             this.parent = parent;
         }
-        
+
         public boolean stopService() {
             try {
                 parent.stop(Channel.MBR_RX_SEQ | Channel.MBR_TX_SEQ);

==================================================
StaticMember.java
index 0b57408bee..78b9a5d860 100644
--- a/java/org/apache/catalina/tribes/membership/Membership.java
+++ b/java/org/apache/catalina/tribes/membership/Membership.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -41,25 +41,25 @@ import org.apache.catalina.tribes.Member;
 public class Membership implements Cloneable {
 
     protected static final MemberImpl[] EMPTY_MEMBERS = new MemberImpl[0];
-    
+
     private final Object membersLock = new Object();
-    
+
     /**
      * The name of this membership, has to be the same as the name for the local
      * member
      */
     protected MemberImpl local;
-    
+
     /**
      * A map of all the members in the cluster.
      */
     protected HashMap<MemberImpl, MbrEntry> map = new HashMap<MemberImpl, MbrEntry>();
-    
+
     /**
      * A list of all the members in the cluster.
      */
     protected MemberImpl[] members = EMPTY_MEMBERS;
-    
+
     /**
       * sort members by alive time
       */
@@ -159,10 +159,10 @@ public class Membership implements Cloneable {
           return entry;
       }
     }
-    
+
     /**
      * Remove a member from this component.
-     * 
+     *
      * @param member The member to remove
      */
     public void removeMember(MemberImpl member) {
@@ -185,7 +185,7 @@ public class Membership implements Cloneable {
             members = results;
         }
     }
-    
+
     /**
      * Runs a refresh cycle and returns a list of members that has expired.
      * This also removes the members from the membership, in such a way that
@@ -196,7 +196,7 @@ public class Membership implements Cloneable {
     public synchronized MemberImpl[] expire(long maxtime) {
         if(!hasMembers() )
            return EMPTY_MEMBERS;
-       
+
         ArrayList<MemberImpl> list = null;
         Iterator<MbrEntry> i = map.values().iterator();
         while(i.hasNext()) {
@@ -207,7 +207,7 @@ public class Membership implements Cloneable {
                 list.add(entry.getMember());
             }
         }
-        
+
         if(list != null) {
             MemberImpl[] result = new MemberImpl[list.size()];
             list.toArray(result);
@@ -226,8 +226,8 @@ public class Membership implements Cloneable {
     public boolean hasMembers() {
         return members.length > 0 ;
     }
-    
-    
+
+
     public MemberImpl getMember(Member mbr) {
         if(hasMembers()) {
             MemberImpl result = null;
@@ -239,11 +239,11 @@ public class Membership implements Cloneable {
             return null;
         }
     }
-    
-    public boolean contains(Member mbr) { 
+
+    public boolean contains(Member mbr) {
         return getMember(mbr)!=null;
     }
- 
+
     /**
      * Returning a list of all the members in the membership
      * We not need a copy: add and remove generate new arrays.
@@ -268,7 +268,7 @@ public class Membership implements Cloneable {
             result[pos++] = i.next().getValue();
         return result;
     }
-    
+
     // --------------------------------------------- Inner Class
 
     private static class MemberComparator implements Comparator<Member>,
@@ -288,7 +288,7 @@ public class Membership implements Cloneable {
                 return 1;
         }
     }
-    
+
     /**
      * Inner class that represents a member entry
      */

==================================================
AbstractReplicatedMap.java
index 54b5e0bb71..8a726c4f80 100644
--- a/java/org/apache/catalina/tribes/package.html
+++ b/java/org/apache/catalina/tribes/package.html
@@ -70,13 +70,13 @@
             IO Component to send messages over some network transport
         </li>
         <li><code>org.apache.catalina.tribes.MembershipService</code>
-            IO Component that handles membership discovery and 
+            IO Component that handles membership discovery and
         </li>
         <li><code>org.apache.catalina.tribes.ChannelInterceptor</code>
             interceptors between the Channel and the IO layer
         </li>
         <li><code>org.apache.catalina.tribes.ChannelMessage</code>
-            The message that is sent through the interceptor stack down to the IO layer 
+            The message that is sent through the interceptor stack down to the IO layer
         </li>
 
         <li><code>org.apache.catalina.tribes.Member</code>

==================================================
LazyReplicatedMap.java
index 7614b25ff5..abfee140d3 100644
--- a/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
+++ b/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
@@ -67,7 +67,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
      * The load factor used when none specified in constructor.
      **/
     public static final float DEFAULT_LOAD_FACTOR = 0.75f;
-    
+
     /**
      * Used to identify the map
      */
@@ -78,8 +78,8 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
 //              INSTANCE VARIABLES
 //------------------------------------------------------------------------------
     protected abstract int getStateMessageType();
-    
-    
+
+
     /**
      * Timeout for RPC messages, how long we will wait for a reply
      */
@@ -122,21 +122,21 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
      * External class loaders if serialization and deserialization is to be performed successfully.
      */
     protected transient ClassLoader[] externalLoaders;
-    
+
     /**
      * The node we are currently backing up data to, this index will rotate
      * on a round robin basis
      */
     protected transient int currentNode = 0;
-    
+
     /**
      * Since the map keeps internal membership
      * this is the timeout for a ping message to be responded to
-     * If a remote map doesn't respond within this timeframe, 
+     * If a remote map doesn't respond within this timeframe,
      * its considered dead.
      */
     protected transient long accessTimeout = 5000;
-    
+
     /**
      * Readable string of the mapContextName value
      */
@@ -145,7 +145,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
 //------------------------------------------------------------------------------
 //              map owner interface
 //------------------------------------------------------------------------------
-    
+
     public static interface MapOwner {
         // a typo, should have been "objectMadePrimary"
         public void objectMadePrimay(Object key, Object value);
@@ -165,16 +165,16 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
      * @param cls - a list of classloaders to be used for deserialization of objects.
      */
     public AbstractReplicatedMap(MapOwner owner,
-                                 Channel channel, 
-                                 long timeout, 
-                                 String mapContextName, 
+                                 Channel channel,
+                                 long timeout,
+                                 String mapContextName,
                                  int initialCapacity,
                                  float loadFactor,
                                  int channelSendOptions,
                                  ClassLoader[] cls) {
         super(initialCapacity, loadFactor, 15);
         init(owner, channel, mapContextName, timeout, channelSendOptions, cls);
-        
+
     }
 
     /**
@@ -216,8 +216,8 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         this.channel.addChannelListener(this);
         //listen for membership notifications
         this.channel.addMembershipListener(this);
-        
-        
+
+
         try {
             //broadcast our map, this just notifies other members of our existence
             broadcast(MapMessage.MSG_INIT, true);
@@ -234,8 +234,8 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             throw new RuntimeException("Unable to start replicated map.",x);
         }
     }
-    
-    
+
+
     /**
      * Sends a ping out to all the members in the cluster, not just map members
      * that this map is alive.
@@ -244,19 +244,19 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
      */
     protected void ping(long timeout) throws ChannelException {
         //send out a map membership message, only wait for the first reply
-        MapMessage msg = new MapMessage(this.mapContextName, 
+        MapMessage msg = new MapMessage(this.mapContextName,
                                         MapMessage.MSG_INIT,
-                                        false, 
-                                        null, 
-                                        null, 
-                                        null, 
+                                        false,
+                                        null,
+                                        null,
+                                        null,
                                         channel.getLocalMember(false),
                                         null);
         if ( channel.getMembers().length > 0 ) {
             try {
                 //send a ping, wait for all nodes to reply
-                Response[] resp = rpcChannel.send(channel.getMembers(), 
-                                                  msg, RpcChannel.ALL_REPLY, 
+                Response[] resp = rpcChannel.send(channel.getMembers(),
+                                                  msg, RpcChannel.ALL_REPLY,
                                                   (channelSendOptions),
                                                   (int) accessTimeout);
                 for (int i = 0; i < resp.length; i++) {
@@ -268,7 +268,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                 for (FaultyMember faultyMember : faultyMembers) {
                     memberDisappeared(faultyMember.getMember());
                 }
-            }            
+            }
         }
         //update our map of members, expire some if we didn't receive a ping back
         synchronized (mapMembers) {
@@ -276,7 +276,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             long now = System.currentTimeMillis();
             while ( it.hasNext() ) {
                 Map.Entry<Member,Long> entry = it.next();
-                long access = entry.getValue().longValue(); 
+                long access = entry.getValue().longValue();
                 if ( (now - access) > timeout ) {
                     it.remove();
                     memberDisappeared(entry.getKey());
@@ -297,7 +297,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             mapMembers.put(member, new Long(System.currentTimeMillis()));
         }
     }
-    
+
     /**
      * Helper method to broadcast a message to all members in a channel
      * @param msgtype int
@@ -349,12 +349,12 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         this.stateTransferred = false;
         this.externalLoaders = null;
     }
-    
+
     @Override
     public int hashCode() {
         return Arrays.hashCode(this.mapContextName);
     }
-    
+
     @Override
     public boolean equals(Object o) {
         if ( !(o instanceof AbstractReplicatedMap)) return false;
@@ -376,7 +376,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
     public Member[] getMapMembers() {
         return getMapMembers(this.mapMembers);
     }
-    
+
     public Member[] getMapMembersExcl(Member[] exclude) {
         synchronized (mapMembers) {
             @SuppressWarnings("unchecked") // mapMembers has the correct type
@@ -404,11 +404,11 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             Object value = entry.getValue();
             //check to see if we need to replicate this object isDirty()||complete
             boolean repl = complete || ( (value instanceof ReplicatedMapEntry) && ( (ReplicatedMapEntry) value).isDirty());
-            
+
             if (!repl) {
                 if ( log.isTraceEnabled() )
                     log.trace("Not replicating:"+key+", no change made");
-                
+
                 return;
             }
             //check to see if the message is diffable
@@ -430,7 +430,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                 } finally {
                     rentry.unlock();
                 }
-                
+
             }
             if (msg == null) {
                 //construct a complete
@@ -512,7 +512,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             mapmsg.setPrimary(channel.getLocalMember(false));
             return mapmsg;
         }
-        
+
         //map start request
         if (mapmsg.getMsgType() == MapMessage.MSG_START) {
             mapmsg.setPrimary(channel.getLocalMember(false));
@@ -538,7 +538,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                     MapEntry entry = (MapEntry) super.get(e.getKey());
                     if ( entry != null && entry.isSerializable() ) {
                         boolean copy = (mapmsg.getMsgType() == MapMessage.MSG_STATE_COPY);
-                        MapMessage me = new MapMessage(mapContextName, 
+                        MapMessage me = new MapMessage(mapContextName,
                                                        copy?MapMessage.MSG_COPY:MapMessage.MSG_PROXY,
                             false, (Serializable) entry.getKey(), copy?(Serializable) entry.getValue():null, null, entry.getPrimary(),entry.getBackupNodes());
                         list.add(me);
@@ -546,7 +546,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                 }
                 mapmsg.setValue(list);
                 return mapmsg;
-                
+
             } //synchronized
         }
 
@@ -588,7 +588,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         if ( log.isTraceEnabled() ) {
             log.trace("Map["+mapname+"] received message:"+mapmsg);
         }
-        
+
         try {
             mapmsg.deserialize(getExternalLoaders());
         } catch (IOException x) {
@@ -598,7 +598,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             log.error("Unable to deserialize MapMessage.", x);
             return;
         }
-        if ( log.isTraceEnabled() ) 
+        if ( log.isTraceEnabled() )
             log.trace("Map message received from:"+sender.getName()+" msg:"+mapmsg);
         if (mapmsg.getMsgType() == MapMessage.MSG_START) {
             mapMemberAdded(mapmsg.getPrimary());
@@ -713,7 +713,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             } //synchronized
         }//end if
     }
-    
+
     public boolean inSet(Member m, Member[] set) {
         if ( set == null ) return false;
         boolean result = false;
@@ -726,7 +726,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         ArrayList<Member> result = new ArrayList<Member>();
         for (int i=0; i<set.length; i++ ) {
             boolean include = true;
-            for (int j=0; j<mbrs.length; j++ ) 
+            for (int j=0; j<mbrs.length; j++ )
                 if ( mbrs[j].equals(set[i]) ) include = false;
             if ( include ) result.add(set[i]);
         }
@@ -748,7 +748,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                 return; //the member was not part of our map.
             }
         }
-        
+
         Iterator<Map.Entry<?,?>> i = super.entrySet().iterator();
         while (i.hasNext()) {
             Map.Entry<?,?> e = i.next();
@@ -767,10 +767,10 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                 if (log.isDebugEnabled()) log.debug("[2] Primary disappeared");
                 entry.setPrimary(null);
             } //end if
-            
+
             if ( entry.isProxy() &&
-                 entry.getPrimary() == null && 
-                 entry.getBackupNodes()!=null && 
+                 entry.getPrimary() == null &&
+                 entry.getBackupNodes()!=null &&
                  entry.getBackupNodes().length == 1 &&
                  entry.getBackupNodes()[0].equals(member) ) {
                 //remove proxies that have no backup nor primaries
@@ -778,7 +778,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                 i.remove();
             } else if ( entry.getPrimary() == null &&
                         entry.isBackup() &&
-                        entry.getBackupNodes()!=null && 
+                        entry.getBackupNodes()!=null &&
                         entry.getBackupNodes().length == 1 &&
                         entry.getBackupNodes()[0].equals(channel.getLocalMember(false)) ) {
                 try {
@@ -789,7 +789,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                     Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
                     entry.setBackupNodes(backup);
                     if ( mapOwner!=null ) mapOwner.objectMadePrimay(entry.getKey(),entry.getValue());
-                    
+
                 } catch (ChannelException x) {
                     log.error("Unable to relocate[" + entry.getKey() + "] to a new backup node", x);
                 }
@@ -817,7 +817,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
     }
 
     protected abstract Member[] publishEntryInfo(Object key, Object value) throws ChannelException;
-    
+
     @Override
     public void heartbeat() {
         try {
@@ -827,13 +827,13 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         }
     }
 
-//------------------------------------------------------------------------------    
-//              METHODS TO OVERRIDE    
 //------------------------------------------------------------------------------
-  
+//              METHODS TO OVERRIDE
+//------------------------------------------------------------------------------
+
     /**
-     * Removes an object from this map, it will also remove it from 
-     * 
+     * Removes an object from this map, it will also remove it from
+     *
      * @param key Object
      * @return Object
      */
@@ -854,11 +854,11 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         }
         return entry!=null?entry.getValue():null;
     }
-    
+
     public MapEntry getInternal(Object key) {
         return (MapEntry)super.get(key);
     }
-    
+
     @Override
     public Object get(Object key) {
         MapEntry entry = (MapEntry)super.get(key);
@@ -900,7 +900,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                     }
                     if ( entry.getValue() != null && entry.getValue() instanceof ReplicatedMapEntry ) {
                         ReplicatedMapEntry val = (ReplicatedMapEntry)entry.getValue();
-                        val.setOwner(getMapOwner());   
+                        val.setOwner(getMapOwner());
                     }
                 }
                 entry.setPrimary(channel.getLocalMember(false));
@@ -916,9 +916,9 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         }
         if (log.isTraceEnabled()) log.trace("Requesting id:"+key+" result:"+entry.getValue());
         return entry.getValue();
-    }    
+    }
+
 
-    
     protected void printMap(String header) {
         try {
             System.out.println("\nDEBUG MAP:"+header);
@@ -941,7 +941,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             ignore.printStackTrace();
         }
     }
-    
+
     /**
          * Returns true if the key has an entry in the map.
          * The entry can be a proxy or a backup entry, invoking <code>get(key)</code>
@@ -953,20 +953,20 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         public boolean containsKey(Object key) {
             return super.containsKey(key);
         }
-    
+
         @Override
         public Object put(Object key, Object value) {
             return put(key,value,true);
         }
-    
+
         public Object put(Object key, Object value, boolean notify) {
             MapEntry entry = new MapEntry(key,value);
             entry.setBackup(false);
             entry.setProxy(false);
             entry.setPrimary(channel.getLocalMember(false));
-    
+
             Object old = null;
-    
+
             //make sure that any old values get removed
             if ( containsKey(key) ) old = remove(key);
             try {
@@ -980,8 +980,8 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             super.put(key,entry);
             return old;
         }
-    
-    
+
+
         /**
          * Copies all values from one map to this instance
          * @param m Map
@@ -994,12 +994,12 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                 put(entry.getKey(),entry.getValue());
             }
         }
-        
+
         @Override
         public void clear() {
             clear(true);
         }
-    
+
         public void clear(boolean notify) {
             if ( notify ) {
                 //only delete active keys
@@ -1010,7 +1010,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                 super.clear();
             }
         }
-    
+
         @Override
         public boolean containsValue(Object value) {
             if ( value == null ) {
@@ -1025,30 +1025,30 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                 return false;
             }//end if
         }
-    
+
         @Override
         public Object clone() {
             throw new UnsupportedOperationException("This operation is not valid on a replicated map");
         }
-    
+
         /**
          * Returns the entire contents of the map
-         * Map.Entry.getValue() will return a LazyReplicatedMap.MapEntry object containing all the information 
+         * Map.Entry.getValue() will return a LazyReplicatedMap.MapEntry object containing all the information
          * about the object.
          * @return Set
          */
         public Set entrySetFull() {
             return super.entrySet();
         }
-    
+
         public Set keySetFull() {
             return super.keySet();
         }
-    
+
         public int sizeFull() {
             return super.size();
         }
-    
+
         @Override
         public Set<MapEntry> entrySet() {
             LinkedHashSet<MapEntry> set = new LinkedHashSet<MapEntry>(super.size());
@@ -1063,7 +1063,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             }
             return Collections.unmodifiableSet(set);
         }
-    
+
         @Override
         public Set<Object> keySet() {
             //todo implement
@@ -1079,8 +1079,8 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             return Collections.unmodifiableSet(set);
 
         }
-    
-    
+
+
         @Override
         public int size() {
             //todo, implement a counter variable instead
@@ -1096,12 +1096,12 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             }
             return counter;
         }
-    
+
         @Override
         public boolean isEmpty() {
             return size()==0;
         }
-    
+
         @Override
         public Collection<Object> values() {
             ArrayList<Object> values = new ArrayList<Object>();
@@ -1113,7 +1113,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             }
             return Collections.unmodifiableCollection(values);
         }
-        
+
 
 //------------------------------------------------------------------------------
 //                Map Entry class
@@ -1129,21 +1129,21 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         public MapEntry(Object key, Object value) {
             setKey(key);
             setValue(value);
-            
+
         }
-        
+
         public boolean isKeySerializable() {
             return (key == null) || (key instanceof Serializable);
         }
-        
+
         public boolean isValueSerializable() {
             return (value==null) || (value instanceof Serializable);
         }
-        
+
         public boolean isSerializable() {
             return isKeySerializable() && isValueSerializable();
         }
-        
+
         public boolean isBackup() {
             return backup;
         }
@@ -1163,7 +1163,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         public boolean isActive() {
             return !proxy;
         }
-        
+
         public void setProxy(boolean proxy) {
             this.proxy = proxy;
         }
@@ -1180,11 +1180,11 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         public Member[] getBackupNodes() {
             return backupNodes;
         }
-        
+
         public void setPrimary(Member m) {
             primary = m;
         }
-        
+
         public Member getPrimary() {
             return primary;
         }
@@ -1205,7 +1205,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         public Object getKey() {
             return key;
         }
-        
+
         public Object setKey(Object key) {
             Object old = this.key;
             this.key = key;
@@ -1247,7 +1247,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                 value = XByteBuffer.deserialize(data, offset, length);
             }
         }
-        
+
         @Override
         public String toString() {
             StringBuilder buf = new StringBuilder("MapEntry[key:");
@@ -1288,7 +1288,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         private byte[] diffvalue;
         private Member[] nodes;
         private Member primary;
-        
+
         @Override
         public String toString() {
             StringBuilder buf = new StringBuilder("MapMessage[context=");
@@ -1301,7 +1301,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             buf.append(value);
             return buf.toString();
         }
-        
+
         public String getTypeDesc() {
             switch (msgtype) {
                 case MSG_BACKUP: return "MSG_BACKUP";
@@ -1334,7 +1334,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             setValue(value);
             setKey(key);
         }
-        
+
         public void deserialize(ClassLoader[] cls) throws IOException, ClassNotFoundException {
             key(cls);
             value(cls);
@@ -1364,11 +1364,11 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             keydata = null;
             return key;
         }
-        
+
         public byte[] getKeyData() {
             return keydata;
         }
-        
+
         public Serializable getValue() {
             try {
                 return value(null);
@@ -1385,7 +1385,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             valuedata = null;
             return value;
         }
-        
+
         public byte[] getValueData() {
             return valuedata;
         }
@@ -1401,7 +1401,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
         public Member getPrimary() {
             return primary;
         }
-        
+
         private void setPrimary(Member m) {
             primary = m;
         }
@@ -1418,7 +1418,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                 throw new RuntimeException(x);
             }
         }
-        
+
         public void setKey(Serializable key) {
             try {
                 if (key != null) keydata = XByteBuffer.serialize(key);
@@ -1427,7 +1427,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                 throw new RuntimeException(x);
             }
         }
-        
+
         protected Member[] readMembers(ObjectInput in) throws IOException {
             int nodecount = in.readInt();
             Member[] members = new Member[nodecount];
@@ -1438,7 +1438,7 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
             }
             return members;
         }
-        
+
         protected void writeMembers(ObjectOutput out,Member[] members) throws IOException {
             if ( members == null ) members = new Member[0];
             out.writeInt(members.length);
@@ -1450,8 +1450,8 @@ public abstract class AbstractReplicatedMap extends ConcurrentHashMap implements
                 }
             }
         }
-        
-        
+
+
         /**
          * shallow clone
          * @return Object

==================================================
ReplicatedMap.java
index a5c8294b72..2011711a38 100644
--- a/java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java
+++ b/java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java
@@ -27,7 +27,7 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 
 /**
- * A smart implementation of a stateful replicated map. uses primary/secondary backup strategy. 
+ * A smart implementation of a stateful replicated map. uses primary/secondary backup strategy.
  * One node is always the primary and one node is always the backup.
  * This map is synchronized across a cluster, and only has one backup member.<br/>
  * A perfect usage for this map would be a session map for a session manager in a clustered environment.<br/>
@@ -39,25 +39,25 @@ import org.apache.juli.logging.LogFactory;
  * These two methods are very important two understand. The map can work with two set of value objects:<br>
  * 1. Serializable - the entire object gets serialized each time it is replicated<br>
  * 2. ReplicatedMapEntry - this interface allows for a isDirty() flag and to replicate diffs if desired.<br>
- * Implementing the <code>ReplicatedMapEntry</code> interface allows you to decide what objects 
+ * Implementing the <code>ReplicatedMapEntry</code> interface allows you to decide what objects
  * get replicated and how much data gets replicated each time.<br>
  * If you implement a smart AOP mechanism to detect changes in underlying objects, you can replicate
  * only those changes by implementing the ReplicatedMapEntry interface, and return true when isDiffable()
  * is invoked.<br><br>
- * 
+ *
  * This map implementation doesn't have a background thread running to replicate changes.
  * If you do have changes without invoking put/remove then you need to invoke one of the following methods:
  * <ul>
  * <li><code>replicate(Object,boolean)</code> - replicates only the object that belongs to the key</li>
  * <li><code>replicate(boolean)</code> - Scans the entire map for changes and replicates data</li>
  *  </ul>
- * the <code>boolean</code> value in the <code>replicate</code> method used to decide 
+ * the <code>boolean</code> value in the <code>replicate</code> method used to decide
  * whether to only replicate objects that implement the <code>ReplicatedMapEntry</code> interface
  * or to replicate all objects. If an object doesn't implement the <code>ReplicatedMapEntry</code> interface
  * each time the object gets replicated the entire object gets serialized, hence a call to <code>replicate(true)</code>
  * will replicate all objects in this map that are using this node as primary.
- * 
- * <br><br><b>REMBER TO CALL <code>breakdown()</code> or <code>finalize()</code> when you are done with the map to 
+ *
+ * <br><br><b>REMBER TO CALL <code>breakdown()</code> or <code>finalize()</code> when you are done with the map to
  * avoid memory leaks.<br><br>
  * TODO implement periodic sync/transfer thread
  * @author Filip Hanik
@@ -68,9 +68,9 @@ public class LazyReplicatedMap extends AbstractReplicatedMap {
     private static final Log log = LogFactory.getLog(LazyReplicatedMap.class);
 
 
-//------------------------------------------------------------------------------    
+//------------------------------------------------------------------------------
 //              CONSTRUCTORS / DESTRUCTORS
-//------------------------------------------------------------------------------   
+//------------------------------------------------------------------------------
     /**
          * Creates a new map
          * @param channel The channel to use for communication
@@ -105,8 +105,8 @@ public class LazyReplicatedMap extends AbstractReplicatedMap {
         }
 
 
-//------------------------------------------------------------------------------    
-//              METHODS TO OVERRIDE    
+//------------------------------------------------------------------------------
+//              METHODS TO OVERRIDE
 //------------------------------------------------------------------------------
     @Override
     protected int getStateMessageType() {
@@ -127,19 +127,19 @@ public class LazyReplicatedMap extends AbstractReplicatedMap {
         int firstIdx = getNextBackupIndex();
         int nextIdx = firstIdx;
         Member[] backup = new Member[0];
-        
+
         //there are no backups
         if ( members.length == 0 || firstIdx == -1 ) return backup;
-        
+
         boolean success = false;
         do {
             //select a backup node
             Member next = members[nextIdx];
-            
+
             //increment for the next round of back up selection
             nextIdx = nextIdx + 1;
             if ( nextIdx >= members.length ) nextIdx = 0;
-            
+
             if (next == null) {
                 continue;
             }
@@ -149,7 +149,7 @@ public class LazyReplicatedMap extends AbstractReplicatedMap {
                 //publish the backup data to one node
                 msg = new MapMessage(getMapContextName(), MapMessage.MSG_BACKUP, false,
                                      (Serializable) key, (Serializable) value, null, channel.getLocalMember(false), backup);
-                if ( log.isTraceEnabled() ) 
+                if ( log.isTraceEnabled() )
                     log.trace("Publishing backup data:"+msg+" to: "+next.getName());
                 UniqueId id = getChannel().send(backup, msg, getChannelSendOptions());
                 if ( log.isTraceEnabled() )
@@ -165,7 +165,7 @@ public class LazyReplicatedMap extends AbstractReplicatedMap {
                 if (success && proxies.length > 0 ) {
                     msg = new MapMessage(getMapContextName(), MapMessage.MSG_PROXY, false,
                                          (Serializable) key, null, null, channel.getLocalMember(false),backup);
-                    if ( log.isTraceEnabled() ) 
+                    if ( log.isTraceEnabled() )
                     log.trace("Publishing proxy data:"+msg+" to: "+Arrays.toNameString(proxies));
                     getChannel().send(proxies, msg, getChannelSendOptions());
                 }

==================================================
ReplicatedMapEntry.java
index 7076c57130..f33fe994ea 100644
--- a/java/org/apache/catalina/tribes/tipis/ReplicatedMap.java
+++ b/java/org/apache/catalina/tribes/tipis/ReplicatedMap.java
@@ -23,7 +23,7 @@ import org.apache.catalina.tribes.ChannelException;
 import org.apache.catalina.tribes.Member;
 
 /**
- * All-to-all replication for a hash map implementation. Each node in the cluster will carry an identical 
+ * All-to-all replication for a hash map implementation. Each node in the cluster will carry an identical
  * copy of the map.<br><br>
  * This map implementation doesn't have a background thread running to replicate changes.
  * If you do have changes without invoking put/remove then you need to invoke one of the following methods:
@@ -42,7 +42,7 @@ import org.apache.catalina.tribes.Member;
  * TODO implement periodic sync/transfer thread
  * @author Filip Hanik
  * @version 1.0
- * 
+ *
  * TODO memberDisappeared, should do nothing except change map membership
  *       by default it relocates the primary objects
  */
@@ -93,7 +93,7 @@ public class ReplicatedMap extends AbstractReplicatedMap {
     protected int getStateMessageType() {
         return AbstractReplicatedMap.MapMessage.MSG_STATE_COPY;
     }
-    
+
     /**
      * publish info about a map pair (key/value) to other nodes in the cluster
      * @param key Object

==================================================
Streamable.java
index b44c606819..90cfe055df 100644
--- a/java/org/apache/catalina/tribes/tipis/ReplicatedMapEntry.java
+++ b/java/org/apache/catalina/tribes/tipis/ReplicatedMapEntry.java
@@ -20,7 +20,7 @@ import java.io.IOException;
 import java.io.Serializable;
 
 /**
- * 
+ *
  * For smarter replication, an object can implement this interface to replicate diffs<br>
  * The replication logic will call the methods in the following order:<br>
  * <code>
@@ -42,35 +42,35 @@ import java.io.Serializable;
  * 2. if ( isBackup(entry)||isPrimary(entry) ) entry.setOwner(owner); <br>
  * </code>
  * <br>
- * 
- * 
+ *
+ *
  * @author Filip Hanik
  * @version 1.0
  */
 public interface ReplicatedMapEntry extends Serializable {
-    
+
     /**
      * Has the object changed since last replication
      * and is not in a locked state
      * @return boolean
      */
     public boolean isDirty();
-    
+
     /**
      * If this returns true, the map will extract the diff using getDiff()
      * Otherwise it will serialize the entire object.
      * @return boolean
      */
     public boolean isDiffable();
-    
+
     /**
      * Returns a diff and sets the dirty map to false
      * @return byte[]
      * @throws IOException
      */
     public byte[] getDiff() throws IOException;
-    
-    
+
+
     /**
      * Applies a diff to an existing object.
      * @param diff byte[]
@@ -79,31 +79,31 @@ public interface ReplicatedMapEntry extends Serializable {
      * @throws IOException
      */
     public void applyDiff(byte[] diff, int offset, int length) throws IOException, ClassNotFoundException;
-    
+
     /**
      * Resets the current diff state and resets the dirty flag
      */
     public void resetDiff();
-    
+
     /**
      * Lock during serialization
      */
     public void lock();
-    
+
     /**
      * Unlock after serialization
      */
     public void unlock();
-    
+
     /**
-     * This method is called after the object has been 
+     * This method is called after the object has been
      * created on a remote map. On this method,
-     * the object can initialize itself for any data that wasn't 
-     * 
+     * the object can initialize itself for any data that wasn't
+     *
      * @param owner Object
      */
     public void setOwner(Object owner);
-    
+
     /**
      * For accuracy checking, a serialized attribute can contain a version number
      * This number increases as modifications are made to the data.
@@ -111,7 +111,7 @@ public interface ReplicatedMapEntry extends Serializable {
      * @return long - the version number or -1 if the data is not versioned
      */
     public long getVersion();
-    
+
     /**
      * Forces a certain version to a replicated map entry<br>
      * @param version long

==================================================
AbstractRxTask.java
index 5607bb26eb..731c30dd20 100644
--- a/java/org/apache/catalina/tribes/tipis/Streamable.java
+++ b/java/org/apache/catalina/tribes/tipis/Streamable.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -33,13 +33,13 @@ import java.io.IOException;
  * @version 1.0
  */
 public interface Streamable {
-    
+
     /**
      * returns true if the stream has reached its end
      * @return boolean
      */
     public boolean eof();
-   
+
     /**
      * write data into the byte array starting at offset, maximum bytes read are (data.length-offset)
      * @param data byte[] - the array to read data into
@@ -47,7 +47,7 @@ public interface Streamable {
      * @return int - the number of bytes written into the data buffer
      */
     public int write(byte[] data, int offset, int length) throws IOException;
-    
+
     /**
      * read data into the byte array starting at offset
      * @param data byte[] - the array to read data into
@@ -57,5 +57,5 @@ public interface Streamable {
      */
     public int read(byte[] data, int offset, int length) throws IOException;
 
-   
+
 }
\ No newline at end of file

==================================================
Constants.java
index 9bedf1b628..613a28df79 100644
--- a/java/org/apache/catalina/tribes/transport/AbstractRxTask.java
+++ b/java/org/apache/catalina/tribes/transport/AbstractRxTask.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -25,10 +25,10 @@ import org.apache.catalina.tribes.io.ListenCallback;
  * @version $Id$
  */
 public abstract class AbstractRxTask implements Runnable
-{ 
-    
+{
+
     public static final int OPTION_DIRECT_BUFFER = ReceiverBase.OPTION_DIRECT_BUFFER;
-    
+
     private ListenCallback callback;
     private RxTaskPool pool;
     private boolean doRun = true;
@@ -76,11 +76,11 @@ public abstract class AbstractRxTask implements Runnable
         doRun = false;
         notify();
     }
-    
+
     public void setUseBufferPool(boolean usebufpool) {
         useBufferPool = usebufpool;
     }
-    
+
     public boolean getUseBufferPool() {
         return useBufferPool;
     }

==================================================
DataSender.java
index c798940eca..bbcb7e34d7 100644
--- a/java/org/apache/catalina/tribes/transport/Constants.java
+++ b/java/org/apache/catalina/tribes/transport/Constants.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -31,7 +31,7 @@ import org.apache.catalina.tribes.io.XByteBuffer;
 public class Constants {
 
     public static final String Package = "org.apache.catalina.tribes.transport";
-    
+
     /*
      * Do not change any of these values!
      */

==================================================
MultiPointSender.java
index ece1353a9b..38a6a70516 100644
--- a/java/org/apache/catalina/tribes/transport/LocalStrings.properties
+++ b/java/org/apache/catalina/tribes/transport/LocalStrings.properties
@@ -36,4 +36,4 @@ IDataSender.senderModes.Instantiate=Can't instantiate a data replication sender
 IDataSender.senderModes.Missing=Can't configure a data replication sender for mode {0}
 IDataSender.senderModes.Resources=Can't load data replication sender mapping list
 IDataSender.stats=Send stats from [{0}:{1,number,integer}], Nr of bytes sent={2,number,integer} over {3} = {4,number,integer} bytes/request, processing time {5,number,integer} msec, avg processing time {6,number,integer} msec
-PooledSender.senderDisconnectFail=Failed to disconnect sender 
+PooledSender.senderDisconnectFail=Failed to disconnect sender

==================================================
PooledSender.java
index cbddf6fe60..c45460d396 100644
--- a/java/org/apache/catalina/tribes/transport/MultiPointSender.java
+++ b/java/org/apache/catalina/tribes/transport/MultiPointSender.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
ReceiverBase.java
index fef6c19920..82f209fd00 100644
--- a/java/org/apache/catalina/tribes/transport/PooledSender.java
+++ b/java/org/apache/catalina/tribes/transport/PooledSender.java
@@ -35,42 +35,42 @@ import org.apache.juli.logging.LogFactory;
  * @version 1.0
  */
 public abstract class PooledSender extends AbstractSender implements MultiPointSender {
-    
+
     private static final Log log = LogFactory.getLog(PooledSender.class);
     protected static final StringManager sm =
         StringManager.getManager(Constants.Package);
-    
+
     private SenderQueue queue = null;
     private int poolSize = 25;
     public PooledSender() {
         queue = new SenderQueue(this,poolSize);
     }
-    
+
     public abstract DataSender getNewDataSender();
-    
+
     public DataSender getSender() {
         return queue.getSender(getTimeout());
     }
-    
+
     public void returnSender(DataSender sender) {
         sender.keepalive();
         queue.returnSender(sender);
     }
-    
+
     @Override
     public synchronized void connect() throws IOException {
         //do nothing, happens in the socket sender itself
         queue.open();
         setConnected(true);
     }
-    
+
     @Override
     public synchronized void disconnect() {
         queue.close();
         setConnected(false);
     }
-    
-    
+
+
     public int getInPoolSize() {
         return queue.getInPoolSize();
     }
@@ -152,7 +152,7 @@ public abstract class PooledSender extends AbstractSender implements MultiPointS
         public int getInPoolSize() {
             return notinuse.size();
         }
-        
+
         public synchronized boolean checkIdleKeepAlive() {
             DataSender[] list = new DataSender[notinuse.size()];
             notinuse.toArray(list);

==================================================
ReplicationTransmitter.java
index 2c31e38749..30e5f2bda3 100644
--- a/java/org/apache/catalina/tribes/transport/ReceiverBase.java
+++ b/java/org/apache/catalina/tribes/transport/ReceiverBase.java
@@ -84,7 +84,7 @@ public abstract class ReceiverBase implements ChannelReceiver, ListenCallback, R
     private boolean useBufferPool = true;
     private boolean daemon = true;
     private long maxIdleTime = 60000;
-    
+
     private ExecutorService executor;
 
 
@@ -604,6 +604,6 @@ public abstract class ReceiverBase implements ChannelReceiver, ListenCallback, R
 
     public void setMaxIdleTime(long maxIdleTime) {
         this.maxIdleTime = maxIdleTime;
-    }    
-    
+    }
+
 }
\ No newline at end of file

==================================================
RxTaskPool.java
index 40ea11a626..8f2285c26c 100644
--- a/java/org/apache/catalina/tribes/transport/ReplicationTransmitter.java
+++ b/java/org/apache/catalina/tribes/transport/ReplicationTransmitter.java
@@ -27,8 +27,8 @@ import org.apache.catalina.tribes.util.StringManager;
 /**
  * Transmit message to other cluster members
  * Actual senders are created based on the replicationMode
- * type 
- * 
+ * type
+ *
  * @author Filip Hanik
  * @version $Id$
  */
@@ -52,9 +52,9 @@ public class ReplicationTransmitter implements ChannelSender {
     public void setTransport(MultiPointSender transport) {
         this.transport = transport;
     }
-    
+
     // ------------------------------------------------------------- public
-    
+
     /**
      * Send data to one member
      * @see org.apache.catalina.tribes.ChannelSender#sendMessage(org.apache.catalina.tribes.ChannelMessage, org.apache.catalina.tribes.Member[])
@@ -64,11 +64,11 @@ public class ReplicationTransmitter implements ChannelSender {
         MultiPointSender sender = getTransport();
         sender.sendMessage(destination,message);
     }
-    
-    
+
+
     /**
      * start the sender and register transmitter mbean
-     * 
+     *
      * @see org.apache.catalina.tribes.ChannelSender#start()
      */
     @Override
@@ -78,7 +78,7 @@ public class ReplicationTransmitter implements ChannelSender {
 
     /**
      * stop the sender and deregister mbeans (transmitter, senders)
-     * 
+     *
      * @see org.apache.catalina.tribes.ChannelSender#stop()
      */
     @Override
@@ -88,7 +88,7 @@ public class ReplicationTransmitter implements ChannelSender {
 
     /**
      * Call transmitter to check for sender socket status
-     * 
+     *
      * @see org.apache.catalina.ha.tcp.SimpleTcpCluster#backgroundProcess()
      */
     @Override
@@ -99,7 +99,7 @@ public class ReplicationTransmitter implements ChannelSender {
     /**
      * add new cluster member and create sender ( s. replicationMode) transfer
      * current properties to sender
-     * 
+     *
      * @see org.apache.catalina.tribes.ChannelSender#add(org.apache.catalina.tribes.Member)
      */
     @Override
@@ -109,7 +109,7 @@ public class ReplicationTransmitter implements ChannelSender {
 
     /**
      * remove sender from transmitter. ( deregister mbean and disconnect sender )
-     * 
+     *
      * @see org.apache.catalina.tribes.ChannelSender#remove(org.apache.catalina.tribes.Member)
      */
     @Override

==================================================
SenderState.java
index d521fc08c7..9aa6813dca 100644
--- a/java/org/apache/catalina/tribes/transport/RxTaskPool.java
+++ b/java/org/apache/catalina/tribes/transport/RxTaskPool.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -35,23 +35,23 @@ public class RxTaskPool
 
     List<AbstractRxTask> idle = new LinkedList<AbstractRxTask>();
     List<AbstractRxTask> used = new LinkedList<AbstractRxTask>();
-    
+
     Object mutex = new Object();
     boolean running = true;
-    
+
     private int maxTasks;
     private int minTasks;
-    
+
     private TaskCreator creator = null;
 
-    
+
     public RxTaskPool (int maxTasks, int minTasks, TaskCreator creator) throws Exception {
         // fill up the pool with worker threads
         this.maxTasks = maxTasks;
         this.minTasks = minTasks;
         this.creator = creator;
     }
-    
+
     protected void configureTask(AbstractRxTask task) {
         synchronized (task) {
             task.setTaskPool(this);
@@ -92,7 +92,7 @@ public class RxTaskPool
         }
         return (worker);
     }
-    
+
     public int available() {
         return idle.size();
     }
@@ -150,7 +150,7 @@ public class RxTaskPool
     public TaskCreator getTaskCreator() {
         return this.creator;
     }
-    
+
     public static interface TaskCreator  {
         public AbstractRxTask createRxTask();
     }

==================================================
BioReceiver.java
index 6c74e40855..78c9497894 100644
--- a/java/org/apache/catalina/tribes/transport/SenderState.java
+++ b/java/org/apache/catalina/tribes/transport/SenderState.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -23,20 +23,20 @@ import org.apache.catalina.tribes.Member;
 
 
 /**
- * 
+ *
  * @author Filip Hanik
  * @version 1.0
  * @since 5.5.16
  */
 
 public class SenderState {
-    
+
     public static final int READY = 0;
     public static final int SUSPECT = 1;
-    public static final int FAILING = 2;    
-    
+    public static final int FAILING = 2;
+
     protected static HashMap<Member, SenderState> memberStates = new HashMap<Member, SenderState>();
-    
+
     public static SenderState getSenderState(Member member) {
         return getSenderState(member,true);
     }
@@ -54,13 +54,13 @@ public class SenderState {
         }
         return state;
     }
-    
+
     public static void removeSenderState(Member member) {
         synchronized ( memberStates ) {
             memberStates.remove(member);
         }
     }
-    
+
 
     // ----------------------------------------------------- Instance Variables
 
@@ -68,7 +68,7 @@ public class SenderState {
 
     //  ----------------------------------------------------- Constructor
 
-    
+
     private SenderState() {
         this(READY);
     }
@@ -76,9 +76,9 @@ public class SenderState {
     private SenderState(int state) {
         this.state = state;
     }
-    
+
     /**
-     * 
+     *
      * @return boolean
      */
     public boolean isSuspect() {
@@ -88,23 +88,23 @@ public class SenderState {
     public void setSuspect() {
         state = SUSPECT;
     }
-    
+
     public boolean isReady() {
         return state == READY;
     }
-    
+
     public void setReady() {
         state = READY;
     }
-    
+
     public boolean isFailing() {
         return state == FAILING;
     }
-    
+
     public void setFailing() {
         state = FAILING;
     }
-    
+
 
     //  ----------------------------------------------------- Public Properties
 

==================================================
BioReplicationTask.java
index 804bb9e3d1..987f696f60 100644
--- a/java/org/apache/catalina/tribes/transport/bio/BioReceiver.java
+++ b/java/org/apache/catalina/tribes/transport/bio/BioReceiver.java
@@ -64,12 +64,12 @@ public class BioReceiver extends ReceiverBase implements Runnable {
             else throw new IOException(x.getMessage());
         }
     }
-    
+
     @Override
     public AbstractRxTask createRxTask() {
         return getReplicationThread();
     }
-    
+
     protected BioReplicationTask getReplicationThread() {
         BioReplicationTask result = new BioReplicationTask(this);
         result.setOptions(getWorkerThreadOptions());
@@ -108,7 +108,7 @@ public class BioReceiver extends ReceiverBase implements Runnable {
             log.error("Unable to run replication listener.", x);
         }
     }
-    
+
     public void listen() throws Exception {
         if (doListen()) {
             log.warn("ServerSocket already started");
@@ -150,6 +150,6 @@ public class BioReceiver extends ReceiverBase implements Runnable {
             getExecutor().execute(task);
         }//while
     }
-    
+
 
 }
\ No newline at end of file

==================================================
BioSender.java
index 321d865da1..112c990444 100644
--- a/java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java
+++ b/java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -40,19 +40,19 @@ import org.apache.juli.logging.LogFactory;
  * serviceChannel() method stores the key reference in the thread object then
  * calls notify() to wake it up. When the channel has been drained, the worker
  * thread returns itself to its parent pool.
- * 
+ *
  * @author Filip Hanik
- * 
+ *
  * @version $Id$
  */
 public class BioReplicationTask extends AbstractRxTask {
 
 
     private static final Log log = LogFactory.getLog( BioReplicationTask.class );
-    
+
     protected Socket socket;
     protected ObjectReader reader;
-    
+
     public BioReplicationTask (ListenCallback callback) {
         super(callback);
     }
@@ -88,12 +88,12 @@ public class BioReplicationTask extends AbstractRxTask {
         if ( getTaskPool() != null ) getTaskPool().returnWorker (this);
     }
 
-    
+
     public synchronized void serviceSocket(Socket socket, ObjectReader reader) {
         this.socket = socket;
         this.reader = reader;
     }
-    
+
     protected void execute(ObjectReader reader) throws Exception{
         int pkgcnt = reader.count();
 
@@ -101,7 +101,7 @@ public class BioReplicationTask extends AbstractRxTask {
             ChannelMessage[] msgs = reader.execute();
             for ( int i=0; i<msgs.length; i++ ) {
                 /**
-                 * Use send ack here if you want to ack the request to the remote 
+                 * Use send ack here if you want to ack the request to the remote
                  * server before completing the request
                  * This is considered an asynchronized request
                  */
@@ -123,10 +123,10 @@ public class BioReplicationTask extends AbstractRxTask {
                     BufferPool.getBufferPool().returnBuffer(msgs[i].getMessage());
                     msgs[i].setMessage(null);
                 }
-            }                       
+            }
         }
 
-       
+
     }
 
     /**
@@ -166,7 +166,7 @@ public class BioReplicationTask extends AbstractRxTask {
             log.warn("Unable to send ACK back through channel, channel disconnected?: "+x.getMessage());
         }
     }
-    
+
     @Override
     public void close() {
         setDoRun(false);

==================================================
MultipointBioSender.java
index 003a241f07..6f21031eda 100644
--- a/java/org/apache/catalina/tribes/transport/bio/BioSender.java
+++ b/java/org/apache/catalina/tribes/transport/bio/BioSender.java
@@ -34,7 +34,7 @@ import org.apache.catalina.tribes.util.StringManager;
 /**
  * Send cluster messages with only one socket. Ack and keep Alive Handling is
  * supported
- * 
+ *
  * @author Peter Rossbach
  * @author Filip Hanik
  * @version $Id$
@@ -57,12 +57,12 @@ public class BioSender extends AbstractSender {
     private Socket socket = null;
     private OutputStream soOut = null;
     private InputStream soIn = null;
-    
+
     protected XByteBuffer ackbuf = new XByteBuffer(Constants.ACK_COMMAND.length,true);
 
 
     // ------------------------------------------------------------- Constructor
-    
+
     public BioSender()  {
         // NO-OP
     }
@@ -71,7 +71,7 @@ public class BioSender extends AbstractSender {
     // --------------------------------------------------------- Public Methods
 
     /**
-     * Connect other cluster member receiver 
+     * Connect other cluster member receiver
      * @see org.apache.catalina.tribes.transport.DataSender#connect()
      */
     @Override
@@ -79,10 +79,10 @@ public class BioSender extends AbstractSender {
         openSocket();
    }
 
- 
+
     /**
      * disconnect and close socket
-     * 
+     *
      * @see org.apache.catalina.tribes.transport.DataSender#disconnect()
      */
     @Override
@@ -93,7 +93,7 @@ public class BioSender extends AbstractSender {
             if (log.isDebugEnabled())
                 log.debug(sm.getString("IDataSender.disconnect", getAddress().getHostAddress(), new Integer(getPort()), new Long(0)));
         }
-        
+
     }
 
     /**
@@ -127,7 +127,7 @@ public class BioSender extends AbstractSender {
         }
     }
 
-    
+
     /**
      * Name of this SockerSender
      */
@@ -140,7 +140,7 @@ public class BioSender extends AbstractSender {
     }
 
     // --------------------------------------------------------- Protected Methods
- 
+
     /**
      * open real socket and set time out when waitForAck is enabled
      * is socket open return directly
@@ -173,12 +173,12 @@ public class BioSender extends AbstractSender {
               log.debug(sm.getString("IDataSender.openSocket.failure",getAddress().getHostAddress(), new Integer(getPort()),new Long(0)), ex1);
           throw (ex1);
         }
-        
+
      }
 
     /**
      * Close socket.
-     * 
+     *
      * @see #disconnect()
      */
     protected void closeSocket() {
@@ -205,20 +205,20 @@ public class BioSender extends AbstractSender {
      * Push messages with only one socket at a time
      * Wait for ack is needed and make auto retry when write message is failed.
      * After sending error close and reopen socket again.
-     * 
+     *
      * After successful sending update stats
-     * 
+     *
      * WARNING: Subclasses must be very careful that only one thread call this pushMessage at once!!!
-     * 
+     *
      * @see #closeSocket()
      * @see #openSocket()
      * @see #sendMessage(byte[], boolean)
-     * 
+     *
      * @param data
      *            data to send
      * @since 5.5.10
      */
-    
+
     protected void pushMessage(byte[] data, boolean reconnect, boolean waitForAck) throws IOException {
         keepalive();
         if ( reconnect ) closeSocket();
@@ -229,7 +229,7 @@ public class BioSender extends AbstractSender {
         SenderState.getSenderState(getDestination()).setReady();
 
     }
-    
+
     /**
      * Wait for Acknowledgement from other server.
      * FIXME Please, not wait only for three characters, better control that the wait ack message is correct.

==================================================
PooledMultiSender.java
index 949e4286a4..b2010a5ae9 100644
--- a/java/org/apache/catalina/tribes/transport/bio/MultipointBioSender.java
+++ b/java/org/apache/catalina/tribes/transport/bio/MultipointBioSender.java
@@ -40,8 +40,8 @@ public class MultipointBioSender extends AbstractSender implements MultiPointSen
     public MultipointBioSender() {
         // NO-OP
     }
-    
-    protected long selectTimeout = 1000; 
+
+    protected long selectTimeout = 1000;
     protected HashMap<Member, BioSender> bioSenders =
         new HashMap<Member, BioSender>();
 

==================================================
FastQueue.java
index 8f96d060e0..2709b739f3 100644
--- a/java/org/apache/catalina/tribes/transport/bio/PooledMultiSender.java
+++ b/java/org/apache/catalina/tribes/transport/bio/PooledMultiSender.java
@@ -35,12 +35,12 @@ import org.apache.catalina.tribes.transport.PooledSender;
  * @version 1.0
  */
 public class PooledMultiSender extends PooledSender {
-    
+
 
     public PooledMultiSender() {
         // NO-OP
     }
-    
+
     @Override
     public void sendMessage(Member[] destination, ChannelMessage msg) throws ChannelException {
         MultiPointSender sender = null;

==================================================
LinkObject.java
index 78c058cc64..2e700010f0 100644
--- a/java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java
+++ b/java/org/apache/catalina/tribes/transport/bio/util/FastQueue.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -26,7 +26,7 @@ import org.apache.catalina.tribes.group.InterceptorPayload;
 /**
  * A fast queue that remover thread lock the adder thread. <br/>Limit the queue
  * length when you have strange producer thread problems.
- * 
+ *
  * FIXME add i18n support to log messages
  * @author Rainer Jung
  * @author Peter Rossbach
@@ -61,7 +61,7 @@ public class FastQueue {
      */
     private boolean checkLock = false;
 
-    
+
     private boolean inAdd = false;
 
     private boolean inRemove = false;
@@ -78,7 +78,7 @@ public class FastQueue {
      */
     private long addWaitTimeout = 10000L;
 
-    
+
     /**
      * removeWaitTimeout for consumer
      */
@@ -106,7 +106,7 @@ public class FastQueue {
 
     /**
      * get current add wait timeout
-     * 
+     *
      * @return current wait timeout
      */
     public long getAddWaitTimeout() {
@@ -116,7 +116,7 @@ public class FastQueue {
 
     /**
      * Set add wait timeout (default 10000 msec)
-     * 
+     *
      * @param timeout
      */
     public void setAddWaitTimeout(long timeout) {
@@ -126,7 +126,7 @@ public class FastQueue {
 
     /**
      * get current remove wait timeout
-     * 
+     *
      * @return The timeout
      */
     public long getRemoveWaitTimeout() {
@@ -136,7 +136,7 @@ public class FastQueue {
 
     /**
      * set remove wait timeout ( default 30000 msec)
-     * 
+     *
      * @param timeout
      */
     public void setRemoveWaitTimeout(long timeout) {
@@ -178,7 +178,7 @@ public class FastQueue {
         this.checkLock = checkLock;
     }
 
-    
+
     /**
      * @return The max size
      */
@@ -193,16 +193,16 @@ public class FastQueue {
         maxSize = size;
     }
 
-    
+
     /**
-     * unlock queue for next add 
+     * unlock queue for next add
      */
     public void unlockAdd() {
         lock.unlockAdd(size > 0 ? true : false);
     }
 
     /**
-     * unlock queue for next remove 
+     * unlock queue for next remove
      */
     public void unlockRemove() {
         lock.unlockRemove();
@@ -232,7 +232,7 @@ public class FastQueue {
 
     /**
      * Add new data to the queue.
-     * 
+     *
      * FIXME extract some method
      */
     public boolean add(ChannelMessage msg, Member[] destination, InterceptorPayload payload) {

==================================================
SingleRemoveSynchronizedAddLock.java
index 1cf45279ac..804fc754ea 100644
--- a/java/org/apache/catalina/tribes/transport/bio/util/LinkObject.java
+++ b/java/org/apache/catalina/tribes/transport/bio/util/LinkObject.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -73,7 +73,7 @@ public class LinkObject {
     public LinkObject next() {
         return next;
     }
-    
+
     public void setNext(LinkObject next) {
         this.next = next;
     }

==================================================
NioSender.java
index fe89b7b7f0..e4c8075e1d 100644
--- a/java/org/apache/catalina/tribes/transport/bio/util/SingleRemoveSynchronizedAddLock.java
+++ b/java/org/apache/catalina/tribes/transport/bio/util/SingleRemoveSynchronizedAddLock.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -31,7 +31,7 @@ package org.apache.catalina.tribes.transport.bio.util;
  * but the queue is empty, it will block (poll)
  * until an add threads adds an entry to the queue and
  * releases the lock.
- * 
+ *
  * If the remove thread and add threads compete for
  * the lock and an add thread releases the lock, then
  * the remove thread will get the lock first.
@@ -48,17 +48,17 @@ package org.apache.catalina.tribes.transport.bio.util;
  * @author Peter Rossbach
  * @version 1.1
  */
- 
+
 public class SingleRemoveSynchronizedAddLock {
-    
+
     public SingleRemoveSynchronizedAddLock() {
         // NO-OP
     }
-    
+
     public SingleRemoveSynchronizedAddLock(boolean dataAvailable) {
         this.dataAvailable=dataAvailable;
     }
-    
+
     /**
      * Time in milliseconds after which threads
      * waiting for an add lock are woken up.
@@ -213,7 +213,7 @@ public class SingleRemoveSynchronizedAddLock {
         }
         if ( removeEnabled ) {
             removeLocked=true;
-        } 
+        }
         return removeLocked;
     }
 

==================================================
PooledParallelSender.java
index 6330f18543..d591b4bfe2 100644
--- a/java/org/apache/catalina/tribes/transport/nio/NioSender.java
+++ b/java/org/apache/catalina/tribes/transport/nio/NioSender.java
@@ -236,7 +236,7 @@ public class NioSender extends AbstractSender {
             dataChannel.connect(daddr);
             completeConnect();
             dataChannel.register(getSelector(),SelectionKey.OP_WRITE, this);
-            
+
         } else {
             InetSocketAddress addr = new InetSocketAddress(getAddress(),getPort());
             if ( socketChannel != null ) throw new IOException("Socket channel has already been established. Connection might be in progress.");
@@ -341,7 +341,7 @@ public class NioSender extends AbstractSender {
            if ( writebuf != null ) writebuf.clear();
            else writebuf = getBuffer(length);
            if ( writebuf.capacity() < length ) writebuf = getBuffer(length);
-           
+
            //TODO use ByteBuffer.wrap to avoid copying the data.
            writebuf.put(data,offset,length);
            //writebuf.rewind();

==================================================
Arrays.java
index b7fab94884..2419ac4252 100644
--- a/java/org/apache/catalina/tribes/transport/nio/PooledParallelSender.java
+++ b/java/org/apache/catalina/tribes/transport/nio/PooledParallelSender.java
@@ -73,7 +73,7 @@ public class PooledParallelSender extends PooledSender {
             throw new RuntimeException("Unable to open NIO selector.",x);
         }
     }
-    
+
     @Override
     public synchronized void disconnect() {
         this.connected = false;
@@ -85,5 +85,5 @@ public class PooledParallelSender extends PooledSender {
         this.connected = true;
         super.connect();
     }
-   
+
 }
\ No newline at end of file

==================================================
ExecutorFactory.java
index 76739fecf7..b24cce4bc0 100644
--- a/java/org/apache/catalina/tribes/util/Arrays.java
+++ b/java/org/apache/catalina/tribes/util/Arrays.java
@@ -35,7 +35,7 @@ import org.apache.catalina.tribes.membership.Membership;
 public class Arrays {
     private static final Charset CHARSET_ISO_8859_1 =
         Charset.forName("ISO-8859-1");
-    
+
     public static boolean contains(byte[] source, int srcoffset, byte[] key, int keyoffset, int length) {
         if ( srcoffset < 0 || srcoffset >= source.length) throw new ArrayIndexOutOfBoundsException("srcoffset is out of bounds.");
         if ( keyoffset < 0 || keyoffset >= key.length) throw new ArrayIndexOutOfBoundsException("keyoffset is out of bounds.");
@@ -49,7 +49,7 @@ public class Arrays {
         }
         return match;
     }
-    
+
     public static String toString(byte[] data) {
         return toString(data,0,data!=null?data.length:0);
     }
@@ -81,7 +81,7 @@ public class Arrays {
     public static String toString(Object[] data) {
         return toString(data,0,data!=null?data.length:0);
     }
-    
+
     public static String toString(Object[] data, int offset, int length) {
         StringBuilder buf = new StringBuilder("{");
         if ( data != null && length > 0 ) {
@@ -93,11 +93,11 @@ public class Arrays {
         buf.append("}");
         return buf.toString();
     }
-    
+
     public static String toNameString(Member[] data) {
         return toNameString(data,0,data!=null?data.length:0);
     }
-    
+
     public static String toNameString(Member[] data, int offset, int length) {
         StringBuilder buf = new StringBuilder("{");
         if ( data != null && length > 0 ) {
@@ -115,7 +115,7 @@ public class Arrays {
         for (int i=0;i<data.length; i++ ) result += data[i];
         return result;
     }
-    
+
     public static UniqueId getUniqudId(ChannelMessage msg) {
         return new UniqueId(msg.getUniqueId());
     }
@@ -123,7 +123,7 @@ public class Arrays {
     public static UniqueId getUniqudId(byte[] data) {
         return new UniqueId(data);
     }
-    
+
     public static boolean equals(byte[] o1, byte[] o2) {
         return java.util.Arrays.equals(o1,o2);
     }
@@ -133,13 +133,13 @@ public class Arrays {
         if ( result ) for (int i=0; i<o1.length && result; i++ ) result = o1[i].equals(o2[i]);
         return result;
     }
-    
+
     public static boolean sameMembers(Member[] m1, Member[] m2) {
         AbsoluteOrder.absoluteOrder(m1);
         AbsoluteOrder.absoluteOrder(m2);
         return equals(m1,m2);
     }
-    
+
     public static Member[] merge(Member[] m1, Member[] m2) {
         AbsoluteOrder.absoluteOrder(m1);
         AbsoluteOrder.absoluteOrder(m2);
@@ -151,11 +151,11 @@ public class Arrays {
         AbsoluteOrder.absoluteOrder(result);
         return result;
     }
-    
+
     public static void fill(Membership mbrship, Member[] m) {
         for (int i=0; i<m.length; i++ ) mbrship.addMember((MemberImpl)m[i]);
     }
-    
+
     public static Member[] diff(Membership complete, Membership local, MemberImpl ignore) {
         ArrayList<Member> result = new ArrayList<Member>();
         MemberImpl[] comp = complete.getMembers();
@@ -165,35 +165,35 @@ public class Arrays {
         }
         return result.toArray(new MemberImpl[result.size()]);
     }
-    
+
     public static Member[] remove(Member[] all, Member remove) {
         return extract(all,new Member[] {remove});
     }
-    
+
     public static Member[] extract(Member[] all, Member[] remove) {
         List<Member> alist = java.util.Arrays.asList(all);
         ArrayList<Member> list = new ArrayList<Member>(alist);
         for (int i=0; i<remove.length; i++ ) list.remove(remove[i]);
         return list.toArray(new Member[list.size()]);
     }
-    
+
     public static int indexOf(Member member, Member[] members) {
         int result = -1;
-        for (int i=0; (result==-1) && (i<members.length); i++ ) 
+        for (int i=0; (result==-1) && (i<members.length); i++ )
             if ( member.equals(members[i]) ) result = i;
         return result;
     }
-    
+
     public static int nextIndex(Member member, Member[] members) {
         int idx = indexOf(member,members)+1;
         if (idx >= members.length ) idx = ((members.length>0)?0:-1);
-        
+
 //System.out.println("Next index:"+idx);
 //System.out.println("Member:"+member.getName());
 //System.out.println("Members:"+toNameString(members));
         return idx;
     }
-    
+
     public static int hashCode(byte a[]) {
         if (a == null)
             return 0;
@@ -205,8 +205,8 @@ public class Arrays {
         }
         return result;
     }
-    
-    public static byte[] fromString(String value) { 
+
+    public static byte[] fromString(String value) {
         if ( value == null ) return null;
         if ( !value.startsWith("{") ) throw new RuntimeException("byte arrays must be represented as {1,3,4,5,6}");
         StringTokenizer t = new StringTokenizer(value,"{,}",false);

==================================================
Logs.java
index 944e014728..db17d447a8 100644
--- a/java/org/apache/catalina/tribes/util/ExecutorFactory.java
+++ b/java/org/apache/catalina/tribes/util/ExecutorFactory.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -38,7 +38,7 @@ public class ExecutorFactory {
         taskqueue.setParent(service);
         return service;
     }
-    
+
      // ---------------------------------------------- TaskQueue Inner Class
     private static class TaskQueue extends LinkedBlockingQueue<Runnable> {
         private static final long serialVersionUID = 1L;
@@ -52,7 +52,7 @@ public class ExecutorFactory {
         public void setParent(ThreadPoolExecutor tp) {
             parent = tp;
         }
-        
+
         @Override
         public boolean offer(Runnable o) {
             //we can't do any checks

==================================================
StringManager.java
index 1655f45f98..f55cf6d2aa 100644
--- a/java/org/apache/catalina/tribes/util/Logs.java
+++ b/java/org/apache/catalina/tribes/util/Logs.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,7 @@ package org.apache.catalina.tribes.util;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 /**
- * 
+ *
  * Simple class that holds references to global loggers
  * @author Filip Hanik
  * @version 1.0

==================================================
TcclThreadFactory.java
index cf2cbd86d3..69f87c6329 100644
--- a/java/org/apache/catalina/tribes/util/StringManager.java
+++ b/java/org/apache/catalina/tribes/util/StringManager.java
@@ -93,11 +93,11 @@ public class StringManager {
     /**
         Get a string from the underlying resource bundle or return
         null if the String is not found.
-     
+
         @param key to desired resource String
         @return resource String matching <i>key</i> from underlying
                 bundle or null if not found.
-        @throws IllegalArgumentException if <i>key</i> is null.        
+        @throws IllegalArgumentException if <i>key</i> is null.
      */
     public String getString(String key) {
         if(key == null){

==================================================
UUIDGenerator.java
index a1959f930c..ec73687827 100644
--- a/java/org/apache/catalina/tribes/util/TcclThreadFactory.java
+++ b/java/org/apache/catalina/tribes/util/TcclThreadFactory.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -29,15 +29,15 @@ import java.util.concurrent.atomic.AtomicInteger;
  * session replication.
  */
 public class TcclThreadFactory implements ThreadFactory {
-    
+
     private static final AtomicInteger poolNumber = new AtomicInteger(1);
     private static final boolean IS_SECURITY_ENABLED =
         (System.getSecurityManager() != null);
-    
+
     private final ThreadGroup group;
     private final AtomicInteger threadNumber = new AtomicInteger(1);
     private final String namePrefix;
-    
+
     public TcclThreadFactory() {
         SecurityManager s = System.getSecurityManager();
         group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();
@@ -48,7 +48,7 @@ public class TcclThreadFactory implements ThreadFactory {
     public Thread newThread(Runnable r) {
         final Thread t = new Thread(group, r, namePrefix +
                 threadNumber.getAndIncrement());
-        
+
         if (IS_SECURITY_ENABLED) {
             AccessController.doPrivileged(new PrivilegedAction<Void>() {
                 @Override

==================================================
