1af0c6da9735e6a9de567906e7b9d8f4e05875ee
==================================================
First attempt for SSL send file
==================================================
Filip Hanik
==================================================
Wed Nov 26 03:39:03 2008 +0000
==================================================
Http11NioProtocol.java
First attempt for SSL send file


git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@720724 13f79535-47bb-0310-9956-ffa450edef68



==================================================
NioChannel.java
index 631551364f..b30ceef0fd 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -309,7 +309,6 @@ public class Http11NioProtocol implements ProtocolHandler, MBeanRegistration
     public void setUseSendfile(boolean useSendfile) {
         ep.setUseSendfile(useSendfile);
     }
-
     
     // -------------------- Tcp setup --------------------
 

==================================================
NioEndpoint.java
index ba90442b60..aba04da39d 100644
--- a/java/org/apache/tomcat/util/net/NioChannel.java
+++ b/java/org/apache/tomcat/util/net/NioChannel.java
@@ -47,6 +47,8 @@ public class NioChannel implements ByteChannel{
     protected ApplicationBufferHandler bufHandler;
 
     protected Poller poller;
+    
+    protected boolean sendFile = false;
 
     public NioChannel(SocketChannel channel, ApplicationBufferHandler bufHandler) throws IOException {
         this.sc = channel;
@@ -56,6 +58,7 @@ public class NioChannel implements ByteChannel{
     public void reset() throws IOException {
         bufHandler.getReadBuffer().clear();
         bufHandler.getWriteBuffer().clear();
+        this.sendFile = false;
     }
     
     public int getBufferSize() {
@@ -191,5 +194,22 @@ public class NioChannel implements ByteChannel{
     public String toString() {
         return super.toString()+":"+this.sc.toString();
     }
+    
+    public int getOutboundRemaining() {
+        return 0;
+    }
+    
+    public void flushOutbound() throws IOException {
+        
+    }
+    
+    public boolean isSendFile() {
+        return sendFile;
+    }
+    
+    public void setSendFile(boolean s) {
+        this.sendFile = s;
+    }
+    
 
 }

==================================================
SecureNioChannel.java
index ff125185bf..9423b9c299 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -30,6 +30,7 @@ import java.nio.channels.SelectionKey;
 import java.nio.channels.Selector;
 import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.SocketChannel;
+import java.nio.channels.WritableByteChannel;
 import java.security.KeyStore;
 import java.util.Collection;
 import java.util.Iterator;
@@ -644,7 +645,6 @@ public class NioEndpoint {
     }
 
     public void setUseSendfile(boolean useSendfile) {
-
         this.useSendfile = useSendfile;
     }
 
@@ -958,8 +958,7 @@ public class NioEndpoint {
     }
 
     public boolean getUseSendfile() {
-        //send file doesn't work with SSL
-        return useSendfile && (!isSSLEnabled());
+        return useSendfile;
     }
 
     public int getOomParachute() {
@@ -1328,10 +1327,10 @@ public class NioEndpoint {
                     } else {
                         cancel = true;
                     }
-                    if ( cancel ) getPoller0().cancelledKey(key,SocketStatus.ERROR,false);
+                    if ( cancel ) socket.getPoller().cancelledKey(key,SocketStatus.ERROR,false);
                 }catch (CancelledKeyException ckx) {
                     try {
-                        getPoller0().cancelledKey(key,SocketStatus.DISCONNECT,true);
+                        socket.getPoller().cancelledKey(key,SocketStatus.DISCONNECT,true);
                     }catch (Exception ignore) {}
                 }
             }//end if
@@ -1627,6 +1626,7 @@ public class NioEndpoint {
         }
         
         public boolean processSendfile(SelectionKey sk, KeyAttachment attachment, boolean reg, boolean event) {
+            NioChannel sc = null;
             try {
                 //unreg(sk,attachment);//only do this if we do process send file on a separate thread
                 SendfileData sd = attachment.getSendfileData();
@@ -1638,13 +1638,20 @@ public class NioEndpoint {
                     }
                     sd.fchannel = new FileInputStream(f).getChannel();
                 }
-                SocketChannel sc = attachment.getChannel().getIOChannel();
-                long written = sd.fchannel.transferTo(sd.pos,sd.length,sc);
-                if ( written > 0 ) {
-                    sd.pos += written;
-                    sd.length -= written;
+                sc = attachment.getChannel();
+                sc.setSendFile(true);
+                WritableByteChannel wc =(WritableByteChannel) ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());
+                
+                if (sc.getOutboundRemaining()>0) {
+                    sc.flushOutbound();
+                } else {
+                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);
+                    if ( written > 0 ) {
+                        sd.pos += written;
+                        sd.length -= written;
+                    }
                 }
-                if ( sd.length <= 0 ) {
+                if ( sd.length <= 0 && sc.getOutboundRemaining()<=0) {
                     if (log.isDebugEnabled()) {
                         log.debug("Send file complete for:"+sd.fileName);
                     }
@@ -1684,6 +1691,8 @@ public class NioEndpoint {
                 log.error("",t);
                 cancelledKey(sk, SocketStatus.ERROR, false);
                 return false;
+            }finally {
+                if (sc!=null) sc.setSendFile(false);
             }
             return true;
         }

==================================================
