f4058bef677b09da0f9e2514728dfb30ee092fc6
==================================================
Format classes. No functional change.
==================================================
Mark Thomas
==================================================
Fri Jan 12 14:16:08 2018 +0000
==================================================
ByteChunk.java
Format classes. No functional change.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1820994 13f79535-47bb-0310-9956-ffa450edef68



==================================================
CharChunk.java
index b95f52ce93..19132e2cda 100644
--- a/java/org/apache/tomcat/util/buf/ByteChunk.java
+++ b/java/org/apache/tomcat/util/buf/ByteChunk.java
@@ -43,16 +43,15 @@ import java.nio.charset.StandardCharsets;
 // inside this way it could provide the search/etc on ByteBuffer, as a helper.
 
 /**
- * This class is used to represent a chunk of bytes, and
- * utilities to manipulate byte[].
+ * This class is used to represent a chunk of bytes, and utilities to manipulate
+ * byte[].
  *
  * The buffer can be modified and used for both input and output.
  *
  * There are 2 modes: The chunk can be associated with a sink - ByteInputChannel
  * or ByteOutputChannel, which will be used when the buffer is empty (on input)
- * or filled (on output).
- * For output, it can also grow. This operating mode is selected by calling
- * setLimit() or allocate(initial, limit) with limit != -1.
+ * or filled (on output). For output, it can also grow. This operating mode is
+ * selected by calling setLimit() or allocate(initial, limit) with limit != -1.
  *
  * Various search and append method are defined - similar with String and
  * StringBuffer, but operating on bytes.
@@ -71,11 +70,13 @@ public final class ByteChunk implements Cloneable, Serializable {
 
     private static final long serialVersionUID = 1L;
 
-    /** Input interface, used when the buffer is empty
+    /**
+     * Input interface, used when the buffer is empty
      *
      * Same as java.nio.channel.ReadableByteChannel
      */
     public static interface ByteInputChannel {
+
         /**
          * Read new bytes.
          *
@@ -86,24 +87,26 @@ public final class ByteChunk implements Cloneable, Serializable {
         public int realReadBytes() throws IOException;
     }
 
-    /** Same as java.nio.channel.WritableByteChannel.
+    /**
+     * Same as java.nio.channel.WritableByteChannel.
      */
     public static interface ByteOutputChannel {
+
         /**
-         * Send the bytes ( usually the internal conversion buffer ).
-         * Expect 8k output if the buffer is full.
+         * Send the bytes ( usually the internal conversion buffer ). Expect 8k
+         * output if the buffer is full.
          *
          * @param cbuf bytes that will be written
          * @param off offset in the bytes array
          * @param len length that will be written
          * @throws IOException If an I/O occurs while writing the bytes
          */
-        public void realWriteBytes(byte cbuf[], int off, int len)
-            throws IOException;
+        public void realWriteBytes(byte cbuf[], int off, int len) throws IOException;
+
 
         /**
-         * Send the bytes ( usually the internal conversion buffer ).
-         * Expect 8k output if the buffer is full.
+         * Send the bytes ( usually the internal conversion buffer ). Expect 8k
+         * output if the buffer is full.
          *
          * @param from bytes that will be written
          * @throws IOException If an I/O occurs while writing the bytes
@@ -113,33 +116,35 @@ public final class ByteChunk implements Cloneable, Serializable {
 
     // --------------------
 
-    /** Default encoding used to convert to strings. It should be UTF8,
-        as most standards seem to converge, but the servlet API requires
-        8859_1, and this object is used mostly for servlets.
-    */
+    /**
+     * Default encoding used to convert to strings. It should be UTF8, as most
+     * standards seem to converge, but the servlet API requires 8859_1, and this
+     * object is used mostly for servlets.
+     */
     public static final Charset DEFAULT_CHARSET = StandardCharsets.ISO_8859_1;
 
-    private int hashCode=0;
+    private int hashCode = 0;
     // did we compute the hashcode ?
     private boolean hasHashCode = false;
 
     // byte[]
     private byte[] buff;
 
-    private int start=0;
+    private int start = 0;
     private int end;
 
     private transient Charset charset;
 
-    private boolean isSet=false; // XXX
+    private boolean isSet = false; // XXX
 
     // How much can it grow, when data is added
-    private int limit=-1;
+    private int limit = -1;
 
     // transient as serialization is primarily for values via, e.g. JMX
     private transient ByteInputChannel in = null;
     private transient ByteOutputChannel out = null;
 
+
     /**
      * Creates a new, uninitialized ByteChunk object.
      */
@@ -147,8 +152,9 @@ public final class ByteChunk implements Cloneable, Serializable {
         // NO-OP
     }
 
-    public ByteChunk( int initial ) {
-        allocate( initial, -1 );
+
+    public ByteChunk(int initial) {
+        allocate(initial, -1);
     }
 
 
@@ -169,34 +175,38 @@ public final class ByteChunk implements Cloneable, Serializable {
         return super.clone();
     }
 
+
     public boolean isNull() {
-        return ! isSet; // buff==null;
+        return !isSet; // buff==null;
     }
 
+
     /**
      * Resets the message buff to an uninitialized state.
      */
     public void recycle() {
-        charset=null;
-        start=0;
-        end=0;
-        isSet=false;
+        charset = null;
+        start = 0;
+        end = 0;
+        isSet = false;
         hasHashCode = false;
     }
 
+
     // -------------------- Setup --------------------
 
-    public void allocate( int initial, int limit  ) {
-        if( buff==null || buff.length < initial ) {
-            buff=new byte[initial];
+    public void allocate(int initial, int limit) {
+        if (buff == null || buff.length < initial) {
+            buff = new byte[initial];
         }
-        this.limit=limit;
-        start=0;
-        end=0;
-        isSet=true;
+        this.limit = limit;
+        start = 0;
+        end = 0;
+        isSet = true;
         hasHashCode = false;
     }
 
+
     /**
      * Sets the message bytes to the specified subarray of bytes.
      *
@@ -207,15 +217,17 @@ public final class ByteChunk implements Cloneable, Serializable {
     public void setBytes(byte[] b, int off, int len) {
         buff = b;
         start = off;
-        end = start+ len;
-        isSet=true;
+        end = start + len;
+        isSet = true;
         hasHashCode = false;
     }
 
+
     public void setCharset(Charset charset) {
         this.charset = charset;
     }
 
+
     public Charset getCharset() {
         if (charset == null) {
             charset = DEFAULT_CHARSET;
@@ -223,6 +235,7 @@ public final class ByteChunk implements Cloneable, Serializable {
         return charset;
     }
 
+
     /**
      * @return the message bytes.
      */
@@ -230,6 +243,7 @@ public final class ByteChunk implements Cloneable, Serializable {
         return getBuffer();
     }
 
+
     /**
      * @return the message bytes.
      */
@@ -237,95 +251,107 @@ public final class ByteChunk implements Cloneable, Serializable {
         return buff;
     }
 
+
     /**
-     * @return the start offset of the bytes.
-     * For output this is the end of the buffer.
+     * @return the start offset of the bytes. For output this is the end of the
+     *         buffer.
      */
     public int getStart() {
         return start;
     }
 
+
     public int getOffset() {
         return start;
     }
 
+
     public void setOffset(int off) {
-        if (end < off ) {
-            end=off;
+        if (end < off) {
+            end = off;
         }
-        start=off;
+        start = off;
     }
 
+
     /**
      * @return the length of the bytes.
      */
     public int getLength() {
-        return end-start;
+        return end - start;
     }
 
+
     /**
-     * Maximum amount of data in this buffer.
-     * If -1 or not set, the buffer will grow indefinitely.
-     * Can be smaller than the current buffer size ( which will not shrink ).
-     * When the limit is reached, the buffer will be flushed ( if out is set )
-     * or throw exception.
+     * Maximum amount of data in this buffer. If -1 or not set, the buffer will
+     * grow indefinitely. Can be smaller than the current buffer size ( which
+     * will not shrink ). When the limit is reached, the buffer will be flushed
+     * ( if out is set ) or throw exception.
+     *
      * @param limit The new limit
      */
     public void setLimit(int limit) {
-        this.limit=limit;
+        this.limit = limit;
     }
 
+
     public int getLimit() {
         return limit;
     }
 
+
     /**
      * When the buffer is empty, read the data from the input channel.
+     *
      * @param in The input channel
      */
     public void setByteInputChannel(ByteInputChannel in) {
         this.in = in;
     }
 
+
     /**
-     * When the buffer is full, write the data to the output channel.
-     * Also used when large amount of data is appended.
-     * If not set, the buffer will grow to the limit.
+     * When the buffer is full, write the data to the output channel. Also used
+     * when large amount of data is appended. If not set, the buffer will grow
+     * to the limit.
+     *
      * @param out The output channel
      */
     public void setByteOutputChannel(ByteOutputChannel out) {
-        this.out=out;
+        this.out = out;
     }
 
+
     public int getEnd() {
         return end;
     }
 
-    public void setEnd( int i ) {
-        end=i;
+
+    public void setEnd(int i) {
+        end = i;
     }
 
+
     // -------------------- Adding data to the buffer --------------------
-    public void append( byte b )
-        throws IOException
-    {
-        makeSpace( 1 );
+    public void append(byte b) throws IOException {
+        makeSpace(1);
 
         // couldn't make space
-        if( limit >0 && end >= limit ) {
+        if (limit > 0 && end >= limit) {
             flushBuffer();
         }
-        buff[end++]=b;
+        buff[end++] = b;
     }
 
-    public void append( ByteChunk src )
-        throws IOException
-    {
-        append( src.getBytes(), src.getStart(), src.getLength());
+
+    public void append(ByteChunk src) throws IOException {
+        append(src.getBytes(), src.getStart(), src.getLength());
     }
 
+
     /**
      * Add data to the buffer.
+     *
      * @param src Bytes array
      * @param off Offset
      * @param len Length
@@ -333,13 +359,13 @@ public final class ByteChunk implements Cloneable, Serializable {
      */
     public void append(byte src[], int off, int len) throws IOException {
         // will grow, up to limit
-        makeSpace( len );
+        makeSpace(len);
 
         // if we don't have limit: makeSpace can grow as it wants
-        if( limit < 0 ) {
+        if (limit < 0) {
             // assert: makeSpace made enough space
-            System.arraycopy( src, off, buff, end, len );
-            end+=len;
+            System.arraycopy(src, off, buff, end, len);
+            end += len;
             return;
         }
 
@@ -347,16 +373,16 @@ public final class ByteChunk implements Cloneable, Serializable {
         // If the buffer is empty and the source is going to fill up all the
         // space in buffer, may as well write it directly to the output,
         // and avoid an extra copy
-        if ( len == limit && end == start && out != null ) {
-            out.realWriteBytes( src, off, len );
+        if (len == limit && end == start && out != null) {
+            out.realWriteBytes(src, off, len);
             return;
         }
         // if we have limit and we're below
-        if( len <= limit - end ) {
+        if (len <= limit - end) {
             // makeSpace will grow the buffer to the limit,
             // so we have space
-            System.arraycopy( src, off, buff, end, len );
-            end+=len;
+            System.arraycopy(src, off, buff, end, len);
+            end += len;
             return;
         }
 
@@ -368,7 +394,7 @@ public final class ByteChunk implements Cloneable, Serializable {
         // We chunk the data into slices fitting in the buffer limit, although
         // if the data is written directly if it doesn't fit
 
-        int avail=limit-end;
+        int avail = limit - end;
         System.arraycopy(src, off, buff, end, avail);
         end += avail;
 
@@ -377,7 +403,7 @@ public final class ByteChunk implements Cloneable, Serializable {
         int remain = len - avail;
 
         while (remain > (limit - end)) {
-            out.realWriteBytes( src, (off + len) - remain, limit - end );
+            out.realWriteBytes(src, (off + len) - remain, limit - end);
             remain = remain - (limit - end);
         }
 
@@ -473,7 +499,7 @@ public final class ByteChunk implements Cloneable, Serializable {
     }
 
 
-    public int substract(byte dest[], int off, int len ) throws IOException {
+    public int substract(byte dest[], int off, int len) throws IOException {
         if (checkEof()) {
             return -1;
         }
@@ -490,8 +516,8 @@ public final class ByteChunk implements Cloneable, Serializable {
     /**
      * Transfers bytes from the buffer to the specified ByteBuffer. After the
      * operation the position of the ByteBuffer will be returned to the one
-     * before the operation, the limit will be the position incremented by
-     * the number of the transfered bytes.
+     * before the operation, the limit will be the position incremented by the
+     * number of the transfered bytes.
      *
      * @param to the ByteBuffer into which bytes are to be written.
      * @return an integer specifying the actual number of bytes read, or -1 if
@@ -531,24 +557,21 @@ public final class ByteChunk implements Cloneable, Serializable {
      *
      * @throws IOException Writing overflow data to the output channel failed
      */
-    public void flushBuffer()
-        throws IOException
-    {
-        //assert out!=null
-        if( out==null ) {
-            throw new IOException( "Buffer overflow, no sink " + limit + " " +
-                                   buff.length  );
+    public void flushBuffer() throws IOException {
+        // assert out!=null
+        if (out == null) {
+            throw new IOException("Buffer overflow, no sink " + limit + " " + buff.length);
         }
-        out.realWriteBytes( buff, start, end-start );
-        end=start;
+        out.realWriteBytes(buff, start, end - start);
+        end = start;
     }
 
+
     /**
      * Make space for len bytes. If len is small, allocate a reserve space too.
      * Never grow bigger than limit.
      *
-     * @param count
-     *            The size
+     * @param count The size
      */
     public void makeSpace(int count) {
         byte[] tmp = null;
@@ -592,18 +615,20 @@ public final class ByteChunk implements Cloneable, Serializable {
         start = 0;
     }
 
+
     // -------------------- Conversion and getters --------------------
 
     @Override
     public String toString() {
         if (null == buff) {
             return null;
-        } else if (end-start == 0) {
+        } else if (end - start == 0) {
             return "";
         }
         return StringCache.toString(this);
     }
 
+
     public String toStringInternal() {
         if (charset == null) {
             charset = DEFAULT_CHARSET;
@@ -611,12 +636,13 @@ public final class ByteChunk implements Cloneable, Serializable {
         // new String(byte[], int, int, Charset) takes a defensive copy of the
         // entire byte array. This is expensive if only a small subset of the
         // bytes will be used. The code below is from Apache Harmony.
-        CharBuffer cb = charset.decode(ByteBuffer.wrap(buff, start, end-start));
+        CharBuffer cb = charset.decode(ByteBuffer.wrap(buff, start, end - start));
         return new String(cb.array(), cb.arrayOffset(), cb.length());
     }
 
+
     public long getLong() {
-        return Ascii.parseLong(buff, start,end-start);
+        return Ascii.parseLong(buff, start, end - start);
     }
 
 
@@ -630,8 +656,10 @@ public final class ByteChunk implements Cloneable, Serializable {
         return false;
     }
 
+
     /**
      * Compares the message bytes to the specified String object.
+     *
      * @param s the String to compare
      * @return true if the comparison succeeded, false otherwise
      */
@@ -640,7 +668,7 @@ public final class ByteChunk implements Cloneable, Serializable {
         // ( ok for tomcat, where we compare ascii - header names, etc )!!!
 
         byte[] b = buff;
-        int blen = end-start;
+        int blen = end - start;
         if (b == null || blen != s.length()) {
             return false;
         }
@@ -653,14 +681,16 @@ public final class ByteChunk implements Cloneable, Serializable {
         return true;
     }
 
+
     /**
      * Compares the message bytes to the specified String object.
+     *
      * @param s the String to compare
      * @return true if the comparison succeeded, false otherwise
      */
     public boolean equalsIgnoreCase(String s) {
         byte[] b = buff;
-        int blen = end-start;
+        int blen = end - start;
         if (b == null || blen != s.length()) {
             return false;
         }
@@ -673,24 +703,26 @@ public final class ByteChunk implements Cloneable, Serializable {
         return true;
     }
 
-    public boolean equals( ByteChunk bb ) {
-        return equals( bb.getBytes(), bb.getStart(), bb.getLength());
+
+    public boolean equals(ByteChunk bb) {
+        return equals(bb.getBytes(), bb.getStart(), bb.getLength());
     }
 
-    public boolean equals( byte b2[], int off2, int len2) {
-        byte b1[]=buff;
-        if( b1==null && b2==null ) {
+
+    public boolean equals(byte b2[], int off2, int len2) {
+        byte b1[] = buff;
+        if (b1 == null && b2 == null) {
             return true;
         }
 
-        int len=end-start;
-        if ( len2 != len || b1==null || b2==null ) {
+        int len = end - start;
+        if (len2 != len || b1 == null || b2 == null) {
             return false;
         }
 
         int off1 = start;
 
-        while ( len-- > 0) {
+        while (len-- > 0) {
             if (b1[off1++] != b2[off2++]) {
                 return false;
             }
@@ -698,33 +730,37 @@ public final class ByteChunk implements Cloneable, Serializable {
         return true;
     }
 
-    public boolean equals( CharChunk cc ) {
-        return equals( cc.getChars(), cc.getStart(), cc.getLength());
+
+    public boolean equals(CharChunk cc) {
+        return equals(cc.getChars(), cc.getStart(), cc.getLength());
     }
 
-    public boolean equals( char c2[], int off2, int len2) {
+
+    public boolean equals(char c2[], int off2, int len2) {
         // XXX works only for enc compatible with ASCII/UTF !!!
-        byte b1[]=buff;
-        if( c2==null && b1==null ) {
+        byte b1[] = buff;
+        if (c2 == null && b1 == null) {
             return true;
         }
 
-        if (b1== null || c2==null || end-start != len2 ) {
+        if (b1 == null || c2 == null || end - start != len2) {
             return false;
         }
         int off1 = start;
-        int len=end-start;
+        int len = end - start;
 
-        while ( len-- > 0) {
-            if ( (char)b1[off1++] != c2[off2++]) {
+        while (len-- > 0) {
+            if ((char) b1[off1++] != c2[off2++]) {
                 return false;
             }
         }
         return true;
     }
 
+
     /**
      * Returns true if the message bytes starts with the specified string.
+     *
      * @param s the string
      * @param pos The position
      * @return <code>true</code> if the start matches
@@ -732,42 +768,43 @@ public final class ByteChunk implements Cloneable, Serializable {
     public boolean startsWithIgnoreCase(String s, int pos) {
         byte[] b = buff;
         int len = s.length();
-        if (b == null || len+pos > end-start) {
+        if (b == null || len + pos > end - start) {
             return false;
         }
-        int off = start+pos;
+        int off = start + pos;
         for (int i = 0; i < len; i++) {
-            if (Ascii.toLower( b[off++] ) != Ascii.toLower( s.charAt(i))) {
+            if (Ascii.toLower(b[off++]) != Ascii.toLower(s.charAt(i))) {
                 return false;
             }
         }
         return true;
     }
 
-    public int indexOf( String src, int srcOff, int srcLen, int myOff ) {
-        char first=src.charAt( srcOff );
+
+    public int indexOf(String src, int srcOff, int srcLen, int myOff) {
+        char first = src.charAt(srcOff);
 
         // Look for first char
         int srcEnd = srcOff + srcLen;
 
-        mainLoop:
-        for( int i=myOff+start; i <= (end - srcLen); i++ ) {
-            if( buff[i] != first ) {
+        mainLoop: for (int i = myOff + start; i <= (end - srcLen); i++) {
+            if (buff[i] != first) {
                 continue;
             }
             // found first char, now look for a match
-            int myPos=i+1;
-            for( int srcPos=srcOff + 1; srcPos< srcEnd;) {
-                if( buff[myPos++] != src.charAt( srcPos++ )) {
+            int myPos = i + 1;
+            for (int srcPos = srcOff + 1; srcPos < srcEnd;) {
+                if (buff[myPos++] != src.charAt(srcPos++)) {
                     continue mainLoop;
                 }
             }
-            return i-start; // found it
+            return i - start; // found it
         }
         return -1;
     }
 
-    // -------------------- Hash code  --------------------
+
+    // -------------------- Hash code --------------------
 
     @Override
     public int hashCode() {
@@ -782,32 +819,34 @@ public final class ByteChunk implements Cloneable, Serializable {
         return code;
     }
 
+
     // normal hash.
     public int hash() {
-        return hashBytes( buff, start, end-start);
+        return hashBytes(buff, start, end - start);
     }
 
-    private static int hashBytes( byte buff[], int start, int bytesLen ) {
-        int max=start+bytesLen;
-        byte bb[]=buff;
-        int code=0;
-        for (int i = start; i < max ; i++) {
+
+    private static int hashBytes(byte buff[], int start, int bytesLen) {
+        int max = start + bytesLen;
+        byte bb[] = buff;
+        int code = 0;
+        for (int i = start; i < max; i++) {
             code = code * 37 + bb[i];
         }
         return code;
     }
 
+
     /**
      * Returns the first instance of the given character in this ByteChunk
      * starting at the specified byte. If the character is not found, -1 is
-     * returned.
-     * <br>
+     * returned. <br>
      * NOTE: This only works for characters in the range 0-127.
      *
-     * @param c         The character
-     * @param starting  The start position
-     * @return          The position of the first instance of the character or
-     *                      -1 if the character is not found.
+     * @param c The character
+     * @param starting The start position
+     * @return The position of the first instance of the character or -1 if the
+     *         character is not found.
      */
     public int indexOf(char c, int starting) {
         int ret = indexOf(buff, start + starting, end, c);
@@ -817,22 +856,21 @@ public final class ByteChunk implements Cloneable, Serializable {
 
     /**
      * Returns the first instance of the given character in the given byte array
-     * between the specified start and end.
-     * <br>
+     * between the specified start and end. <br>
      * NOTE: This only works for characters in the range 0-127.
      *
      * @param bytes The byte array to search
      * @param start The point to start searching from in the byte array
-     * @param end   The point to stop searching in the byte array
-     * @param c     The character to search for
-     * @return      The position of the first instance of the character or -1
-     *                  if the character is not found.
+     * @param end The point to stop searching in the byte array
+     * @param c The character to search for
+     * @return The position of the first instance of the character or -1 if the
+     *         character is not found.
      */
     public static int indexOf(byte bytes[], int start, int end, char c) {
         int offset = start;
 
         while (offset < end) {
-            byte b=bytes[offset];
+            byte b = bytes[offset];
             if (b == c) {
                 return offset;
             }
@@ -841,16 +879,17 @@ public final class ByteChunk implements Cloneable, Serializable {
         return -1;
     }
 
+
     /**
      * Returns the first instance of the given byte in the byte array between
      * the specified start and end.
      *
      * @param bytes The byte array to search
      * @param start The point to start searching from in the byte array
-     * @param end   The point to stop searching in the byte array
-     * @param b     The byte to search for
-     * @return      The position of the first instance of the byte or -1 if the
-     *                  byte is not found.
+     * @param end The point to stop searching in the byte array
+     * @param b The byte to search for
+     * @return The position of the first instance of the byte or -1 if the byte
+     *         is not found.
      */
     public static int findByte(byte bytes[], int start, int end, byte b) {
         int offset = start;
@@ -863,22 +902,23 @@ public final class ByteChunk implements Cloneable, Serializable {
         return -1;
     }
 
+
     /**
      * Returns the first instance of any of the given bytes in the byte array
      * between the specified start and end.
      *
      * @param bytes The byte array to search
      * @param start The point to start searching from in the byte array
-     * @param end   The point to stop searching in the byte array
-     * @param b     The array of bytes to search for
-     * @return      The position of the first instance of the byte or -1 if the
-     *                  byte is not found.
+     * @param end The point to stop searching in the byte array
+     * @param b The array of bytes to search for
+     * @return The position of the first instance of the byte or -1 if the byte
+     *         is not found.
      */
     public static int findBytes(byte bytes[], int start, int end, byte b[]) {
         int blen = b.length;
         int offset = start;
         while (offset < end) {
-            for (int i = 0;  i < blen; i++) {
+            for (int i = 0; i < blen; i++) {
                 if (bytes[offset] == b[i]) {
                     return offset;
                 }
@@ -888,6 +928,7 @@ public final class ByteChunk implements Cloneable, Serializable {
         return -1;
     }
 
+
     /**
      * Convert specified String to a byte array. This ONLY WORKS for ascii, UTF
      * chars will be truncated.

==================================================
