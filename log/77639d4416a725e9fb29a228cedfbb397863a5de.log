77639d4416a725e9fb29a228cedfbb397863a5de
==================================================
Fix handling of nested lambda expressions with method parameters.
==================================================
Mark Emlyn
==================================================
Tue Jul 16 20:01:47 2013 +0000
==================================================
LambdaExpression.java
Fix handling of nested lambda expressions with method parameters.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1503857 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AstLambdaExpression.java
index 5ea680d689..4788377bbf 100644
--- a/java/javax/el/LambdaExpression.java
+++ b/java/javax/el/LambdaExpression.java
@@ -24,12 +24,14 @@ public class LambdaExpression {
 
     private final List<String> formalParameters;
     private final ValueExpression expression;
+    private final Map<String,Object> nestedArguments = new HashMap<>();
     private ELContext context = null;
 
     public LambdaExpression(List<String> formalParameters,
             ValueExpression expression) {
         this.formalParameters = formalParameters;
         this.expression = expression;
+
     }
 
     public void setELContext(ELContext context) {
@@ -62,7 +64,10 @@ public class LambdaExpression {
         }
 
         // Build the argument map
+        // Start with the arguments from any outer expressions so if there is
+        // any overlap the local arguments have priority
         Map<String,Object> lambdaArguments = new HashMap<>();
+        lambdaArguments.putAll(nestedArguments);
         for (int i = 0; i < formalParamCount; i++) {
             lambdaArguments.put(formalParameters.get(i), args[i]);
         }
@@ -70,7 +75,14 @@ public class LambdaExpression {
         context.enterLambdaScope(lambdaArguments);
 
         try {
-            return expression.getValue(context);
+            Object result = expression.getValue(context);
+            // Make arguments from this expression available to any nested
+            // expression
+            if (result instanceof LambdaExpression) {
+                ((LambdaExpression) result).nestedArguments.putAll(
+                        lambdaArguments);
+            }
+            return result;
         } finally {
             context.exitLambdaScope();
         }

==================================================
AstLambdaExpressionOrInvocation.java
index f0775832a9..25a930077b 100644
--- a/java/org/apache/el/parser/AstLambdaExpression.java
+++ b/java/org/apache/el/parser/AstLambdaExpression.java
@@ -35,11 +35,15 @@ public class AstLambdaExpression extends SimpleNode {
     @Override
     public Object getValue(EvaluationContext ctx) throws ELException {
 
-        // Two children - the formal parameters and the expression
+        // First child is always parameters even if there aren't any
         AstLambdaParameters formalParametersNode =
                 (AstLambdaParameters) children[0];
         Node[] formalParamNodes = formalParametersNode.children;
 
+        // Second child is a value expression
+        ValueExpressionImpl ve = new ValueExpressionImpl("", children[1],
+                ctx.getFunctionMapper(), ctx.getVariableMapper(), null);
+
         // Build a LambdaExpression
         List<String> formalParameters = new ArrayList<>();
         if (formalParamNodes != null) {
@@ -47,30 +51,29 @@ public class AstLambdaExpression extends SimpleNode {
                 formalParameters.add(formalParamNode.getImage());
             }
         }
-
-        ValueExpressionImpl ve = new ValueExpressionImpl("", children[1],
-                ctx.getFunctionMapper(), ctx.getVariableMapper(), null);
         LambdaExpression le = new LambdaExpression(formalParameters, ve);
         le.setELContext(ctx);
 
         if (formalParameters.isEmpty()) {
-            // No formal parameters - should be able to simply invoke this
+            // No formal parameters - invoke the expression
             return le.invoke(ctx, (Object[]) null);
-        } else {
-            // Has parameters but they aren't provided so return the
-            // LambdaExpression
-            return le;
         }
-    }
 
-    @Override
-    public Object invoke(EvaluationContext ctx, Class<?>[] paramTypes,
-            Object[] paramValues) throws ELException {
-
-        Object result = getValue(ctx);
+        // If there are method parameters, need to invoke the expression with
+        // those parameters. If there are multiple method parameters there
+        // should be that many nested expressions.
+        // If there are more nested expressions that parameters this will return
+        // a LambdaExpression
+        Object result = le;
+        int i = 2;
+        while (result instanceof LambdaExpression && i < jjtGetNumChildren()) {
+            result = ((LambdaExpression) result).invoke(
+                    ((AstMethodParameters) children[i]).getParameters(ctx));
+            i++;
+        }
 
-        if (result instanceof LambdaExpression) {
-            result = ((LambdaExpression) result).invoke(ctx, paramValues);
+        if (i < jjtGetNumChildren()) {
+            throw new ELException();
         }
 
         return result;

==================================================
ELParser.java
deleted file mode 100644
index 0c139124f8..0000000000
--- a/java/org/apache/el/parser/AstLambdaExpressionOrInvocation.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/* Generated By:JJTree: Do not edit this line. AstLambdaExpressionOrInvocation.java Version 4.3 */
-package org.apache.el.parser;
-
-import javax.el.ELException;
-
-import org.apache.el.lang.EvaluationContext;
-
-public class AstLambdaExpressionOrInvocation extends SimpleNode {
-
-    public AstLambdaExpressionOrInvocation(int id) {
-        super(id);
-    }
-
-    @Override
-    public Object getValue(EvaluationContext ctx) throws ELException {
-
-        AstLambdaExpression lambdaExpression =
-                (AstLambdaExpression) children[0];
-
-        Object[] args;
-        if (children.length == 2) {
-            args = ((AstMethodParameters) children[1]).getParameters(ctx);
-        } else {
-            // No parameters. AstLambdaExpression contains the logic to handle
-            // this in getValue()
-            return lambdaExpression.getValue(ctx);
-        }
-        return lambdaExpression.invoke(ctx, null, args);
-    }
-}
-/* JavaCC - OriginalChecksum=6b3dd15b31540457a41bd55974037ed9 (do not edit this line) */

==================================================
ELParserTreeConstants.java
index c4c1fec6aa..5daa9dd3fc 100644
--- a/java/org/apache/el/parser/ELParser.jjt
+++ b/java/org/apache/el/parser/ELParser.jjt
@@ -136,9 +136,14 @@ void LambdaParameters() #LambdaParameters : {}
  * Possible invocation of lambda expression. Invocations must be bracketed but
  * being bracketed does not mean it is an invocation.
  */
-void LambdaExpressionOrInvocation() #LambdaExpressionOrInvocation : {}
-{
-    <LPAREN> LambdaExpression() <RPAREN> ( MethodParameters() )*
+void LambdaExpressionOrInvocation() #LambdaExpression : {}
+{
+    <LPAREN> 
+        LambdaParameters()
+        <ARROW>
+        ( LOOKAHEAD(3) LambdaExpression() | Choice() )
+    <RPAREN>
+    ( MethodParameters() )*
 }
 
 /*

==================================================
TestAstLambdaExpression.java
index 5ed200e4e6..8afe6fa9d2 100644
--- a/java/org/apache/el/parser/ELParserTreeConstants.java
+++ b/java/org/apache/el/parser/ELParserTreeConstants.java
@@ -12,41 +12,40 @@ public interface ELParserTreeConstants
   public int JJTASSIGN = 6;
   public int JJTLAMBDAEXPRESSION = 7;
   public int JJTLAMBDAPARAMETERS = 8;
-  public int JJTLAMBDAEXPRESSIONORINVOCATION = 9;
-  public int JJTCHOICE = 10;
-  public int JJTOR = 11;
-  public int JJTAND = 12;
-  public int JJTEQUAL = 13;
-  public int JJTNOTEQUAL = 14;
-  public int JJTLESSTHAN = 15;
-  public int JJTGREATERTHAN = 16;
-  public int JJTLESSTHANEQUAL = 17;
-  public int JJTGREATERTHANEQUAL = 18;
-  public int JJTCONCATENATION = 19;
-  public int JJTPLUS = 20;
-  public int JJTMINUS = 21;
-  public int JJTMULT = 22;
-  public int JJTDIV = 23;
-  public int JJTMOD = 24;
-  public int JJTNEGATIVE = 25;
-  public int JJTNOT = 26;
-  public int JJTEMPTY = 27;
-  public int JJTVALUE = 28;
-  public int JJTDOTSUFFIX = 29;
-  public int JJTBRACKETSUFFIX = 30;
-  public int JJTMETHODPARAMETERS = 31;
-  public int JJTSETDATA = 32;
-  public int JJTLISTDATA = 33;
-  public int JJTMAPDATA = 34;
-  public int JJTMAPENTRY = 35;
-  public int JJTIDENTIFIER = 36;
-  public int JJTFUNCTION = 37;
-  public int JJTTRUE = 38;
-  public int JJTFALSE = 39;
-  public int JJTFLOATINGPOINT = 40;
-  public int JJTINTEGER = 41;
-  public int JJTSTRING = 42;
-  public int JJTNULL = 43;
+  public int JJTCHOICE = 9;
+  public int JJTOR = 10;
+  public int JJTAND = 11;
+  public int JJTEQUAL = 12;
+  public int JJTNOTEQUAL = 13;
+  public int JJTLESSTHAN = 14;
+  public int JJTGREATERTHAN = 15;
+  public int JJTLESSTHANEQUAL = 16;
+  public int JJTGREATERTHANEQUAL = 17;
+  public int JJTCONCATENATION = 18;
+  public int JJTPLUS = 19;
+  public int JJTMINUS = 20;
+  public int JJTMULT = 21;
+  public int JJTDIV = 22;
+  public int JJTMOD = 23;
+  public int JJTNEGATIVE = 24;
+  public int JJTNOT = 25;
+  public int JJTEMPTY = 26;
+  public int JJTVALUE = 27;
+  public int JJTDOTSUFFIX = 28;
+  public int JJTBRACKETSUFFIX = 29;
+  public int JJTMETHODPARAMETERS = 30;
+  public int JJTSETDATA = 31;
+  public int JJTLISTDATA = 32;
+  public int JJTMAPDATA = 33;
+  public int JJTMAPENTRY = 34;
+  public int JJTIDENTIFIER = 35;
+  public int JJTFUNCTION = 36;
+  public int JJTTRUE = 37;
+  public int JJTFALSE = 38;
+  public int JJTFLOATINGPOINT = 39;
+  public int JJTINTEGER = 40;
+  public int JJTSTRING = 41;
+  public int JJTNULL = 42;
 
 
   public String[] jjtNodeName = {
@@ -59,7 +58,6 @@ public interface ELParserTreeConstants
     "Assign",
     "LambdaExpression",
     "LambdaParameters",
-    "LambdaExpressionOrInvocation",
     "Choice",
     "Or",
     "And",
@@ -96,4 +94,4 @@ public interface ELParserTreeConstants
     "Null",
   };
 }
-/* JavaCC - OriginalChecksum=23b494fccd3ecfb960d2779462d5457d (do not edit this line) */
+/* JavaCC - OriginalChecksum=96680d397165a1214a1ad1f24011d5c1 (do not edit this line) */

==================================================
