775d5fa422c231f9de36d6cc0aabd9a0e5d5feab
==================================================
Resolve a FIXME and expand unit tests to cover CRLF vs LF checking.
==================================================
Mark Emlyn
==================================================
Wed Aug 29 20:21:01 2012 +0000
==================================================
ChunkedInputFilter.java
Resolve a FIXME and expand unit tests to cover CRLF vs LF checking.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1378699 13f79535-47bb-0310-9956-ffa450edef68



==================================================
SimpleHttpClient.java
index 05d3d7ef22..dc94f8a5ef 100644
--- a/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/ChunkedInputFilter.java
@@ -144,7 +144,7 @@ public class ChunkedInputFilter implements InputFilter {
 
         if(needCRLFParse) {
             needCRLFParse = false;
-            parseCRLF();
+            parseCRLF(false);
         }
 
         if (remaining <= 0) {
@@ -179,7 +179,7 @@ public class ChunkedInputFilter implements InputFilter {
                 //so we defer it to the next call BZ 11117
                 needCRLFParse = true;
             } else {
-                parseCRLF(); //parse the CRLF immediately
+                parseCRLF(false); //parse the CRLF immediately
             }
         }
 
@@ -305,9 +305,8 @@ public class ChunkedInputFilter implements InputFilter {
                     return false;
             }
 
-            if (buf[pos] == Constants.CR) {
-                // FIXME: Improve parsing to check for CRLF
-            } else if (buf[pos] == Constants.LF) {
+            if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) {
+                parseCRLF(false);
                 eol = true;
             } else if (buf[pos] == Constants.SEMI_COLON) {
                 trailer = true;
@@ -325,7 +324,10 @@ public class ChunkedInputFilter implements InputFilter {
                 }
             }
 
-            pos++;
+            // Parsing the CRLF increments pos
+            if (!eol) {
+                pos++;
+            }
 
         }
 
@@ -346,9 +348,21 @@ public class ChunkedInputFilter implements InputFilter {
 
     /**
      * Parse CRLF at end of chunk.
+     * @deprecated  Use {@link #parseCRLF(boolean)}
      */
-    protected boolean parseCRLF()
-        throws IOException {
+    @Deprecated
+    protected boolean parseCRLF() throws IOException {
+        return parseCRLF(false);
+    }
+
+    /**
+     * Parse CRLF at end of chunk.
+     *
+     * @param   tolerant    Should tolerant parsing (LF and CRLF) be used? This
+     *                      is recommended (RFC2616, section 19.3) for message
+     *                      headers.
+     */
+    protected boolean parseCRLF(boolean tolerant) throws IOException {
 
         boolean eol = false;
         boolean crfound = false;
@@ -364,7 +378,9 @@ public class ChunkedInputFilter implements InputFilter {
                 if (crfound) throw new IOException("Invalid CRLF, two CR characters encountered.");
                 crfound = true;
             } else if (buf[pos] == Constants.LF) {
-                if (!crfound) throw new IOException("Invalid CRLF, no CR character encountered.");
+                if (!tolerant && !crfound) {
+                    throw new IOException("Invalid CRLF, no CR character encountered.");
+                }
                 eol = true;
             } else {
                 throw new IOException("Invalid CRLF");
@@ -396,26 +412,19 @@ public class ChunkedInputFilter implements InputFilter {
         MimeHeaders headers = request.getMimeHeaders();
 
         byte chr = 0;
-        while (true) {
-            // Read new bytes if needed
-            if (pos >= lastValid) {
-                if (readBytes() <0)
-                    throw new EOFException("Unexpected end of stream whilst reading trailer headers for chunked request");
-            }
 
-            chr = buf[pos];
-
-            if ((chr == Constants.CR) || (chr == Constants.LF)) {
-                if (chr == Constants.LF) {
-                    pos++;
-                    return false;
-                }
-            } else {
-                break;
-            }
+        // Read new bytes if needed
+        if (pos >= lastValid) {
+            if (readBytes() <0)
+                throw new EOFException("Unexpected end of stream whilst reading trailer headers for chunked request");
+        }
 
-            pos++;
+        chr = buf[pos];
 
+        // CRLF terminates the request
+        if (chr == Constants.CR || chr == Constants.LF) {
+            parseCRLF(true);
+            return false;
         }
 
         // Mark the current buffer position
@@ -495,9 +504,8 @@ public class ChunkedInputFilter implements InputFilter {
                 }
 
                 chr = buf[pos];
-                if (chr == Constants.CR) {
-                    // Skip
-                } else if (chr == Constants.LF) {
+                if (chr == Constants.CR || chr == Constants.LF) {
+                    parseCRLF(true);
                     eol = true;
                 } else if (chr == Constants.SP) {
                     trailingHeaders.append(chr);

==================================================
TestChunkedInputFilter.java
index 0c96f0889b..b3190ebfe9 100644
--- a/test/org/apache/catalina/startup/SimpleHttpClient.java
+++ b/test/org/apache/catalina/startup/SimpleHttpClient.java
@@ -201,7 +201,13 @@ public abstract class SimpleHttpClient {
                 line = readLine();
                 while (line != null) {
                     builder.append(line);
-                    line = readLine();
+                    try {
+                        line = readLine();
+                    } catch (IOException ioe) {
+                        // The server probably closed the connection due to an
+                        // error
+                        line = null;
+                    }
                 }
             }
         }

==================================================
