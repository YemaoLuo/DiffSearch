2fcb104294b2676154cb08f00d5665d668792280
==================================================
Add support for coercing LambdaExpression to any functional interface
==================================================
Mark Thomas
==================================================
Thu Jul 8 22:02:26 2021 +0100
==================================================
ELSupport.java
index 1bf600d6d1..d9f5503c9a 100644
--- a/java/org/apache/el/LocalStrings.properties
+++ b/java/org/apache/el/LocalStrings.properties
@@ -13,6 +13,8 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+elSupport.coerce.nonAbstract=Unable to coerce a LambdaExpression to the functional interface [{0}] because the method [{1}] is not abstract
+
 # General Errors
 error.cannotSetVariables=Cannot set variables on factory
 error.convert=Cannot convert [{0}] of type [{1}] to [{2}]

==================================================
TestELSupport.java
index 808ad799ae..c37fbac488 100644
--- a/java/org/apache/el/lang/ELSupport.java
+++ b/java/org/apache/el/lang/ELSupport.java
@@ -19,6 +19,9 @@ package org.apache.el.lang;
 import java.beans.PropertyEditor;
 import java.beans.PropertyEditorManager;
 import java.lang.reflect.Array;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.Proxy;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.security.AccessController;
@@ -29,6 +32,7 @@ import java.util.Set;
 
 import jakarta.el.ELContext;
 import jakarta.el.ELException;
+import jakarta.el.LambdaExpression;
 
 import org.apache.el.util.MessageFactory;
 
@@ -588,6 +592,11 @@ public class ELSupport {
             return result;
         }
 
+        if (obj instanceof LambdaExpression && type.getAnnotation(FunctionalInterface.class) != null) {
+            T result = coerceToFunctionalInterface(ctx, (LambdaExpression) obj, type);
+            return result;
+        }
+
         throw new ELException(MessageFactory.get("error.convert",
                 obj, obj.getClass(), type));
     }
@@ -613,6 +622,24 @@ public class ELSupport {
         return result;
     }
 
+
+    private static <T> T coerceToFunctionalInterface(final ELContext ctx, final LambdaExpression lambdaExpression,
+            final Class<T> type) {
+        // Create a dynamic proxy for the functional interface
+        @SuppressWarnings("unchecked")
+        T result = (T) Proxy.newProxyInstance(type.getClassLoader(), new Class[] { type },
+                (Object obj, Method method, Object[] args) -> {
+            // Functional interfaces have a single, abstract method
+            if (!Modifier.isAbstract(method.getModifiers())) {
+                // TODO
+                throw new ELException(MessageFactory.get("elSupport.coerce.nonAbstract", type, method));
+            }
+            return lambdaExpression.invoke(ctx, args);
+        });
+        return result;
+    }
+
+
     public static final boolean isBigDecimalOp(final Object obj0,
             final Object obj1) {
         return (obj0 instanceof BigDecimal || obj1 instanceof BigDecimal);

==================================================
