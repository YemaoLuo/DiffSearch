c648adce743d573ef49eeeb4a94b4fb1013d3aa2
==================================================
Move the additional dispatches required from the SocketWrapper to the
==================================================
Mark Thomas
==================================================
Tue Oct 20 09:00:08 2015 +0000
==================================================
AbstractProcessorLight.java
Move the additional dispatches required from the SocketWrapper to the
Processor

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1709543 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractProtocol.java
index 9310f3a935..e4f6d13ff7 100644
--- a/java/org/apache/coyote/AbstractProcessorLight.java
+++ b/java/org/apache/coyote/AbstractProcessorLight.java
@@ -16,6 +16,12 @@
  */
 package org.apache.coyote;
 
+import java.util.Iterator;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
+
+import org.apache.tomcat.util.net.DispatchType;
+
 /**
  * This is a light-weight abstract processor implementation that is intended as
  * a basis for all Processor implementations from the light-weight upgrade
@@ -23,4 +29,40 @@ package org.apache.coyote;
  */
 public abstract class AbstractProcessorLight implements Processor {
 
+    private Set<DispatchType> dispatches = new CopyOnWriteArraySet<>();
+
+
+    @Override
+    public void addDispatch(DispatchType dispatchType) {
+        synchronized (dispatches) {
+            dispatches.add(dispatchType);
+        }
+    }
+
+
+    @Override
+    public Iterator<DispatchType> getIteratorAndClearDispatches() {
+        // Note: Logic in AbstractProtocol depends on this method only returning
+        // a non-null value if the iterator is non-empty. i.e. it should never
+        // return an empty iterator.
+        Iterator<DispatchType> result;
+        synchronized (dispatches) {
+            // Synchronized as the generation of the iterator and the clearing
+            // of dispatches needs to be an atomic operation.
+            result = dispatches.iterator();
+            if (result.hasNext()) {
+                dispatches.clear();
+            } else {
+                result = null;
+            }
+        }
+        return result;
+    }
+
+
+    protected void clearDispatches() {
+        synchronized (dispatches) {
+            dispatches.clear();
+        }
+    }
 }

==================================================
Processor.java
index 86e7a2160f..671f2a9c46 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -758,7 +758,7 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
                     if (dispatches == null || !dispatches.hasNext()) {
                         // Only returns non-null iterator if there are
                         // dispatches to process.
-                        dispatches = wrapper.getIteratorAndClearDispatches();
+                        dispatches = processor.getIteratorAndClearDispatches();
                     }
                 } while (state == SocketState.ASYNC_END ||
                         state == SocketState.UPGRADING ||

==================================================
AjpProcessor.java
index a75a03298b..ffabcc917a 100644
--- a/java/org/apache/coyote/Processor.java
+++ b/java/org/apache/coyote/Processor.java
@@ -18,11 +18,13 @@ package org.apache.coyote;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.Iterator;
 import java.util.concurrent.Executor;
 
 import javax.servlet.http.HttpUpgradeHandler;
 
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
+import org.apache.tomcat.util.net.DispatchType;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapperBase;
@@ -96,4 +98,8 @@ public interface Processor {
      * an existing multiplexed connection.
      */
     void pause();
+
+    void addDispatch(DispatchType dispatchType);
+
+    Iterator<DispatchType> getIteratorAndClearDispatches();
 }

==================================================
Http11Processor.java
index 96a3424f5e..60f4aff32a 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -483,7 +483,7 @@ public class AjpProcessor extends AbstractProcessor {
             break;
         }
         case ASYNC_COMPLETE: {
-            socketWrapper.clearDispatches();
+            clearDispatches();
             if (asyncStateMachine.asyncComplete()) {
                 socketWrapper.processSocket(SocketStatus.OPEN_READ, true);
             }
@@ -573,15 +573,15 @@ public class AjpProcessor extends AbstractProcessor {
             break;
         }
         case DISPATCH_READ: {
-            socketWrapper.addDispatch(DispatchType.NON_BLOCKING_READ);
+            addDispatch(DispatchType.NON_BLOCKING_READ);
             break;
         }
         case DISPATCH_WRITE: {
-            socketWrapper.addDispatch(DispatchType.NON_BLOCKING_WRITE);
+            addDispatch(DispatchType.NON_BLOCKING_WRITE);
             break;
         }
         case DISPATCH_EXECUTE: {
-            socketWrapper.executeNonBlockingDispatches();
+            socketWrapper.executeNonBlockingDispatches(getIteratorAndClearDispatches());
             break;
         }
         case CLOSE_NOW: {

==================================================
UpgradeProcessorExternal.java
index 51fc29e03f..2bfe798278 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -731,7 +731,7 @@ public class Http11Processor extends AbstractProcessor {
             break;
         }
         case ASYNC_COMPLETE: {
-            socketWrapper.clearDispatches();
+            clearDispatches();
             if (asyncStateMachine.asyncComplete()) {
                 socketWrapper.processSocket(SocketStatus.OPEN_READ, true);
             }
@@ -776,17 +776,17 @@ public class Http11Processor extends AbstractProcessor {
             break;
         }
         case DISPATCH_READ: {
-            socketWrapper.addDispatch(DispatchType.NON_BLOCKING_READ);
+            addDispatch(DispatchType.NON_BLOCKING_READ);
             break;
         }
         case DISPATCH_WRITE: {
-            socketWrapper.addDispatch(DispatchType.NON_BLOCKING_WRITE);
+            addDispatch(DispatchType.NON_BLOCKING_WRITE);
             break;
         }
         case DISPATCH_EXECUTE: {
             SocketWrapperBase<?> wrapper = socketWrapper;
             if (wrapper != null) {
-                wrapper.executeNonBlockingDispatches();
+                wrapper.executeNonBlockingDispatches(getIteratorAndClearDispatches());
             }
             break;
         }

==================================================
UpgradeServletInputStream.java
index dbe68a82e0..68ed98e4da 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeProcessorExternal.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeProcessorExternal.java
@@ -43,8 +43,8 @@ public class UpgradeProcessorExternal extends UpgradeProcessorBase {
     public UpgradeProcessorExternal(SocketWrapperBase<?> wrapper, ByteBuffer leftOverInput,
             HttpUpgradeHandler httpUpgradeHandler) {
         super(wrapper, leftOverInput, httpUpgradeHandler);
-        this.upgradeServletInputStream = new UpgradeServletInputStream(wrapper);
-        this.upgradeServletOutputStream = new UpgradeServletOutputStream(wrapper);
+        this.upgradeServletInputStream = new UpgradeServletInputStream(this, wrapper);
+        this.upgradeServletOutputStream = new UpgradeServletOutputStream(this, wrapper);
 
         wrapper.unRead(leftOverInput);
         /*

==================================================
UpgradeServletOutputStream.java
index c51ac50b50..db057a9a61 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeServletInputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeServletInputStream.java
@@ -22,6 +22,7 @@ import javax.servlet.ReadListener;
 import javax.servlet.ServletInputStream;
 
 import org.apache.coyote.ContainerThreadMarker;
+import org.apache.coyote.Processor;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.ExceptionUtils;
@@ -35,6 +36,7 @@ public class UpgradeServletInputStream extends ServletInputStream {
     private static final StringManager sm =
             StringManager.getManager(UpgradeServletInputStream.class);
 
+    private final Processor processor;
     private final SocketWrapperBase<?> socketWrapper;
 
     private volatile boolean closed = false;
@@ -45,7 +47,8 @@ public class UpgradeServletInputStream extends ServletInputStream {
     private volatile ClassLoader applicationLoader = null;
 
 
-    public UpgradeServletInputStream(SocketWrapperBase<?> socketWrapper) {
+    public UpgradeServletInputStream(Processor processor, SocketWrapperBase<?> socketWrapper) {
+        this.processor = processor;
         this.socketWrapper = socketWrapper;
     }
 
@@ -101,7 +104,7 @@ public class UpgradeServletInputStream extends ServletInputStream {
 
         // Container is responsible for first call to onDataAvailable().
         if (ContainerThreadMarker.isContainerThread()) {
-            socketWrapper.addDispatch(DispatchType.NON_BLOCKING_READ);
+            processor.addDispatch(DispatchType.NON_BLOCKING_READ);
         } else {
             socketWrapper.registerReadInterest();
         }

==================================================
StreamProcessor.java
index 850a2127a2..0e90784c63 100644
--- a/java/org/apache/coyote/http11/upgrade/UpgradeServletOutputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/UpgradeServletOutputStream.java
@@ -22,6 +22,7 @@ import javax.servlet.ServletOutputStream;
 import javax.servlet.WriteListener;
 
 import org.apache.coyote.ContainerThreadMarker;
+import org.apache.coyote.Processor;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.ExceptionUtils;
@@ -35,6 +36,7 @@ public class UpgradeServletOutputStream extends ServletOutputStream {
     private static final StringManager sm =
             StringManager.getManager(UpgradeServletOutputStream.class);
 
+    private final Processor processor;
     private final SocketWrapperBase<?> socketWrapper;
 
     // Used to ensure that isReady() and onWritePossible() have a consistent
@@ -61,7 +63,8 @@ public class UpgradeServletOutputStream extends ServletOutputStream {
     private volatile ClassLoader applicationLoader = null;
 
 
-    public UpgradeServletOutputStream(SocketWrapperBase<?> socketWrapper) {
+    public UpgradeServletOutputStream(Processor processor, SocketWrapperBase<?> socketWrapper) {
+        this.processor = processor;
         this.socketWrapper = socketWrapper;
     }
 
@@ -115,7 +118,7 @@ public class UpgradeServletOutputStream extends ServletOutputStream {
             registered = true;
             // Container is responsible for first call to onDataAvailable().
             if (ContainerThreadMarker.isContainerThread()) {
-                socketWrapper.addDispatch(DispatchType.NON_BLOCKING_WRITE);
+                processor.addDispatch(DispatchType.NON_BLOCKING_WRITE);
             } else {
                 socketWrapper.registerWriteInterest();
             }

==================================================
AbstractEndpoint.java
index 989df2d7da..a04064b84c 100644
--- a/java/org/apache/coyote/http2/StreamProcessor.java
+++ b/java/org/apache/coyote/http2/StreamProcessor.java
@@ -19,8 +19,6 @@ package org.apache.coyote.http2;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Iterator;
-import java.util.Set;
-import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import javax.servlet.http.HttpUpgradeHandler;
@@ -48,7 +46,6 @@ public class StreamProcessor extends AbstractProcessor implements Runnable {
     private static final StringManager sm = StringManager.getManager(StreamProcessor.class);
 
     private final Stream stream;
-    private Set<DispatchType> dispatches = new CopyOnWriteArraySet<>();
 
     private volatile SSLSupport sslSupport;
 
@@ -374,11 +371,11 @@ public class StreamProcessor extends AbstractProcessor implements Runnable {
             break;
         }
         case DISPATCH_READ: {
-            dispatches.add(DispatchType.NON_BLOCKING_READ);
+            addDispatch(DispatchType.NON_BLOCKING_READ);
             break;
         }
         case DISPATCH_WRITE: {
-            dispatches.add(DispatchType.NON_BLOCKING_WRITE);
+            addDispatch(DispatchType.NON_BLOCKING_WRITE);
             break;
         }
         case DISPATCH_EXECUTE: {
@@ -482,35 +479,6 @@ public class StreamProcessor extends AbstractProcessor implements Runnable {
     }
 
 
-    public void addDispatch(DispatchType dispatchType) {
-        synchronized (dispatches) {
-            dispatches.add(dispatchType);
-        }
-    }
-    public Iterator<DispatchType> getIteratorAndClearDispatches() {
-        // Note: Logic in AbstractProtocol depends on this method only returning
-        // a non-null value if the iterator is non-empty. i.e. it should never
-        // return an empty iterator.
-        Iterator<DispatchType> result;
-        synchronized (dispatches) {
-            // Synchronized as the generation of the iterator and the clearing
-            // of dispatches needs to be an atomic operation.
-            result = dispatches.iterator();
-            if (result.hasNext()) {
-                dispatches.clear();
-            } else {
-                result = null;
-            }
-        }
-        return result;
-    }
-    public void clearDispatches() {
-        synchronized (dispatches) {
-            dispatches.clear();
-        }
-    }
-
-
     @Override
     public HttpUpgradeHandler getHttpUpgradeHandler() {
         // Should never happen

==================================================
SocketWrapperBase.java
index 316a8339f7..0e3481e433 100644
--- a/java/org/apache/tomcat/util/net/AbstractEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AbstractEndpoint.java
@@ -811,7 +811,8 @@ public abstract class AbstractEndpoint<S> {
             SocketStatus socketStatus, boolean dispatch);
 
 
-    public void executeNonBlockingDispatches(SocketWrapperBase<S> socketWrapper) {
+    public void executeNonBlockingDispatches(SocketWrapperBase<S> socketWrapper,
+            Iterator<DispatchType> dispatches) {
         /*
          * This method is called when non-blocking IO is initiated by defining
          * a read and/or write listener in a non-container thread. It is called
@@ -831,8 +832,6 @@ public abstract class AbstractEndpoint<S> {
          * sure that the socket has been added to the waitingRequests queue.
          */
         synchronized (socketWrapper) {
-            Iterator<DispatchType> dispatches = socketWrapper.getIteratorAndClearDispatches();
-
             while (dispatches != null && dispatches.hasNext()) {
                 DispatchType dispatchType = dispatches.next();
                 processSocket(socketWrapper, dispatchType.getSocketStatus(), false);

==================================================
