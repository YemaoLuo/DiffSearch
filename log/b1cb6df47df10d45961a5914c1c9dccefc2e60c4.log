b1cb6df47df10d45961a5914c1c9dccefc2e60c4
==================================================
More cookie refactoring
==================================================
Mark Emlyn
==================================================
Sat Nov 14 03:47:48 2009 +0000
==================================================
CookieSupport.java
More cookie refactoring
 - new support class for common elements of parsing and writing
 - better consistency between parsing and writing
 - remove unused code
 - reduce visibility of methods where possible
 - auto-switch to v1 for any attribute that might require quoting
 - better names for constants
 - allow v0 cookies to break http spec (disabled by default)
 - update test cases and documentation


git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@836113 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Cookies.java
new file mode 100644
index 0000000000..23251721ab
--- /dev/null
+++ b/java/org/apache/tomcat/util/http/CookieSupport.java
@@ -0,0 +1,236 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.tomcat.util.http;
+
+
+/**
+ * Static constants for this package.
+ */
+public final class CookieSupport {
+
+	
+    // --------------------------------------------------------------- Constants
+    /**
+     * If set to true, we parse cookies strictly according to the servlet,
+     * cookie and HTTP specs by default.
+     */
+    public static final boolean STRICT_SERVLET_COMPLIANCE;
+
+    /**
+     * If true, cookie values are allowed to contain an equals character without
+     * being quoted.
+     */
+    public static final boolean ALLOW_EQUALS_IN_VALUE;
+
+    /**
+     * If true, separators that are not explicitly dis-allowed by the v0 cookie
+     * spec but are disallowed by the HTTP spec will be allowed in v0 cookie
+     * names and values. These characters are: \"()/:<=>?@[\\]{} Note that the
+     * inclusion of / depend on the value of {@link #FWD_SLASH_IS_SEPARATOR}.
+     */
+    public static final boolean ALLOW_HTTP_SEPARATORS_IN_V0;
+    
+    /**
+     * If set to false, we don't use the IE6/7 Max-Age/Expires work around.
+     * Default is usually true. If STRICT_SERVLET_COMPLIANCE==true then default
+     * is false. Explicitly setting always takes priority.
+     */
+    public static final boolean ALWAYS_ADD_EXPIRES;
+
+    /**
+     * If set to true, the <code>/</code> character will be treated as a
+     * separator. Default is usually false. If STRICT_SERVLET_COMPLIANCE==true
+     * then default is true. Explicitly setting always takes priority.
+     */
+    public static final boolean FWD_SLASH_IS_SEPARATOR;
+
+    /**
+     * The list of separators that apply to version 0 cookies. To quote the
+     * spec, these are comma, semi-colon and white-space. The HTTP spec
+     * definition of linear white space is [CRLF] 1*( SP | HT )
+     */
+    public static final char[] V0_SEPARATORS = {',', ';', ' ', '\t'};
+    public static final boolean[] V0_SEPARATOR_FLAGS = new boolean[128];
+    
+    /**
+     * The list of separators that apply to version 1 cookies. This may or may
+     * not include '/' depending on the setting of
+     * {@link #FWD_SLASH_IS_SEPARATOR}.
+     */
+    public static final char[] HTTP_SEPARATORS;
+    public static final boolean[] HTTP_SEPARATOR_FLAGS = new boolean[128];
+    
+    static {
+        STRICT_SERVLET_COMPLIANCE = Boolean.valueOf(System.getProperty(
+                "org.apache.catalina.STRICT_SERVLET_COMPLIANCE",
+                "false")).booleanValue();
+        
+        ALLOW_EQUALS_IN_VALUE = Boolean.valueOf(System.getProperty(
+                "org.apache.tomcat.util.http.ServerCookie.ALLOW_EQUALS_IN_VALUE",
+                "false")).booleanValue();
+        
+        ALLOW_HTTP_SEPARATORS_IN_V0 = Boolean.valueOf(System.getProperty(
+                "org.apache.tomcat.util.http.ServerCookie.ALLOW_HTTP_SEPARATORS_IN_V0",
+                "false")).booleanValue();
+        
+        String alwaysAddExpires = System.getProperty(
+        "org.apache.tomcat.util.http.ServerCookie.ALWAYS_ADD_EXPIRES");
+        if (alwaysAddExpires == null) {
+            ALWAYS_ADD_EXPIRES = !STRICT_SERVLET_COMPLIANCE;
+        } else {
+            ALWAYS_ADD_EXPIRES =
+                Boolean.valueOf(alwaysAddExpires).booleanValue();
+        }
+        
+        String  fwdSlashIsSeparator = System.getProperty(
+                "org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR");
+        if (fwdSlashIsSeparator == null) {
+            FWD_SLASH_IS_SEPARATOR = STRICT_SERVLET_COMPLIANCE;
+        } else {
+            FWD_SLASH_IS_SEPARATOR =
+                Boolean.valueOf(fwdSlashIsSeparator).booleanValue();
+        }
+        
+        /*
+        Excluding the '/' char by default violates the RFC, but 
+        it looks like a lot of people put '/'
+        in unquoted values: '/': ; //47 
+        '\t':9 ' ':32 '\"':34 '(':40 ')':41 ',':44 ':':58 ';':59 '<':60 
+        '=':61 '>':62 '?':63 '@':64 '[':91 '\\':92 ']':93 '{':123 '}':125
+        */
+        if (CookieSupport.FWD_SLASH_IS_SEPARATOR) {
+            HTTP_SEPARATORS = new char[] { '\t', ' ', '\"', '(', ')', ',', '/', 
+                    ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '{', '}' };
+        } else {
+            HTTP_SEPARATORS = new char[] { '\t', ' ', '\"', '(', ')', ',', 
+                    ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '{', '}' };
+        }
+        for (int i = 0; i < 128; i++) {
+            V0_SEPARATOR_FLAGS[i] = false;
+            HTTP_SEPARATOR_FLAGS[i] = false;
+        }
+        for (int i = 0; i < V0_SEPARATORS.length; i++) {
+            V0_SEPARATOR_FLAGS[V0_SEPARATORS[i]] = true;
+        }
+        for (int i = 0; i < HTTP_SEPARATORS.length; i++) {
+            HTTP_SEPARATOR_FLAGS[HTTP_SEPARATORS[i]] = true;
+        }
+
+    }
+    
+    // ----------------------------------------------------------------- Methods
+
+    /**
+     * Returns true if the byte is a separator as defined by V0 of the cookie
+     * spec.
+     */
+    public static final boolean isV0Separator(final char c) {
+        if (c < 0x20 || c >= 0x7f) {
+            if (c != 0x09) {
+                throw new IllegalArgumentException(
+                        "Control character in cookie value or attribute.");
+            }
+        }
+
+        return V0_SEPARATOR_FLAGS[c];
+    }
+    
+    public static boolean isV0Token(String value) {
+        if( value==null) return false;
+        
+        int i = 0;
+        int len = value.length();
+
+        if (alreadyQuoted(value)) {
+            i++;
+            len--;
+        }
+        
+        for (; i < len; i++) {
+            char c = value.charAt(i);
+
+            if (isV0Separator(c))
+                return true;
+        }
+        return false;
+    }
+
+    /**
+     * Returns true if the byte is a separator as defined by V1 of the cookie
+     * spec, RFC2109.
+     * @throws IllegalArgumentException if a control character was supplied as
+     *         input
+     */
+    public static final boolean isHttpSeparator(final char c) {
+        if (c < 0x20 || c >= 0x7f) {
+            if (c != 0x09) {
+                throw new IllegalArgumentException(
+                        "Control character in cookie value or attribute.");
+            }
+        }
+
+        return HTTP_SEPARATOR_FLAGS[c];
+    }
+
+    public static boolean isHttpToken(String value) {
+        if( value==null) return false;
+        
+        int i = 0;
+        int len = value.length();
+
+        if (alreadyQuoted(value)) {
+            i++;
+            len--;
+        }
+        
+        for (; i < len; i++) {
+            char c = value.charAt(i);
+
+            if (isHttpSeparator(c))
+                return true;
+        }
+        return false;
+    }
+
+    public static boolean containsCTL(String value) {
+        if (value==null) return false;
+        int len = value.length();
+        for (int i = 0; i < len; i++) {
+            char c = value.charAt(i);
+            if (c < 0x20 || c >= 0x7f) {
+                if (c == 0x09)
+                    continue; //allow horizontal tabs
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public static boolean alreadyQuoted (String value) {
+        if (value==null || value.length() < 2) return false;
+        return (value.charAt(0)=='\"' && value.charAt(value.length()-1)=='\"');
+    }
+    
+
+    
+    // ------------------------------------------------------------- Constructor
+    private CookieSupport() {
+        // Utility class. Don't allow instances to be created.
+    }
+}

==================================================
ServerCookie.java
index 7efddbe575..7249cb08c4 100644
--- a/java/org/apache/tomcat/util/http/Cookies.java
+++ b/java/org/apache/tomcat/util/http/Cookies.java
@@ -19,7 +19,6 @@ package org.apache.tomcat.util.http;
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
-import java.util.StringTokenizer;
 
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.buf.MessageBytes;
@@ -46,72 +45,6 @@ public final class Cookies { // extends MultiMap {
 
     MimeHeaders headers;
 
-    /**
-     * If set to true, we parse cookies strictly according to the servlet,
-     * cookie and HTTP specs by default.
-     */
-    public static final boolean STRICT_SERVLET_COMPLIANCE;
-
-    /**
-     * If true, cookie values are allowed to contain an equals character without
-     * being quoted.
-     */
-    public static final boolean ALLOW_EQUALS_IN_VALUE;
-    
-    /**
-     * If set to true, the <code>/</code> character will be treated as a
-     * separator. Default is usually false. If STRICT_SERVLET_COMPLIANCE==true
-     * then default is true. Explicitly setting always takes priority.
-     */
-    public static final boolean FWD_SLASH_IS_SEPARATOR;
-    
-    /*
-    List of Separator Characters (see isSeparator())
-    */
-    public static final char SEPARATORS[];
-
-    protected static final boolean separators[] = new boolean[128];
-    static {
-        STRICT_SERVLET_COMPLIANCE = Boolean.valueOf(System.getProperty(
-                "org.apache.catalina.STRICT_SERVLET_COMPLIANCE",
-                "false")).booleanValue();
-        
-        ALLOW_EQUALS_IN_VALUE = Boolean.valueOf(System.getProperty(
-                "org.apache.tomcat.util.http.ServerCookie.ALLOW_EQUALS_IN_VALUE",
-                "false")).booleanValue();
-        
-        String  fwdSlashIsSeparator = System.getProperty(
-                "org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR");
-        if (fwdSlashIsSeparator == null) {
-            FWD_SLASH_IS_SEPARATOR = STRICT_SERVLET_COMPLIANCE;
-        } else {
-            FWD_SLASH_IS_SEPARATOR =
-                Boolean.valueOf(fwdSlashIsSeparator).booleanValue();
-        }
-
-        /*
-        Excluding the '/' char by default violates the RFC, but 
-        it looks like a lot of people put '/'
-        in unquoted values: '/': ; //47 
-        '\t':9 ' ':32 '\"':34 '(':40 ')':41 ',':44 ':':58 ';':59 '<':60 
-        '=':61 '>':62 '?':63 '@':64 '[':91 '\\':92 ']':93 '{':123 '}':125
-        */
-        if (FWD_SLASH_IS_SEPARATOR) {
-            SEPARATORS = new char[] { '\t', ' ', '\"', '(', ')', ',', '/', 
-                    ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '{', '}' };
-        } else {
-            SEPARATORS = new char[] { '\t', ' ', '\"', '(', ')', ',', 
-                    ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '{', '}' };
-        }
-        
-        for (int i = 0; i < 128; i++) {
-            separators[i] = false;
-        }
-        for (int i = 0; i < SEPARATORS.length; i++) {
-            separators[SEPARATORS[i]] = true;
-        }
-    }
-
     /**
      *  Construct a new cookie collection, that will extract
      *  the information from headers.
@@ -123,29 +56,6 @@ public final class Cookies { // extends MultiMap {
         this.headers=headers;
     }
 
-    /**
-     * Construct a new uninitialized cookie collection.
-     * Use {@link #setHeaders} to initialize.
-     */
-    // [seguin] added so that an empty Cookies object could be
-    // created, have headers set, then recycled.
-    public Cookies() {
-    }
-
-    /**
-     * Set the headers from which cookies will be pulled.
-     * This has the side effect of recycling the object.
-     *
-     * @param headers Cookies are lazy-evaluated and will extract the
-     *     information from the provided headers.
-     */
-    // [seguin] added so that an empty Cookies object could be
-    // created, have headers set, then recycled.
-    public void setHeaders(MimeHeaders headers) {
-        recycle();
-        this.headers=headers;
-    }
-
     /**
      * Recycle.
      */
@@ -196,7 +106,7 @@ public final class Cookies { // extends MultiMap {
      *  most of the time an existing ServerCookie object is returned.
      *  The caller can set the name/value and attributes for the cookie
      */
-    public ServerCookie addCookie() {
+    private ServerCookie addCookie() {
         if( cookieCount >= scookies.length  ) {
             ServerCookie scookiesTmp[]=new ServerCookie[2*cookieCount];
             System.arraycopy( scookies, 0, scookiesTmp, 0, cookieCount);
@@ -235,24 +145,24 @@ public final class Cookies { // extends MultiMap {
             }
 
             // Uncomment to test the new parsing code
-            if( cookieValue.getType() == MessageBytes.T_BYTES ) {
-                if(log.isDebugEnabled())
-                    log.debug("Cookies: Parsing b[]: " + cookieValue.toString());
-                ByteChunk bc=cookieValue.getByteChunk();
-                processCookieHeader( bc.getBytes(),
-                                     bc.getOffset(),
-                                     bc.getLength());
-            } else {
-                if(log.isDebugEnabled())
-                    log.debug("Cookies: Parsing S: " + cookieValue.toString());
-                processCookieHeader( cookieValue.toString() );
+            if( cookieValue.getType() != MessageBytes.T_BYTES ) {
+                Exception e = new Exception();
+                log.warn("Cookies: Parsing cookie as String. Expected bytes.",
+                        e);
+                cookieValue.toBytes();
             }
+            if(log.isDebugEnabled())
+                log.debug("Cookies: Parsing b[]: " + cookieValue.toString());
+            ByteChunk bc=cookieValue.getByteChunk();
+            processCookieHeader( bc.getBytes(),
+                                 bc.getOffset(),
+                                 bc.getLength());
             pos++;// search from the next position
         }
     }
 
     // XXX will be refactored soon!
-    public static boolean equals( String s, byte b[], int start, int end) {
+    private static boolean equals( String s, byte b[], int start, int end) {
         int blen = end-start;
         if (b == null || blen != s.length()) {
             return false;
@@ -267,87 +177,12 @@ public final class Cookies { // extends MultiMap {
     }
     
 
-    // ---------------------------------------------------------
-    // -------------------- DEPRECATED, OLD --------------------
-    
-    private void processCookieHeader(  String cookieString )
-    {
-        if(log.isDebugEnabled())
-            log.debug("Cookies: Parsing cookie header " + cookieString);
-        // normal cookie, with a string value.
-        // This is the original code, un-optimized - it shouldn't
-        // happen in normal case
-
-        StringTokenizer tok = new StringTokenizer(cookieString,
-                                                  ";", false);
-        while (tok.hasMoreTokens()) {
-            String token = tok.nextToken();
-            int i = token.indexOf("=");
-            if (i > -1) {
-                
-                // XXX
-                // the trims here are a *hack* -- this should
-                // be more properly fixed to be spec compliant
-                
-                String name = token.substring(0, i).trim();
-                String value = token.substring(i+1, token.length()).trim();
-                // RFC 2109 and bug 
-                value=stripQuote( value );
-                ServerCookie cookie = addCookie();
-                
-                cookie.getName().setString(name);
-                cookie.getValue().setString(value);
-                if(log.isDebugEnabled())
-                    log.debug("Cookies: Add cookie " + name + "=" + value);
-            } else {
-                // we have a bad cookie.... just let it go
-            }
-        }
-    }
-
-    /**
-     *
-     * Strips quotes from the start and end of the cookie string
-     * This conforms to RFC 2965
-     * 
-     * @param value            a <code>String</code> specifying the cookie 
-     *                         value (possibly quoted).
-     *
-     * @see #setValue
-     *
-     */
-    private static String stripQuote( String value )
-    {
-        //        log("Strip quote from " + value );
-        if (value.startsWith("\"") && value.endsWith("\"")) {
-            try {
-                return value.substring(1,value.length()-1);
-            } catch (Exception ex) { 
-            }
-        }
-        return value;
-    }  
-
-   /**
-     * Returns true if the byte is a separator character as
-     * defined in RFC2619. Since this is called often, this
-     * function should be organized with the most probable
-     * outcomes first.
-     * JVK
-     */
-    public static final boolean isSeparator(final byte c) {
-         if (c > 0 && c < 126)
-             return separators[c];
-         else
-             return false;
-    }
-    
     /**
      * Returns true if the byte is a whitespace character as
      * defined in RFC2619
      * JVK
      */
-    public static final boolean isWhiteSpace(final byte c) {
+    private static final boolean isWhiteSpace(final byte c) {
         // This switch statement is slightly slower
         // for my vm than the if statement.
         // Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_07-164)
@@ -369,13 +204,40 @@ public final class Cookies { // extends MultiMap {
            return false;
     }
 
+    /**
+     * Unescapes any double quotes in the given cookie value.
+     *
+     * @param bc The cookie value to modify
+     */
+    private static void unescapeDoubleQuotes(ByteChunk bc) {
+
+        if (bc == null || bc.getLength() == 0 || bc.indexOf('"', 0) == -1) {
+            return;
+        }
+
+        int src = bc.getStart();
+        int end = bc.getEnd();
+        int dest = src;
+        byte[] buffer = bc.getBuffer();
+        
+        while (src < end) {
+            if (buffer[src] == '\\' && src < end && buffer[src+1]  == '"') {
+                src++;
+            }
+            buffer[dest] = buffer[src];
+            dest ++;
+            src ++;
+        }
+        bc.setEnd(dest);
+    }
+
     /**
      * Parses a cookie header after the initial "Cookie:"
      * [WS][$]token[WS]=[WS](token|QV)[;|,]
      * RFC 2965
      * JVK
      */
-    public final void processCookieHeader(byte bytes[], int off, int len){
+    protected final void processCookieHeader(byte bytes[], int off, int len){
         if( len<=0 || bytes==null ) return;
         int end=off+len;
         int pos=off;
@@ -394,7 +256,10 @@ public final class Cookies { // extends MultiMap {
 
             // Skip whitespace and non-token characters (separators)
             while (pos < end && 
-                   (isSeparator(bytes[pos]) || isWhiteSpace(bytes[pos]))) 
+                   (CookieSupport.isHttpSeparator((char) bytes[pos]) &&
+                           !CookieSupport.ALLOW_HTTP_SEPARATORS_IN_V0 ||
+                    CookieSupport.isV0Separator((char) bytes[pos]) ||
+                    isWhiteSpace(bytes[pos]))) 
                 {pos++; } 
 
             if (pos >= end)
@@ -406,9 +271,9 @@ public final class Cookies { // extends MultiMap {
                 pos++;
             }
 
-            // Get the cookie name. This must be a token            
+            // Get the cookie/attribute name. This must be a token            
             valueEnd = valueStart = nameStart = pos; 
-            pos = nameEnd = getTokenEndPosition(bytes,pos,end);
+            pos = nameEnd = getTokenEndPosition(bytes,pos,end,version,true);
 
             // Skip whitespace
             while (pos < end && isWhiteSpace(bytes[pos])) {pos++; } 
@@ -455,19 +320,23 @@ public final class Cookies { // extends MultiMap {
                     // The position is OK (On a delimiter)
                     break;
                 default:
-                    if (!isSeparator(bytes[pos])) {
+                    if (version == 0 &&
+                                !CookieSupport.isV0Separator((char)bytes[pos]) &&
+                                CookieSupport.ALLOW_HTTP_SEPARATORS_IN_V0 ||
+                            !CookieSupport.isHttpSeparator((char)bytes[pos])) {
                         // Token
                         valueStart=pos;
                         // getToken returns the position at the delimeter
                         // or other non-token character
-                        valueEnd=getTokenEndPosition(bytes, valueStart, end);
+                        valueEnd=getTokenEndPosition(bytes, valueStart, end,
+                                version, false);
                         // We need pos to advance
                         pos = valueEnd;
                     } else  {
                         // INVALID COOKIE, advance to next delimiter
                         // The starting character of the cookie value was
                         // not valid.
-                        log.info("Cookies: Invalid cookie." +
+                        log.info("Cookies: Invalid cookie. " +
                                 "Value not a token or quoted value");
                         while (pos < end && bytes[pos] != ';' && 
                                bytes[pos] != ',') 
@@ -503,23 +372,6 @@ public final class Cookies { // extends MultiMap {
             
             pos++;
 
-            /*
-            if (nameEnd <= nameStart || valueEnd < valueStart ) {
-                // Something is wrong, but this may be a case
-                // of having two ';' characters in a row.
-                // log("Cookie name/value does not conform to RFC 2965");
-                // Advance to next delimiter (ignoring everything else)
-                while (pos < end && bytes[pos] != ';' && bytes[pos] != ',') 
-                    { pos++; };
-                pos++;
-                // Make sure no special cookies can be attributed to 
-                // the previous cookie by setting the current cookie
-                // to null
-                sc = null;
-                continue;
-            }
-            */
-
             // All checks passed. Add the cookie, start with the 
             // special avpairs first
             if (isSpecial) {
@@ -557,12 +409,11 @@ public final class Cookies { // extends MultiMap {
                     continue;
                 } 
 
-
+                // v2 cookie attributes - skip them
                 if (equals( "Port", bytes, nameStart, nameEnd)) {
-                    // sc.getPort is not currently implemented.
-                    // sc.getPort().setBytes( bytes,
-                    //                        valueStart,
-                    //                        valueEnd-valueStart );
+                    continue;
+                } 
+                if (equals( "CommentURL", bytes, nameStart, nameEnd)) {
                     continue;
                 } 
 
@@ -580,8 +431,7 @@ public final class Cookies { // extends MultiMap {
                             valueEnd-valueStart);
                     if (isQuoted) {
                         // We know this is a byte value so this is safe
-                        ServerCookie.unescapeDoubleQuotes(
-                                sc.getValue().getByteChunk());
+                        unescapeDoubleQuotes(sc.getValue().getByteChunk());
                     }
                 } else {
                     // Name Only
@@ -597,11 +447,17 @@ public final class Cookies { // extends MultiMap {
      * token, with no separator characters in between.
      * JVK
      */
-    public static final int getTokenEndPosition(byte bytes[], int off, int end){
+    private static final int getTokenEndPosition(byte bytes[], int off, int end,
+            int version, boolean isName){
         int pos = off;
         while (pos < end &&
-                (!isSeparator(bytes[pos]) ||
-                        bytes[pos]=='=' && ALLOW_EQUALS_IN_VALUE)) {
+                (!CookieSupport.isHttpSeparator((char)bytes[pos]) ||
+                 version == 0 &&
+                        CookieSupport.ALLOW_HTTP_SEPARATORS_IN_V0 &&
+                        bytes[pos] != '=' &&
+                        !CookieSupport.isV0Separator((char)bytes[pos]) ||
+                 !isName && bytes[pos] == '=' &&
+                         CookieSupport.ALLOW_EQUALS_IN_VALUE)) {
             pos++;
         }
         
@@ -615,7 +471,7 @@ public final class Cookies { // extends MultiMap {
      * the position of the end quote. This escapes anything after a '\' char
      * JVK RFC 2616
      */
-    public static final int getQuotedValueEndPosition(byte bytes[], int off, int end){
+    private static final int getQuotedValueEndPosition(byte bytes[], int off, int end){
         int pos = off;
         while (pos < end) {
             if (bytes[pos] == '"') {

==================================================
TestCookiesAllowEquals.java
index 2d8ad95a47..ccd608f78a 100644
--- a/java/org/apache/tomcat/util/http/ServerCookie.java
+++ b/java/org/apache/tomcat/util/http/ServerCookie.java
@@ -25,7 +25,6 @@ import java.util.Date;
 import java.util.Locale;
 import java.util.TimeZone;
 
-import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.buf.MessageBytes;
 
 
@@ -40,6 +39,7 @@ import org.apache.tomcat.util.buf.MessageBytes;
  */
 public class ServerCookie implements Serializable {
     
+    private static final long serialVersionUID = 1L;
     
     // Version 0 (Netscape) attributes
     private MessageBytes name=MessageBytes.newInstance();
@@ -69,69 +69,21 @@ public class ServerCookie implements Serializable {
     };
     private static final String ancientDate;
 
-    /**
-     * If set to true, we parse cookies strictly according to the servlet,
-     * cookie and HTTP specs by default.
-     */
-    public static final boolean STRICT_SERVLET_COMPLIANCE;
-
-    /**
-     * If set to false, we don't use the IE6/7 Max-Age/Expires work around.
-     * Default is usually true. If STRICT_SERVLET_COMPLIANCE==true then default
-     * is false. Explicitly setting always takes priority.
-     */
-    public static final boolean ALWAYS_ADD_EXPIRES;
-
-    /**
-     * If set to true, the <code>/</code> character will be treated as a
-     * separator. Default is usually false. If STRICT_SERVLET_COMPLIANCE==true
-     * then default is true. Explicitly setting always takes priority.
-     */
-    public static final boolean FWD_SLASH_IS_SEPARATOR;
-
-
     static {
         ancientDate = OLD_COOKIE_FORMAT.get().format(new Date(10000));
-        
-        STRICT_SERVLET_COMPLIANCE = Boolean.valueOf(System.getProperty(
-                "org.apache.catalina.STRICT_SERVLET_COMPLIANCE",
-                "false")).booleanValue();
-        
-
-        String alwaysAddExpires = System.getProperty(
-                "org.apache.tomcat.util.http.ServerCookie.ALWAYS_ADD_EXPIRES");
-        if (alwaysAddExpires == null) {
-            ALWAYS_ADD_EXPIRES = !STRICT_SERVLET_COMPLIANCE;
-        } else {
-            ALWAYS_ADD_EXPIRES =
-                Boolean.valueOf(alwaysAddExpires).booleanValue();
-        }
-        
-        String  fwdSlashIsSeparator = System.getProperty(
-                "org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR");
-        if (fwdSlashIsSeparator == null) {
-            FWD_SLASH_IS_SEPARATOR = STRICT_SERVLET_COMPLIANCE;
-        } else {
-            FWD_SLASH_IS_SEPARATOR =
-                Boolean.valueOf(fwdSlashIsSeparator).booleanValue();
-        }
-        
-        if (FWD_SLASH_IS_SEPARATOR) {
-            tspecials2 = "()<>@,;:\\\"/[]?={} \t";
-        } else {
-            tspecials2 = "()<>@,;:\\\"[]?={} \t";
-        }
     }
 
-    // Note: Servlet Spec =< 2.5 only refers to Netscape and RFC2109,
+    // Note: Servlet Spec =< 3.0 only refers to Netscape and RFC2109,
     // not RFC2965
 
-    // Version 1 (RFC2965) attributes
-    // TODO Add support for CommentURL
+    // Version 2 (RFC2965) attributes that would need to be added to support
+    // v2 cookies
+    // CommentURL
     // Discard - implied by maxAge <0
-    // TODO Add support for Port
+    // Port
 
     public ServerCookie() {
+        // NOOP
     }
 
     public void recycle() {
@@ -199,98 +151,9 @@ public class ServerCookie implements Serializable {
             + getVersion() + " " + getPath() + " " + getDomain();
     }
     
-    private static final String tspecials = ",; ";
-    private static final String tspecials2;
-
-    /*
-     * Tests a string and returns true if the string counts as a
-     * reserved token in the Java language.
-     *
-     * @param value the <code>String</code> to be tested
-     *
-     * @return      <code>true</code> if the <code>String</code> is a reserved
-     *              token; <code>false</code> if it is not
-     */
-    public static boolean isToken(String value) {
-        return isToken(value,null);
-    }
-    
-    public static boolean isToken(String value, String literals) {
-        String tspecials = (literals==null?ServerCookie.tspecials:literals);
-        if( value==null) return true;
-        int len = value.length();
-
-        for (int i = 0; i < len; i++) {
-            char c = value.charAt(i);
-
-            if (tspecials.indexOf(c) != -1)
-                return false;
-        }
-        return true;
-    }
-
-    public static boolean containsCTL(String value, int version) {
-        if( value==null) return false;
-        int len = value.length();
-        for (int i = 0; i < len; i++) {
-            char c = value.charAt(i);
-            if (c < 0x20 || c >= 0x7f) {
-                if (c == 0x09)
-                    continue; //allow horizontal tabs
-                return true;
-            }
-        }
-        return false;
-    }
-
-    public static boolean isToken2(String value) {
-        return isToken2(value,null);
-    }
-
-    public static boolean isToken2(String value, String literals) {
-        String tokens = (literals==null?ServerCookie.tspecials2:literals);
-        if( value==null) return true;
-        int len = value.length();
-
-        for (int i = 0; i < len; i++) {
-            char c = value.charAt(i);
-            if (tokens.indexOf(c) != -1)
-                return false;
-        }
-        return true;
-    }
-
     // -------------------- Cookie parsing tools
 
     
-    /**
-     * Return the header name to set the cookie, based on cookie version.
-     */
-    public String getCookieHeaderName() {
-        return getCookieHeaderName(version);
-    }
-
-    /**
-     * Return the header name to set the cookie, based on cookie version.
-     */
-    public static String getCookieHeaderName(int version) {
-        // TODO Re-enable logging when RFC2965 is implemented
-        // log( (version==1) ? "Set-Cookie2" : "Set-Cookie");
-        if (version == 1) {
-            // XXX RFC2965 not referenced in Servlet Spec
-            // Set-Cookie2 is not supported by Netscape 4, 6, IE 3, 5
-            // Set-Cookie2 is supported by Lynx and Opera
-            // Need to check on later IE and FF releases but for now... 
-            // RFC2109
-            return "Set-Cookie";
-            // return "Set-Cookie2";
-        } else {
-            // Old Netscape
-            return "Set-Cookie";
-        }
-    }
-
-    // TODO RFC2965 fields also need to be passed
     public static void appendCookieValue( StringBuffer headerBuf,
                                           int version,
                                           String name,
@@ -308,41 +171,81 @@ public class ServerCookie implements Serializable {
         buf.append("=");
         // Servlet implementation does not check anything else
         
-        version = maybeQuote2(version, buf, value, true);
+        /*
+         * The spec allows some latitude on when to send the version attribute
+         * with a Set-Cookie header. To be nice to clients, we'll make sure the
+         * version attribute is first. That means checking the various things
+         * that can cause us to switch to a v1 cookie first.
+         * 
+         * Note that by checking for tokens we will also throw an exception if a
+         * control character is encountered.
+         */
+        // Start by using the version we were asked for
+        int newVersion = version;
         
-        // Spec team clarified setting comment on a v0 cookie switches it to v1
-        if (version == 0 && comment != null) {
-            version = 1;
+        // If it is v0, check if we need to switch
+        if (newVersion == 0 &&
+                (!CookieSupport.ALLOW_HTTP_SEPARATORS_IN_V0 &&
+                 CookieSupport.isHttpToken(value) ||
+                 CookieSupport.ALLOW_HTTP_SEPARATORS_IN_V0 &&
+                 CookieSupport.isV0Token(value))) {
+            // HTTP token in value - need to use v1
+            newVersion = 1;
+        }
+        
+        if (newVersion == 0 && comment != null) {
+            // Using a comment makes it a v1 cookie
+           newVersion = 1;
+        }
+
+        if (newVersion == 0 &&
+                (!CookieSupport.ALLOW_HTTP_SEPARATORS_IN_V0 &&
+                 CookieSupport.isHttpToken(path) ||
+                 CookieSupport.ALLOW_HTTP_SEPARATORS_IN_V0 &&
+                 CookieSupport.isV0Token(path))) {
+            // HTTP token in path - need to use v1
+            newVersion = 1;
+        }
+
+        if (newVersion == 0 &&
+                (!CookieSupport.ALLOW_HTTP_SEPARATORS_IN_V0 &&
+                 CookieSupport.isHttpToken(domain) ||
+                 CookieSupport.ALLOW_HTTP_SEPARATORS_IN_V0 &&
+                 CookieSupport.isV0Token(domain))) {
+            // HTTP token in domain - need to use v1
+            newVersion = 1;
         }
 
+        // Now build the cookie header
+        // Value
+        maybeQuote(buf, value);
         // Add version 1 specific information
-        if (version == 1) {
+        if (newVersion == 1) {
             // Version=1 ... required
             buf.append ("; Version=1");
 
             // Comment=comment
             if ( comment!=null ) {
                 buf.append ("; Comment=");
-                maybeQuote2(version, buf, comment);
+                maybeQuote(buf, comment);
             }
         }
         
         // Add domain information, if present
         if (domain!=null) {
             buf.append("; Domain=");
-            maybeQuote2(version, buf, domain);
+            maybeQuote(buf, domain);
         }
 
         // Max-Age=secs ... or use old "Expires" format
-        // TODO RFC2965 Discard
         if (maxAge >= 0) {
-            if (version > 0) {
+            if (newVersion > 0) {
                 buf.append ("; Max-Age=");
                 buf.append (maxAge);
             }
             // IE6, IE7 and possibly other browsers don't understand Max-Age.
             // They do understand Expires, even with V1 cookies!
-            if (version == 0 || ALWAYS_ADD_EXPIRES) {
+            if (newVersion == 0 || CookieSupport.ALWAYS_ADD_EXPIRES) {
                 // Wdy, DD-Mon-YY HH:MM:SS GMT ( Expires Netscape format )
                 buf.append ("; Expires=");
                 // To expire immediately we need to set the time in past
@@ -359,7 +262,7 @@ public class ServerCookie implements Serializable {
         // Path=path
         if (path!=null) {
             buf.append ("; Path=");
-            maybeQuote2(version, buf, path);
+            maybeQuote(buf, path);
         }
 
         // Secure
@@ -374,51 +277,28 @@ public class ServerCookie implements Serializable {
         headerBuf.append(buf);
     }
 
-    public static boolean alreadyQuoted (String value) {
-        if (value==null || value.length()==0) return false;
-        return (value.charAt(0)=='\"' && value.charAt(value.length()-1)=='\"');
-    }
-    
     /**
-     * Quotes values using rules that vary depending on Cookie version.
-     * @param version
+     * Quotes values if required.
      * @param buf
      * @param value
      */
-    public static int maybeQuote2 (int version, StringBuffer buf, String value) {
-        return maybeQuote2(version,buf,value,false);
-    }
-
-    public static int maybeQuote2 (int version, StringBuffer buf, String value, boolean allowVersionSwitch) {
-        return maybeQuote2(version,buf,value,null,allowVersionSwitch);
-    }
-
-    public static int maybeQuote2 (int version, StringBuffer buf, String value, String literals, boolean allowVersionSwitch) {
+    private static void maybeQuote (StringBuffer buf, String value) {
         if (value==null || value.length()==0) {
             buf.append("\"\"");
-        }else if (containsCTL(value,version)) 
-            throw new IllegalArgumentException("Control character in cookie value, consider BASE64 encoding your value");
-        else if (alreadyQuoted(value)) {
+        } else if (CookieSupport.alreadyQuoted(value)) {
             buf.append('"');
             buf.append(escapeDoubleQuotes(value,1,value.length()-1));
             buf.append('"');
-        } else if (allowVersionSwitch && version==0 && !isToken2(value, literals)) {
-            buf.append('"');
-            buf.append(escapeDoubleQuotes(value,0,value.length()));
-            buf.append('"');
-            version = 1;
-        } else if (version==0 && !isToken(value,literals)) {
+        } else if (CookieSupport.isHttpToken(value) &&
+                !CookieSupport.ALLOW_HTTP_SEPARATORS_IN_V0 ||
+                CookieSupport.isV0Token(value) &&
+                CookieSupport.ALLOW_HTTP_SEPARATORS_IN_V0) {
             buf.append('"');
             buf.append(escapeDoubleQuotes(value,0,value.length()));
             buf.append('"');
-        } else if (version==1 && !isToken2(value,literals)) {
-            buf.append('"');
-            buf.append(escapeDoubleQuotes(value,0,value.length()));
-            buf.append('"');
-        }else {
+        } else {
             buf.append(value);
         }
-        return version;
     }
 
 
@@ -453,31 +333,5 @@ public class ServerCookie implements Serializable {
         return b.toString();
     }
 
-    /**
-     * Unescapes any double quotes in the given cookie value.
-     *
-     * @param bc The cookie value to modify
-     */
-    public static void unescapeDoubleQuotes(ByteChunk bc) {
-
-        if (bc == null || bc.getLength() == 0 || bc.indexOf('"', 0) == -1) {
-            return;
-        }
-
-        int src = bc.getStart();
-        int end = bc.getEnd();
-        int dest = src;
-        byte[] buffer = bc.getBuffer();
-        
-        while (src < end) {
-            if (buffer[src] == '\\' && src < end && buffer[src+1]  == '"') {
-                src++;
-            }
-            buffer[dest] = buffer[src];
-            dest ++;
-            src ++;
-        }
-        bc.setEnd(dest);
-    }
 }
 

==================================================
TestCookiesAllowHttpSeps.java
index 225946aebf..9445b4be3b 100644
--- a/test/org/apache/tomcat/util/http/TestCookiesAllowEquals.java
+++ b/test/org/apache/tomcat/util/http/TestCookiesAllowEquals.java
@@ -68,7 +68,7 @@ public class TestCookiesAllowEquals extends TomcatBaseTest{
             disconnect();
             reset();
             tomcat.stop();
-            assertTrue(response.contains(COOKIE_WITH_EQUALS));
+            assertEquals(COOKIE_WITH_EQUALS, response);
         }
         
         @Override

==================================================
TestCookiesDefaultSysProps.java
new file mode 100644
index 0000000000..28435b9725
--- /dev/null
+++ b/test/org/apache/tomcat/util/http/TestCookiesAllowHttpSeps.java
@@ -0,0 +1,99 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.util.http;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.catalina.core.StandardContext;
+import org.apache.catalina.startup.SimpleHttpClient;
+import org.apache.catalina.startup.TomcatBaseTest;
+import org.apache.catalina.startup.Tomcat;
+
+public class TestCookiesAllowHttpSeps extends TomcatBaseTest{
+
+    private static final String COOKIE_WITH_SEPS = "name=val(ue";
+    
+    public void testWithHttpSep() throws Exception {
+        System.setProperty(
+                "org.apache.tomcat.util.http.ServerCookie.ALLOW_HTTP_SEPARATORS_IN_V0",
+                "true");
+
+        TestCookieHttpSepClient client = new TestCookieHttpSepClient();
+        client.doRequest();
+    }
+    
+    private class TestCookieHttpSepClient extends SimpleHttpClient {
+
+
+        private void doRequest() throws Exception {
+            Tomcat tomcat = getTomcatInstance();
+            StandardContext root = tomcat.addContext("", TEMP_DIR);
+            Tomcat.addServlet(root, "Simple", new SimpleServlet());
+            root.addServletMapping("/test", "Simple");
+            
+            tomcat.start();
+            // Open connection
+            setPort(tomcat.getConnector().getPort());
+            connect();
+            
+            String[] request = new String[1];
+            request[0] =
+                "GET /test HTTP/1.0" + CRLF +
+                "Cookie: " + COOKIE_WITH_SEPS + CRLF + CRLF;
+            setRequest(request);
+            processRequest(true); // blocks until response has been read
+            String response = getResponseBody();
+            
+            // Close the connection
+            disconnect();
+            reset();
+            tomcat.stop();
+            assertEquals(COOKIE_WITH_SEPS, response);
+        }
+        
+        @Override
+        public boolean isResponseBodyOK() {
+            return true;
+        }
+        
+    }
+    
+    
+    private static class SimpleServlet extends HttpServlet {
+
+        private static final long serialVersionUID = 1L;
+
+        @Override
+        protected void service(HttpServletRequest req, HttpServletResponse resp)
+        throws ServletException, IOException {
+            Cookie cookies[] = req.getCookies();
+            for (Cookie cookie : cookies) {
+                resp.getWriter().write(cookie.getName() + "=" +
+                        cookie.getValue() + "\n");
+            }
+            resp.flushBuffer();
+        }
+        
+    }
+    
+}

==================================================
TestCookiesDisallowEquals.java
index 6f21116f07..de32d1921b 100644
--- a/test/org/apache/tomcat/util/http/TestCookiesDefaultSysProps.java
+++ b/test/org/apache/tomcat/util/http/TestCookiesDefaultSysProps.java
@@ -59,9 +59,7 @@ public class TestCookiesDefaultSysProps extends CookiesBaseTest {
         getUrl("http://localhost:" + getPort() + "/switch", res, headers);
         List<String> cookieHeaders = headers.get("Set-Cookie");
         for (String cookieHeader : cookieHeaders) {
-            if (cookieHeader.contains("name=")) {
-                assertTrue(cookieHeader.contains("name=\"val?ue\";"));
-            }
+            assertEquals("name=\"val?ue\"; Version=1", cookieHeader);
         }
 
     }

==================================================
TestCookiesNoFwdStrictSysProps.java
index 4efbb2c47a..4750892d86 100644
--- a/test/org/apache/tomcat/util/http/TestCookiesDisallowEquals.java
+++ b/test/org/apache/tomcat/util/http/TestCookiesDisallowEquals.java
@@ -65,7 +65,7 @@ public class TestCookiesDisallowEquals extends TomcatBaseTest{
             disconnect();
             reset();
             tomcat.stop();
-            assertTrue(response.contains(COOKIE_TRUNCATED));
+            assertEquals(COOKIE_TRUNCATED, response);
         }
         
         @Override

==================================================
TestCookiesStrictSysProps.java
index f7f18bd2d8..5995539981 100644
--- a/test/org/apache/tomcat/util/http/TestCookiesNoFwdStrictSysProps.java
+++ b/test/org/apache/tomcat/util/http/TestCookiesNoFwdStrictSysProps.java
@@ -51,7 +51,7 @@ public class TestCookiesNoFwdStrictSysProps extends CookiesBaseTest {
         res = getUrl("http://localhost:" + getPort() + "/invalidFwd");
         assertEquals("Cookie name ok", res.toString());
         res = getUrl("http://localhost:" + getPort() + "/invalidStrict");
-        assertEquals("Cookie name fail", res.toString());
+        assertEquals("Cookie name ok", res.toString()); // Will auto switch
         res = getUrl("http://localhost:" + getPort() + "/valid");
         assertEquals("Cookie name ok", res.toString());
 

==================================================
TestCookiesSwitchSysProps.java
index 4da3cdfd1c..74a1df1cc2 100644
--- a/test/org/apache/tomcat/util/http/TestCookiesStrictSysProps.java
+++ b/test/org/apache/tomcat/util/http/TestCookiesStrictSysProps.java
@@ -51,9 +51,9 @@ public class TestCookiesStrictSysProps extends CookiesBaseTest {
         res = getUrl("http://localhost:" + getPort() + "/blank");
         assertEquals("Cookie name fail", res.toString());
         res = getUrl("http://localhost:" + getPort() + "/invalidFwd");
-        assertEquals("Cookie name fail", res.toString());
+        assertEquals("Cookie name ok", res.toString()); // Will auto-switch
         res = getUrl("http://localhost:" + getPort() + "/invalidStrict");
-        assertEquals("Cookie name fail", res.toString());
+        assertEquals("Cookie name ok", res.toString()); // Will auto-switch
         res = getUrl("http://localhost:" + getPort() + "/valid");
         assertEquals("Cookie name ok", res.toString());
         
@@ -62,9 +62,7 @@ public class TestCookiesStrictSysProps extends CookiesBaseTest {
         getUrl("http://localhost:" + getPort() + "/switch", res, headers);
         List<String> cookieHeaders = headers.get("Set-Cookie");
         for (String cookieHeader : cookieHeaders) {
-            if (cookieHeader.contains("name=")) {
-                assertTrue(cookieHeader.contains("name=val?ue"));
-            }
+            assertEquals("name=\"val?ue\"; Version=1", cookieHeader);
         }
         
     }

==================================================
