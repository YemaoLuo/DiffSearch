376a308dbb1742f9fc88e693fb8100c44a8d7cf6
==================================================
Remove Comet
==================================================
Mark Emlyn
==================================================
Tue Nov 4 11:54:58 2014 +0000
==================================================
Globals.java
index 98727cb7b3..966a2a9f82 100644
--- a/conf/context.xml
+++ b/conf/context.xml
@@ -27,10 +27,4 @@
     <!--
     <Manager pathname="" />
     -->
-
-    <!-- Uncomment this to enable Comet connection tacking (provides events
-         on session expiration as well as webapp lifecycle) -->
-    <!--
-    <Valve className="org.apache.catalina.valves.CometConnectionManagerValve" />
-    -->
 </Context>

==================================================
Valve.java
index 30eea17a69..52cc15320a 100644
--- a/java/org/apache/catalina/Globals.java
+++ b/java/org/apache/catalina/Globals.java
@@ -136,41 +136,6 @@ public final class Globals {
         "org.apache.catalina.realm.GSS_CREDENTIAL";
 
 
-    /**
-     * The request attribute that is set to the value of {@code Boolean.TRUE}
-     * if connector processing this request supports Comet API.
-     * Duplicated here for neater code in the catalina packages.
-     */
-    public static final String COMET_SUPPORTED_ATTR =
-        org.apache.coyote.Constants.COMET_SUPPORTED_ATTR;
-
-
-    /**
-     * The request attribute that is set to the value of {@code Boolean.TRUE}
-     * if connector processing this request supports setting
-     * per-connection request timeout through Comet API.
-     *
-     * @see org.apache.catalina.comet.CometEvent#setTimeout(int)
-     *
-     * Duplicated here for neater code in the catalina packages.
-     */
-    public static final String COMET_TIMEOUT_SUPPORTED_ATTR =
-            org.apache.coyote.Constants.COMET_TIMEOUT_SUPPORTED_ATTR;
-
-
-    /**
-     * The request attribute that can be set to a value of type
-     * {@code java.lang.Integer} to specify per-connection request
-     * timeout for Comet API. The value is in milliseconds.
-     *
-     * @see org.apache.catalina.comet.CometEvent#setTimeout(int)
-     *
-     * Duplicated here for neater code in the catalina packages.
-     */
-    public static final String COMET_TIMEOUT_ATTR =
-        org.apache.coyote.Constants.COMET_TIMEOUT_ATTR;
-
-
     /**
      * The request attribute that is set to the value of {@code Boolean.TRUE}
      * if connector processing this request supports use of sendfile.

==================================================
CometEvent.java
index ac0af85b4d..fd05a7d9aa 100644
--- a/java/org/apache/catalina/Valve.java
+++ b/java/org/apache/catalina/Valve.java
@@ -14,20 +14,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina;
 
-
 import java.io.IOException;
 
 import javax.servlet.ServletException;
 
-import org.apache.catalina.comet.CometEvent;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
 
-
 /**
  * <p>A <b>Valve</b> is a request processing component associated with a
  * particular Container.  A series of Valves are generally associated with
@@ -123,22 +118,5 @@ public interface Valve {
         throws IOException, ServletException;
 
 
-    /**
-     * Process a Comet event.
-     *
-     * @param request The servlet request to be processed
-     * @param response The servlet response to be created
-     *
-     * @exception IOException if an input/output error occurs, or is thrown
-     *  by a subsequently invoked Valve, Filter, or Servlet
-     * @exception ServletException if a servlet error occurs, or is thrown
-     *  by a subsequently invoked Valve, Filter, or Servlet
-     */
-    public void event(Request request, Response response, CometEvent event)
-        throws IOException, ServletException;
-
-
     public boolean isAsyncSupported();
-
-
 }

==================================================
CometFilter.java
deleted file mode 100644
index 4cadc6c424..0000000000
--- a/java/org/apache/catalina/comet/CometEvent.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.comet;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-/**
- * The CometEvent interface.
- *
- * @author Remy Maucherat
- */
-public interface CometEvent {
-
-    /**
-     * Enumeration describing the major events that the container can invoke
-     * the CometProcessors event() method with.<br>
-     * BEGIN - will be called at the beginning
-     *  of the processing of the connection. It can be used to initialize any relevant
-     *  fields using the request and response objects. Between the end of the processing
-     *  of this event, and the beginning of the processing of the end or error events,
-     *  it is possible to use the response object to write data on the open connection.
-     *  Note that the response object and dependent OutputStream and Writer are still
-     *  not synchronized, so when they are accessed by multiple threads,
-     *  synchronization is mandatory. After processing the initial event, the request
-     *  is considered to be committed.<br>
-     * READ - This indicates that input data is available, and that one read can be made
-     *  without blocking. The available and ready methods of the InputStream or
-     *  Reader may be used to determine if there is a risk of blocking: the servlet
-     *  should read while data is reported available. When encountering a read error,
-     *  the servlet should report it by propagating the exception properly. Throwing
-     *  an exception will cause the error event to be invoked, and the connection
-     *  will be closed.
-     *  Alternately, it is also possible to catch any exception, perform clean up
-     *  on any data structure the servlet may be using, and using the close method
-     *  of the event. It is not allowed to attempt reading data from the request
-     *  object outside of the execution of this method.<br>
-     * END - End may be called to end the processing of the request. Fields that have
-     *  been initialized in the begin method should be reset. After this event has
-     *  been processed, the request and response objects, as well as all their dependent
-     *  objects will be recycled and used to process other requests. End will also be
-     *  called when data is available and the end of file is reached on the request input
-     *  (this usually indicates the client has pipelined a request).<br>
-     * ERROR - Error will be called by the container in the case where an IO exception
-     *  or a similar unrecoverable error occurs on the connection. Fields that have
-     *  been initialized in the begin method should be reset. After this event has
-     *  been processed, the request and response objects, as well as all their dependent
-     *  objects will be recycled and used to process other requests.
-     */
-    public enum EventType {BEGIN, READ, END, ERROR}
-
-
-    /**
-     * Event details.<br>
-     * TIMEOUT - the connection timed out (sub type of ERROR); note that this ERROR type is not fatal, and
-     *   the connection will not be closed unless the servlet uses the close method of the event<br>
-     * CLIENT_DISCONNECT - the client connection was closed (sub type of ERROR)<br>
-     * IOEXCEPTION - an IO exception occurred, such as invalid content, for example, an invalid chunk block (sub type of ERROR)<br>
-     * WEBAPP_RELOAD - the webapplication is being reloaded (sub type of END)<br>
-     * SERVER_SHUTDOWN - the server is shutting down (sub type of END)<br>
-     * SESSION_END - the servlet ended the session (sub type of END)
-     */
-    public enum EventSubType { TIMEOUT, CLIENT_DISCONNECT, IOEXCEPTION, WEBAPP_RELOAD, SERVER_SHUTDOWN, SESSION_END }
-
-
-    /**
-     * Returns the HttpServletRequest.
-     *
-     * @return HttpServletRequest
-     */
-    public HttpServletRequest getHttpServletRequest();
-
-    /**
-     * Returns the HttpServletResponse.
-     *
-     * @return HttpServletResponse
-     */
-    public HttpServletResponse getHttpServletResponse();
-
-    /**
-     * Returns the event type.
-     *
-     * @return EventType
-     */
-    public EventType getEventType();
-
-    /**
-     * Returns the sub type of this event.
-     *
-     * @return EventSubType
-     */
-    public EventSubType getEventSubType();
-
-    /**
-     * Ends the Comet session. This signals to the container that
-     * the container wants to end the comet session. This will send back to the
-     * client a notice that the server has no more data to send as part of this
-     * request. The servlet should perform any needed cleanup as if it had received
-     * an END or ERROR event.
-     *
-     * @throws IOException if an IO exception occurs
-     */
-    public void close() throws IOException;
-
-    /**
-     * Sets the timeout for this Comet connection. Please NOTE, that the implementation
-     * of a per connection timeout is OPTIONAL and MAY NOT be implemented.<br>
-     * This method sets the timeout in milliseconds of idle time on the connection.
-     * The timeout is reset every time data is received from the connection or data is flushed
-     * using <code>response.flushBuffer()</code>. If a timeout occurs, the
-     * <code>error(HttpServletRequest, HttpServletResponse)</code> method is invoked. The
-     * web application SHOULD NOT attempt to reuse the request and response objects after a timeout
-     * as the <code>error(HttpServletRequest, HttpServletResponse)</code> method indicates.<br>
-     * This method should not be called asynchronously, as that will have no effect.
-     *
-     * @param timeout The timeout in milliseconds for this connection, must be a positive value, larger than 0
-     * @throws IOException An IOException may be thrown to indicate an IO error,
-     *         or that the EOF has been reached on the connection
-     * @throws ServletException An exception has occurred, as specified by the root
-     *         cause
-     * @throws UnsupportedOperationException if per connection timeout is not supported, either at all or at this phase
-     *         of the invocation.
-     */
-    public void setTimeout(int timeout)
-        throws IOException, ServletException, UnsupportedOperationException;
-
-}

==================================================
CometFilterChain.java
deleted file mode 100644
index ffb0d1c2ce..0000000000
--- a/java/org/apache/catalina/comet/CometFilter.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.comet;
-
-import java.io.IOException;
-
-import javax.servlet.Filter;
-import javax.servlet.ServletException;
-
-/**
- * A Comet filter, similar to regular filters, performs filtering tasks on either
- * the request to a resource (a Comet servlet), or on the response from a resource, or both.
- * <br><br>
- * Filters perform filtering in the <code>doFilterEvent</code> method. Every Filter has access to
- * a FilterConfig object from which it can obtain its initialization parameters, a
- * reference to the ServletContext which it can use, for example, to load resources
- * needed for filtering tasks.
- * <p>
- * Filters are configured in the deployment descriptor of a web application
- * <p>
- * Examples that have been identified for this design are<br>
- * 1) Authentication Filters <br>
- * 2) Logging and Auditing Filters <br>
- * 3) Image conversion Filters <br>
- * 4) Data compression Filters <br>
- * 5) Encryption Filters <br>
- * 6) Tokenizing Filters <br>
- * 7) Filters that trigger resource access events <br>
- * 8) XSL/T filters <br>
- * 9) Mime-type chain Filter <br>
- * <br>
- *
- * @author Remy Maucherat
- */
-public interface CometFilter extends Filter {
-
-
-    /**
-     * The <code>doFilterEvent</code> method of the CometFilter is called by the container
-     * each time a request/response pair is passed through the chain due
-     * to a client event for a resource at the end of the chain. The CometFilterChain passed in to this
-     * method allows the Filter to pass on the event to the next entity in the
-     * chain.<p>
-     * A typical implementation of this method would follow the following pattern:- <br>
-     * 1. Examine the request<br>
-     * 2. Optionally wrap the request object contained in the event with a custom implementation to
-     * filter content or headers for input filtering and pass a CometEvent instance containing
-     * the wrapped request to the next filter<br>
-     * 3. Optionally wrap the response object contained in the event with a custom implementation to
-     * filter content or headers for output filtering and pass a CometEvent instance containing
-     * the wrapped request to the next filter<br>
-     * 4. a) <strong>Either</strong> invoke the next entity in the chain using the CometFilterChain object (<code>chain.doFilterEvent()</code>), <br>
-     * 4. b) <strong>or</strong> not pass on the request/response pair to the next entity in the filter chain to block the event processing<br>
-     * 5. Directly set fields on the response after invocation of the next entity in the filter chain.
-     *
-     * @param event the event that is being processed. Another event may be passed along the chain.
-     * @param chain
-     * @throws IOException
-     * @throws ServletException
-     */
-    public void doFilterEvent(CometEvent event, CometFilterChain chain)
-        throws IOException, ServletException;
-
-
-}

==================================================
CometProcessor.java
deleted file mode 100644
index 68ff5f1ccb..0000000000
--- a/java/org/apache/catalina/comet/CometFilterChain.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.comet;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-
-/**
- * A CometFilterChain is an object provided by the servlet container to the developer
- * giving a view into the invocation chain of a filtered event for a resource. Filters
- * use the CometFilterChain to invoke the next filter in the chain, or if the calling filter
- * is the last filter in the chain, to invoke the resource at the end of the chain.
- *
- * @author Remy Maucherat
- */
-public interface CometFilterChain {
-
-
-    /**
-     * Causes the next filter in the chain to be invoked, or if the calling filter is the last filter
-     * in the chain, causes the resource at the end of the chain to be invoked.
-     *
-     * @param event the event to pass along the chain.
-     */
-    public void doFilterEvent(CometEvent event) throws IOException, ServletException;
-
-
-}

==================================================
CometEventImpl.java
deleted file mode 100644
index 4e22f8d2b9..0000000000
--- a/java/org/apache/catalina/comet/CometProcessor.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.comet;
-
-import java.io.IOException;
-
-import javax.servlet.Servlet;
-import javax.servlet.ServletException;
-
-/**
- * This interface should be implemented by servlets which would like to handle
- * asynchronous IO, receiving events when data is available for reading, and
- * being able to output data without the need for being invoked by the container.
- * Note: When this interface is implemented, the service method of the servlet will
- * never be called, and will be replaced with a begin event.
- */
-public interface CometProcessor extends Servlet{
-
-    /**
-     * Process the given Comet event.
-     *
-     * @param event The Comet event that will be processed
-     * @throws IOException
-     * @throws ServletException
-     */
-    public void event(CometEvent event)
-        throws IOException, ServletException;
-
-}

==================================================
CoyoteAdapter.java
deleted file mode 100644
index 97c54b14f0..0000000000
--- a/java/org/apache/catalina/connector/CometEventImpl.java
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.connector;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.catalina.Globals;
-import org.apache.catalina.comet.CometEvent;
-import org.apache.tomcat.util.res.StringManager;
-
-public class CometEventImpl implements CometEvent {
-
-
-    /**
-     * The string manager for this package.
-     */
-    protected static final StringManager sm =
-        StringManager.getManager(Constants.Package);
-
-
-    public CometEventImpl(Request request, Response response) {
-        this.request = request;
-        this.response = response;
-    }
-
-
-    // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * Associated request.
-     */
-    protected Request request = null;
-
-
-    /**
-     * Associated response.
-     */
-    protected Response response = null;
-
-
-    /**
-     * Event type.
-     */
-    protected EventType eventType = EventType.BEGIN;
-
-
-    /**
-     * Event sub type.
-     */
-    protected EventSubType eventSubType = null;
-
-
-    // --------------------------------------------------------- Public Methods
-
-    /**
-     * Clear the event.
-     */
-    public void clear() {
-        request = null;
-        response = null;
-    }
-
-    public void setEventType(EventType eventType) {
-        this.eventType = eventType;
-    }
-
-    public void setEventSubType(EventSubType eventSubType) {
-        this.eventSubType = eventSubType;
-    }
-
-    @Override
-    public void close() throws IOException {
-        if (request == null) {
-            throw new IllegalStateException(sm.getString("cometEvent.nullRequest"));
-        }
-        request.finishRequest();
-        response.finishResponse();
-        if (request.isComet()) {
-            request.cometClose();
-        }
-    }
-
-    @Override
-    public EventSubType getEventSubType() {
-        return eventSubType;
-    }
-
-    @Override
-    public EventType getEventType() {
-        return eventType;
-    }
-
-    @Override
-    public HttpServletRequest getHttpServletRequest() {
-        return request.getRequest();
-    }
-
-    @Override
-    public HttpServletResponse getHttpServletResponse() {
-        return response.getResponse();
-    }
-
-    @Override
-    public void setTimeout(int timeout) throws IOException, ServletException,
-            UnsupportedOperationException {
-        if (request.getAttribute(Globals.COMET_TIMEOUT_SUPPORTED_ATTR) ==
-                Boolean.TRUE) {
-            request.setAttribute(Globals.COMET_TIMEOUT_ATTR,
-                    Integer.valueOf(timeout));
-            if (request.isComet()) {
-                request.setCometTimeout(timeout);
-            }
-        } else {
-            throw new UnsupportedOperationException();
-        }
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder buf = new StringBuilder();
-        buf.append(super.toString());
-        buf.append("[EventType:");
-        buf.append(eventType);
-        buf.append(", EventSubType:");
-        buf.append(eventSubType);
-        buf.append("]");
-        return buf.toString();
-    }
-
-}

==================================================
InputBuffer.java
index 9c7e17886f..689b280145 100644
--- a/java/org/apache/catalina/connector/CoyoteAdapter.java
+++ b/java/org/apache/catalina/connector/CoyoteAdapter.java
@@ -31,8 +31,6 @@ import javax.servlet.http.HttpServletResponse;
 import org.apache.catalina.Context;
 import org.apache.catalina.Host;
 import org.apache.catalina.Wrapper;
-import org.apache.catalina.comet.CometEvent;
-import org.apache.catalina.comet.CometEvent.EventType;
 import org.apache.catalina.core.AsyncContextImpl;
 import org.apache.catalina.util.ServerInfo;
 import org.apache.catalina.util.SessionConfig;
@@ -147,135 +145,6 @@ public class CoyoteAdapter implements Adapter {
 
     // -------------------------------------------------------- Adapter Methods
 
-
-    /**
-     * Event method.
-     *
-     * @return false to indicate an error, expected or not
-     */
-    @Override
-    public boolean event(org.apache.coyote.Request req,
-            org.apache.coyote.Response res, SocketStatus status) {
-
-        Request request = (Request) req.getNote(ADAPTER_NOTES);
-        Response response = (Response) res.getNote(ADAPTER_NOTES);
-
-        if (request.getWrapper() == null) {
-            return false;
-        }
-
-        boolean error = false;
-        boolean read = false;
-        try {
-            if (status == SocketStatus.OPEN_READ) {
-                if (response.isClosed()) {
-                    // The event has been closed asynchronously, so call end instead of
-                    // read to cleanup the pipeline
-                    request.getEvent().setEventType(CometEvent.EventType.END);
-                    request.getEvent().setEventSubType(null);
-                } else {
-                    try {
-                        // Fill the read buffer of the servlet layer
-                        if (request.read()) {
-                            read = true;
-                        }
-                    } catch (IOException e) {
-                        error = true;
-                    }
-                    if (read) {
-                        request.getEvent().setEventType(CometEvent.EventType.READ);
-                        request.getEvent().setEventSubType(null);
-                    } else if (error) {
-                        request.getEvent().setEventType(CometEvent.EventType.ERROR);
-                        request.getEvent().setEventSubType(CometEvent.EventSubType.CLIENT_DISCONNECT);
-                    } else {
-                        request.getEvent().setEventType(CometEvent.EventType.END);
-                        request.getEvent().setEventSubType(null);
-                    }
-                }
-            } else if (status == SocketStatus.DISCONNECT) {
-                request.getEvent().setEventType(CometEvent.EventType.ERROR);
-                request.getEvent().setEventSubType(CometEvent.EventSubType.CLIENT_DISCONNECT);
-                error = true;
-            } else if (status == SocketStatus.ERROR) {
-                request.getEvent().setEventType(CometEvent.EventType.ERROR);
-                request.getEvent().setEventSubType(CometEvent.EventSubType.IOEXCEPTION);
-                error = true;
-            } else if (status == SocketStatus.STOP) {
-                request.getEvent().setEventType(CometEvent.EventType.END);
-                request.getEvent().setEventSubType(CometEvent.EventSubType.SERVER_SHUTDOWN);
-            } else if (status == SocketStatus.TIMEOUT) {
-                if (response.isClosed()) {
-                    // The event has been closed asynchronously, so call end instead of
-                    // read to cleanup the pipeline
-                    request.getEvent().setEventType(CometEvent.EventType.END);
-                    request.getEvent().setEventSubType(null);
-                } else {
-                    request.getEvent().setEventType(CometEvent.EventType.ERROR);
-                    request.getEvent().setEventSubType(CometEvent.EventSubType.TIMEOUT);
-                }
-            }
-
-            req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());
-
-            // Calling the container
-            connector.getService().getContainer().getPipeline().getFirst().event(request, response, request.getEvent());
-
-            if (!error && !response.isClosed() && (request.getAttribute(
-                    RequestDispatcher.ERROR_EXCEPTION) != null)) {
-                // An unexpected exception occurred while processing the event, so
-                // error should be called
-                request.getEvent().setEventType(CometEvent.EventType.ERROR);
-                request.getEvent().setEventSubType(null);
-                error = true;
-                connector.getService().getContainer().getPipeline().getFirst().event(request, response, request.getEvent());
-            }
-            if (response.isClosed() || !request.isComet()) {
-                if (status==SocketStatus.OPEN_READ &&
-                        request.getEvent().getEventType() != EventType.END) {
-                    //CometEvent.close was called during an event other than END
-                    request.getEvent().setEventType(CometEvent.EventType.END);
-                    request.getEvent().setEventSubType(null);
-                    error = true;
-                    connector.getService().getContainer().getPipeline().getFirst().event(request, response, request.getEvent());
-                }
-                res.action(ActionCode.COMET_END, null);
-            } else if (!error && read && request.getAvailable()) {
-                // If this was a read and not all bytes have been read, or if no data
-                // was read from the connector, then it is an error
-                request.getEvent().setEventType(CometEvent.EventType.ERROR);
-                request.getEvent().setEventSubType(CometEvent.EventSubType.IOEXCEPTION);
-                error = true;
-                connector.getService().getContainer().getPipeline().getFirst().event(request, response, request.getEvent());
-            }
-            return (!error);
-        } catch (Throwable t) {
-            ExceptionUtils.handleThrowable(t);
-            if (!(t instanceof IOException)) {
-                log.error(sm.getString("coyoteAdapter.service"), t);
-            }
-            error = true;
-            return false;
-        } finally {
-            req.getRequestProcessor().setWorkerThreadName(null);
-            // Recycle the wrapper request and response
-            if (error || response.isClosed() || !request.isComet()) {
-                if (request.getMappingData().context != null) {
-                    request.getMappingData().context.logAccess(
-                            request, response,
-                            System.currentTimeMillis() - req.getStartTime(),
-                            false);
-                } else {
-                    // Should normally not happen
-                    log(req, res, System.currentTimeMillis() - req.getStartTime());
-                }
-                request.recycle();
-                request.setFilterChain(null);
-                response.recycle();
-            }
-        }
-    }
-
     @Override
     public boolean asyncDispatch(org.apache.coyote.Request req,
             org.apache.coyote.Response res, SocketStatus status) throws Exception {
@@ -286,12 +155,11 @@ public class CoyoteAdapter implements Adapter {
             throw new IllegalStateException(
                     "Dispatch may only happen on an existing request.");
         }
-        boolean comet = false;
         boolean success = true;
         AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();
         req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());
         try {
-            if (!request.isAsync() && !comet) {
+            if (!request.isAsync()) {
                 // Error or timeout - need to tell listeners the request is over
                 // Have to test this first since state may change while in this
                 // method and this is only required if entering this method in
@@ -414,25 +282,7 @@ public class CoyoteAdapter implements Adapter {
                 }
             }
 
-            if (request.isComet()) {
-                if (!response.isClosed() && !response.isError()) {
-                    if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) {
-                        // Invoke a read event right away if there are available bytes
-                        if (event(req, res, SocketStatus.OPEN_READ)) {
-                            comet = true;
-                            res.action(ActionCode.COMET_BEGIN, null);
-                        }
-                    } else {
-                        comet = true;
-                        res.action(ActionCode.COMET_BEGIN, null);
-                    }
-                } else {
-                    // Clear the filter chain, as otherwise it will not be reset elsewhere
-                    // since this is a Comet request
-                    request.setFilterChain(null);
-                }
-            }
-            if (!request.isAsync() && !comet) {
+            if (!request.isAsync()) {
                 request.finishRequest();
                 response.finishResponse();
                 if (request.getMappingData().context != null) {
@@ -471,7 +321,7 @@ public class CoyoteAdapter implements Adapter {
             }
             req.getRequestProcessor().setWorkerThreadName(null);
             // Recycle the wrapper request and response
-            if (!success || (!comet && !request.isAsync())) {
+            if (!success || !request.isAsync()) {
                 request.recycle();
                 response.recycle();
             } else {
@@ -521,7 +371,6 @@ public class CoyoteAdapter implements Adapter {
             response.addHeader("X-Powered-By", POWERED_BY);
         }
 
-        boolean comet = false;
         boolean async = false;
 
         try {
@@ -535,26 +384,6 @@ public class CoyoteAdapter implements Adapter {
                 request.setAsyncSupported(connector.getService().getContainer().getPipeline().isAsyncSupported());
                 // Calling the container
                 connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
-
-                if (request.isComet()) {
-                    if (!response.isClosed() && !response.isError()) {
-                        if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) {
-                            // Invoke a read event right away if there are available bytes
-                            if (event(req, res, SocketStatus.OPEN_READ)) {
-                                comet = true;
-                                res.action(ActionCode.COMET_BEGIN, null);
-                            }
-                        } else {
-                            comet = true;
-                            res.action(ActionCode.COMET_BEGIN, null);
-                        }
-                    } else {
-                        // Clear the filter chain, as otherwise it will not be reset elsewhere
-                        // since this is a Comet request
-                        request.setFilterChain(null);
-                    }
-                }
-
             }
             AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();
             if (asyncConImpl != null) {
@@ -573,15 +402,12 @@ public class CoyoteAdapter implements Adapter {
                         request.getContext().unbind(false, oldCL);
                     }
                 }
-            } else if (!comet) {
+            } else {
                 request.finishRequest();
                 response.finishResponse();
-                if (postParseSuccess &&
-                        request.getMappingData().context != null) {
+                if (postParseSuccess) {
                     // Log only if processing was invoked.
                     // If postParseRequest() failed, it has already logged it.
-                    // If context is null this was the start of a comet request
-                    // that failed and has already been logged.
                     request.getMappingData().context.logAccess(
                             request, response,
                             System.currentTimeMillis() - req.getStartTime(),
@@ -596,7 +422,7 @@ public class CoyoteAdapter implements Adapter {
             AtomicBoolean error = new AtomicBoolean(false);
             res.action(ActionCode.IS_ERROR, error);
             // Recycle the wrapper request and response
-            if (!comet && !async || error.get()) {
+            if (!async || error.get()) {
                 request.recycle();
                 response.recycle();
             } else {

==================================================
OutputBuffer.java
index 229984c448..0b49c9ea72 100644
--- a/java/org/apache/catalina/connector/LocalStrings_es.properties
+++ b/java/org/apache/catalina/connector/LocalStrings_es.properties
@@ -51,7 +51,6 @@ coyoteRequest.uploadLocationInvalid = No es v\u00E1lida la localizaci\u00F3n [{0
 coyoteRequest.sessionEndAccessFail = Excepci\u00F3n disparada acabando acceso a sesi\u00F3n mientras se reciclaba el requerimiento
 requestFacade.nullRequest = El objeto de requerimiento ha sido reciclado y ya no est\u00E1 asociado con esta fachada
 responseFacade.nullResponse = El objeto de respuesta ha sido reciclado y ya no est\u00E1 asociado con esta fachada
-cometEvent.nullRequest = El objeto de evento ha sido reciclado y ya no est\u00E1 asociado con este requerimiento
 mapperListener.unknownDefaultHost = M\u00E1quina por defecto desconocida\: {0} para el conector [{1}]
 mapperListener.registerHost = Registrar m\u00E1quina {0} en dominio {1} para el conector [{2}]
 mapperListener.unregisterHost = Desregistrar m\u00E1quina {0} en dominio {1} para el conector [{2}]

==================================================
Request.java
index 4a32650615..d22ed56fca 100644
--- a/java/org/apache/catalina/connector/OutputBuffer.java
+++ b/java/org/apache/catalina/connector/OutputBuffer.java
@@ -249,7 +249,7 @@ public class OutputBuffer extends Writer
 
 
     /**
-     * Clear cached encoders (to save memory for Comet requests).
+     * Clear cached encoders (to save memory for async requests).
      */
     public void clearEncoders() {
         encoders.clear();

==================================================
Response.java
index e6331a7a55..ee36be8bb3 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -222,18 +222,6 @@ public class Request
     protected String authType = null;
 
 
-    /**
-     * Associated event.
-     */
-    protected CometEventImpl event = null;
-
-
-    /**
-     * Comet state
-     */
-    protected boolean comet = false;
-
-
     /**
      * The current dispatcher type.
      */
@@ -446,12 +434,6 @@ public class Request
         internalDispatcherType = null;
         requestDispatcherPath = null;
 
-        comet = false;
-        if (event != null) {
-            event.clear();
-            event = null;
-        }
-
         authType = null;
         inputBuffer.recycle();
         usingInputStream = false;
@@ -534,7 +516,7 @@ public class Request
     }
 
     /**
-     * Clear cached encoders (to save memory for Comet requests).
+     * Clear cached encoders (to save memory for async requests).
      */
     public void clearEncoders() {
         inputBuffer.clearEncoders();
@@ -542,7 +524,7 @@ public class Request
 
 
     /**
-     * Clear cached encoders (to save memory for Comet requests).
+     * Clear cached encoders (to save memory for async requests).
      */
     public boolean read()
         throws IOException {
@@ -949,8 +931,6 @@ public class Request
      * have names starting with "org.apache.tomcat" and include:
      * <ul>
      * <li>{@link Globals#SENDFILE_SUPPORTED_ATTR}</li>
-     * <li>{@link Globals#COMET_SUPPORTED_ATTR}</li>
-     * <li>{@link Globals#COMET_TIMEOUT_SUPPORTED_ATTR}</li>
      * </ul>
      * Connector implementations may return some, all or none of these
      * attributes and may also support additional attributes.
@@ -2454,33 +2434,6 @@ public class Request
     }
 
 
-    /**
-     * Get the event associated with the request.
-     * @return the event
-     */
-    public CometEventImpl getEvent() {
-        if (event == null) {
-            event = new CometEventImpl(this, response);
-        }
-        return event;
-    }
-
-
-    /**
-     * Return true if the current request is handling Comet traffic.
-     */
-    public boolean isComet() {
-        return comet;
-    }
-
-
-    /**
-     * Set comet state.
-     */
-    public void setComet(boolean comet) {
-        this.comet = comet;
-    }
-
     /**
      * return true if we have parsed parameters
      */
@@ -2515,15 +2468,6 @@ public class Request
         }
     }
 
-    public void cometClose() {
-        coyoteRequest.action(ActionCode.COMET_CLOSE,getEvent());
-        setComet(false);
-    }
-
-    public void setCometTimeout(long timeout) {
-        coyoteRequest.action(ActionCode.COMET_SETTIMEOUT, Long.valueOf(timeout));
-    }
-
     /**
      * @throws IOException If an I/O error occurs
      * @throws IllegalStateException If the response has been committed
@@ -3281,32 +3225,6 @@ public class Request
                         return null;
                     }
 
-                    @Override
-                    public void set(Request request, String name, Object value) {
-                        // NO-OP
-                    }
-                });
-        specialAttributes.put(Globals.COMET_SUPPORTED_ATTR,
-                new SpecialAttributeAdapter() {
-                    @Override
-                    public Object get(Request request, String name) {
-                        return Boolean.valueOf(
-                                request.getConnector().getProtocolHandler(
-                                        ).isCometSupported());
-                    }
-                    @Override
-                    public void set(Request request, String name, Object value) {
-                        // NO-OP
-                    }
-                });
-        specialAttributes.put(Globals.COMET_TIMEOUT_SUPPORTED_ATTR,
-                new SpecialAttributeAdapter() {
-                    @Override
-                    public Object get(Request request, String name) {
-                        return Boolean.valueOf(
-                                request.getConnector().getProtocolHandler(
-                                        ).isCometTimeoutSupported());
-                    }
                     @Override
                     public void set(Request request, String name, Object value) {
                         // NO-OP

==================================================
ApplicationFilterChain.java
index 87395a4618..ca3fff7e25 100644
--- a/java/org/apache/catalina/connector/Response.java
+++ b/java/org/apache/catalina/connector/Response.java
@@ -289,7 +289,7 @@ public class Response
 
 
     /**
-     * Clear cached encoders (to save memory for Comet requests).
+     * Clear cached encoders (to save memory for async requests).
      */
     public void clearEncoders() {
         outputBuffer.clearEncoders();

==================================================
ApplicationFilterFactory.java
index fefcf75c84..7fffb2416d 100644
--- a/java/org/apache/catalina/core/ApplicationFilterChain.java
+++ b/java/org/apache/catalina/core/ApplicationFilterChain.java
@@ -14,11 +14,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.core;
 
-
 import java.io.IOException;
 import java.security.Principal;
 import java.security.PrivilegedActionException;
@@ -34,10 +31,6 @@ import javax.servlet.http.HttpServletResponse;
 
 import org.apache.catalina.Globals;
 import org.apache.catalina.InstanceEvent;
-import org.apache.catalina.comet.CometEvent;
-import org.apache.catalina.comet.CometFilter;
-import org.apache.catalina.comet.CometFilterChain;
-import org.apache.catalina.comet.CometProcessor;
 import org.apache.catalina.security.SecurityUtil;
 import org.apache.catalina.util.InstanceSupport;
 import org.apache.tomcat.util.ExceptionUtils;
@@ -52,7 +45,7 @@ import org.apache.tomcat.util.res.StringManager;
  *
  * @author Craig R. McClanahan
  */
-final class ApplicationFilterChain implements FilterChain, CometFilterChain {
+final class ApplicationFilterChain implements FilterChain {
 
     // Used to enforce requirements of SRV.8.2 / SRV.14.2.5.1
     private static final ThreadLocal<ServletRequest> lastServicedRequest;
@@ -144,24 +137,9 @@ final class ApplicationFilterChain implements FilterChain, CometFilterChain {
     private static final Class<?>[] classTypeUsedInService = new Class[]{
         ServletRequest.class, ServletResponse.class};
 
-    /**
-     * Static class array used when the SecurityManager is turned on and
-     * <code>doFilterEvent</code> is invoked.
-     */
-    private static final Class<?>[] cometClassType =
-        new Class[]{ CometEvent.class, CometFilterChain.class};
-
-    /**
-     * Static class array used when the SecurityManager is turned on and
-     * <code>event</code> is invoked.
-     */
-    private static final Class<?>[] classTypeUsedInEvent =
-        new Class[] { CometEvent.class };
-
 
     // ---------------------------------------------------- FilterChain Methods
 
-
     /**
      * Invoke the next filter in this chain, passing the specified request
      * and response.  If there are no more filters in this chain, invoke
@@ -323,48 +301,6 @@ final class ApplicationFilterChain implements FilterChain, CometFilterChain {
     }
 
 
-    /**
-     * Process the event, using the security manager if the option is enabled.
-     *
-     * @param event the event to process
-     *
-     * @exception IOException if an input/output error occurs
-     * @exception ServletException if a servlet exception occurs
-     */
-    @Override
-    public void doFilterEvent(CometEvent event)
-        throws IOException, ServletException {
-
-        if( Globals.IS_SECURITY_ENABLED ) {
-            final CometEvent ev = event;
-            try {
-                java.security.AccessController.doPrivileged(
-                    new java.security.PrivilegedExceptionAction<Void>() {
-                        @Override
-                        public Void run()
-                            throws ServletException, IOException {
-                            internalDoFilterEvent(ev);
-                            return null;
-                        }
-                    }
-                );
-            } catch( PrivilegedActionException pe) {
-                Exception e = pe.getException();
-                if (e instanceof ServletException)
-                    throw (ServletException) e;
-                else if (e instanceof IOException)
-                    throw (IOException) e;
-                else if (e instanceof RuntimeException)
-                    throw (RuntimeException) e;
-                else
-                    throw new ServletException(e.getMessage(), e);
-            }
-        } else {
-            internalDoFilterEvent(event);
-        }
-    }
-
-
     /**
      * The last request passed to a servlet for servicing from the current
      * thread.
@@ -387,125 +323,8 @@ final class ApplicationFilterChain implements FilterChain, CometFilterChain {
     }
 
 
-    private void internalDoFilterEvent(CometEvent event)
-        throws IOException, ServletException {
-
-        // Call the next filter if there is one
-        if (pos < n) {
-            ApplicationFilterConfig filterConfig = filters[pos++];
-            CometFilter filter = null;
-            try {
-                filter = (CometFilter) filterConfig.getFilter();
-                // FIXME: No instance listener processing for events for now
-                /*
-                support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT,
-                        filter, event);
-                        */
-
-                if( Globals.IS_SECURITY_ENABLED ) {
-                    final CometEvent ev = event;
-                    Principal principal =
-                        ev.getHttpServletRequest().getUserPrincipal();
-
-                    Object[] args = new Object[]{ev, this};
-                    SecurityUtil.doAsPrivilege("doFilterEvent", filter,
-                            cometClassType, args, principal);
-
-                } else {
-                    filter.doFilterEvent(event, this);
-                }
-
-                /*support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,
-                        filter, event);*/
-            } catch (IOException e) {
-                /*
-                if (filter != null)
-                    support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,
-                            filter, event, e);
-                            */
-                throw e;
-            } catch (ServletException e) {
-                /*
-                if (filter != null)
-                    support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,
-                            filter, event, e);
-                            */
-                throw e;
-            } catch (RuntimeException e) {
-                /*
-                if (filter != null)
-                    support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,
-                            filter, event, e);
-                            */
-                throw e;
-            } catch (Throwable e) {
-                e = ExceptionUtils.unwrapInvocationTargetException(e);
-                ExceptionUtils.handleThrowable(e);
-                /*if (filter != null)
-                    support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,
-                            filter, event, e);*/
-                throw new ServletException
-                    (sm.getString("filterChain.filter"), e);
-            }
-            return;
-        }
-
-        // We fell off the end of the chain -- call the servlet instance
-        try {
-            /*
-            support.fireInstanceEvent(InstanceEvent.BEFORE_SERVICE_EVENT,
-                    servlet, request, response);
-                    */
-            if( Globals.IS_SECURITY_ENABLED ) {
-                final CometEvent ev = event;
-                Principal principal =
-                    ev.getHttpServletRequest().getUserPrincipal();
-                Object[] args = new Object[]{ ev };
-                SecurityUtil.doAsPrivilege("event",
-                        servlet,
-                        classTypeUsedInEvent,
-                        args,
-                        principal);
-            } else {
-                ((CometProcessor) servlet).event(event);
-            }
-            /*
-            support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,
-                    servlet, request, response);*/
-        } catch (IOException e) {
-            /*
-            support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,
-                    servlet, request, response, e);
-                    */
-            throw e;
-        } catch (ServletException e) {
-            /*
-            support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,
-                    servlet, request, response, e);
-                    */
-            throw e;
-        } catch (RuntimeException e) {
-            /*
-            support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,
-                    servlet, request, response, e);
-                    */
-            throw e;
-        } catch (Throwable e) {
-            ExceptionUtils.handleThrowable(e);
-            /*
-            support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,
-                    servlet, request, response, e);
-                    */
-            throw new ServletException
-                (sm.getString("filterChain.servlet"), e);
-        }
-
-    }
-
-
     // -------------------------------------------------------- Package Methods
 
-
     /**
      * Add a filter to the set of filters that will be executed in this chain.
      *

==================================================
StandardContextValve.java
index 2142530ba3..d8c9978a3a 100644
--- a/java/org/apache/catalina/core/ApplicationFilterFactory.java
+++ b/java/org/apache/catalina/core/ApplicationFilterFactory.java
@@ -22,9 +22,7 @@ import javax.servlet.ServletRequest;
 
 import org.apache.catalina.Globals;
 import org.apache.catalina.Wrapper;
-import org.apache.catalina.comet.CometFilter;
 import org.apache.catalina.connector.Request;
-import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.descriptor.web.FilterMap;
 
 /**
@@ -87,19 +85,13 @@ public final class ApplicationFilterFactory {
         if (servlet == null)
             return (null);
 
-        boolean comet = false;
-
         // Create and initialize a filter chain object
         ApplicationFilterChain filterChain = null;
         if (request instanceof Request) {
             Request req = (Request) request;
-            comet = req.isComet();
             if (Globals.IS_SECURITY_ENABLED) {
                 // Security: Do not recycle
                 filterChain = new ApplicationFilterChain();
-                if (comet) {
-                    req.setFilterChain(filterChain);
-                }
             } else {
                 filterChain = (ApplicationFilterChain) req.getFilterChain();
                 if (filterChain == null) {
@@ -141,23 +133,7 @@ public final class ApplicationFilterFactory {
                 // FIXME - log configuration problem
                 continue;
             }
-            boolean isCometFilter = false;
-            if (comet) {
-                try {
-                    isCometFilter = filterConfig.getFilter() instanceof CometFilter;
-                } catch (Exception e) {
-                    // Note: The try catch is there because getFilter has a lot of
-                    // declared exceptions. However, the filter is allocated much
-                    // earlier
-                    Throwable t = ExceptionUtils.unwrapInvocationTargetException(e);
-                    ExceptionUtils.handleThrowable(t);
-                }
-                if (isCometFilter) {
-                    filterChain.addFilter(filterConfig);
-                }
-            } else {
-                filterChain.addFilter(filterConfig);
-            }
+            filterChain.addFilter(filterConfig);
         }
 
         // Add filters that match on servlet name second
@@ -173,26 +149,11 @@ public final class ApplicationFilterFactory {
                 // FIXME - log configuration problem
                 continue;
             }
-            boolean isCometFilter = false;
-            if (comet) {
-                try {
-                    isCometFilter = filterConfig.getFilter() instanceof CometFilter;
-                } catch (Exception e) {
-                    // Note: The try catch is there because getFilter has a lot of
-                    // declared exceptions. However, the filter is allocated much
-                    // earlier
-                }
-                if (isCometFilter) {
-                    filterChain.addFilter(filterConfig);
-                }
-            } else {
-                filterChain.addFilter(filterConfig);
-            }
+            filterChain.addFilter(filterConfig);
         }
 
         // Return the completed filter chain
-        return (filterChain);
-
+        return filterChain;
     }
 
 

==================================================
StandardEngineValve.java
index 8419fce4ff..f72d8989ad 100644
--- a/java/org/apache/catalina/core/StandardContextValve.java
+++ b/java/org/apache/catalina/core/StandardContextValve.java
@@ -24,7 +24,6 @@ import javax.servlet.http.HttpServletResponse;
 
 import org.apache.catalina.Container;
 import org.apache.catalina.Wrapper;
-import org.apache.catalina.comet.CometEvent;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
 import org.apache.catalina.valves.ValveBase;
@@ -105,27 +104,4 @@ final class StandardContextValve extends ValveBase {
         }
         wrapper.getPipeline().getFirst().invoke(request, response);
     }
-
-
-    /**
-     * Select the appropriate child Wrapper to process this request,
-     * based on the specified request URI.  If no matching Wrapper can
-     * be found, return an appropriate HTTP error.
-     *
-     * @param request Request to be processed
-     * @param response Response to be produced
-     * @param event
-     *
-     * @exception IOException if an input/output error occurred
-     * @exception ServletException if a servlet error occurred
-     */
-    @Override
-    public final void event(Request request, Response response, CometEvent event)
-        throws IOException, ServletException {
-
-        // Select the Wrapper to be used for this Request
-        Wrapper wrapper = request.getWrapper();
-
-        wrapper.getPipeline().getFirst().event(request, response, event);
-    }
 }

==================================================
StandardHostValve.java
index 41c5a00edf..8ec5ef32fb 100644
--- a/java/org/apache/catalina/core/StandardEngineValve.java
+++ b/java/org/apache/catalina/core/StandardEngineValve.java
@@ -22,7 +22,6 @@ import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletResponse;
 
 import org.apache.catalina.Host;
-import org.apache.catalina.comet.CometEvent;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
 import org.apache.catalina.valves.ValveBase;
@@ -88,25 +87,4 @@ final class StandardEngineValve extends ValveBase {
         host.getPipeline().getFirst().invoke(request, response);
 
     }
-
-
-    /**
-     * Process Comet event.
-     *
-     * @param request Request to be processed
-     * @param response Response to be produced
-     * @param event the event
-     *
-     * @exception IOException if an input/output error occurred
-     * @exception ServletException if a servlet error occurred
-     */
-    @Override
-    public final void event(Request request, Response response, CometEvent event)
-        throws IOException, ServletException {
-
-        // Ask this Host to process this request
-        request.getHost().getPipeline().getFirst().event(request, response, event);
-
-    }
-
 }

==================================================
StandardWrapperValve.java
index 86e37abb52..1dbded4c20 100644
--- a/java/org/apache/catalina/core/StandardHostValve.java
+++ b/java/org/apache/catalina/core/StandardHostValve.java
@@ -27,7 +27,6 @@ import javax.servlet.http.HttpServletResponse;
 import org.apache.catalina.Context;
 import org.apache.catalina.Globals;
 import org.apache.catalina.Wrapper;
-import org.apache.catalina.comet.CometEvent;
 import org.apache.catalina.connector.ClientAbortException;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
@@ -192,52 +191,6 @@ final class StandardHostValve extends ValveBase {
     }
 
 
-    /**
-     * Process Comet event.
-     *
-     * @param request Request to be processed
-     * @param response Response to be produced
-     * @param event the event
-     *
-     * @exception IOException if an input/output error occurred
-     * @exception ServletException if a servlet error occurred
-     */
-    @Override
-    public final void event(Request request, Response response, CometEvent event)
-        throws IOException, ServletException {
-
-        // Select the Context to be used for this Request
-        Context context = request.getContext();
-
-        context.bind(false, MY_CLASSLOADER);
-
-        // Ask this Context to process this request
-        context.getPipeline().getFirst().event(request, response, event);
-
-
-        // Error page processing
-        response.setSuspended(false);
-
-        Throwable t = (Throwable) request.getAttribute(
-                RequestDispatcher.ERROR_EXCEPTION);
-
-        if (t != null) {
-            throwable(request, response, t);
-        } else {
-            status(request, response);
-        }
-
-        // Access a session (if present) to update last accessed time, based on a
-        // strict interpretation of the specification
-        if (ACCESS_SESSION) {
-            request.getSession(false);
-        }
-
-        // Restore the context classloader
-        context.unbind(false, MY_CLASSLOADER);
-    }
-
-
     // -------------------------------------------------------- Private Methods
 
     /**

==================================================
FailedRequestFilter.java
index 67bb01f6e7..9e8b92fdfc 100644
--- a/java/org/apache/catalina/core/StandardWrapperValve.java
+++ b/java/org/apache/catalina/core/StandardWrapperValve.java
@@ -32,8 +32,6 @@ import javax.servlet.http.HttpServletResponse;
 import org.apache.catalina.Context;
 import org.apache.catalina.Globals;
 import org.apache.catalina.LifecycleException;
-import org.apache.catalina.comet.CometEvent;
-import org.apache.catalina.comet.CometProcessor;
 import org.apache.catalina.connector.ClientAbortException;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
@@ -163,14 +161,6 @@ final class StandardWrapperValve
             servlet = null;
         }
 
-        // Identify if the request is Comet related now that the servlet has been allocated
-        boolean comet = false;
-        if (servlet instanceof CometProcessor && request.getAttribute(
-                Globals.COMET_SUPPORTED_ATTR) == Boolean.TRUE) {
-            comet = true;
-            request.setComet(true);
-        }
-
         MessageBytes requestPathMB = request.getRequestPathMB();
         DispatcherType dispatcherType = DispatcherType.REQUEST;
         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;
@@ -183,9 +173,6 @@ final class StandardWrapperValve
         ApplicationFilterChain filterChain =
             factory.createFilterChain(request, wrapper, servlet);
 
-        // Reset comet flag value after creating the filter chain
-        request.setComet(false);
-
         // Call the filter chain for this request
         // NOTE: This also calls the servlet's service() method
         try {
@@ -196,9 +183,6 @@ final class StandardWrapperValve
                         SystemLogHandler.startCapture();
                         if (request.isAsyncDispatching()) {
                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();
-                        } else if (comet) {
-                            filterChain.doFilterEvent(request.getEvent());
-                            request.setComet(true);
                         } else {
                             filterChain.doFilter(request.getRequest(),
                                     response.getResponse());
@@ -212,9 +196,6 @@ final class StandardWrapperValve
                 } else {
                     if (request.isAsyncDispatching()) {
                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();
-                    } else if (comet) {
-                        request.setComet(true);
-                        filterChain.doFilterEvent(request.getEvent());
                     } else {
                         filterChain.doFilter
                             (request.getRequest(), response.getResponse());
@@ -272,180 +253,7 @@ final class StandardWrapperValve
 
         // Release the filter chain (if any) for this request
         if (filterChain != null) {
-            if (request.isComet()) {
-                // If this is a Comet request, then the same chain will be used for the
-                // processing of all subsequent events.
-                filterChain.reuse();
-            } else {
-                filterChain.release();
-            }
-        }
-
-        // Deallocate the allocated servlet instance
-        try {
-            if (servlet != null) {
-                wrapper.deallocate(servlet);
-            }
-        } catch (Throwable e) {
-            ExceptionUtils.handleThrowable(e);
-            container.getLogger().error(sm.getString("standardWrapper.deallocateException",
-                             wrapper.getName()), e);
-            if (throwable == null) {
-                throwable = e;
-                exception(request, response, e);
-            }
-        }
-
-        // If this servlet has been marked permanently unavailable,
-        // unload it and release this instance
-        try {
-            if ((servlet != null) &&
-                (wrapper.getAvailable() == Long.MAX_VALUE)) {
-                wrapper.unload();
-            }
-        } catch (Throwable e) {
-            ExceptionUtils.handleThrowable(e);
-            container.getLogger().error(sm.getString("standardWrapper.unloadException",
-                             wrapper.getName()), e);
-            if (throwable == null) {
-                throwable = e;
-                exception(request, response, e);
-            }
-        }
-        long t2=System.currentTimeMillis();
-
-        long time=t2-t1;
-        processingTime += time;
-        if( time > maxTime) maxTime=time;
-        if( time < minTime) minTime=time;
-
-    }
-
-
-    /**
-     * Process a Comet event. The main differences here are to not use sendError
-     * (the response is committed), to avoid creating a new filter chain
-     * (which would work but be pointless), and a few very minor tweaks.
-     *
-     * @param request The servlet request to be processed
-     * @param response The servlet response to be created
-     *
-     * @exception IOException if an input/output error occurs, or is thrown
-     *  by a subsequently invoked Valve, Filter, or Servlet
-     * @exception ServletException if a servlet error occurs, or is thrown
-     *  by a subsequently invoked Valve, Filter, or Servlet
-     */
-    @Override
-    public void event(Request request, Response response, CometEvent event)
-        throws IOException, ServletException {
-
-        // Initialize local variables we may need
-        Throwable throwable = null;
-        // This should be a Request attribute...
-        long t1=System.currentTimeMillis();
-        // FIXME: Add a flag to count the total amount of events processed ? requestCount++;
-
-        StandardWrapper wrapper = (StandardWrapper) getContainer();
-        if (wrapper == null) {
-            // Context has been shutdown. Nothing to do here.
-            return;
-        }
-
-        Servlet servlet = null;
-        Context context = (Context) wrapper.getParent();
-
-        // Check for the application being marked unavailable
-        boolean unavailable = !context.getState().isAvailable() ||
-                wrapper.isUnavailable();
-
-        // Allocate a servlet instance to process this request
-        try {
-            if (!unavailable) {
-                servlet = wrapper.allocate();
-            }
-        } catch (UnavailableException e) {
-            // The response is already committed, so it's not possible to do anything
-        } catch (ServletException e) {
-            container.getLogger().error(sm.getString("standardWrapper.allocateException",
-                             wrapper.getName()), StandardWrapper.getRootCause(e));
-            throwable = e;
-            exception(request, response, e);
-        } catch (Throwable e) {
-            ExceptionUtils.handleThrowable(e);
-            container.getLogger().error(sm.getString("standardWrapper.allocateException",
-                             wrapper.getName()), e);
-            throwable = e;
-            exception(request, response, e);
-            servlet = null;
-        }
-
-        MessageBytes requestPathMB = request.getRequestPathMB();
-        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,
-                DispatcherType.REQUEST);
-        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,
-                requestPathMB);
-        // Get the current (unchanged) filter chain for this request
-        ApplicationFilterChain filterChain =
-            (ApplicationFilterChain) request.getFilterChain();
-
-        // Call the filter chain for this request
-        // NOTE: This also calls the servlet's event() method
-        try {
-            if ((servlet != null) && (filterChain != null)) {
-
-                // Swallow output if needed
-                if (context.getSwallowOutput()) {
-                    try {
-                        SystemLogHandler.startCapture();
-                        filterChain.doFilterEvent(request.getEvent());
-                    } finally {
-                        String log = SystemLogHandler.stopCapture();
-                        if (log != null && log.length() > 0) {
-                            context.getLogger().info(log);
-                        }
-                    }
-                } else {
-                    filterChain.doFilterEvent(request.getEvent());
-                }
-
-            }
-        } catch (ClientAbortException e) {
-            throwable = e;
-            exception(request, response, e);
-        } catch (IOException e) {
-            container.getLogger().error(sm.getString(
-                    "standardWrapper.serviceException", wrapper.getName(),
-                    context.getName()), e);
-            throwable = e;
-            exception(request, response, e);
-        } catch (UnavailableException e) {
-            container.getLogger().error(sm.getString(
-                    "standardWrapper.serviceException", wrapper.getName(),
-                    context.getName()), e);
-            // Do not save exception in 'throwable', because we
-            // do not want to do exception(request, response, e) processing
-        } catch (ServletException e) {
-            Throwable rootCause = StandardWrapper.getRootCause(e);
-            if (!(rootCause instanceof ClientAbortException)) {
-                container.getLogger().error(sm.getString(
-                        "standardWrapper.serviceExceptionRoot",
-                        wrapper.getName(), context.getName(), e.getMessage()),
-                        rootCause);
-            }
-            throwable = e;
-            exception(request, response, e);
-        } catch (Throwable e) {
-            ExceptionUtils.handleThrowable(e);
-            container.getLogger().error(sm.getString(
-                    "standardWrapper.serviceException", wrapper.getName(),
-                    context.getName()), e);
-            throwable = e;
-            exception(request, response, e);
-        }
-
-        // Release the filter chain (if any) for this request
-        if (filterChain != null) {
-            filterChain.reuse();
+            filterChain.release();
         }
 
         // Deallocate the allocated servlet instance
@@ -479,7 +287,6 @@ final class StandardWrapperValve
                 exception(request, response, e);
             }
         }
-
         long t2=System.currentTimeMillis();
 
         long time=t2-t1;
@@ -492,7 +299,6 @@ final class StandardWrapperValve
 
     // -------------------------------------------------------- Private Methods
 
-
     /**
      * Handle the specified ServletException encountered while processing
      * the specified Request to produce the specified Response.  Any

==================================================
RemoteAddrFilter.java
index 045372d0aa..52f49dd58d 100644
--- a/java/org/apache/catalina/filters/FailedRequestFilter.java
+++ b/java/org/apache/catalina/filters/FailedRequestFilter.java
@@ -25,9 +25,6 @@ import javax.servlet.ServletResponse;
 import javax.servlet.http.HttpServletResponse;
 
 import org.apache.catalina.Globals;
-import org.apache.catalina.comet.CometEvent;
-import org.apache.catalina.comet.CometFilter;
-import org.apache.catalina.comet.CometFilterChain;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 
@@ -43,7 +40,7 @@ import org.apache.juli.logging.LogFactory;
  * <code>request.getInputStream()</code> and <code>request.getReader()</code>,
  * if requests parsed by them do not use standard value for content mime-type.
  */
-public class FailedRequestFilter extends FilterBase implements CometFilter {
+public class FailedRequestFilter extends FilterBase {
 
     private static final Log log = LogFactory.getLog(FailedRequestFilter.class);
 
@@ -63,19 +60,6 @@ public class FailedRequestFilter extends FilterBase implements CometFilter {
         chain.doFilter(request, response);
     }
 
-    @Override
-    public void doFilterEvent(CometEvent event, CometFilterChain chain)
-            throws IOException, ServletException {
-        if (event.getEventType() == CometEvent.EventType.BEGIN
-                && !isGoodRequest(event.getHttpServletRequest())) {
-            event.getHttpServletResponse().sendError(
-                    HttpServletResponse.SC_BAD_REQUEST);
-            event.close();
-            return;
-        }
-        chain.doFilterEvent(event);
-    }
-
     private boolean isGoodRequest(ServletRequest request) {
         // Trigger parsing of parameters
         request.getParameter("none");

==================================================
RemoteHostFilter.java
index 8fe9fc6828..4da7d2cc68 100644
--- a/java/org/apache/catalina/filters/RemoteAddrFilter.java
+++ b/java/org/apache/catalina/filters/RemoteAddrFilter.java
@@ -16,7 +16,6 @@
  */
 package org.apache.catalina.filters;
 
-
 import java.io.IOException;
 
 import javax.servlet.FilterChain;
@@ -24,12 +23,9 @@ import javax.servlet.ServletException;
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 
-import org.apache.catalina.comet.CometEvent;
-import org.apache.catalina.comet.CometFilterChain;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 
-
 /**
  * Concrete implementation of <code>RequestFilter</code> that filters
  * based on the string representation of the remote client's IP address.
@@ -72,24 +68,6 @@ public final class RemoteAddrFilter extends RequestFilter {
 
     }
 
-    /**
-     * Extract the desired request property, and pass it (along with the comet
-     * event and filter chain) to the protected <code>process()</code> method
-     * to perform the actual filtering.
-     *
-     * @param event The comet event to be processed
-     * @param chain The filter chain for this event
-     *
-     * @exception IOException if an input/output error occurs
-     * @exception ServletException if a servlet error occurs
-     */
-    @Override
-    public void doFilterEvent(CometEvent event, CometFilterChain chain)
-            throws IOException, ServletException {
-        processCometEvent(event.getHttpServletRequest().getRemoteAddr(),
-                event, chain);
-    }
-
     @Override
     protected Log getLogger() {
         return log;

==================================================
RequestFilter.java
index de8a327b0e..0871a405ac 100644
--- a/java/org/apache/catalina/filters/RemoteHostFilter.java
+++ b/java/org/apache/catalina/filters/RemoteHostFilter.java
@@ -16,7 +16,6 @@
  */
 package org.apache.catalina.filters;
 
-
 import java.io.IOException;
 
 import javax.servlet.FilterChain;
@@ -24,12 +23,9 @@ import javax.servlet.ServletException;
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 
-import org.apache.catalina.comet.CometEvent;
-import org.apache.catalina.comet.CometFilterChain;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 
-
 /**
  * Concrete implementation of <code>RequestFilter</code> that filters
  * based on the remote client's host name.
@@ -67,24 +63,6 @@ public final class RemoteHostFilter extends RequestFilter {
 
     }
 
-    /**
-     * Extract the desired request property, and pass it (along with the comet
-     * event and filter chain) to the protected <code>process()</code> method
-     * to perform the actual filtering.
-     *
-     * @param event The comet event to be processed
-     * @param chain The filter chain for this event
-     *
-     * @exception IOException if an input/output error occurs
-     * @exception ServletException if a servlet error occurs
-     */
-    @Override
-    public void doFilterEvent(CometEvent event, CometFilterChain chain)
-            throws IOException, ServletException {
-        processCometEvent(event.getHttpServletRequest().getRemoteHost(),
-                event, chain);
-    }
-
     @Override
     protected Log getLogger() {
         return log;

==================================================
CometConnectionManagerValve.java
index e6c79ddb01..859c36fee6 100644
--- a/java/org/apache/catalina/filters/RequestFilter.java
+++ b/java/org/apache/catalina/filters/RequestFilter.java
@@ -26,10 +26,6 @@ import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 import javax.servlet.http.HttpServletResponse;
 
-import org.apache.catalina.comet.CometEvent;
-import org.apache.catalina.comet.CometFilter;
-import org.apache.catalina.comet.CometFilterChain;
-
 /**
  * Implementation of a Filter that performs filtering based on comparing the
  * appropriate request property (selected based on which subclass you choose
@@ -55,7 +51,7 @@ import org.apache.catalina.comet.CometFilterChain;
  * <li>The request will be rejected with a "Forbidden" HTTP response.</li>
  * </ul>
  */
-public abstract class RequestFilter extends FilterBase implements CometFilter {
+public abstract class RequestFilter extends FilterBase {
 
 
     // ----------------------------------------------------- Instance Variables
@@ -213,28 +209,6 @@ public abstract class RequestFilter extends FilterBase implements CometFilter {
     }
 
 
-    /**
-     * Perform the filtering that has been configured for this Filter, matching
-     * against the specified request property.
-     *
-     * @param property  The property to check against the allow/deny rules
-     * @param event     The comet event to be filtered
-     * @param chain     The comet filter chain
-     * @exception IOException if an input/output error occurs
-     * @exception ServletException if a servlet error occurs
-     */
-    protected void processCometEvent(String property, CometEvent event,
-            CometFilterChain chain) throws IOException, ServletException {
-        HttpServletResponse response = event.getHttpServletResponse();
-
-        if (isAllowed(property)) {
-            chain.doFilterEvent(event);
-        } else {
-            response.sendError(denyStatus);
-            event.close();
-        }
-    }
-
     /**
      * Process the allow and deny rules for the provided property.
      *

==================================================
ValveBase.java
index bba69a5dff..412d12aaf4 100644
--- a/java/org/apache/catalina/valves/LocalStrings_es.properties
+++ b/java/org/apache/catalina/valves/LocalStrings_es.properties
@@ -13,8 +13,6 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 jdbcAccessLogValve.exception = Excepci\u00F3n realizando entrada de acceso a inserci\u00F3n
-cometConnectionManagerValve.event = Excepci\u00F3n procesando evento
-cometConnectionManagerValve.listenerEvent = Excepci\u00F3n procesando evento de oyente de sesi\u00F3n
 accessLogValve.closeFail = No pude cerrar fichero de historial
 accessLogValve.openDirFail = No pude crear directorio [{0}] para historiales de acceso
 accessLogValve.rotateFail = No pude rotar historial de acceso

==================================================
AbstractProcessor.java
index fcf092346e..0603f70bba 100644
--- a/java/org/apache/catalina/valves/ValveBase.java
+++ b/java/org/apache/catalina/valves/ValveBase.java
@@ -16,7 +16,6 @@
  */
 package org.apache.catalina.valves;
 
-
 import java.io.IOException;
 
 import javax.servlet.ServletException;
@@ -27,14 +26,12 @@ import org.apache.catalina.LifecycleException;
 import org.apache.catalina.LifecycleState;
 import org.apache.catalina.Pipeline;
 import org.apache.catalina.Valve;
-import org.apache.catalina.comet.CometEvent;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
 import org.apache.catalina.util.LifecycleMBeanBase;
 import org.apache.juli.logging.Log;
 import org.apache.tomcat.util.res.StringManager;
 
-
 /**
  * Convenience base class for implementations of the <b>Valve</b> interface.
  * A subclass <strong>MUST</strong> implement an <code>invoke()</code>
@@ -182,27 +179,6 @@ public abstract class ValveBase extends LifecycleMBeanBase
         throws IOException, ServletException;
 
 
-    /**
-     * Process a Comet event. This method will rarely need to be provided by
-     * a subclass, unless it needs to reassociate a particular object with
-     * the thread that is processing the request.
-     *
-     * @param request The servlet request to be processed
-     * @param response The servlet response to be created
-     *
-     * @exception IOException if an input/output error occurs, or is thrown
-     *  by a subsequently invoked Valve, Filter, or Servlet
-     * @exception ServletException if a servlet error occurs, or is thrown
-     *  by a subsequently invoked Valve, Filter, or Servlet
-     */
-    @Override
-    public void event(Request request, Response response, CometEvent event)
-        throws IOException, ServletException {
-        // Perform the request
-        getNext().event(request, response, event);
-    }
-
-
     @Override
     protected void initInternal() throws LifecycleException {
         super.initInternal();

==================================================
AbstractProtocol.java
index 762cc5f58b..be45c5c405 100644
--- a/java/org/apache/coyote/AbstractProcessor.java
+++ b/java/org/apache/coyote/AbstractProcessor.java
@@ -178,9 +178,6 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor<S> {
         getAdapter().errorDispatch(request, response);
     }
 
-    @Override
-    public abstract boolean isComet();
-
     @Override
     public abstract boolean isUpgrade();
 
@@ -191,12 +188,6 @@ public abstract class AbstractProcessor<S> implements ActionHook, Processor<S> {
     @Override
     public abstract SocketState process(SocketWrapper<S> socket) throws IOException;
 
-    /**
-     * Process in-progress Comet requests. These will start as HTTP requests.
-     */
-    @Override
-    public abstract SocketState event(SocketStatus status) throws IOException;
-
     /**
      * Process in-progress Servlet 3.0 Async requests. These will start as HTTP
      * requests.

==================================================
ActionCode.java
index b7ec2af7cc..e4fee7f005 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -160,18 +160,6 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
     }
 
 
-    @Override
-    public boolean isCometSupported() {
-        return endpoint.getUseComet();
-    }
-
-
-    @Override
-    public boolean isCometTimeoutSupported() {
-        return endpoint.getUseCometTimeout();
-    }
-
-
     @Override
     public boolean isSendfileSupported() {
         return endpoint.getUseSendfile();
@@ -640,16 +628,11 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
                             state = processor.asyncDispatch(
                                     nextDispatch.getSocketStatus());
                         }
-                    } else if (status == SocketStatus.DISCONNECT &&
-                            !processor.isComet()) {
+                    } else if (status == SocketStatus.DISCONNECT) {
                         // Do nothing here, just wait for it to get recycled
-                        // Don't do this for Comet we need to generate an end
-                        // event (see BZ 54022)
                     } else if (processor.isAsync() ||
                             state == SocketState.ASYNC_END) {
                         state = processor.asyncDispatch(status);
-                    } else if (processor.isComet()) {
-                        state = processor.event(status);
                     } else if (processor.isUpgrade()) {
                         state = processor.upgradeDispatch(status);
                     } else if (status == SocketStatus.OPEN_WRITE) {

==================================================
Adapter.java
index efcf4d8824..7fdbcc33c6 100644
--- a/java/org/apache/coyote/ActionCode.java
+++ b/java/org/apache/coyote/ActionCode.java
@@ -109,31 +109,11 @@ public enum ActionCode {
      */
     REQ_SET_BODY_REPLAY,
 
-    /**
-     * Callback for begin Comet processing.
-     */
-    COMET_BEGIN,
-
-    /**
-     * Callback for end Comet processing.
-     */
-    COMET_END,
-
     /**
      * Callback for getting the amount of available bytes.
      */
     AVAILABLE,
 
-    /**
-     * Callback for an asynchronous close of the Comet event
-     */
-    COMET_CLOSE,
-
-    /**
-     * Callback for setting the timeout asynchronously
-     */
-    COMET_SETTIMEOUT,
-
     /**
      * Callback for an async request.
      */

==================================================
Constants.java
index 19a46d35b9..86edd1708c 100644
--- a/java/org/apache/coyote/Adapter.java
+++ b/java/org/apache/coyote/Adapter.java
@@ -45,9 +45,6 @@ public interface Adapter {
     public void service(Request req, Response res)
             throws Exception;
 
-    public boolean event(Request req, Response res, SocketStatus status)
-            throws Exception;
-
     public boolean asyncDispatch(Request req,Response res, SocketStatus status)
             throws Exception;
 

==================================================
Processor.java
index b79884b765..b674a0e376 100644
--- a/java/org/apache/coyote/Constants.java
+++ b/java/org/apache/coyote/Constants.java
@@ -60,36 +60,6 @@ public final class Constants {
                 "org.apache.coyote.USE_CUSTOM_STATUS_MSG_IN_HEADER",
                 "false")).booleanValue();
 
-    /**
-     * The request attribute that is set to the value of {@code Boolean.TRUE}
-     * if connector processing this request supports Comet API.
-     */
-    public static final String COMET_SUPPORTED_ATTR =
-        "org.apache.tomcat.comet.support";
-
-
-    /**
-     * The request attribute that is set to the value of {@code Boolean.TRUE}
-     * if connector processing this request supports setting
-     * per-connection request timeout through Comet API.
-     *
-     * @see org.apache.catalina.comet.CometEvent#setTimeout(int)
-     */
-    public static final String COMET_TIMEOUT_SUPPORTED_ATTR =
-        "org.apache.tomcat.comet.timeout.support";
-
-
-    /**
-     * The request attribute that can be set to a value of type
-     * {@code java.lang.Integer} to specify per-connection request
-     * timeout for Comet API. The value is in milliseconds.
-     *
-     * @see org.apache.catalina.comet.CometEvent#setTimeout(int)
-     */
-    public static final String COMET_TIMEOUT_ATTR =
-        "org.apache.tomcat.comet.timeout";
-
-
     /**
      * The request attribute that is set to the value of {@code Boolean.TRUE}
      * if connector processing this request supports use of sendfile.

==================================================
ProtocolHandler.java
index 81a1d2518b..991af90e4e 100644
--- a/java/org/apache/coyote/Processor.java
+++ b/java/org/apache/coyote/Processor.java
@@ -36,8 +36,6 @@ public interface Processor<S> {
 
     SocketState process(SocketWrapper<S> socketWrapper) throws IOException;
 
-    SocketState event(SocketStatus status) throws IOException;
-
     SocketState asyncDispatch(SocketStatus status);
     SocketState asyncPostProcess();
 
@@ -46,7 +44,6 @@ public interface Processor<S> {
 
     void errorDispatch();
 
-    boolean isComet();
     boolean isAsync();
     boolean isUpgrade();
 

==================================================
AbstractAjpProcessor.java
index ed1d0b8f4b..757c044c4e 100644
--- a/java/org/apache/coyote/ProtocolHandler.java
+++ b/java/org/apache/coyote/ProtocolHandler.java
@@ -90,18 +90,6 @@ public interface ProtocolHandler {
     public boolean isAprRequired();
 
 
-    /**
-     * Does this ProtocolHandler support Comet?
-     */
-    public boolean isCometSupported();
-
-
-    /**
-     * Does this ProtocolHandler support Comet timeouts?
-     */
-    public boolean isCometTimeoutSupported();
-
-
     /**
      * Does this ProtocolHandler support sendfile?
      */

==================================================
AjpNio2Protocol.java
index d99cdaeade..3feff79f0e 100644
--- a/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AbstractAjpProcessor.java
@@ -587,26 +587,6 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
             throw new UnsupportedOperationException(
                     sm.getString("ajpprocessor.httpupgrade.notsupported"));
         }
-        case COMET_BEGIN: {
-            // HTTP connections only. Unsupported for AJP.
-            throw new UnsupportedOperationException(
-                    sm.getString("ajpprocessor.comet.notsupported"));
-        }
-        case COMET_END: {
-            // HTTP connections only. Unsupported for AJP.
-            throw new UnsupportedOperationException(
-                    sm.getString("ajpprocessor.comet.notsupported"));
-        }
-        case COMET_CLOSE: {
-            // HTTP connections only. Unsupported for AJP.
-            throw new UnsupportedOperationException(
-                    sm.getString("ajpprocessor.comet.notsupported"));
-        }
-        case COMET_SETTIMEOUT: {
-            // HTTP connections only. Unsupported for AJP.
-            throw new UnsupportedOperationException(
-                    sm.getString("ajpprocessor.comet.notsupported"));
-        }
         case AVAILABLE: {
             if (available()) {
                 request.setAvailable(1);
@@ -893,14 +873,6 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
     }
 
 
-    @Override
-    public SocketState event(SocketStatus status) throws IOException {
-        // Should never reach this code but in case we do...
-        throw new IOException(
-                sm.getString("ajpprocessor.comet.notsupported"));
-    }
-
-
     @Override
     public SocketState upgradeDispatch(SocketStatus status) throws IOException {
         // Should never reach this code but in case we do...
@@ -1070,13 +1042,6 @@ public abstract class AbstractAjpProcessor<S> extends AbstractProcessor<S> {
     }
 
 
-    @Override
-    public final boolean isComet() {
-        // AJP does not support Comet
-        return false;
-    }
-
-
     @Override
     public final boolean isUpgrade() {
         // AJP does not support HTTP upgrade

==================================================
AbstractHttp11Processor.java
index fc7b387687..d16033401b 100644
--- a/java/org/apache/coyote/ajp/LocalStrings.properties
+++ b/java/org/apache/coyote/ajp/LocalStrings.properties
@@ -15,7 +15,6 @@
 ajpnioprotocol.releaseStart=Iterating through our connections to release a socket channel [{0}]
 ajpnioprotocol.releaseEnd=Done iterating through our connections to release a socket channel [{0}] released [{1}]
 
-ajpprocessor.comet.notsupported=Comet is not supported by the AJP protocol
 ajpprocessor.failedread=Socket read failed
 ajpprocessor.failedsend=Failed to send AJP message
 ajpprocessor.header.error=Header message parsing failed
@@ -24,7 +23,6 @@ ajpprocessor.readtimeout=Timeout attempting to read data from the socket
 ajpprocessor.request.prepare=Error preparing request
 ajpprocessor.request.process=Error processing request
 ajpprocessor.certs.fail=Certificate conversion failed
-ajpprocessor.comet.notsupported=The Comet protocol is not supported by this connector
 ajpprocessor.ssl.notsupported=The SSL protocol is not supported by this connector
 ajpprocessor.httpupgrade.notsupported=HTTP upgrade is not supported by the AJP protocol
 

==================================================
Http11AprProcessor.java
index c576dda102..297d94dc7a 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Processor.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Processor.java
@@ -149,12 +149,6 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
     protected boolean expectation = false;
 
 
-    /**
-     * Comet used.
-     */
-    protected boolean comet = false;
-
-
     /**
      * Regular expression that defines the restricted user agents.
      */
@@ -976,7 +970,6 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
 
         // Flags
         keepAlive = true;
-        comet = false;
         openSocket = false;
         sendfileInProgress = false;
         readComplete = true;
@@ -990,7 +983,7 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
             socketWrapper.setKeepAliveLeft(0);
         }
 
-        while (!getErrorState().isError() && keepAlive && !comet && !isAsync() &&
+        while (!getErrorState().isError() && keepAlive && !isAsync() &&
                 httpUpgradeHandler == null && !endpoint.isPaused()) {
 
             // Parsing the request header
@@ -1095,7 +1088,6 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
                                     statusDropsConnection(response.getStatus())))) {
                         setErrorState(ErrorState.CLOSE_CLEAN, null);
                     }
-                    setCometTimeouts(socketWrapper);
                 } catch (InterruptedIOException e) {
                     setErrorState(ErrorState.CLOSE_NOW, e);
                 } catch (HeadersTooLargeException e) {
@@ -1123,7 +1115,7 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
             // Finish the handling of the request
             rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);
 
-            if (!isAsync() && !comet) {
+            if (!isAsync()) {
                 if (getErrorState().isError()) {
                     // If we know we are closing the connection, don't drain
                     // input. This way uploading a 100GB file doesn't tie up the
@@ -1152,7 +1144,7 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
             }
             request.updateCounters();
 
-            if (!isAsync() && !comet || getErrorState().isError()) {
+            if (!isAsync() || getErrorState().isError()) {
                 if (getErrorState().isIoAllowed()) {
                     getInputBuffer().nextRequest();
                     getOutputBuffer().nextRequest();
@@ -1178,7 +1170,7 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
 
         if (getErrorState().isError() || endpoint.isPaused()) {
             return SocketState.CLOSED;
-        } else if (isAsync() || comet) {
+        } else if (isAsync()) {
             return SocketState.LONG;
         } else if (isUpgrade()) {
             return SocketState.UPGRADING;
@@ -1710,12 +1702,6 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
     }
 
 
-    @Override
-    public boolean isComet() {
-        return comet;
-    }
-
-
     @Override
     public boolean isUpgrade() {
         return httpUpgradeHandler != null;
@@ -1745,12 +1731,6 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
     protected abstract void resetTimeouts();
 
 
-    /**
-     * Provides a mechanism for those connectors (currently only NIO) that need
-     * that need to set comet timeouts.
-     */
-    protected abstract void setCometTimeouts(SocketWrapper<S> socketWrapper);
-
     public void endRequest() {
 
         // Finish the handling of the request
@@ -1807,7 +1787,6 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
             asyncStateMachine.recycle();
         }
         httpUpgradeHandler = null;
-        comet = false;
         resetErrorState();
         recycleInternal();
     }

==================================================
Http11AprProtocol.java
index e4ecd1a370..9241f07c96 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -18,13 +18,11 @@ package org.apache.coyote.http11;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
-import java.io.InterruptedIOException;
 import java.security.cert.CertificateFactory;
 import java.security.cert.X509Certificate;
 
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.ErrorState;
-import org.apache.coyote.RequestInfo;
 import org.apache.coyote.http11.filters.BufferedInputFilter;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
@@ -33,11 +31,8 @@ import org.apache.tomcat.jni.SSL;
 import org.apache.tomcat.jni.SSLSocket;
 import org.apache.tomcat.jni.Sockaddr;
 import org.apache.tomcat.jni.Socket;
-import org.apache.tomcat.util.ExceptionUtils;
-import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.AprEndpoint;
 import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapper;
 
 
@@ -98,47 +93,6 @@ public class Http11AprProcessor extends AbstractHttp11Processor<Long> {
     // --------------------------------------------------------- Public Methods
 
 
-    /**
-     * Process pipelined HTTP requests using the specified input and output
-     * streams.
-     *
-     * @throws IOException error during an I/O operation
-     */
-    @Override
-    public SocketState event(SocketStatus status)
-        throws IOException {
-
-        RequestInfo rp = request.getRequestProcessor();
-
-        try {
-            rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
-            if (!getAdapter().event(request, response, status)) {
-                setErrorState(ErrorState.CLOSE_NOW, null);
-            }
-        } catch (InterruptedIOException e) {
-            setErrorState(ErrorState.CLOSE_NOW, e);
-        } catch (Throwable t) {
-            ExceptionUtils.handleThrowable(t);
-            // 500 - Internal Server Error
-            response.setStatus(500);
-            setErrorState(ErrorState.CLOSE_NOW, t);
-            getAdapter().log(request, response, 0);
-            log.error(sm.getString("http11processor.request.process"), t);
-        }
-
-        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
-
-        if (getErrorState().isError() || status==SocketStatus.STOP) {
-            return SocketState.CLOSED;
-        } else if (!comet) {
-            inputBuffer.nextRequest();
-            outputBuffer.nextRequest();
-            return SocketState.OPEN;
-        } else {
-            return SocketState.LONG;
-        }
-    }
-
     @Override
     protected boolean disableKeepAlive() {
         return false;
@@ -185,12 +139,6 @@ public class Http11AprProcessor extends AbstractHttp11Processor<Long> {
     }
 
 
-    @Override
-    protected void setCometTimeouts(SocketWrapper<Long> socketWrapper) {
-        // NO-OP for APR/native
-    }
-
-
     @Override
     protected boolean breakKeepAliveLoop(SocketWrapper<Long> socketWrapper) {
         openSocket = keepAlive;
@@ -455,23 +403,6 @@ public class Http11AprProcessor extends AbstractHttp11Processor<Long> {
             }
             break;
         }
-        case COMET_BEGIN: {
-            comet = true;
-            break;
-        }
-        case COMET_END: {
-            comet = false;
-            break;
-        }
-        case COMET_CLOSE: {
-            ((AprEndpoint)endpoint).processSocket(this.socketWrapper,
-                    SocketStatus.OPEN_READ, true);
-            break;
-        }
-        case COMET_SETTIMEOUT: {
-            //no op
-            break;
-        }
         }
     }
 

==================================================
Http11Nio2Processor.java
index 1ba9c8fadb..716cb5869c 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -266,7 +266,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
 
                 }
                 if (processor == null) {
-                    // if not null - this is a former comet request, handled by http11
+                    // if not null - handled by http11
                     SocketState socketState = proto.npnHandler.process(socket, status);
                     // handled by npn protocol.
                     if (socketState == SocketState.CLOSED ||
@@ -291,19 +291,6 @@ public class Http11AprProtocol extends AbstractHttp11Protocol<Long> {
             if (processor.isAsync()) {
                 // Async
                 socket.setAsync(true);
-            } else if (processor.isComet()) {
-                // Comet
-                if (proto.endpoint.isRunning()) {
-                    socket.setComet(true);
-                    ((AprEndpoint) proto.endpoint).getPoller().add(
-                            socket.getSocket().longValue(),
-                            proto.endpoint.getSoTimeout(), true, false);
-                } else {
-                    // Process a STOP directly
-                    ((AprEndpoint) proto.endpoint).processSocket(
-                            socket.getSocket().longValue(),
-                            SocketStatus.STOP);
-                }
             } else {
                 // Upgraded
                 Poller p = ((AprEndpoint) proto.endpoint).getPoller();

==================================================
Http11Nio2Protocol.java
index 6abd2004b8..6e3df5d531 100644
--- a/java/org/apache/coyote/http11/Http11Nio2Processor.java
+++ b/java/org/apache/coyote/http11/Http11Nio2Processor.java
@@ -17,7 +17,6 @@
 package org.apache.coyote.http11;
 
 import java.io.IOException;
-import java.io.InterruptedIOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 
@@ -25,11 +24,9 @@ import javax.net.ssl.SSLEngine;
 
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.ErrorState;
-import org.apache.coyote.RequestInfo;
 import org.apache.coyote.http11.filters.BufferedInputFilter;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.Nio2Channel;
 import org.apache.tomcat.util.net.Nio2Endpoint;
@@ -84,72 +81,6 @@ public class Http11Nio2Processor extends AbstractHttp11Processor<Nio2Channel> {
 
     // --------------------------------------------------------- Public Methods
 
-    @Override
-    public SocketState event(SocketStatus status)
-        throws IOException {
-
-        long soTimeout = endpoint.getSoTimeout();
-
-        RequestInfo rp = request.getRequestProcessor();
-        try {
-            rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
-            if (!getAdapter().event(request, response, status)) {
-                setErrorState(ErrorState.CLOSE_NOW, null);
-            }
-            if (!getErrorState().isError()) {
-                if (socketWrapper != null) {
-                    socketWrapper.setComet(comet);
-                    if (comet) {
-                        Integer comettimeout = (Integer) request.getAttribute(
-                                org.apache.coyote.Constants.COMET_TIMEOUT_ATTR);
-                        if (comettimeout != null) {
-                            socketWrapper.setTimeout(comettimeout.longValue());
-                        }
-                    } else {
-                        //reset the timeout
-                        if (keepAlive) {
-                            socketWrapper.setTimeout(keepAliveTimeout);
-                        } else {
-                            socketWrapper.setTimeout(soTimeout);
-                        }
-                    }
-
-                }
-            }
-        } catch (InterruptedIOException e) {
-            setErrorState(ErrorState.CLOSE_NOW, e);
-        } catch (Throwable t) {
-            ExceptionUtils.handleThrowable(t);
-            // 500 - Internal Server Error
-            response.setStatus(500);
-            setErrorState(ErrorState.CLOSE_NOW, t);
-            getAdapter().log(request, response, 0);
-            log.error(sm.getString("http11processor.request.process"), t);
-        }
-
-        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
-
-        if (getErrorState().isError() || status==SocketStatus.STOP) {
-            return SocketState.CLOSED;
-        } else if (!comet) {
-            if (keepAlive) {
-                inputBuffer.nextRequest();
-                outputBuffer.nextRequest();
-                if (((InternalNio2InputBuffer) inputBuffer).isPending()) {
-                    // Following comet processing, a read is still pending, so
-                    // keep the processor associated
-                    return SocketState.LONG;
-                } else {
-                    return SocketState.OPEN;
-                }
-            } else {
-                return SocketState.CLOSED;
-            }
-        } else {
-            return SocketState.LONG;
-        }
-    }
-
     @Override
     public SocketState asyncDispatch(SocketStatus status) {
         SocketState state = super.asyncDispatch(status);
@@ -257,21 +188,6 @@ public class Http11Nio2Processor extends AbstractHttp11Processor<Nio2Channel> {
     }
 
 
-    @Override
-    protected void setCometTimeouts(SocketWrapper<Nio2Channel> socketWrapper) {
-        if (socketWrapper != null)  {
-            socketWrapper.setComet(comet);
-            if (comet) {
-                Integer comettimeout = (Integer) request.getAttribute(
-                        org.apache.coyote.Constants.COMET_TIMEOUT_ATTR);
-                if (comettimeout != null) {
-                    socketWrapper.setTimeout(comettimeout.longValue());
-                }
-            }
-        }
-    }
-
-
     @Override
     protected boolean breakKeepAliveLoop(
             SocketWrapper<Nio2Channel> socketWrapper) {
@@ -503,42 +419,6 @@ public class Http11Nio2Processor extends AbstractHttp11Processor<Nio2Channel> {
             }
             break;
         }
-        case COMET_BEGIN: {
-            comet = true;
-            break;
-        }
-        case COMET_END: {
-            comet = false;
-            break;
-        }
-        case COMET_CLOSE: {
-            if (socketWrapper == null || socketWrapper.getSocket() == null) {
-                return;
-            }
-            RequestInfo rp = request.getRequestProcessor();
-            if (rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE) {
-                // Close event for this processor triggered by request
-                // processing in another processor, a non-Tomcat thread (i.e.
-                // an application controlled thread) or similar.
-                endpoint.processSocket(this.socketWrapper, SocketStatus.OPEN_READ, true);
-            }
-            break;
-        }
-        case COMET_SETTIMEOUT: {
-            if (param == null) {
-                return;
-            }
-            if (socketWrapper == null) {
-                return;
-            }
-            long timeout = ((Long)param).longValue();
-            //if we are not piggy backing on a worker thread, set the timeout
-            RequestInfo rp = request.getRequestProcessor();
-            if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) {
-                socketWrapper.setTimeout(timeout);
-            }
-            break;
-        }
         }
     }
 

==================================================
Http11NioProcessor.java
index 64edf2ef8c..5fffea8bd4 100644
--- a/java/org/apache/coyote/http11/Http11Nio2Protocol.java
+++ b/java/org/apache/coyote/http11/Http11Nio2Protocol.java
@@ -236,7 +236,6 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
                 }
             } else {
                 // Either:
-                //  - this is comet request
                 //  - this is an upgraded connection
                 //  - the request line/headers have not been completely
                 //    read
@@ -275,7 +274,7 @@ public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol<Nio2Channel>
         @Override
         public void closeAll() {
             for (Nio2Channel channel : connections.keySet()) {
-                ((Nio2Endpoint) proto.endpoint).closeSocket(channel.getSocket(), SocketStatus.STOP);
+                ((Nio2Endpoint) proto.endpoint).closeSocket(channel.getSocket());
             }
         }
     }

==================================================
Http11NioProtocol.java
index edf4b72a8b..c9b358d14d 100644
--- a/java/org/apache/coyote/http11/Http11NioProcessor.java
+++ b/java/org/apache/coyote/http11/Http11NioProcessor.java
@@ -17,7 +17,6 @@
 package org.apache.coyote.http11;
 
 import java.io.IOException;
-import java.io.InterruptedIOException;
 import java.net.InetAddress;
 import java.nio.channels.SelectionKey;
 
@@ -25,18 +24,14 @@ import javax.net.ssl.SSLEngine;
 
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.ErrorState;
-import org.apache.coyote.RequestInfo;
 import org.apache.coyote.http11.filters.BufferedInputFilter;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.ExceptionUtils;
-import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.NioChannel;
 import org.apache.tomcat.util.net.NioEndpoint;
 import org.apache.tomcat.util.net.NioEndpoint.KeyAttachment;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.SecureNioChannel;
-import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapper;
 
 
@@ -87,73 +82,6 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
 
     // --------------------------------------------------------- Public Methods
 
-    /**
-     * Process pipelined HTTP requests using the specified input and output
-     * streams.
-     *
-     * @throws IOException error during an I/O operation
-     */
-    @Override
-    public SocketState event(SocketStatus status) throws IOException {
-
-        long soTimeout = endpoint.getSoTimeout();
-
-        RequestInfo rp = request.getRequestProcessor();
-        final NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socketWrapper.getSocket().getAttachment(false);
-        try {
-            rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
-            if (!getAdapter().event(request, response, status)) {
-                setErrorState(ErrorState.CLOSE_NOW, null);
-            }
-            if (!getErrorState().isError()) {
-                if (attach != null) {
-                    attach.setComet(comet);
-                    if (comet) {
-                        Integer comettimeout = (Integer) request.getAttribute(
-                                org.apache.coyote.Constants.COMET_TIMEOUT_ATTR);
-                        if (comettimeout != null) {
-                            attach.setTimeout(comettimeout.longValue());
-                        }
-                    } else {
-                        //reset the timeout
-                        if (keepAlive) {
-                            attach.setTimeout(keepAliveTimeout);
-                        } else {
-                            attach.setTimeout(soTimeout);
-                        }
-                    }
-
-                }
-            }
-        } catch (InterruptedIOException e) {
-            setErrorState(ErrorState.CLOSE_NOW, e);
-        } catch (Throwable t) {
-            ExceptionUtils.handleThrowable(t);
-            // 500 - Internal Server Error
-            response.setStatus(500);
-            setErrorState(ErrorState.CLOSE_NOW, t);
-            log.error(sm.getString("http11processor.request.process"), t);
-            getAdapter().log(request, response, 0);
-        }
-
-        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
-
-        if (getErrorState().isError() || status==SocketStatus.STOP) {
-            return SocketState.CLOSED;
-        } else if (!comet) {
-            if (keepAlive) {
-                inputBuffer.nextRequest();
-                outputBuffer.nextRequest();
-                return SocketState.OPEN;
-            } else {
-                return SocketState.CLOSED;
-            }
-        } else {
-            return SocketState.LONG;
-        }
-    }
-
-
     @Override
     protected void registerForEvent(boolean read, boolean write) {
         final NioChannel socket = socketWrapper.getSocket();
@@ -250,27 +178,6 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
     }
 
 
-    @Override
-    protected void setCometTimeouts(SocketWrapper<NioChannel> socketWrapper) {
-        // Comet support
-        SelectionKey key = socketWrapper.getSocket().getIOChannel().keyFor(
-                socketWrapper.getSocket().getPoller().getSelector());
-        if (key != null) {
-            NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) key.attachment();
-            if (attach != null)  {
-                attach.setComet(comet);
-                if (comet) {
-                    Integer comettimeout = (Integer) request.getAttribute(
-                            org.apache.coyote.Constants.COMET_TIMEOUT_ATTR);
-                    if (comettimeout != null) {
-                        attach.setTimeout(comettimeout.longValue());
-                    }
-                }
-            }
-        }
-    }
-
-
     @Override
     protected boolean breakKeepAliveLoop(SocketWrapper<NioChannel> socketWrapper) {
         openSocket = keepAlive;
@@ -472,43 +379,6 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
             }
             break;
         }
-        case COMET_BEGIN: {
-            comet = true;
-            break;
-        }
-        case COMET_END: {
-            comet = false;
-            break;
-        }
-        case COMET_CLOSE: {
-            if (socketWrapper==null || socketWrapper.getSocket().getAttachment(false)==null) {
-                return;
-            }
-            RequestInfo rp = request.getRequestProcessor();
-            if (rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE) {
-                // Close event for this processor triggered by request
-                // processing in another processor, a non-Tomcat thread (i.e.
-                // an application controlled thread) or similar.
-                socketWrapper.getSocket().getPoller().add(socketWrapper.getSocket());
-            }
-            break;
-        }
-        case COMET_SETTIMEOUT: {
-            if (param==null) {
-                return;
-            }
-            if (socketWrapper==null || socketWrapper.getSocket().getAttachment(false)==null) {
-                return;
-            }
-            NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socketWrapper.getSocket().getAttachment(false);
-            long timeout = ((Long)param).longValue();
-            //if we are not piggy backing on a worker thread, set the timeout
-            RequestInfo rp = request.getRequestProcessor();
-            if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) {
-                attach.setTimeout(timeout);
-            }
-            break;
-        }
         }
     }
 

==================================================
Http11Processor.java
index 0d421a3f77..791a0be4d6 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -269,7 +269,6 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol<NioChannel> {
                 socket.setAsync(true);
             } else {
                 // Either:
-                //  - this is comet request
                 //  - this is an upgraded connection
                 //  - the request line/headers have not been completely
                 //    read

==================================================
AbstractProcessor.java
index e55ce1a199..a3c7c63d6a 100644
--- a/java/org/apache/coyote/http11/LocalStrings.properties
+++ b/java/org/apache/coyote/http11/LocalStrings.properties
@@ -23,7 +23,6 @@ http11processor.response.finish=Error finishing response
 http11processor.socket.info=Exception getting socket information
 http11processor.socket.ssl=Exception getting SSL attributes
 http11processor.socket.sslreneg=Exception re-negotiating SSL connection
-http11processor.comet.notsupported=The Comet protocol is not supported by this connector
 http11processor.sendfile.error=Error sending data using sendfile. May be caused by invalid request attributes for start/end points
 http11Processor.upgrade=An internal error has occurred as upgraded connections should only be processed by the dedicated upgrade processor implementations
 

==================================================
SpdyProcessor.java
index 46f20ac0f6..68cf01531c 100644
--- a/java/org/apache/coyote/http11/upgrade/AbstractProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/AbstractProcessor.java
@@ -140,11 +140,6 @@ public abstract class AbstractProcessor<S>
         return null;
     }
 
-    @Override
-    public final SocketState event(SocketStatus status) throws IOException {
-        return null;
-    }
-
     @Override
     public final SocketState asyncDispatch(SocketStatus status) {
         return null;
@@ -160,11 +155,6 @@ public abstract class AbstractProcessor<S>
         return null;
     }
 
-    @Override
-    public final boolean isComet() {
-        return false;
-    }
-
     @Override
     public final boolean isAsync() {
         return false;

==================================================
AbstractEndpoint.java
index 618e41e7ee..f35de64c37 100644
--- a/java/org/apache/coyote/spdy/SpdyProcessor.java
+++ b/java/org/apache/coyote/spdy/SpdyProcessor.java
@@ -506,23 +506,12 @@ public class SpdyProcessor<S> extends AbstractProcessor<S> implements Runnable {
         outCommit = true;
     }
 
-    @Override
-    public boolean isComet() {
-        return false;
-    }
-
     @Override
     public SocketState process(SocketWrapper<S> socket)
             throws IOException {
         throw new IOException("Unimplemented");
     }
 
-    @Override
-    public SocketState event(SocketStatus status) throws IOException {
-        System.err.println("EVENT: " + status);
-        return null;
-    }
-
     @Override
     public SocketState asyncDispatch(SocketStatus status) {
         System.err.println("ASYNC DISPATCH: " + status);

==================================================
AprEndpoint.java
index 31ce4f08d1..063bbb02f9 100644
--- a/java/org/apache/tomcat/util/net/AbstractEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AbstractEndpoint.java
@@ -821,8 +821,6 @@ public abstract class AbstractEndpoint<S> {
     // Some of these are always hard-coded, some are hard-coded to false (i.e.
     // the endpoint does not support them) and some are configurable.
     public abstract boolean getUseSendfile();
-    public abstract boolean getUseComet();
-    public abstract boolean getUseCometTimeout();
     public abstract boolean getUsePolling();
 
     protected LimitLatch initializeConnectionLatch() {

==================================================
JIoEndpoint.java
index b5d9b0409b..a4275701b8 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -159,15 +159,6 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
     public boolean getUseSendfile() { return useSendfile; }
 
 
-    /**
-     * Allow comet request handling.
-     */
-    protected boolean useComet = true;
-    public void setUseComet(boolean useComet) { this.useComet = useComet; }
-    @Override
-    public boolean getUseComet() { return useComet; }
-    @Override
-    public boolean getUseCometTimeout() { return false; } // Not supported
     @Override
     public boolean getUsePolling() { return true; } // Always supported
 
@@ -857,8 +848,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
 
 
     /**
-     * Process given socket. Called in non-comet mode, typically keep alive
-     * or upgraded protocol.
+     * Process given socket. Typically keep alive or upgraded protocol.
      */
     public boolean processSocket(long socket, SocketStatus status) {
         try {
@@ -1405,14 +1395,9 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
             // Close all sockets in the add queue
             SocketInfo info = addList.get();
             while (info != null) {
-                boolean comet =
-                        connections.get(Long.valueOf(info.socket)).isComet();
-                if (!comet || (comet && !processSocket(
-                        info.socket, SocketStatus.STOP))) {
-                    // Poller isn't running at this point so use destroySocket()
-                    // directly
-                    destroySocket(info.socket);
-                }
+                // Poller isn't running at this point so use destroySocket()
+                // directly
+                destroySocket(info.socket);
                 info = addList.get();
             }
             addList.clear();
@@ -1421,12 +1406,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
                 int rv = Poll.pollset(pollers[i], desc);
                 if (rv > 0) {
                     for (int n = 0; n < rv; n++) {
-                        boolean comet = connections.get(
-                                Long.valueOf(desc[n*2+1])).isComet();
-                        if (!comet || (comet && !processSocket(
-                                desc[n*2+1], SocketStatus.STOP))) {
-                            destroySocket(desc[n*2+1]);
-                        }
+                        destroySocket(desc[n*2+1]);
                     }
                 }
             }
@@ -1483,12 +1463,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
             }
             if (!ok) {
                 // Can't do anything: close the socket right away
-                boolean comet = connections.get(
-                        Long.valueOf(socket)).isComet();
-                if (!comet || (comet && !processSocket(
-                        socket, SocketStatus.ERROR))) {
-                    closeSocket(socket);
-                }
+                closeSocket(socket);
             }
         }
 
@@ -1576,12 +1551,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
                             Long.valueOf(socket)));
                 }
                 removeFromPoller(socket);
-                boolean comet = connections.get(
-                        Long.valueOf(socket)).isComet();
-                if (!comet || (comet && !processSocket(
-                        socket, SocketStatus.TIMEOUT))) {
-                    destroySocket(socket);
-                }
+                destroySocket(socket);
                 socket = timeouts.check(date);
             }
 
@@ -1703,20 +1673,11 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
                                 continue;
                             }
                             if (info.read() || info.write()) {
-                                boolean comet = wrapper.isComet();
-                                if (comet || wrapper.pollerFlags != 0) {
-                                    removeFromPoller(info.socket);
-                                }
                                 wrapper.pollerFlags = wrapper.pollerFlags |
                                         (info.read() ? Poll.APR_POLLIN : 0) |
                                         (info.write() ? Poll.APR_POLLOUT : 0);
                                 if (!addToPoller(info.socket, wrapper.pollerFlags)) {
-                                    // Can't do anything: close the socket right
-                                    // away
-                                    if (!comet || (comet && !processSocket(
-                                            info.socket, SocketStatus.ERROR))) {
-                                        closeSocket(info.socket);
-                                    }
+                                    closeSocket(info.socket);
                                 } else {
                                     timeouts.add(info.socket,
                                             System.currentTimeMillis() +
@@ -1770,42 +1731,7 @@ public class AprEndpoint extends AbstractEndpoint<Long> {
                                 }
                                 wrapper.pollerFlags = wrapper.pollerFlags & ~((int) desc[n*2]);
                                 // Check for failed sockets and hand this socket off to a worker
-                                if (wrapper.isComet()) {
-                                    // Event processes either a read or a write depending on what the poller returns
-                                    if (((desc[n*2] & Poll.APR_POLLHUP) == Poll.APR_POLLHUP)
-                                            || ((desc[n*2] & Poll.APR_POLLERR) == Poll.APR_POLLERR)
-                                            || ((desc[n*2] & Poll.APR_POLLNVAL) == Poll.APR_POLLNVAL)) {
-                                        if (!processSocket(desc[n*2+1], SocketStatus.ERROR)) {
-                                            // Close socket and clear pool
-                                            closeSocket(desc[n*2+1]);
-                                        }
-                                    } else if ((desc[n*2] & Poll.APR_POLLIN) == Poll.APR_POLLIN) {
-                                        if (wrapper.pollerFlags != 0) {
-                                            add(desc[n*2+1], 1, wrapper.pollerFlags);
-                                        }
-                                        if (!processSocket(desc[n*2+1], SocketStatus.OPEN_READ)) {
-                                            // Close socket and clear pool
-                                            closeSocket(desc[n*2+1]);
-                                        }
-                                    } else if ((desc[n*2] & Poll.APR_POLLOUT) == Poll.APR_POLLOUT) {
-                                        if (wrapper.pollerFlags != 0) {
-                                            add(desc[n*2+1], 1, wrapper.pollerFlags);
-                                        }
-                                        if (!processSocket(desc[n*2+1], SocketStatus.OPEN_WRITE)) {
-                                            // Close socket and clear pool
-                                            closeSocket(desc[n*2+1]);
-                                        }
-                                    } else {
-                                        // Unknown event
-                                        getLog().warn(sm.getString(
-                                                "endpoint.apr.pollUnknownEvent",
-                                                Long.valueOf(desc[n*2])));
-                                        if (!processSocket(desc[n*2+1], SocketStatus.ERROR)) {
-                                            // Close socket and clear pool
-                                            closeSocket(desc[n*2+1]);
-                                        }
-                                    }
-                                } else if (((desc[n*2] & Poll.APR_POLLHUP) == Poll.APR_POLLHUP)
+                                if (((desc[n*2] & Poll.APR_POLLHUP) == Poll.APR_POLLHUP)
                                         || ((desc[n*2] & Poll.APR_POLLERR) == Poll.APR_POLLERR)
                                         || ((desc[n*2] & Poll.APR_POLLNVAL) == Poll.APR_POLLNVAL)) {
                                     if (wrapper.isAsync() || wrapper.isUpgraded()) {

==================================================
Nio2Endpoint.java
index 749af9672e..0b2526e069 100644
--- a/java/org/apache/tomcat/util/net/JIoEndpoint.java
+++ b/java/org/apache/tomcat/util/net/JIoEndpoint.java
@@ -118,10 +118,6 @@ public class JIoEndpoint extends AbstractEndpoint<Socket> {
     @Override
     public boolean getUseSendfile() { return false; } // Not supported
     @Override
-    public boolean getUseComet() { return false; } // Not supported
-    @Override
-    public boolean getUseCometTimeout() { return false; } // Not supported
-    @Override
     public boolean getDeferAccept() { return false; } // Not supported
     @Override
     public boolean getUsePolling() { return false; } // Not supported

==================================================
NioEndpoint.java
index 0f9a02378e..9f742ff02e 100644
--- a/java/org/apache/tomcat/util/net/Nio2Endpoint.java
+++ b/java/org/apache/tomcat/util/net/Nio2Endpoint.java
@@ -151,15 +151,6 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
     public Handler getHandler() { return handler; }
 
 
-    /**
-     * Allow comet request handling.
-     */
-    private boolean useComet = true;
-    public void setUseComet(boolean useComet) { this.useComet = useComet; }
-    @Override
-    public boolean getUseComet() { return useComet; }
-    @Override
-    public boolean getUseCometTimeout() { return getUseComet(); }
     @Override
     public boolean getUsePolling() { return true; } // Always supported
 
@@ -610,22 +601,11 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
         return true;
     }
 
-    public void closeSocket(SocketWrapper<Nio2Channel> socket, SocketStatus status) {
+    public void closeSocket(SocketWrapper<Nio2Channel> socket) {
         if (socket == null) {
             return;
         }
         try {
-            if (socket.isComet() && status != null) {
-                socket.setComet(false);//to avoid a loop
-                if (status == SocketStatus.TIMEOUT) {
-                    if (processSocket0(socket, status, true)) {
-                        return; // don't close on comet timeout
-                    }
-                } else {
-                    // Don't dispatch if the lines below are canceling the key
-                    processSocket0(socket, status, false);
-                }
-            }
             handler.release(socket);
             try {
                 if (socket.getSocket() != null) {
@@ -1088,8 +1068,7 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
                     }
                     if (state == SocketState.CLOSED) {
                         // Close socket and pool
-                        socket.setComet(false);
-                        closeSocket(socket, SocketStatus.ERROR);
+                        closeSocket(socket);
                         if (useCaches && running && !paused) {
                             nioChannels.push(socket.getSocket());
                             socketWrapperCache.push((Nio2SocketWrapper) socket);
@@ -1100,7 +1079,7 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
                         launch = true;
                     }
                 } else if (handshake == -1 ) {
-                    closeSocket(socket, SocketStatus.DISCONNECT);
+                    closeSocket(socket);
                     if (useCaches && running && !paused) {
                         nioChannels.push(socket.getSocket());
                         socketWrapperCache.push(((Nio2SocketWrapper) socket));
@@ -1110,7 +1089,7 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
                 try {
                     oomParachuteData = null;
                     log.error("", oom);
-                    closeSocket(socket, SocketStatus.ERROR);
+                    closeSocket(socket);
                     releaseCaches();
                 } catch (Throwable oomt) {
                     try {
@@ -1125,7 +1104,7 @@ public class Nio2Endpoint extends AbstractEndpoint<Nio2Channel> {
             } catch (Throwable t) {
                 log.error(sm.getString("endpoint.processing.fail"), t);
                 if (socket != null) {
-                    closeSocket(socket, SocketStatus.ERROR);
+                    closeSocket(socket);
                 }
             } finally {
                 if (launch) {

==================================================
SecureNio2Channel.java
index 0230191048..bc4d2648f5 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -183,15 +183,6 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
     public Handler getHandler() { return handler; }
 
 
-    /**
-     * Allow comet request handling.
-     */
-    private boolean useComet = true;
-    public void setUseComet(boolean useComet) { this.useComet = useComet; }
-    @Override
-    public boolean getUseComet() { return useComet; }
-    @Override
-    public boolean getUseCometTimeout() { return getUseComet(); }
     @Override
     public boolean getUsePolling() { return true; } // Always supported
 
@@ -618,7 +609,6 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
             if (attachment == null) {
                 return false;
             }
-            attachment.setCometNotify(false); //will get reset upon next reg
             SocketProcessor sc = processorCache.pop();
             if ( sc == null ) sc = new SocketProcessor(attachment, status);
             else sc.reset(attachment, status);
@@ -801,28 +791,22 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                         final KeyAttachment att = (KeyAttachment) key.attachment();
                         if ( att!=null ) {
                             //handle callback flag
-                            if ((interestOps & OP_CALLBACK) == OP_CALLBACK ) {
-                                att.setCometNotify(true);
-                            } else {
-                                att.setCometNotify(false);
-                            }
                             interestOps = (interestOps & (~OP_CALLBACK));//remove the callback flag
                             att.access();//to prevent timeout
                             //we are registering the key to start with, reset the fairness counter.
                             int ops = key.interestOps() | interestOps;
                             att.interestOps(ops);
-                            if (att.getCometNotify()) key.interestOps(0);
-                            else key.interestOps(ops);
+                            key.interestOps(ops);
                         } else {
                             cancel = true;
                         }
                     } else {
                         cancel = true;
                     }
-                    if ( cancel ) socket.getPoller().cancelledKey(key,SocketStatus.ERROR);
+                    if ( cancel ) socket.getPoller().cancelledKey(key);
                 }catch (CancelledKeyException ckx) {
                     try {
-                        socket.getPoller().cancelledKey(key,SocketStatus.DISCONNECT);
+                        socket.getPoller().cancelledKey(key);
                     }catch (Exception ignore) {}
                 }
             }//end if
@@ -950,21 +934,10 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
             addEvent(r);
         }
 
-        public void cancelledKey(SelectionKey key, SocketStatus status) {
+        public void cancelledKey(SelectionKey key) {
             try {
                 if ( key == null ) return;//nothing to do
                 KeyAttachment ka = (KeyAttachment) key.attachment();
-                if (ka != null && ka.isComet() && status != null) {
-                    ka.setComet(false);//to avoid a loop
-                    if (status == SocketStatus.TIMEOUT ) {
-                        if (processSocket(ka, status, true)) {
-                            return; // don't close on comet timeout
-                        }
-                    } else {
-                        // Don't dispatch if the lines below are canceling the key
-                        processSocket(ka, status, false);
-                    }
-                }
                 key.attach(null);
                 if (ka!=null) handler.release(ka);
                 else handler.release((SocketChannel)key.channel());
@@ -1114,7 +1087,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
             boolean result = true;
             try {
                 if ( close ) {
-                    cancelledKey(sk, SocketStatus.STOP);
+                    cancelledKey(sk);
                 } else if ( sk.isValid() && attachment != null ) {
                     attachment.access();//make sure we don't time out valid sockets
                     if (sk.isReadable() || sk.isWritable() ) {
@@ -1136,7 +1109,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                                     }
                                 }
                                 if (closeSocket) {
-                                    cancelledKey(sk,SocketStatus.DISCONNECT);
+                                    cancelledKey(sk);
                                 }
                             } else {
                                 result = false;
@@ -1145,10 +1118,10 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                     }
                 } else {
                     //invalid key
-                    cancelledKey(sk, SocketStatus.ERROR);
+                    cancelledKey(sk);
                 }
             } catch ( CancelledKeyException ckx ) {
-                cancelledKey(sk, SocketStatus.ERROR);
+                cancelledKey(sk);
             } catch (Throwable t) {
                 ExceptionUtils.handleThrowable(t);
                 log.error("",t);
@@ -1170,7 +1143,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                 if ( sd.fchannel == null ) {
                     File f = new File(sd.fileName);
                     if ( !f.exists() ) {
-                        cancelledKey(sk,SocketStatus.ERROR);
+                        cancelledKey(sk);
                         return false;
                     }
                     @SuppressWarnings("resource") // Closed when channel is closed
@@ -1226,7 +1199,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                         if (log.isDebugEnabled()) {
                             log.debug("Send file connection is being closed");
                         }
-                        cancelledKey(sk,SocketStatus.STOP);
+                        cancelledKey(sk);
                         return false;
                     }
                 } else {
@@ -1241,11 +1214,11 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                 }
             }catch ( IOException x ) {
                 if ( log.isDebugEnabled() ) log.debug("Unable to complete sendfile request:", x);
-                cancelledKey(sk,SocketStatus.ERROR);
+                cancelledKey(sk);
                 return false;
             }catch ( Throwable t ) {
                 log.error("",t);
-                cancelledKey(sk, SocketStatus.ERROR);
+                cancelledKey(sk);
                 return false;
             }finally {
                 if (sc!=null) sc.setSendFile(false);
@@ -1284,15 +1257,9 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                 try {
                     KeyAttachment ka = (KeyAttachment) key.attachment();
                     if ( ka == null ) {
-                        cancelledKey(key, SocketStatus.ERROR); //we don't support any keys without attachments
+                        cancelledKey(key); //we don't support any keys without attachments
                     } else if ( ka.getError() ) {
-                        cancelledKey(key, SocketStatus.ERROR);//TODO this is not yet being used
-                    } else if (ka.getCometNotify() ) {
-                        ka.setCometNotify(false);
-                        int ops = ka.interestOps() & ~OP_CALLBACK;
-                        reg(key,ka,0);//avoid multiple calls, this gets re-registered after invocation
-                        ka.interestOps(ops);
-                        if (!processSocket(ka, SocketStatus.OPEN_READ, true)) processSocket(ka, SocketStatus.DISCONNECT, true);
+                        cancelledKey(key);//TODO this is not yet being used
                     } else if ((ka.interestOps()&SelectionKey.OP_READ) == SelectionKey.OP_READ ||
                               (ka.interestOps()&SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {
                         //only timeout sockets that we are waiting for a read from
@@ -1306,9 +1273,9 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                         } else if (isTimedout) {
                             key.interestOps(0);
                             ka.interestOps(0); //avoid duplicate timeout calls
-                            cancelledKey(key, SocketStatus.TIMEOUT);
+                            cancelledKey(key);
                         }
-                    } else if (ka.isAsync() || ka.isComet()) {
+                    } else if (ka.isAsync()) {
                         if (close) {
                             key.interestOps(0);
                             ka.interestOps(0); //avoid duplicate stop calls
@@ -1326,7 +1293,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                         }
                     }//end if
                 }catch ( CancelledKeyException ckx ) {
-                    cancelledKey(key, SocketStatus.ERROR);
+                    cancelledKey(key);
                 }
             }//for
             long prevExp = nextExpiration; //for logging purposes only
@@ -1352,7 +1319,6 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
         public void reset(Poller poller, NioChannel channel, long soTimeout) {
             super.reset(channel, soTimeout);
 
-            cometNotify = false;
             interestOps = 0;
             this.poller = poller;
             sendfileData = null;
@@ -1384,8 +1350,6 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
 
         public Poller getPoller() { return poller;}
         public void setPoller(Poller poller){this.poller = poller;}
-        public void setCometNotify(boolean notify) { this.cometNotify = notify; }
-        public boolean getCometNotify() { return cometNotify; }
         public int interestOps() { return interestOps;}
         public int interestOps(int ops) { this.interestOps  = ops; return ops; }
         public CountDownLatch getReadLatch() { return readLatch; }
@@ -1426,7 +1390,6 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
 
         private Poller poller = null;
         private int interestOps = 0;
-        private boolean cometNotify = false;
         private CountDownLatch readLatch = null;
         private CountDownLatch writeLatch = null;
         private SendfileData sendfileData = null;
@@ -1558,8 +1521,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                     if (state == SocketState.CLOSED) {
                         // Close socket and pool
                         try {
-                            ka.setComet(false);
-                            socket.getPoller().cancelledKey(key, SocketStatus.ERROR);
+                            socket.getPoller().cancelledKey(key);
                             if (running && !paused) {
                                 nioChannels.push(socket);
                             }
@@ -1577,7 +1539,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                     }
                 } else if (handshake == -1 ) {
                     if (key != null) {
-                        socket.getPoller().cancelledKey(key, SocketStatus.DISCONNECT);
+                        socket.getPoller().cancelledKey(key);
                     }
                     if (running && !paused) {
                         nioChannels.push(socket);
@@ -1592,14 +1554,14 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
                 }
             } catch (CancelledKeyException cx) {
                 if (socket != null) {
-                    socket.getPoller().cancelledKey(key, null);
+                    socket.getPoller().cancelledKey(key);
                 }
             } catch (OutOfMemoryError oom) {
                 try {
                     oomParachuteData = null;
                     log.error("", oom);
                     if (socket != null) {
-                        socket.getPoller().cancelledKey(key,SocketStatus.ERROR);
+                        socket.getPoller().cancelledKey(key);
                     }
                     releaseCaches();
                 } catch (Throwable oomt) {
@@ -1615,7 +1577,7 @@ public class NioEndpoint extends AbstractEndpoint<NioChannel> {
             } catch (Throwable t) {
                 log.error("", t);
                 if (socket != null) {
-                    socket.getPoller().cancelledKey(key,SocketStatus.ERROR);
+                    socket.getPoller().cancelledKey(key);
                 }
             } finally {
                 socket = null;

==================================================
SocketWrapper.java
index ba16492244..ec51f75ec8 100644
--- a/java/org/apache/tomcat/util/net/SecureNio2Channel.java
+++ b/java/org/apache/tomcat/util/net/SecureNio2Channel.java
@@ -84,7 +84,7 @@ public class SecureNio2Channel extends Nio2Channel  {
             }
             @Override
             public void failed(Throwable exc, SocketWrapper<Nio2Channel> attachment) {
-                endpoint.closeSocket(attachment, SocketStatus.ERROR);
+                endpoint.closeSocket(attachment);
             }
         };
         handshakeWriteCompletionHandler = new CompletionHandler<Integer, SocketWrapper<Nio2Channel>>() {
@@ -98,7 +98,7 @@ public class SecureNio2Channel extends Nio2Channel  {
             }
             @Override
             public void failed(Throwable exc, SocketWrapper<Nio2Channel> attachment) {
-                endpoint.closeSocket(attachment, SocketStatus.ERROR);
+                endpoint.closeSocket(attachment);
             }
         };
     }

==================================================
TestCometProcessor.java
index 5cd540df6f..9ebf87c0d2 100644
--- a/java/org/apache/tomcat/util/net/SocketWrapper.java
+++ b/java/org/apache/tomcat/util/net/SocketWrapper.java
@@ -31,7 +31,6 @@ public class SocketWrapper<E> {
     private long timeout = -1;
     private boolean error = false;
     private volatile int keepAliveLeft = 100;
-    private volatile boolean comet = false;
     private volatile boolean async = false;
     private boolean keptAlive = false;
     private volatile boolean upgraded = false;
@@ -76,8 +75,6 @@ public class SocketWrapper<E> {
         return socket;
     }
 
-    public boolean isComet() { return comet; }
-    public void setComet(boolean comet) { this.comet = comet; }
     public boolean isAsync() { return async; }
     public void setAsync(boolean async) { this.async = async; }
     public boolean isUpgraded() { return upgraded; }
@@ -155,7 +152,6 @@ public class SocketWrapper<E> {
     public void reset(E socket, long timeout) {
         async = false;
         blockingStatus = true;
-        comet = false;
         dispatches.clear();
         error = false;
         keepAliveLeft = 100;

==================================================
ChatServlet.java
index 36c1dcf7fa..1c409f846e 100644
--- a/webapps/docs/config/http.xml
+++ b/webapps/docs/config/http.xml
@@ -677,11 +677,6 @@
         default value is <code>1000</code> milliseconds.</p>
       </attribute>
 
-      <attribute name="useComet" required="false">
-        <p>(bool)Whether to allow comet servlets or not. Default value is
-        <code>true</code>.</p>
-      </attribute>
-
       <attribute name="useSendfile" required="false">
         <p>(bool)Use this attribute to enable or disable sendfile capability.
         The default value is <code>true</code>. Note that the use of sendfile
@@ -812,11 +807,6 @@
         The default value is <code>false</code>.</p>
       </attribute>
 
-      <attribute name="useComet" required="false">
-        <p>(bool)Whether to allow comet servlets or not. Default value is
-        <code>true</code>.</p>
-      </attribute>
-
       <attribute name="useSendfile" required="false">
         <p>(bool)Use this attribute to enable or disable sendfile capability.
         The default value is <code>true</code>. Note that the use of sendfile
@@ -964,11 +954,6 @@
         this priority means.</p>
       </attribute>
 
-      <attribute name="useComet" required="false">
-        <p>(bool)Whether to allow comet servlets or not. Default value is
-        <code>true</code>.</p>
-      </attribute>
-
       <attribute name="useSendfile" required="false">
         <p>(bool)Use this attribute to enable or disable sendfile capability.
         The default value is <code>true</code>. Note that the use of sendfile

==================================================
