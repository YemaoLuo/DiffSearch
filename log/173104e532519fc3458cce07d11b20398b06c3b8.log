173104e532519fc3458cce07d11b20398b06c3b8
==================================================
Add support for defining Sets, Lists and Maps to the parser. The new nodes (the Ast*.java files) are just the auto-generated skeletons and some - if not all - will need some work before these new expression elements are fully implemented.
==================================================
Mark Emlyn
==================================================
Sat Jul 13 19:28:02 2013 +0000
==================================================
AstListData.java
Add support for defining Sets, Lists and Maps to the parser. The new nodes (the Ast*.java files) are just the auto-generated skeletons and some - if not all - will need some work before these new expression elements are fully implemented.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1502847 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AstMapData.java
new file mode 100644
index 0000000000..904325962a
--- /dev/null
+++ b/java/org/apache/el/parser/AstListData.java
@@ -0,0 +1,26 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/* Generated By:JJTree: Do not edit this line. AstListData.java Version 4.3 */
+package org.apache.el.parser;
+
+public
+class AstListData extends SimpleNode {
+  public AstListData(int id) {
+    super(id);
+  }
+}
+/* JavaCC - OriginalChecksum=7f2694086a9ba64558ee39d1cd719db1 (do not edit this line) */

==================================================
AstMapEntry.java
new file mode 100644
index 0000000000..c12369300c
--- /dev/null
+++ b/java/org/apache/el/parser/AstMapData.java
@@ -0,0 +1,26 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/* Generated By:JJTree: Do not edit this line. AstMapData.java Version 4.3 */
+package org.apache.el.parser;
+
+public
+class AstMapData extends SimpleNode {
+  public AstMapData(int id) {
+    super(id);
+  }
+}
+/* JavaCC - OriginalChecksum=a68b5c6f0a0708f478fdf8c0e6e1263e (do not edit this line) */

==================================================
AstSetData.java
new file mode 100644
index 0000000000..5a897dc097
--- /dev/null
+++ b/java/org/apache/el/parser/AstMapEntry.java
@@ -0,0 +1,26 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/* Generated By:JJTree: Do not edit this line. AstMapEntry.java Version 4.3 */
+package org.apache.el.parser;
+
+public
+class AstMapEntry extends SimpleNode {
+  public AstMapEntry(int id) {
+    super(id);
+  }
+}
+/* JavaCC - OriginalChecksum=6a7910e58a583371769800554113a8d3 (do not edit this line) */

==================================================
ELParser.java
new file mode 100644
index 0000000000..6aca4a490f
--- /dev/null
+++ b/java/org/apache/el/parser/AstSetData.java
@@ -0,0 +1,26 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/* Generated By:JJTree: Do not edit this line. AstSetData.java Version 4.3 */
+package org.apache.el.parser;
+
+public
+class AstSetData extends SimpleNode {
+  public AstSetData(int id) {
+    super(id);
+  }
+}
+/* JavaCC - OriginalChecksum=e1dc4e2011eee313491decfa9e0152fe (do not edit this line) */

==================================================
ELParserConstants.java
index 8cf65dd8df..32a9b63743 100644
--- a/java/org/apache/el/parser/ELParser.jjt
+++ b/java/org/apache/el/parser/ELParser.jjt
@@ -78,7 +78,7 @@ void LiteralExpression() #LiteralExpression : { Token t = null; }
  */
 void DeferredExpression() #DeferredExpression : {}
 {
-    <START_DEFERRED_EXPRESSION> Expression() <END_EXPRESSION>
+    <START_DEFERRED_EXPRESSION> Expression() <RCURL>
 }
 
 /*
@@ -87,7 +87,7 @@ void DeferredExpression() #DeferredExpression : {}
  */
 void DynamicExpression() #DynamicExpression : {}
 {
-    <START_DYNAMIC_EXPRESSION> Expression() <END_EXPRESSION>
+    <START_DYNAMIC_EXPRESSION> Expression() <RCURL>
 }
 
 /*
@@ -266,6 +266,35 @@ void NonLiteral() : {}
     <LPAREN> Expression() <RPAREN>
     | LOOKAHEAD((<IDENTIFIER> <COLON>)? <IDENTIFIER> <LPAREN>) Function()
     | Identifier()
+    | LOOKAHEAD(3)SetData()
+    | ListData()
+    | MapData()
+}
+
+void SetData() #SetData: {}
+{
+    <START_SET_OR_MAP>
+        ( Expression() ( <COMMA> Expression() )* )?
+    <RCURL>
+}
+
+void ListData() #ListData: {}
+{
+    <LBRACK>
+        ( Expression() ( <COMMA> Expression() )* )?
+    <RBRACK>
+}
+
+void MapData() #MapData: {}
+{
+    <START_SET_OR_MAP>
+        ( MapEntry() ( <COMMA> MapEntry() )* )?
+    <RCURL>
+}
+
+void MapEntry() #MapEntry: {}
+{
+    Expression() <COLON> Expression()
 }
 
 /*
@@ -360,6 +389,10 @@ void Null() #Null : {}
 
 
 /* ========================================================================== */
+TOKEN_MGR_DECLS:
+{
+java.util.Deque<Integer> deque = new java.util.ArrayDeque<Integer>();
+}
 <DEFAULT> TOKEN :
 {
   /*
@@ -376,16 +409,18 @@ void Null() #Null : {}
     | "#"
   >
 |
-  < START_DYNAMIC_EXPRESSION: "${" > : IN_EXPRESSION
+  < START_DYNAMIC_EXPRESSION: "${" > {deque.push(DEFAULT);}: IN_EXPRESSION
 |
-  < START_DEFERRED_EXPRESSION: "#{" > : IN_EXPRESSION
+  < START_DEFERRED_EXPRESSION: "#{" > {deque.push(DEFAULT);}: IN_EXPRESSION
 }
 
 <IN_EXPRESSION> SKIP : { " " | "\t" | "\n" | "\r" }
 
-<IN_EXPRESSION> TOKEN :
+<IN_EXPRESSION, IN_SET_OR_MAP> TOKEN :
 {
-     < INTEGER_LITERAL: ["0"-"9"] (["0"-"9"])* >
+     < START_SET_OR_MAP : "{" > {deque.push(curLexState);}: IN_SET_OR_MAP
+|    < RCURL: "}" > {SwitchTo(deque.pop());}
+|    < INTEGER_LITERAL: ["0"-"9"] (["0"-"9"])* >
 |    < FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
         | "." (["0"-"9"])+ (<EXPONENT>)?
         | (["0"-"9"])+ <EXPONENT>
@@ -399,7 +434,6 @@ void Null() #Null : {}
 |    < TRUE : "true" >
 |    < FALSE : "false" >
 |    < NULL : "null" >
-|    < END_EXPRESSION : "}" > : DEFAULT
 |    < DOT : "." >
 |    < LPAREN : "(" >
 |    < RPAREN : ")" >

==================================================
ELParserTokenManager.java
index 50c825d42c..8cabca350a 100644
--- a/java/org/apache/el/parser/ELParserConstants.java
+++ b/java/org/apache/el/parser/ELParserConstants.java
@@ -17,108 +17,112 @@ public interface ELParserConstants {
   /** RegularExpression Id. */
   int START_DEFERRED_EXPRESSION = 3;
   /** RegularExpression Id. */
-  int INTEGER_LITERAL = 8;
+  int START_SET_OR_MAP = 8;
   /** RegularExpression Id. */
-  int FLOATING_POINT_LITERAL = 9;
+  int RCURL = 9;
   /** RegularExpression Id. */
-  int EXPONENT = 10;
+  int INTEGER_LITERAL = 10;
   /** RegularExpression Id. */
-  int STRING_LITERAL = 11;
+  int FLOATING_POINT_LITERAL = 11;
   /** RegularExpression Id. */
-  int TRUE = 12;
+  int EXPONENT = 12;
   /** RegularExpression Id. */
-  int FALSE = 13;
+  int STRING_LITERAL = 13;
   /** RegularExpression Id. */
-  int NULL = 14;
+  int TRUE = 14;
   /** RegularExpression Id. */
-  int END_EXPRESSION = 15;
+  int FALSE = 15;
   /** RegularExpression Id. */
-  int DOT = 16;
+  int NULL = 16;
   /** RegularExpression Id. */
-  int LPAREN = 17;
+  int DOT = 17;
   /** RegularExpression Id. */
-  int RPAREN = 18;
+  int LPAREN = 18;
   /** RegularExpression Id. */
-  int LBRACK = 19;
+  int RPAREN = 19;
   /** RegularExpression Id. */
-  int RBRACK = 20;
+  int LBRACK = 20;
   /** RegularExpression Id. */
-  int COLON = 21;
+  int RBRACK = 21;
   /** RegularExpression Id. */
-  int COMMA = 22;
+  int COLON = 22;
   /** RegularExpression Id. */
-  int GT0 = 23;
+  int COMMA = 23;
   /** RegularExpression Id. */
-  int GT1 = 24;
+  int GT0 = 24;
   /** RegularExpression Id. */
-  int LT0 = 25;
+  int GT1 = 25;
   /** RegularExpression Id. */
-  int LT1 = 26;
+  int LT0 = 26;
   /** RegularExpression Id. */
-  int GE0 = 27;
+  int LT1 = 27;
   /** RegularExpression Id. */
-  int GE1 = 28;
+  int GE0 = 28;
   /** RegularExpression Id. */
-  int LE0 = 29;
+  int GE1 = 29;
   /** RegularExpression Id. */
-  int LE1 = 30;
+  int LE0 = 30;
   /** RegularExpression Id. */
-  int EQ0 = 31;
+  int LE1 = 31;
   /** RegularExpression Id. */
-  int EQ1 = 32;
+  int EQ0 = 32;
   /** RegularExpression Id. */
-  int NE0 = 33;
+  int EQ1 = 33;
   /** RegularExpression Id. */
-  int NE1 = 34;
+  int NE0 = 34;
   /** RegularExpression Id. */
-  int NOT0 = 35;
+  int NE1 = 35;
   /** RegularExpression Id. */
-  int NOT1 = 36;
+  int NOT0 = 36;
   /** RegularExpression Id. */
-  int AND0 = 37;
+  int NOT1 = 37;
   /** RegularExpression Id. */
-  int AND1 = 38;
+  int AND0 = 38;
   /** RegularExpression Id. */
-  int OR0 = 39;
+  int AND1 = 39;
   /** RegularExpression Id. */
-  int OR1 = 40;
+  int OR0 = 40;
   /** RegularExpression Id. */
-  int EMPTY = 41;
+  int OR1 = 41;
   /** RegularExpression Id. */
-  int INSTANCEOF = 42;
+  int EMPTY = 42;
   /** RegularExpression Id. */
-  int MULT = 43;
+  int INSTANCEOF = 43;
   /** RegularExpression Id. */
-  int PLUS = 44;
+  int MULT = 44;
   /** RegularExpression Id. */
-  int MINUS = 45;
+  int PLUS = 45;
   /** RegularExpression Id. */
-  int QUESTIONMARK = 46;
+  int MINUS = 46;
   /** RegularExpression Id. */
-  int DIV0 = 47;
+  int QUESTIONMARK = 47;
   /** RegularExpression Id. */
-  int DIV1 = 48;
+  int DIV0 = 48;
   /** RegularExpression Id. */
-  int MOD0 = 49;
+  int DIV1 = 49;
   /** RegularExpression Id. */
-  int MOD1 = 50;
+  int MOD0 = 50;
   /** RegularExpression Id. */
-  int IDENTIFIER = 51;
+  int MOD1 = 51;
   /** RegularExpression Id. */
-  int FUNCTIONSUFFIX = 52;
+  int IDENTIFIER = 52;
   /** RegularExpression Id. */
-  int IMPL_OBJ_START = 53;
+  int FUNCTIONSUFFIX = 53;
   /** RegularExpression Id. */
-  int LETTER = 54;
+  int IMPL_OBJ_START = 54;
   /** RegularExpression Id. */
-  int DIGIT = 55;
+  int LETTER = 55;
   /** RegularExpression Id. */
-  int ILLEGAL_CHARACTER = 56;
+  int DIGIT = 56;
+  /** RegularExpression Id. */
+  int ILLEGAL_CHARACTER = 57;
 
   /** Lexical state. */
   int DEFAULT = 0;
   /** Lexical state. */
   int IN_EXPRESSION = 1;
+  /** Lexical state. */
+  int IN_SET_OR_MAP = 2;
 
   /** Literal token values. */
   String[] tokenImage = {
@@ -130,6 +134,8 @@ public interface ELParserConstants {
     "\"\\t\"",
     "\"\\n\"",
     "\"\\r\"",
+    "\"{\"",
+    "\"}\"",
     "<INTEGER_LITERAL>",
     "<FLOATING_POINT_LITERAL>",
     "<EXPONENT>",
@@ -137,7 +143,6 @@ public interface ELParserConstants {
     "\"true\"",
     "\"false\"",
     "\"null\"",
-    "\"}\"",
     "\".\"",
     "\"(\"",
     "\")\"",

==================================================
ELParserTreeConstants.java
index 8e9ded967b..abf7ff9ff1 100644
--- a/java/org/apache/el/parser/ELParserTokenManager.java
+++ b/java/org/apache/el/parser/ELParserTokenManager.java
@@ -1,10 +1,13 @@
 /* Generated By:JJTree&JavaCC: Do not edit this line. ELParserTokenManager.java */
 package org.apache.el.parser;
+import java.io.StringReader;
+import javax.el.ELException;
 
 /** Token Manager. */
 @SuppressWarnings("all") // Ignore warnings in generated code
 public class ELParserTokenManager implements ELParserConstants
 {
+java.util.Deque<Integer> deque = new java.util.ArrayDeque<Integer>();
 
   /** Debug output. */
   public  java.io.PrintStream debugStream = System.out;
@@ -254,87 +257,869 @@ private int jjMoveNfa_0(int startState, int curPos)
       catch(java.io.IOException e) { return curPos; }
    }
 }
+private final int jjStopStringLiteralDfa_2(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x20000L) != 0L)
+            return 1;
+         if ((active0 & 0xa0eaaaa01c000L) != 0L)
+         {
+            jjmatchedKind = 52;
+            return 30;
+         }
+         return -1;
+      case 1:
+         if ((active0 & 0x20aaa000000L) != 0L)
+            return 30;
+         if ((active0 & 0xa0ca00001c000L) != 0L)
+         {
+            jjmatchedKind = 52;
+            jjmatchedPos = 1;
+            return 30;
+         }
+         return -1;
+      case 2:
+         if ((active0 & 0xa00a000000000L) != 0L)
+            return 30;
+         if ((active0 & 0xc000001c000L) != 0L)
+         {
+            jjmatchedKind = 52;
+            jjmatchedPos = 2;
+            return 30;
+         }
+         return -1;
+      case 3:
+         if ((active0 & 0x14000L) != 0L)
+            return 30;
+         if ((active0 & 0xc0000008000L) != 0L)
+         {
+            jjmatchedKind = 52;
+            jjmatchedPos = 3;
+            return 30;
+         }
+         return -1;
+      case 4:
+         if ((active0 & 0x40000008000L) != 0L)
+            return 30;
+         if ((active0 & 0x80000000000L) != 0L)
+         {
+            jjmatchedKind = 52;
+            jjmatchedPos = 4;
+            return 30;
+         }
+         return -1;
+      case 5:
+         if ((active0 & 0x80000000000L) != 0L)
+         {
+            jjmatchedKind = 52;
+            jjmatchedPos = 5;
+            return 30;
+         }
+         return -1;
+      case 6:
+         if ((active0 & 0x80000000000L) != 0L)
+         {
+            jjmatchedKind = 52;
+            jjmatchedPos = 6;
+            return 30;
+         }
+         return -1;
+      case 7:
+         if ((active0 & 0x80000000000L) != 0L)
+         {
+            jjmatchedKind = 52;
+            jjmatchedPos = 7;
+            return 30;
+         }
+         return -1;
+      case 8:
+         if ((active0 & 0x80000000000L) != 0L)
+         {
+            jjmatchedKind = 52;
+            jjmatchedPos = 8;
+            return 30;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_2(int pos, long active0)
+{
+   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
+}
+private int jjMoveStringLiteralDfa0_2()
+{
+   switch(curChar)
+   {
+      case 33:
+         jjmatchedKind = 36;
+         return jjMoveStringLiteralDfa1_2(0x400000000L);
+      case 37:
+         return jjStopAtPos(0, 50);
+      case 38:
+         return jjMoveStringLiteralDfa1_2(0x4000000000L);
+      case 40:
+         return jjStopAtPos(0, 18);
+      case 41:
+         return jjStopAtPos(0, 19);
+      case 42:
+         return jjStopAtPos(0, 44);
+      case 43:
+         return jjStopAtPos(0, 45);
+      case 44:
+         return jjStopAtPos(0, 23);
+      case 45:
+         return jjStopAtPos(0, 46);
+      case 46:
+         return jjStartNfaWithStates_2(0, 17, 1);
+      case 47:
+         return jjStopAtPos(0, 48);
+      case 58:
+         return jjStopAtPos(0, 22);
+      case 60:
+         jjmatchedKind = 26;
+         return jjMoveStringLiteralDfa1_2(0x40000000L);
+      case 61:
+         return jjMoveStringLiteralDfa1_2(0x100000000L);
+      case 62:
+         jjmatchedKind = 24;
+         return jjMoveStringLiteralDfa1_2(0x10000000L);
+      case 63:
+         return jjStopAtPos(0, 47);
+      case 91:
+         return jjStopAtPos(0, 20);
+      case 93:
+         return jjStopAtPos(0, 21);
+      case 97:
+         return jjMoveStringLiteralDfa1_2(0x8000000000L);
+      case 100:
+         return jjMoveStringLiteralDfa1_2(0x2000000000000L);
+      case 101:
+         return jjMoveStringLiteralDfa1_2(0x40200000000L);
+      case 102:
+         return jjMoveStringLiteralDfa1_2(0x8000L);
+      case 103:
+         return jjMoveStringLiteralDfa1_2(0x22000000L);
+      case 105:
+         return jjMoveStringLiteralDfa1_2(0x80000000000L);
+      case 108:
+         return jjMoveStringLiteralDfa1_2(0x88000000L);
+      case 109:
+         return jjMoveStringLiteralDfa1_2(0x8000000000000L);
+      case 110:
+         return jjMoveStringLiteralDfa1_2(0x2800010000L);
+      case 111:
+         return jjMoveStringLiteralDfa1_2(0x20000000000L);
+      case 116:
+         return jjMoveStringLiteralDfa1_2(0x4000L);
+      case 123:
+         return jjStopAtPos(0, 8);
+      case 124:
+         return jjMoveStringLiteralDfa1_2(0x10000000000L);
+      case 125:
+         return jjStopAtPos(0, 9);
+      default :
+         return jjMoveNfa_2(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_2(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_2(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 38:
+         if ((active0 & 0x4000000000L) != 0L)
+            return jjStopAtPos(1, 38);
+         break;
+      case 61:
+         if ((active0 & 0x10000000L) != 0L)
+            return jjStopAtPos(1, 28);
+         else if ((active0 & 0x40000000L) != 0L)
+            return jjStopAtPos(1, 30);
+         else if ((active0 & 0x100000000L) != 0L)
+            return jjStopAtPos(1, 32);
+         else if ((active0 & 0x400000000L) != 0L)
+            return jjStopAtPos(1, 34);
+         break;
+      case 97:
+         return jjMoveStringLiteralDfa2_2(active0, 0x8000L);
+      case 101:
+         if ((active0 & 0x20000000L) != 0L)
+            return jjStartNfaWithStates_2(1, 29, 30);
+         else if ((active0 & 0x80000000L) != 0L)
+            return jjStartNfaWithStates_2(1, 31, 30);
+         else if ((active0 & 0x800000000L) != 0L)
+            return jjStartNfaWithStates_2(1, 35, 30);
+         break;
+      case 105:
+         return jjMoveStringLiteralDfa2_2(active0, 0x2000000000000L);
+      case 109:
+         return jjMoveStringLiteralDfa2_2(active0, 0x40000000000L);
+      case 110:
+         return jjMoveStringLiteralDfa2_2(active0, 0x88000000000L);
+      case 111:
+         return jjMoveStringLiteralDfa2_2(active0, 0x8002000000000L);
+      case 113:
+         if ((active0 & 0x200000000L) != 0L)
+            return jjStartNfaWithStates_2(1, 33, 30);
+         break;
+      case 114:
+         if ((active0 & 0x20000000000L) != 0L)
+            return jjStartNfaWithStates_2(1, 41, 30);
+         return jjMoveStringLiteralDfa2_2(active0, 0x4000L);
+      case 116:
+         if ((active0 & 0x2000000L) != 0L)
+            return jjStartNfaWithStates_2(1, 25, 30);
+         else if ((active0 & 0x8000000L) != 0L)
+            return jjStartNfaWithStates_2(1, 27, 30);
+         break;
+      case 117:
+         return jjMoveStringLiteralDfa2_2(active0, 0x10000L);
+      case 124:
+         if ((active0 & 0x10000000000L) != 0L)
+            return jjStopAtPos(1, 40);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_2(0, active0);
+}
+private int jjMoveStringLiteralDfa2_2(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_2(0, old0);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_2(1, active0);
+      return 2;
+   }
+   switch(curChar)
+   {
+      case 100:
+         if ((active0 & 0x8000000000L) != 0L)
+            return jjStartNfaWithStates_2(2, 39, 30);
+         else if ((active0 & 0x8000000000000L) != 0L)
+            return jjStartNfaWithStates_2(2, 51, 30);
+         break;
+      case 108:
+         return jjMoveStringLiteralDfa3_2(active0, 0x18000L);
+      case 112:
+         return jjMoveStringLiteralDfa3_2(active0, 0x40000000000L);
+      case 115:
+         return jjMoveStringLiteralDfa3_2(active0, 0x80000000000L);
+      case 116:
+         if ((active0 & 0x2000000000L) != 0L)
+            return jjStartNfaWithStates_2(2, 37, 30);
+         break;
+      case 117:
+         return jjMoveStringLiteralDfa3_2(active0, 0x4000L);
+      case 118:
+         if ((active0 & 0x2000000000000L) != 0L)
+            return jjStartNfaWithStates_2(2, 49, 30);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_2(1, active0);
+}
+private int jjMoveStringLiteralDfa3_2(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_2(1, old0);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_2(2, active0);
+      return 3;
+   }
+   switch(curChar)
+   {
+      case 101:
+         if ((active0 & 0x4000L) != 0L)
+            return jjStartNfaWithStates_2(3, 14, 30);
+         break;
+      case 108:
+         if ((active0 & 0x10000L) != 0L)
+            return jjStartNfaWithStates_2(3, 16, 30);
+         break;
+      case 115:
+         return jjMoveStringLiteralDfa4_2(active0, 0x8000L);
+      case 116:
+         return jjMoveStringLiteralDfa4_2(active0, 0xc0000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_2(2, active0);
+}
+private int jjMoveStringLiteralDfa4_2(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_2(2, old0);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_2(3, active0);
+      return 4;
+   }
+   switch(curChar)
+   {
+      case 97:
+         return jjMoveStringLiteralDfa5_2(active0, 0x80000000000L);
+      case 101:
+         if ((active0 & 0x8000L) != 0L)
+            return jjStartNfaWithStates_2(4, 15, 30);
+         break;
+      case 121:
+         if ((active0 & 0x40000000000L) != 0L)
+            return jjStartNfaWithStates_2(4, 42, 30);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_2(3, active0);
+}
+private int jjMoveStringLiteralDfa5_2(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_2(3, old0);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_2(4, active0);
+      return 5;
+   }
+   switch(curChar)
+   {
+      case 110:
+         return jjMoveStringLiteralDfa6_2(active0, 0x80000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_2(4, active0);
+}
+private int jjMoveStringLiteralDfa6_2(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_2(4, old0);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_2(5, active0);
+      return 6;
+   }
+   switch(curChar)
+   {
+      case 99:
+         return jjMoveStringLiteralDfa7_2(active0, 0x80000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_2(5, active0);
+}
+private int jjMoveStringLiteralDfa7_2(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_2(5, old0);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_2(6, active0);
+      return 7;
+   }
+   switch(curChar)
+   {
+      case 101:
+         return jjMoveStringLiteralDfa8_2(active0, 0x80000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_2(6, active0);
+}
+private int jjMoveStringLiteralDfa8_2(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_2(6, old0);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_2(7, active0);
+      return 8;
+   }
+   switch(curChar)
+   {
+      case 111:
+         return jjMoveStringLiteralDfa9_2(active0, 0x80000000000L);
+      default :
+         break;
+   }
+   return jjStartNfa_2(7, active0);
+}
+private int jjMoveStringLiteralDfa9_2(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_2(7, old0);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_2(8, active0);
+      return 9;
+   }
+   switch(curChar)
+   {
+      case 102:
+         if ((active0 & 0x80000000000L) != 0L)
+            return jjStartNfaWithStates_2(9, 43, 30);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_2(8, active0);
+}
+private int jjStartNfaWithStates_2(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_2(state, pos + 1);
+}
+static final long[] jjbitVec3 = {
+   0x1ff00000fffffffeL, 0xffffffffffffc000L, 0xffffffffL, 0x600000000000000L
+};
+static final long[] jjbitVec4 = {
+   0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL
+};
+static final long[] jjbitVec5 = {
+   0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec6 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffL, 0x0L
+};
+static final long[] jjbitVec7 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0x0L, 0x0L
+};
+static final long[] jjbitVec8 = {
+   0x3fffffffffffL, 0x0L, 0x0L, 0x0L
+};
+private int jjMoveNfa_2(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 30;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x3ff000000000000L & l) != 0L)
+                  {
+                     if (kind > 10)
+                        kind = 10;
+                     jjCheckNAddStates(18, 22);
+                  }
+                  else if ((0x1800000000L & l) != 0L)
+                  {
+                     if (kind > 52)
+                        kind = 52;
+                     jjCheckNAddTwoStates(28, 29);
+                  }
+                  else if (curChar == 39)
+                     jjCheckNAddStates(23, 25);
+                  else if (curChar == 34)
+                     jjCheckNAddStates(26, 28);
+                  else if (curChar == 46)
+                     jjCheckNAdd(1);
+                  break;
+               case 30:
+                  if ((0x3ff001000000000L & l) != 0L)
+                  {
+                     if (kind > 53)
+                        kind = 53;
+                     jjCheckNAdd(29);
+                  }
+                  if ((0x3ff001000000000L & l) != 0L)
+                  {
+                     if (kind > 52)
+                        kind = 52;
+                     jjCheckNAdd(28);
+                  }
+                  break;
+               case 1:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 11)
+                     kind = 11;
+                  jjCheckNAddTwoStates(1, 2);
+                  break;
+               case 3:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(4);
+                  break;
+               case 4:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 11)
+                     kind = 11;
+                  jjCheckNAdd(4);
+                  break;
+               case 5:
+                  if (curChar == 34)
+                     jjCheckNAddStates(26, 28);
+                  break;
+               case 6:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(26, 28);
+                  break;
+               case 8:
+                  if ((0x8400000000L & l) != 0L)
+                     jjCheckNAddStates(26, 28);
+                  break;
+               case 9:
+                  if (curChar == 34 && kind > 13)
+                     kind = 13;
+                  break;
+               case 10:
+                  if (curChar == 39)
+                     jjCheckNAddStates(23, 25);
+                  break;
+               case 11:
+                  if ((0xffffff7fffffffffL & l) != 0L)
+                     jjCheckNAddStates(23, 25);
+                  break;
+               case 13:
+                  if ((0x8400000000L & l) != 0L)
+                     jjCheckNAddStates(23, 25);
+                  break;
+               case 14:
+                  if (curChar == 39 && kind > 13)
+                     kind = 13;
+                  break;
+               case 15:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 10)
+                     kind = 10;
+                  jjCheckNAddStates(18, 22);
+                  break;
+               case 16:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 10)
+                     kind = 10;
+                  jjCheckNAdd(16);
+                  break;
+               case 17:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(17, 18);
+                  break;
+               case 18:
+                  if (curChar != 46)
+                     break;
+                  if (kind > 11)
+                     kind = 11;
+                  jjCheckNAddTwoStates(19, 20);
+                  break;
+               case 19:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 11)
+                     kind = 11;
+                  jjCheckNAddTwoStates(19, 20);
+                  break;
+               case 21:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(22);
+                  break;
+               case 22:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 11)
+                     kind = 11;
+                  jjCheckNAdd(22);
+                  break;
+               case 23:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAddTwoStates(23, 24);
+                  break;
+               case 25:
+                  if ((0x280000000000L & l) != 0L)
+                     jjCheckNAdd(26);
+                  break;
+               case 26:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 11)
+                     kind = 11;
+                  jjCheckNAdd(26);
+                  break;
+               case 27:
+                  if ((0x1800000000L & l) == 0L)
+                     break;
+                  if (kind > 52)
+                     kind = 52;
+                  jjCheckNAddTwoStates(28, 29);
+                  break;
+               case 28:
+                  if ((0x3ff001000000000L & l) == 0L)
+                     break;
+                  if (kind > 52)
+                     kind = 52;
+                  jjCheckNAdd(28);
+                  break;
+               case 29:
+                  if ((0x3ff001000000000L & l) == 0L)
+                     break;
+                  if (kind > 53)
+                     kind = 53;
+                  jjCheckNAdd(29);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x7fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 52)
+                     kind = 52;
+                  jjCheckNAddTwoStates(28, 29);
+                  break;
+               case 30:
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 53)
+                        kind = 53;
+                     jjCheckNAdd(29);
+                  }
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 52)
+                        kind = 52;
+                     jjCheckNAdd(28);
+                  }
+                  break;
+               case 2:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(29, 30);
+                  break;
+               case 6:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     jjCheckNAddStates(26, 28);
+                  break;
+               case 7:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  break;
+               case 8:
+                  if (curChar == 92)
+                     jjCheckNAddStates(26, 28);
+                  break;
+               case 11:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     jjCheckNAddStates(23, 25);
+                  break;
+               case 12:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 13;
+                  break;
+               case 13:
+                  if (curChar == 92)
+                     jjCheckNAddStates(23, 25);
+                  break;
+               case 20:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(31, 32);
+                  break;
+               case 24:
+                  if ((0x2000000020L & l) != 0L)
+                     jjAddStates(33, 34);
+                  break;
+               case 28:
+                  if ((0x7fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 52)
+                     kind = 52;
+                  jjCheckNAdd(28);
+                  break;
+               case 29:
+                  if ((0x7fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 53)
+                     kind = 53;
+                  jjCheckNAdd(29);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 52)
+                     kind = 52;
+                  jjCheckNAddTwoStates(28, 29);
+                  break;
+               case 30:
+                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 52)
+                        kind = 52;
+                     jjCheckNAdd(28);
+                  }
+                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 53)
+                        kind = 53;
+                     jjCheckNAdd(29);
+                  }
+                  break;
+               case 6:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjAddStates(26, 28);
+                  break;
+               case 11:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjAddStates(23, 25);
+                  break;
+               case 28:
+                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 52)
+                     kind = 52;
+                  jjCheckNAdd(28);
+                  break;
+               case 29:
+                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 53)
+                     kind = 53;
+                  jjCheckNAdd(29);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 30 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
 private final int jjStopStringLiteralDfa_1(int pos, long active0)
 {
    switch (pos)
    {
       case 0:
-         if ((active0 & 0x10000L) != 0L)
+         if ((active0 & 0x20000L) != 0L)
             return 1;
-         if ((active0 & 0x5075555007000L) != 0L)
+         if ((active0 & 0xa0eaaaa01c000L) != 0L)
          {
-            jjmatchedKind = 51;
+            jjmatchedKind = 52;
             return 30;
          }
          return -1;
       case 1:
-         if ((active0 & 0x5065000007000L) != 0L)
+         if ((active0 & 0x20aaa000000L) != 0L)
+            return 30;
+         if ((active0 & 0xa0ca00001c000L) != 0L)
          {
-            jjmatchedKind = 51;
+            jjmatchedKind = 52;
             jjmatchedPos = 1;
             return 30;
          }
-         if ((active0 & 0x10555000000L) != 0L)
-            return 30;
          return -1;
       case 2:
-         if ((active0 & 0x5005000000000L) != 0L)
+         if ((active0 & 0xa00a000000000L) != 0L)
             return 30;
-         if ((active0 & 0x60000007000L) != 0L)
+         if ((active0 & 0xc000001c000L) != 0L)
          {
-            jjmatchedKind = 51;
+            jjmatchedKind = 52;
             jjmatchedPos = 2;
             return 30;
          }
          return -1;
       case 3:
-         if ((active0 & 0x5000L) != 0L)
+         if ((active0 & 0x14000L) != 0L)
             return 30;
-         if ((active0 & 0x60000002000L) != 0L)
+         if ((active0 & 0xc0000008000L) != 0L)
          {
-            jjmatchedKind = 51;
+            jjmatchedKind = 52;
             jjmatchedPos = 3;
             return 30;
          }
          return -1;
       case 4:
-         if ((active0 & 0x40000000000L) != 0L)
+         if ((active0 & 0x40000008000L) != 0L)
+            return 30;
+         if ((active0 & 0x80000000000L) != 0L)
          {
-            jjmatchedKind = 51;
+            jjmatchedKind = 52;
             jjmatchedPos = 4;
             return 30;
          }
-         if ((active0 & 0x20000002000L) != 0L)
-            return 30;
          return -1;
       case 5:
-         if ((active0 & 0x40000000000L) != 0L)
+         if ((active0 & 0x80000000000L) != 0L)
          {
-            jjmatchedKind = 51;
+            jjmatchedKind = 52;
             jjmatchedPos = 5;
             return 30;
          }
          return -1;
       case 6:
-         if ((active0 & 0x40000000000L) != 0L)
+         if ((active0 & 0x80000000000L) != 0L)
          {
-            jjmatchedKind = 51;
+            jjmatchedKind = 52;
             jjmatchedPos = 6;
             return 30;
          }
          return -1;
       case 7:
-         if ((active0 & 0x40000000000L) != 0L)
+         if ((active0 & 0x80000000000L) != 0L)
          {
-            jjmatchedKind = 51;
+            jjmatchedKind = 52;
             jjmatchedPos = 7;
             return 30;
          }
          return -1;
       case 8:
-         if ((active0 & 0x40000000000L) != 0L)
+         if ((active0 & 0x80000000000L) != 0L)
          {
-            jjmatchedKind = 51;
+            jjmatchedKind = 52;
             jjmatchedPos = 8;
             return 30;
          }
@@ -352,70 +1137,72 @@ private int jjMoveStringLiteralDfa0_1()
    switch(curChar)
    {
       case 33:
-         jjmatchedKind = 35;
-         return jjMoveStringLiteralDfa1_1(0x200000000L);
+         jjmatchedKind = 36;
+         return jjMoveStringLiteralDfa1_1(0x400000000L);
       case 37:
-         return jjStopAtPos(0, 49);
+         return jjStopAtPos(0, 50);
       case 38:
-         return jjMoveStringLiteralDfa1_1(0x2000000000L);
+         return jjMoveStringLiteralDfa1_1(0x4000000000L);
       case 40:
-         return jjStopAtPos(0, 17);
-      case 41:
          return jjStopAtPos(0, 18);
+      case 41:
+         return jjStopAtPos(0, 19);
       case 42:
-         return jjStopAtPos(0, 43);
-      case 43:
          return jjStopAtPos(0, 44);
+      case 43:
+         return jjStopAtPos(0, 45);
       case 44:
-         return jjStopAtPos(0, 22);
+         return jjStopAtPos(0, 23);
       case 45:
-         return jjStopAtPos(0, 45);
+         return jjStopAtPos(0, 46);
       case 46:
-         return jjStartNfaWithStates_1(0, 16, 1);
+         return jjStartNfaWithStates_1(0, 17, 1);
       case 47:
-         return jjStopAtPos(0, 47);
+         return jjStopAtPos(0, 48);
       case 58:
-         return jjStopAtPos(0, 21);
+         return jjStopAtPos(0, 22);
       case 60:
-         jjmatchedKind = 25;
-         return jjMoveStringLiteralDfa1_1(0x20000000L);
+         jjmatchedKind = 26;
+         return jjMoveStringLiteralDfa1_1(0x40000000L);
       case 61:
-         return jjMoveStringLiteralDfa1_1(0x80000000L);
+         return jjMoveStringLiteralDfa1_1(0x100000000L);
       case 62:
-         jjmatchedKind = 23;
-         return jjMoveStringLiteralDfa1_1(0x8000000L);
+         jjmatchedKind = 24;
+         return jjMoveStringLiteralDfa1_1(0x10000000L);
       case 63:
-         return jjStopAtPos(0, 46);
+         return jjStopAtPos(0, 47);
       case 91:
-         return jjStopAtPos(0, 19);
-      case 93:
          return jjStopAtPos(0, 20);
+      case 93:
+         return jjStopAtPos(0, 21);
       case 97:
-         return jjMoveStringLiteralDfa1_1(0x4000000000L);
+         return jjMoveStringLiteralDfa1_1(0x8000000000L);
       case 100:
-         return jjMoveStringLiteralDfa1_1(0x1000000000000L);
+         return jjMoveStringLiteralDfa1_1(0x2000000000000L);
       case 101:
-         return jjMoveStringLiteralDfa1_1(0x20100000000L);
+         return jjMoveStringLiteralDfa1_1(0x40200000000L);
       case 102:
-         return jjMoveStringLiteralDfa1_1(0x2000L);
+         return jjMoveStringLiteralDfa1_1(0x8000L);
       case 103:
-         return jjMoveStringLiteralDfa1_1(0x11000000L);
+         return jjMoveStringLiteralDfa1_1(0x22000000L);
       case 105:
-         return jjMoveStringLiteralDfa1_1(0x40000000000L);
+         return jjMoveStringLiteralDfa1_1(0x80000000000L);
       case 108:
-         return jjMoveStringLiteralDfa1_1(0x44000000L);
+         return jjMoveStringLiteralDfa1_1(0x88000000L);
       case 109:
-         return jjMoveStringLiteralDfa1_1(0x4000000000000L);
+         return jjMoveStringLiteralDfa1_1(0x8000000000000L);
       case 110:
-         return jjMoveStringLiteralDfa1_1(0x1400004000L);
+         return jjMoveStringLiteralDfa1_1(0x2800010000L);
       case 111:
-         return jjMoveStringLiteralDfa1_1(0x10000000000L);
+         return jjMoveStringLiteralDfa1_1(0x20000000000L);
       case 116:
-         return jjMoveStringLiteralDfa1_1(0x1000L);
+         return jjMoveStringLiteralDfa1_1(0x4000L);
+      case 123:
+         return jjStopAtPos(0, 8);
       case 124:
-         return jjMoveStringLiteralDfa1_1(0x8000000000L);
+         return jjMoveStringLiteralDfa1_1(0x10000000000L);
       case 125:
-         return jjStopAtPos(0, 15);
+         return jjStopAtPos(0, 9);
       default :
          return jjMoveNfa_1(0, 0);
    }
@@ -430,56 +1217,56 @@ private int jjMoveStringLiteralDfa1_1(long active0)
    switch(curChar)
    {
       case 38:
-         if ((active0 & 0x2000000000L) != 0L)
-            return jjStopAtPos(1, 37);
+         if ((active0 & 0x4000000000L) != 0L)
+            return jjStopAtPos(1, 38);
          break;
       case 61:
-         if ((active0 & 0x8000000L) != 0L)
-            return jjStopAtPos(1, 27);
-         else if ((active0 & 0x20000000L) != 0L)
-            return jjStopAtPos(1, 29);
-         else if ((active0 & 0x80000000L) != 0L)
-            return jjStopAtPos(1, 31);
-         else if ((active0 & 0x200000000L) != 0L)
-            return jjStopAtPos(1, 33);
-         break;
-      case 97:
-         return jjMoveStringLiteralDfa2_1(active0, 0x2000L);
-      case 101:
          if ((active0 & 0x10000000L) != 0L)
-            return jjStartNfaWithStates_1(1, 28, 30);
+            return jjStopAtPos(1, 28);
          else if ((active0 & 0x40000000L) != 0L)
-            return jjStartNfaWithStates_1(1, 30, 30);
+            return jjStopAtPos(1, 30);
+         else if ((active0 & 0x100000000L) != 0L)
+            return jjStopAtPos(1, 32);
          else if ((active0 & 0x400000000L) != 0L)
-            return jjStartNfaWithStates_1(1, 34, 30);
+            return jjStopAtPos(1, 34);
+         break;
+      case 97:
+         return jjMoveStringLiteralDfa2_1(active0, 0x8000L);
+      case 101:
+         if ((active0 & 0x20000000L) != 0L)
+            return jjStartNfaWithStates_1(1, 29, 30);
+         else if ((active0 & 0x80000000L) != 0L)
+            return jjStartNfaWithStates_1(1, 31, 30);
+         else if ((active0 & 0x800000000L) != 0L)
+            return jjStartNfaWithStates_1(1, 35, 30);
          break;
       case 105:
-         return jjMoveStringLiteralDfa2_1(active0, 0x1000000000000L);
+         return jjMoveStringLiteralDfa2_1(active0, 0x2000000000000L);
       case 109:
-         return jjMoveStringLiteralDfa2_1(active0, 0x20000000000L);
+         return jjMoveStringLiteralDfa2_1(active0, 0x40000000000L);
       case 110:
-         return jjMoveStringLiteralDfa2_1(active0, 0x44000000000L);
+         return jjMoveStringLiteralDfa2_1(active0, 0x88000000000L);
       case 111:
-         return jjMoveStringLiteralDfa2_1(active0, 0x4001000000000L);
+         return jjMoveStringLiteralDfa2_1(active0, 0x8002000000000L);
       case 113:
-         if ((active0 & 0x100000000L) != 0L)
-            return jjStartNfaWithStates_1(1, 32, 30);
+         if ((active0 & 0x200000000L) != 0L)
+            return jjStartNfaWithStates_1(1, 33, 30);
          break;
       case 114:
-         if ((active0 & 0x10000000000L) != 0L)
-            return jjStartNfaWithStates_1(1, 40, 30);
-         return jjMoveStringLiteralDfa2_1(active0, 0x1000L);
+         if ((active0 & 0x20000000000L) != 0L)
+            return jjStartNfaWithStates_1(1, 41, 30);
+         return jjMoveStringLiteralDfa2_1(active0, 0x4000L);
       case 116:
-         if ((active0 & 0x1000000L) != 0L)
-            return jjStartNfaWithStates_1(1, 24, 30);
-         else if ((active0 & 0x4000000L) != 0L)
-            return jjStartNfaWithStates_1(1, 26, 30);
+         if ((active0 & 0x2000000L) != 0L)
+            return jjStartNfaWithStates_1(1, 25, 30);
+         else if ((active0 & 0x8000000L) != 0L)
+            return jjStartNfaWithStates_1(1, 27, 30);
          break;
       case 117:
-         return jjMoveStringLiteralDfa2_1(active0, 0x4000L);
+         return jjMoveStringLiteralDfa2_1(active0, 0x10000L);
       case 124:
-         if ((active0 & 0x8000000000L) != 0L)
-            return jjStopAtPos(1, 39);
+         if ((active0 & 0x10000000000L) != 0L)
+            return jjStopAtPos(1, 40);
          break;
       default :
          break;
@@ -498,26 +1285,26 @@ private int jjMoveStringLiteralDfa2_1(long old0, long active0)
    switch(curChar)
    {
       case 100:
-         if ((active0 & 0x4000000000L) != 0L)
-            return jjStartNfaWithStates_1(2, 38, 30);
-         else if ((active0 & 0x4000000000000L) != 0L)
-            return jjStartNfaWithStates_1(2, 50, 30);
+         if ((active0 & 0x8000000000L) != 0L)
+            return jjStartNfaWithStates_1(2, 39, 30);
+         else if ((active0 & 0x8000000000000L) != 0L)
+            return jjStartNfaWithStates_1(2, 51, 30);
          break;
       case 108:
-         return jjMoveStringLiteralDfa3_1(active0, 0x6000L);
+         return jjMoveStringLiteralDfa3_1(active0, 0x18000L);
       case 112:
-         return jjMoveStringLiteralDfa3_1(active0, 0x20000000000L);
-      case 115:
          return jjMoveStringLiteralDfa3_1(active0, 0x40000000000L);
+      case 115:
+         return jjMoveStringLiteralDfa3_1(active0, 0x80000000000L);
       case 116:
-         if ((active0 & 0x1000000000L) != 0L)
-            return jjStartNfaWithStates_1(2, 36, 30);
+         if ((active0 & 0x2000000000L) != 0L)
+            return jjStartNfaWithStates_1(2, 37, 30);
          break;
       case 117:
-         return jjMoveStringLiteralDfa3_1(active0, 0x1000L);
+         return jjMoveStringLiteralDfa3_1(active0, 0x4000L);
       case 118:
-         if ((active0 & 0x1000000000000L) != 0L)
-            return jjStartNfaWithStates_1(2, 48, 30);
+         if ((active0 & 0x2000000000000L) != 0L)
+            return jjStartNfaWithStates_1(2, 49, 30);
          break;
       default :
          break;
@@ -536,17 +1323,17 @@ private int jjMoveStringLiteralDfa3_1(long old0, long active0)
    switch(curChar)
    {
       case 101:
-         if ((active0 & 0x1000L) != 0L)
-            return jjStartNfaWithStates_1(3, 12, 30);
-         break;
-      case 108:
          if ((active0 & 0x4000L) != 0L)
             return jjStartNfaWithStates_1(3, 14, 30);
          break;
+      case 108:
+         if ((active0 & 0x10000L) != 0L)
+            return jjStartNfaWithStates_1(3, 16, 30);
+         break;
       case 115:
-         return jjMoveStringLiteralDfa4_1(active0, 0x2000L);
+         return jjMoveStringLiteralDfa4_1(active0, 0x8000L);
       case 116:
-         return jjMoveStringLiteralDfa4_1(active0, 0x60000000000L);
+         return jjMoveStringLiteralDfa4_1(active0, 0xc0000000000L);
       default :
          break;
    }
@@ -564,14 +1351,14 @@ private int jjMoveStringLiteralDfa4_1(long old0, long active0)
    switch(curChar)
    {
       case 97:
-         return jjMoveStringLiteralDfa5_1(active0, 0x40000000000L);
+         return jjMoveStringLiteralDfa5_1(active0, 0x80000000000L);
       case 101:
-         if ((active0 & 0x2000L) != 0L)
-            return jjStartNfaWithStates_1(4, 13, 30);
+         if ((active0 & 0x8000L) != 0L)
+            return jjStartNfaWithStates_1(4, 15, 30);
          break;
       case 121:
-         if ((active0 & 0x20000000000L) != 0L)
-            return jjStartNfaWithStates_1(4, 41, 30);
+         if ((active0 & 0x40000000000L) != 0L)
+            return jjStartNfaWithStates_1(4, 42, 30);
          break;
       default :
          break;
@@ -590,7 +1377,7 @@ private int jjMoveStringLiteralDfa5_1(long old0, long active0)
    switch(curChar)
    {
       case 110:
-         return jjMoveStringLiteralDfa6_1(active0, 0x40000000000L);
+         return jjMoveStringLiteralDfa6_1(active0, 0x80000000000L);
       default :
          break;
    }
@@ -608,7 +1395,7 @@ private int jjMoveStringLiteralDfa6_1(long old0, long active0)
    switch(curChar)
    {
       case 99:
-         return jjMoveStringLiteralDfa7_1(active0, 0x40000000000L);
+         return jjMoveStringLiteralDfa7_1(active0, 0x80000000000L);
       default :
          break;
    }
@@ -626,7 +1413,7 @@ private int jjMoveStringLiteralDfa7_1(long old0, long active0)
    switch(curChar)
    {
       case 101:
-         return jjMoveStringLiteralDfa8_1(active0, 0x40000000000L);
+         return jjMoveStringLiteralDfa8_1(active0, 0x80000000000L);
       default :
          break;
    }
@@ -644,7 +1431,7 @@ private int jjMoveStringLiteralDfa8_1(long old0, long active0)
    switch(curChar)
    {
       case 111:
-         return jjMoveStringLiteralDfa9_1(active0, 0x40000000000L);
+         return jjMoveStringLiteralDfa9_1(active0, 0x80000000000L);
       default :
          break;
    }
@@ -662,8 +1449,8 @@ private int jjMoveStringLiteralDfa9_1(long old0, long active0)
    switch(curChar)
    {
       case 102:
-         if ((active0 & 0x40000000000L) != 0L)
-            return jjStartNfaWithStates_1(9, 42, 30);
+         if ((active0 & 0x80000000000L) != 0L)
+            return jjStartNfaWithStates_1(9, 43, 30);
          break;
       default :
          break;
@@ -678,24 +1465,6 @@ private int jjStartNfaWithStates_1(int pos, int kind, int state)
    catch(java.io.IOException e) { return pos + 1; }
    return jjMoveNfa_1(state, pos + 1);
 }
-static final long[] jjbitVec3 = {
-   0x1ff00000fffffffeL, 0xffffffffffffc000L, 0xffffffffL, 0x600000000000000L
-};
-static final long[] jjbitVec4 = {
-   0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL
-};
-static final long[] jjbitVec5 = {
-   0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
-};
-static final long[] jjbitVec6 = {
-   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffL, 0x0L
-};
-static final long[] jjbitVec7 = {
-   0xffffffffffffffffL, 0xffffffffffffffffL, 0x0L, 0x0L
-};
-static final long[] jjbitVec8 = {
-   0x3fffffffffffL, 0x0L, 0x0L, 0x0L
-};
 private int jjMoveNfa_1(int startState, int curPos)
 {
    int startsAt = 0;
@@ -717,14 +1486,14 @@ private int jjMoveNfa_1(int startState, int curPos)
                case 0:
                   if ((0x3ff000000000000L & l) != 0L)
                   {
-                     if (kind > 8)
-                        kind = 8;
+                     if (kind > 10)
+                        kind = 10;
                      jjCheckNAddStates(18, 22);
                   }
                   else if ((0x1800000000L & l) != 0L)
                   {
-                     if (kind > 51)
-                        kind = 51;
+                     if (kind > 52)
+                        kind = 52;
                      jjCheckNAddTwoStates(28, 29);
                   }
                   else if (curChar == 39)
@@ -737,22 +1506,22 @@ private int jjMoveNfa_1(int startState, int curPos)
                case 30:
                   if ((0x3ff001000000000L & l) != 0L)
                   {
-                     if (kind > 52)
-                        kind = 52;
+                     if (kind > 53)
+                        kind = 53;
                      jjCheckNAdd(29);
                   }
                   if ((0x3ff001000000000L & l) != 0L)
                   {
-                     if (kind > 51)
-                        kind = 51;
+                     if (kind > 52)
+                        kind = 52;
                      jjCheckNAdd(28);
                   }
                   break;
                case 1:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 9)
-                     kind = 9;
+                  if (kind > 11)
+                     kind = 11;
                   jjCheckNAddTwoStates(1, 2);
                   break;
                case 3:
@@ -762,8 +1531,8 @@ private int jjMoveNfa_1(int startState, int curPos)
                case 4:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 9)
-                     kind = 9;
+                  if (kind > 11)
+                     kind = 11;
                   jjCheckNAdd(4);
                   break;
                case 5:
@@ -779,8 +1548,8 @@ private int jjMoveNfa_1(int startState, int curPos)
                      jjCheckNAddStates(26, 28);
                   break;
                case 9:
-                  if (curChar == 34 && kind > 11)
-                     kind = 11;
+                  if (curChar == 34 && kind > 13)
+                     kind = 13;
                   break;
                case 10:
                   if (curChar == 39)
@@ -795,21 +1564,21 @@ private int jjMoveNfa_1(int startState, int curPos)
                      jjCheckNAddStates(23, 25);
                   break;
                case 14:
-                  if (curChar == 39 && kind > 11)
-                     kind = 11;
+                  if (curChar == 39 && kind > 13)
+                     kind = 13;
                   break;
                case 15:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 8)
-                     kind = 8;
+                  if (kind > 10)
+                     kind = 10;
                   jjCheckNAddStates(18, 22);
                   break;
                case 16:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 8)
-                     kind = 8;
+                  if (kind > 10)
+                     kind = 10;
                   jjCheckNAdd(16);
                   break;
                case 17:
@@ -819,15 +1588,15 @@ private int jjMoveNfa_1(int startState, int curPos)
                case 18:
                   if (curChar != 46)
                      break;
-                  if (kind > 9)
-                     kind = 9;
+                  if (kind > 11)
+                     kind = 11;
                   jjCheckNAddTwoStates(19, 20);
                   break;
                case 19:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 9)
-                     kind = 9;
+                  if (kind > 11)
+                     kind = 11;
                   jjCheckNAddTwoStates(19, 20);
                   break;
                case 21:
@@ -837,8 +1606,8 @@ private int jjMoveNfa_1(int startState, int curPos)
                case 22:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 9)
-                     kind = 9;
+                  if (kind > 11)
+                     kind = 11;
                   jjCheckNAdd(22);
                   break;
                case 23:
@@ -852,29 +1621,29 @@ private int jjMoveNfa_1(int startState, int curPos)
                case 26:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 9)
-                     kind = 9;
+                  if (kind > 11)
+                     kind = 11;
                   jjCheckNAdd(26);
                   break;
                case 27:
                   if ((0x1800000000L & l) == 0L)
                      break;
-                  if (kind > 51)
-                     kind = 51;
+                  if (kind > 52)
+                     kind = 52;
                   jjCheckNAddTwoStates(28, 29);
                   break;
                case 28:
                   if ((0x3ff001000000000L & l) == 0L)
                      break;
-                  if (kind > 51)
-                     kind = 51;
+                  if (kind > 52)
+                     kind = 52;
                   jjCheckNAdd(28);
                   break;
                case 29:
                   if ((0x3ff001000000000L & l) == 0L)
                      break;
-                  if (kind > 52)
-                     kind = 52;
+                  if (kind > 53)
+                     kind = 53;
                   jjCheckNAdd(29);
                   break;
                default : break;
@@ -891,21 +1660,21 @@ private int jjMoveNfa_1(int startState, int curPos)
                case 0:
                   if ((0x7fffffe87fffffeL & l) == 0L)
                      break;
-                  if (kind > 51)
-                     kind = 51;
+                  if (kind > 52)
+                     kind = 52;
                   jjCheckNAddTwoStates(28, 29);
                   break;
                case 30:
                   if ((0x7fffffe87fffffeL & l) != 0L)
                   {
-                     if (kind > 52)
-                        kind = 52;
+                     if (kind > 53)
+                        kind = 53;
                      jjCheckNAdd(29);
                   }
                   if ((0x7fffffe87fffffeL & l) != 0L)
                   {
-                     if (kind > 51)
-                        kind = 51;
+                     if (kind > 52)
+                        kind = 52;
                      jjCheckNAdd(28);
                   }
                   break;
@@ -948,15 +1717,15 @@ private int jjMoveNfa_1(int startState, int curPos)
                case 28:
                   if ((0x7fffffe87fffffeL & l) == 0L)
                      break;
-                  if (kind > 51)
-                     kind = 51;
+                  if (kind > 52)
+                     kind = 52;
                   jjCheckNAdd(28);
                   break;
                case 29:
                   if ((0x7fffffe87fffffeL & l) == 0L)
                      break;
-                  if (kind > 52)
-                     kind = 52;
+                  if (kind > 53)
+                     kind = 53;
                   jjCheckNAdd(29);
                   break;
                default : break;
@@ -977,21 +1746,21 @@ private int jjMoveNfa_1(int startState, int curPos)
                case 0:
                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 51)
-                     kind = 51;
+                  if (kind > 52)
+                     kind = 52;
                   jjCheckNAddTwoStates(28, 29);
                   break;
                case 30:
                   if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                   {
-                     if (kind > 51)
-                        kind = 51;
+                     if (kind > 52)
+                        kind = 52;
                      jjCheckNAdd(28);
                   }
                   if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                   {
-                     if (kind > 52)
-                        kind = 52;
+                     if (kind > 53)
+                        kind = 53;
                      jjCheckNAdd(29);
                   }
                   break;
@@ -1006,15 +1775,15 @@ private int jjMoveNfa_1(int startState, int curPos)
                case 28:
                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 51)
-                     kind = 51;
+                  if (kind > 52)
+                     kind = 52;
                   jjCheckNAdd(28);
                   break;
                case 29:
                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 52)
-                     kind = 52;
+                  if (kind > 53)
+                     kind = 53;
                   jjCheckNAdd(29);
                   break;
                default : break;
@@ -1074,28 +1843,29 @@ private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, lo
 
 /** Token literal values. */
 public static final String[] jjstrLiteralImages = {
-"", null, "\44\173", "\43\173", null, null, null, null, null, null, null, null,
-"\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\175", "\56", "\50", "\51",
-"\133", "\135", "\72", "\54", "\76", "\147\164", "\74", "\154\164", "\76\75",
-"\147\145", "\74\75", "\154\145", "\75\75", "\145\161", "\41\75", "\156\145", "\41",
-"\156\157\164", "\46\46", "\141\156\144", "\174\174", "\157\162", "\145\155\160\164\171",
-"\151\156\163\164\141\156\143\145\157\146", "\52", "\53", "\55", "\77", "\57", "\144\151\166", "\45", "\155\157\144", null,
-null, null, null, null, null, };
+"", null, "\44\173", "\43\173", null, null, null, null, "\173", "\175", null,
+null, null, null, "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154",
+"\56", "\50", "\51", "\133", "\135", "\72", "\54", "\76", "\147\164", "\74",
+"\154\164", "\76\75", "\147\145", "\74\75", "\154\145", "\75\75", "\145\161", "\41\75",
+"\156\145", "\41", "\156\157\164", "\46\46", "\141\156\144", "\174\174", "\157\162",
+"\145\155\160\164\171", "\151\156\163\164\141\156\143\145\157\146", "\52", "\53", "\55", "\77", "\57",
+"\144\151\166", "\45", "\155\157\144", null, null, null, null, null, null, };
 
 /** Lexer state names. */
 public static final String[] lexStateNames = {
    "DEFAULT",
    "IN_EXPRESSION",
+   "IN_SET_OR_MAP",
 };
 
 /** Lex State array. */
 public static final int[] jjnewLexState = {
-   -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+   -1, -1, 1, 1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-   -1, -1, -1, -1, -1, -1, -1,
+   -1, -1, -1, -1, -1, -1, -1, -1,
 };
 static final long[] jjtoToken = {
-   0x11ffffffffffb0fL,
+   0x23fffffffffef0fL,
 };
 static final long[] jjtoSkip = {
    0xf0L,
@@ -1103,6 +1873,10 @@ static final long[] jjtoSkip = {
 protected SimpleCharStream input_stream;
 private final int[] jjrounds = new int[30];
 private final int[] jjstateSet = new int[60];
+private final StringBuilder jjimage = new StringBuilder();
+private StringBuilder image = jjimage;
+private int jjimageLen;
+private int lengthOfMatch;
 protected char curChar;
 /** Constructor. */
 public ELParserTokenManager(SimpleCharStream stream){
@@ -1143,7 +1917,7 @@ public void ReInit(SimpleCharStream stream, int lexState)
 /** Switch to specified lex state. */
 public void SwitchTo(int lexState)
 {
-   if (lexState >= 2 || lexState < 0)
+   if (lexState >= 3 || lexState < 0)
       throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
    else
       curLexState = lexState;
@@ -1199,6 +1973,9 @@ public Token getNextToken()
       matchedToken = jjFillToken();
       return matchedToken;
    }
+   image = jjimage;
+   image.setLength(0);
+   jjimageLen = 0;
 
    switch(curLexState)
    {
@@ -1216,9 +1993,18 @@ public Token getNextToken()
        jjmatchedKind = 0x7fffffff;
        jjmatchedPos = 0;
        curPos = jjMoveStringLiteralDfa0_1();
-       if (jjmatchedPos == 0 && jjmatchedKind > 56)
+       if (jjmatchedPos == 0 && jjmatchedKind > 57)
+       {
+          jjmatchedKind = 57;
+       }
+       break;
+     case 2:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_2();
+       if (jjmatchedPos == 0 && jjmatchedKind > 57)
        {
-          jjmatchedKind = 56;
+          jjmatchedKind = 57;
        }
        break;
    }
@@ -1229,6 +2015,7 @@ public Token getNextToken()
         if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
         {
            matchedToken = jjFillToken();
+           TokenLexicalActions(matchedToken);
        if (jjnewLexState[jjmatchedKind] != -1)
          curLexState = jjnewLexState[jjmatchedKind];
            return matchedToken;
@@ -1263,6 +2050,34 @@ public Token getNextToken()
   }
 }
 
+void TokenLexicalActions(Token matchedToken)
+{
+   switch(jjmatchedKind)
+   {
+      case 2 :
+        image.append(jjstrLiteralImages[2]);
+        lengthOfMatch = jjstrLiteralImages[2].length();
+                                      deque.push(DEFAULT);
+         break;
+      case 3 :
+        image.append(jjstrLiteralImages[3]);
+        lengthOfMatch = jjstrLiteralImages[3].length();
+                                       deque.push(DEFAULT);
+         break;
+      case 8 :
+        image.append(jjstrLiteralImages[8]);
+        lengthOfMatch = jjstrLiteralImages[8].length();
+                                 deque.push(curLexState);
+         break;
+      case 9 :
+        image.append(jjstrLiteralImages[9]);
+        lengthOfMatch = jjstrLiteralImages[9].length();
+                     SwitchTo(deque.pop());
+         break;
+      default :
+         break;
+   }
+}
 private void jjCheckNAdd(int state)
 {
    if (jjrounds[state] != jjround)

==================================================
SimpleCharStream.java
index ac33b5dae9..d932fb5859 100644
--- a/java/org/apache/el/parser/ELParserTreeConstants.java
+++ b/java/org/apache/el/parser/ELParserTreeConstants.java
@@ -29,14 +29,18 @@ public interface ELParserTreeConstants
   public int JJTDOTSUFFIX = 23;
   public int JJTBRACKETSUFFIX = 24;
   public int JJTMETHODPARAMETERS = 25;
-  public int JJTIDENTIFIER = 26;
-  public int JJTFUNCTION = 27;
-  public int JJTTRUE = 28;
-  public int JJTFALSE = 29;
-  public int JJTFLOATINGPOINT = 30;
-  public int JJTINTEGER = 31;
-  public int JJTSTRING = 32;
-  public int JJTNULL = 33;
+  public int JJTSETDATA = 26;
+  public int JJTLISTDATA = 27;
+  public int JJTMAPDATA = 28;
+  public int JJTMAPENTRY = 29;
+  public int JJTIDENTIFIER = 30;
+  public int JJTFUNCTION = 31;
+  public int JJTTRUE = 32;
+  public int JJTFALSE = 33;
+  public int JJTFLOATINGPOINT = 34;
+  public int JJTINTEGER = 35;
+  public int JJTSTRING = 36;
+  public int JJTNULL = 37;
 
 
   public String[] jjtNodeName = {
@@ -66,6 +70,10 @@ public interface ELParserTreeConstants
     "DotSuffix",
     "BracketSuffix",
     "MethodParameters",
+    "SetData",
+    "ListData",
+    "MapData",
+    "MapEntry",
     "Identifier",
     "Function",
     "True",
@@ -76,4 +84,4 @@ public interface ELParserTreeConstants
     "Null",
   };
 }
-/* JavaCC - OriginalChecksum=437008e736f149e8fa6712fb36d831a1 (do not edit this line) */
+/* JavaCC - OriginalChecksum=c22b9fc4e2a56a586ebf50a9db81e05b (do not edit this line) */

==================================================
Token.java
index 0e7f31e9bb..0984071c21 100644
--- a/java/org/apache/el/parser/SimpleCharStream.java
+++ b/java/org/apache/el/parser/SimpleCharStream.java
@@ -6,6 +6,7 @@ package org.apache.el.parser;
  * An implementation of interface CharStream, where the stream is assumed to
  * contain only ASCII characters (without unicode processing).
  */
+
 @SuppressWarnings("all") // Ignore warnings in generated code
 public class SimpleCharStream
 {

==================================================
