71e5ed5848a2d07510c1f923ea0244e1b23c0ff9
==================================================
Reduce visibility as recommended by UCdetector
==================================================
Mark Thomas
==================================================
Mon Oct 10 14:24:54 2016 +0000
==================================================
ConnectionSettingsBase.java
Reduce visibility as recommended by UCdetector
Remove unused code

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1764106 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ConnectionSettingsLocal.java
index bab42405dc..845d60ce92 100644
--- a/java/org/apache/coyote/http2/ConnectionSettingsBase.java
+++ b/java/org/apache/coyote/http2/ConnectionSettingsBase.java
@@ -23,7 +23,7 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.res.StringManager;
 
-public abstract class ConnectionSettingsBase<T extends Throwable> {
+abstract class ConnectionSettingsBase<T extends Throwable> {
 
     private final Log log = LogFactory.getLog(ConnectionSettingsBase.class);
     private final StringManager sm = StringManager.getManager(ConnectionSettingsBase.class);
@@ -31,25 +31,25 @@ public abstract class ConnectionSettingsBase<T extends Throwable> {
     private final String connectionId;
 
     // Limits
-    protected static final int MAX_WINDOW_SIZE = (1 << 31) - 1;
-    protected static final int MIN_MAX_FRAME_SIZE = 1 << 14;
-    protected static final int MAX_MAX_FRAME_SIZE = (1 << 24) - 1;
-    protected static final long UNLIMITED = ((long)1 << 32); // Use the maximum possible
-    protected static final int MAX_HEADER_TABLE_SIZE = 1 << 16;
+    static final int MAX_WINDOW_SIZE = (1 << 31) - 1;
+    static final int MIN_MAX_FRAME_SIZE = 1 << 14;
+    static final int MAX_MAX_FRAME_SIZE = (1 << 24) - 1;
+    static final long UNLIMITED = ((long)1 << 32); // Use the maximum possible
+    static final int MAX_HEADER_TABLE_SIZE = 1 << 16;
 
     // Defaults
-    protected static final int DEFAULT_HEADER_TABLE_SIZE = 4096;
-    protected static final boolean DEFAULT_ENABLE_PUSH = true;
-    protected static final long DEFAULT_MAX_CONCURRENT_STREAMS = UNLIMITED;
-    protected static final int DEFAULT_INITIAL_WINDOW_SIZE = (1 << 16) - 1;
-    protected static final int DEFAULT_MAX_FRAME_SIZE = MIN_MAX_FRAME_SIZE;
-    protected static final long DEFAULT_MAX_HEADER_LIST_SIZE = UNLIMITED;
+    static final int DEFAULT_HEADER_TABLE_SIZE = 4096;
+    static final boolean DEFAULT_ENABLE_PUSH = true;
+    static final long DEFAULT_MAX_CONCURRENT_STREAMS = UNLIMITED;
+    static final int DEFAULT_INITIAL_WINDOW_SIZE = (1 << 16) - 1;
+    static final int DEFAULT_MAX_FRAME_SIZE = MIN_MAX_FRAME_SIZE;
+    static final long DEFAULT_MAX_HEADER_LIST_SIZE = UNLIMITED;
 
-    protected Map<Setting,Long> current = new HashMap<>();
-    protected Map<Setting,Long> pending = new HashMap<>();
+    Map<Setting,Long> current = new HashMap<>();
+    Map<Setting,Long> pending = new HashMap<>();
 
 
-    public ConnectionSettingsBase(String connectionId) {
+    ConnectionSettingsBase(String connectionId) {
         this.connectionId = connectionId;
         // Set up the defaults
         current.put(Setting.HEADER_TABLE_SIZE,      Long.valueOf(DEFAULT_HEADER_TABLE_SIZE));
@@ -61,7 +61,7 @@ public abstract class ConnectionSettingsBase<T extends Throwable> {
     }
 
 
-    public void set(Setting setting, long value) throws T {
+    final void set(Setting setting, long value) throws T {
         if (log.isDebugEnabled()) {
             log.debug(sm.getString("connectionSettings.debug",
                     connectionId, setting, Long.toString(value)));
@@ -102,33 +102,33 @@ public abstract class ConnectionSettingsBase<T extends Throwable> {
     }
 
 
-    public int getHeaderTableSize() {
+    final int getHeaderTableSize() {
         return getMinInt(Setting.HEADER_TABLE_SIZE);
     }
 
 
-    public boolean getEnablePush() {
+    final boolean getEnablePush() {
         long result = getMin(Setting.ENABLE_PUSH);
         return result != 0;
     }
 
 
-    public long getMaxConcurrentStreams() {
+    final long getMaxConcurrentStreams() {
         return getMax(Setting.MAX_CONCURRENT_STREAMS);
     }
 
 
-    public int getInitialWindowSize() {
+    final int getInitialWindowSize() {
         return getMaxInt(Setting.INITIAL_WINDOW_SIZE);
     }
 
 
-    public int getMaxFrameSize() {
+    final int getMaxFrameSize() {
         return getMaxInt(Setting.MAX_FRAME_SIZE);
     }
 
 
-    public long getMaxHeaderListSize() {
+    final long getMaxHeaderListSize() {
         return getMax(Setting.MAX_HEADER_LIST_SIZE);
     }
 

==================================================
ConnectionSettingsRemote.java
index 54e2aa1ded..af7ff8cd63 100644
--- a/java/org/apache/coyote/http2/ConnectionSettingsLocal.java
+++ b/java/org/apache/coyote/http2/ConnectionSettingsLocal.java
@@ -30,18 +30,18 @@ import java.util.Map;
  * client will respond (almost certainly by closing the connection) as defined
  * in the HTTP/2 specification.
  */
-public class ConnectionSettingsLocal extends ConnectionSettingsBase<IllegalArgumentException> {
+class ConnectionSettingsLocal extends ConnectionSettingsBase<IllegalArgumentException> {
 
     private boolean sendInProgress = false;
 
 
-    public ConnectionSettingsLocal(String connectionId) {
+    ConnectionSettingsLocal(String connectionId) {
         super(connectionId);
     }
 
 
     @Override
-    protected synchronized void set(Setting setting, Long value) {
+    final synchronized void set(Setting setting, Long value) {
         checkSend();
         if (current.get(setting).longValue() == value.longValue()) {
             pending.remove(setting);
@@ -51,7 +51,7 @@ public class ConnectionSettingsLocal extends ConnectionSettingsBase<IllegalArgum
     }
 
 
-    synchronized byte[] getSettingsFrameForPending() {
+    final synchronized byte[] getSettingsFrameForPending() {
         checkSend();
         int payloadSize = pending.size() * 6;
         byte[] result = new byte[9 + payloadSize];
@@ -73,7 +73,7 @@ public class ConnectionSettingsLocal extends ConnectionSettingsBase<IllegalArgum
     }
 
 
-    synchronized boolean ack() {
+    final synchronized boolean ack() {
         if (sendInProgress) {
             sendInProgress = false;
             current.putAll(pending);
@@ -94,7 +94,7 @@ public class ConnectionSettingsLocal extends ConnectionSettingsBase<IllegalArgum
 
 
     @Override
-    void throwException(String msg, Http2Error error) throws IllegalArgumentException {
+    final void throwException(String msg, Http2Error error) throws IllegalArgumentException {
         throw new IllegalArgumentException(msg);
     }
 }

==================================================
Flags.java
index 914d7fe5b7..e50a5d2cb2 100644
--- a/java/org/apache/coyote/http2/ConnectionSettingsRemote.java
+++ b/java/org/apache/coyote/http2/ConnectionSettingsRemote.java
@@ -20,15 +20,15 @@ package org.apache.coyote.http2;
  * Represents the remote connection settings: i.e. the settings the server must
  * use when communicating with the client.
  */
-public class ConnectionSettingsRemote extends ConnectionSettingsBase<ConnectionException> {
+class ConnectionSettingsRemote extends ConnectionSettingsBase<ConnectionException> {
 
-    public ConnectionSettingsRemote(String connectionId) {
+    ConnectionSettingsRemote(String connectionId) {
         super(connectionId);
     }
 
 
     @Override
-    void throwException(String msg, Http2Error error) throws ConnectionException {
+    final void throwException(String msg, Http2Error error) throws ConnectionException {
         throw new ConnectionException(msg, error);
     }
 }

==================================================
FrameType.java
index d52095127f..6c63f93dd0 100644
--- a/java/org/apache/coyote/http2/Flags.java
+++ b/java/org/apache/coyote/http2/Flags.java
@@ -16,34 +16,34 @@
  */
 package org.apache.coyote.http2;
 
-public class Flags {
+class Flags {
 
     private Flags() {
         // Utility class. Hide default constructor
     }
 
 
-    public static boolean isEndOfStream(int flags) {
+    static boolean isEndOfStream(int flags) {
         return (flags & 0x01) > 0;
     }
 
 
-    public static boolean isAck(int flags) {
+    static boolean isAck(int flags) {
         return (flags & 0x01) > 0;
     }
 
 
-    public static boolean isEndOfHeaders(int flags) {
+    static boolean isEndOfHeaders(int flags) {
         return (flags & 0x04) > 0;
     }
 
 
-    public static boolean hasPadding(int flags) {
+    static boolean hasPadding(int flags) {
         return (flags & 0x08) > 0;
     }
 
 
-    public static boolean hasPriority(int flags) {
+    static boolean hasPriority(int flags) {
         return (flags & 0x20) > 0;
     }
 }

==================================================
HeaderSink.java
index dbe8686762..0f17f6ff3a 100644
--- a/java/org/apache/coyote/http2/FrameType.java
+++ b/java/org/apache/coyote/http2/FrameType.java
@@ -20,7 +20,7 @@ import java.util.function.IntPredicate;
 
 import org.apache.tomcat.util.res.StringManager;
 
-public enum FrameType {
+enum FrameType {
 
     DATA          (0,   false,  true, null,              false),
     HEADERS       (1,   false,  true, null,               true),
@@ -53,12 +53,12 @@ public enum FrameType {
     }
 
 
-    public byte getIdByte() {
+    byte getIdByte() {
         return (byte) id;
     }
 
 
-    public void check(int streamId, int payloadSize) throws Http2Exception {
+    void check(int streamId, int payloadSize) throws Http2Exception {
         // Is FrameType valid for the given stream?
         if (streamId == 0 && !streamZero || streamId != 0 && !streamNonZero) {
             throw new ConnectionException(sm.getString("frameType.checkStream", this),
@@ -80,7 +80,7 @@ public enum FrameType {
     }
 
 
-    public static FrameType valueOf(int i) {
+    static FrameType valueOf(int i) {
         switch(i) {
         case 0:
             return DATA;

==================================================
Hpack.java
index 679fd6775e..7a9693273a 100644
--- a/java/org/apache/coyote/http2/HeaderSink.java
+++ b/java/org/apache/coyote/http2/HeaderSink.java
@@ -23,7 +23,7 @@ import org.apache.coyote.http2.HpackDecoder.HeaderEmitter;
  * the connection close process has started if headers for new streams are
  * received.
  */
-public class HeaderSink implements HeaderEmitter {
+class HeaderSink implements HeaderEmitter {
 
     @Override
     public void emitHeader(String name, String value, boolean neverIndex) {

==================================================
HpackDecoder.java
index a7dd378153..e60c9d52ac 100644
--- a/java/org/apache/coyote/http2/Hpack.java
+++ b/java/org/apache/coyote/http2/Hpack.java
@@ -22,7 +22,7 @@ import org.apache.tomcat.util.res.StringManager;
 
 final class Hpack {
 
-    static final StringManager sm = StringManager.getManager(Hpack.class);
+    private static final StringManager sm = StringManager.getManager(Hpack.class);
 
     private static final byte LOWER_DIFF = 'a' - 'A';
     static final int DEFAULT_TABLE_SIZE = 4096;

==================================================
HpackEncoder.java
index c9925a6be4..ab5c3677e3 100644
--- a/java/org/apache/coyote/http2/HpackDecoder.java
+++ b/java/org/apache/coyote/http2/HpackDecoder.java
@@ -63,12 +63,12 @@ public class HpackDecoder {
 
     private final StringBuilder stringBuilder = new StringBuilder();
 
-    public HpackDecoder(int maxMemorySize) {
+    HpackDecoder(int maxMemorySize) {
         this.maxMemorySize = maxMemorySize;
         headerTable = new Hpack.HeaderField[DEFAULT_RING_BUFFER_SIZE];
     }
 
-    public HpackDecoder() {
+    HpackDecoder() {
         this(Hpack.DEFAULT_TABLE_SIZE);
     }
 
@@ -81,7 +81,7 @@ public class HpackDecoder {
      *
      * @throws HpackException If the packed data is not valid
      */
-    public void decode(ByteBuffer buffer) throws HpackException {
+    void decode(ByteBuffer buffer) throws HpackException {
         while (buffer.hasRemaining()) {
             int originalPos = buffer.position();
             byte b = buffer.get();
@@ -326,16 +326,16 @@ public class HpackDecoder {
     /**
      * Interface that can be used to immediately validate headers (ex: uppercase detection).
      */
-    public interface HeaderEmitter {
+    interface HeaderEmitter {
         void emitHeader(String name, String value, boolean neverIndex);
     }
 
 
-    public HeaderEmitter getHeaderEmitter() {
+    HeaderEmitter getHeaderEmitter() {
         return headerEmitter;
     }
 
-    public void setHeaderEmitter(HeaderEmitter headerEmitter) {
+    void setHeaderEmitter(HeaderEmitter headerEmitter) {
         this.headerEmitter = headerEmitter;
     }
 

==================================================
Http2Error.java
index 5731faff7c..3169f35499 100644
--- a/java/org/apache/coyote/http2/HpackEncoder.java
+++ b/java/org/apache/coyote/http2/HpackEncoder.java
@@ -34,12 +34,12 @@ import org.apache.tomcat.util.res.StringManager;
 /**
  * Encoder for HPACK frames.
  */
-public class HpackEncoder {
+class HpackEncoder {
 
     private static final Log log = LogFactory.getLog(HpackEncoder.class);
     private static final StringManager sm = StringManager.getManager(HpackEncoder.class);
 
-    public static final HpackHeaderFunction DEFAULT_HEADER_FUNCTION = new HpackHeaderFunction() {
+    private static final HpackHeaderFunction DEFAULT_HEADER_FUNCTION = new HpackHeaderFunction() {
         @Override
         public boolean shouldUseIndexing(String headerName, String value) {
             //content length and date change all the time
@@ -104,13 +104,9 @@ public class HpackEncoder {
 
     private final HpackHeaderFunction hpackHeaderFunction;
 
-    public HpackEncoder(int maxTableSize, HpackHeaderFunction headerFunction) {
+    HpackEncoder(int maxTableSize) {
         this.maxTableSize = maxTableSize;
-        this.hpackHeaderFunction = headerFunction;
-    }
-
-    public HpackEncoder(int maxTableSize) {
-        this(maxTableSize, DEFAULT_HEADER_FUNCTION);
+        this.hpackHeaderFunction = DEFAULT_HEADER_FUNCTION;
     }
 
     /**
@@ -121,7 +117,7 @@ public class HpackEncoder {
      *
      * @return The state of the encoding process
      */
-    public State encode(MimeHeaders headers, ByteBuffer target) {
+    State encode(MimeHeaders headers, ByteBuffer target) {
         int it = headersIterator;
         if (headersIterator == -1) {
             handleTableSizeChange(target);
@@ -250,7 +246,7 @@ public class HpackEncoder {
         }
         existing.add(d);
         evictionQueue.add(d);
-        currentTableSize += d.size;
+        currentTableSize += d.getSize();
         runEvictionIfRequired();
         if (entryPositionCounter == Integer.MAX_VALUE) {
             //prevent rollover
@@ -335,19 +331,19 @@ public class HpackEncoder {
         minNewMaxHeaderSize = -1;
     }
 
-    public enum State {
+    enum State {
         COMPLETE,
         UNDERFLOW,
 
     }
 
-    static class TableEntry {
-        final String name;
-        final String value;
-        final int size;
-        int position;
+    private static class TableEntry {
+        private final String name;
+        private final String value;
+        private final int size;
+        private int position;
 
-        TableEntry(String name, String value, int position) {
+        private TableEntry(String name, String value, int position) {
             this.name = name;
             this.value = value;
             this.position = position;
@@ -358,24 +354,28 @@ public class HpackEncoder {
             }
         }
 
-        public int getPosition() {
+        int getPosition() {
             return position;
         }
+
+        int getSize() {
+            return size;
+        }
     }
 
-    class DynamicTableEntry extends TableEntry {
+    private class DynamicTableEntry extends TableEntry {
 
-        DynamicTableEntry(String name, String value, int position) {
+        private DynamicTableEntry(String name, String value, int position) {
             super(name, value, position);
         }
 
         @Override
-        public int getPosition() {
+        int getPosition() {
             return super.getPosition() + entryPositionCounter + Hpack.STATIC_TABLE_LENGTH;
         }
     }
 
-    public interface HpackHeaderFunction {
+    private interface HpackHeaderFunction {
         boolean shouldUseIndexing(String header, String value);
 
         /**

==================================================
Http2UpgradeHandler.java
index 9db65ac311..b826b57812 100644
--- a/java/org/apache/coyote/http2/Http2Error.java
+++ b/java/org/apache/coyote/http2/Http2Error.java
@@ -16,7 +16,7 @@
  */
 package org.apache.coyote.http2;
 
-public enum Http2Error {
+enum Http2Error {
 
     NO_ERROR            (0x00),
     PROTOCOL_ERROR      (0x01),
@@ -40,12 +40,12 @@ public enum Http2Error {
     }
 
 
-    public long getCode() {
+    long getCode() {
         return code;
     }
 
 
-    public byte[] getCodeBytes() {
+    byte[] getCodeBytes() {
         byte[] codeByte = new byte[4];
         ByteUtil.setFourBytes(codeByte, 0, code);
         return codeByte;

==================================================
Setting.java
index 024f1f39ed..8bce58e1b0 100644
--- a/java/org/apache/coyote/http2/Http2UpgradeHandler.java
+++ b/java/org/apache/coyote/http2/Http2UpgradeHandler.java
@@ -71,7 +71,7 @@ import org.apache.tomcat.util.res.StringManager;
  *     </li>
  * </ul>
  */
-public class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeHandler,
+class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeHandler,
         Input, Output {
 
     private static final Log log = LogFactory.getLog(Http2UpgradeHandler.class);
@@ -144,7 +144,7 @@ public class Http2UpgradeHandler extends AbstractStream implements InternalHttpU
     private AtomicInteger streamConcurrency = null;
     private Queue<StreamProcessor> queuedProcessors = null;
 
-    public Http2UpgradeHandler(Adapter adapter, Request coyoteRequest) {
+    Http2UpgradeHandler(Adapter adapter, Request coyoteRequest) {
         super (STREAM_ID_ZERO);
         this.adapter = adapter;
         this.connectionId = Integer.toString(connectionIdGenerator.getAndIncrement());
@@ -573,7 +573,7 @@ public class Http2UpgradeHandler extends AbstractStream implements InternalHttpU
     }
 
 
-    void writePushHeaders(Stream stream, int pushedStreamId, Request coyoteRequest, int payloadSize)
+    private void writePushHeaders(Stream stream, int pushedStreamId, Request coyoteRequest, int payloadSize)
             throws IOException {
         if (log.isDebugEnabled()) {
             log.debug(sm.getString("upgradeHandler.writePushHeaders", connectionId,

==================================================
StreamProcessor.java
index edfde16725..54b99dacba 100644
--- a/java/org/apache/coyote/http2/Setting.java
+++ b/java/org/apache/coyote/http2/Setting.java
@@ -16,7 +16,7 @@
  */
 package org.apache.coyote.http2;
 
-public enum Setting {
+enum Setting {
     HEADER_TABLE_SIZE(1),
     ENABLE_PUSH(2),
     MAX_CONCURRENT_STREAMS(3),
@@ -31,16 +31,16 @@ public enum Setting {
         this.id = id;
     }
 
-    public int getId() {
+    final int getId() {
         return id;
     }
 
     @Override
-    public String toString() {
+    public final String toString() {
         return Integer.toString(id);
     }
 
-    public static Setting valueOf(int i) {
+    static final Setting valueOf(int i) {
         switch(i) {
         case 1: {
             return HEADER_TABLE_SIZE;

==================================================
StreamStateMachine.java
index 7d5cbe3d8d..086d138db6 100644
--- a/java/org/apache/coyote/http2/StreamProcessor.java
+++ b/java/org/apache/coyote/http2/StreamProcessor.java
@@ -32,7 +32,7 @@ import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
-public class StreamProcessor extends AbstractProcessor implements Runnable {
+class StreamProcessor extends AbstractProcessor implements Runnable {
 
     private static final Log log = LogFactory.getLog(StreamProcessor.class);
     private static final StringManager sm = StringManager.getManager(StreamProcessor.class);
@@ -41,7 +41,7 @@ public class StreamProcessor extends AbstractProcessor implements Runnable {
     private final Stream stream;
 
 
-    public StreamProcessor(Http2UpgradeHandler handler, Stream stream, Adapter adapter, SocketWrapperBase<?> socketWrapper) {
+    StreamProcessor(Http2UpgradeHandler handler, Stream stream, Adapter adapter, SocketWrapperBase<?> socketWrapper) {
         super(stream.getCoyoteRequest(), stream.getCoyoteResponse());
         this.handler = handler;
         this.stream = stream;
@@ -51,7 +51,7 @@ public class StreamProcessor extends AbstractProcessor implements Runnable {
 
 
     @Override
-    public void run() {
+    public final void run() {
         try {
             // FIXME: the regular processor syncs on socketWrapper, but here this deadlocks
             synchronized (this) {
@@ -192,7 +192,7 @@ public class StreamProcessor extends AbstractProcessor implements Runnable {
 
 
     @Override
-    public void recycle() {
+    public final void recycle() {
         // StreamProcessor instances are not re-used.
         // Clear fields that can be cleared to aid GC and trigger NPEs if this
         // is reused
@@ -202,19 +202,19 @@ public class StreamProcessor extends AbstractProcessor implements Runnable {
 
 
     @Override
-    protected Log getLog() {
+    protected final Log getLog() {
         return log;
     }
 
 
     @Override
-    public void pause() {
+    public final void pause() {
         // NO-OP. Handled by the Http2UpgradeHandler
     }
 
 
     @Override
-    public SocketState service(SocketWrapperBase<?> socket) throws IOException {
+    public final SocketState service(SocketWrapperBase<?> socket) throws IOException {
         try {
             adapter.service(request, response);
         } catch (Exception e) {
@@ -239,7 +239,7 @@ public class StreamProcessor extends AbstractProcessor implements Runnable {
 
 
     @Override
-    protected boolean flushBufferedWrite() throws IOException {
+    protected final boolean flushBufferedWrite() throws IOException {
         if (stream.getOutputBuffer().flush(false)) {
             // The buffer wasn't fully flushed so re-register the
             // stream for write. Note this does not go via the
@@ -259,7 +259,7 @@ public class StreamProcessor extends AbstractProcessor implements Runnable {
 
 
     @Override
-    protected SocketState dispatchEndRequest() {
+    protected final SocketState dispatchEndRequest() {
         return SocketState.CLOSED;
     }
 }

==================================================
