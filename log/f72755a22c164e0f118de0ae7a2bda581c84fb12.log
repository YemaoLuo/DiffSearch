f72755a22c164e0f118de0ae7a2bda581c84fb12
==================================================
svn:eol-style = native
==================================================
Konstantin Kolinko
==================================================
Sun Nov 25 10:55:52 2012 +0000
==================================================
AbstractServletInputStream.java
svn:eol-style = native

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1413328 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractServletOutputStream.java
index e68c91e142..8239d368f8 100644
--- a/java/org/apache/coyote/http11/upgrade/AbstractServletInputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/AbstractServletInputStream.java
@@ -1,157 +1,157 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-
-import javax.servlet.ReadListener;
-import javax.servlet.ServletInputStream;
-
-import org.apache.tomcat.util.res.StringManager;
-
-public abstract class AbstractServletInputStream extends ServletInputStream {
-
-    protected static final StringManager sm =
-            StringManager.getManager(Constants.Package);
-
-
-    // Start in blocking-mode
-    private volatile Boolean ready = Boolean.TRUE;
-    private volatile ReadListener listener = null;
-
-
-    @Override
-    public final boolean isFinished() {
-        if (listener == null) {
-            throw new IllegalStateException(
-                    sm.getString("upgrade.sis.isFinished.ise"));
-        }
-        // The only way to finish an HTTP Upgrade connection is to close the
-        // socket.
-        return false;
-    }
-
-
-    @Override
-    public final boolean isReady() {
-        if (listener == null) {
-            throw new IllegalStateException(
-                    sm.getString("upgrade.sis.isReady.ise"));
-        }
-
-        // If we already know the current state, return it.
-        if (ready != null) {
-            return ready.booleanValue();
-        }
-
-        try {
-            ready = Boolean.valueOf(doIsReady());
-        } catch (IOException e) {
-            listener.onError(e);
-        }
-        return ready.booleanValue();
-    }
-
-
-    @Override
-    public final void setReadListener(ReadListener listener) {
-        if (listener == null) {
-            throw new IllegalArgumentException(
-                    sm.getString("upgrade.sis.readListener.null"));
-        }
-        this.listener = listener;
-        // Switching to non-blocking. Don't know if data is available.
-        ready = null;
-    }
-
-
-    @Override
-    public final int read() throws IOException {
-        preReadChecks();
-
-        return readInternal();
-    }
-
-
-    @Override
-    public final int readLine(byte[] b, int off, int len) throws IOException {
-        preReadChecks();
-
-        if (len <= 0) {
-            return 0;
-        }
-        int count = 0, c;
-
-        while ((c = readInternal()) != -1) {
-            b[off++] = (byte) c;
-            count++;
-            if (c == '\n' || count == len) {
-                break;
-            }
-        }
-        return count > 0 ? count : -1;
-    }
-
-
-    @Override
-    public final int read(byte[] b, int off, int len) throws IOException {
-        preReadChecks();
-
-        return doRead(listener == null, b, off, len);
-    }
-
-
-    private void preReadChecks() {
-        if (listener != null && (ready == null || !ready.booleanValue())) {
-            throw new IllegalStateException(
-                    sm.getString("upgrade.sis.read.ise"));
-        }
-        // No longer know if data is available
-        ready = null;
-    }
-
-
-    private int readInternal() throws IOException {
-        // Single byte reads for non-blocking need special handling so all
-        // single byte reads run through this method.
-        ReadListener readListener = this.listener;
-        byte[] b = new byte[1];
-        int result = doRead(readListener == null, b, 0, 1);
-        if (result == 0) {
-            return -1;
-        } else if (result == -1) {
-            // Will never happen with a network socket. An IOException will be
-            // thrown when the client closes the connection.
-            // Echo back the -1 to be safe.
-            return -1;
-        } else {
-            return b[0] & 0xFF;
-        }
-    }
-
-
-    protected final void onDataAvailable() {
-        ready = Boolean.TRUE;
-        listener.onDataAvailable();
-    }
-
-
-    protected abstract boolean doIsReady() throws IOException;
-
-    protected abstract int doRead(boolean block, byte[] b, int off, int len)
-            throws IOException;
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.IOException;
+
+import javax.servlet.ReadListener;
+import javax.servlet.ServletInputStream;
+
+import org.apache.tomcat.util.res.StringManager;
+
+public abstract class AbstractServletInputStream extends ServletInputStream {
+
+    protected static final StringManager sm =
+            StringManager.getManager(Constants.Package);
+
+
+    // Start in blocking-mode
+    private volatile Boolean ready = Boolean.TRUE;
+    private volatile ReadListener listener = null;
+
+
+    @Override
+    public final boolean isFinished() {
+        if (listener == null) {
+            throw new IllegalStateException(
+                    sm.getString("upgrade.sis.isFinished.ise"));
+        }
+        // The only way to finish an HTTP Upgrade connection is to close the
+        // socket.
+        return false;
+    }
+
+
+    @Override
+    public final boolean isReady() {
+        if (listener == null) {
+            throw new IllegalStateException(
+                    sm.getString("upgrade.sis.isReady.ise"));
+        }
+
+        // If we already know the current state, return it.
+        if (ready != null) {
+            return ready.booleanValue();
+        }
+
+        try {
+            ready = Boolean.valueOf(doIsReady());
+        } catch (IOException e) {
+            listener.onError(e);
+        }
+        return ready.booleanValue();
+    }
+
+
+    @Override
+    public final void setReadListener(ReadListener listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException(
+                    sm.getString("upgrade.sis.readListener.null"));
+        }
+        this.listener = listener;
+        // Switching to non-blocking. Don't know if data is available.
+        ready = null;
+    }
+
+
+    @Override
+    public final int read() throws IOException {
+        preReadChecks();
+
+        return readInternal();
+    }
+
+
+    @Override
+    public final int readLine(byte[] b, int off, int len) throws IOException {
+        preReadChecks();
+
+        if (len <= 0) {
+            return 0;
+        }
+        int count = 0, c;
+
+        while ((c = readInternal()) != -1) {
+            b[off++] = (byte) c;
+            count++;
+            if (c == '\n' || count == len) {
+                break;
+            }
+        }
+        return count > 0 ? count : -1;
+    }
+
+
+    @Override
+    public final int read(byte[] b, int off, int len) throws IOException {
+        preReadChecks();
+
+        return doRead(listener == null, b, off, len);
+    }
+
+
+    private void preReadChecks() {
+        if (listener != null && (ready == null || !ready.booleanValue())) {
+            throw new IllegalStateException(
+                    sm.getString("upgrade.sis.read.ise"));
+        }
+        // No longer know if data is available
+        ready = null;
+    }
+
+
+    private int readInternal() throws IOException {
+        // Single byte reads for non-blocking need special handling so all
+        // single byte reads run through this method.
+        ReadListener readListener = this.listener;
+        byte[] b = new byte[1];
+        int result = doRead(readListener == null, b, 0, 1);
+        if (result == 0) {
+            return -1;
+        } else if (result == -1) {
+            // Will never happen with a network socket. An IOException will be
+            // thrown when the client closes the connection.
+            // Echo back the -1 to be safe.
+            return -1;
+        } else {
+            return b[0] & 0xFF;
+        }
+    }
+
+
+    protected final void onDataAvailable() {
+        ready = Boolean.TRUE;
+        listener.onDataAvailable();
+    }
+
+
+    protected abstract boolean doIsReady() throws IOException;
+
+    protected abstract int doRead(boolean block, byte[] b, int off, int len)
+            throws IOException;
+}

==================================================
AprServletInputStream.java
index a02b64bdd9..00016f9d7d 100644
--- a/java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java
@@ -1,113 +1,113 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-
-import javax.servlet.ServletOutputStream;
-import javax.servlet.WriteListener;
-
-import org.apache.tomcat.util.res.StringManager;
-
-public abstract class AbstractServletOutputStream extends ServletOutputStream {
-
-    protected static final StringManager sm =
-            StringManager.getManager(Constants.Package);
-
-
-    // Start in blocking-mode
-    private volatile WriteListener listener = null;
-    private byte[] buffer;
-
-    @Override
-    public final boolean canWrite() {
-        if (listener == null) {
-            throw new IllegalStateException(
-                    sm.getString("upgrade.sos.canWrite.is"));
-        }
-
-        return buffer == null;
-    }
-
-    @Override
-    public final void setWriteListener(WriteListener listener) {
-        if (listener == null) {
-            throw new IllegalArgumentException(
-                    sm.getString("upgrade.sos.writeListener.null"));
-        }
-        this.listener = listener;
-    }
-
-    @Override
-    public void write(int b) throws IOException {
-        preWriteChecks();
-
-        writeInternal(new byte[] { (byte) b }, 0, 1);
-    }
-
-
-    @Override
-    public void write(byte[] b, int off, int len) throws IOException {
-        preWriteChecks();
-
-        writeInternal(b, off, len);
-    }
-
-
-    private void preWriteChecks() {
-        if (buffer != null) {
-            throw new IllegalStateException(
-                    sm.getString("upgrade.sis.write.ise"));
-        }
-    }
-
-
-    private void writeInternal(byte[] b, int off, int len) throws IOException {
-        if (listener == null) {
-            // Simple case - blocking IO
-            doWrite(true, b, off, len);
-        } else {
-            // Non-blocking IO
-            int written = doWrite(false, b, off, len);
-            if (written < len) {
-                // TODO: - Reuse the buffer
-                //       - Only reallocate if it gets too big (>8k?)
-                buffer = new byte[len - written];
-                System.arraycopy(b, off + written, buffer, 0, len - written);
-            } else {
-                buffer = null;
-            }
-        }
-    }
-
-
-    protected final void onWritePossible() {
-        try {
-            writeInternal(buffer, 0, buffer.length);
-        } catch (IOException ioe) {
-            throw new RuntimeException(ioe);
-        }
-        if (buffer == null) {
-            listener.onWritePossible();
-        }
-    }
-
-    protected abstract int doWrite(boolean block, byte[] b, int off, int len)
-            throws IOException;
-
-    protected abstract void doFlush() throws IOException;
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.IOException;
+
+import javax.servlet.ServletOutputStream;
+import javax.servlet.WriteListener;
+
+import org.apache.tomcat.util.res.StringManager;
+
+public abstract class AbstractServletOutputStream extends ServletOutputStream {
+
+    protected static final StringManager sm =
+            StringManager.getManager(Constants.Package);
+
+
+    // Start in blocking-mode
+    private volatile WriteListener listener = null;
+    private byte[] buffer;
+
+    @Override
+    public final boolean canWrite() {
+        if (listener == null) {
+            throw new IllegalStateException(
+                    sm.getString("upgrade.sos.canWrite.is"));
+        }
+
+        return buffer == null;
+    }
+
+    @Override
+    public final void setWriteListener(WriteListener listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException(
+                    sm.getString("upgrade.sos.writeListener.null"));
+        }
+        this.listener = listener;
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+        preWriteChecks();
+
+        writeInternal(new byte[] { (byte) b }, 0, 1);
+    }
+
+
+    @Override
+    public void write(byte[] b, int off, int len) throws IOException {
+        preWriteChecks();
+
+        writeInternal(b, off, len);
+    }
+
+
+    private void preWriteChecks() {
+        if (buffer != null) {
+            throw new IllegalStateException(
+                    sm.getString("upgrade.sis.write.ise"));
+        }
+    }
+
+
+    private void writeInternal(byte[] b, int off, int len) throws IOException {
+        if (listener == null) {
+            // Simple case - blocking IO
+            doWrite(true, b, off, len);
+        } else {
+            // Non-blocking IO
+            int written = doWrite(false, b, off, len);
+            if (written < len) {
+                // TODO: - Reuse the buffer
+                //       - Only reallocate if it gets too big (>8k?)
+                buffer = new byte[len - written];
+                System.arraycopy(b, off + written, buffer, 0, len - written);
+            } else {
+                buffer = null;
+            }
+        }
+    }
+
+
+    protected final void onWritePossible() {
+        try {
+            writeInternal(buffer, 0, buffer.length);
+        } catch (IOException ioe) {
+            throw new RuntimeException(ioe);
+        }
+        if (buffer == null) {
+            listener.onWritePossible();
+        }
+    }
+
+    protected abstract int doWrite(boolean block, byte[] b, int off, int len)
+            throws IOException;
+
+    protected abstract void doFlush() throws IOException;
+}

==================================================
AprServletOutputStream.java
index eb4490d16d..22787001b6 100644
--- a/java/org/apache/coyote/http11/upgrade/AprServletInputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/AprServletInputStream.java
@@ -1,81 +1,81 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-
-import org.apache.tomcat.util.net.SocketWrapper;
-
-public class AprServletInputStream extends AbstractServletInputStream {
-
-    private final long socket;
-
-
-    public AprServletInputStream(SocketWrapper<Long> wrapper) {
-        this.socket = wrapper.getSocket().longValue();
-    }
-/*
-    @Override
-    protected int doRead() throws IOException {
-        byte[] bytes = new byte[1];
-        int result = Socket.recv(socket, bytes, 0, 1);
-        if (result == -1) {
-            return -1;
-        } else {
-            return bytes[0] & 0xFF;
-        }
-    }
-
-    @Override
-    protected int doRead(byte[] b, int off, int len) throws IOException {
-        boolean block = true;
-        if (!block) {
-            Socket.optSet(socket, Socket.APR_SO_NONBLOCK, -1);
-        }
-        try {
-            int result = Socket.recv(socket, b, off, len);
-            if (result > 0) {
-                return result;
-            } else if (-result == Status.EAGAIN) {
-                return 0;
-            } else {
-                throw new IOException(sm.getString("apr.error",
-                        Integer.valueOf(-result)));
-            }
-        } finally {
-            if (!block) {
-                Socket.optSet(socket, Socket.APR_SO_NONBLOCK, 0);
-            }
-        }
-    }
-}
-*/
-
-    @Override
-    protected int doRead(boolean block, byte[] b, int off, int len)
-            throws IOException {
-        // TODO Auto-generated method stub
-        return 0;
-    }
-
-    @Override
-    protected boolean doIsReady() {
-        // TODO Auto-generated method stub
-        return false;
-    }
-
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.IOException;
+
+import org.apache.tomcat.util.net.SocketWrapper;
+
+public class AprServletInputStream extends AbstractServletInputStream {
+
+    private final long socket;
+
+
+    public AprServletInputStream(SocketWrapper<Long> wrapper) {
+        this.socket = wrapper.getSocket().longValue();
+    }
+/*
+    @Override
+    protected int doRead() throws IOException {
+        byte[] bytes = new byte[1];
+        int result = Socket.recv(socket, bytes, 0, 1);
+        if (result == -1) {
+            return -1;
+        } else {
+            return bytes[0] & 0xFF;
+        }
+    }
+
+    @Override
+    protected int doRead(byte[] b, int off, int len) throws IOException {
+        boolean block = true;
+        if (!block) {
+            Socket.optSet(socket, Socket.APR_SO_NONBLOCK, -1);
+        }
+        try {
+            int result = Socket.recv(socket, b, off, len);
+            if (result > 0) {
+                return result;
+            } else if (-result == Status.EAGAIN) {
+                return 0;
+            } else {
+                throw new IOException(sm.getString("apr.error",
+                        Integer.valueOf(-result)));
+            }
+        } finally {
+            if (!block) {
+                Socket.optSet(socket, Socket.APR_SO_NONBLOCK, 0);
+            }
+        }
+    }
+}
+*/
+
+    @Override
+    protected int doRead(boolean block, byte[] b, int off, int len)
+            throws IOException {
+        // TODO Auto-generated method stub
+        return 0;
+    }
+
+    @Override
+    protected boolean doIsReady() {
+        // TODO Auto-generated method stub
+        return false;
+    }
+
+}

==================================================
BioServletInputStream.java
index ecfbb6d952..2343d3a84d 100644
--- a/java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/AprServletOutputStream.java
@@ -1,44 +1,44 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-
-import org.apache.tomcat.util.net.SocketWrapper;
-
-public class AprServletOutputStream extends AbstractServletOutputStream {
-
-    private final long socket;
-
-
-    public AprServletOutputStream(SocketWrapper<Long> wrapper) {
-        this.socket = wrapper.getSocket().longValue();
-    }
-
-
-    @Override
-    protected int doWrite(boolean block, byte[] b, int off, int len)
-            throws IOException {
-        // TODO Auto-generated method stub
-        return 0;
-    }
-
-    @Override
-    protected void doFlush() throws IOException {
-        // TODO Auto-generated method stub
-    }
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.IOException;
+
+import org.apache.tomcat.util.net.SocketWrapper;
+
+public class AprServletOutputStream extends AbstractServletOutputStream {
+
+    private final long socket;
+
+
+    public AprServletOutputStream(SocketWrapper<Long> wrapper) {
+        this.socket = wrapper.getSocket().longValue();
+    }
+
+
+    @Override
+    protected int doWrite(boolean block, byte[] b, int off, int len)
+            throws IOException {
+        // TODO Auto-generated method stub
+        return 0;
+    }
+
+    @Override
+    protected void doFlush() throws IOException {
+        // TODO Auto-generated method stub
+    }
+}

==================================================
BioServletOutputStream.java
index 6ee52e96e5..119000ac15 100644
--- a/java/org/apache/coyote/http11/upgrade/BioServletInputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/BioServletInputStream.java
@@ -1,45 +1,45 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.Socket;
-
-import org.apache.tomcat.util.net.SocketWrapper;
-
-public class BioServletInputStream extends AbstractServletInputStream {
-
-    private final InputStream inputStream;
-
-    public BioServletInputStream(SocketWrapper<Socket> wrapper)
-            throws IOException {
-        inputStream = wrapper.getSocket().getInputStream();
-    }
-
-    @Override
-    protected int doRead(boolean block, byte[] b, int off, int len)
-            throws IOException {
-        return inputStream.read(b, off, len);
-    }
-
-    @Override
-    protected boolean doIsReady() {
-        // Always returns true for BIO
-        return true;
-    }
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.Socket;
+
+import org.apache.tomcat.util.net.SocketWrapper;
+
+public class BioServletInputStream extends AbstractServletInputStream {
+
+    private final InputStream inputStream;
+
+    public BioServletInputStream(SocketWrapper<Socket> wrapper)
+            throws IOException {
+        inputStream = wrapper.getSocket().getInputStream();
+    }
+
+    @Override
+    protected int doRead(boolean block, byte[] b, int off, int len)
+            throws IOException {
+        return inputStream.read(b, off, len);
+    }
+
+    @Override
+    protected boolean doIsReady() {
+        // Always returns true for BIO
+        return true;
+    }
+}

==================================================
NioServletInputStream.java
index 4c7dd155b9..30178b578c 100644
--- a/java/org/apache/coyote/http11/upgrade/BioServletOutputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/BioServletOutputStream.java
@@ -1,45 +1,45 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.Socket;
-
-import org.apache.tomcat.util.net.SocketWrapper;
-
-public class BioServletOutputStream extends AbstractServletOutputStream {
-
-    private final OutputStream os;
-
-    public BioServletOutputStream(SocketWrapper<Socket> wrapper)
-            throws IOException {
-        os = wrapper.getSocket().getOutputStream();
-    }
-
-    @Override
-    protected int doWrite(boolean block, byte[] b, int off, int len)
-            throws IOException {
-        os.write(b, off, len);
-        return len;
-    }
-
-    @Override
-    protected void doFlush() throws IOException {
-        os.flush();
-    }
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.Socket;
+
+import org.apache.tomcat.util.net.SocketWrapper;
+
+public class BioServletOutputStream extends AbstractServletOutputStream {
+
+    private final OutputStream os;
+
+    public BioServletOutputStream(SocketWrapper<Socket> wrapper)
+            throws IOException {
+        os = wrapper.getSocket().getOutputStream();
+    }
+
+    @Override
+    protected int doWrite(boolean block, byte[] b, int off, int len)
+            throws IOException {
+        os.write(b, off, len);
+        return len;
+    }
+
+    @Override
+    protected void doFlush() throws IOException {
+        os.flush();
+    }
+}

==================================================
NioServletOutputStream.java
index ec56387a10..80b10d54ce 100644
--- a/java/org/apache/coyote/http11/upgrade/NioServletInputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/NioServletInputStream.java
@@ -1,133 +1,133 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.Selector;
-
-import org.apache.tomcat.util.net.NioChannel;
-import org.apache.tomcat.util.net.NioEndpoint;
-import org.apache.tomcat.util.net.NioSelectorPool;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-public class NioServletInputStream extends AbstractServletInputStream {
-
-    private final NioChannel channel;
-    private final NioSelectorPool pool;
-
-    public NioServletInputStream(SocketWrapper<NioChannel> wrapper,
-            NioSelectorPool pool) {
-        this.channel = wrapper.getSocket();
-        this.pool = pool;
-    }
-
-    @Override
-    protected boolean doIsReady() throws IOException {
-        ByteBuffer readBuffer = channel.getBufHandler().getReadBuffer();
-
-        if (readBuffer.remaining() > 0) {
-            return true;
-        }
-
-        readBuffer.clear();
-        fillReadBuffer(false);
-
-        boolean isReady = readBuffer.position() > 0;
-        readBuffer.flip();
-        return isReady;
-    }
-
-    @Override
-    protected int doRead(boolean block, byte[] b, int off, int len)
-            throws IOException {
-
-        ByteBuffer readBuffer = channel.getBufHandler().getReadBuffer();
-        int remaining = readBuffer.remaining();
-
-        // Is there enough data in the read buffer to satisfy this request?
-        if (remaining >= len) {
-            readBuffer.get(b, off, len);
-            return len;
-        }
-
-        // Copy what data there is in the read buffer to the byte array
-        int leftToWrite = len;
-        int newOffset = off;
-        if (remaining > 0) {
-            readBuffer.get(b, off, remaining);
-            leftToWrite -= remaining;
-            newOffset += remaining;
-        }
-
-        // Fill the read buffer as best we can
-        readBuffer.clear();
-        int nRead = fillReadBuffer(block);
-
-        // Full as much of the remaining byte array as possible with the data
-        // that was just read
-        if (nRead > 0) {
-            readBuffer.flip();
-            readBuffer.limit(nRead);
-            if (nRead > leftToWrite) {
-                readBuffer.get(b, newOffset, leftToWrite);
-                leftToWrite = 0;
-            } else {
-                readBuffer.get(b, newOffset, nRead);
-                leftToWrite -= nRead;
-            }
-        } else if (nRead == 0) {
-            readBuffer.flip();
-        } else if (nRead == -1) {
-            // TODO i18n
-            throw new EOFException();
-        }
-
-        return len - leftToWrite;
-    }
-
-    private int fillReadBuffer(boolean block) throws IOException {
-        int nRead;
-        if (block) {
-            Selector selector = null;
-            try {
-                selector = pool.get();
-            } catch ( IOException x ) {
-                // Ignore
-            }
-            try {
-                NioEndpoint.KeyAttachment att =
-                        (NioEndpoint.KeyAttachment) channel.getAttachment(false);
-                if (att == null) {
-                    throw new IOException("Key must be cancelled.");
-                }
-                nRead = pool.read(channel.getBufHandler().getReadBuffer(),
-                        channel, selector, att.getTimeout());
-            } catch (EOFException eof) {
-                nRead = -1;
-            } finally {
-                if (selector != null) {
-                    pool.put(selector);
-                }
-            }
-        } else {
-            nRead = channel.read(channel.getBufHandler().getReadBuffer());
-        }
-        return nRead;
-    }
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.Selector;
+
+import org.apache.tomcat.util.net.NioChannel;
+import org.apache.tomcat.util.net.NioEndpoint;
+import org.apache.tomcat.util.net.NioSelectorPool;
+import org.apache.tomcat.util.net.SocketWrapper;
+
+public class NioServletInputStream extends AbstractServletInputStream {
+
+    private final NioChannel channel;
+    private final NioSelectorPool pool;
+
+    public NioServletInputStream(SocketWrapper<NioChannel> wrapper,
+            NioSelectorPool pool) {
+        this.channel = wrapper.getSocket();
+        this.pool = pool;
+    }
+
+    @Override
+    protected boolean doIsReady() throws IOException {
+        ByteBuffer readBuffer = channel.getBufHandler().getReadBuffer();
+
+        if (readBuffer.remaining() > 0) {
+            return true;
+        }
+
+        readBuffer.clear();
+        fillReadBuffer(false);
+
+        boolean isReady = readBuffer.position() > 0;
+        readBuffer.flip();
+        return isReady;
+    }
+
+    @Override
+    protected int doRead(boolean block, byte[] b, int off, int len)
+            throws IOException {
+
+        ByteBuffer readBuffer = channel.getBufHandler().getReadBuffer();
+        int remaining = readBuffer.remaining();
+
+        // Is there enough data in the read buffer to satisfy this request?
+        if (remaining >= len) {
+            readBuffer.get(b, off, len);
+            return len;
+        }
+
+        // Copy what data there is in the read buffer to the byte array
+        int leftToWrite = len;
+        int newOffset = off;
+        if (remaining > 0) {
+            readBuffer.get(b, off, remaining);
+            leftToWrite -= remaining;
+            newOffset += remaining;
+        }
+
+        // Fill the read buffer as best we can
+        readBuffer.clear();
+        int nRead = fillReadBuffer(block);
+
+        // Full as much of the remaining byte array as possible with the data
+        // that was just read
+        if (nRead > 0) {
+            readBuffer.flip();
+            readBuffer.limit(nRead);
+            if (nRead > leftToWrite) {
+                readBuffer.get(b, newOffset, leftToWrite);
+                leftToWrite = 0;
+            } else {
+                readBuffer.get(b, newOffset, nRead);
+                leftToWrite -= nRead;
+            }
+        } else if (nRead == 0) {
+            readBuffer.flip();
+        } else if (nRead == -1) {
+            // TODO i18n
+            throw new EOFException();
+        }
+
+        return len - leftToWrite;
+    }
+
+    private int fillReadBuffer(boolean block) throws IOException {
+        int nRead;
+        if (block) {
+            Selector selector = null;
+            try {
+                selector = pool.get();
+            } catch ( IOException x ) {
+                // Ignore
+            }
+            try {
+                NioEndpoint.KeyAttachment att =
+                        (NioEndpoint.KeyAttachment) channel.getAttachment(false);
+                if (att == null) {
+                    throw new IOException("Key must be cancelled.");
+                }
+                nRead = pool.read(channel.getBufHandler().getReadBuffer(),
+                        channel, selector, att.getTimeout());
+            } catch (EOFException eof) {
+                nRead = -1;
+            } finally {
+                if (selector != null) {
+                    pool.put(selector);
+                }
+            }
+        } else {
+            nRead = channel.read(channel.getBufHandler().getReadBuffer());
+        }
+        return nRead;
+    }
+}

==================================================
TestUpgrade.java
index 560f96d31e..e98f9fc560 100644
--- a/java/org/apache/coyote/http11/upgrade/NioServletOutputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/NioServletOutputStream.java
@@ -1,128 +1,128 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.coyote.http11.upgrade;
-
-import java.io.IOException;
-import java.nio.channels.Selector;
-
-import org.apache.tomcat.util.net.NioChannel;
-import org.apache.tomcat.util.net.NioEndpoint;
-import org.apache.tomcat.util.net.NioSelectorPool;
-import org.apache.tomcat.util.net.SocketWrapper;
-
-public class NioServletOutputStream extends AbstractServletOutputStream {
-
-    private final NioChannel nioChannel;
-    private final NioSelectorPool pool;
-    private final int maxWrite;
-
-
-    public NioServletOutputStream(
-            SocketWrapper<NioChannel> wrapper, NioSelectorPool pool) {
-        nioChannel = wrapper.getSocket();
-        this.pool = pool;
-        maxWrite = nioChannel.getBufHandler().getWriteBuffer().capacity();
-    }
-
-
-    @Override
-    protected int doWrite(boolean block, byte[] b, int off, int len)
-            throws IOException {
-        int leftToWrite = len;
-        int count = 0;
-        int offset = off;
-
-        while (leftToWrite > 0) {
-            int writeThisLoop;
-            int writtenThisLoop;
-
-            if (leftToWrite > maxWrite) {
-                writeThisLoop = maxWrite;
-            } else {
-                writeThisLoop = leftToWrite;
-            }
-
-            writtenThisLoop = doWriteInternal(block, b, offset, writeThisLoop);
-            count += writtenThisLoop;
-            leftToWrite -= writtenThisLoop;
-
-            if (writtenThisLoop < writeThisLoop) {
-                break;
-            }
-        }
-
-        return count;
-    }
-
-    private int doWriteInternal (boolean block, byte[] b, int off, int len)
-            throws IOException {
-        nioChannel.getBufHandler().getWriteBuffer().clear();
-        nioChannel.getBufHandler().getWriteBuffer().put(b, off, len);
-        nioChannel.getBufHandler().getWriteBuffer().flip();
-
-        int written = 0;
-        NioEndpoint.KeyAttachment att =
-                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
-        if (att == null) {
-            throw new IOException("Key must be cancelled");
-        }
-        long writeTimeout = att.getTimeout();
-        Selector selector = null;
-        try {
-            selector = pool.get();
-        } catch ( IOException x ) {
-            //ignore
-        }
-        try {
-            written = pool.write(nioChannel.getBufHandler().getWriteBuffer(),
-                    nioChannel, selector, writeTimeout, block);
-        } finally {
-            if (selector != null) {
-                pool.put(selector);
-            }
-        }
-        return written;
-    }
-
-
-    @Override
-    protected void doFlush() throws IOException {
-        NioEndpoint.KeyAttachment att =
-                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
-        if (att == null) {
-            throw new IOException("Key must be cancelled");
-        }
-        long writeTimeout = att.getTimeout();
-        Selector selector = null;
-        try {
-            selector = pool.get();
-        } catch ( IOException x ) {
-            //ignore
-        }
-        try {
-            do {
-                if (nioChannel.flush(true, selector, writeTimeout)) {
-                    break;
-                }
-            } while (true);
-        } finally {
-            if (selector != null) {
-                pool.put(selector);
-            }
-        }
-    }
-}
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http11.upgrade;
+
+import java.io.IOException;
+import java.nio.channels.Selector;
+
+import org.apache.tomcat.util.net.NioChannel;
+import org.apache.tomcat.util.net.NioEndpoint;
+import org.apache.tomcat.util.net.NioSelectorPool;
+import org.apache.tomcat.util.net.SocketWrapper;
+
+public class NioServletOutputStream extends AbstractServletOutputStream {
+
+    private final NioChannel nioChannel;
+    private final NioSelectorPool pool;
+    private final int maxWrite;
+
+
+    public NioServletOutputStream(
+            SocketWrapper<NioChannel> wrapper, NioSelectorPool pool) {
+        nioChannel = wrapper.getSocket();
+        this.pool = pool;
+        maxWrite = nioChannel.getBufHandler().getWriteBuffer().capacity();
+    }
+
+
+    @Override
+    protected int doWrite(boolean block, byte[] b, int off, int len)
+            throws IOException {
+        int leftToWrite = len;
+        int count = 0;
+        int offset = off;
+
+        while (leftToWrite > 0) {
+            int writeThisLoop;
+            int writtenThisLoop;
+
+            if (leftToWrite > maxWrite) {
+                writeThisLoop = maxWrite;
+            } else {
+                writeThisLoop = leftToWrite;
+            }
+
+            writtenThisLoop = doWriteInternal(block, b, offset, writeThisLoop);
+            count += writtenThisLoop;
+            leftToWrite -= writtenThisLoop;
+
+            if (writtenThisLoop < writeThisLoop) {
+                break;
+            }
+        }
+
+        return count;
+    }
+
+    private int doWriteInternal (boolean block, byte[] b, int off, int len)
+            throws IOException {
+        nioChannel.getBufHandler().getWriteBuffer().clear();
+        nioChannel.getBufHandler().getWriteBuffer().put(b, off, len);
+        nioChannel.getBufHandler().getWriteBuffer().flip();
+
+        int written = 0;
+        NioEndpoint.KeyAttachment att =
+                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
+        if (att == null) {
+            throw new IOException("Key must be cancelled");
+        }
+        long writeTimeout = att.getTimeout();
+        Selector selector = null;
+        try {
+            selector = pool.get();
+        } catch ( IOException x ) {
+            //ignore
+        }
+        try {
+            written = pool.write(nioChannel.getBufHandler().getWriteBuffer(),
+                    nioChannel, selector, writeTimeout, block);
+        } finally {
+            if (selector != null) {
+                pool.put(selector);
+            }
+        }
+        return written;
+    }
+
+
+    @Override
+    protected void doFlush() throws IOException {
+        NioEndpoint.KeyAttachment att =
+                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);
+        if (att == null) {
+            throw new IOException("Key must be cancelled");
+        }
+        long writeTimeout = att.getTimeout();
+        Selector selector = null;
+        try {
+            selector = pool.get();
+        } catch ( IOException x ) {
+            //ignore
+        }
+        try {
+            do {
+                if (nioChannel.flush(true, selector, writeTimeout)) {
+                    break;
+                }
+            } while (true);
+        } finally {
+            if (selector != null) {
+                pool.put(selector);
+            }
+        }
+    }
+}

==================================================
