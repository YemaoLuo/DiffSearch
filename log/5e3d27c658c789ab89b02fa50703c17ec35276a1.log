5e3d27c658c789ab89b02fa50703c17ec35276a1
==================================================
Align all three StringManager implementations
==================================================
Mark Emlyn
==================================================
Mon Nov 9 21:18:01 2009 +0000
==================================================
StringManager.java
Align all three StringManager implementations

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@834238 13f79535-47bb-0310-9956-ffa450edef68



==================================================
StringManager.java
index bac15e2891..bc671b01b9 100644
--- a/java/org/apache/catalina/tribes/util/StringManager.java
+++ b/java/org/apache/catalina/tribes/util/StringManager.java
@@ -1,21 +1,20 @@
 /*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
  */
 
-
 package org.apache.catalina.tribes.util;
 
 import java.text.MessageFormat;
@@ -23,7 +22,6 @@ import java.util.Hashtable;
 import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.ResourceBundle;
-import java.net.URLClassLoader;
 
 /**
  * An internationalization / localization helper class which reduces
@@ -44,8 +42,12 @@ import java.net.URLClassLoader;
  * <p>Please see the documentation for java.util.ResourceBundle for
  * more information.
  *
+ * @version $Revision$ $Date$
+ *
  * @author James Duncan Davidson [duncan@eng.sun.com]
  * @author James Todd [gonzo@eng.sun.com]
+ * @author Mel Martinez [mmartinez@g1440.com]
+ * @see java.util.ResourceBundle
  */
 
 public class StringManager {
@@ -53,11 +55,8 @@ public class StringManager {
     /**
      * The ResourceBundle for this StringManager.
      */
-
     private ResourceBundle bundle;
-
-    private static org.apache.juli.logging.Log log=
-        org.apache.juli.logging.LogFactory.getLog( StringManager.class );
+    private Locale locale;
 
     /**
      * Creates a new StringManager for a given package. This is a
@@ -67,60 +66,62 @@ public class StringManager {
      *
      * @param packageName Name of package to create StringManager for.
      */
-
     private StringManager(String packageName) {
         String bundleName = packageName + ".LocalStrings";
         try {
-            bundle = ResourceBundle.getBundle(bundleName);
-            return;
+            bundle = ResourceBundle.getBundle(bundleName, Locale.getDefault());
         } catch( MissingResourceException ex ) {
-            // Try from the current loader ( that's the case for trusted apps )
-            ClassLoader cl=Thread.currentThread().getContextClassLoader();
+            // Try from the current loader (that's the case for trusted apps)
+            // Should only be required if using a TC5 style classloader structure
+            // where common != shared != server
+            ClassLoader cl = Thread.currentThread().getContextClassLoader();
             if( cl != null ) {
                 try {
-                    bundle=ResourceBundle.getBundle(bundleName, Locale.getDefault(), cl);
-                    return;
+                    bundle = ResourceBundle.getBundle(
+                            bundleName, Locale.getDefault(), cl);
                 } catch(MissingResourceException ex2) {
+                    // Ignore
                 }
             }
-            if( cl==null )
-                cl=this.getClass().getClassLoader();
-
-            if (log.isDebugEnabled())
-                log.debug("Can't find resource " + bundleName +
-                    " " + cl);
-            if( cl instanceof URLClassLoader ) {
-                if (log.isDebugEnabled()) 
-                    log.debug( ((URLClassLoader)cl).getURLs());
-            }
+        }
+        // Get the actual locale, which may be different from the requested one
+        if (bundle != null) {
+            locale = bundle.getLocale();
         }
     }
 
     /**
-     * Get a string from the underlying resource bundle.
-     *
-     * @param key The resource name
+        Get a string from the underlying resource bundle or return
+        null if the String is not found.
+     
+        @param key to desired resource String
+        @return resource String matching <i>key</i> from underlying
+                bundle or null if not found.
+        @throws IllegalArgumentException if <i>key</i> is null.        
      */
     public String getString(String key) {
-        return MessageFormat.format(getStringInternal(key), (Object [])null);
-    }
-
+        if(key == null){
+            String msg = "key may not have a null value";
 
-    protected String getStringInternal(String key) {
-        if (key == null) {
-            String msg = "key is null";
-
-            throw new NullPointerException(msg);
+            throw new IllegalArgumentException(msg);
         }
 
         String str = null;
 
-        if( bundle==null )
-            return key;
         try {
             str = bundle.getString(key);
-        } catch (MissingResourceException mre) {
-            str = "Cannot find message associated with key '" + key + "'";
+        } catch(MissingResourceException mre) {
+            //bad: shouldn't mask an exception the following way:
+            //   str = "[cannot find message associated with key '" + key + "' due to " + mre + "]";
+            //     because it hides the fact that the String was missing
+            //     from the calling code.
+            //good: could just throw the exception (or wrap it in another)
+            //      but that would probably cause much havoc on existing
+            //      code.
+            //better: consistent with container pattern to
+            //      simply return null.  Calling code can then do
+            //      a null check.
+            str = null;
         }
 
         return str;
@@ -130,109 +131,26 @@ public class StringManager {
      * Get a string from the underlying resource bundle and format
      * it with the given set of arguments.
      *
-     * @param key The resource name
-     * @param args Formatting directives
+     * @param key
+     * @param args
      */
-
-    public String getString(String key, Object[] args) {
-        String iString = null;
-        String value = getStringInternal(key);
-
-        // this check for the runtime exception is some pre 1.1.6
-        // VM's don't do an automatic toString() on the passed in
-        // objects and barf out
-
-        try {
-            // ensure the arguments are not null so pre 1.2 VM's don't barf
-            Object nonNullArgs[] = args;
-            for (int i=0; i<args.length; i++) {
-                if (args[i] == null) {
-                    if (nonNullArgs==args) nonNullArgs = args.clone();
-                    nonNullArgs[i] = "null";
-                }
-            }
-
-            iString = MessageFormat.format(value, nonNullArgs);
-        } catch (IllegalArgumentException iae) {
-            StringBuilder buf = new StringBuilder();
-            buf.append(value);
-            for (int i = 0; i < args.length; i++) {
-                buf.append(" arg[" + i + "]=" + args[i]);
-            }
-            iString = buf.toString();
+    public String getString(final String key, final Object... args) {
+        String value = getString(key);
+        if (value == null) {
+            value = key;
         }
-        return iString;
-    }
-
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object argument. This argument can of course be
-     * a String object.
-     *
-     * @param key The resource name
-     * @param arg Formatting directive
-     */
-
-    public String getString(String key, Object arg) {
-        Object[] args = new Object[] {arg};
-        return getString(key, args);
-    }
-
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object arguments. These arguments can of course
-     * be String objects.
-     *
-     * @param key The resource name
-     * @param arg1 Formatting directive
-     * @param arg2 Formatting directive
-     */
 
-    public String getString(String key, Object arg1, Object arg2) {
-        Object[] args = new Object[] {arg1, arg2};
-        return getString(key, args);
+        MessageFormat mf = new MessageFormat(value);
+        mf.setLocale(locale);
+        return mf.format(args, new StringBuffer(), null).toString();
     }
 
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object arguments. These arguments can of course
-     * be String objects.
-     *
-     * @param key The resource name
-     * @param arg1 Formatting directive
-     * @param arg2 Formatting directive
-     * @param arg3 Formatting directive
-     */
-
-    public String getString(String key, Object arg1, Object arg2,
-                            Object arg3) {
-        Object[] args = new Object[] {arg1, arg2, arg3};
-        return getString(key, args);
-    }
-
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object arguments. These arguments can of course
-     * be String objects.
-     *
-     * @param key The resource name
-     * @param arg1 Formatting directive
-     * @param arg2 Formatting directive
-     * @param arg3 Formatting directive
-     * @param arg4 Formatting directive
-     */
-
-    public String getString(String key, Object arg1, Object arg2,
-                            Object arg3, Object arg4) {
-        Object[] args = new Object[] {arg1, arg2, arg3, arg4};
-        return getString(key, args);
-    }
     // --------------------------------------------------------------
     // STATIC SUPPORT METHODS
     // --------------------------------------------------------------
 
     private static Hashtable<String, StringManager> managers =
-        new Hashtable<String,StringManager>();
+        new Hashtable<String, StringManager>();
 
     /**
      * Get the StringManager for a particular package. If a manager for
@@ -241,14 +159,13 @@ public class StringManager {
      *
      * @param packageName The package name
      */
-
     public synchronized static final StringManager getManager(String packageName) {
         StringManager mgr = managers.get(packageName);
-
         if (mgr == null) {
             mgr = new StringManager(packageName);
             managers.put(packageName, mgr);
         }
         return mgr;
     }
+
 }

==================================================
StringManager.java
index f5632a4223..faffe1b652 100644
--- a/java/org/apache/naming/StringManager.java
+++ b/java/org/apache/naming/StringManager.java
@@ -1,25 +1,25 @@
 /*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */ 
-
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
 
 package org.apache.naming;
 
 import java.text.MessageFormat;
 import java.util.Hashtable;
+import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.ResourceBundle;
 
@@ -42,8 +42,12 @@ import java.util.ResourceBundle;
  * <p>Please see the documentation for java.util.ResourceBundle for
  * more information.
  *
+ * @version $Revision$ $Date$
+ *
  * @author James Duncan Davidson [duncan@eng.sun.com]
  * @author James Todd [gonzo@eng.sun.com]
+ * @author Mel Martinez [mmartinez@g1440.com]
+ * @see java.util.ResourceBundle
  */
 
 public class StringManager {
@@ -51,8 +55,8 @@ public class StringManager {
     /**
      * The ResourceBundle for this StringManager.
      */
-    
     private ResourceBundle bundle;
+    private Locale locale;
 
     /**
      * Creates a new StringManager for a given package. This is a
@@ -62,31 +66,62 @@ public class StringManager {
      *
      * @param packageName Name of package to create StringManager for.
      */
-
     private StringManager(String packageName) {
-	String bundleName = packageName + ".LocalStrings";
-	bundle = ResourceBundle.getBundle(bundleName);
+        String bundleName = packageName + ".LocalStrings";
+        try {
+            bundle = ResourceBundle.getBundle(bundleName, Locale.getDefault());
+        } catch( MissingResourceException ex ) {
+            // Try from the current loader (that's the case for trusted apps)
+            // Should only be required if using a TC5 style classloader structure
+            // where common != shared != server
+            ClassLoader cl = Thread.currentThread().getContextClassLoader();
+            if( cl != null ) {
+                try {
+                    bundle = ResourceBundle.getBundle(
+                            bundleName, Locale.getDefault(), cl);
+                } catch(MissingResourceException ex2) {
+                    // Ignore
+                }
+            }
+        }
+        // Get the actual locale, which may be different from the requested one
+        if (bundle != null) {
+            locale = bundle.getLocale();
+        }
     }
 
     /**
-     * Get a string from the underlying resource bundle.
-     *
-     * @param key 
+        Get a string from the underlying resource bundle or return
+        null if the String is not found.
+     
+        @param key to desired resource String
+        @return resource String matching <i>key</i> from underlying
+                bundle or null if not found.
+        @throws IllegalArgumentException if <i>key</i> is null.        
      */
-    
     public String getString(String key) {
-        if (key == null) {
-            String msg = "key is null";
+        if(key == null){
+            String msg = "key may not have a null value";
 
-            throw new NullPointerException(msg);
+            throw new IllegalArgumentException(msg);
         }
 
         String str = null;
 
         try {
-	    str = bundle.getString(key);
-        } catch (MissingResourceException mre) {
-            str = "Cannot find message associated with key '" + key + "'";
+            str = bundle.getString(key);
+        } catch(MissingResourceException mre) {
+            //bad: shouldn't mask an exception the following way:
+            //   str = "[cannot find message associated with key '" + key + "' due to " + mre + "]";
+            //     because it hides the fact that the String was missing
+            //     from the calling code.
+            //good: could just throw the exception (or wrap it in another)
+            //      but that would probably cause much havoc on existing
+            //      code.
+            //better: consistent with container pattern to
+            //      simply return null.  Calling code can then do
+            //      a null check.
+            str = null;
         }
 
         return str;
@@ -99,121 +134,38 @@ public class StringManager {
      * @param key
      * @param args
      */
-
-    public String getString(String key, Object[] args) {
-	String iString = null;
+    public String getString(final String key, final Object... args) {
         String value = getString(key);
+        if (value == null) {
+            value = key;
+        }
 
-	// this check for the runtime exception is some pre 1.1.6
-	// VM's don't do an automatic toString() on the passed in
-	// objects and barf out
-	
-	try {
-            // ensure the arguments are not null so pre 1.2 VM's don't barf
-            Object nonNullArgs[] = args;
-            for (int i=0; i<args.length; i++) {
-		if (args[i] == null) {
-		    if (nonNullArgs==args) nonNullArgs = args.clone();
-		    nonNullArgs[i] = "null";
-		}
-	    }
- 
-            iString = MessageFormat.format(value, nonNullArgs);
-	} catch (IllegalArgumentException iae) {
-	    StringBuilder buf = new StringBuilder();
-	    buf.append(value);
-	    for (int i = 0; i < args.length; i++) {
-		buf.append(" arg[" + i + "]=" + args[i]);
-	    }
-	    iString = buf.toString();
-	}
-	return iString;
-    }
-
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object argument. This argument can of course be
-     * a String object.
-     *
-     * @param key
-     * @param arg
-     */
-
-    public String getString(String key, Object arg) {
-	Object[] args = new Object[] {arg};
-	return getString(key, args);
-    }
-
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object arguments. These arguments can of course
-     * be String objects.
-     *
-     * @param key
-     * @param arg1
-     * @param arg2
-     */
-
-    public String getString(String key, Object arg1, Object arg2) {
-	Object[] args = new Object[] {arg1, arg2};
-	return getString(key, args);
-    }
-    
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object arguments. These arguments can of course
-     * be String objects.
-     *
-     * @param key
-     * @param arg1
-     * @param arg2
-     * @param arg3
-     */
-
-    public String getString(String key, Object arg1, Object arg2,
-			    Object arg3) {
-	Object[] args = new Object[] {arg1, arg2, arg3};
-	return getString(key, args);
+        MessageFormat mf = new MessageFormat(value);
+        mf.setLocale(locale);
+        return mf.format(args, new StringBuffer(), null).toString();
     }
-    
-    /**
-     * Get a string from the underlying resource bundle and format it
-     * with the given object arguments. These arguments can of course
-     * be String objects.
-     *
-     * @param key
-     * @param arg1
-     * @param arg2
-     * @param arg3
-     * @param arg4
-     */
 
-    public String getString(String key, Object arg1, Object arg2,
-			    Object arg3, Object arg4) {
-	Object[] args = new Object[] {arg1, arg2, arg3, arg4};
-	return getString(key, args);
-    }   
     // --------------------------------------------------------------
     // STATIC SUPPORT METHODS
     // --------------------------------------------------------------
 
-    private static Hashtable<String,StringManager> managers =
-        new Hashtable<String,StringManager>();
+    private static Hashtable<String, StringManager> managers =
+        new Hashtable<String, StringManager>();
 
     /**
      * Get the StringManager for a particular package. If a manager for
      * a package already exists, it will be reused, else a new
      * StringManager will be created and returned.
      *
-     * @param packageName
+     * @param packageName The package name
      */
-
     public synchronized static final StringManager getManager(String packageName) {
-	StringManager mgr = managers.get(packageName);
-	if (mgr == null) {
-	    mgr = new StringManager(packageName);
-	    managers.put(packageName, mgr);
-	}
-	return mgr;
+        StringManager mgr = managers.get(packageName);
+        if (mgr == null) {
+            mgr = new StringManager(packageName);
+            managers.put(packageName, mgr);
+        }
+        return mgr;
     }
+
 }

==================================================
