2c6ad2285456fcc8fe50eb4b0e0a6b730371fdcc
==================================================
 syncing up from 6.0
==================================================
Filip Hanik
==================================================
Fri Jul 20 22:18:27 2007 +0000
==================================================
AcceptLanguage.java
 syncing up from 6.0


git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@558176 13f79535-47bb-0310-9956-ffa450edef68



==================================================
BaseRequest.java
index 061f24954f..a3a103bc05 100644
--- a/java/org/apache/tomcat/util/http/AcceptLanguage.java
+++ b/java/org/apache/tomcat/util/http/AcceptLanguage.java
@@ -38,44 +38,46 @@ import java.util.Vector;
 public class AcceptLanguage {
 
     public static Locale getLocale(String acceptLanguage) {
-	if( acceptLanguage == null ) return Locale.getDefault();
+        if( acceptLanguage == null ) return Locale.getDefault();
 
-        Hashtable languages = new Hashtable();
-        Vector quality=new Vector();
-        processAcceptLanguage(acceptLanguage, languages,quality);
+        Hashtable<String,Vector<String>> languages =
+            new Hashtable<String,Vector<String>>();
+        Vector<Double> quality = new Vector<Double>();
+        processAcceptLanguage(acceptLanguage, languages, quality);
 
         if (languages.size() == 0) return Locale.getDefault();
 
-        Vector l = new Vector();
+        Vector<Locale> l = new Vector<Locale>();
         extractLocales( languages,quality, l);
 
         return (Locale)l.elementAt(0);
     }
 
     public static Enumeration getLocales(String acceptLanguage) {
-    	// Short circuit with an empty enumeration if null header
+            // Short circuit with an empty enumeration if null header
         if (acceptLanguage == null) {
-            Vector v = new Vector();
+            Vector<Locale> v = new Vector<Locale>();
             v.addElement(Locale.getDefault());
             return v.elements();
         }
-	
-        Hashtable languages = new Hashtable();
-        Vector quality=new Vector();
-    	processAcceptLanguage(acceptLanguage, languages , quality);
+        
+        Hashtable<String,Vector<String>> languages =
+            new Hashtable<String,Vector<String>>();
+        Vector<Double> quality=new Vector<Double>();
+            processAcceptLanguage(acceptLanguage, languages , quality);
 
         if (languages.size() == 0) {
-            Vector v = new Vector();
+            Vector<Locale> v = new Vector<Locale>();
             v.addElement(Locale.getDefault());
             return v.elements();
         }
-    	Vector l = new Vector();
-    	extractLocales( languages, quality , l);
-    	return l.elements();
+            Vector<Locale> l = new Vector<Locale>();
+            extractLocales( languages, quality , l);
+            return l.elements();
     }
 
     private static void processAcceptLanguage( String acceptLanguage,
-					      Hashtable languages, Vector q)
+            Hashtable<String,Vector<String>> languages, Vector<Double> q)
     {
         StringTokenizer languageTokenizer =
             new StringTokenizer(acceptLanguage, ",");
@@ -90,7 +92,7 @@ public class AcceptLanguage {
             if (qValueIndex > -1 &&
                     qValueIndex < qIndex &&
                     qIndex < equalIndex) {
-    	        String qValueStr = language.substring(qValueIndex + 1);
+                    String qValueStr = language.substring(qValueIndex + 1);
                 language = language.substring(0, qValueIndex);
                 qValueStr = qValueStr.trim().toLowerCase();
                 qValueIndex = qValueStr.indexOf('=');
@@ -110,11 +112,11 @@ public class AcceptLanguage {
 
             if (! language.equals("*")) {
                 String key = qValue.toString();
-                Vector v;
+                Vector<String> v;
                 if (languages.containsKey(key)) {
-                    v = (Vector)languages.get(key) ;
+                    v = languages.get(key) ;
                 } else {
-                    v= new Vector();
+                    v= new Vector<String>();
                     q.addElement(qValue);
                 }
                 v.addElement(language);
@@ -123,7 +125,8 @@ public class AcceptLanguage {
         }
     }
 
-    private static void extractLocales(Hashtable languages, Vector q,Vector l)
+    private static void extractLocales(Hashtable languages, Vector q,
+            Vector<Locale> l)
     {
         // XXX We will need to order by q value Vector in the Future ?
         Enumeration e = q.elements();
@@ -132,9 +135,9 @@ public class AcceptLanguage {
                 (Vector)languages.get(((Double)e.nextElement()).toString());
             Enumeration le = v.elements();
             while (le.hasMoreElements()) {
-    	        String language = (String)le.nextElement();
-	        	String country = "";
-        		int countryIndex = language.indexOf("-");
+                    String language = (String)le.nextElement();
+                        String country = "";
+                        int countryIndex = language.indexOf("-");
                 if (countryIndex > -1) {
                     country = language.substring(countryIndex + 1).trim();
                     language = language.substring(0, countryIndex).trim();

==================================================
MimeMap.java
index b00f5d3222..92e04c9287 100644
--- a/java/org/apache/tomcat/util/http/BaseRequest.java
+++ b/java/org/apache/tomcat/util/http/BaseRequest.java
@@ -59,7 +59,7 @@ public class BaseRequest {
     MessageBytes contentType = MessageBytes.newInstance();
     MimeHeaders headers = new MimeHeaders();
     Cookies cookies = new Cookies();
-    HashMap attributes = new HashMap();
+    HashMap<String,Object> attributes = new HashMap<String,Object>();
 
     MessageBytes tomcatInstanceId = MessageBytes.newInstance();
     

==================================================
Parameters.java
index e377f388ad..77cccce463 100644
--- a/java/org/apache/tomcat/util/http/MimeMap.java
+++ b/java/org/apache/tomcat/util/http/MimeMap.java
@@ -32,7 +32,8 @@ public class MimeMap implements FileNameMap {
     // Defaults - all of them are "well-known" types,
     // you can add using normal web.xml.
     
-    public static Hashtable defaultMap=new Hashtable(101);
+    public static Hashtable<String,String> defaultMap =
+        new Hashtable<String,String>(101);
     static {
         defaultMap.put("txt", "text/plain");
         defaultMap.put("html","text/html");
@@ -42,7 +43,7 @@ public class MimeMap implements FileNameMap {
         defaultMap.put("jpe", "image/jpeg");
         defaultMap.put("jpeg", "image/jpeg");
         defaultMap.put("png", "image/png");
-		defaultMap.put("java", "text/plain");
+                defaultMap.put("java", "text/plain");
         defaultMap.put("body", "text/html");
         defaultMap.put("rtx", "text/richtext");
         defaultMap.put("tsv", "text/tab-separated-values");
@@ -133,7 +134,7 @@ public class MimeMap implements FileNameMap {
     }
     
 
-    private Hashtable map = new Hashtable();
+    private Hashtable<String,String> map = new Hashtable<String,String>();
 
     public void addContentType(String extn, String type) {
         map.put(extn, type.toLowerCase());
@@ -145,8 +146,8 @@ public class MimeMap implements FileNameMap {
 
     public String getContentType(String extn) {
         String type = (String)map.get(extn.toLowerCase());
-	if( type == null ) type=(String)defaultMap.get( extn );
-	return type;
+        if( type == null ) type=(String)defaultMap.get( extn );
+        return type;
     }
 
     public void removeContentType(String extn) {
@@ -158,14 +159,14 @@ public class MimeMap implements FileNameMap {
     public static String getExtension( String fileName ) {
         // play it safe and get rid of any fragment id
         // that might be there
-	int length=fileName.length();
-	
+        int length=fileName.length();
+        
         int newEnd = fileName.lastIndexOf('#');
-	if( newEnd== -1 ) newEnd=length;
-	// Instead of creating a new string.
-	//         if (i != -1) {
-	//             fileName = fileName.substring(0, i);
-	//         }
+        if( newEnd== -1 ) newEnd=length;
+        // Instead of creating a new string.
+        //         if (i != -1) {
+        //             fileName = fileName.substring(0, i);
+        //         }
         int i = fileName.lastIndexOf('.', newEnd );
         if (i != -1) {
              return  fileName.substring(i + 1, newEnd );
@@ -176,7 +177,7 @@ public class MimeMap implements FileNameMap {
     }
     
     public String getContentTypeFor(String fileName) {
-	String extn=getExtension( fileName );
+        String extn=getExtension( fileName );
         if (extn!=null) {
             return getContentType(extn);
         } else {

==================================================
ServerCookie.java
index 03f59b800d..1d7039449c 100644
--- a/java/org/apache/tomcat/util/http/Parameters.java
+++ b/java/org/apache/tomcat/util/http/Parameters.java
@@ -40,7 +40,8 @@ public final class Parameters extends MultiMap {
     // Transition: we'll use the same Hashtable( String->String[] )
     // for the beginning. When we are sure all accesses happen through
     // this class - we can switch to MultiMap
-    private Hashtable paramHashStringArray=new Hashtable();
+    private Hashtable<String,String[]> paramHashStringArray =
+        new Hashtable<String,String[]>();
     private boolean didQueryParameters=false;
     private boolean didMerge=false;
     
@@ -225,7 +226,7 @@ public final class Parameters extends MultiMap {
 
         // Add the parent props to the child ( lower precedence )
         parent.merge();
-        Hashtable parentProps=parent.paramHashStringArray;
+        Hashtable<String,String[]> parentProps=parent.paramHashStringArray;
         merge2( paramHashStringArray , parentProps);
         didMerge=true;
         if(debug > 0 )
@@ -273,13 +274,14 @@ public final class Parameters extends MultiMap {
      *  Used to combine child parameters ( RequestDispatcher's query )
      *  with parent parameters ( original query or parent dispatcher )
      */
-    private static void merge2(Hashtable one, Hashtable two ) {
+    private static void merge2(Hashtable<String,String[]> one,
+            Hashtable<String,String[]> two ) {
         Enumeration e = two.keys();
 
         while (e.hasMoreElements()) {
             String name = (String) e.nextElement();
-            String[] oneValue = (String[]) one.get(name);
-            String[] twoValue = (String[]) two.get(name);
+            String[] oneValue = one.get(name);
+            String[] twoValue = two.get(name);
             String[] combinedValue;
 
             if (twoValue == null) {

==================================================
