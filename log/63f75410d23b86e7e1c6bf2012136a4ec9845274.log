63f75410d23b86e7e1c6bf2012136a4ec9845274
==================================================
Introduce a new method SocketWrapperBase.write(boolean, ByteBuffer)
==================================================
Violeta Georgieva
==================================================
Fri Aug 26 15:35:40 2016 +0000
==================================================
Nio2Endpoint.java
Introduce a new method SocketWrapperBase.write(boolean, ByteBuffer)

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1757883 13f79535-47bb-0310-9956-ffa450edef68



==================================================
SocketWrapperBase.java
index 918bda5944..b486004e4a 100644
--- a/java/org/apache/tomcat/util/net/Nio2Endpoint.java
+++ b/java/org/apache/tomcat/util/net/Nio2Endpoint.java
@@ -1153,6 +1153,41 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
         }
 
 
+        /**
+         * {@inheritDoc}
+         * <p>
+         * Overridden for NIO2 to enable a gathering write to be used to write
+         * all of the remaining data in a single additional write should a
+         * non-blocking write leave data in the buffer.
+         */
+        @Override
+        protected void writeNonBlocking(ByteBuffer from) throws IOException {
+            // Note: Possible alternate behavior:
+            // If there's non blocking abuse (like a test writing 1MB in a single
+            // "non blocking" write), then block until the previous write is
+            // done rather than continue buffering
+            // Also allows doing autoblocking
+            // Could be "smart" with coordination with the main CoyoteOutputStream to
+            // indicate the end of a write
+            // Uses: if (writePending.tryAcquire(socketWrapper.getTimeout(), TimeUnit.MILLISECONDS))
+            synchronized (writeCompletionHandler) {
+                if (writePending.tryAcquire()) {
+                    // No pending completion handler, so writing to the main buffer
+                    // is possible
+                    socketBufferHandler.configureWriteBufferForWrite();
+                    transfer(from, socketBufferHandler.getWriteBuffer());
+                    if (from.remaining() > 0) {
+                        // Remaining data must be buffered
+                        addToBuffers(from);
+                    }
+                    flushNonBlocking(true);
+                } else {
+                    addToBuffers(from);
+                }
+            }
+        }
+
+
         /**
          * @param block Ignored since this method is only called in the
          *              blocking case

==================================================
