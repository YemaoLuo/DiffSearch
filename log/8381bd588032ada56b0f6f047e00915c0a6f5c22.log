8381bd588032ada56b0f6f047e00915c0a6f5c22
==================================================
Fix various Eclipse warnings.
==================================================
Mark Emlyn
==================================================
Mon Feb 9 19:55:29 2009 +0000
==================================================
ArrayELResolver.java
Fix various Eclipse warnings.
Convert tabs to spaces.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@742709 13f79535-47bb-0310-9956-ffa450edef68



==================================================
BeanELResolver.java
index b5b633a794..944349d3b1 100644
--- a/java/javax/el/ArrayELResolver.java
+++ b/java/javax/el/ArrayELResolver.java
@@ -45,10 +45,9 @@ public class ArrayELResolver extends ELResolver {
 			int idx = coerce(property);
             if (idx < 0 || idx >= Array.getLength(base)) {
                 return null;
-            } else {
-                return Array.get(base, idx);
             }
-		}
+            return Array.get(base, idx);
+        }
 
 		return null;
 	}

==================================================
ListELResolver.java
index 8d2369fd46..30db458ff3 100644
--- a/java/javax/el/BeanELResolver.java
+++ b/java/javax/el/BeanELResolver.java
@@ -207,9 +207,9 @@ public class BeanELResolver extends ELResolver {
 	}
 
     protected final static class BeanProperty {
-		private final Class type;
+		private final Class<?> type;
 
-		private final Class owner;
+		private final Class<?> owner;
 
 		private final PropertyDescriptor descriptor;
 
@@ -283,7 +283,7 @@ public class BeanELResolver extends ELResolver {
 		if (m == null || Modifier.isPublic(type.getModifiers())) {
 			return m;
 		}
-		Class[] inf = type.getInterfaces();
+		Class<?>[] inf = type.getInterfaces();
 		Method mp = null;
 		for (int i = 0; i < inf.length; i++) {
 			try {
@@ -293,9 +293,10 @@ public class BeanELResolver extends ELResolver {
 					return mp;
 				}
 			} catch (NoSuchMethodException e) {
+			    // Ignore
 			}
 		}
-		Class sup = type.getSuperclass();
+		Class<?> sup = type.getSuperclass();
 		if (sup != null) {
 			try {
 				mp = sup.getMethod(m.getName(), m.getParameterTypes());
@@ -304,6 +305,7 @@ public class BeanELResolver extends ELResolver {
 					return mp;
 				}
 			} catch (NoSuchMethodException e) {
+			    // Ignore
 			}
 		}
 		return null;

==================================================
GenericServlet.java
index 8de2755a42..ff0259b95c 100644
--- a/java/javax/el/ListELResolver.java
+++ b/java/javax/el/ListELResolver.java
@@ -28,8 +28,8 @@ public class ListELResolver extends ELResolver {
 
 	private final boolean readOnly;
 
-	private final static Class UNMODIFIABLE = Collections.unmodifiableList(
-			new ArrayList()).getClass();
+	private final static Class<? extends List> UNMODIFIABLE =
+	    Collections.unmodifiableList(new ArrayList<Object>()).getClass();
 
 	public ListELResolver() {
 		this.readOnly = false;
@@ -47,7 +47,7 @@ public class ListELResolver extends ELResolver {
 
 		if (base instanceof List) {
 			context.setPropertyResolved(true);
-			List list = (List) base;
+			List<Object> list = (List<Object>) base;
 			int idx = coerce(property);
 			if (idx < 0 || idx >= list.size()) {
 				return null;
@@ -66,7 +66,7 @@ public class ListELResolver extends ELResolver {
 
 		if (base instanceof List) {
 			context.setPropertyResolved(true);
-			List list = (List) base;
+			List<Object> list = (List<Object>) base;
 			int idx = coerce(property);
 			if (idx < 0 || idx >= list.size()) {
 				return null;
@@ -88,7 +88,7 @@ public class ListELResolver extends ELResolver {
 
 		if (base instanceof List) {
 			context.setPropertyResolved(true);
-			List list = (List) base;
+			List<Object> list = (List<Object>) base;
 
 			if (this.readOnly) {
 				throw new PropertyNotWritableException(message(context,
@@ -115,7 +115,7 @@ public class ListELResolver extends ELResolver {
 
 		if (base instanceof List) {
 			context.setPropertyResolved(true);
-			List list = (List) base;
+			List<Object> list = (List<Object>) base;
 			int idx = coerce(property);
 			if (idx < 0 || idx >= list.size()) {
 				throw new PropertyNotFoundException(

==================================================
ServletInputStream.java
index 88410795d1..a9a98360ae 100644
--- a/java/javax/servlet/GenericServlet.java
+++ b/java/javax/servlet/GenericServlet.java
@@ -62,8 +62,9 @@ public abstract class GenericServlet
      * is done by one of the <code>init</code> methods.
      *
      */
-
-    public GenericServlet() { }
+    public GenericServlet() {
+        // NOOP
+    }
     
     
     
@@ -75,6 +76,7 @@ public abstract class GenericServlet
      */
 
     public void destroy() {
+        // NOOP by default
     }
     
     
@@ -234,7 +236,7 @@ public abstract class GenericServlet
      */
     
     public void init() throws ServletException {
-
+        // NOOP by default
     }
     
 

==================================================
ServletOutputStream.java
index a29c8082ef..d004a3a24f 100644
--- a/java/javax/servlet/ServletInputStream.java
+++ b/java/javax/servlet/ServletInputStream.java
@@ -51,8 +51,9 @@ public abstract class ServletInputStream extends InputStream {
      * Does nothing, because this is an abstract class.
      *
      */
-
-    protected ServletInputStream() { }
+    protected ServletInputStream() {
+        // NOOP
+    }
 
   
   

==================================================
SingleThreadModel.java
index c1b7281fe5..82785b365a 100644
--- a/java/javax/servlet/ServletOutputStream.java
+++ b/java/javax/servlet/ServletOutputStream.java
@@ -53,8 +53,9 @@ public abstract class ServletOutputStream extends OutputStream {
      * Does nothing, because this is an abstract class.
      *
      */
-
-    protected ServletOutputStream() { }
+    protected ServletOutputStream() {
+        // NOOP
+    }
 
 
     /**

==================================================
HttpServlet.java
index ea2e92c906..38bb586c19 100644
--- a/java/javax/servlet/SingleThreadModel.java
+++ b/java/javax/servlet/SingleThreadModel.java
@@ -46,4 +46,5 @@ package javax.servlet;
  */
 
 public interface SingleThreadModel {
+    // No methods
 }

==================================================
HttpUtils.java
index 44480de415..c3db362923 100644
--- a/java/javax/servlet/http/HttpServlet.java
+++ b/java/javax/servlet/http/HttpServlet.java
@@ -73,8 +73,7 @@ import javax.servlet.ServletResponse;
  * @author  Various
  * @version $Version$
  */
-public abstract class HttpServlet extends GenericServlet
-    implements java.io.Serializable {
+public abstract class HttpServlet extends GenericServlet {
 
     private static final String METHOD_DELETE = "DELETE";
     private static final String METHOD_HEAD = "HEAD";
@@ -96,7 +95,9 @@ public abstract class HttpServlet extends GenericServlet
     /**
      * Does nothing, because this is an abstract class.
      */
-    public HttpServlet() { }
+    public HttpServlet() {
+        // NOOP
+    }
     
     
     /**
@@ -783,7 +784,9 @@ class NoBodyOutputStream extends ServletOutputStream {
     private int                contentLength = 0;
 
     // file private
-    NoBodyOutputStream() {}
+    NoBodyOutputStream() {
+        // NOOP
+    }
 
     // file private
     int getContentLength() {

==================================================
JspContext.java
index 90d5468248..9ce22de79c 100644
--- a/java/javax/servlet/http/HttpUtils.java
+++ b/java/javax/servlet/http/HttpUtils.java
@@ -24,10 +24,10 @@ import java.util.StringTokenizer;
 import java.io.IOException;
 
 /**
- * @deprecated		As of Java(tm) Servlet API 2.3. 
- *			These methods were only useful
- *			with the default encoding and have been moved
- *			to the request interfaces.
+ * @deprecated            As of Java(tm) Servlet API 2.3. 
+ *                        These methods were only useful
+ *                        with the default encoding and have been moved
+ *                        to the request interfaces.
  *
 */
 
@@ -35,22 +35,19 @@ import java.io.IOException;
 public class HttpUtils {
 
     private static final String LSTRING_FILE =
-	"javax.servlet.http.LocalStrings";
+        "javax.servlet.http.LocalStrings";
     private static ResourceBundle lStrings =
-	ResourceBundle.getBundle(LSTRING_FILE);
+        ResourceBundle.getBundle(LSTRING_FILE);
         
     
-    
     /**
      * Constructs an empty <code>HttpUtils</code> object.
      *
      */
+    public HttpUtils() {
+        // NOOP
+    }
 
-    public HttpUtils() {}
-    
-    
-    
-    
 
     /**
      *
@@ -74,54 +71,51 @@ public class HttpUtils {
      * sent in hexadecimal notation (like <i>%xx</i>) are
      * converted to ASCII characters.
      *
-     * @param s		a string containing the query to be parsed
+     * @param s                a string containing the query to be parsed
      *
-     * @return		a <code>HashTable</code> object built
-     * 			from the parsed key-value pairs
+     * @return                a <code>HashTable</code> object built
+     *                         from the parsed key-value pairs
      *
-     * @exception IllegalArgumentException	if the query string 
-     *						is invalid
+     * @exception IllegalArgumentException        if the query string 
+     *                                                is invalid
      *
      */
-
     static public Hashtable<String,String[]> parseQueryString(String s) {
 
-	String valArray[] = null;
-	
-	if (s == null) {
-	    throw new IllegalArgumentException();
-	}
-	Hashtable<String,String[]> ht = new Hashtable<String,String[]>();
-	StringBuffer sb = new StringBuffer();
-	StringTokenizer st = new StringTokenizer(s, "&");
-	while (st.hasMoreTokens()) {
-	    String pair = st.nextToken();
-	    int pos = pair.indexOf('=');
-	    if (pos == -1) {
-		// XXX
-		// should give more detail about the illegal argument
-		throw new IllegalArgumentException();
-	    }
-	    String key = parseName(pair.substring(0, pos), sb);
-	    String val = parseName(pair.substring(pos+1, pair.length()), sb);
-	    if (ht.containsKey(key)) {
-		String oldVals[] = ht.get(key);
-		valArray = new String[oldVals.length + 1];
-		for (int i = 0; i < oldVals.length; i++) 
-		    valArray[i] = oldVals[i];
-		valArray[oldVals.length] = val;
-	    } else {
-		valArray = new String[1];
-		valArray[0] = val;
-	    }
-	    ht.put(key, valArray);
-	}
-	return ht;
+        String valArray[] = null;
+        
+        if (s == null) {
+            throw new IllegalArgumentException();
+        }
+        Hashtable<String,String[]> ht = new Hashtable<String,String[]>();
+        StringBuffer sb = new StringBuffer();
+        StringTokenizer st = new StringTokenizer(s, "&");
+        while (st.hasMoreTokens()) {
+            String pair = st.nextToken();
+            int pos = pair.indexOf('=');
+            if (pos == -1) {
+                // XXX
+                // should give more detail about the illegal argument
+                throw new IllegalArgumentException();
+            }
+            String key = parseName(pair.substring(0, pos), sb);
+            String val = parseName(pair.substring(pos+1, pair.length()), sb);
+            if (ht.containsKey(key)) {
+                String oldVals[] = ht.get(key);
+                valArray = new String[oldVals.length + 1];
+                for (int i = 0; i < oldVals.length; i++) 
+                    valArray[i] = oldVals[i];
+                valArray[oldVals.length] = val;
+            } else {
+                valArray = new String[1];
+                valArray[0] = val;
+            }
+            ht.put(key, valArray);
+        }
+        return ht;
     }
 
 
-
-
     /**
      *
      * Parses data from an HTML form that the client sends to 
@@ -143,66 +137,58 @@ public class HttpUtils {
      *
      *
      *
-     * @param len	an integer specifying the length,
-     *			in characters, of the 
-     *			<code>ServletInputStream</code>
-     *			object that is also passed to this
-     *			method
+     * @param len        an integer specifying the length,
+     *                        in characters, of the 
+     *                        <code>ServletInputStream</code>
+     *                        object that is also passed to this
+     *                        method
      *
-     * @param in	the <code>ServletInputStream</code>
-     *			object that contains the data sent
-     *			from the client
+     * @param in        the <code>ServletInputStream</code>
+     *                        object that contains the data sent
+     *                        from the client
      * 
-     * @return		a <code>HashTable</code> object built
-     *			from the parsed key-value pairs
+     * @return                a <code>HashTable</code> object built
+     *                        from the parsed key-value pairs
      *
      *
-     * @exception IllegalArgumentException	if the data
-     *			sent by the POST method is invalid
+     * @exception IllegalArgumentException        if the data
+     *                        sent by the POST method is invalid
      *
      */
-     
-
     static public Hashtable<String,String[]> parsePostData(int len, 
-					  ServletInputStream in)
-    {
-	// XXX
-	// should a length of 0 be an IllegalArgumentException
-	
-    // cheap hack to return an empty hash
-	if (len <=0) 
-	    return new Hashtable<String,String[]>();
-
+                                          ServletInputStream in) {
+        // XXX
+        // should a length of 0 be an IllegalArgumentException
+        
+        // cheap hack to return an empty hash
+        if (len <=0) 
+            return new Hashtable<String,String[]>();
 
-	if (in == null) {
-	    throw new IllegalArgumentException();
-	}
-	
-	//
-	// Make sure we read the entire POSTed body.
-	//
+        if (in == null) {
+            throw new IllegalArgumentException();
+        }
+        
+        // Make sure we read the entire POSTed body.
         byte[] postedBytes = new byte [len];
         try {
             int offset = 0;
        
-	    do {
-		int inputLen = in.read (postedBytes, offset, len - offset);
-		if (inputLen <= 0) {
-		    String msg = lStrings.getString("err.io.short_read");
-		    throw new IllegalArgumentException (msg);
-		}
-		offset += inputLen;
-	    } while ((len - offset) > 0);
-
-	} catch (IOException e) {
-	    throw new IllegalArgumentException(e.getMessage());
-	}
+            do {
+                int inputLen = in.read (postedBytes, offset, len - offset);
+                if (inputLen <= 0) {
+                    String msg = lStrings.getString("err.io.short_read");
+                    throw new IllegalArgumentException (msg);
+                }
+                offset += inputLen;
+            } while ((len - offset) > 0);
+
+        } catch (IOException e) {
+            throw new IllegalArgumentException(e.getMessage());
+        }
 
         // XXX we shouldn't assume that the only kind of POST body
         // is FORM data encoded using ASCII or ISO Latin/1 ... or
         // that the body should always be treated as FORM data.
-        //
-
         try {
             String postedBody = new String(postedBytes, 0, len, "8859_1");
             return parseQueryString(postedBody);
@@ -214,48 +200,43 @@ public class HttpUtils {
     }
 
 
-
-
     /*
      * Parse a name in the query string.
      */
-
     static private String parseName(String s, StringBuffer sb) {
-	sb.setLength(0);
-	for (int i = 0; i < s.length(); i++) {
-	    char c = s.charAt(i); 
-	    switch (c) {
-	    case '+':
-		sb.append(' ');
-		break;
-	    case '%':
-		try {
-		    sb.append((char) Integer.parseInt(s.substring(i+1, i+3), 
-						      16));
-		    i += 2;
-		} catch (NumberFormatException e) {
-		    // XXX
-		    // need to be more specific about illegal arg
-		    throw new IllegalArgumentException();
-		} catch (StringIndexOutOfBoundsException e) {
-		    String rest  = s.substring(i);
-		    sb.append(rest);
-		    if (rest.length()==2)
-			i++;
-		}
-		
-		break;
-	    default:
-		sb.append(c);
-		break;
-	    }
-	}
-	return sb.toString();
+        sb.setLength(0);
+        for (int i = 0; i < s.length(); i++) {
+            char c = s.charAt(i); 
+            switch (c) {
+            case '+':
+                sb.append(' ');
+                break;
+            case '%':
+                try {
+                    sb.append((char) Integer.parseInt(s.substring(i+1, i+3), 
+                                                      16));
+                    i += 2;
+                } catch (NumberFormatException e) {
+                    // XXX
+                    // need to be more specific about illegal arg
+                    throw new IllegalArgumentException();
+                } catch (StringIndexOutOfBoundsException e) {
+                    String rest  = s.substring(i);
+                    sb.append(rest);
+                    if (rest.length()==2)
+                        i++;
+                }
+                
+                break;
+            default:
+                sb.append(c);
+                break;
+            }
+        }
+        return sb.toString();
     }
 
 
-
-
     /**
      *
      * Reconstructs the URL the client used to make the request,
@@ -271,37 +252,30 @@ public class HttpUtils {
      * <p>This method is useful for creating redirect messages
      * and for reporting errors.
      *
-     * @param req	a <code>HttpServletRequest</code> object
-     *			containing the client's request
+     * @param req        a <code>HttpServletRequest</code> object
+     *                        containing the client's request
      * 
-     * @return		a <code>StringBuffer</code> object containing
-     *			the reconstructed URL
+     * @return                a <code>StringBuffer</code> object containing
+     *                        the reconstructed URL
      *
      */
-
     public static StringBuffer getRequestURL (HttpServletRequest req) {
-	StringBuffer url = new StringBuffer ();
-	String scheme = req.getScheme ();
-	int port = req.getServerPort ();
-	String urlPath = req.getRequestURI();
-	
-	//String		servletPath = req.getServletPath ();
-	//String		pathInfo = req.getPathInfo ();
+        StringBuffer url = new StringBuffer ();
+        String scheme = req.getScheme ();
+        int port = req.getServerPort ();
+        String urlPath = req.getRequestURI();
+        
+        url.append (scheme);                // http, https
+        url.append ("://");
+        url.append (req.getServerName ());
+        if ((scheme.equals ("http") && port != 80)
+                || (scheme.equals ("https") && port != 443)) {
+            url.append (':');
+            url.append (req.getServerPort ());
+        }
 
-	url.append (scheme);		// http, https
-	url.append ("://");
-	url.append (req.getServerName ());
-	if ((scheme.equals ("http") && port != 80)
-		|| (scheme.equals ("https") && port != 443)) {
-	    url.append (':');
-	    url.append (req.getServerPort ());
-	}
-	//if (servletPath != null)
-	//    url.append (servletPath);
-	//if (pathInfo != null)
-	//    url.append (pathInfo);
-	url.append(urlPath);
-	return url;
+        url.append(urlPath);
+        return url;
     }
 }
 

==================================================
JspEngineInfo.java
index 8b19b4fd3f..6dc94aaa1c 100644
--- a/java/javax/servlet/jsp/JspContext.java
+++ b/java/javax/servlet/jsp/JspContext.java
@@ -76,6 +76,7 @@ public abstract class JspContext {
      * typically implicit.)
      */
     public JspContext() {
+        // NOOP by default
     }
     
     /** 

==================================================
JspException.java
index 0c6ca67b0b..b07a0a3252 100644
--- a/java/javax/servlet/jsp/JspEngineInfo.java
+++ b/java/javax/servlet/jsp/JspEngineInfo.java
@@ -28,6 +28,7 @@ public abstract class JspEngineInfo {
      * typically implicit.)
      */
     public JspEngineInfo() {
+        // NOOP by default
     }
     
     /**

==================================================
JspFactory.java
index e8a4d629b8..61ef15d485 100644
--- a/java/javax/servlet/jsp/JspException.java
+++ b/java/javax/servlet/jsp/JspException.java
@@ -28,6 +28,7 @@ public class JspException extends Exception {
      * Construct a JspException.
      */
     public JspException() {
+        // NOOP
     }
 
 

==================================================
PageContext.java
index 2fe511f4cb..dfd66ae194 100644
--- a/java/javax/servlet/jsp/JspFactory.java
+++ b/java/javax/servlet/jsp/JspFactory.java
@@ -50,6 +50,7 @@ public abstract class JspFactory {
      * typically implicit.)
      */
     public JspFactory() {
+        // NOOP by default
     }
 
     /**

==================================================
BodyTagSupport.java
index d83f463c2b..68d71cb59e 100644
--- a/java/javax/servlet/jsp/PageContext.java
+++ b/java/javax/servlet/jsp/PageContext.java
@@ -100,6 +100,7 @@ abstract public class PageContext
      * typically implicit.)
      */
     public PageContext() {
+        // NOOP by default
     }
     
     /**

==================================================
JspTag.java
index 31022e88aa..0797831fe4 100644
--- a/java/javax/servlet/jsp/tagext/BodyTagSupport.java
+++ b/java/javax/servlet/jsp/tagext/BodyTagSupport.java
@@ -100,6 +100,7 @@ public class BodyTagSupport extends TagSupport implements BodyTag {
      */
 
     public void doInitBody() throws JspException {
+        // NOOP by default
     }
 
 

==================================================
PageData.java
index 81cdd69475..3c8d138d7b 100644
--- a/java/javax/servlet/jsp/tagext/JspTag.java
+++ b/java/javax/servlet/jsp/tagext/JspTag.java
@@ -23,4 +23,5 @@ package javax.servlet.jsp.tagext;
  * @since 2.0
  */
 public interface JspTag {
+    // No methods even through there are some common methods
 }

==================================================
SimpleTagSupport.java
index 77c6f63548..0cf5ca906f 100644
--- a/java/javax/servlet/jsp/tagext/PageData.java
+++ b/java/javax/servlet/jsp/tagext/PageData.java
@@ -36,6 +36,7 @@ abstract public class PageData {
      * typically implicit.)
      */
     public PageData() {
+        // NOOP by default
     }
     
     /**

==================================================
Tag.java
index 6f5559926c..3132acadd3 100644
--- a/java/javax/servlet/jsp/tagext/SimpleTagSupport.java
+++ b/java/javax/servlet/jsp/tagext/SimpleTagSupport.java
@@ -31,9 +31,7 @@ import java.io.IOException;
  *
  * @since 2.0
  */
-public class SimpleTagSupport 
-    implements SimpleTag
-{
+public class SimpleTagSupport implements SimpleTag {
     /** Reference to the enclosing tag. */
     private JspTag parentTag;
     
@@ -48,6 +46,7 @@ public class SimpleTagSupport
      * typically implicit.)
      */
     public SimpleTagSupport() {
+        // NOOP by default
     }
     
     /** 
@@ -66,9 +65,8 @@ public class SimpleTagSupport
      *     an error writing to the output stream
      * @see SimpleTag#doTag()
      */ 
-    public void doTag() 
-        throws JspException, IOException
-    {
+    public void doTag() throws JspException, IOException {
+        // NOOP by default
     }
     
     /**
@@ -176,38 +174,38 @@ public class SimpleTagSupport
      * or is an instance of the class specified
      */
     public static final JspTag findAncestorWithClass(
-	JspTag from, Class<?> klass) 
+        JspTag from, Class<?> klass) 
     {
-	boolean isInterface = false;
+        boolean isInterface = false;
 
-	if (from == null || klass == null
-	        || (!JspTag.class.isAssignableFrom(klass)
-		    && !(isInterface = klass.isInterface()))) {
-	    return null;
-	}
+        if (from == null || klass == null
+                || (!JspTag.class.isAssignableFrom(klass)
+                    && !(isInterface = klass.isInterface()))) {
+            return null;
+        }
 
-	for (;;) {
-	    JspTag parent = null;
-	    if( from instanceof SimpleTag ) {
-		parent = ((SimpleTag)from).getParent();
-	    }
-	    else if( from instanceof Tag ) {
-		parent = ((Tag)from).getParent();
-	    }
-	    if (parent == null) {
-		return null;
-	    }
+        for (;;) {
+            JspTag parent = null;
+            if( from instanceof SimpleTag ) {
+                parent = ((SimpleTag)from).getParent();
+            }
+            else if( from instanceof Tag ) {
+                parent = ((Tag)from).getParent();
+            }
+            if (parent == null) {
+                return null;
+            }
 
-	    if (parent instanceof TagAdapter) {
-		parent = ((TagAdapter) parent).getAdaptee();
-	    }
+            if (parent instanceof TagAdapter) {
+                parent = ((TagAdapter) parent).getAdaptee();
+            }
 
-	    if ((isInterface && klass.isInstance(parent))
-		    || klass.isAssignableFrom(parent.getClass())) {
-		return parent;
-	    }
+            if ((isInterface && klass.isInstance(parent))
+                    || klass.isAssignableFrom(parent.getClass())) {
+                return parent;
+            }
 
-	    from = parent;
-	}
+            from = parent;
+        }
     }    
 }

==================================================
TagData.java
index 0dd3d57ff9..449d72631a 100644
--- a/java/javax/servlet/jsp/tagext/Tag.java
+++ b/java/javax/servlet/jsp/tagext/Tag.java
@@ -162,12 +162,12 @@ public interface Tag extends JspTag {
      * The current version of the specification only provides one formal
      * way of indicating the observable type of a tag handler: its
      * tag handler implementation class, described in the tag-class
-     * subelement of the tag element.  This is extended in an
+     * sub-element of the tag element.  This is extended in an
      * informal manner by allowing the tag library author to
-     * indicate in the description subelement an observable type.
-     * The type should be a subtype of the tag handler implementation
+     * indicate in the description sub-element an observable type.
+     * The type should be a sub-type of the tag handler implementation
      * class or void.
-     * This addititional constraint can be exploited by a
+     * This additional constraint can be exploited by a
      * specialized container that knows about that specific tag library,
      * as in the case of the JSP standard tag library.
      *

==================================================
TagExtraInfo.java
index 1a061a077e..50dd887215 100644
--- a/java/javax/servlet/jsp/tagext/TagData.java
+++ b/java/javax/servlet/jsp/tagext/TagData.java
@@ -55,17 +55,17 @@ public class TagData implements Cloneable {
      * @param atts the static attribute and values.  May be null.
      */
     public TagData(Object[] atts[]) {
-	if (atts == null) {
-	    attributes = new Hashtable<String, Object>();
-	} else {
-	    attributes = new Hashtable<String, Object>(atts.length);
-	}
-
-	if (atts != null) {
-	    for (int i = 0; i < atts.length; i++) {
-		attributes.put((String) atts[i][0], atts[i][1]);
-	    }
-	}
+        if (atts == null) {
+            attributes = new Hashtable<String, Object>();
+        } else {
+            attributes = new Hashtable<String, Object>(atts.length);
+        }
+
+        if (atts != null) {
+            for (int i = 0; i < atts.length; i++) {
+                attributes.put((String) atts[i][0], atts[i][1]);
+            }
+        }
     }
 
     /**
@@ -88,7 +88,7 @@ public class TagData implements Cloneable {
      */
 
     public String getId() {
-	return getAttributeString(TagAttributeInfo.ID);
+        return getAttributeString(TagAttributeInfo.ID);
     }
 
     /**
@@ -108,7 +108,7 @@ public class TagData implements Cloneable {
      */
 
     public Object getAttribute(String attName) {
-	return attributes.get(attName);
+        return attributes.get(attName);
     }
 
     /**
@@ -118,8 +118,8 @@ public class TagData implements Cloneable {
      * @param value the value.
      */
     public void setAttribute(String attName,
-			     Object value) {
-	attributes.put(attName, value);
+                             Object value) {
+        attributes.put(attName, value);
     }
 
     /**
@@ -131,12 +131,11 @@ public class TagData implements Cloneable {
      */
 
     public String getAttributeString(String attName) {
-	Object o = attributes.get(attName);
-	if (o == null) {
-	    return null;
-	} else {
-	    return (String) o;
-	}	
+        Object o = attributes.get(attName);
+        if (o == null) {
+            return null;
+        }
+        return (String) o;
     }
 
     /**
@@ -150,5 +149,5 @@ public class TagData implements Cloneable {
 
     // private data
 
-    private Hashtable<String, Object> attributes;	// the tagname/value map
+    private Hashtable<String, Object> attributes;        // the tagname/value map
 }

==================================================
TagLibraryValidator.java
index 6a50f5dd7b..371d46571b 100644
--- a/java/javax/servlet/jsp/tagext/TagExtraInfo.java
+++ b/java/javax/servlet/jsp/tagext/TagExtraInfo.java
@@ -59,6 +59,7 @@ public abstract class TagExtraInfo {
      * typically implicit.)
      */
     public TagExtraInfo() {
+        // NOOP by default
     }
     
     /**
@@ -71,7 +72,7 @@ public abstract class TagExtraInfo {
      *         if no scripting variables are to be defined.
      */
     public VariableInfo[] getVariableInfo(TagData data) {
-	return ZERO_VARIABLE_INFO;
+        return ZERO_VARIABLE_INFO;
     }
 
     /**
@@ -86,7 +87,7 @@ public abstract class TagExtraInfo {
      */
 
     public boolean isValid(TagData data) {
-	return true;
+        return true;
     }
 
     /**
@@ -107,14 +108,14 @@ public abstract class TagExtraInfo {
      * @since 2.0
      */
     public ValidationMessage[] validate( TagData data ) {
-	ValidationMessage[] result = null;
+        ValidationMessage[] result = null;
 
-	if( !isValid( data ) ) {
-	    result = new ValidationMessage[] {
-		new ValidationMessage( data.getId(), "isValid() == false" ) };
-	}
+        if( !isValid( data ) ) {
+            result = new ValidationMessage[] {
+                new ValidationMessage( data.getId(), "isValid() == false" ) };
+        }
 
-	return result;
+        return result;
     }
 
     /**
@@ -123,7 +124,7 @@ public abstract class TagExtraInfo {
      * @param tagInfo The TagInfo this instance is extending
      */
     public final void setTagInfo(TagInfo tagInfo) {
-	this.tagInfo = tagInfo;
+        this.tagInfo = tagInfo;
     }
 
     /**
@@ -132,7 +133,7 @@ public abstract class TagExtraInfo {
      * @return the taginfo instance this instance is extending
      */
     public final TagInfo getTagInfo() {
-	return tagInfo;
+        return tagInfo;
     }
     
     // private data

==================================================
TagSupport.java
index a11b125c6f..e98909c684 100644
--- a/java/javax/servlet/jsp/tagext/TagLibraryValidator.java
+++ b/java/javax/servlet/jsp/tagext/TagLibraryValidator.java
@@ -87,6 +87,7 @@ abstract public class TagLibraryValidator {
      * typically implicit.)
      */
     public TagLibraryValidator() {
+        // NOOP by default
     }
     
     /**
@@ -96,7 +97,7 @@ abstract public class TagLibraryValidator {
      * @param map A Map describing the init parameters
      */
     public void setInitParameters(Map<String, Object> map) {
-	initParameters = map;
+        initParameters = map;
     }
 
 
@@ -107,7 +108,7 @@ abstract public class TagLibraryValidator {
      * @return The init parameters as an immutable map.
      */
     public Map<String, Object> getInitParameters() {
-	return initParameters;
+        return initParameters;
     }
 
     /**
@@ -126,16 +127,15 @@ abstract public class TagLibraryValidator {
      * of ValidationMessages otherwise.
      */
     public ValidationMessage[] validate(String prefix, String uri, 
-        PageData page) 
-    {
-	return null;
+        PageData page) {
+        return null;
     }
 
     /**
      * Release any data kept by this instance for validation purposes.
      */
     public void release() {
-	initParameters = null;
+        initParameters = null;
     }
 
     // Private data

==================================================
