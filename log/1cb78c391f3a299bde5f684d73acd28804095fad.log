1cb78c391f3a299bde5f684d73acd28804095fad
==================================================
Removed commented out code / unused classes.
==================================================
Mark Emlyn
==================================================
Sat Mar 28 18:25:29 2009 +0000
==================================================
B2CConverter.java
Removed commented out code / unused classes.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@759544 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Base64.java
index c71e06b7a1..b7dabfce74 100644
--- a/java/org/apache/tomcat/util/buf/B2CConverter.java
+++ b/java/org/apache/tomcat/util/buf/B2CConverter.java
@@ -112,60 +112,6 @@ public class B2CConverter {
             log.debug("B2CConverter: " + s );
     }
 
-    // -------------------- Not used - the speed improvemnt is quite small
-
-    /*
-    private Hashtable decoders;
-    public static final boolean useNewString=false;
-    public static final boolean useSpecialDecoders=true;
-    private UTF8Decoder utfD;
-    // private char[] conversionBuff;
-    CharChunk conversionBuf;
-
-
-    private  static String decodeString(ByteChunk mb, String enc)
-        throws IOException
-    {
-        byte buff=mb.getBuffer();
-        int start=mb.getStart();
-        int end=mb.getEnd();
-        if( useNewString ) {
-            if( enc==null) enc="UTF8";
-            return new String( buff, start, end-start, enc );
-        }
-        B2CConverter b2c=null;
-        if( useSpecialDecoders &&
-            (enc==null || "UTF8".equalsIgnoreCase(enc))) {
-            if( utfD==null ) utfD=new UTF8Decoder();
-            b2c=utfD;
-        }
-        if(decoders == null ) decoders=new Hashtable();
-        if( enc==null ) enc="UTF8";
-        b2c=(B2CConverter)decoders.get( enc );
-        if( b2c==null ) {
-            if( useSpecialDecoders ) {
-                if( "UTF8".equalsIgnoreCase( enc ) ) {
-                    b2c=new UTF8Decoder();
-                }
-            }
-            if( b2c==null )
-                b2c=new B2CConverter( enc );
-            decoders.put( enc, b2c );
-        }
-        if( conversionBuf==null ) conversionBuf=new CharChunk(1024);
-
-        try {
-            conversionBuf.recycle();
-            b2c.convert( this, conversionBuf );
-            //System.out.println("XXX 1 " + conversionBuf );
-            return conversionBuf.toString();
-        } catch( IOException ex ) {
-            ex.printStackTrace();
-            return null;
-        }
-    }
-
-    */
 }
 
 // -------------------- Private implementation --------------------

==================================================
TimeStamp.java
deleted file mode 100644
index 49dc6a15b6..0000000000
--- a/java/org/apache/tomcat/util/buf/Base64.java
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-
-package org.apache.tomcat.util.buf;
-
-
-/**
- * This class provides encode/decode for RFC 2045 Base64 as
- * defined by RFC 2045, N. Freed and N. Borenstein.
- * RFC 2045: Multipurpose Internet Mail Extensions (MIME)
- * Part One: Format of Internet Message Bodies. Reference
- * 1996 Available at: http://www.ietf.org/rfc/rfc2045.txt
- * This class is used by XML Schema binary format validation
- *
- * @author Jeffrey Rodriguez
- * @version $Revision$ $Date$
- */
-
-public final class Base64 {
-
-
-    private static org.apache.juli.logging.Log log=
-        org.apache.juli.logging.LogFactory.getLog( Base64.class );
-    
-    static private final int  BASELENGTH         = 255;
-    static private final int  LOOKUPLENGTH       = 63;
-    static private final int  TWENTYFOURBITGROUP = 24;
-    static private final int  EIGHTBIT           = 8;
-    static private final int  SIXTEENBIT         = 16;
-    static private final int  FOURBYTE           = 4;
-
-
-    static private final byte PAD               = ( byte ) '=';
-    static private byte [] base64Alphabet       = new byte[BASELENGTH];
-    static private byte [] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];
-
-    static {
-
-        for (int i = 0; i<BASELENGTH; i++ ) {
-            base64Alphabet[i] = -1;
-        }
-        for ( int i = 'Z'; i >= 'A'; i-- ) {
-            base64Alphabet[i] = (byte) (i-'A');
-        }
-        for ( int i = 'z'; i>= 'a'; i--) {
-            base64Alphabet[i] = (byte) ( i-'a' + 26);
-        }
-
-        for ( int i = '9'; i >= '0'; i--) {
-            base64Alphabet[i] = (byte) (i-'0' + 52);
-        }
-
-        base64Alphabet['+']  = 62;
-        base64Alphabet['/']  = 63;
-
-       for (int i = 0; i<=25; i++ )
-            lookUpBase64Alphabet[i] = (byte) ('A'+i );
-
-        for (int i = 26,  j = 0; i<=51; i++, j++ )
-            lookUpBase64Alphabet[i] = (byte) ('a'+ j );
-
-        for (int i = 52,  j = 0; i<=61; i++, j++ )
-            lookUpBase64Alphabet[i] = (byte) ('0' + j );
-
-    }
-
-
-    static boolean isBase64( byte octect ) {
-        //shall we ignore white space? JEFF??
-        return(octect == PAD || base64Alphabet[octect] != -1 );
-    }
-
-
-    static boolean isArrayByteBase64( byte[] arrayOctect ) {
-        int length = arrayOctect.length;
-        if ( length == 0 )
-            return false;
-        for ( int i=0; i < length; i++ ) {
-            if ( Base64.isBase64( arrayOctect[i] ) == false)
-                return false;
-        }
-        return true;
-    }
-
-    /**
-     * Encodes hex octects into Base64
-     *
-     * @param binaryData Array containing binaryData
-     * @return Encoded Base64 array
-     */
-    public static byte[] encode( byte[] binaryData ) {
-        int      lengthDataBits    = binaryData.length*EIGHTBIT;
-        int      fewerThan24bits   = lengthDataBits%TWENTYFOURBITGROUP;
-        int      numberTriplets    = lengthDataBits/TWENTYFOURBITGROUP;
-        byte     encodedData[]     = null;
-
-
-        if ( fewerThan24bits != 0 ) //data not divisible by 24 bit
-            encodedData = new byte[ (numberTriplets + 1 )*4  ];
-        else // 16 or 8 bit
-            encodedData = new byte[ numberTriplets*4 ];
-
-        byte k=0, l=0, b1=0,b2=0,b3=0;
-
-        int encodedIndex = 0;
-        int dataIndex   = 0;
-        int i           = 0;
-        for ( i = 0; i<numberTriplets; i++ ) {
-
-            dataIndex = i*3;
-            b1 = binaryData[dataIndex];
-            b2 = binaryData[dataIndex + 1];
-            b3 = binaryData[dataIndex + 2];
-
-            l  = (byte)(b2 & 0x0f);
-            k  = (byte)(b1 & 0x03);
-
-            encodedIndex = i*4;
-            encodedData[encodedIndex]   = lookUpBase64Alphabet[ b1 >>2 ];
-            encodedData[encodedIndex+1] = lookUpBase64Alphabet[(b2 >>4 ) |
-( k<<4 )];
-            encodedData[encodedIndex+2] = lookUpBase64Alphabet[ (l <<2 ) |
-( b3>>6)];
-            encodedData[encodedIndex+3] = lookUpBase64Alphabet[ b3 & 0x3f ];
-        }
-
-        // form integral number of 6-bit groups
-        dataIndex    = i*3;
-        encodedIndex = i*4;
-        if (fewerThan24bits == EIGHTBIT ) {
-            b1 = binaryData[dataIndex];
-            k = (byte) ( b1 &0x03 );
-            encodedData[encodedIndex]     = lookUpBase64Alphabet[ b1 >>2 ];
-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[ k<<4 ];
-            encodedData[encodedIndex + 2] = PAD;
-            encodedData[encodedIndex + 3] = PAD;
-        } else if ( fewerThan24bits == SIXTEENBIT ) {
-
-            b1 = binaryData[dataIndex];
-            b2 = binaryData[dataIndex +1 ];
-            l = ( byte ) ( b2 &0x0f );
-            k = ( byte ) ( b1 &0x03 );
-            encodedData[encodedIndex]     = lookUpBase64Alphabet[ b1 >>2 ];
-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[ (b2 >>4 )
-| ( k<<4 )];
-            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[ l<<2 ];
-            encodedData[encodedIndex + 3] = PAD;
-        }
-        return encodedData;
-    }
-
-
-    /**
-     * Decodes Base64 data into octects
-     *
-     * @param base64Data Byte array containing Base64 data
-     * @return Array containind decoded data.
-     */
-    public byte[] decode( byte[] base64Data ) {
-        int      numberQuadruple    = base64Data.length/FOURBYTE;
-        byte     decodedData[]      = null;
-        byte     b1=0,b2=0,b3=0, b4=0, marker0=0, marker1=0;
-
-        // Throw away anything not in base64Data
-        // Adjust size
-
-        int encodedIndex = 0;
-        int dataIndex    = 0;
-        decodedData      = new byte[ numberQuadruple*3 + 1 ];
-
-        for (int i = 0; i<numberQuadruple; i++ ) {
-            dataIndex = i*4;
-            marker0   = base64Data[dataIndex +2];
-            marker1   = base64Data[dataIndex +3];
-
-            b1 = base64Alphabet[base64Data[dataIndex]];
-            b2 = base64Alphabet[base64Data[dataIndex +1]];
-
-            if ( marker0 != PAD && marker1 != PAD ) {     //No PAD e.g 3cQl
-                b3 = base64Alphabet[ marker0 ];
-                b4 = base64Alphabet[ marker1 ];
-
-                decodedData[encodedIndex]   = (byte)(  b1 <<2 | b2>>4 ) ;
-                decodedData[encodedIndex+1] = (byte)(((b2 & 0xf)<<4 ) |(
-(b3>>2) & 0xf) );
-                decodedData[encodedIndex+2] = (byte)( b3<<6 | b4 );
-            } else if ( marker0 == PAD ) {               //Two PAD e.g. 3c[Pad][Pad]
-                decodedData[encodedIndex]   = (byte)(  b1 <<2 | b2>>4 ) ;
-                decodedData[encodedIndex+1] = (byte)((b2 & 0xf)<<4 );
-                decodedData[encodedIndex+2] = (byte) 0;
-            } else if ( marker1 == PAD ) {              //One PAD e.g. 3cQ[Pad]
-                b3 = base64Alphabet[ marker0 ];
-
-                decodedData[encodedIndex]   = (byte)(  b1 <<2 | b2>>4 );
-                decodedData[encodedIndex+1] = (byte)(((b2 & 0xf)<<4 ) |(
-(b3>>2) & 0xf) );
-                decodedData[encodedIndex+2] = (byte)( b3<<6);
-            }
-            encodedIndex += 3;
-        }
-        return decodedData;
-
-    }
-
-    static final int base64[]= {
-	64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
-	    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
-	    64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
-	    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
-	    64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-	    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
-	    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
-	    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64
-    };
-
-    public static String base64Decode( String orig ) {
-	char chars[]=orig.toCharArray();
-	StringBuffer sb=new StringBuffer();
-	int i=0;
-
-	int shift = 0;   // # of excess bits stored in accum
-	int acc = 0;
-	
-	for (i=0; i<chars.length; i++) {
-	    int v = base64[ chars[i] & 0xFF ];
-	    
-	    if ( v >= 64 ) {
-		if( chars[i] != '=' )
-                    if (log.isDebugEnabled())
-                        log.debug("Wrong char in base64: " + chars[i]);
-	    } else {
-		acc= ( acc << 6 ) | v;
-		shift += 6;
-		if ( shift >= 8 ) {
-		    shift -= 8;
-		    sb.append( (char) ((acc >> shift) & 0xff));
-		}
-	    }
-	}
-	return sb.toString();
-    }
-
-
-}
-

==================================================
UTF8Decoder.java
deleted file mode 100644
index a7315d79bd..0000000000
--- a/java/org/apache/tomcat/util/buf/TimeStamp.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.util.buf;
-
-import java.io.Serializable;
-
-// XXX Shouldn't be here - has nothing to do with buffers.
-
-/**
- * Main tool for object expiry. 
- * Marks creation and access time of an "expirable" object,
- * and extra properties like "id", "valid", etc.
- *
- * Used for objects that expire - originally Sessions, but 
- * also Contexts, Servlets, cache - or any other object that
- * expires.
- * 
- * @author Costin Manolache
- */
-public final class TimeStamp implements  Serializable {
-    private long creationTime = 0L;
-    private long lastAccessedTime = creationTime;
-    private long thisAccessedTime = creationTime;
-    private boolean isNew = true;
-    private long maxInactiveInterval = -1;
-    private boolean isValid = false;
-    MessageBytes name;
-    int id=-1;
-    
-    Object parent;
-    
-    public TimeStamp() {
-    }
-
-    // -------------------- Active methods --------------------
-
-    /**
-     *  Access notification. This method takes a time parameter in order
-     *  to allow callers to efficiently manage expensive calls to
-     *  System.currentTimeMillis() 
-     */
-    public void touch(long time) {
-	this.lastAccessedTime = this.thisAccessedTime;
-	this.thisAccessedTime = time;
-	this.isNew=false;
-    }
-
-    // -------------------- Property access --------------------
-
-    /** Return the "name" of the timestamp. This can be used
-     *  to associate unique identifier with each timestamped object.
-     *  The name is a MessageBytes - i.e. a modifiable byte[] or char[]. 
-     */
-    public MessageBytes getName() {
-	if( name==null ) name=MessageBytes.newInstance();//lazy
-	return name;
-    }
-
-    /** Each object can have an unique id, similar with name but
-     *  providing faster access ( array vs. hashtable lookup )
-     */
-    public int getId() {
-	return id;
-    }
-
-    public void setId( int id ) {
-	this.id=id;
-    }
-    
-    /** Returns the owner of this stamp ( the object that is
-     *  time-stamped ).
-     *  For a 
-     */
-    public void setParent( Object o ) {
-	parent=o;
-    }
-
-    public Object getParent() {
-	return parent;
-    }
-
-    public void setCreationTime(long time) {
-	this.creationTime = time;
-	this.lastAccessedTime = time;
-	this.thisAccessedTime = time;
-    }
-
-
-    public long getLastAccessedTime() {
-	return lastAccessedTime;
-    }
-
-    public long getThisAccessedTime() {
-        return thisAccessedTime;
-    }
-
-    /** Inactive interval in millis - the time is computed
-     *  in millis, convert to secs in the upper layer
-     */
-    public long getMaxInactiveInterval() {
-	return maxInactiveInterval;
-    }
-
-    public void setMaxInactiveInterval(long interval) {
-	maxInactiveInterval = interval;
-    }
-
-    public boolean isValid() {
-	return isValid;
-    }
-
-    public void setValid(boolean isValid) {
-	this.isValid = isValid;
-    }
-
-    public boolean isNew() {
-	return isNew;
-    }
-
-    public void setNew(boolean isNew) {
-	this.isNew = isNew;
-    }
-
-    public long getCreationTime() {
-	return creationTime;
-    }
-
-    // -------------------- Maintainance --------------------
-
-    public void recycle() {
-	creationTime = 0L;
-	lastAccessedTime = 0L;
-	maxInactiveInterval = -1;
-	isNew = true;
-	isValid = false;
-	id=-1;
-	if( name!=null) name.recycle();
-    }
-
-}
-

==================================================
