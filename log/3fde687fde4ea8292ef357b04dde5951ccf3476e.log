3fde687fde4ea8292ef357b04dde5951ccf3476e
==================================================
Pull up asyncDispatch()
==================================================
Mark Emlyn
==================================================
Thu Jul 7 21:57:13 2011 +0000
==================================================
AbstractHttp11Processor.java
Pull up asyncDispatch()

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1144067 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http11AprProcessor.java
index c1aa4b0e9a..9f7818f560 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Processor.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Processor.java
@@ -17,6 +17,7 @@
 package org.apache.coyote.http11;
 
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.util.Locale;
 import java.util.StringTokenizer;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -25,6 +26,7 @@ import java.util.regex.Pattern;
 import org.apache.coyote.AbstractProcessor;
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.AsyncContextCallback;
+import org.apache.coyote.RequestInfo;
 import org.apache.coyote.http11.filters.BufferedInputFilter;
 import org.apache.coyote.http11.filters.ChunkedInputFilter;
 import org.apache.coyote.http11.filters.ChunkedOutputFilter;
@@ -43,6 +45,8 @@ import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.http.FastHttpDateFormat;
 import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.net.AbstractEndpoint;
+import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
+import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.res.StringManager;
 
 public abstract class AbstractHttp11Processor extends AbstractProcessor {
@@ -1200,6 +1204,52 @@ public abstract class AbstractHttp11Processor extends AbstractProcessor {
 
     }
 
+    
+    public SocketState asyncDispatch(SocketStatus status) {
+
+        RequestInfo rp = request.getRequestProcessor();
+        try {
+            rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
+            error = !adapter.asyncDispatch(request, response, status);
+            resetTimeouts();
+        } catch (InterruptedIOException e) {
+            error = true;
+        } catch (Throwable t) {
+            ExceptionUtils.handleThrowable(t);
+            getLog().error(sm.getString("http11processor.request.process"), t);
+            error = true;
+        } finally {
+            if (error) {
+                // 500 - Internal Server Error
+                response.setStatus(500);
+                adapter.log(request, response, 0);
+            }
+        }
+
+        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
+
+        if (error) {
+            return SocketState.CLOSED;
+        } else if (isAsync()) {
+            return SocketState.LONG;
+        } else {
+            if (!keepAlive) {
+                return SocketState.CLOSED;
+            } else {
+                return SocketState.OPEN;
+            }
+        }
+    }
+
+
+    /**
+     * Provides a mechanism for those connector implementations (currently only
+     * NIO) that need to reset timeouts from Async timeouts to standard HTTP
+     * timeouts once async processing completes.
+     */
+    protected abstract void resetTimeouts();
+
+
     public void endRequest() {
 
         // Finish the handling of the request

==================================================
Http11NioProcessor.java
index 257977cd1c..fa87c0fc93 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -339,39 +339,9 @@ public class Http11AprProcessor extends AbstractHttp11Processor {
     }
 
 
-    public SocketState asyncDispatch(SocketStatus status) {
-
-        RequestInfo rp = request.getRequestProcessor();
-        try {
-            rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
-            error = !adapter.asyncDispatch(request, response, status);
-        } catch (InterruptedIOException e) {
-            error = true;
-        } catch (Throwable t) {
-            ExceptionUtils.handleThrowable(t);
-            log.error(sm.getString("http11processor.request.process"), t);
-            error = true;
-        } finally {
-            if (error) {
-                // 500 - Internal Server Error
-                response.setStatus(500);
-                adapter.log(request, response, 0);
-            }
-        }
-
-        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
-
-        if (error) {
-            return SocketState.CLOSED;
-        } else if (isAsync()) {
-            return SocketState.LONG;
-        } else {
-            if (!keepAlive) {
-                return SocketState.CLOSED;
-            } else {
-                return SocketState.OPEN;
-            }
-        }
+    @Override
+    protected void resetTimeouts() {
+        // NOOP for APR
     }
 
 

==================================================
Http11Processor.java
index f857f0d51b..f9ef4eaeae 100644
--- a/java/org/apache/coyote/http11/Http11NioProcessor.java
+++ b/java/org/apache/coyote/http11/Http11NioProcessor.java
@@ -173,59 +173,25 @@ public class Http11NioProcessor extends AbstractHttp11Processor {
         }
     }
     
-    
-    /**
-     * Process pipelined HTTP requests using the specified input and output
-     * streams.
-     */
-    public SocketState asyncDispatch(SocketStatus status) {
 
-        RequestInfo rp = request.getRequestProcessor();
+    @Override
+    protected void resetTimeouts() {
         final NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socket.getAttachment(false);
-        try {
-            rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
-            error = !adapter.asyncDispatch(request, response, status);
-            if (!error && attach != null &&
-                    asyncStateMachine.isAsyncDispatching()) {
-                long soTimeout = endpoint.getSoTimeout();
-                int keepAliveTimeout = endpoint.getKeepAliveTimeout();
-
-                //reset the timeout
-                if (keepAlive && keepAliveTimeout>0) {
-                    attach.setTimeout(keepAliveTimeout);
-                } else {
-                    attach.setTimeout(soTimeout);
-                }
-            }
-        } catch (InterruptedIOException e) {
-            error = true;
-        } catch (Throwable t) {
-            ExceptionUtils.handleThrowable(t);
-            log.error(sm.getString("http11processor.request.process"), t);
-            error = true;
-        } finally {
-            if (error) {
-                // 500 - Internal Server Error
-                response.setStatus(500);
-                adapter.log(request, response, 0);
-            }
-        }
-
-        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
-
-        if (error) {
-            return SocketState.CLOSED;
-        } else if (isAsync()) {
-            return SocketState.LONG;
-        } else {
-            if (!keepAlive) {
-                return SocketState.CLOSED;
+        if (!error && attach != null &&
+                asyncStateMachine.isAsyncDispatching()) {
+            long soTimeout = endpoint.getSoTimeout();
+            int keepAliveTimeout = endpoint.getKeepAliveTimeout();
+
+            //reset the timeout
+            if (keepAlive && keepAliveTimeout>0) {
+                attach.setTimeout(keepAliveTimeout);
             } else {
-                return SocketState.OPEN;
+                attach.setTimeout(soTimeout);
             }
         }
     }
 
+
     /**
      * Process pipelined HTTP requests using the specified input and output
      * streams.

==================================================
