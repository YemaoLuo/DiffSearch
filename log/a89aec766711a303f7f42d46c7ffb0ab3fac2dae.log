a89aec766711a303f7f42d46c7ffb0ab3fac2dae
==================================================
Pull up Handler.process for the Http11 connectors.
==================================================
Mark Emlyn
==================================================
Fri Jul 8 17:19:38 2011 +0000
==================================================
AbstractHttp11Processor.java
Pull up Handler.process for the Http11 connectors.
Note that this is an intermediate step. The aim is to pull this up to AbstractProtocol

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1144391 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractHttp11Protocol.java
index e3e489ce03..54a3f4ca48 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Processor.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Processor.java
@@ -47,9 +47,10 @@ import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketWrapper;
 import org.apache.tomcat.util.res.StringManager;
 
-public abstract class AbstractHttp11Processor extends AbstractProcessor {
+public abstract class AbstractHttp11Processor<S> extends AbstractProcessor {
 
     protected abstract Log getLog();
 
@@ -1211,6 +1212,9 @@ public abstract class AbstractHttp11Processor extends AbstractProcessor {
     }
 
     
+    public abstract SocketState process(SocketWrapper<S> socket)
+            throws IOException;
+    
     public SocketState asyncDispatch(SocketStatus status) {
 
         RequestInfo rp = request.getRequestProcessor();

==================================================
Http11AprProcessor.java
index 0d1aca45a4..b15c35b352 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
@@ -16,7 +16,12 @@
  */
 package org.apache.coyote.http11;
 
+import java.util.concurrent.ConcurrentHashMap;
+
 import org.apache.coyote.AbstractProtocol;
+import org.apache.tomcat.util.ExceptionUtils;
+import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketWrapper;
 import org.apache.tomcat.util.res.StringManager;
 
 public abstract class AbstractHttp11Protocol extends AbstractProtocol {
@@ -182,4 +187,94 @@ public abstract class AbstractHttp11Protocol extends AbstractProtocol {
     public void setMaxKeepAliveRequests(int mkar) {
         endpoint.setMaxKeepAliveRequests(mkar);
     }
+
+
+    protected abstract static class AbstractHttp11ConnectionHandler<S,P extends AbstractHttp11Processor<S>>
+            extends AbstractConnectionHandler {
+        
+        protected ConcurrentHashMap<SocketWrapper<S>,P> connections =
+            new ConcurrentHashMap<SocketWrapper<S>,P>();
+
+        protected RecycledProcessors<P> recycledProcessors =
+            new RecycledProcessors<P>(this);
+        
+        @Override
+        public void recycle() {
+            recycledProcessors.clear();
+        }
+        
+        public SocketState process(SocketWrapper<S> socket,
+                SocketStatus status) {
+            P processor = connections.remove(socket);
+
+            socket.setAsync(false); //no longer check for timeout
+
+            try {
+                if (processor == null) {
+                    processor = recycledProcessors.poll();
+                }
+                if (processor == null) {
+                    processor = createProcessor();
+                }
+
+                initSsl(socket, processor);
+                
+                SocketState state = SocketState.CLOSED;
+                do {
+                    if (processor.isAsync() || state == SocketState.ASYNC_END) {
+                        state = processor.asyncDispatch(status);
+                    } else if (processor.comet) {
+                        state = processor.event(status);
+                    } else {
+                        state = processor.process(socket);
+                    }
+    
+                    if (state != SocketState.CLOSED && processor.isAsync()) {
+                        state = processor.asyncPostProcess();
+                    }
+                } while (state == SocketState.ASYNC_END);
+
+                if (state == SocketState.LONG) {
+                    // In the middle of processing a request/response. Keep the
+                    // socket associated with the processor. Exact requirements
+                    // depend on type of long poll
+                    longPoll(socket, processor);
+                } else if (state == SocketState.OPEN){
+                    // In keep-alive but between requests. OK to recycle
+                    // processor. Continue to poll for the next request.
+                    release(socket, processor, false, true);
+                } else {
+                    // Connection closed. OK to recycle the processor.
+                    release(socket, processor, true, false);
+                }
+                return state;
+            } catch(java.net.SocketException e) {
+                // SocketExceptions are normal
+                getLog().debug(sm.getString(
+                        "http11protocol.proto.socketexception.debug"), e);
+            } catch (java.io.IOException e) {
+                // IOExceptions are normal
+                getLog().debug(sm.getString(
+                        "http11protocol.proto.ioexception.debug"), e);
+            }
+            // Future developers: if you discover any other
+            // rare-but-nonfatal exceptions, catch them here, and log as
+            // above.
+            catch (Throwable e) {
+                ExceptionUtils.handleThrowable(e);
+                // any other exception or error is odd. Here we log it
+                // with "ERROR" level, so it will show up even on
+                // less-than-verbose logs.
+                getLog().error(sm.getString("http11protocol.proto.error"), e);
+            }
+            release(socket, processor, true, false);
+            return SocketState.CLOSED;
+        }
+        
+        protected abstract P createProcessor();
+        protected abstract void initSsl(SocketWrapper<S> socket, P processor);
+        protected abstract void longPoll(SocketWrapper<S> socket, P processor);
+        protected abstract void release(SocketWrapper<S> socket, P processor,
+                boolean socketClosing, boolean addToPoller);        
+    }
 }

==================================================
Http11AprProtocol.java
index 38fb8e9164..14f664b169 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -45,7 +45,7 @@ import org.apache.tomcat.util.net.SocketWrapper;
  *
  * @author Remy Maucherat
  */
-public class Http11AprProcessor extends AbstractHttp11Processor {
+public class Http11AprProcessor extends AbstractHttp11Processor<Long> {
 
 
     private static final Log log = LogFactory.getLog(Http11AprProcessor.class);
@@ -163,6 +163,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor {
      *
      * @throws IOException error during an I/O operation
      */
+    @Override
     public SocketState process(SocketWrapper<Long> socket)
         throws IOException {
         RequestInfo rp = request.getRequestProcessor();

==================================================
Http11NioProcessor.java
index b8ae0a84d9..f630dfbf42 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -14,19 +14,14 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.coyote.http11;
 
-import java.util.concurrent.ConcurrentHashMap;
-
 import org.apache.coyote.AbstractProtocol;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AprEndpoint;
 import org.apache.tomcat.util.net.AprEndpoint.Handler;
-import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapper;
 
 
@@ -182,16 +177,10 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
     // --------------------  Connection handler --------------------
 
     protected static class Http11ConnectionHandler
-            extends AbstractConnectionHandler implements Handler {
+            extends AbstractHttp11ConnectionHandler<Long,Http11AprProcessor> implements Handler {
         
         protected Http11AprProtocol proto;
         
-        protected ConcurrentHashMap<Long, Http11AprProcessor> connections =
-            new ConcurrentHashMap<Long, Http11AprProcessor>();
-
-        protected RecycledProcessors<Http11AprProcessor> recycledProcessors =
-            new RecycledProcessors<Http11AprProcessor>(this);
-
         Http11ConnectionHandler(Http11AprProtocol proto) {
             this.proto = proto;
         }
@@ -220,6 +209,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
          * @param isSocketClosing   Not used in HTTP
          * @param addToPoller
          */
+        @Override
         public void release(SocketWrapper<Long> socket,
                 Http11AprProcessor processor, boolean isSocketClosing,
                 boolean addToPoller) {
@@ -232,83 +222,15 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
         }
 
         @Override
-        public SocketState process(SocketWrapper<Long> socket,
-                SocketStatus status) {
-            Http11AprProcessor processor = connections.remove(socket.getSocket());
-            
-            socket.setAsync(false);
-
-            try {
-                if (processor == null) {
-                    processor = recycledProcessors.poll();
-                }
-                if (processor == null) {
-                    processor = createProcessor();
-                }
-
-                initSsl(socket, processor);
-
-                SocketState state = SocketState.CLOSED;
-                do {
-                    if (processor.isAsync() || state == SocketState.ASYNC_END) {
-                        state = processor.asyncDispatch(status);
-                    } else if (processor.comet) {
-                        state = processor.event(status);
-                    } else {
-                        state = processor.process(socket);
-                    }
-
-                    if (state != SocketState.CLOSED && processor.isAsync()) {
-                        state = processor.asyncPostProcess();
-                    }
-                } while (state == SocketState.ASYNC_END);
-
-                if (state == SocketState.LONG) {
-                    // In the middle of processing a request/response. Keep the
-                    // socket associated with the processor. Exact requirements
-                    // depend on type of long poll
-                    longPoll(socket, processor);
-                } else if (state == SocketState.OPEN){
-                    // In keep-alive but between requests. OK to recycle
-                    // processor. Continue to poll for the next request.
-                    release(socket, processor, false, true);
-                } else {
-                    // Connection closed. OK to recycle the processor.
-                    release(socket, processor, true, false);
-                }
-                return state;
-            } catch (java.net.SocketException e) {
-                // SocketExceptions are normal
-                log.debug(sm.getString(
-                        "http11protocol.proto.socketexception.debug"), e);
-            } catch (java.io.IOException e) {
-                // IOExceptions are normal
-                log.debug(sm.getString(
-                        "http11protocol.proto.ioexception.debug"), e);
-            }
-            // Future developers: if you discover any other
-            // rare-but-nonfatal exceptions, catch them here, and log as
-            // above.
-            catch (Throwable e) {
-                ExceptionUtils.handleThrowable(e);
-                // any other exception or error is odd. Here we log it
-                // with "ERROR" level, so it will show up even on
-                // less-than-verbose logs.
-                log.error(sm.getString("http11protocol.proto.error"), e);
-            }
-            release(socket, processor, true, false);
-            return SocketState.CLOSED;
-        }
-
-        @SuppressWarnings("unused")
-        private void initSsl(SocketWrapper<Long> socket,
+        protected void initSsl(SocketWrapper<Long> socket,
                 Http11AprProcessor processor) {
             // NOOP for APR
         }
 
-        private void longPoll(SocketWrapper<Long> socket,
+        @Override
+        protected void longPoll(SocketWrapper<Long> socket,
                 Http11AprProcessor processor) {
-            connections.put(socket.getSocket(), processor);
+            connections.put(socket, processor);
 
             if (processor.isAsync()) {
                 socket.setAsync(true);
@@ -318,6 +240,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
             }
         }
 
+        @Override
         protected Http11AprProcessor createProcessor() {
             Http11AprProcessor processor = new Http11AprProcessor(
                     proto.getMaxHttpHeaderSize(), (AprEndpoint)proto.endpoint,

==================================================
Http11NioProtocol.java
index fcc6b7515a..599776bd27 100644
--- a/java/org/apache/coyote/http11/Http11NioProcessor.java
+++ b/java/org/apache/coyote/http11/Http11NioProcessor.java
@@ -45,7 +45,7 @@ import org.apache.tomcat.util.net.SocketWrapper;
  * @author Remy Maucherat
  * @author Filip Hanik
  */
-public class Http11NioProcessor extends AbstractHttp11Processor {
+public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
 
     private static final Log log = LogFactory.getLog(Http11NioProcessor.class);
     @Override
@@ -194,6 +194,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor {
      *
      * @throws IOException error during an I/O operation
      */
+    @Override
     public SocketState process(SocketWrapper<NioChannel> socket)
         throws IOException {
         RequestInfo rp = request.getRequestProcessor();

==================================================
Http11Processor.java
index 0711d72225..b3915ba42e 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -14,18 +14,15 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.coyote.http11;
 
 import java.nio.channels.SelectionKey;
 import java.nio.channels.SocketChannel;
 import java.util.Iterator;
-import java.util.concurrent.ConcurrentHashMap;
 
 import org.apache.coyote.AbstractProtocol;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.NioChannel;
 import org.apache.tomcat.util.net.NioEndpoint;
@@ -33,7 +30,6 @@ import org.apache.tomcat.util.net.NioEndpoint.Handler;
 import org.apache.tomcat.util.net.NioEndpoint.KeyAttachment;
 import org.apache.tomcat.util.net.SSLImplementation;
 import org.apache.tomcat.util.net.SecureNioChannel;
-import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.SocketWrapper;
 
 
@@ -152,16 +148,11 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
     // --------------------  Connection handler --------------------
 
     protected static class Http11ConnectionHandler
-            extends AbstractConnectionHandler implements Handler {
+            extends AbstractHttp11ConnectionHandler<NioChannel,Http11NioProcessor>
+            implements Handler {
 
         protected Http11NioProtocol proto;
 
-        protected ConcurrentHashMap<SocketWrapper<NioChannel>, Http11NioProcessor> connections =
-            new ConcurrentHashMap<SocketWrapper<NioChannel>, Http11NioProcessor>();
-
-        protected RecycledProcessors<Http11NioProcessor> recycledProcessors =
-            new RecycledProcessors<Http11NioProcessor>(this);
-
         Http11ConnectionHandler(Http11NioProtocol proto) {
             this.proto = proto;
         }
@@ -182,11 +173,6 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
             return proto.sslImplementation;
         }
 
-        @Override
-        public void recycle() {
-            recycledProcessors.clear();
-        }
-        
         /**
          * Expected to be used by the Poller to release resources on socket
          * close, errors etc.
@@ -235,6 +221,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
          * @param isSocketClosing   Not used in HTTP
          * @param addToPoller
          */
+        @Override
         public void release(SocketWrapper<NioChannel> socket,
                 Http11NioProcessor processor, boolean isSocketClosing,
                 boolean addToPoller) {
@@ -247,75 +234,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
 
 
         @Override
-        public SocketState process(SocketWrapper<NioChannel> socket,
-                SocketStatus status) {
-            Http11NioProcessor processor = connections.remove(socket);
-
-            socket.setAsync(false); //no longer check for timeout
-
-            try {
-                if (processor == null) {
-                    processor = recycledProcessors.poll();
-                }
-                if (processor == null) {
-                    processor = createProcessor();
-                }
-
-                initSsl(socket, processor);
-
-                SocketState state = SocketState.CLOSED;
-                do {
-                    if (processor.isAsync() || state == SocketState.ASYNC_END) {
-                        state = processor.asyncDispatch(status);
-                    } else if (processor.comet) {
-                        state = processor.event(status);
-                    } else {
-                        state = processor.process(socket);
-                    }
-
-                    if (state != SocketState.CLOSED && processor.isAsync()) {
-                        state = processor.asyncPostProcess();
-                    }
-                } while (state == SocketState.ASYNC_END);
-
-                if (state == SocketState.LONG) {
-                    // In the middle of processing a request/response. Keep the
-                    // socket associated with the processor. Exact requirements
-                    // depend on type of long poll
-                    longPoll(socket, processor);
-                } else if (state == SocketState.OPEN){
-                    // In keep-alive but between requests. OK to recycle
-                    // processor. Continue to poll for the next request.
-                    release(socket, processor, false, true);
-                } else {
-                    // Connection closed. OK to recycle the processor.
-                    release(socket, processor, true, false);
-                }
-                return state;
-            } catch (java.net.SocketException e) {
-                // SocketExceptions are normal
-                log.debug(sm.getString(
-                        "http11protocol.proto.socketexception.debug"), e);
-            } catch (java.io.IOException e) {
-                // IOExceptions are normal
-                log.debug(sm.getString(
-                        "http11protocol.proto.ioexception.debug"), e);
-            }
-            // Future developers: if you discover any other
-            // rare-but-nonfatal exceptions, catch them here, and log as
-            // above.
-            catch (Throwable e) {
-                ExceptionUtils.handleThrowable(e);
-                // any other exception or error is odd. Here we log it
-                // with "ERROR" level, so it will show up even on
-                // less-than-verbose logs.
-                log.error(sm.getString("http11protocol.proto.error"), e);
-            }
-            release(socket, processor, true, false);
-            return SocketState.CLOSED;
-        }
-
-        private void initSsl(SocketWrapper<NioChannel> socket,
+        protected void initSsl(SocketWrapper<NioChannel> socket,
                 Http11NioProcessor processor) {
             if (proto.isSSLEnabled() &&
                     (proto.sslImplementation != null)
@@ -330,7 +249,8 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
 
         }
 
-        private void longPoll(SocketWrapper<NioChannel> socket,
+        @Override
+        protected void longPoll(SocketWrapper<NioChannel> socket,
                 Http11NioProcessor processor) {
             connections.put(socket, processor);
             
@@ -349,6 +269,7 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
             }
         }
 
+        @Override
         public Http11NioProcessor createProcessor() {
             Http11NioProcessor processor = new Http11NioProcessor(
                     proto.getMaxHttpHeaderSize(), (NioEndpoint)proto.endpoint,

==================================================
Http11Protocol.java
index df77477e7d..0b87894adb 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -41,7 +41,7 @@ import org.apache.tomcat.util.net.SocketWrapper;
  * @author Remy Maucherat
  * @author fhanik
  */
-public class Http11Processor extends AbstractHttp11Processor {
+public class Http11Processor extends AbstractHttp11Processor<Socket> {
 
     private static final Log log = LogFactory.getLog(Http11Processor.class);
     @Override
@@ -129,6 +129,7 @@ public class Http11Processor extends AbstractHttp11Processor {
      *  
      * @throws IOException error during an I/O operation
      */
+    @Override
     public SocketState process(SocketWrapper<Socket> socketWrapper)
         throws IOException {
         RequestInfo rp = request.getRequestProcessor();

==================================================
