8700aa0f6a6de79f2f26d975b5cc63750fe0d500
==================================================
Pull up action()
==================================================
Mark Thomas
==================================================
Fri Aug 12 07:47:34 2016 +0000
==================================================
AbstractProcessor.java
Pull up action()

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1756106 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AjpProcessor.java
index d6d607b1d3..b162ca1790 100644
--- a/java/org/apache/coyote/AbstractProcessor.java
+++ b/java/org/apache/coyote/AbstractProcessor.java
@@ -19,11 +19,14 @@ package org.apache.coyote;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import javax.servlet.RequestDispatcher;
 
 import org.apache.tomcat.util.ExceptionUtils;
+import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.net.AbstractEndpoint;
+import org.apache.tomcat.util.net.DispatchType;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.SocketEvent;
@@ -246,6 +249,245 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
     }
 
 
+    @Override
+    public final void action(ActionCode actionCode, Object param) {
+        switch (actionCode) {
+        // 'Normal' servlet support
+        case COMMIT: {
+            if (!response.isCommitted()) {
+                try {
+                    // Validate and write response headers
+                    prepareResponse();
+                } catch (IOException e) {
+                    setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);
+                }
+            }
+            break;
+        }
+        case CLOSE: {
+            action(ActionCode.COMMIT, null);
+            try {
+                finishResponse();
+            } catch (IOException e) {
+                setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);
+            }
+            break;
+        }
+        case ACK: {
+            ack();
+            break;
+        }
+        case CLIENT_FLUSH: {
+            action(ActionCode.COMMIT, null);
+            try {
+                flush();
+            } catch (IOException e) {
+                setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);
+                response.setErrorException(e);
+            }
+            break;
+        }
+        case AVAILABLE: {
+            request.setAvailable(available(Boolean.TRUE.equals(param)));
+            break;
+        }
+        case REQ_SET_BODY_REPLAY: {
+            ByteChunk body = (ByteChunk) param;
+            setRequestBody(body);
+            break;
+        }
+
+        // Error handling
+        case IS_ERROR: {
+            ((AtomicBoolean) param).set(getErrorState().isError());
+            break;
+        }
+        case CLOSE_NOW: {
+            // Prevent further writes to the response
+            setSwallowResponse();
+            setErrorState(ErrorState.CLOSE_NOW, null);
+            break;
+        }
+        case DISABLE_SWALLOW_INPUT: {
+            // Aborted upload or similar.
+            // No point reading the remainder of the request.
+            disableSwallowRequest();
+            // This is an error state. Make sure it is marked as such.
+            setErrorState(ErrorState.CLOSE_CLEAN, null);
+            break;
+        }
+
+        // Request attribute support
+        case REQ_HOST_ADDR_ATTRIBUTE: {
+            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
+                request.remoteAddr().setString(socketWrapper.getRemoteAddr());
+            }
+            break;
+        }
+        case REQ_HOST_ATTRIBUTE: {
+            populateRequestAttributeRemoteHost();
+            break;
+        }
+        case REQ_LOCALPORT_ATTRIBUTE: {
+            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
+                request.setLocalPort(socketWrapper.getLocalPort());
+            }
+            break;
+        }
+        case REQ_LOCAL_ADDR_ATTRIBUTE: {
+            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
+                request.localAddr().setString(socketWrapper.getLocalAddr());
+            }
+            break;
+        }
+        case REQ_LOCAL_NAME_ATTRIBUTE: {
+            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
+                request.localName().setString(socketWrapper.getLocalName());
+            }
+            break;
+        }
+        case REQ_REMOTEPORT_ATTRIBUTE: {
+            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
+                request.setRemotePort(socketWrapper.getRemotePort());
+            }
+            break;
+        }
+
+        // SSL request attribute support
+        case REQ_SSL_ATTRIBUTE: {
+            populateSslRequestAttributes();
+            break;
+        }
+        case REQ_SSL_CERTIFICATE: {
+            sslReHandShake();
+            break;
+        }
+
+        // Servlet 3.0 asynchronous support
+        case ASYNC_START: {
+            asyncStateMachine.asyncStart((AsyncContextCallback) param);
+            break;
+        }
+        case ASYNC_COMPLETE: {
+            clearDispatches();
+            if (asyncStateMachine.asyncComplete()) {
+                socketWrapper.processSocket(SocketEvent.OPEN_READ, true);
+            }
+            break;
+        }
+        case ASYNC_DISPATCH: {
+            if (asyncStateMachine.asyncDispatch()) {
+                socketWrapper.processSocket(SocketEvent.OPEN_READ, true);
+            }
+            break;
+        }
+        case ASYNC_DISPATCHED: {
+            asyncStateMachine.asyncDispatched();
+            break;
+        }
+        case ASYNC_ERROR: {
+            asyncStateMachine.asyncError();
+            break;
+        }
+        case ASYNC_IS_ASYNC: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isAsync());
+            break;
+        }
+        case ASYNC_IS_COMPLETING: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isCompleting());
+            break;
+        }
+        case ASYNC_IS_DISPATCHING: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncDispatching());
+            break;
+        }
+        case ASYNC_IS_ERROR: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncError());
+            break;
+        }
+        case ASYNC_IS_STARTED: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncStarted());
+            break;
+        }
+        case ASYNC_IS_TIMINGOUT: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncTimingOut());
+            break;
+        }
+        case ASYNC_RUN: {
+            asyncStateMachine.asyncRun((Runnable) param);
+            break;
+        }
+        case ASYNC_SETTIMEOUT: {
+            if (param == null) {
+                return;
+            }
+            long timeout = ((Long) param).longValue();
+            setAsyncTimeout(timeout);
+            break;
+        }
+        case ASYNC_TIMEOUT: {
+            AtomicBoolean result = (AtomicBoolean) param;
+            result.set(asyncStateMachine.asyncTimeout());
+            break;
+        }
+        case ASYNC_POST_PROCESS: {
+            asyncStateMachine.asyncPostProcess();
+            break;
+        }
+
+        // Servlet 3.1 non-blocking I/O
+        case REQUEST_BODY_FULLY_READ: {
+            AtomicBoolean result = (AtomicBoolean) param;
+            result.set(isRequestBodyFullyRead());
+            break;
+        }
+        case NB_READ_INTEREST: {
+            if (!isRequestBodyFullyRead()) {
+                registerReadInterest();
+            }
+            break;
+        }
+        case NB_WRITE_INTEREST: {
+            AtomicBoolean isReady = (AtomicBoolean)param;
+            isReady.set(isReady());
+            break;
+        }
+        case DISPATCH_READ: {
+            addDispatch(DispatchType.NON_BLOCKING_READ);
+            break;
+        }
+        case DISPATCH_WRITE: {
+            addDispatch(DispatchType.NON_BLOCKING_WRITE);
+            break;
+        }
+        case DISPATCH_EXECUTE: {
+            SocketWrapperBase<?> wrapper = socketWrapper;
+            if (wrapper != null) {
+                executeDispatches(wrapper);
+            }
+            break;
+        }
+
+        // Servlet 3.1 HTTP Upgrade
+        case UPGRADE: {
+            doHttpUpgrade((UpgradeToken) param);
+            break;
+        }
+
+        // Servlet 4.0 Push requests
+        case IS_PUSH_SUPPORTED: {
+            AtomicBoolean result = (AtomicBoolean) param;
+            result.set(isPushSupported());
+            break;
+        }
+        case PUSH_REQUEST: {
+            doPush((PushToken) param);
+            break;
+        }
+        }
+    }
+
+
     /**
      * Perform any necessary processing for a non-blocking read before
      * dispatching to the adapter.
@@ -305,6 +547,63 @@ public abstract class AbstractProcessor extends AbstractProcessorLight implement
     }
 
 
+    protected abstract void prepareResponse() throws IOException;
+
+
+    protected abstract void finishResponse() throws IOException;
+
+
+    protected abstract void ack();
+
+
+    protected abstract void flush() throws IOException;
+
+
+    protected abstract int available(boolean doRead);
+
+
+    protected abstract void setRequestBody(ByteChunk body);
+
+
+    protected abstract void setSwallowResponse();
+
+
+    protected abstract void disableSwallowRequest();
+
+
+    protected abstract boolean getPopulateRequestAttributesFromSocket();
+
+
+    protected abstract void populateRequestAttributeRemoteHost();
+
+
+    protected abstract void populateSslRequestAttributes();
+
+
+    protected abstract void sslReHandShake() ;
+
+
+    protected abstract boolean isRequestBodyFullyRead();
+
+
+    protected abstract void registerReadInterest();
+
+
+    protected abstract boolean isReady();
+
+
+    protected abstract void executeDispatches(SocketWrapperBase<?> wrapper);
+
+
+    protected abstract void doHttpUpgrade(UpgradeToken upgradeToken);
+
+
+    protected abstract boolean isPushSupported();
+
+
+    protected abstract void doPush(PushToken pushToken);
+
+
     /**
      * Flush any pending writes. Used during non-blocking writes to flush any
      * remaining data from a previous incomplete write.

==================================================
Http11Processor.java
index c4a7b41615..a7a8b1ddb2 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -25,13 +25,11 @@ import java.nio.ByteBuffer;
 import java.security.NoSuchProviderException;
 import java.security.cert.CertificateFactory;
 import java.security.cert.X509Certificate;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 import javax.servlet.http.HttpServletResponse;
 
 import org.apache.coyote.AbstractProcessor;
 import org.apache.coyote.ActionCode;
-import org.apache.coyote.AsyncContextCallback;
 import org.apache.coyote.ErrorState;
 import org.apache.coyote.InputBuffer;
 import org.apache.coyote.OutputBuffer;
@@ -47,9 +45,7 @@ import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
-import org.apache.tomcat.util.net.DispatchType;
 import org.apache.tomcat.util.net.SSLSupport;
-import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
@@ -354,245 +350,6 @@ public class AjpProcessor extends AbstractProcessor {
 
     // --------------------------------------------------------- Public Methods
 
-    @Override
-    public final void action(ActionCode actionCode, Object param) {
-        switch (actionCode) {
-        // 'Normal' servlet support
-        case COMMIT: {
-            if (!response.isCommitted()) {
-                try {
-                    // Validate and write response headers
-                    prepareResponse();
-                } catch (IOException e) {
-                    setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);
-                }
-            }
-            break;
-        }
-        case CLOSE: {
-            action(ActionCode.COMMIT, null);
-            try {
-                finishResponse();
-            } catch (IOException e) {
-                setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);
-            }
-            break;
-        }
-        case ACK: {
-            ack();
-            break;
-        }
-        case CLIENT_FLUSH: {
-            action(ActionCode.COMMIT, null);
-            try {
-                flush();
-            } catch (IOException e) {
-                setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);
-                response.setErrorException(e);
-            }
-            break;
-        }
-        case AVAILABLE: {
-            request.setAvailable(available(Boolean.TRUE.equals(param)));
-            break;
-        }
-        case REQ_SET_BODY_REPLAY: {
-            ByteChunk body = (ByteChunk) param;
-            setRequestBody(body);
-            break;
-        }
-
-        // Error handling
-        case IS_ERROR: {
-            ((AtomicBoolean) param).set(getErrorState().isError());
-            break;
-        }
-        case CLOSE_NOW: {
-            // Prevent further writes to the response
-            setSwallowResponse();
-            setErrorState(ErrorState.CLOSE_NOW, null);
-            break;
-        }
-        case DISABLE_SWALLOW_INPUT: {
-            // Aborted upload or similar.
-            // No point reading the remainder of the request.
-            disableSwallowRequest();
-            // This is an error state. Make sure it is marked as such.
-            setErrorState(ErrorState.CLOSE_CLEAN, null);
-            break;
-        }
-
-        // Request attribute support
-        case REQ_HOST_ADDR_ATTRIBUTE: {
-            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
-                request.remoteAddr().setString(socketWrapper.getRemoteAddr());
-            }
-            break;
-        }
-        case REQ_HOST_ATTRIBUTE: {
-            populateRequestAttributeRemoteHost();
-            break;
-        }
-        case REQ_LOCALPORT_ATTRIBUTE: {
-            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
-                request.setLocalPort(socketWrapper.getLocalPort());
-            }
-            break;
-        }
-        case REQ_LOCAL_ADDR_ATTRIBUTE: {
-            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
-                request.localAddr().setString(socketWrapper.getLocalAddr());
-            }
-            break;
-        }
-        case REQ_LOCAL_NAME_ATTRIBUTE: {
-            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
-                request.localName().setString(socketWrapper.getLocalName());
-            }
-            break;
-        }
-        case REQ_REMOTEPORT_ATTRIBUTE: {
-            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
-                request.setRemotePort(socketWrapper.getRemotePort());
-            }
-            break;
-        }
-
-        // SSL request attribute support
-        case REQ_SSL_ATTRIBUTE: {
-            populateSslRequestAttributes();
-            break;
-        }
-        case REQ_SSL_CERTIFICATE: {
-            sslReHandShake();
-            break;
-        }
-
-        // Servlet 3.0 asynchronous support
-        case ASYNC_START: {
-            asyncStateMachine.asyncStart((AsyncContextCallback) param);
-            break;
-        }
-        case ASYNC_COMPLETE: {
-            clearDispatches();
-            if (asyncStateMachine.asyncComplete()) {
-                socketWrapper.processSocket(SocketEvent.OPEN_READ, true);
-            }
-            break;
-        }
-        case ASYNC_DISPATCH: {
-            if (asyncStateMachine.asyncDispatch()) {
-                socketWrapper.processSocket(SocketEvent.OPEN_READ, true);
-            }
-            break;
-        }
-        case ASYNC_DISPATCHED: {
-            asyncStateMachine.asyncDispatched();
-            break;
-        }
-        case ASYNC_ERROR: {
-            asyncStateMachine.asyncError();
-            break;
-        }
-        case ASYNC_IS_ASYNC: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsync());
-            break;
-        }
-        case ASYNC_IS_COMPLETING: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isCompleting());
-            break;
-        }
-        case ASYNC_IS_DISPATCHING: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncDispatching());
-            break;
-        }
-        case ASYNC_IS_ERROR: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncError());
-            break;
-        }
-        case ASYNC_IS_STARTED: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncStarted());
-            break;
-        }
-        case ASYNC_IS_TIMINGOUT: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncTimingOut());
-            break;
-        }
-        case ASYNC_RUN: {
-            asyncStateMachine.asyncRun((Runnable) param);
-            break;
-        }
-        case ASYNC_SETTIMEOUT: {
-            if (param == null) {
-                return;
-            }
-            long timeout = ((Long) param).longValue();
-            setAsyncTimeout(timeout);
-            break;
-        }
-        case ASYNC_TIMEOUT: {
-            AtomicBoolean result = (AtomicBoolean) param;
-            result.set(asyncStateMachine.asyncTimeout());
-            break;
-        }
-        case ASYNC_POST_PROCESS: {
-            asyncStateMachine.asyncPostProcess();
-            break;
-        }
-
-        // Servlet 3.1 non-blocking I/O
-        case REQUEST_BODY_FULLY_READ: {
-            AtomicBoolean result = (AtomicBoolean) param;
-            result.set(isRequestBodyFullyRead());
-            break;
-        }
-        case NB_READ_INTEREST: {
-            if (!isRequestBodyFullyRead()) {
-                registerReadInterest();
-            }
-            break;
-        }
-        case NB_WRITE_INTEREST: {
-            AtomicBoolean isReady = (AtomicBoolean)param;
-            isReady.set(isReady());
-            break;
-        }
-        case DISPATCH_READ: {
-            addDispatch(DispatchType.NON_BLOCKING_READ);
-            break;
-        }
-        case DISPATCH_WRITE: {
-            addDispatch(DispatchType.NON_BLOCKING_WRITE);
-            break;
-        }
-        case DISPATCH_EXECUTE: {
-            SocketWrapperBase<?> wrapper = socketWrapper;
-            if (wrapper != null) {
-                executeDispatches(wrapper);
-            }
-            break;
-        }
-
-        // Servlet 3.1 HTTP Upgrade
-        case UPGRADE: {
-            doHttpUpgrade((UpgradeToken) param);
-            break;
-        }
-
-        // Servlet 4.0 Push requests
-        case IS_PUSH_SUPPORTED: {
-            AtomicBoolean result = (AtomicBoolean) param;
-            result.set(isPushSupported());
-            break;
-        }
-        case PUSH_REQUEST: {
-            doPush((PushToken) param);
-            break;
-        }
-        }
-    }
-
-
     @Override
     protected boolean flushBufferedWrite() throws IOException {
         if (hasDataToWrite()) {
@@ -1274,7 +1031,8 @@ public class AjpProcessor extends AbstractProcessor {
      * When committing the response, we have to validate the set of headers, as
      * well as setup the response filters.
      */
-    private void prepareResponse() throws IOException {
+    @Override
+    protected final void prepareResponse() throws IOException {
 
         response.setCommitted(true);
 
@@ -1348,7 +1106,8 @@ public class AjpProcessor extends AbstractProcessor {
     /**
      * Callback to write data from the buffer.
      */
-    private void flush() throws IOException {
+    @Override
+    protected final void flush() throws IOException {
         // Calling code should ensure that there is no data in the buffers for
         // non-blocking writes.
         // TODO Validate the assertion above
@@ -1365,7 +1124,8 @@ public class AjpProcessor extends AbstractProcessor {
     /**
      * Finish AJP response.
      */
-    private void finishResponse() throws IOException {
+    @Override
+    protected final void finishResponse() throws IOException {
         if (responseFinished)
             return;
 
@@ -1386,12 +1146,14 @@ public class AjpProcessor extends AbstractProcessor {
     }
 
 
-    private void ack() {
+    @Override
+    protected final void ack() {
         // NO-OP for AJP
     }
 
 
-    private int available(boolean doRead) {
+    @Override
+    protected final int available(boolean doRead) {
         if (endOfStream) {
             return 0;
         }
@@ -1413,7 +1175,8 @@ public class AjpProcessor extends AbstractProcessor {
     }
 
 
-    private void setRequestBody(ByteChunk body) {
+    @Override
+    protected final void setRequestBody(ByteChunk body) {
         int length = body.getLength();
         bodyBytes.setBytes(body.getBytes(), body.getStart(), length);
         request.setContentLength(length);
@@ -1424,12 +1187,14 @@ public class AjpProcessor extends AbstractProcessor {
     }
 
 
-    private void setSwallowResponse() {
+    @Override
+    protected final void setSwallowResponse() {
         swallowResponse = true;
     }
 
 
-    private void disableSwallowRequest() {
+    @Override
+    protected final void disableSwallowRequest() {
         /* NO-OP
          * With AJP, Tomcat controls when the client sends request body data. At
          * most there will be a single packet to read and that will be handled
@@ -1438,14 +1203,16 @@ public class AjpProcessor extends AbstractProcessor {
     }
 
 
-    private boolean getPopulateRequestAttributesFromSocket() {
+    @Override
+    protected final boolean getPopulateRequestAttributesFromSocket() {
         // NO-OPs the attribute requests since they are pre-populated when
         // parsing the first AJP message.
         return false;
     }
 
 
-    private void populateRequestAttributeRemoteHost() {
+    @Override
+    protected final void populateRequestAttributeRemoteHost() {
         // Get remote host name using a DNS resolution
         if (request.remoteHost().isNull()) {
             try {
@@ -1458,7 +1225,8 @@ public class AjpProcessor extends AbstractProcessor {
     }
 
 
-    private void populateSslRequestAttributes() {
+    @Override
+    protected final void populateSslRequestAttributes() {
         if (!certificates.isNull()) {
             ByteChunk certData = certificates.getByteChunk();
             X509Certificate jsseCerts[] = null;
@@ -1501,28 +1269,33 @@ public class AjpProcessor extends AbstractProcessor {
     }
 
 
-    private void sslReHandShake() {
+    @Override
+    protected final void sslReHandShake() {
         // NO-OP. Can't force a new SSL handshake with the client when using
         // AJP as the reverse proxy controls that connection.
     }
 
 
-    private boolean isRequestBodyFullyRead() {
+    @Override
+    protected final boolean isRequestBodyFullyRead() {
         return endOfStream;
     }
 
 
-    private void registerReadInterest() {
+    @Override
+    protected final void registerReadInterest() {
         socketWrapper.registerReadInterest();
     }
 
 
-    private boolean isReady() {
+    @Override
+    protected final boolean isReady() {
         return responseMsgPos == -1 && socketWrapper.isReadyForWrite();
     }
 
 
-    private void executeDispatches(SocketWrapperBase<?> wrapper) {
+    @Override
+    protected final void executeDispatches(SocketWrapperBase<?> wrapper) {
         wrapper.executeNonBlockingDispatches(getIteratorAndClearDispatches());
     }
 
@@ -1530,14 +1303,16 @@ public class AjpProcessor extends AbstractProcessor {
     /**
      * @param upgradeToken Unused.
      */
-    private void doHttpUpgrade(UpgradeToken upgradeToken) {
+    @Override
+    protected final void doHttpUpgrade(UpgradeToken upgradeToken) {
         // HTTP connections only. Unsupported for AJP.
         throw new UnsupportedOperationException(
                 sm.getString("ajpprocessor.httpupgrade.notsupported"));
     }
 
 
-    private boolean isPushSupported() {
+    @Override
+    protected final boolean isPushSupported() {
         // HTTP2 connections only. Unsupported for AJP.
         return false;
     }
@@ -1546,7 +1321,8 @@ public class AjpProcessor extends AbstractProcessor {
     /**
      * @param pushToken Unused
      */
-    private void doPush(PushToken pushToken) {
+    @Override
+    protected final void doPush(PushToken pushToken) {
         // HTTP2 connections only. Unsupported for AJP.
         throw new UnsupportedOperationException(
                 sm.getString("ajpprocessor.pushrequest.notsupported"));

==================================================
StreamProcessor.java
index 36ff4358e1..30512ed244 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -23,14 +23,12 @@ import java.util.Enumeration;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.regex.Pattern;
 
 import javax.servlet.http.HttpServletResponse;
 
 import org.apache.coyote.AbstractProcessor;
 import org.apache.coyote.ActionCode;
-import org.apache.coyote.AsyncContextCallback;
 import org.apache.coyote.ErrorState;
 import org.apache.coyote.PushToken;
 import org.apache.coyote.Request;
@@ -59,10 +57,8 @@ import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.log.UserDataHelper;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
-import org.apache.tomcat.util.net.DispatchType;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.SendfileDataBase;
-import org.apache.tomcat.util.net.SocketEvent;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.res.StringManager;
 
@@ -647,245 +643,6 @@ public class Http11Processor extends AbstractProcessor {
     }
 
 
-    @Override
-    public final void action(ActionCode actionCode, Object param) {
-        switch (actionCode) {
-        // 'Normal' servlet support
-        case COMMIT: {
-            if (!response.isCommitted()) {
-                try {
-                    // Validate and write response headers
-                    prepareResponse();
-                } catch (IOException e) {
-                    setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);
-                }
-            }
-            break;
-        }
-        case CLOSE: {
-            action(ActionCode.COMMIT, null);
-            try {
-                finishResponse();
-            } catch (IOException e) {
-                setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);
-            }
-            break;
-        }
-        case ACK: {
-            ack();
-            break;
-        }
-        case CLIENT_FLUSH: {
-            action(ActionCode.COMMIT, null);
-            try {
-                flush();
-            } catch (IOException e) {
-                setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);
-                response.setErrorException(e);
-            }
-            break;
-        }
-        case AVAILABLE: {
-            request.setAvailable(available(Boolean.TRUE.equals(param)));
-            break;
-        }
-        case REQ_SET_BODY_REPLAY: {
-            ByteChunk body = (ByteChunk) param;
-            setRequestBody(body);
-            break;
-        }
-
-        // Error handling
-        case IS_ERROR: {
-            ((AtomicBoolean) param).set(getErrorState().isError());
-            break;
-        }
-        case CLOSE_NOW: {
-            // Prevent further writes to the response
-            setSwallowResponse();
-            setErrorState(ErrorState.CLOSE_NOW, null);
-            break;
-        }
-        case DISABLE_SWALLOW_INPUT: {
-            // Aborted upload or similar.
-            // No point reading the remainder of the request.
-            disableSwallowRequest();
-            // This is an error state. Make sure it is marked as such.
-            setErrorState(ErrorState.CLOSE_CLEAN, null);
-            break;
-        }
-
-        // Request attribute support
-        case REQ_HOST_ADDR_ATTRIBUTE: {
-            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
-                request.remoteAddr().setString(socketWrapper.getRemoteAddr());
-            }
-            break;
-        }
-        case REQ_HOST_ATTRIBUTE: {
-            populateRequestAttributeRemoteHost();
-            break;
-        }
-        case REQ_LOCALPORT_ATTRIBUTE: {
-            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
-                request.setLocalPort(socketWrapper.getLocalPort());
-            }
-            break;
-        }
-        case REQ_LOCAL_ADDR_ATTRIBUTE: {
-            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
-                request.localAddr().setString(socketWrapper.getLocalAddr());
-            }
-            break;
-        }
-        case REQ_LOCAL_NAME_ATTRIBUTE: {
-            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
-                request.localName().setString(socketWrapper.getLocalName());
-            }
-            break;
-        }
-        case REQ_REMOTEPORT_ATTRIBUTE: {
-            if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
-                request.setRemotePort(socketWrapper.getRemotePort());
-            }
-            break;
-        }
-
-        // SSL request attribute support
-        case REQ_SSL_ATTRIBUTE: {
-            populateSslRequestAttributes();
-            break;
-        }
-        case REQ_SSL_CERTIFICATE: {
-            sslReHandShake();
-            break;
-        }
-
-        // Servlet 3.0 asynchronous support
-        case ASYNC_START: {
-            asyncStateMachine.asyncStart((AsyncContextCallback) param);
-            break;
-        }
-        case ASYNC_COMPLETE: {
-            clearDispatches();
-            if (asyncStateMachine.asyncComplete()) {
-                socketWrapper.processSocket(SocketEvent.OPEN_READ, true);
-            }
-            break;
-        }
-        case ASYNC_DISPATCH: {
-            if (asyncStateMachine.asyncDispatch()) {
-                socketWrapper.processSocket(SocketEvent.OPEN_READ, true);
-            }
-            break;
-        }
-        case ASYNC_DISPATCHED: {
-            asyncStateMachine.asyncDispatched();
-            break;
-        }
-        case ASYNC_ERROR: {
-            asyncStateMachine.asyncError();
-            break;
-        }
-        case ASYNC_IS_ASYNC: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsync());
-            break;
-        }
-        case ASYNC_IS_COMPLETING: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isCompleting());
-            break;
-        }
-        case ASYNC_IS_DISPATCHING: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncDispatching());
-            break;
-        }
-        case ASYNC_IS_ERROR: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncError());
-            break;
-        }
-        case ASYNC_IS_STARTED: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncStarted());
-            break;
-        }
-        case ASYNC_IS_TIMINGOUT: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncTimingOut());
-            break;
-        }
-        case ASYNC_RUN: {
-            asyncStateMachine.asyncRun((Runnable) param);
-            break;
-        }
-        case ASYNC_SETTIMEOUT: {
-            if (param == null) {
-                return;
-            }
-            long timeout = ((Long) param).longValue();
-            setAsyncTimeout(timeout);
-            break;
-        }
-        case ASYNC_TIMEOUT: {
-            AtomicBoolean result = (AtomicBoolean) param;
-            result.set(asyncStateMachine.asyncTimeout());
-            break;
-        }
-        case ASYNC_POST_PROCESS: {
-            asyncStateMachine.asyncPostProcess();
-            break;
-        }
-
-        // Servlet 3.1 non-blocking I/O
-        case REQUEST_BODY_FULLY_READ: {
-            AtomicBoolean result = (AtomicBoolean) param;
-            result.set(isRequestBodyFullyRead());
-            break;
-        }
-        case NB_READ_INTEREST: {
-            if (!isRequestBodyFullyRead()) {
-                registerReadInterest();
-            }
-            break;
-        }
-        case NB_WRITE_INTEREST: {
-            AtomicBoolean isReady = (AtomicBoolean)param;
-            isReady.set(isReady());
-            break;
-        }
-        case DISPATCH_READ: {
-            addDispatch(DispatchType.NON_BLOCKING_READ);
-            break;
-        }
-        case DISPATCH_WRITE: {
-            addDispatch(DispatchType.NON_BLOCKING_WRITE);
-            break;
-        }
-        case DISPATCH_EXECUTE: {
-            SocketWrapperBase<?> wrapper = socketWrapper;
-            if (wrapper != null) {
-                executeDispatches(wrapper);
-            }
-            break;
-        }
-
-        // Servlet 3.1 HTTP Upgrade
-        case UPGRADE: {
-            doHttpUpgrade((UpgradeToken) param);
-            break;
-        }
-
-        // Servlet 4.0 Push requests
-        case IS_PUSH_SUPPORTED: {
-            AtomicBoolean result = (AtomicBoolean) param;
-            result.set(isPushSupported());
-            break;
-        }
-        case PUSH_REQUEST: {
-            doPush((PushToken) param);
-            break;
-        }
-        }
-    }
-
-
     @Override
     public SocketState service(SocketWrapperBase<?> socketWrapper)
         throws IOException {
@@ -1356,7 +1113,8 @@ public class Http11Processor extends AbstractProcessor {
      * When committing the response, we have to validate the set of headers, as
      * well as setup the response filters.
      */
-    private void prepareResponse() throws IOException {
+    @Override
+    protected final void prepareResponse() throws IOException {
 
         boolean entityBody = true;
         contentDelimitation = false;
@@ -1723,12 +1481,14 @@ public class Http11Processor extends AbstractProcessor {
     }
 
 
-    private void finishResponse() throws IOException {
+    @Override
+    protected final void finishResponse() throws IOException {
         outputBuffer.finishResponse();
     }
 
 
-    private void ack() {
+    @Override
+    protected final void ack() {
         // Acknowledge request
         // Send a 100 status back if it makes sense (response not committed
         // yet, and client specified an expectation for 100-continue)
@@ -1743,17 +1503,20 @@ public class Http11Processor extends AbstractProcessor {
     }
 
 
-    private void flush() throws IOException {
+    @Override
+    protected final void flush() throws IOException {
         outputBuffer.flush();
     }
 
 
-    private int available(boolean doRead) {
+    @Override
+    protected final int available(boolean doRead) {
         return inputBuffer.available(doRead);
     }
 
 
-    private void setRequestBody(ByteChunk body) {
+    @Override
+    protected final void setRequestBody(ByteChunk body) {
         InputFilter savedBody = new SavedRequestInputFilter(body);
         savedBody.setRequest(request);
 
@@ -1762,29 +1525,34 @@ public class Http11Processor extends AbstractProcessor {
     }
 
 
-    private void setSwallowResponse() {
+    @Override
+    protected final void setSwallowResponse() {
         outputBuffer.responseFinished = true;
     }
 
 
-    private void disableSwallowRequest() {
+    @Override
+    protected final void disableSwallowRequest() {
         inputBuffer.setSwallowInput(false);
     }
 
 
-    private boolean getPopulateRequestAttributesFromSocket() {
+    @Override
+    protected final boolean getPopulateRequestAttributesFromSocket() {
         return true;
     }
 
 
-    private void populateRequestAttributeRemoteHost() {
+    @Override
+    protected final void populateRequestAttributeRemoteHost() {
         if (getPopulateRequestAttributesFromSocket() && socketWrapper != null) {
             request.remoteHost().setString(socketWrapper.getRemoteHost());
         }
     }
 
 
-    private void populateSslRequestAttributes() {
+    @Override
+    protected final void populateSslRequestAttributes() {
         try {
             if (sslSupport != null) {
                 Object sslO = sslSupport.getCipherSuite();
@@ -1815,7 +1583,8 @@ public class Http11Processor extends AbstractProcessor {
     }
 
 
-    private void sslReHandShake() {
+    @Override
+    protected final void sslReHandShake() {
         if (sslSupport != null) {
             // Consume and buffer the request body, so that it does not
             // interfere with the client's handshake messages
@@ -1837,43 +1606,47 @@ public class Http11Processor extends AbstractProcessor {
     }
 
 
-    private boolean isRequestBodyFullyRead() {
+    @Override
+    protected final boolean isRequestBodyFullyRead() {
         return inputBuffer.isFinished();
     }
 
 
-    private void registerReadInterest() {
+    @Override
+    protected final void registerReadInterest() {
         socketWrapper.registerReadInterest();
     }
 
 
-    private boolean isReady() {
+    @Override
+    protected final boolean isReady() {
         return outputBuffer.isReady();
     }
 
 
-    private void executeDispatches(SocketWrapperBase<?> wrapper) {
+    @Override
+    protected final void executeDispatches(SocketWrapperBase<?> wrapper) {
         wrapper.executeNonBlockingDispatches(getIteratorAndClearDispatches());
     }
 
 
-    private void doHttpUpgrade(UpgradeToken upgradeToken) {
+    @Override
+    protected final void doHttpUpgrade(UpgradeToken upgradeToken) {
         this.upgradeToken = upgradeToken;
         // Stop further HTTP output
         outputBuffer.responseFinished = true;
     }
 
 
-    private boolean isPushSupported() {
+    @Override
+    protected final boolean isPushSupported() {
         // HTTP2 connections only. Unsupported for HTTP/1.x
         return false;
     }
 
 
-    /**
-     * @param pushToken Unused
-     */
-    private void doPush(PushToken pushToken) {
+    @Override
+    protected final void doPush(PushToken pushToken) {
         // HTTP2 connections only. Unsupported for AJP.
         throw new UnsupportedOperationException(
                 sm.getString("http11processor.pushrequest.notsupported"));

==================================================
