afe9c32f9b5be1a4d694797d7c1f063cdd045c6e
==================================================
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=56712
==================================================
Konstantin Kolinko
==================================================
Sat Jul 12 13:54:30 2014 +0000
==================================================
PersistentManagerBase.java
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=56712
Fix session time comparisons in PersistentManagerBase.
When asking for session times use internal**() methods to avoid an IllegalStateException.

Speed up TestPersistentManager test for BZ 56698 by removing sleep(1000) and fix occasional failures.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1609920 13f79535-47bb-0310-9956-ffa450edef68



==================================================
TestPersistentManager.java
index b8000e9142..7cd30aa935 100644
--- a/java/org/apache/catalina/session/PersistentManagerBase.java
+++ b/java/org/apache/catalina/session/PersistentManagerBase.java
@@ -903,8 +903,8 @@ public abstract class PersistentManagerBase extends ManagerBase
                 synchronized (session) {
                     if (!session.isValid())
                         continue;
-                    int timeIdle = (int) (session.getIdleTime() / 1000L);
-                    if (timeIdle > maxIdleSwap && timeIdle > minIdleSwap) {
+                    int timeIdle = (int) (session.getIdleTimeInternal() / 1000L);
+                    if (timeIdle >= maxIdleSwap && timeIdle >= minIdleSwap) {
                         if (session.accessCount != null &&
                                 session.accessCount.get() > 0) {
                             // Session is currently being accessed - skip it
@@ -952,8 +952,8 @@ public abstract class PersistentManagerBase extends ManagerBase
         for (int i = 0; i < sessions.length && toswap > 0; i++) {
             StandardSession session =  (StandardSession) sessions[i];
             synchronized (session) {
-                int timeIdle = (int) (session.getIdleTime() / 1000L);
-                if (timeIdle > minIdleSwap) {
+                int timeIdle = (int) (session.getIdleTimeInternal() / 1000L);
+                if (timeIdle >= minIdleSwap) {
                     if (session.accessCount != null &&
                             session.accessCount.get() > 0) {
                         // Session is currently being accessed - skip it
@@ -994,14 +994,14 @@ public abstract class PersistentManagerBase extends ManagerBase
                 synchronized (session) {
                     if (!session.isValid())
                         continue;
-                    long lastAccessedTime = session.getLastAccessedTime();
+                    long lastAccessedTime = session.getLastAccessedTimeInternal();
                     Long persistedLastAccessedTime =
                             (Long) session.getNote(PERSISTED_LAST_ACCESSED_TIME);
                     if (persistedLastAccessedTime != null &&
                             lastAccessedTime == persistedLastAccessedTime.longValue())
                         continue;
-                    int timeIdle = (int) (session.getIdleTime() / 1000L);
-                    if (timeIdle > maxIdleBackup) {
+                    int timeIdle = (int) (session.getIdleTimeInternal() / 1000L);
+                    if (timeIdle >= maxIdleBackup) {
                         if (log.isDebugEnabled())
                             log.debug(sm.getString
                                 ("persistentManager.backupMaxIdle",

==================================================
