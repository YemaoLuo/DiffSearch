7e7f717c4d7d5cd68b3e8a83def0c921ca9e70a9
==================================================
Revert r1609326 as it contained fixes for multiple separate issues
==================================================
Mark Emlyn
==================================================
Wed Jul 9 22:08:17 2014 +0000
==================================================
SignCode.java
Revert r1609326 as it contained fixes for multiple separate issues

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1609327 13f79535-47bb-0310-9956-ffa450edef68



==================================================
BaseGenericObjectPool.java
index 6250ff5c1b..55e896e384 100644
--- a/java/org/apache/tomcat/buildutil/SignCode.java
+++ b/java/org/apache/tomcat/buildutil/SignCode.java
@@ -16,34 +16,14 @@
 */
 package org.apache.tomcat.buildutil;
 
-import java.io.ByteArrayOutputStream;
 import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipOutputStream;
 
-import javax.xml.soap.MessageFactory;
-import javax.xml.soap.SOAPBody;
-import javax.xml.soap.SOAPConnection;
-import javax.xml.soap.SOAPConnectionFactory;
-import javax.xml.soap.SOAPConstants;
-import javax.xml.soap.SOAPElement;
-import javax.xml.soap.SOAPEnvelope;
-import javax.xml.soap.SOAPException;
-import javax.xml.soap.SOAPMessage;
-import javax.xml.soap.SOAPPart;
-
-import org.apache.tomcat.util.codec.binary.Base64;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.FileSet;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
 
 /**
  * Ant task that submits a file to the Symantec code-signing service.
@@ -52,9 +32,6 @@ public class SignCode extends Task {
 
     private final List<FileSet> filesets = new ArrayList<>();
 
-    private static String USERNAME = "AOOAPI";
-    private static String PASSWORD = "Demo1234!";
-    private static String PARTNERCODE = "4615797APA95264";
 
     public void addFileset(FileSet fileset) {
         filesets.add(fileset);
@@ -76,151 +53,9 @@ public class SignCode extends Task {
                 for (int i = 0; i < files.length; i++) {
                     File file = new File(basedir, files[i]);
                     filesToSign.add(file);
+                    log("TODO: Sign " + file.getAbsolutePath());
                 }
             }
         }
-
-        try {
-            // Construct the signing request
-            log("Constructing the code signing request");
-
-            // Create the SOAP message
-            MessageFactory factory = MessageFactory.newInstance(SOAPConstants.SOAP_1_1_PROTOCOL);
-            SOAPMessage message = factory.createMessage();
-
-            // Populate envelope
-            SOAPPart soapPart = message.getSOAPPart();
-            SOAPEnvelope envelope = soapPart.getEnvelope();
-            envelope.addNamespaceDeclaration("soapenv","http://schemas.xmlsoap.org/soap/envelope/");
-            envelope.addNamespaceDeclaration("cod","http://api.ws.symantec.com/webtrust/codesigningservice");
-
-            SOAPBody body = envelope.getBody();
-
-            SOAPElement requestSigning =
-                    body.addChildElement("requestSigning", "cod");
-
-            SOAPElement requestSigningRequest =
-                    requestSigning.addChildElement("requestSigningRequest", "cod");
-
-            SOAPElement authToken = requestSigningRequest.addChildElement("authToken", "cod");
-            SOAPElement userName = authToken.addChildElement("userName", "cod");
-            userName.addTextNode(USERNAME);
-            SOAPElement password = authToken.addChildElement("password", "cod");
-            password.addTextNode(PASSWORD);
-            SOAPElement partnerCode = authToken.addChildElement("partnerCode", "cod");
-            partnerCode.addTextNode(PARTNERCODE);
-
-            SOAPElement applicationName =
-                    requestSigningRequest.addChildElement("applicationName", "cod");
-            applicationName.addTextNode("Apache Tomcat");
-
-            SOAPElement applicationVersion =
-                    requestSigningRequest.addChildElement("applicationVersion", "cod");
-            applicationVersion.addTextNode("8.0.x trunk");
-
-            SOAPElement signingServiceName =
-                    requestSigningRequest.addChildElement("signingServiceName", "cod");
-            signingServiceName.addTextNode("Microsoft Signing");
-
-            SOAPElement commaDelimitedFileNames =
-                    requestSigningRequest.addChildElement("commaDelimitedFileNames", "cod");
-            commaDelimitedFileNames.addTextNode(getFileNames(filesToSign.size()));
-
-            SOAPElement application =
-                    requestSigningRequest.addChildElement("application", "cod");
-            application.addTextNode(getApplicationString(filesToSign));
-
-            // Send the message
-            SOAPConnectionFactory soapConnectionFactory = SOAPConnectionFactory.newInstance();
-            SOAPConnection connection = soapConnectionFactory.createConnection();
-            java.net.URL endpoint = new URL("https://test-api.ws.symantec.com:443/webtrust/SigningService");
-
-            log("Sending siging request to server and waiting for reponse");
-            SOAPMessage response = connection.call(message, endpoint);
-
-            log("Processing response");
-            SOAPElement responseBody = response.getSOAPBody();
-            log(responseBody.getTextContent());
-
-            // Should come back signed
-            NodeList bodyNodes = responseBody.getChildNodes();
-            NodeList requestSigningResponseNodes = bodyNodes.item(0).getChildNodes();
-            NodeList returnNodes = requestSigningResponseNodes.item(0).getChildNodes();
-
-            String signingSetID = null;
-            String signingSetStatus = null;
-
-            for (int i = 0; i < returnNodes.getLength(); i++) {
-                Node returnNode = returnNodes.item(i);
-                if (returnNode.getLocalName().equals("signingSetID")) {
-                    signingSetID = returnNode.getTextContent();
-                } else if (returnNode.getLocalName().equals("signingSetStatus")) {
-                    signingSetStatus = returnNode.getTextContent();
-                }
-            }
-
-            if (!"SIGNED".equals(signingSetStatus)) {
-                throw new BuildException("Signing failed. Status was: " + signingSetStatus);
-            }
-
-            log("TODO: Download signingSet: " + signingSetID);
-
-
-        } catch (SOAPException | IOException e) {
-            throw new BuildException(e);
-        }
-    }
-
-    /**
-     * Signing service requires unique files names. Since files will be returned
-     * in order, use dummy names that we know are unique.
-     */
-    private String getFileNames(int fileCount) {
-        StringBuilder sb = new StringBuilder();
-
-        boolean first = true;
-
-        for (int i = 0; i < fileCount; i++) {
-            if (first) {
-                first = false;
-            } else {
-                sb.append(',');
-            }
-            sb.append(Integer.toString(i));
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Zips the files, base 64 encodes the resulting zip and then returns the
-     * string. It would be far more efficient to stream this directly to the
-     * signing server but the files that need to be signed are relatively small
-     * and this simpler to write.
-     *
-     * @param files Files to be signed
-     */
-    private String getApplicationString(List<File> files) throws IOException {
-        // 10 MB should be more than enough for Tomcat
-        ByteArrayOutputStream baos = new ByteArrayOutputStream(10 * 1024 * 1024);
-        try (ZipOutputStream zos = new ZipOutputStream(baos)) {
-
-            byte[] buf = new byte[32 * 1024];
-
-            for (int i = 0; i < files.size() ; i++) {
-                try (FileInputStream fis = new FileInputStream(files.get(i))) {
-                    ZipEntry zipEntry = new ZipEntry(Integer.toString(i));
-                    zos.putNextEntry(zipEntry);
-
-                    int numRead;
-                    while ( (numRead = fis.read(buf) ) >= 0) {
-                        zos.write(buf, 0, numRead);
-                    }
-                }
-            }
-        }
-
-        log("" + baos.size());
-
-        return Base64.encodeBase64String(baos.toByteArray());
     }
 }

==================================================
BaseObjectPoolConfig.java
index 1d91ca3e60..264c53f52b 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/BaseGenericObjectPool.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/BaseGenericObjectPool.java
@@ -63,7 +63,6 @@ public abstract class BaseGenericObjectPool<T> {
     private volatile long maxWaitMillis =
             BaseObjectPoolConfig.DEFAULT_MAX_WAIT_MILLIS;
     private volatile boolean lifo = BaseObjectPoolConfig.DEFAULT_LIFO;
-    private final boolean fairness;
     private volatile boolean testOnCreate =
             BaseObjectPoolConfig.DEFAULT_TEST_ON_CREATE;
     private volatile boolean testOnBorrow =
@@ -136,7 +135,6 @@ public abstract class BaseGenericObjectPool<T> {
 
         // save the current CCL to be used later by the evictor Thread
         factoryClassLoader = Thread.currentThread().getContextClassLoader();
-        fairness = config.getFairness();
     }
 
 
@@ -249,17 +247,6 @@ public abstract class BaseGenericObjectPool<T> {
     public final boolean getLifo() {
         return lifo;
     }
-    
-    /**
-     * Returns whether or not the pool serves threads waiting to borrow objects fairly.
-     * True means that waiting threads are served as if waiting in a FIFO queue.
-     *
-     * @return <code>true</code> if waiting threads are to be served
-     *             by the pool in arrival order
-     */
-    public final boolean getFairness() {
-        return fairness;
-    }
 
     /**
      * Sets whether the pool has LIFO (last in, first out) behaviour with

==================================================
GenericKeyedObjectPool.java
index 2786efa775..95386bb8bd 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/BaseObjectPoolConfig.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/BaseObjectPoolConfig.java
@@ -33,13 +33,6 @@ public abstract class BaseObjectPoolConfig implements Cloneable {
      * @see GenericKeyedObjectPool#getLifo()
      */
     public static final boolean DEFAULT_LIFO = true;
-    
-    /**
-     * The default value for the {@code fairness} configuration attribute.
-     * @see GenericObjectPool#getFairness()
-     * @see GenericKeyedObjectPool#getFairness()
-     */
-    public static final boolean DEFAULT_FAIRNESS = false;
 
     /**
      * The default value for the {@code maxWait} configuration attribute.
@@ -153,8 +146,6 @@ public abstract class BaseObjectPoolConfig implements Cloneable {
 
 
     private boolean lifo = DEFAULT_LIFO;
-    
-    private boolean fairness = DEFAULT_FAIRNESS;
 
     private long maxWaitMillis = DEFAULT_MAX_WAIT_MILLIS;
 
@@ -203,20 +194,6 @@ public abstract class BaseObjectPoolConfig implements Cloneable {
     public boolean getLifo() {
         return lifo;
     }
-    
-    /**
-     * Get the value for the {@code fairness} configuration attribute for pools
-     * created with this configuration instance.
-     *
-     * @return  The current setting of {@code fairness} for this configuration
-     *          instance
-     *
-     * @see GenericObjectPool#getFairness()
-     * @see GenericKeyedObjectPool#getFairness()
-     */
-    public boolean getFairness() {
-        return fairness;
-    }
 
     /**
      * Set the value for the {@code lifo} configuration attribute for pools
@@ -231,20 +208,6 @@ public abstract class BaseObjectPoolConfig implements Cloneable {
     public void setLifo(boolean lifo) {
         this.lifo = lifo;
     }
-    
-    /**
-     * Set the value for the {@code fairness} configuration attribute for pools
-     * created with this configuration instance.
-     *
-     * @param fairness The new setting of {@code fairness}
-     *        for this configuration instance
-     *
-     * @see GenericObjectPool#getFairness()
-     * @see GenericKeyedObjectPool#getFairness()
-     */
-    public void setFairness(boolean fairness) {
-        this.fairness = fairness;
-    }
 
     /**
      * Get the value for the {@code maxWait} configuration attribute for pools

==================================================
GenericKeyedObjectPoolMXBean.java
index a947cecc24..e1b0d05039 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java
@@ -103,7 +103,6 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
             throw new IllegalArgumentException("factory may not be null");
         }
         this.factory = factory;
-        this.fairness = config.getFairness();
 
         setConfig(config);
 
@@ -341,7 +340,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
         boolean blockWhenExhausted = getBlockWhenExhausted();
 
         boolean create;
-        long waitTime = System.currentTimeMillis();
+        long waitTime = 0;
         ObjectDeque<T> objectDeque = register(key);
 
         try {
@@ -357,8 +356,10 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
                         if (borrowMaxWaitMillis < 0) {
                             p = objectDeque.getIdleObjects().takeFirst();
                         } else {
+                            waitTime = System.currentTimeMillis();
                             p = objectDeque.getIdleObjects().pollFirst(
                                     borrowMaxWaitMillis, TimeUnit.MILLISECONDS);
+                            waitTime = System.currentTimeMillis() - waitTime;
                         }
                     }
                     if (p == null) {
@@ -430,7 +431,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
             deregister(key);
         }
 
-        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
+        updateStatsBorrow(p, waitTime);
 
         return p.getObject();
     }
@@ -533,12 +534,6 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
             } else {
                 idleObjects.addLast(p);
             }
-            if (isClosed()) {
-                // Pool closed while object was being added to idle objects.
-                // Make sure the returned object is destroyed rather than left
-                // in the idle object pool (which would effectively be a leak)
-                clear(key);
-            }
         }
 
         if (hasBorrowWaiters()) {
@@ -1088,7 +1083,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
                 lock.lock();
                 objectDeque = poolMap.get(k);
                 if (objectDeque == null) {
-                    objectDeque = new ObjectDeque<>(fairness);
+                    objectDeque = new ObjectDeque<>();
                     objectDeque.getNumInterested().incrementAndGet();
                     // NOTE: Keys must always be added to both poolMap and
                     //       poolKeyList at the same time while protected by
@@ -1404,7 +1399,8 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      */
     private class ObjectDeque<S> {
 
-        private final LinkedBlockingDeque<PooledObject<S>> idleObjects;
+        private final LinkedBlockingDeque<PooledObject<S>> idleObjects =
+                new LinkedBlockingDeque<>();
 
         /*
          * Number of instances created - number destroyed.
@@ -1428,15 +1424,6 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
          */
         private final AtomicLong numInterested = new AtomicLong(0);
 
-        /**
-         * Create a new ObjecDeque with the given fairness policy.
-         * @param fairness true means client threads waiting to borrow / return instances
-         * will be served as if waiting in a FIFO queue.
-         */
-        public ObjectDeque(boolean fairness) {
-            idleObjects = new LinkedBlockingDeque<>(fairness);
-        }
-
         /**
          * Obtain the idle objects for the current key.
          *
@@ -1483,7 +1470,6 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
     private volatile int maxTotalPerKey =
         GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL_PER_KEY;
     private final KeyedPooledObjectFactory<K,T> factory;
-    private final boolean fairness;
 
 
     //--- internal attributes --------------------------------------------------

==================================================
GenericObjectPool.java
index 2d29dfe515..9756c8e0ad 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPoolMXBean.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPoolMXBean.java
@@ -40,11 +40,6 @@ public interface GenericKeyedObjectPoolMXBean<K> {
      * @return See {@link GenericKeyedObjectPool#getBlockWhenExhausted()}
      */
     boolean getBlockWhenExhausted();
-    /**
-     * See {@link GenericKeyedObjectPool#getFairness()}
-     * @return See {@link GenericKeyedObjectPool#getFairness()}
-     */
-    boolean getFairness();
     /**
      * See {@link GenericKeyedObjectPool#getLifo()}
      * @return See {@link GenericKeyedObjectPool#getLifo()}

==================================================
GenericObjectPoolMXBean.java
index 69e3119a8c..15725b6f70 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java
@@ -109,8 +109,6 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
         }
         this.factory = factory;
 
-        idleObjects = new LinkedBlockingDeque<>(config.getFairness());
-
         setConfig(config);
 
         startEvictor(getTimeBetweenEvictionRunsMillis());
@@ -422,7 +420,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
         boolean blockWhenExhausted = getBlockWhenExhausted();
 
         boolean create;
-        long waitTime = System.currentTimeMillis();
+        long waitTime = 0;
 
         while (p == null) {
             create = false;
@@ -436,8 +434,10 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
                     if (borrowMaxWaitMillis < 0) {
                         p = idleObjects.takeFirst();
                     } else {
+                        waitTime = System.currentTimeMillis();
                         p = idleObjects.pollFirst(borrowMaxWaitMillis,
                                 TimeUnit.MILLISECONDS);
+                        waitTime = System.currentTimeMillis() - waitTime;
                     }
                 }
                 if (p == null) {
@@ -506,7 +506,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
             }
         }
 
-        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
+        updateStatsBorrow(p, waitTime);
 
         return p.getObject();
     }
@@ -607,12 +607,6 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
             } else {
                 idleObjects.addLast(p);
             }
-            if (isClosed()) {
-                // Pool closed while object was being added to idle objects.
-                // Make sure the returned object is destroyed rather than left
-                // in the idle object pool (which would effectively be a leak)
-                clear();
-            }
         }
         updateStatsReturn(activeTime);
     }
@@ -909,12 +903,6 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
                 idleObjects.addLast(p);
             }
         }
-        if (isClosed()) {
-            // Pool closed while object was being added to idle objects.
-            // Make sure the returned object is destroyed rather than left
-            // in the idle object pool (which would effectively be a leak)
-            clear();
-        }
     }
 
     /**
@@ -1109,7 +1097,8 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      * {@link #_maxActive} objects created at any one time.
      */
     private final AtomicLong createCount = new AtomicLong(0);
-    private final LinkedBlockingDeque<PooledObject<T>> idleObjects;
+    private final LinkedBlockingDeque<PooledObject<T>> idleObjects =
+        new LinkedBlockingDeque<>();
 
     // JMX specific attributes
     private static final String ONAME_BASE =

==================================================
InterruptibleReentrantLock.java
index 064220a433..788bdf9b9c 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPoolMXBean.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPoolMXBean.java
@@ -41,11 +41,6 @@ public interface GenericObjectPoolMXBean {
      * See {@link GenericObjectPool#getLifo()}
      * @return See {@link GenericObjectPool#getLifo()}
      */
-    boolean getFairness();  
-    /**
-     * See {@link GenericObjectPool#getFairness()}
-     * @return See {@link GenericObjectPool#getFairness()}
-     */
     boolean getLifo();
     /**
      * See {@link GenericObjectPool#getMaxIdle()}

==================================================
LinkedBlockingDeque.java
index dbd22f482f..a31ce2a644 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/InterruptibleReentrantLock.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/InterruptibleReentrantLock.java
@@ -33,16 +33,6 @@ class InterruptibleReentrantLock extends ReentrantLock {
 
     private static final long serialVersionUID = 1L;
 
-    /**
-     * Create a new InterruptibleReentrantLock with the given fairness policy.
-     * 
-     * @param fairness true means threads should acquire contended locks as if
-     * waiting in a FIFO queue
-     */
-    public InterruptibleReentrantLock(boolean fairness) {
-        super(fairness);
-    }
-
     /**
      * Interrupt the threads that are waiting on a specific condition
      *

==================================================
