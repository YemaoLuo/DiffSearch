9b7c05434c490e2c3bf823a806612fe2aeb764fa
==================================================
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=57324
==================================================
Mark Thomas
==================================================
Mon Dec 15 11:41:49 2014 +0000
==================================================
AbstractHttp11Processor.java
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=57324
If it is known that the connection is going to be closed when committing the response, send the connection: close header.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1645626 13f79535-47bb-0310-9956-ffa450edef68



==================================================
TomcatBaseTest.java
index 367ce6cfaa..2aaec401fd 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Processor.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Processor.java
@@ -1098,16 +1098,11 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
                     // input. This way uploading a 100GB file doesn't tie up the
                     // thread if the servlet has rejected it.
                     getInputBuffer().setSwallowInput(false);
-                } else if (expectation &&
-                        (response.getStatus() < 200 || response.getStatus() > 299)) {
-                    // Client sent Expect: 100-continue but received a
-                    // non-2xx final response. Disable keep-alive (if enabled)
-                    // to ensure that the connection is closed. Some clients may
-                    // still send the body, some may send the next request.
-                    // No way to differentiate, so close the connection to
-                    // force the client to send the next request.
-                    getInputBuffer().setSwallowInput(false);
-                    keepAlive = false;
+                } else {
+                    // Need to check this again here in case the response was
+                    // committed before the error that requires the connection
+                    // to be closed occurred.
+                    checkExpectationAndResponseStatus();
                 }
                 endRequest();
             }
@@ -1169,6 +1164,20 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
     }
 
 
+    private void checkExpectationAndResponseStatus() {
+        if (expectation && (response.getStatus() < 200 || response.getStatus() > 299)) {
+            // Client sent Expect: 100-continue but received a
+            // non-2xx final response. Disable keep-alive (if enabled)
+            // to ensure that the connection is closed. Some clients may
+            // still send the body, some may send the next request.
+            // No way to differentiate, so close the connection to
+            // force the client to send the next request.
+            getInputBuffer().setSwallowInput(false);
+            keepAlive = false;
+        }
+    }
+
+
     /**
      * After reading the request headers, we have to setup the request filters.
      */
@@ -1493,6 +1502,10 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
             keepAlive = false;
         }
 
+        // This may disabled keep-alive to check before working out the
+        // Connection header.
+        checkExpectationAndResponseStatus();
+
         // If we know that the request is bad this early, add the
         // Connection: close header.
         keepAlive = keepAlive && !statusDropsConnection(statusCode);

==================================================
TestAbstractHttp11Processor.java
index b777fbe749..c6900dba28 100644
--- a/test/org/apache/catalina/startup/TomcatBaseTest.java
+++ b/test/org/apache/catalina/startup/TomcatBaseTest.java
@@ -565,6 +565,37 @@ public abstract class TomcatBaseTest extends LoggingBaseTest {
     }
 
 
+    /**
+     * Servlet that simply echos the request body back as the response body.
+     */
+    public static class EchoBodyServlet extends HttpServlet {
+
+        private static final long serialVersionUID = 1L;
+
+        @Override
+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+                throws ServletException, IOException {
+            // NO-OP - No body to echo
+        }
+
+        @Override
+        protected void doPost(HttpServletRequest req, HttpServletResponse resp)
+                throws ServletException, IOException {
+            // Beware of clients that try to send the whole request body before
+            // reading any of the response. They may cause this test to lock up.
+            byte[] buffer = new byte[8096];
+            int read = 0;
+            try (InputStream is = req.getInputStream();
+                    OutputStream os = resp.getOutputStream()) {
+                while (read > -1) {
+                    os.write(buffer, 0, read);
+                    read = is.read(buffer);
+                }
+            }
+        }
+    }
+
+
     /*
      *  Wrapper for getting the response.
      */

==================================================
