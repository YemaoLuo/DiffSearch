25e5e86e6b6d4e92c2f5da9674e223f33fa55405
==================================================
Refactor the utility scheduled executor from the Service to the Server as I got a usecase for ha.backend.HeartbeatListener as a Server listener.
==================================================
Remy Maucherat
==================================================
Wed Nov 28 12:55:32 2018 +0000
==================================================
Server.java
Refactor the utility scheduled executor from the Service to the Server as I got a usecase for ha.backend.HeartbeatListener as a Server listener.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1847635 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Service.java
index 52e591494d..934f4da83d 100644
--- a/java/org/apache/catalina/Server.java
+++ b/java/org/apache/catalina/Server.java
@@ -19,6 +19,7 @@
 package org.apache.catalina;
 
 import java.io.File;
+import java.util.concurrent.ScheduledExecutorService;
 
 import org.apache.catalina.deploy.NamingResourcesImpl;
 import org.apache.catalina.startup.Catalina;
@@ -204,6 +205,20 @@ public interface Server extends Lifecycle {
     public void setCatalinaHome(File catalinaHome);
 
 
+    /**
+     * Get the utility thread count.
+     * @return the thread count
+     */
+    public int getUtilityThreads();
+
+
+    /**
+     * Set the utility thread count.
+     * @param utilityThreads the new thread count
+     */
+    public void setUtilityThreads(int utilityThreads);
+
+
     // --------------------------------------------------------- Public Methods
 
 
@@ -250,4 +265,10 @@ public interface Server extends Lifecycle {
      * context.
      */
     public Object getNamingToken();
+
+    /**
+     * @return the utility executor managed by the Service.
+     */
+    public ScheduledExecutorService getUtilityExecutor();
+
 }

==================================================
Connector.java
index a9fbcf3b2b..112df9d9c2 100644
--- a/java/org/apache/catalina/Service.java
+++ b/java/org/apache/catalina/Service.java
@@ -18,8 +18,6 @@
 
 package org.apache.catalina;
 
-import java.util.concurrent.ScheduledExecutorService;
-
 import org.apache.catalina.connector.Connector;
 import org.apache.catalina.mapper.Mapper;
 
@@ -98,20 +96,6 @@ public interface Service extends Lifecycle {
     public String getDomain();
 
 
-    /**
-     * Get the utility thread count.
-     * @return the thread count
-     */
-    public int getUtilityThreads();
-
-
-    /**
-     * Set the utility thread count.
-     * @param utilityThreads the new thread count
-     */
-    public void setUtilityThreads(int utilityThreads);
-
-
     // --------------------------------------------------------- Public Methods
 
     /**
@@ -168,9 +152,4 @@ public interface Service extends Lifecycle {
      */
     Mapper getMapper();
 
-    /**
-     * @return the utility executor managed by the Service.
-     */
-    ScheduledExecutorService getUtilityExecutor();
-
 }

==================================================
ContainerBase.java
index 98baec8fdd..31b85f52cf 100644
--- a/java/org/apache/catalina/connector/Connector.java
+++ b/java/org/apache/catalina/connector/Connector.java
@@ -949,7 +949,7 @@ public class Connector extends LifecycleMBeanBase  {
         adapter = new CoyoteAdapter(this);
         protocolHandler.setAdapter(adapter);
         if (service != null) {
-            protocolHandler.setUtilityExecutor(service.getUtilityExecutor());
+            protocolHandler.setUtilityExecutor(service.getServer().getUtilityExecutor());
         }
 
         // Make sure parseBodyMethodsSet has a default

==================================================
StandardServer.java
index a253b2e3fc..5327e19b1b 100644
--- a/java/org/apache/catalina/core/LocalStrings.properties
+++ b/java/org/apache/catalina/core/LocalStrings.properties
@@ -221,6 +221,7 @@ standardHostValue.customStatusFailed=Custom error page [{0}] could not be dispat
 
 standardServer.accept.timeout=The socket listening for the shutdown command experienced an unexpected timeout [{0}] milliseconds after the call to accept(). Is this an instance of bug 56684?
 standardServer.awaitSocket.fail=Failed to create server shutdown socket on address [{0}] and port [{1}] (base port [{2}] and offset [{3}])
+standardServer.periodicEventError=Error sending periodic event
 standardServer.portOffset.invalid=The value [{0}] for portOffset is not valid as portOffset may not be negative
 standardServer.shutdownViaPort=A valid shutdown command was received via the shutdown port. Stopping the Server instance.
 standardServer.storeConfig.notAvailable=No StoreConfig implementation was registered as an MBean named [{0}] so no configuration could be saved. A suitable MBean is normally registered via the StoreConfigLifecycleListener.

==================================================
StandardService.java
index c0703420e4..a54434daf5 100644
--- a/java/org/apache/catalina/core/StandardServer.java
+++ b/java/org/apache/catalina/core/StandardServer.java
@@ -30,12 +30,18 @@ import java.net.URL;
 import java.net.URLClassLoader;
 import java.security.AccessControlException;
 import java.util.Random;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 
 import javax.management.InstanceNotFoundException;
 import javax.management.MBeanException;
 import javax.management.ObjectName;
 
 import org.apache.catalina.Context;
+import org.apache.catalina.Lifecycle;
 import org.apache.catalina.LifecycleException;
 import org.apache.catalina.LifecycleState;
 import org.apache.catalina.Server;
@@ -51,6 +57,7 @@ import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.buf.StringCache;
 import org.apache.tomcat.util.res.StringManager;
+import org.apache.tomcat.util.threads.TaskThreadFactory;
 
 
 /**
@@ -175,6 +182,39 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
 
     private final Object namingToken = new Object();
 
+    /**
+     * The number of threads available to process utility tasks in this service.
+     */
+    protected int utilityThreads = 1;
+
+    /**
+     * The utility threads daemon flag.
+     */
+    protected boolean utilityThreadsAsDaemon = false;
+
+    /**
+     * Utility executor with scheduling capabilities.
+     */
+    private ScheduledThreadPoolExecutor utilityExecutor = null;
+
+    /**
+     * Utility executor wrapper.
+     */
+    private ScheduledExecutorService utilityExecutorWrapper = null;
+
+
+    /**
+     * Controller for the periodic lifecycle event.
+     */
+    private ScheduledFuture<?> periodicLifecycleEventFuture = null;
+    private ScheduledFuture<?> monitorFuture;
+
+
+    /**
+     * The event period.
+     */
+    protected int eventPeriod = 10;
+
 
     // ------------------------------------------------------------- Properties
 
@@ -364,6 +404,99 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
         this.catalina = catalina;
     }
 
+
+    @Override
+    public int getUtilityThreads() {
+        return utilityThreads;
+    }
+
+
+    /**
+     * Handles the special values.
+     */
+    private static int getUtilityThreadsInternal(int utilityThreads) {
+        int result = utilityThreads;
+        if (result > 0) {
+            return result;
+        }
+
+        // Zero == Runtime.getRuntime().availableProcessors() / 2
+        // -ve  == Runtime.getRuntime().availableProcessors() / 2 + value
+        // These two are the same
+        result = (Runtime.getRuntime().availableProcessors() / 2) + result;
+        if (result < 1) {
+            result = 1;
+        }
+        return result;
+    }
+
+    @Override
+    public void setUtilityThreads(int utilityThreads) {
+        if (getUtilityThreadsInternal(utilityThreads) < getUtilityThreadsInternal(this.utilityThreads)) {
+            return;
+        }
+        int oldUtilityThreads = this.utilityThreads;
+        this.utilityThreads = utilityThreads;
+
+        // Use local copies to ensure thread safety
+        if (oldUtilityThreads != utilityThreads && utilityExecutor != null) {
+            reconfigureUtilityExecutor(getUtilityThreadsInternal(utilityThreads));
+        }
+    }
+
+
+    private synchronized void reconfigureUtilityExecutor(int threads) {
+        // The ScheduledThreadPoolExecutor doesn't use MaximumPoolSize, only CorePoolSize is available
+        if (utilityExecutor != null) {
+            utilityExecutor.setCorePoolSize(threads);
+        } else {
+            ScheduledThreadPoolExecutor scheduledThreadPoolExecutor =
+                    new ScheduledThreadPoolExecutor(threads,
+                            new TaskThreadFactory("Catalina-utility-", utilityThreadsAsDaemon, Thread.NORM_PRIORITY));
+            scheduledThreadPoolExecutor.setKeepAliveTime(10, TimeUnit.SECONDS);
+            scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true);
+            scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
+            utilityExecutor = scheduledThreadPoolExecutor;
+            utilityExecutorWrapper = new org.apache.tomcat.util.threads.ScheduledThreadPoolExecutor(utilityExecutor);
+        }
+    }
+
+
+    /**
+     * Get if the utility threads are daemon threads.
+     * @return the threads daemon flag
+     */
+    public boolean getUtilityThreadsAsDaemon() {
+        return utilityThreadsAsDaemon;
+    }
+
+
+    /**
+     * Set the utility threads daemon flag. The default value is true.
+     * @param utilityThreadsAsDaemon the new thread daemon flag
+     */
+    public void setUtilityThreadsAsDaemon(boolean utilityThreadsAsDaemon) {
+        this.utilityThreadsAsDaemon = utilityThreadsAsDaemon;
+    }
+
+
+    /**
+     * @return The period between two events, in seconds
+     */
+    public int getEventPeriod() {
+        return eventPeriod;
+    }
+
+
+    /**
+     * Set the new period between two events.
+     * @param eventPeriod The period in seconds, <= 0 disables events
+     */
+    public final void setEventPeriod(int eventPeriod) {
+        this.eventPeriod = eventPeriod;
+    }
+
+
     // --------------------------------------------------------- Server Methods
 
 
@@ -801,6 +934,37 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
                 services[i].start();
             }
         }
+
+        if (eventPeriod > 0) {
+            monitorFuture = getUtilityExecutor().scheduleWithFixedDelay(
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            startPeriodicLifecycleEvent();
+                        }
+                    }, 0, 60, TimeUnit.SECONDS);
+        }
+    }
+
+
+    protected void startPeriodicLifecycleEvent() {
+        if (periodicLifecycleEventFuture == null || (periodicLifecycleEventFuture != null && periodicLifecycleEventFuture.isDone())) {
+            if (periodicLifecycleEventFuture != null && periodicLifecycleEventFuture.isDone()) {
+                // There was an error executing the scheduled task, get it and log it
+                try {
+                    periodicLifecycleEventFuture.get();
+                } catch (InterruptedException | ExecutionException e) {
+                    log.error(sm.getString("standardServer.periodicEventError"), e);
+                }
+            }
+            periodicLifecycleEventFuture = getUtilityExecutor().scheduleAtFixedRate(
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            fireLifecycleEvent(Lifecycle.PERIODIC_EVENT, null);
+                        }
+                    }, eventPeriod, eventPeriod, TimeUnit.SECONDS);
+        }
     }
 
 
@@ -815,6 +979,16 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
     protected void stopInternal() throws LifecycleException {
 
         setState(LifecycleState.STOPPING);
+
+        if (monitorFuture != null) {
+            monitorFuture.cancel(true);
+            monitorFuture = null;
+        }
+        if (periodicLifecycleEventFuture != null) {
+            periodicLifecycleEventFuture.cancel(false);
+            periodicLifecycleEventFuture = null;
+        }
+
         fireLifecycleEvent(CONFIGURE_STOP_EVENT, null);
 
         // Stop our defined Services
@@ -836,6 +1010,10 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
 
         super.initInternal();
 
+        // Initialize utility executor
+        reconfigureUtilityExecutor(getUtilityThreadsInternal(utilityThreads));
+        register(utilityExecutor, "type=UtilityExecutor");
+
         // Register global String cache
         // Note although the cache is global, if there are multiple Servers
         // present in the JVM (may happen when embedding) then the same cache
@@ -897,6 +1075,12 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
 
         unregister(onameStringCache);
 
+        if (utilityExecutor != null) {
+            utilityExecutor.shutdownNow();
+            unregister("type=UtilityExecutor");
+            utilityExecutor = null;
+        }
+
         super.destroyInternal();
     }
 
@@ -958,4 +1142,10 @@ public final class StandardServer extends LifecycleMBeanBase implements Server {
     protected final String getObjectNameKeyProperties() {
         return "type=Server";
     }
+
+    @Override
+    public ScheduledExecutorService getUtilityExecutor() {
+        return utilityExecutorWrapper;
+    }
+
 }

==================================================
SimpleTcpCluster.java
index d7cb641647..a0d55c02d3 100644
--- a/java/org/apache/catalina/core/StandardService.java
+++ b/java/org/apache/catalina/core/StandardService.java
@@ -20,9 +20,6 @@ package org.apache.catalina.core;
 import java.beans.PropertyChangeListener;
 import java.beans.PropertyChangeSupport;
 import java.util.ArrayList;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
 
 import javax.management.ObjectName;
 
@@ -41,7 +38,6 @@ import org.apache.catalina.util.LifecycleMBeanBase;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.res.StringManager;
-import org.apache.tomcat.util.threads.TaskThreadFactory;
 
 
 /**
@@ -93,26 +89,6 @@ public class StandardService extends LifecycleMBeanBase implements Service {
      */
     protected final ArrayList<Executor> executors = new ArrayList<>();
 
-    /**
-     * The number of threads available to process utility tasks in this service.
-     */
-    protected int utilityThreads = 1;
-
-    /**
-     * The utility threads daemon flag.
-     */
-    protected boolean utilityThreadsAsDaemon = false;
-
-    /**
-     * Utility executor with scheduling capabilities.
-     */
-    private ScheduledThreadPoolExecutor utilityExecutor = null;
-
-    /**
-     * Utility executor wrapper.
-     */
-    private ScheduledExecutorService utilityExecutorWrapper = null;
-
     private Engine engine = null;
 
     private ClassLoader parentClassLoader = null;
@@ -226,81 +202,6 @@ public class StandardService extends LifecycleMBeanBase implements Service {
     }
 
 
-    @Override
-    public int getUtilityThreads() {
-        return utilityThreads;
-    }
-
-
-    /**
-     * Handles the special values.
-     */
-    private static int getUtilityThreadsInternal(int utilityThreads) {
-        int result = utilityThreads;
-        if (result > 0) {
-            return result;
-        }
-
-        // Zero == Runtime.getRuntime().availableProcessors() / 2
-        // -ve  == Runtime.getRuntime().availableProcessors() / 2 + value
-        // These two are the same
-        result = (Runtime.getRuntime().availableProcessors() / 2) + result;
-        if (result < 1) {
-            result = 1;
-        }
-        return result;
-    }
-
-    @Override
-    public void setUtilityThreads(int utilityThreads) {
-        if (getUtilityThreadsInternal(utilityThreads) < getUtilityThreadsInternal(this.utilityThreads)) {
-            return;
-        }
-        int oldUtilityThreads = this.utilityThreads;
-        this.utilityThreads = utilityThreads;
-
-        // Use local copies to ensure thread safety
-        if (oldUtilityThreads != utilityThreads && utilityExecutor != null) {
-            reconfigureUtilityExecutor(getUtilityThreadsInternal(utilityThreads));
-        }
-    }
-
-
-    private synchronized void reconfigureUtilityExecutor(int threads) {
-        // The ScheduledThreadPoolExecutor doesn't use MaximumPoolSize, only CorePoolSize is available
-        if (utilityExecutor != null) {
-            utilityExecutor.setCorePoolSize(threads);
-        } else {
-            ScheduledThreadPoolExecutor scheduledThreadPoolExecutor =
-                    new ScheduledThreadPoolExecutor(threads,
-                            new TaskThreadFactory(getName() + "-utility-", utilityThreadsAsDaemon, Thread.NORM_PRIORITY));
-            scheduledThreadPoolExecutor.setKeepAliveTime(10, TimeUnit.SECONDS);
-            scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true);
-            scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
-            utilityExecutor = scheduledThreadPoolExecutor;
-            utilityExecutorWrapper = new org.apache.tomcat.util.threads.ScheduledThreadPoolExecutor(utilityExecutor);
-        }
-    }
-
-
-    /**
-     * Get if the utility threads are daemon threads.
-     * @return the threads daemon flag
-     */
-    public boolean getUtilityThreadsAsDaemon() {
-        return utilityThreadsAsDaemon;
-    }
-
-
-    /**
-     * Set the utility threads daemon flag. The default value is true.
-     * @param utilityThreadsAsDaemon the new thread daemon flag
-     */
-    public void setUtilityThreadsAsDaemon(boolean utilityThreadsAsDaemon) {
-        this.utilityThreadsAsDaemon = utilityThreadsAsDaemon;
-    }
-
-
     // --------------------------------------------------------- Public Methods
 
 
@@ -613,9 +514,6 @@ public class StandardService extends LifecycleMBeanBase implements Service {
 
         super.initInternal();
 
-        reconfigureUtilityExecutor(getUtilityThreadsInternal(utilityThreads));
-        register(utilityExecutor, "type=UtilityExecutor");
-
         if (engine != null) {
             engine.init();
         }
@@ -660,12 +558,6 @@ public class StandardService extends LifecycleMBeanBase implements Service {
             engine.destroy();
         }
 
-        if (utilityExecutor != null) {
-            utilityExecutor.shutdownNow();
-            unregister("type=UtilityExecutor");
-            utilityExecutor = null;
-        }
-
         super.destroyInternal();
     }
 
@@ -724,9 +616,4 @@ public class StandardService extends LifecycleMBeanBase implements Service {
         return "type=Service";
     }
 
-    @Override
-    public ScheduledExecutorService getUtilityExecutor() {
-        return utilityExecutorWrapper;
-    }
-
 }

==================================================
