92710ebf3299e1e55c7a377a55395a78d3cc0296
==================================================
Add missing managed package to DBCP, so that it is possible to use it with a transaction manager. The removal was not actually documented, it simply stated DBCP2 was included so no change in the docs.
==================================================
Remy Maucherat
==================================================
Fri Mar 30 14:15:56 2018 +0000
==================================================
HeuristicCommitException.java
Add missing managed package to DBCP, so that it is possible to use it with a transaction manager. The removal was not actually documented, it simply stated DBCP2 was included so no change in the docs.
The transaction manager or user code will have to provide the object factory to create the BasicManagedDataSource instance and call setTransactionManager on it.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1828065 13f79535-47bb-0310-9956-ffa450edef68



==================================================
HeuristicMixedException.java
new file mode 100644
index 0000000000..138cb6a010
--- /dev/null
+++ b/java/javax/transaction/HeuristicCommitException.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction;
+
+public class HeuristicCommitException extends java.lang.Exception {
+    public HeuristicCommitException() {
+        super();
+    }
+
+    public HeuristicCommitException(String msg) {
+        super(msg);
+    }
+}

==================================================
HeuristicRollbackException.java
new file mode 100644
index 0000000000..e183101dea
--- /dev/null
+++ b/java/javax/transaction/HeuristicMixedException.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction;
+
+public class HeuristicMixedException extends java.lang.Exception {
+    public HeuristicMixedException() {
+        super();
+    }
+
+    public HeuristicMixedException(String msg) {
+        super(msg);
+    }
+}

==================================================
InvalidTransactionException.java
new file mode 100644
index 0000000000..96691ca4eb
--- /dev/null
+++ b/java/javax/transaction/HeuristicRollbackException.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction;
+
+public class HeuristicRollbackException extends java.lang.Exception {
+    public HeuristicRollbackException() {
+        super();
+    }
+
+    public HeuristicRollbackException(String msg) {
+        super(msg);
+    }
+}

==================================================
NotSupportedException.java
new file mode 100644
index 0000000000..049ef5f0e0
--- /dev/null
+++ b/java/javax/transaction/InvalidTransactionException.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction;
+
+public class InvalidTransactionException extends java.rmi.RemoteException {
+    public InvalidTransactionException() {
+        super();
+    }
+
+    public InvalidTransactionException(String msg) {
+        super(msg);
+    }
+}

==================================================
RollbackException.java
new file mode 100644
index 0000000000..4453110e63
--- /dev/null
+++ b/java/javax/transaction/NotSupportedException.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction;
+
+public class NotSupportedException extends java.lang.Exception {
+    public NotSupportedException() {
+        super();
+    }
+
+    public NotSupportedException(String msg) {
+        super(msg);
+    }
+}

==================================================
Status.java
new file mode 100644
index 0000000000..6d9889761b
--- /dev/null
+++ b/java/javax/transaction/RollbackException.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction;
+
+public class RollbackException extends java.lang.Exception {
+    public RollbackException() {
+        super();
+    }
+
+    public RollbackException(String msg) {
+        super(msg);
+    }
+}

==================================================
Synchronization.java
new file mode 100644
index 0000000000..513f9e0dd9
--- /dev/null
+++ b/java/javax/transaction/Status.java
@@ -0,0 +1,30 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction;
+
+public interface Status {
+    public static final int STATUS_ACTIVE = 0;
+    public static final int STATUS_MARKED_ROLLBACK = 1;
+    public static final int STATUS_PREPARED = 2;
+    public static final int STATUS_COMMITTED = 3;
+    public static final int STATUS_ROLLEDBACK = 4;
+    public static final int STATUS_UNKNOWN = 5;
+    public static final int STATUS_NO_TRANSACTION = 6;
+    public static final int STATUS_PREPARING = 7;
+    public static final int STATUS_COMMITTING = 8;
+    public static final int STATUS_ROLLING_BACK = 9;
+}

==================================================
SystemException.java
new file mode 100644
index 0000000000..0b5db31587
--- /dev/null
+++ b/java/javax/transaction/Synchronization.java
@@ -0,0 +1,22 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction;
+
+public interface Synchronization {
+    public void beforeCompletion();
+    public void afterCompletion(int status);
+}

==================================================
Transaction.java
new file mode 100644
index 0000000000..f84eacddc9
--- /dev/null
+++ b/java/javax/transaction/SystemException.java
@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction;
+
+public class SystemException extends java.lang.Exception {
+
+    public int errorCode;
+
+    public SystemException() {
+        super();
+    }
+
+    public SystemException(String s) {
+        super(s);
+    }
+
+    public SystemException(int errcode) {
+        super();
+        errorCode = errcode;
+    }
+
+}

==================================================
TransactionManager.java
new file mode 100644
index 0000000000..ed1f00fbca
--- /dev/null
+++ b/java/javax/transaction/Transaction.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction;
+
+import javax.transaction.xa.XAResource;
+
+public interface Transaction {
+
+    public void commit() throws RollbackException, HeuristicMixedException,
+            HeuristicRollbackException, SecurityException,
+            IllegalStateException, SystemException;
+
+    public boolean delistResource(XAResource xaRes, int flag)
+            throws IllegalStateException, SystemException;
+
+    public boolean enlistResource(XAResource xaRes)
+            throws RollbackException, IllegalStateException, SystemException;
+
+    public int getStatus() throws SystemException;
+
+    public void registerSynchronization(Synchronization sync)
+            throws RollbackException, IllegalStateException, SystemException;
+
+    public void rollback() throws IllegalStateException, SystemException;
+
+    public void setRollbackOnly() throws IllegalStateException, SystemException;
+
+}

==================================================
TransactionRequiredException.java
new file mode 100644
index 0000000000..b2969db36e
--- /dev/null
+++ b/java/javax/transaction/TransactionManager.java
@@ -0,0 +1,41 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction;
+
+public interface TransactionManager {
+    public void begin() throws NotSupportedException, SystemException;
+
+    public void commit() throws RollbackException, HeuristicMixedException,
+            HeuristicRollbackException, SecurityException,
+            IllegalStateException, SystemException;
+
+    public int getStatus() throws SystemException;
+
+    public Transaction getTransaction() throws SystemException;
+
+    public void resume(Transaction tobj) throws InvalidTransactionException,
+            IllegalStateException, SystemException;
+
+    public void rollback()
+            throws IllegalStateException, SecurityException, SystemException;
+
+    public void setRollbackOnly() throws IllegalStateException, SystemException;
+
+    public void setTransactionTimeout(int seconds) throws SystemException;
+
+    public Transaction suspend() throws SystemException;
+}

==================================================
TransactionRolledbackException.java
new file mode 100644
index 0000000000..6b584dde5e
--- /dev/null
+++ b/java/javax/transaction/TransactionRequiredException.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction;
+
+public class TransactionRequiredException extends java.rmi.RemoteException {
+    public TransactionRequiredException() {
+        super();
+    }
+
+    public TransactionRequiredException(String msg) {
+        super(msg);
+    }
+}

==================================================
TransactionSynchronizationRegistry.java
new file mode 100644
index 0000000000..ac6f7bf905
--- /dev/null
+++ b/java/javax/transaction/TransactionRolledbackException.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction;
+
+public class TransactionRolledbackException extends java.rmi.RemoteException {
+    public TransactionRolledbackException() {
+        super();
+    }
+
+    public TransactionRolledbackException(String msg) {
+        super(msg);
+    }
+}

==================================================
UserTransaction.java
new file mode 100644
index 0000000000..9aa8daf227
--- /dev/null
+++ b/java/javax/transaction/TransactionSynchronizationRegistry.java
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction;
+
+public interface TransactionSynchronizationRegistry {
+    Object getTransactionKey();
+
+    void putResource(Object key, Object value);
+
+    Object getResource(Object key);
+
+    void registerInterposedSynchronization(Synchronization sync);
+
+    int getTransactionStatus();
+
+    void setRollbackOnly();
+
+    boolean getRollbackOnly();
+}

==================================================
XAException.java
new file mode 100644
index 0000000000..b0cce4a244
--- /dev/null
+++ b/java/javax/transaction/UserTransaction.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction;
+
+public interface UserTransaction {
+    void begin() throws NotSupportedException, SystemException;
+
+    void commit() throws RollbackException, HeuristicMixedException,
+            HeuristicRollbackException, SecurityException,
+            IllegalStateException, SystemException;
+
+    void rollback()
+            throws IllegalStateException, SecurityException, SystemException;
+
+    void setRollbackOnly() throws IllegalStateException, SystemException;
+
+    int getStatus() throws SystemException;
+
+    void setTransactionTimeout(int seconds) throws SystemException;
+}

==================================================
XAResource.java
new file mode 100644
index 0000000000..b42d9bd90b
--- /dev/null
+++ b/java/javax/transaction/xa/XAException.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction.xa;
+
+public class XAException extends java.lang.Exception {
+
+    public int errorCode;
+
+    public XAException() {
+        super();
+    }
+
+    public XAException(String s) {
+        super(s);
+    }
+
+    public XAException(int errcode) {
+        super();
+        errorCode = errcode;
+    }
+
+    public static final int XA_RBBASE = 100;
+    public static final int XA_RBROLLBACK = XA_RBBASE;
+    public static final int XA_RBCOMMFAIL = XA_RBBASE + 1;
+    public static final int XA_RBDEADLOCK = XA_RBBASE + 2;
+    public static final int XA_RBINTEGRITY = XA_RBBASE + 3;
+    public static final int XA_RBOTHER = XA_RBBASE + 4;
+    public static final int XA_RBPROTO = XA_RBBASE + 5;
+    public static final int XA_RBTIMEOUT = XA_RBBASE + 6;
+    public static final int XA_RBTRANSIENT = XA_RBBASE + 7;
+    public static final int XA_RBEND = XA_RBTRANSIENT;
+    public static final int XA_NOMIGRATE = 9;
+    public static final int XA_HEURHAZ = 8;
+    public static final int XA_HEURCOM = 7;
+    public static final int XA_HEURRB = 6;
+    public static final int XA_HEURMIX = 5;
+    public static final int XA_RETRY = 4;
+    public static final int XA_RDONLY = 3;
+    public static final int XAER_ASYNC = -2;
+    public static final int XAER_RMERR = -3;
+    public static final int XAER_NOTA = -4;
+    public static final int XAER_INVAL = -5;
+    public static final int XAER_PROTO = -6;
+    public static final int XAER_RMFAIL = -7;
+    public static final int XAER_DUPID = -8;
+    public static final int XAER_OUTSIDE = -9;
+
+}

==================================================
Xid.java
new file mode 100644
index 0000000000..c7edd36204
--- /dev/null
+++ b/java/javax/transaction/xa/XAResource.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction.xa;
+
+public interface XAResource {
+    void commit(Xid xid, boolean onePhase) throws XAException;
+
+    void end(Xid xid, int flags) throws XAException;
+
+    void forget(Xid xid) throws XAException;
+
+    int getTransactionTimeout() throws XAException;
+
+    boolean isSameRM(XAResource xares) throws XAException;
+
+    int prepare(Xid xid) throws XAException;
+
+    Xid[] recover(int flag) throws XAException;
+
+    void rollback(Xid xid) throws XAException;
+
+    boolean setTransactionTimeout(int seconds) throws XAException;
+
+    void start(Xid xid, int flags) throws XAException;
+
+    public static final int TMENDRSCAN = 0x00800000;
+    public static final int TMFAIL = 0x20000000;
+    public static final int TMJOIN = 0x00200000;
+    public static final int TMNOFLAGS = 0x00000000;
+    public static final int TMONEPHASE = 0x40000000;
+    public static final int TMRESUME = 0x08000000;
+    public static final int TMSTARTRSCAN = 0x01000000;
+    public static final int TMSUCCESS = 0x04000000;
+    public static final int TMSUSPEND = 0x02000000;
+    public static final int XA_RDONLY = 0x00000003;
+    public static final int XA_OK = 0;
+
+}

==================================================
BasicManagedDataSource.java
new file mode 100644
index 0000000000..054fd3e5ca
--- /dev/null
+++ b/java/javax/transaction/xa/Xid.java
@@ -0,0 +1,28 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.transaction.xa;
+
+public interface Xid {
+    static final int MAXGTRIDSIZE = 64;
+    static final int MAXBQUALSIZE = 64;
+
+    int getFormatId();
+
+    byte[] getGlobalTransactionId();
+
+    byte[] getBranchQualifier();
+}

==================================================
DataSourceXAConnectionFactory.java
new file mode 100644
index 0000000000..949a7833be
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/BasicManagedDataSource.java
@@ -0,0 +1,213 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2.managed;
+
+import java.sql.SQLException;
+
+import javax.sql.DataSource;
+import javax.sql.XADataSource;
+import javax.transaction.TransactionManager;
+
+import org.apache.tomcat.dbcp.dbcp2.BasicDataSource;
+import org.apache.tomcat.dbcp.dbcp2.ConnectionFactory;
+import org.apache.tomcat.dbcp.dbcp2.PoolableConnection;
+import org.apache.tomcat.dbcp.dbcp2.PoolableConnectionFactory;
+import org.apache.tomcat.dbcp.dbcp2.PoolingDataSource;
+
+/**
+ * <p>BasicManagedDataSource is an extension of BasicDataSource which
+ * creates ManagedConnections.  This data source can create either
+ * full two-phase-commit XA connections or one-phase-commit
+ * local connections.  Both types of connections are committed or
+ * rolled back as part of the global transaction (a.k.a. XA
+ * transaction or JTA Transaction), but only XA connections can be
+ * recovered in the case of a system crash.
+ * </p>
+ * <p>BasicManagedDataSource adds the TransactionManager and XADataSource
+ * properties.  The TransactionManager property is required and is
+ * used to enlist connections in global transactions.  The XADataSource
+ * is optional and if set is the class name of the XADataSource class
+ * for a two-phase-commit JDBC driver.  If the XADataSource property
+ * is set, the driverClassName is ignored and a DataSourceXAConnectionFactory
+ * is created. Otherwise, a standard DriverConnectionFactory is created
+ * and wrapped with a LocalXAConnectionFactory.
+ * </p>
+ *
+ * @see BasicDataSource
+ * @see ManagedConnection
+ * @since 2.0
+ */
+public class BasicManagedDataSource extends BasicDataSource {
+    /** Transaction Registry */
+    private TransactionRegistry transactionRegistry;
+    /** Transaction Manager */
+    private transient TransactionManager transactionManager;
+    /** XA datasource class name */
+    private String xaDataSource;
+    /** XA datasource instance */
+    private XADataSource xaDataSourceInstance;
+
+    /**
+     * Gets the XADataSource instance used by the XAConnectionFactory.
+     *
+     * @return the XADataSource
+     */
+    public synchronized XADataSource getXaDataSourceInstance() {
+        return xaDataSourceInstance;
+    }
+
+    /**
+     * <p>Sets the XADataSource instance used by the XAConnectionFactory.</p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been
+     * initialized.  The pool is initialized the first time one of the
+     * following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     *
+     * @param xaDataSourceInstance XADataSource instance
+     */
+    public synchronized void setXaDataSourceInstance(final XADataSource xaDataSourceInstance) {
+        this.xaDataSourceInstance = xaDataSourceInstance;
+        xaDataSource = xaDataSourceInstance == null ? null : xaDataSourceInstance.getClass().getName();
+    }
+
+    /**
+     * Gets the required transaction manager property.
+     * @return the transaction manager used to enlist connections
+     */
+    public TransactionManager getTransactionManager() {
+        return transactionManager;
+    }
+
+    /**
+     * Gets the transaction registry.
+     * @return the transaction registry associating XAResources with managed connections
+     */
+    protected synchronized TransactionRegistry getTransactionRegistry() {
+        return transactionRegistry;
+    }
+
+    /**
+     * Sets the required transaction manager property.
+     * @param transactionManager the transaction manager used to enlist connections
+     */
+    public void setTransactionManager(final TransactionManager transactionManager) {
+        this.transactionManager = transactionManager;
+    }
+
+    /**
+     * Gets the optional XADataSource class name.
+     * @return the optional XADataSource class name
+     */
+    public synchronized String getXADataSource() {
+        return xaDataSource;
+    }
+
+    /**
+     * Sets the optional XADataSource class name.
+     * @param xaDataSource the optional XADataSource class name
+     */
+    public synchronized void setXADataSource(final String xaDataSource) {
+        this.xaDataSource = xaDataSource;
+    }
+
+    @Override
+    protected ConnectionFactory createConnectionFactory() throws SQLException {
+        if (transactionManager == null) {
+            throw new SQLException("Transaction manager must be set before a connection can be created");
+        }
+
+        // If xa data source is not specified a DriverConnectionFactory is created and wrapped with a LocalXAConnectionFactory
+        if (xaDataSource == null) {
+            final ConnectionFactory connectionFactory = super.createConnectionFactory();
+            final XAConnectionFactory xaConnectionFactory = new LocalXAConnectionFactory(getTransactionManager(), connectionFactory);
+            transactionRegistry = xaConnectionFactory.getTransactionRegistry();
+            return xaConnectionFactory;
+        }
+
+        // Create the XADataSource instance using the configured class name if it has not been set
+        if (xaDataSourceInstance == null) {
+            Class<?> xaDataSourceClass = null;
+            try {
+                xaDataSourceClass = Class.forName(xaDataSource);
+            } catch (final Exception t) {
+                final String message = "Cannot load XA data source class '" + xaDataSource + "'";
+                throw new SQLException(message, t);
+            }
+
+            try {
+                xaDataSourceInstance = (XADataSource) xaDataSourceClass.newInstance();
+            } catch (final Exception t) {
+                final String message = "Cannot create XA data source of class '" + xaDataSource + "'";
+                throw new SQLException(message, t);
+            }
+        }
+
+        // finally, create the XAConnectionFactory using the XA data source
+        final XAConnectionFactory xaConnectionFactory = new DataSourceXAConnectionFactory(getTransactionManager(), xaDataSourceInstance, getUsername(), getPassword());
+        transactionRegistry = xaConnectionFactory.getTransactionRegistry();
+        return xaConnectionFactory;
+    }
+
+    @Override
+    protected DataSource createDataSourceInstance() throws SQLException {
+        final PoolingDataSource<PoolableConnection> pds =
+                new ManagedDataSource<>(getConnectionPool(), transactionRegistry);
+        pds.setAccessToUnderlyingConnectionAllowed(isAccessToUnderlyingConnectionAllowed());
+        return pds;
+    }
+
+    /**
+     * Creates the PoolableConnectionFactory and attaches it to the connection pool.
+     *
+     * @param driverConnectionFactory JDBC connection factory created by {@link #createConnectionFactory()}
+     * @throws SQLException if an error occurs creating the PoolableConnectionFactory
+     */
+    @Override
+    protected PoolableConnectionFactory createPoolableConnectionFactory(
+            final ConnectionFactory driverConnectionFactory) throws SQLException {
+        PoolableConnectionFactory connectionFactory = null;
+        try {
+            connectionFactory = new PoolableManagedConnectionFactory(
+                    (XAConnectionFactory) driverConnectionFactory, getRegisteredJmxName());
+            connectionFactory.setValidationQuery(getValidationQuery());
+            connectionFactory.setValidationQueryTimeout(getValidationQueryTimeout());
+            connectionFactory.setConnectionInitSql(getConnectionInitSqls());
+            connectionFactory.setDefaultReadOnly(getDefaultReadOnly());
+            connectionFactory.setDefaultAutoCommit(getDefaultAutoCommit());
+            connectionFactory.setDefaultTransactionIsolation(getDefaultTransactionIsolation());
+            connectionFactory.setDefaultCatalog(getDefaultCatalog());
+            connectionFactory.setCacheState(getCacheState());
+            connectionFactory.setPoolStatements(isPoolPreparedStatements());
+            connectionFactory.setMaxOpenPreparedStatements(
+                    getMaxOpenPreparedStatements());
+            connectionFactory.setMaxConnLifetimeMillis(getMaxConnLifetimeMillis());
+            connectionFactory.setRollbackOnReturn(getRollbackOnReturn());
+            connectionFactory.setEnableAutoCommitOnReturn(getEnableAutoCommitOnReturn());
+            connectionFactory.setDefaultQueryTimeout(getDefaultQueryTimeout());
+            connectionFactory.setFastFailValidation(getFastFailValidation());
+            connectionFactory.setDisconnectionSqlCodes(getDisconnectionSqlCodes());
+            validateConnectionFactory(connectionFactory);
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Exception e) {
+            throw new SQLException("Cannot create PoolableConnectionFactory (" + e.getMessage() + ")", e);
+        }
+        return connectionFactory;
+    }
+}

==================================================
LocalXAConnectionFactory.java
new file mode 100644
index 0000000000..a7abac957f
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/DataSourceXAConnectionFactory.java
@@ -0,0 +1,149 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2.managed;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+
+import javax.sql.ConnectionEvent;
+import javax.sql.ConnectionEventListener;
+import javax.sql.PooledConnection;
+import javax.sql.XAConnection;
+import javax.sql.XADataSource;
+import javax.transaction.TransactionManager;
+import javax.transaction.xa.XAResource;
+
+/**
+ * An implementation of XAConnectionFactory which uses a real XADataSource to obtain connections and XAResources.
+ *
+ * @author Dain Sundstrom
+ * @since 2.0
+ */
+public class DataSourceXAConnectionFactory implements XAConnectionFactory {
+    private final TransactionRegistry transactionRegistry;
+    private final XADataSource xaDataSource;
+    private String username;
+    private String password;
+
+    /**
+     * Creates an DataSourceXAConnectionFactory which uses the specified XADataSource to create database
+     * connections.  The connections are enlisted into transactions using the specified transaction manager.
+     *
+     * @param transactionManager the transaction manager in which connections will be enlisted
+     * @param xaDataSource the data source from which connections will be retrieved
+     */
+    public DataSourceXAConnectionFactory(final TransactionManager transactionManager, final XADataSource xaDataSource) {
+        this(transactionManager, xaDataSource, null, null);
+    }
+
+    /**
+     * Creates an DataSourceXAConnectionFactory which uses the specified XADataSource to create database
+     * connections.  The connections are enlisted into transactions using the specified transaction manager.
+     *
+     * @param transactionManager the transaction manager in which connections will be enlisted
+     * @param xaDataSource the data source from which connections will be retrieved
+     * @param username the username used for authenticating new connections or null for unauthenticated
+     * @param password the password used for authenticating new connections
+     */
+    public DataSourceXAConnectionFactory(final TransactionManager transactionManager, final XADataSource xaDataSource, final String username, final String password) {
+        if (transactionManager == null) {
+            throw new NullPointerException("transactionManager is null");
+        }
+        if (xaDataSource == null) {
+            throw new NullPointerException("xaDataSource is null");
+        }
+
+        this.transactionRegistry = new TransactionRegistry(transactionManager);
+        this.xaDataSource = xaDataSource;
+        this.username = username;
+        this.password = password;
+    }
+
+    /**
+     * Gets the username used to authenticate new connections.
+     * @return the user name or null if unauthenticated connections are used
+     */
+    public String getUsername() {
+        return username;
+    }
+
+    /**
+     * Sets the username used to authenticate new connections.
+     * @param username the username used for authenticating the connection or null for unauthenticated
+     */
+    public void setUsername(final String username) {
+        this.username = username;
+    }
+
+    /**
+     * Sets the password used to authenticate new connections.
+     * @param password the password used for authenticating the connection or null for unauthenticated
+     */
+    public void setPassword(final String password) {
+        this.password = password;
+    }
+
+    @Override
+    public TransactionRegistry getTransactionRegistry() {
+        return transactionRegistry;
+    }
+
+    @Override
+    public Connection createConnection() throws SQLException {
+        // create a new XAConnection
+        XAConnection xaConnection;
+        if (username == null) {
+            xaConnection = xaDataSource.getXAConnection();
+        } else {
+            xaConnection = xaDataSource.getXAConnection(username, password);
+        }
+
+        // get the real connection and XAResource from the connection
+        final Connection connection = xaConnection.getConnection();
+        final XAResource xaResource = xaConnection.getXAResource();
+
+        // register the xa resource for the connection
+        transactionRegistry.registerConnection(connection, xaResource);
+
+        // The Connection we're returning is a handle on the XAConnection.
+        // When the pool calling us closes the Connection, we need to
+        // also close the XAConnection that holds the physical connection.
+        xaConnection.addConnectionEventListener(new ConnectionEventListener() {
+
+            @Override
+            public void connectionClosed(final ConnectionEvent event) {
+                final PooledConnection pc = (PooledConnection) event.getSource();
+                pc.removeConnectionEventListener(this);
+                try {
+                    pc.close();
+                } catch (final SQLException e) {
+                    System.err.println("Failed to close XAConnection");
+                    e.printStackTrace();
+                }
+            }
+
+            @Override
+            public void connectionErrorOccurred(final ConnectionEvent event) {
+                connectionClosed(event);
+            }
+        });
+
+
+        return connection;
+    }
+}

==================================================
ManagedConnection.java
new file mode 100644
index 0000000000..779778618f
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/LocalXAConnectionFactory.java
@@ -0,0 +1,332 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2.managed;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+
+import javax.transaction.TransactionManager;
+import javax.transaction.xa.XAException;
+import javax.transaction.xa.XAResource;
+import javax.transaction.xa.Xid;
+
+import org.apache.tomcat.dbcp.dbcp2.ConnectionFactory;
+
+/**
+ * An implementation of XAConnectionFactory which manages non-XA connections in XA transactions.  A non-XA connection
+ * commits and rolls back as part of the XA transaction, but is not recoverable since the connection does not implement
+ * the 2-phase protocol.
+ *
+ * @author Dain Sundstrom
+ * @since 2.0
+ */
+public class LocalXAConnectionFactory implements XAConnectionFactory {
+    private final TransactionRegistry transactionRegistry;
+    private final ConnectionFactory connectionFactory;
+
+    /**
+     * Creates an LocalXAConnectionFactory which uses the specified connection factory to create database
+     * connections.  The connections are enlisted into transactions using the specified transaction manager.
+     *
+     * @param transactionManager the transaction manager in which connections will be enlisted
+     * @param connectionFactory  the connection factory from which connections will be retrieved
+     */
+    public LocalXAConnectionFactory(final TransactionManager transactionManager, final ConnectionFactory connectionFactory) {
+        if (transactionManager == null) {
+            throw new NullPointerException("transactionManager is null");
+        }
+        if (connectionFactory == null) {
+            throw new NullPointerException("connectionFactory is null");
+        }
+
+        this.transactionRegistry = new TransactionRegistry(transactionManager);
+        this.connectionFactory = connectionFactory;
+    }
+
+    @Override
+    public TransactionRegistry getTransactionRegistry() {
+        return transactionRegistry;
+    }
+
+    @Override
+    public Connection createConnection() throws SQLException {
+        // create a new connection
+        final Connection connection = connectionFactory.createConnection();
+
+        // create a XAResource to manage the connection during XA transactions
+        final XAResource xaResource = new LocalXAResource(connection);
+
+        // register the xa resource for the connection
+        transactionRegistry.registerConnection(connection, xaResource);
+
+        return connection;
+    }
+
+    /**
+     * LocalXAResource is a fake XAResource for non-XA connections.  When a transaction is started
+     * the connection auto-commit is turned off.  When the connection is committed or rolled back,
+     * the commit or rollback method is called on the connection and then the original auto-commit
+     * value is restored.
+     * <p>
+     * The LocalXAResource also respects the connection read-only setting.  If the connection is
+     * read-only the commit method will not be called, and the prepare method returns the XA_RDONLY.
+     * </p>
+     * It is assumed that the wrapper around a managed connection disables the setAutoCommit(),
+     * commit(), rollback() and setReadOnly() methods while a transaction is in progress.
+     * @since 2.0
+     */
+    protected static class LocalXAResource implements XAResource {
+        private final Connection connection;
+        private Xid currentXid; // @GuardedBy("this")
+        private boolean originalAutoCommit; // @GuardedBy("this")
+
+        public LocalXAResource(final Connection localTransaction) {
+            this.connection = localTransaction;
+        }
+
+        /**
+         * Gets the current xid of the transaction branch associated with this XAResource.
+         *
+         * @return the current xid of the transaction branch associated with this XAResource.
+         */
+        public synchronized Xid getXid() {
+            return currentXid;
+        }
+
+        /**
+         * Signals that a the connection has been enrolled in a transaction.  This method saves off the
+         * current auto commit flag, and then disables auto commit.  The original auto commit setting is
+         * restored when the transaction completes.
+         *
+         * @param xid  the id of the transaction branch for this connection
+         * @param flag either XAResource.TMNOFLAGS or XAResource.TMRESUME
+         * @throws XAException if the connection is already enlisted in another transaction, or if auto-commit
+         *                     could not be disabled
+         */
+        @Override
+        public synchronized void start(final Xid xid, final int flag) throws XAException {
+            if (flag == XAResource.TMNOFLAGS) {
+                // first time in this transaction
+
+                // make sure we aren't already in another tx
+                if (this.currentXid != null) {
+                    throw new XAException("Already enlisted in another transaction with xid " + xid);
+                }
+
+                // save off the current auto commit flag so it can be restored after the transaction completes
+                try {
+                    originalAutoCommit = connection.getAutoCommit();
+                } catch (final SQLException ignored) {
+                    // no big deal, just assume it was off
+                    originalAutoCommit = true;
+                }
+
+                // update the auto commit flag
+                try {
+                    connection.setAutoCommit(false);
+                } catch (final SQLException e) {
+                    throw (XAException) new XAException("Count not turn off auto commit for a XA transaction").initCause(e);
+                }
+
+                this.currentXid = xid;
+            } else if (flag == XAResource.TMRESUME) {
+                if (!xid.equals(this.currentXid)) {
+                    throw new XAException("Attempting to resume in different transaction: expected " + this.currentXid + ", but was " + xid);
+                }
+            } else {
+                throw new XAException("Unknown start flag " + flag);
+            }
+        }
+
+        /**
+         * This method does nothing.
+         *
+         * @param xid  the id of the transaction branch for this connection
+         * @param flag ignored
+         * @throws XAException if the connection is already enlisted in another transaction
+         */
+        @Override
+        public synchronized void end(final Xid xid, final int flag) throws XAException {
+            if (xid == null) {
+                throw new NullPointerException("xid is null");
+            }
+            if (!this.currentXid.equals(xid)) {
+                throw new XAException("Invalid Xid: expected " + this.currentXid + ", but was " + xid);
+            }
+
+            // This notification tells us that the application server is done using this
+            // connection for the time being.  The connection is still associated with an
+            // open transaction, so we must still wait for the commit or rollback method
+        }
+
+        /**
+         * This method does nothing since the LocalXAConnection does not support two-phase-commit.  This method
+         * will return XAResource.XA_RDONLY if the connection isReadOnly().  This assumes that the physical
+         * connection is wrapped with a proxy that prevents an application from changing the read-only flag
+         * while enrolled in a transaction.
+         *
+         * @param xid the id of the transaction branch for this connection
+         * @return XAResource.XA_RDONLY if the connection.isReadOnly(); XAResource.XA_OK otherwise
+         */
+        @Override
+        public synchronized int prepare(final Xid xid) {
+            // if the connection is read-only, then the resource is read-only
+            // NOTE: this assumes that the outer proxy throws an exception when application code
+            // attempts to set this in a transaction
+            try {
+                if (connection.isReadOnly()) {
+                    // update the auto commit flag
+                    connection.setAutoCommit(originalAutoCommit);
+
+                    // tell the transaction manager we are read only
+                    return XAResource.XA_RDONLY;
+                }
+            } catch (final SQLException ignored) {
+                // no big deal
+            }
+
+            // this is a local (one phase) only connection, so we can't prepare
+            return XAResource.XA_OK;
+        }
+
+        /**
+         * Commits the transaction and restores the original auto commit setting.
+         *
+         * @param xid  the id of the transaction branch for this connection
+         * @param flag ignored
+         * @throws XAException if connection.commit() throws a SQLException
+         */
+        @Override
+        public synchronized void commit(final Xid xid, final boolean flag) throws XAException {
+            if (xid == null) {
+                throw new NullPointerException("xid is null");
+            }
+            if (this.currentXid == null) {
+                throw new XAException("There is no current transaction");
+            }
+            if (!this.currentXid.equals(xid)) {
+                throw new XAException("Invalid Xid: expected " +
+                        this.currentXid + ", but was " + xid);
+            }
+
+            try {
+                // make sure the connection isn't already closed
+                if (connection.isClosed()) {
+                    throw new XAException("Connection is closed");
+                }
+
+                // A read only connection should not be committed
+                if (!connection.isReadOnly()) {
+                    connection.commit();
+                }
+            } catch (final SQLException e) {
+                throw (XAException) new XAException().initCause(e);
+            } finally {
+                try {
+                    connection.setAutoCommit(originalAutoCommit);
+                } catch (final SQLException e) {
+                }
+                this.currentXid = null;
+            }
+        }
+
+        /**
+         * Rolls back the transaction and restores the original auto commit setting.
+         *
+         * @param xid the id of the transaction branch for this connection
+         * @throws XAException if connection.rollback() throws a SQLException
+         */
+        @Override
+        public synchronized void rollback(final Xid xid) throws XAException {
+            if (xid == null) {
+                throw new NullPointerException("xid is null");
+            }
+            if (!this.currentXid.equals(xid)) {
+                throw new XAException("Invalid Xid: expected " + this.currentXid + ", but was " + xid);
+            }
+
+            try {
+                connection.rollback();
+            } catch (final SQLException e) {
+                throw (XAException) new XAException().initCause(e);
+            } finally {
+                try {
+                    connection.setAutoCommit(originalAutoCommit);
+                } catch (final SQLException e) {
+                }
+                this.currentXid = null;
+            }
+        }
+
+        /**
+         * Returns true if the specified XAResource == this XAResource.
+         *
+         * @param xaResource the XAResource to test
+         * @return true if the specified XAResource == this XAResource; false otherwise
+         */
+        @Override
+        public boolean isSameRM(final XAResource xaResource) {
+            return this == xaResource;
+        }
+
+        /**
+         * Clears the currently associated transaction if it is the specified xid.
+         *
+         * @param xid the id of the transaction to forget
+         */
+        @Override
+        public synchronized void forget(final Xid xid) {
+            if (xid != null && xid.equals(currentXid)) {
+                currentXid = null;
+            }
+        }
+
+        /**
+         * Always returns a zero length Xid array.  The LocalXAConnectionFactory can not support recovery, so no xids will ever be found.
+         *
+         * @param flag ignored since recovery is not supported
+         * @return always a zero length Xid array.
+         */
+        @Override
+        public Xid[] recover(final int flag) {
+            return new Xid[0];
+        }
+
+        /**
+         * Always returns 0 since we have no way to set a transaction timeout on a JDBC connection.
+         *
+         * @return always 0
+         */
+        @Override
+        public int getTransactionTimeout() {
+            return 0;
+        }
+
+        /**
+         * Always returns false since we have no way to set a transaction timeout on a JDBC connection.
+         *
+         * @param transactionTimeout ignored since we have no way to set a transaction timeout on a JDBC connection
+         * @return always false
+         */
+        @Override
+        public boolean setTransactionTimeout(final int transactionTimeout) {
+            return false;
+        }
+    }
+
+}

==================================================
ManagedDataSource.java
new file mode 100644
index 0000000000..6a1e9a2f83
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/ManagedConnection.java
@@ -0,0 +1,281 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2.managed;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+
+import org.apache.tomcat.dbcp.dbcp2.DelegatingConnection;
+import org.apache.tomcat.dbcp.pool2.ObjectPool;
+
+/**
+ * ManagedConnection is responsible for managing a database connection in a transactional environment
+ * (typically called "Container Managed").  A managed connection operates like any other connection
+ * when no global transaction (a.k.a. XA transaction or JTA Transaction) is in progress.  When a
+ * global transaction is active a single physical connection to the database is used by all
+ * ManagedConnections accessed in the scope of the transaction.  Connection sharing means that all
+ * data access during a transaction has a consistent view of the database.  When the global transaction
+ * is committed or rolled back the enlisted connections are committed or rolled back.  Typically upon
+ * transaction completion, a connection returns to the auto commit setting in effect before being
+ * enlisted in the transaction, but some vendors do not properly implement this.
+ *
+ * When enlisted in a transaction the setAutoCommit(), commit(), rollback(), and setReadOnly() methods
+ * throw a SQLException.  This is necessary to assure that the transaction completes as a single unit.
+ *
+ * @param <C> the Connection type
+ *
+ * @author Dain Sundstrom
+ * @since 2.0
+ */
+public class ManagedConnection<C extends Connection> extends DelegatingConnection<C> {
+    private final ObjectPool<C> pool;
+    private final TransactionRegistry transactionRegistry;
+    private final boolean accessToUnderlyingConnectionAllowed;
+    private TransactionContext transactionContext;
+    private boolean isSharedConnection;
+
+    public ManagedConnection(final ObjectPool<C> pool,
+            final TransactionRegistry transactionRegistry,
+            final boolean accessToUnderlyingConnectionAllowed) throws SQLException {
+        super(null);
+        this.pool = pool;
+        this.transactionRegistry = transactionRegistry;
+        this.accessToUnderlyingConnectionAllowed = accessToUnderlyingConnectionAllowed;
+        updateTransactionStatus();
+    }
+
+    @Override
+    protected void checkOpen() throws SQLException {
+        super.checkOpen();
+        updateTransactionStatus();
+    }
+
+    private void updateTransactionStatus() throws SQLException {
+        // if there is a is an active transaction context, assure the transaction context hasn't changed
+        if (transactionContext != null) {
+            if (transactionContext.isActive()) {
+                if (transactionContext != transactionRegistry.getActiveTransactionContext()) {
+                    throw new SQLException("Connection can not be used while enlisted in another transaction");
+                }
+                return;
+            }
+            // transaction should have been cleared up by TransactionContextListener, but in
+            // rare cases another lister could have registered which uses the connection before
+            // our listener is called.  In that rare case, trigger the transaction complete call now
+            transactionComplete();
+        }
+
+        // the existing transaction context ended (or we didn't have one), get the active transaction context
+        transactionContext = transactionRegistry.getActiveTransactionContext();
+
+        // if there is an active transaction context and it already has a shared connection, use it
+        if (transactionContext != null && transactionContext.getSharedConnection() != null) {
+            // A connection for the connection factory has already been enrolled
+            // in the transaction, replace our delegate with the enrolled connection
+
+            // return current connection to the pool
+            final C connection = getDelegateInternal();
+            setDelegate(null);
+            if (connection != null) {
+                try {
+                    pool.returnObject(connection);
+                } catch (final Exception ignored) {
+                    // whatever... try to invalidate the connection
+                    try {
+                        pool.invalidateObject(connection);
+                    } catch (final Exception ignore) {
+                        // no big deal
+                    }
+                }
+            }
+
+            // add a listener to the transaction context
+            transactionContext.addTransactionContextListener(new CompletionListener());
+
+            // Set our delegate to the shared connection. Note that this will
+            // always be of type C since it has been shared by another
+            // connection from the same pool.
+            @SuppressWarnings("unchecked")
+            final
+            C shared = (C) transactionContext.getSharedConnection();
+            setDelegate(shared);
+
+            // remember that we are using a shared connection so it can be cleared after the
+            // transaction completes
+            isSharedConnection = true;
+        } else {
+            C connection = getDelegateInternal();
+            // if our delegate is null, create one
+            if (connection == null) {
+                try {
+                    // borrow a new connection from the pool
+                    connection = pool.borrowObject();
+                    setDelegate(connection);
+                } catch (final Exception e) {
+                    throw new SQLException("Unable to acquire a new connection from the pool", e);
+                }
+            }
+
+            // if we have a transaction, out delegate becomes the shared delegate
+            if (transactionContext != null) {
+                // add a listener to the transaction context
+                transactionContext.addTransactionContextListener(new CompletionListener());
+
+                // register our connection as the shared connection
+                try {
+                    transactionContext.setSharedConnection(connection);
+                } catch (final SQLException e) {
+                    // transaction is hosed
+                    transactionContext = null;
+                    try {
+                        pool.invalidateObject(connection);
+                    } catch (final Exception e1) {
+                        // we are try but no luck
+                    }
+                    throw e;
+                }
+            }
+        }
+        // autoCommit may have been changed directly on the underlying
+        // connection
+        clearCachedState();
+    }
+
+    @Override
+    public void close() throws SQLException {
+        if (!isClosedInternal()) {
+            try {
+                // Don't actually close the connection if in a transaction. The
+                // connection will be closed by the transactionComplete method.
+                if (transactionContext == null) {
+                    super.close();
+                }
+            } finally {
+                setClosedInternal(true);
+            }
+        }
+    }
+
+    /**
+     * Delegates to {@link ManagedConnection#transactionComplete()}
+     * for transaction completion events.
+     * @since 2.0
+     */
+    protected class CompletionListener implements TransactionContextListener {
+        @Override
+        public void afterCompletion(final TransactionContext completedContext, final boolean commited) {
+            if (completedContext == transactionContext) {
+                transactionComplete();
+            }
+        }
+    }
+
+    protected void transactionComplete() {
+        transactionContext = null;
+
+        // If we were using a shared connection, clear the reference now that
+        // the transaction has completed
+        if (isSharedConnection) {
+            setDelegate(null);
+            isSharedConnection = false;
+        }
+
+        // If this connection was closed during the transaction and there is
+        // still a delegate present close it
+        final Connection delegate = getDelegateInternal();
+        if (isClosedInternal() && delegate != null) {
+            try {
+                setDelegate(null);
+
+                if (!delegate.isClosed()) {
+                    delegate.close();
+                }
+            } catch (final SQLException ignored) {
+                // Not a whole lot we can do here as connection is closed
+                // and this is a transaction callback so there is no
+                // way to report the error.
+            }
+        }
+    }
+
+    //
+    // The following methods can't be used while enlisted in a transaction
+    //
+
+    @Override
+    public void setAutoCommit(final boolean autoCommit) throws SQLException {
+        if (transactionContext != null) {
+            throw new SQLException("Auto-commit can not be set while enrolled in a transaction");
+        }
+        super.setAutoCommit(autoCommit);
+    }
+
+
+    @Override
+    public void commit() throws SQLException {
+        if (transactionContext != null) {
+            throw new SQLException("Commit can not be set while enrolled in a transaction");
+        }
+        super.commit();
+    }
+
+    @Override
+    public void rollback() throws SQLException {
+        if (transactionContext != null) {
+            throw new SQLException("Commit can not be set while enrolled in a transaction");
+        }
+        super.rollback();
+    }
+
+
+    @Override
+    public void setReadOnly(final boolean readOnly) throws SQLException {
+        if (transactionContext != null) {
+            throw new SQLException("Read-only can not be set while enrolled in a transaction");
+        }
+        super.setReadOnly(readOnly);
+    }
+
+    //
+    // Methods for accessing the delegate connection
+    //
+
+    /**
+     * If false, getDelegate() and getInnermostDelegate() will return null.
+     * @return if false, getDelegate() and getInnermostDelegate() will return null
+     */
+    public boolean isAccessToUnderlyingConnectionAllowed() {
+        return accessToUnderlyingConnectionAllowed;
+    }
+
+    @Override
+    public C getDelegate() {
+        if (isAccessToUnderlyingConnectionAllowed()) {
+            return getDelegateInternal();
+        }
+        return null;
+    }
+
+    @Override
+    public Connection getInnermostDelegate() {
+        if (isAccessToUnderlyingConnectionAllowed()) {
+            return super.getInnermostDelegateInternal();
+        }
+        return null;
+    }
+}

==================================================
PoolableManagedConnection.java
new file mode 100644
index 0000000000..638393fd8a
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/ManagedDataSource.java
@@ -0,0 +1,84 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2.managed;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+
+import org.apache.tomcat.dbcp.dbcp2.PoolingDataSource;
+import org.apache.tomcat.dbcp.pool2.ObjectPool;
+
+/**
+ * The ManagedDataSource is a PoolingDataSource that creates ManagedConnections.
+ *
+ * @author Dain Sundstrom
+ * @param <C> The kind of {@link Connection} to manage.
+ * @since 2.0
+ */
+public class ManagedDataSource<C extends Connection> extends PoolingDataSource<C> {
+    private TransactionRegistry transactionRegistry;
+
+    /**
+     * Creates a ManagedDataSource which obtains connections from the specified pool and
+     * manages them using the specified transaction registry.  The TransactionRegistry must
+     * be the transaction registry obtained from the XAConnectionFactory used to create
+     * the connection pool.  If not, an error will occur when attempting to use the connection
+     * in a global transaction because the XAResource object associated with the connection
+     * will be unavailable.
+     *
+     * @param pool the connection pool
+     * @param transactionRegistry the transaction registry obtained from the
+     * XAConnectionFactory used to create the connection pool object factory
+     */
+    public ManagedDataSource(final ObjectPool<C> pool,
+            final TransactionRegistry transactionRegistry) {
+        super(pool);
+        this.transactionRegistry = transactionRegistry;
+    }
+
+    /**
+     * Sets the transaction registry from the XAConnectionFactory used to create the pool.
+     * The transaction registry can only be set once using either a connector or this setter
+     * method.
+     * @param transactionRegistry the transaction registry acquired from the XAConnectionFactory
+     * used to create the pool
+     */
+    public void setTransactionRegistry(final TransactionRegistry transactionRegistry) {
+        if(this.transactionRegistry != null) {
+            throw new IllegalStateException("TransactionRegistry already set");
+        }
+        if(transactionRegistry == null) {
+            throw new NullPointerException("TransactionRegistry is null");
+        }
+
+        this.transactionRegistry = transactionRegistry;
+    }
+
+    @Override
+    public Connection getConnection() throws SQLException {
+        if (getPool() == null) {
+            throw new IllegalStateException("Pool has not been set");
+        }
+        if (transactionRegistry == null) {
+            throw new IllegalStateException("TransactionRegistry has not been set");
+        }
+
+        final Connection connection = new ManagedConnection<>(getPool(), transactionRegistry, isAccessToUnderlyingConnectionAllowed());
+        return connection;
+    }
+}

==================================================
PoolableManagedConnectionFactory.java
new file mode 100644
index 0000000000..4a01ea1a0a
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/PoolableManagedConnection.java
@@ -0,0 +1,80 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2.managed;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.util.Collection;
+
+import org.apache.tomcat.dbcp.dbcp2.PoolableConnection;
+import org.apache.tomcat.dbcp.pool2.ObjectPool;
+
+/**
+ * PoolableConnection that unregisters from TransactionRegistry on Connection real destroy.
+ *
+ * @see PoolableConnection
+ * @since 2.0
+ */
+public class PoolableManagedConnection extends PoolableConnection {
+    private final TransactionRegistry transactionRegistry;
+
+
+    /**
+     * Create a PoolableManagedConnection.
+     *
+     * @param transactionRegistry transaction registry
+     * @param conn underlying connection
+     * @param pool connection pool
+     */
+    public PoolableManagedConnection(final TransactionRegistry transactionRegistry,
+            final Connection conn, final ObjectPool<PoolableConnection> pool) {
+        this(transactionRegistry, conn, pool, null, false);
+    }
+
+
+    /**
+     * Create a PoolableManagedConnection.
+     *
+     * @param transactionRegistry transaction registry
+     * @param conn underlying connection
+     * @param pool connection pool
+     * @param disconnectSqlCodes SQL_STATE codes considered fatal disconnection errors
+     * @param fastFailValidation true means fatal disconnection errors cause subsequent
+     *        validations to fail immediately (no attempt to run query or isValid)
+     */
+    public PoolableManagedConnection(final TransactionRegistry transactionRegistry,
+            final Connection conn, final ObjectPool<PoolableConnection> pool,
+            final Collection<String> disconnectSqlCodes,
+            final boolean fastFailValidation) {
+        super(conn, pool, null, disconnectSqlCodes, fastFailValidation);
+        this.transactionRegistry = transactionRegistry;
+    }
+
+
+    /**
+     * Actually close the underlying connection.
+     */
+    @Override
+    public void reallyClose() throws SQLException {
+        try {
+            super.reallyClose();
+        } finally {
+            transactionRegistry.unregisterConnection(this);
+        }
+    }
+}

==================================================
TransactionContext.java
new file mode 100644
index 0000000000..676407ad2a
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/PoolableManagedConnectionFactory.java
@@ -0,0 +1,101 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2.managed;
+
+import java.sql.Connection;
+
+import javax.management.ObjectName;
+
+import org.apache.tomcat.dbcp.dbcp2.Constants;
+import org.apache.tomcat.dbcp.dbcp2.DelegatingPreparedStatement;
+import org.apache.tomcat.dbcp.dbcp2.PStmtKey;
+import org.apache.tomcat.dbcp.dbcp2.PoolableConnection;
+import org.apache.tomcat.dbcp.dbcp2.PoolableConnectionFactory;
+import org.apache.tomcat.dbcp.dbcp2.PoolingConnection;
+import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
+import org.apache.tomcat.dbcp.pool2.PooledObject;
+import org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject;
+import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool;
+import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPoolConfig;
+
+/**
+ * A {@link PoolableConnectionFactory} that creates {@link PoolableManagedConnection}s.
+ *
+ * @since 2.0
+ */
+public class PoolableManagedConnectionFactory extends PoolableConnectionFactory {
+
+    /** Transaction registry associated with connections created by this factory */
+    private final TransactionRegistry transactionRegistry;
+
+    /**
+     * Create a PoolableManagedConnectionFactory and attach it to a connection pool.
+     *
+     * @param connFactory XAConnectionFactory
+     */
+    public PoolableManagedConnectionFactory(final XAConnectionFactory connFactory,
+            final ObjectName dataSourceJmxName) {
+        super(connFactory, dataSourceJmxName);
+        this.transactionRegistry = connFactory.getTransactionRegistry();
+    }
+
+    /**
+     * Uses the configured XAConnectionFactory to create a {@link PoolableManagedConnection}.
+     * Throws <code>IllegalStateException</code> if the connection factory returns null.
+     * Also initializes the connection using configured initialization sql (if provided)
+     * and sets up a prepared statement pool associated with the PoolableManagedConnection
+     * if statement pooling is enabled.
+     */
+    @Override
+    public synchronized PooledObject<PoolableConnection> makeObject() throws Exception {
+        Connection conn = getConnectionFactory().createConnection();
+        if (conn == null) {
+            throw new IllegalStateException("Connection factory returned null from createConnection");
+        }
+        initializeConnection(conn);
+        if (getPoolStatements()) {
+            conn = new PoolingConnection(conn);
+            final GenericKeyedObjectPoolConfig config = new GenericKeyedObjectPoolConfig();
+            config.setMaxTotalPerKey(-1);
+            config.setBlockWhenExhausted(false);
+            config.setMaxWaitMillis(0);
+            config.setMaxIdlePerKey(1);
+            config.setMaxTotal(getMaxOpenPreparedStatements());
+            final ObjectName dataSourceJmxName = getDataSourceJmxName();
+            final long connIndex = getConnectionIndex().getAndIncrement();
+            if (dataSourceJmxName != null) {
+                final StringBuilder base = new StringBuilder(dataSourceJmxName.toString());
+                base.append(Constants.JMX_CONNECTION_BASE_EXT);
+                base.append(Long.toString(connIndex));
+                config.setJmxNameBase(base.toString());
+                config.setJmxNamePrefix(Constants.JMX_STATEMENT_POOL_PREFIX);
+            } else {
+                config.setJmxEnabled(false);
+            }
+            final KeyedObjectPool<PStmtKey,DelegatingPreparedStatement> stmtPool =
+                new GenericKeyedObjectPool<>((PoolingConnection)conn, config);
+            ((PoolingConnection)conn).setStatementPool(stmtPool);
+            ((PoolingConnection) conn).setCacheState(getCacheState());
+        }
+        final PoolableManagedConnection pmc =
+                new PoolableManagedConnection(transactionRegistry, conn, getPool(),
+                        getDisconnectionSqlCodes(), isFastFailValidation());
+        pmc.setCacheState(getCacheState());
+        return new DefaultPooledObject<PoolableConnection>(pmc);
+    }
+}

==================================================
TransactionContextListener.java
new file mode 100644
index 0000000000..f4c10595af
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/TransactionContext.java
@@ -0,0 +1,157 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2.managed;
+
+import java.lang.ref.WeakReference;
+import java.sql.Connection;
+import java.sql.SQLException;
+
+import javax.transaction.RollbackException;
+import javax.transaction.Status;
+import javax.transaction.Synchronization;
+import javax.transaction.SystemException;
+import javax.transaction.Transaction;
+import javax.transaction.xa.XAResource;
+
+/**
+ * TransactionContext represents the association between a single XAConnectionFactory and a Transaction.
+ * This context contains a single shared connection which should be used by all ManagedConnections for
+ * the XAConnectionFactory, the ability to listen for the transaction completion event, and a method
+ * to check the status of the transaction.
+ *
+ * @author Dain Sundstrom
+ * @since 2.0
+ */
+public class TransactionContext {
+    private final TransactionRegistry transactionRegistry;
+    private final WeakReference<Transaction> transactionRef;
+    private Connection sharedConnection;
+
+    /**
+     * Creates a TransactionContext for the specified Transaction and TransactionRegistry.  The
+     * TransactionRegistry is used to obtain the XAResource for the shared connection when it is
+     * enlisted in the transaction.
+     *
+     * @param transactionRegistry the TransactionRegistry used to obtain the XAResource for the
+     * shared connection
+     * @param transaction the transaction
+     */
+    public TransactionContext(final TransactionRegistry transactionRegistry, final Transaction transaction) {
+        if (transactionRegistry == null) {
+            throw new NullPointerException("transactionRegistry is null");
+        }
+        if (transaction == null) {
+            throw new NullPointerException("transaction is null");
+        }
+        this.transactionRegistry = transactionRegistry;
+        this.transactionRef = new WeakReference<>(transaction);
+    }
+
+    /**
+     * Gets the connection shared by all ManagedConnections in the transaction.  Specifically,
+     * connection using the same XAConnectionFactory from which the TransactionRegistry was
+     * obtained.
+     * @return the shared connection for this transaction
+     */
+    public Connection getSharedConnection() {
+        return sharedConnection;
+    }
+
+    /**
+     * Sets the shared connection for this transaction.  The shared connection is enlisted
+     * in the transaction.
+     *
+     * @param sharedConnection the shared connection
+     * @throws SQLException if a shared connection is already set, if XAResource for the connection
+     * could not be found in the transaction registry, or if there was a problem enlisting the
+     * connection in the transaction
+     */
+    public void setSharedConnection(final Connection sharedConnection) throws SQLException {
+        if (this.sharedConnection != null) {
+            throw new IllegalStateException("A shared connection is already set");
+        }
+
+        // This is the first use of the connection in this transaction, so we must
+        // enlist it in the transaction
+        final Transaction transaction = getTransaction();
+        try {
+            final XAResource xaResource = transactionRegistry.getXAResource(sharedConnection);
+            if ( !transaction.enlistResource(xaResource) ) {
+                throw new SQLException("Unable to enlist connection in transaction: enlistResource returns 'false'.");
+            }
+        } catch (final RollbackException e) {
+            // transaction was rolled back... proceed as if there never was a transaction
+        } catch (final SystemException e) {
+            throw new SQLException("Unable to enlist connection the transaction", e);
+        }
+
+        this.sharedConnection = sharedConnection;
+    }
+
+    /**
+     * Adds a listener for transaction completion events.
+     *
+     * @param listener the listener to add
+     * @throws SQLException if a problem occurs adding the listener to the transaction
+     */
+    public void addTransactionContextListener(final TransactionContextListener listener) throws SQLException {
+        try {
+            getTransaction().registerSynchronization(new Synchronization() {
+                @Override
+                public void beforeCompletion() {
+                }
+
+                @Override
+                public void afterCompletion(final int status) {
+                    listener.afterCompletion(TransactionContext.this, status == Status.STATUS_COMMITTED);
+                }
+            });
+        } catch (final RollbackException e) {
+            // JTA spec doesn't let us register with a transaction marked rollback only
+            // just ignore this and the tx state will be cleared another way.
+        } catch (final Exception e) {
+            throw new SQLException("Unable to register transaction context listener", e);
+        }
+    }
+
+    /**
+     * True if the transaction is active or marked for rollback only.
+     * @return true if the transaction is active or marked for rollback only; false otherwise
+     * @throws SQLException if a problem occurs obtaining the transaction status
+     */
+    public boolean isActive() throws SQLException {
+        try {
+            final Transaction transaction = this.transactionRef.get();
+            if (transaction == null) {
+                return false;
+            }
+            final int status = transaction.getStatus();
+            return status == Status.STATUS_ACTIVE || status == Status.STATUS_MARKED_ROLLBACK;
+        } catch (final SystemException e) {
+            throw new SQLException("Unable to get transaction status", e);
+        }
+    }
+
+    private Transaction getTransaction() throws SQLException {
+        final Transaction transaction = this.transactionRef.get();
+        if (transaction == null) {
+            throw new SQLException("Unable to enlist connection because the transaction has been garbage collected");
+        }
+        return transaction;
+    }
+}

==================================================
TransactionRegistry.java
new file mode 100644
index 0000000000..6b25a4bf2d
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/TransactionContextListener.java
@@ -0,0 +1,33 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2.managed;
+
+/**
+ * A listener for transaction completion events.
+ *
+ * @author Dain Sundstrom
+ * @since 2.0
+ */
+public interface TransactionContextListener {
+    /**
+     * Occurs after the transaction commits or rolls back.
+     * @param transactionContext the transaction context that completed
+     * @param commited true if the transaction committed; false otherwise
+     */
+    void afterCompletion(TransactionContext transactionContext, boolean commited);
+}

==================================================
XAConnectionFactory.java
new file mode 100644
index 0000000000..41b80a6b3f
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/TransactionRegistry.java
@@ -0,0 +1,148 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2.managed;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+import javax.transaction.Status;
+import javax.transaction.SystemException;
+import javax.transaction.Transaction;
+import javax.transaction.TransactionManager;
+import javax.transaction.xa.XAResource;
+
+import org.apache.tomcat.dbcp.dbcp2.DelegatingConnection;
+
+
+/**
+ * TransactionRegistry tracks Connections and XAResources in a transacted environment for a single XAConnectionFactory.
+ * <p>
+ * The TransactionRegistry hides the details of transaction processing from the existing DBCP pooling code, and gives
+ * the ManagedConnection a way to enlist connections in a transaction, allowing for the maximal rescue of DBCP.
+ * </p>
+ * @author Dain Sundstrom
+ * @since 2.0
+ */
+public class TransactionRegistry {
+    private final TransactionManager transactionManager;
+    private final Map<Transaction, TransactionContext> caches =
+            new WeakHashMap<>();
+    private final Map<Connection, XAResource> xaResources = new WeakHashMap<>();
+
+    /**
+     * Creates a TransactionRegistry for the specified transaction manager.
+     * @param transactionManager the transaction manager used to enlist connections
+     */
+    public TransactionRegistry(final TransactionManager transactionManager) {
+        this.transactionManager = transactionManager;
+    }
+
+    /**
+     * Registers the association between a Connection and a XAResource.  When a connection
+     * is enlisted in a transaction, it is actually the XAResource that is given to the transaction
+     * manager.
+     *
+     * @param connection the JDBC connection
+     * @param xaResource the XAResource which managed the connection within a transaction
+     */
+    public synchronized void registerConnection(final Connection connection, final XAResource xaResource) {
+        if (connection == null) {
+            throw new NullPointerException("connection is null");
+        }
+        if (xaResource == null) {
+            throw new NullPointerException("xaResource is null");
+        }
+        xaResources.put(connection, xaResource);
+    }
+
+    /**
+     * Gets the XAResource registered for the connection.
+     * @param connection the connection
+     * @return the XAResource registered for the connection; never null
+     * @throws SQLException if the connection does not have a registered XAResource
+     */
+    public synchronized XAResource getXAResource(final Connection connection) throws SQLException {
+        if (connection == null) {
+            throw new NullPointerException("connection is null");
+        }
+        final Connection key = getConnectionKey(connection);
+        final XAResource xaResource = xaResources.get(key);
+        if (xaResource == null) {
+            throw new SQLException("Connection does not have a registered XAResource " + connection);
+        }
+        return xaResource;
+    }
+
+    /**
+     * Gets the active TransactionContext or null if not Transaction is active.
+     * @return the active TransactionContext or null if no Transaction is active
+     * @throws SQLException if an error occurs while fetching the transaction
+     */
+    public TransactionContext getActiveTransactionContext() throws SQLException {
+        Transaction transaction = null;
+        try {
+            transaction = transactionManager.getTransaction();
+
+            // was there a transaction?
+            if (transaction == null) {
+                return null;
+            }
+
+            // is it active
+            final int status = transaction.getStatus();
+            if (status != Status.STATUS_ACTIVE && status != Status.STATUS_MARKED_ROLLBACK) {
+                return null;
+            }
+        } catch (final SystemException e) {
+            throw new SQLException("Unable to determine current transaction ", e);
+        }
+
+        // register the the context (or create a new one)
+        synchronized (this) {
+            TransactionContext cache = caches.get(transaction);
+            if (cache == null) {
+                cache = new TransactionContext(this, transaction);
+                caches.put(transaction, cache);
+            }
+            return cache;
+        }
+    }
+
+    /**
+     * Unregisters a destroyed connection from {@link TransactionRegistry}
+     * @param connection
+     */
+    public synchronized void unregisterConnection(final Connection connection) {
+        final Connection key = getConnectionKey(connection);
+        xaResources.remove(key);
+    }
+
+
+    private Connection getConnectionKey(final Connection connection) {
+        Connection result;
+        if (connection instanceof DelegatingConnection) {
+            result = ((DelegatingConnection<?>) connection).getInnermostDelegateInternal();
+        } else {
+            result = connection;
+        }
+        return result;
+    }
+}
+

==================================================
package-info.java
new file mode 100644
index 0000000000..958b0f3bb3
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/XAConnectionFactory.java
@@ -0,0 +1,59 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.dbcp.dbcp2.managed;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+
+import org.apache.tomcat.dbcp.dbcp2.ConnectionFactory;
+
+/**
+ * XAConnectionFactory is an extension of ConnectionFactory used to create connections
+ * in a transaction managed environment.  The XAConnectionFactory operates like a normal
+ * ConnectionFactory except a TransactionRegistry is provided from which the XAResource
+ * for a connection can be obtained.  This allows the existing DBCP pool code to work with
+ * XAConnections and gives a the ManagedConnection a way to enlist a connection in the
+ * the transaction.
+ *
+ * @author Dain Sundstrom
+ * @author Rodney Waldhoff
+ * @since 2.0
+ */
+public interface XAConnectionFactory extends ConnectionFactory {
+    /**
+     * Gets the TransactionRegistry for this connection factory which contains a the
+     * XAResource for every connection created by this factory.
+     *
+     * @return the transaction registry for this connection factory
+     */
+    TransactionRegistry getTransactionRegistry();
+
+    /**
+     * Create a new {@link java.sql.Connection} in an implementation specific fashion.
+     * <p>
+     * An implementation can assume that the caller of this will wrap the connection in
+     * a proxy that protects access to the setAutoCommit, commit and rollback when
+     * enrolled in a XA transaction.
+     * </p>
+     *
+     * @return a new {@link java.sql.Connection}
+     * @throws java.sql.SQLException if a database error occurs creating the connection
+     */
+    @Override
+    Connection createConnection() throws SQLException;
+}

==================================================
