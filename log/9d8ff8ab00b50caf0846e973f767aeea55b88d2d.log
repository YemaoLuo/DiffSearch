9d8ff8ab00b50caf0846e973f767aeea55b88d2d
==================================================
Remainder of tabs to spaces changes
==================================================
Mark Emlyn
==================================================
Sat Jul 24 13:03:11 2010 +0000
==================================================
Constants.java
index 784b70a28c..f5ac96a204 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -19,7 +19,5 @@
     "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
     "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
 <module name="Checker">
-<!--
   <module name="FileTabCharacter"/>
--->
 </module>
\ No newline at end of file

==================================================
EmbeddedServletOptions.java
index cea3a50c96..694017661a 100644
--- a/java/org/apache/jasper/Constants.java
+++ b/java/org/apache/jasper/Constants.java
@@ -56,9 +56,9 @@ public class Constants {
      * generated code. 
      */
     private static final String[] PRIVATE_STANDARD_IMPORTS = { 
-	"javax.servlet.*", 
-	"javax.servlet.http.*", 
-	"javax.servlet.jsp.*"
+        "javax.servlet.*", 
+        "javax.servlet.http.*", 
+        "javax.servlet.jsp.*"
     };
     public static final List<String> STANDARD_IMPORTS =
         Collections.unmodifiableList(Arrays.asList(PRIVATE_STANDARD_IMPORTS));
@@ -135,26 +135,26 @@ public class Constants {
      * of the DTDs for tag library descriptors. 
      */
     public static final String TAGLIB_DTD_PUBLIC_ID_11 = 
-	"-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.1//EN";
+        "-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.1//EN";
     public static final String TAGLIB_DTD_RESOURCE_PATH_11 = 
-	"/javax/servlet/jsp/resources/web-jsptaglibrary_1_1.dtd";
+        "/javax/servlet/jsp/resources/web-jsptaglibrary_1_1.dtd";
     public static final String TAGLIB_DTD_PUBLIC_ID_12 = 
-	"-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN";
+        "-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN";
     public static final String TAGLIB_DTD_RESOURCE_PATH_12 = 
-	"/javax/servlet/jsp/resources/web-jsptaglibrary_1_2.dtd";
+        "/javax/servlet/jsp/resources/web-jsptaglibrary_1_2.dtd";
 
     /**
      * Public Id and the Resource path (of the cached copy) 
      * of the DTDs for web application deployment descriptors
      */
     public static final String WEBAPP_DTD_PUBLIC_ID_22 = 
-	"-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN";
+        "-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN";
     public static final String WEBAPP_DTD_RESOURCE_PATH_22 = 
-	"/javax/servlet/resources/web-app_2_2.dtd";
+        "/javax/servlet/resources/web-app_2_2.dtd";
     public static final String WEBAPP_DTD_PUBLIC_ID_23 = 
-	"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN";
+        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN";
     public static final String WEBAPP_DTD_RESOURCE_PATH_23 = 
-	"/javax/servlet/resources/web-app_2_3.dtd";
+        "/javax/servlet/resources/web-app_2_3.dtd";
 
     /**
      * List of the Public IDs that we cache, and their
@@ -164,19 +164,19 @@ public class Constants {
      */
     // TODO Add 2.4, 2.5, 3.0
     private static final String[] PRIVATE_CACHED_DTD_PUBLIC_IDS = {
-	TAGLIB_DTD_PUBLIC_ID_11,
-	TAGLIB_DTD_PUBLIC_ID_12,
-	WEBAPP_DTD_PUBLIC_ID_22,
-	WEBAPP_DTD_PUBLIC_ID_23,
+        TAGLIB_DTD_PUBLIC_ID_11,
+        TAGLIB_DTD_PUBLIC_ID_12,
+        WEBAPP_DTD_PUBLIC_ID_22,
+        WEBAPP_DTD_PUBLIC_ID_23,
     };
     public static final List<String> CACHED_DTD_PUBLIC_IDS =
         Collections.unmodifiableList(
                 Arrays.asList(PRIVATE_CACHED_DTD_PUBLIC_IDS));
     private static final String[] PRIVATE_CACHED_DTD_RESOURCE_PATHS = {
-	TAGLIB_DTD_RESOURCE_PATH_11,
-	TAGLIB_DTD_RESOURCE_PATH_12,
-	WEBAPP_DTD_RESOURCE_PATH_22,
-	WEBAPP_DTD_RESOURCE_PATH_23,
+        TAGLIB_DTD_RESOURCE_PATH_11,
+        TAGLIB_DTD_RESOURCE_PATH_12,
+        WEBAPP_DTD_RESOURCE_PATH_22,
+        WEBAPP_DTD_RESOURCE_PATH_23,
     };
     public static final List<String> CACHED_DTD_RESOURCE_PATHS =
         Collections.unmodifiableList(

==================================================
JasperException.java
index 3fe5a8855a..733654f480 100644
--- a/java/org/apache/jasper/EmbeddedServletOptions.java
+++ b/java/org/apache/jasper/EmbeddedServletOptions.java
@@ -451,7 +451,7 @@ public final class EmbeddedServletOptions implements Options {
             } else {
                 if (log.isWarnEnabled()) {
                     log.warn(Localizer.getMessage("jsp.warning.enablePooling"));
-                }		       	   
+                }
             }
         }
         

==================================================
JspCompilationContext.java
index 0e2eddf23b..3dd19aa705 100644
--- a/java/org/apache/jasper/JasperException.java
+++ b/java/org/apache/jasper/JasperException.java
@@ -26,7 +26,7 @@ package org.apache.jasper;
 public class JasperException extends javax.servlet.ServletException {
     
     public JasperException(String reason) {
-	super(reason);
+        super(reason);
     }
 
     /**
@@ -34,13 +34,13 @@ public class JasperException extends javax.servlet.ServletException {
      * throwing a JasperException
      */
     public JasperException (String reason, Throwable exception) {
-   	super(reason, exception);
+        super(reason, exception);
     }
 
     /**
      * Creates a JasperException with the embedded exception
      */
     public JasperException (Throwable exception) {
-   	super(exception);
+        super(exception);
     }
 }

==================================================
Compiler.java
index 47f454d993..19a6116265 100644
--- a/java/org/apache/jasper/JspCompilationContext.java
+++ b/java/org/apache/jasper/JspCompilationContext.java
@@ -195,9 +195,9 @@ public class JspCompilationContext {
      * plus the directory derived from the package name.
      */
     public String getOutputDir() {
-	if (outputDir == null) {
-	    createOutputDir();
-	}
+        if (outputDir == null) {
+            createOutputDir();
+        }
 
         return outputDir;
     }
@@ -458,7 +458,7 @@ public class JspCompilationContext {
         }
         return derivedPackageName;
     }
-	    
+            
     /**
      * The package name into which the servlet class is generated.
      */
@@ -502,12 +502,12 @@ public class JspCompilationContext {
         }
 
         if (isTagFile()) {
-	    String tagName = tagInfo.getTagClassName();
+            String tagName = tagInfo.getTagClassName();
             javaPath = tagName.replace('.', '/') + ".java";
         } else {
             javaPath = getServletPackageName().replace('.', '/') + '/' +
                        getServletClassName() + ".java";
-	}
+        }
         return javaPath;
     }
 

==================================================
Dumper.java
index 1d47ad404b..0c02fbda59 100644
--- a/java/org/apache/jasper/compiler/Compiler.java
+++ b/java/org/apache/jasper/compiler/Compiler.java
@@ -293,25 +293,25 @@ public abstract class Compiler {
         return smapStr;
     }
 
-	private ServletWriter setupContextWriter(String javaFileName)
-			throws FileNotFoundException, JasperException {
-		ServletWriter writer;
-		// Setup the ServletWriter
-		String javaEncoding = ctxt.getOptions().getJavaEncoding();
-		OutputStreamWriter osw = null;
-
-		try {
-		    osw = new OutputStreamWriter(
-		            new FileOutputStream(javaFileName), javaEncoding);
-		} catch (UnsupportedEncodingException ex) {
-		    errDispatcher.jspError("jsp.error.needAlternateJavaEncoding",
-		            javaEncoding);
-		}
-
-		writer = new ServletWriter(new PrintWriter(osw));
-		ctxt.setWriter(writer);
-		return writer;
-	}
+    private ServletWriter setupContextWriter(String javaFileName)
+            throws FileNotFoundException, JasperException {
+        ServletWriter writer;
+        // Setup the ServletWriter
+        String javaEncoding = ctxt.getOptions().getJavaEncoding();
+        OutputStreamWriter osw = null;
+
+        try {
+            osw = new OutputStreamWriter(
+                    new FileOutputStream(javaFileName), javaEncoding);
+        } catch (UnsupportedEncodingException ex) {
+            errDispatcher.jspError("jsp.error.needAlternateJavaEncoding",
+                    javaEncoding);
+        }
+
+        writer = new ServletWriter(new PrintWriter(osw));
+        ctxt.setWriter(writer);
+        return writer;
+    }
 
     /**
      * Compile the servlet from .java file to .class file

==================================================
ErrorDispatcher.java
index 8c45491908..197bdcf6b7 100644
--- a/java/org/apache/jasper/compiler/Dumper.java
+++ b/java/org/apache/jasper/compiler/Dumper.java
@@ -23,198 +23,198 @@ import org.apache.jasper.JasperException;
 class Dumper {
 
     static class DumpVisitor extends Node.Visitor {
-	private int indent = 0;
-
-	private String getAttributes(Attributes attrs) {
-	    if (attrs == null)
-		return "";
-
-	    StringBuilder buf = new StringBuilder();
-	    for (int i=0; i < attrs.getLength(); i++) {
-		buf.append(" " + attrs.getQName(i) + "=\""
-			   + attrs.getValue(i) + "\"");
-	    }
-	    return buf.toString();
-	}
-
-	private void printString(String str) {
-	    printIndent();
-	    System.out.print(str);
-	}
-
-	private void printString(String prefix, String str, String suffix) {
-	    printIndent();
-	    if (str != null) {
-		System.out.print(prefix + str + suffix);
-	    } else {
-		System.out.print(prefix + suffix);
-	    }
-	}
-
-	private void printAttributes(String prefix, Attributes attrs,
-				     String suffix) {
-	    printString(prefix, getAttributes(attrs), suffix);
-	}
-
-	private void dumpBody(Node n) throws JasperException {
-	    Node.Nodes page = n.getBody();
-	    if (page != null) {
-//		indent++;
-		page.visit(this);
-//		indent--;
-	    }
+        private int indent = 0;
+
+        private String getAttributes(Attributes attrs) {
+            if (attrs == null)
+                return "";
+
+            StringBuilder buf = new StringBuilder();
+            for (int i=0; i < attrs.getLength(); i++) {
+                buf.append(" " + attrs.getQName(i) + "=\""
+                           + attrs.getValue(i) + "\"");
+            }
+            return buf.toString();
+        }
+
+        private void printString(String str) {
+            printIndent();
+            System.out.print(str);
+        }
+
+        private void printString(String prefix, String str, String suffix) {
+            printIndent();
+            if (str != null) {
+                System.out.print(prefix + str + suffix);
+            } else {
+                System.out.print(prefix + suffix);
+            }
+        }
+
+        private void printAttributes(String prefix, Attributes attrs,
+                                     String suffix) {
+            printString(prefix, getAttributes(attrs), suffix);
+        }
+
+        private void dumpBody(Node n) throws JasperException {
+            Node.Nodes page = n.getBody();
+            if (page != null) {
+//                indent++;
+                page.visit(this);
+//                indent--;
+            }
         }
 
         @Override
         public void visit(Node.PageDirective n) throws JasperException {
-	    printAttributes("<%@ page", n.getAttributes(), "%>");
+            printAttributes("<%@ page", n.getAttributes(), "%>");
         }
 
         @Override
         public void visit(Node.TaglibDirective n) throws JasperException {
-	    printAttributes("<%@ taglib", n.getAttributes(), "%>");
+            printAttributes("<%@ taglib", n.getAttributes(), "%>");
         }
 
         @Override
         public void visit(Node.IncludeDirective n) throws JasperException {
-	    printAttributes("<%@ include", n.getAttributes(), "%>");
-	    dumpBody(n);
+            printAttributes("<%@ include", n.getAttributes(), "%>");
+            dumpBody(n);
         }
 
         @Override
         public void visit(Node.Comment n) throws JasperException {
-	    printString("<%--", n.getText(), "--%>");
+            printString("<%--", n.getText(), "--%>");
         }
 
         @Override
         public void visit(Node.Declaration n) throws JasperException {
-	    printString("<%!", n.getText(), "%>");
+            printString("<%!", n.getText(), "%>");
         }
 
         @Override
         public void visit(Node.Expression n) throws JasperException {
-	    printString("<%=", n.getText(), "%>");
+            printString("<%=", n.getText(), "%>");
         }
 
         @Override
         public void visit(Node.Scriptlet n) throws JasperException {
-	    printString("<%", n.getText(), "%>");
+            printString("<%", n.getText(), "%>");
         }
 
         @Override
         public void visit(Node.IncludeAction n) throws JasperException {
-	    printAttributes("<jsp:include", n.getAttributes(), ">");
-	    dumpBody(n);
+            printAttributes("<jsp:include", n.getAttributes(), ">");
+            dumpBody(n);
             printString("</jsp:include>");
         }
 
         @Override
         public void visit(Node.ForwardAction n) throws JasperException {
-	    printAttributes("<jsp:forward", n.getAttributes(), ">");
-	    dumpBody(n);
-	    printString("</jsp:forward>");
+            printAttributes("<jsp:forward", n.getAttributes(), ">");
+            dumpBody(n);
+            printString("</jsp:forward>");
         }
 
         @Override
         public void visit(Node.GetProperty n) throws JasperException {
-	    printAttributes("<jsp:getProperty", n.getAttributes(), "/>");
+            printAttributes("<jsp:getProperty", n.getAttributes(), "/>");
         }
 
         @Override
         public void visit(Node.SetProperty n) throws JasperException {
-	    printAttributes("<jsp:setProperty", n.getAttributes(), ">");
+            printAttributes("<jsp:setProperty", n.getAttributes(), ">");
             dumpBody(n);
             printString("</jsp:setProperty>");
         }
 
         @Override
         public void visit(Node.UseBean n) throws JasperException {
-	    printAttributes("<jsp:useBean", n.getAttributes(), ">");
-	    dumpBody(n);
-	    printString("</jsp:useBean>");
+            printAttributes("<jsp:useBean", n.getAttributes(), ">");
+            dumpBody(n);
+            printString("</jsp:useBean>");
         }
-	
+        
         @Override
         public void visit(Node.PlugIn n) throws JasperException {
-	    printAttributes("<jsp:plugin", n.getAttributes(), ">");
-	    dumpBody(n);
-	    printString("</jsp:plugin>");
-	}
+            printAttributes("<jsp:plugin", n.getAttributes(), ">");
+            dumpBody(n);
+            printString("</jsp:plugin>");
+        }
         
         @Override
         public void visit(Node.ParamsAction n) throws JasperException {
-	    printAttributes("<jsp:params", n.getAttributes(), ">");
-	    dumpBody(n);
-	    printString("</jsp:params>");
+            printAttributes("<jsp:params", n.getAttributes(), ">");
+            dumpBody(n);
+            printString("</jsp:params>");
         }
         
         @Override
         public void visit(Node.ParamAction n) throws JasperException {
-	    printAttributes("<jsp:param", n.getAttributes(), ">");
-	    dumpBody(n);
-	    printString("</jsp:param>");
+            printAttributes("<jsp:param", n.getAttributes(), ">");
+            dumpBody(n);
+            printString("</jsp:param>");
         }
         
         @Override
         public void visit(Node.NamedAttribute n) throws JasperException {
-	    printAttributes("<jsp:attribute", n.getAttributes(), ">");
-	    dumpBody(n);
-	    printString("</jsp:attribute>");
+            printAttributes("<jsp:attribute", n.getAttributes(), ">");
+            dumpBody(n);
+            printString("</jsp:attribute>");
         }
 
         @Override
         public void visit(Node.JspBody n) throws JasperException {
-	    printAttributes("<jsp:body", n.getAttributes(), ">");
-	    dumpBody(n);
-	    printString("</jsp:body>");
+            printAttributes("<jsp:body", n.getAttributes(), ">");
+            dumpBody(n);
+            printString("</jsp:body>");
         }
         
         @Override
         public void visit(Node.ELExpression n) throws JasperException {
-	    printString( "${" + new String( n.getText() ) + "}" );
+            printString( "${" + new String( n.getText() ) + "}" );
         }
 
         @Override
         public void visit(Node.CustomTag n) throws JasperException {
-	    printAttributes("<" + n.getQName(), n.getAttributes(), ">");
-	    dumpBody(n);
-	    printString("</" + n.getQName() + ">");
+            printAttributes("<" + n.getQName(), n.getAttributes(), ">");
+            dumpBody(n);
+            printString("</" + n.getQName() + ">");
         }
 
-	@Override
-    public void visit(Node.UninterpretedTag n) throws JasperException {
-	    String tag = n.getQName();
-	    printAttributes("<"+tag, n.getAttributes(), ">");
-	    dumpBody(n);
-	    printString("</" + tag + ">");
+        @Override
+        public void visit(Node.UninterpretedTag n) throws JasperException {
+            String tag = n.getQName();
+            printAttributes("<"+tag, n.getAttributes(), ">");
+            dumpBody(n);
+            printString("</" + tag + ">");
         }
 
-	@Override
-    public void visit(Node.TemplateText n) throws JasperException {
-	    printString(new String(n.getText()));
-	}
+        @Override
+        public void visit(Node.TemplateText n) throws JasperException {
+            printString(new String(n.getText()));
+        }
 
-	private void printIndent() {
-	    for (int i=0; i < indent; i++) {
-		System.out.print("  ");
-	    }
-	}
+        private void printIndent() {
+            for (int i=0; i < indent; i++) {
+                System.out.print("  ");
+            }
+        }
     }
 
     public static void dump(Node n) {
-	try {
-	    n.accept(new DumpVisitor());	
-	} catch (JasperException e) {
-	    e.printStackTrace();
-	}
+        try {
+            n.accept(new DumpVisitor());        
+        } catch (JasperException e) {
+            e.printStackTrace();
+        }
     }
 
     public static void dump(Node.Nodes page) {
-	try {
-	    page.visit(new DumpVisitor());
-	} catch (JasperException e) {
-	    e.printStackTrace();
-	}
+        try {
+            page.visit(new DumpVisitor());
+        } catch (JasperException e) {
+            e.printStackTrace();
+        }
     }
 }
 

==================================================
ErrorHandler.java
index 882575ed9d..395a54f09c 100644
--- a/java/org/apache/jasper/compiler/ErrorDispatcher.java
+++ b/java/org/apache/jasper/compiler/ErrorDispatcher.java
@@ -56,8 +56,8 @@ public class ErrorDispatcher {
      * otherwise
      */
     public ErrorDispatcher(boolean jspcMode) {
-	// XXX check web.xml for custom error handler
-	errHandler = new DefaultErrorHandler();
+        // XXX check web.xml for custom error handler
+        errHandler = new DefaultErrorHandler();
         this.jspcMode = jspcMode;
     }
 
@@ -71,7 +71,7 @@ public class ErrorDispatcher {
      * @param errCode Error code
      */
     public void jspError(String errCode) throws JasperException {
-	dispatch(null, errCode, null, null);
+        dispatch(null, errCode, null, null);
     }
 
     /*
@@ -85,7 +85,7 @@ public class ErrorDispatcher {
      * @param errCode Error code
      */
     public void jspError(Mark where, String errCode) throws JasperException {
-	dispatch(where, errCode, null, null);
+        dispatch(where, errCode, null, null);
     }
 
     /*
@@ -99,7 +99,7 @@ public class ErrorDispatcher {
      * @param errCode Error code
      */
     public void jspError(Node n, String errCode) throws JasperException {
-	dispatch(n.getStart(), errCode, null, null);
+        dispatch(n.getStart(), errCode, null, null);
     }
 
     /*
@@ -113,7 +113,7 @@ public class ErrorDispatcher {
      * @param arg Argument for parametric replacement
      */
     public void jspError(String errCode, String arg) throws JasperException {
-	dispatch(null, errCode, new Object[] {arg}, null);
+        dispatch(null, errCode, new Object[] {arg}, null);
     }
 
     /*
@@ -128,8 +128,8 @@ public class ErrorDispatcher {
      * @param arg Argument for parametric replacement
      */
     public void jspError(Mark where, String errCode, String arg)
-	        throws JasperException {
-	dispatch(where, errCode, new Object[] {arg}, null);
+                throws JasperException {
+        dispatch(where, errCode, new Object[] {arg}, null);
     }
 
     /*
@@ -144,8 +144,8 @@ public class ErrorDispatcher {
      * @param arg Argument for parametric replacement
      */
     public void jspError(Node n, String errCode, String arg)
-	        throws JasperException {
-	dispatch(n.getStart(), errCode, new Object[] {arg}, null);
+                throws JasperException {
+        dispatch(n.getStart(), errCode, new Object[] {arg}, null);
     }
 
     /*
@@ -160,8 +160,8 @@ public class ErrorDispatcher {
      * @param arg2 Second argument for parametric replacement
      */
     public void jspError(String errCode, String arg1, String arg2)
-	        throws JasperException {
-	dispatch(null, errCode, new Object[] {arg1, arg2}, null);
+                throws JasperException {
+        dispatch(null, errCode, new Object[] {arg1, arg2}, null);
     }
 
     /*
@@ -177,8 +177,8 @@ public class ErrorDispatcher {
      * @param arg3 Third argument for parametric replacement
      */
     public void jspError(String errCode, String arg1, String arg2, String arg3)
-	        throws JasperException {
-	dispatch(null, errCode, new Object[] {arg1, arg2, arg3}, null);
+                throws JasperException {
+        dispatch(null, errCode, new Object[] {arg1, arg2, arg3}, null);
     }
 
     /*
@@ -194,8 +194,8 @@ public class ErrorDispatcher {
      * @param arg2 Second argument for parametric replacement
      */
     public void jspError(Mark where, String errCode, String arg1, String arg2)
-	        throws JasperException {
-	dispatch(where, errCode, new Object[] {arg1, arg2}, null);
+                throws JasperException {
+        dispatch(where, errCode, new Object[] {arg1, arg2}, null);
     }
 
     /*
@@ -232,8 +232,8 @@ public class ErrorDispatcher {
      */
 
     public void jspError(Node n, String errCode, String arg1, String arg2)
-	        throws JasperException {
-	dispatch(n.getStart(), errCode, new Object[] {arg1, arg2}, null);
+                throws JasperException {
+        dispatch(n.getStart(), errCode, new Object[] {arg1, arg2}, null);
     }
 
     /*
@@ -252,8 +252,8 @@ public class ErrorDispatcher {
 
     public void jspError(Node n, String errCode, String arg1, String arg2,
                          String arg3)
-	        throws JasperException {
-	dispatch(n.getStart(), errCode, new Object[] {arg1, arg2, arg3}, null);
+                throws JasperException {
+        dispatch(n.getStart(), errCode, new Object[] {arg1, arg2, arg3}, null);
     }
 
     /*
@@ -262,7 +262,7 @@ public class ErrorDispatcher {
      * @param e Parsing exception
      */
     public void jspError(Exception e) throws JasperException {
-	dispatch(null, null, null, e);
+        dispatch(null, null, null, e);
     }
 
     /*
@@ -277,8 +277,8 @@ public class ErrorDispatcher {
      * @param e Parsing exception
      */
     public void jspError(String errCode, String arg, Exception e)
-	        throws JasperException {
-	dispatch(null, errCode, new Object[] {arg}, e);
+                throws JasperException {
+        dispatch(null, errCode, new Object[] {arg}, e);
     }
 
     /*
@@ -294,8 +294,8 @@ public class ErrorDispatcher {
      * @param e Parsing exception
      */
     public void jspError(Node n, String errCode, String arg, Exception e)
-	        throws JasperException {
-	dispatch(n.getStart(), errCode, new Object[] {arg}, e);
+                throws JasperException {
+        dispatch(n.getStart(), errCode, new Object[] {arg}, e);
     }
 
     /**
@@ -315,7 +315,7 @@ public class ErrorDispatcher {
                                                       Node.Nodes page)
             throws JasperException, IOException {
 
-	return parseJavacMessage(errMsg, fname, page);
+        return parseJavacMessage(errMsg, fname, page);
     }
 
     /*
@@ -361,23 +361,23 @@ public class ErrorDispatcher {
      * @param e Parsing exception
      */
     private void dispatch(Mark where, String errCode, Object[] args,
-			  Exception e) throws JasperException {
-	String file = null;
-	String errMsg = null;
-	int line = -1;
-	int column = -1;
-	boolean hasLocation = false;
-
-	// Localize
-	if (errCode != null) {
-	    errMsg = Localizer.getMessage(errCode, args);
-	} else if (e != null) {
-	    // give a hint about what's wrong
-	    errMsg = e.getMessage();
-	}
-
-	// Get error location
-	if (where != null) {
+                          Exception e) throws JasperException {
+        String file = null;
+        String errMsg = null;
+        int line = -1;
+        int column = -1;
+        boolean hasLocation = false;
+
+        // Localize
+        if (errCode != null) {
+            errMsg = Localizer.getMessage(errCode, args);
+        } else if (e != null) {
+            // give a hint about what's wrong
+            errMsg = e.getMessage();
+        }
+
+        // Get error location
+        if (where != null) {
             if (jspcMode) {
                 // Get the full URL of the resource that caused the error
                 try {
@@ -391,23 +391,23 @@ public class ErrorDispatcher {
                 // disclose any local filesystem details
                 file = where.getFile();
             }
-	    line = where.getLineNumber();
-	    column = where.getColumnNumber();
-	    hasLocation = true;
-	}
-
-	// Get nested exception
-	Exception nestedEx = e;
-	if ((e instanceof SAXException)
-	        && (((SAXException) e).getException() != null)) {
-	    nestedEx = ((SAXException) e).getException();
-	}
-
-	if (hasLocation) {
-	    errHandler.jspError(file, line, column, errMsg, nestedEx);
-	} else {
-	    errHandler.jspError(errMsg, nestedEx);
-	}
+            line = where.getLineNumber();
+            column = where.getColumnNumber();
+            hasLocation = true;
+        }
+
+        // Get nested exception
+        Exception nestedEx = e;
+        if ((e instanceof SAXException)
+                && (((SAXException) e).getException() != null)) {
+            nestedEx = ((SAXException) e).getException();
+        }
+
+        if (hasLocation) {
+            errHandler.jspError(file, line, column, errMsg, nestedEx);
+        } else {
+            errHandler.jspError(errMsg, nestedEx);
+        }
     }
 
     /*
@@ -428,7 +428,7 @@ public class ErrorDispatcher {
      */
     private static JavacErrorDetail[] parseJavacMessage(
                                 String errMsg, String fname, Node.Nodes page)
-	        throws IOException, JasperException {
+                throws IOException, JasperException {
 
         ArrayList<JavacErrorDetail> errors = new ArrayList<JavacErrorDetail>();
         StringBuilder errMsgBuf = null;
@@ -576,41 +576,41 @@ public class ErrorDispatcher {
      */
     static class ErrorVisitor extends Node.Visitor {
 
-	// Java source line number to be mapped
-	private int lineNum;
-
-	/*
-	 * JSP node whose Java source code range in the generated servlet
-	 * contains the Java source line number to be mapped
-	 */
-	Node found;
-
-	/*
-	 * Constructor.
-	 *
-	 * @param lineNum Source line number in the generated servlet code
-	 */
-	public ErrorVisitor(int lineNum) {
-	    this.lineNum = lineNum;
-	}
-
-	@Override
-    public void doVisit(Node n) throws JasperException {
-	    if ((lineNum >= n.getBeginJavaLine())
-		    && (lineNum < n.getEndJavaLine())) {
-		found = n;
-	    }
+        // Java source line number to be mapped
+        private int lineNum;
+
+        /*
+         * JSP node whose Java source code range in the generated servlet
+         * contains the Java source line number to be mapped
+         */
+        Node found;
+
+        /*
+         * Constructor.
+         *
+         * @param lineNum Source line number in the generated servlet code
+         */
+        public ErrorVisitor(int lineNum) {
+            this.lineNum = lineNum;
+        }
+
+        @Override
+        public void doVisit(Node n) throws JasperException {
+            if ((lineNum >= n.getBeginJavaLine())
+                    && (lineNum < n.getEndJavaLine())) {
+                found = n;
+            }
         }
 
-	/*
-	 * Gets the JSP node to which the source line number in the generated
-	 * servlet code was mapped.
-	 *
-	 * @return JSP node to which the source line number in the generated
-	 * servlet code was mapped
-	 */
-	public Node getJspSourceNode() {
-	    return found;
-	}
+        /*
+         * Gets the JSP node to which the source line number in the generated
+         * servlet code was mapped.
+         *
+         * @return JSP node to which the source line number in the generated
+         * servlet code was mapped
+         */
+        public Node getJspSourceNode() {
+            return found;
+        }
     }
 }

==================================================
Generator.java
index a998edaf07..36ad3aaf53 100644
--- a/java/org/apache/jasper/compiler/ErrorHandler.java
+++ b/java/org/apache/jasper/compiler/ErrorHandler.java
@@ -42,7 +42,7 @@ public interface ErrorHandler {
      * @param exception Parse exception
      */
     public void jspError(String fname, int line, int column, String msg,
-			 Exception exception) throws JasperException;
+            Exception exception) throws JasperException;
 
     /**
      * Processes the given JSP parse error.
@@ -51,7 +51,7 @@ public interface ErrorHandler {
      * @param exception Parse exception
      */
     public void jspError(String msg, Exception exception)
-	throws JasperException;
+            throws JasperException;
 
     /**
      * Processes the given javac compilation errors.
@@ -60,7 +60,7 @@ public interface ErrorHandler {
      * compilation errors
      */
     public void javacError(JavacErrorDetail[] details)
-	throws JasperException;
+            throws JasperException;
 
     /**
      * Processes the given javac error report and exception.
@@ -69,5 +69,5 @@ public interface ErrorHandler {
      * @param exception Compilation exception
      */
     public void javacError(String errorReport, Exception exception)
-        throws JasperException;
+            throws JasperException;
 }

==================================================
JarScannerFactory.java
index 7ab94965b6..0d8ea733f4 100644
--- a/java/org/apache/jasper/compiler/Generator.java
+++ b/java/org/apache/jasper/compiler/Generator.java
@@ -2299,30 +2299,30 @@ class Generator {
         }
 
         private void writeNewInstance(String tagHandlerVar, String tagHandlerClassName) {
-        	if (Constants.USE_INSTANCE_MANAGER_FOR_TAGS) {
-        		out.printin(tagHandlerClassName);
-        		out.print(" ");
-        		out.print(tagHandlerVar);
-        		out.print(" = (");
-        		out.print(tagHandlerClassName);
-        		out.print(")");
-        		out.print(VAR_INSTANCEMANAGER);
-        		out.print(".newInstance(\"");
-        		out.print(tagHandlerClassName);
-        		out.println("\", this.getClass().getClassLoader());");
-        	} else {
-        		out.printin(tagHandlerClassName);
-        		out.print(" ");
-        		out.print(tagHandlerVar);
-        		out.print(" = (");
-        		out.print("new ");
-        		out.print(tagHandlerClassName);
-        		out.println("());");
-        		out.printin(VAR_INSTANCEMANAGER);
-        		out.print(".newInstance(");
-        		out.print(tagHandlerVar);
-        		out.println(");");
-        	}
+            if (Constants.USE_INSTANCE_MANAGER_FOR_TAGS) {
+                out.printin(tagHandlerClassName);
+                out.print(" ");
+                out.print(tagHandlerVar);
+                out.print(" = (");
+                out.print(tagHandlerClassName);
+                out.print(")");
+                out.print(VAR_INSTANCEMANAGER);
+                out.print(".newInstance(\"");
+                out.print(tagHandlerClassName);
+                out.println("\", this.getClass().getClassLoader());");
+            } else {
+                out.printin(tagHandlerClassName);
+                out.print(" ");
+                out.print(tagHandlerVar);
+                out.print(" = (");
+                out.print("new ");
+                out.print(tagHandlerClassName);
+                out.println("());");
+                out.printin(VAR_INSTANCEMANAGER);
+                out.print(".newInstance(");
+                out.print(tagHandlerVar);
+                out.println(");");
+            }
         }
 
         private void writeDestroyInstance(String tagHandlerVar) {

==================================================
JasperTagInfo.java
index b48e95915c..56ea260752 100644
--- a/java/org/apache/jasper/compiler/JarScannerFactory.java
+++ b/java/org/apache/jasper/compiler/JarScannerFactory.java
@@ -41,7 +41,7 @@ public class JarScannerFactory {
      */
     public static JarScanner getJarScanner(ServletContext ctxt) {
         JarScanner jarScanner = 
-        	(JarScanner) ctxt.getAttribute(JarScanner.class.getName());
+            (JarScanner) ctxt.getAttribute(JarScanner.class.getName());
         if (jarScanner == null) {
             ctxt.log(Localizer.getMessage("jsp.warning.noJarScanner"));
             jarScanner = new StandardJarScanner();

==================================================
JspConfig.java
index 3136b0be97..58cd57f998 100644
--- a/java/org/apache/jasper/compiler/JasperTagInfo.java
+++ b/java/org/apache/jasper/compiler/JasperTagInfo.java
@@ -30,26 +30,27 @@ class JasperTagInfo extends TagInfo {
     private String dynamicAttrsMapName;
 
     public JasperTagInfo(String tagName,
-			 String tagClassName,
-			 String bodyContent,
-			 String infoString,
-			 TagLibraryInfo taglib,
-			 TagExtraInfo tagExtraInfo,
-			 TagAttributeInfo[] attributeInfo,
-			 String displayName,
-			 String smallIcon,
-			 String largeIcon,
-			 TagVariableInfo[] tvi,
-			 String mapName) {
-
-	super(tagName, tagClassName, bodyContent, infoString, taglib,
-	      tagExtraInfo, attributeInfo, displayName, smallIcon, largeIcon,
-	      tvi);
-	this.dynamicAttrsMapName = mapName;
+            String tagClassName,
+            String bodyContent,
+            String infoString,
+            TagLibraryInfo taglib,
+            TagExtraInfo tagExtraInfo,
+            TagAttributeInfo[] attributeInfo,
+            String displayName,
+            String smallIcon,
+            String largeIcon,
+            TagVariableInfo[] tvi,
+            String mapName) {
+
+        super(tagName, tagClassName, bodyContent, infoString, taglib,
+                tagExtraInfo, attributeInfo, displayName, smallIcon, largeIcon,
+                tvi);
+        
+        this.dynamicAttrsMapName = mapName;
     }
 
     public String getDynamicAttributesMapName() {
-	return dynamicAttrsMapName;
+        return dynamicAttrsMapName;
     }
 
     @Override

==================================================
JspDocumentParser.java
index 91756384b9..9bbbdec2fc 100644
--- a/java/org/apache/jasper/compiler/JspConfig.java
+++ b/java/org/apache/jasper/compiler/JspConfig.java
@@ -45,8 +45,8 @@ public class JspConfig {
     private ServletContext ctxt;
     private volatile boolean initialized = false;
 
-    private final static String defaultIsXml = null;		// unspecified
-    private String defaultIsELIgnored = null;	// unspecified
+    private final static String defaultIsXml = null;    // unspecified
+    private String defaultIsELIgnored = null;           // unspecified
     private final static String defaultIsScriptingInvalid = null;
     private String defaultDeferedSyntaxAllowedAsLiteral = null;
     private final static String defaultTrimDirectiveWhitespaces = null;
@@ -289,7 +289,7 @@ public class JspConfig {
 
         init();
 
-        // JSP Configuration settings do not apply to tag files	    
+        // JSP Configuration settings do not apply to tag files
         if (jspProperties == null || uri.endsWith(".tag")
                 || uri.endsWith(".tagx")) {
             return defaultJspProperty;

==================================================
JspRuntimeContext.java
index dbfec45c8a..15b0fbfd4f 100644
--- a/java/org/apache/jasper/compiler/JspDocumentParser.java
+++ b/java/org/apache/jasper/compiler/JspDocumentParser.java
@@ -665,21 +665,21 @@ class JspDocumentParser
         }
 
         if (current instanceof Node.CustomTag) {
-        	String bodyType = getBodyType((Node.CustomTag) current);
-        	if (TagInfo.BODY_CONTENT_EMPTY.equalsIgnoreCase(bodyType)) {
-        		// Children - if any - must be JSP attributes
-        		Node.Nodes children = current.getBody();
-        		if (children != null && children.size() > 0) {
-        			for (int i = 0; i < children.size(); i++) {
-        				Node child = children.getNode(i);
-        				if (!(child instanceof Node.NamedAttribute)) {
-        					throw new SAXParseException(Localizer.getMessage(
-        							"jasper.error.emptybodycontent.nonempty",
-        							current.qName), locator); 
-        				}
-        			}
-        		}
-        	}
+            String bodyType = getBodyType((Node.CustomTag) current);
+            if (TagInfo.BODY_CONTENT_EMPTY.equalsIgnoreCase(bodyType)) {
+                // Children - if any - must be JSP attributes
+                Node.Nodes children = current.getBody();
+                if (children != null && children.size() > 0) {
+                    for (int i = 0; i < children.size(); i++) {
+                        Node child = children.getNode(i);
+                        if (!(child instanceof Node.NamedAttribute)) {
+                            throw new SAXParseException(Localizer.getMessage(
+                                    "jasper.error.emptybodycontent.nonempty",
+                                    current.qName), locator); 
+                        }
+                    }
+                }
+            }
         }
         if (current.getParent() != null) {
             current = current.getParent();

==================================================
Localizer.java
index ab922fd662..117937c517 100644
--- a/java/org/apache/jasper/compiler/JspRuntimeContext.java
+++ b/java/org/apache/jasper/compiler/JspRuntimeContext.java
@@ -520,7 +520,7 @@ public final class JspRuntimeContext {
      * If JSP's to be unloaded are found, they will be destroyed.
      * Uses the lastCheck time from background compiler to determine if it is time to unload JSP's.
      */
-    public void checkUnload() {    	
+    public void checkUnload() {
         if (options.getMaxLoadedJsps() > 0) {
             long now = System.currentTimeMillis();
             if (now > (lastCheck + (options.getCheckInterval() * 1000L))) {

==================================================
Mark.java
index 260ac51be4..2db3d2aa80 100644
--- a/java/org/apache/jasper/compiler/Localizer.java
+++ b/java/org/apache/jasper/compiler/Localizer.java
@@ -52,12 +52,12 @@ public class Localizer {
      * @return Localized error message
      */
     public static String getMessage(String errCode) {
-	String errMsg = errCode;
-	try {
-	    errMsg = bundle.getString(errCode);
-	} catch (MissingResourceException e) {
-	}
-	return errMsg;
+        String errMsg = errCode;
+        try {
+            errMsg = bundle.getString(errCode);
+        } catch (MissingResourceException e) {
+        }
+        return errMsg;
     }
 
     /* 
@@ -73,7 +73,7 @@ public class Localizer {
      * @return Localized error message
      */
     public static String getMessage(String errCode, String arg) {
-	return getMessage(errCode, new Object[] {arg});
+        return getMessage(errCode, new Object[] {arg});
     }
 
     /* 
@@ -90,7 +90,7 @@ public class Localizer {
      * @return Localized error message
      */
     public static String getMessage(String errCode, String arg1, String arg2) {
-	return getMessage(errCode, new Object[] {arg1, arg2});
+        return getMessage(errCode, new Object[] {arg1, arg2});
     }
     
     /* 
@@ -108,8 +108,8 @@ public class Localizer {
      * @return Localized error message
      */
     public static String getMessage(String errCode, String arg1, String arg2,
-				    String arg3) {
-	return getMessage(errCode, new Object[] {arg1, arg2, arg3});
+                                    String arg3) {
+        return getMessage(errCode, new Object[] {arg1, arg2, arg3});
     }
 
     /* 
@@ -128,8 +128,8 @@ public class Localizer {
      * @return Localized error message
      */
     public static String getMessage(String errCode, String arg1, String arg2,
-				    String arg3, String arg4) {
-	return getMessage(errCode, new Object[] {arg1, arg2, arg3, arg4});
+                                    String arg3, String arg4) {
+        return getMessage(errCode, new Object[] {arg1, arg2, arg3, arg4});
     }
 
     /*
@@ -145,16 +145,16 @@ public class Localizer {
      * @return Localized error message
      */
     public static String getMessage(String errCode, Object[] args) {
-	String errMsg = errCode;
-	try {
-	    errMsg = bundle.getString(errCode);
-	    if (args != null) {
-		MessageFormat formatter = new MessageFormat(errMsg);
-		errMsg = formatter.format(args);
-	    }
-	} catch (MissingResourceException e) {
-	}
-	
-	return errMsg;
+        String errMsg = errCode;
+        try {
+            errMsg = bundle.getString(errCode);
+            if (args != null) {
+                MessageFormat formatter = new MessageFormat(errMsg);
+                errMsg = formatter.format(args);
+            }
+        } catch (MissingResourceException e) {
+        }
+        
+        return errMsg;
     }
 }

==================================================
PageDataImpl.java
index d3b69adfe6..3b8afc08ba 100644
--- a/java/org/apache/jasper/compiler/Mark.java
+++ b/java/org/apache/jasper/compiler/Mark.java
@@ -142,7 +142,7 @@ final class Mark {
         // store current state in stack
         includeStack.push(new IncludeState(cursor, line, col, fileId,
                                            fileName, baseDir, 
-					   encoding, stream) );
+                                           encoding, stream) );
 
         // set new variables
         cursor = 0;
@@ -202,7 +202,7 @@ final class Mark {
 
     @Override
     public String toString() {
-	return getFile()+"("+line+","+col+")";
+        return getFile()+"("+line+","+col+")";
     }
 
     public String getFile() {
@@ -222,13 +222,13 @@ final class Mark {
 
     @Override
     public boolean equals(Object other) {
-	if (other instanceof Mark) {
-	    Mark m = (Mark) other;
-	    return this.reader == m.reader && this.fileId == m.fileId 
-		&& this.cursor == m.cursor && this.line == m.line 
-		&& this.col == m.col;
-	} 
-	return false;
+        if (other instanceof Mark) {
+            Mark m = (Mark) other;
+            return this.reader == m.reader && this.fileId == m.fileId 
+                && this.cursor == m.cursor && this.line == m.line 
+                && this.col == m.col;
+        } 
+        return false;
     }
 
     /**

==================================================
ServletWriter.java
index bf722c855e..dfb72fb0d1 100644
--- a/java/org/apache/jasper/compiler/PageDataImpl.java
+++ b/java/org/apache/jasper/compiler/PageDataImpl.java
@@ -61,19 +61,19 @@ class PageDataImpl extends PageData implements TagConstants {
      * @param page the page nodes from which to generate the XML view
      */
     public PageDataImpl(Node.Nodes page, Compiler compiler)
-	        throws JasperException {
-
-	// First pass
-	FirstPassVisitor firstPass = new FirstPassVisitor(page.getRoot(),
-							  compiler.getPageInfo());
-	page.visit(firstPass);
-
-	// Second pass
-	buf = new StringBuilder();
-	SecondPassVisitor secondPass
-	    = new SecondPassVisitor(page.getRoot(), buf, compiler,
-				    firstPass.getJspIdPrefix());
-	page.visit(secondPass);
+                throws JasperException {
+
+        // First pass
+        FirstPassVisitor firstPass = new FirstPassVisitor(page.getRoot(),
+                                                          compiler.getPageInfo());
+        page.visit(firstPass);
+
+        // Second pass
+        buf = new StringBuilder();
+        SecondPassVisitor secondPass
+            = new SecondPassVisitor(page.getRoot(), buf, compiler,
+                                    firstPass.getJspIdPrefix());
+        page.visit(secondPass);
     }
 
     /**
@@ -83,11 +83,11 @@ class PageDataImpl extends PageData implements TagConstants {
      */
     @Override
     public InputStream getInputStream() {
-	// Turn StringBuilder into InputStream
+        // Turn StringBuilder into InputStream
         try {
             return new ByteArrayInputStream(buf.toString().getBytes("UTF-8"));
         } catch (UnsupportedEncodingException uee) {
-	    // should never happen
+            // should never happen
             throw new RuntimeException(uee.toString());
         }
     }
@@ -103,118 +103,118 @@ class PageDataImpl extends PageData implements TagConstants {
      * attributes and adds them to the jsp:root element of the XML view.
      */
     static class FirstPassVisitor
-	        extends Node.Visitor implements TagConstants {
-
-	private Node.Root root;
-	private AttributesImpl rootAttrs;
-	private PageInfo pageInfo;
-
-	// Prefix for the 'id' attribute
-	private String jspIdPrefix;
-
-	/*
-	 * Constructor
-	 */
-	public FirstPassVisitor(Node.Root root, PageInfo pageInfo) {
-	    this.root = root;
-	    this.pageInfo = pageInfo;
-	    this.rootAttrs = new AttributesImpl();
-	    this.rootAttrs.addAttribute("", "", "version", "CDATA",
-					JSP_VERSION);
-	    this.jspIdPrefix = "jsp";
-	}
-
-	@Override
+                extends Node.Visitor implements TagConstants {
+
+        private Node.Root root;
+        private AttributesImpl rootAttrs;
+        private PageInfo pageInfo;
+
+        // Prefix for the 'id' attribute
+        private String jspIdPrefix;
+
+        /*
+         * Constructor
+         */
+        public FirstPassVisitor(Node.Root root, PageInfo pageInfo) {
+            this.root = root;
+            this.pageInfo = pageInfo;
+            this.rootAttrs = new AttributesImpl();
+            this.rootAttrs.addAttribute("", "", "version", "CDATA",
+                                        JSP_VERSION);
+            this.jspIdPrefix = "jsp";
+        }
+
+        @Override
     public void visit(Node.Root n) throws JasperException {
-	    visitBody(n);
-	    if (n == root) {
-		/*
-		 * Top-level page.
-		 *
-		 * Add
-		 *   xmlns:jsp="http://java.sun.com/JSP/Page"
-		 * attribute only if not already present.
-		 */
-		if (!JSP_URI.equals(rootAttrs.getValue("xmlns:jsp"))) {
-		    rootAttrs.addAttribute("", "", "xmlns:jsp", "CDATA",
-					   JSP_URI);
-		}
-
-		if (pageInfo.isJspPrefixHijacked()) {
-		    /*
-		     * 'jsp' prefix has been hijacked, that is, bound to a
-		     * namespace other than the JSP namespace. This means that
-		     * when adding an 'id' attribute to each element, we can't
-		     * use the 'jsp' prefix. Therefore, create a new prefix 
-		     * (one that is unique across the translation unit) for use
-		     * by the 'id' attribute, and bind it to the JSP namespace
-		     */
-		    jspIdPrefix += "jsp";
-		    while (pageInfo.containsPrefix(jspIdPrefix)) {
-			jspIdPrefix += "jsp";
-		    }
-		    rootAttrs.addAttribute("", "", "xmlns:" + jspIdPrefix,
-					   "CDATA", JSP_URI);
-		}
-
-		root.setAttributes(rootAttrs);
-	    }
-	}
-
-	@Override
+            visitBody(n);
+            if (n == root) {
+                /*
+                 * Top-level page.
+                 *
+                 * Add
+                 *   xmlns:jsp="http://java.sun.com/JSP/Page"
+                 * attribute only if not already present.
+                 */
+                if (!JSP_URI.equals(rootAttrs.getValue("xmlns:jsp"))) {
+                    rootAttrs.addAttribute("", "", "xmlns:jsp", "CDATA",
+                                           JSP_URI);
+                }
+
+                if (pageInfo.isJspPrefixHijacked()) {
+                    /*
+                     * 'jsp' prefix has been hijacked, that is, bound to a
+                     * namespace other than the JSP namespace. This means that
+                     * when adding an 'id' attribute to each element, we can't
+                     * use the 'jsp' prefix. Therefore, create a new prefix 
+                     * (one that is unique across the translation unit) for use
+                     * by the 'id' attribute, and bind it to the JSP namespace
+                     */
+                    jspIdPrefix += "jsp";
+                    while (pageInfo.containsPrefix(jspIdPrefix)) {
+                        jspIdPrefix += "jsp";
+                    }
+                    rootAttrs.addAttribute("", "", "xmlns:" + jspIdPrefix,
+                                           "CDATA", JSP_URI);
+                }
+
+                root.setAttributes(rootAttrs);
+            }
+        }
+
+        @Override
     public void visit(Node.JspRoot n) throws JasperException {
-	    addAttributes(n.getTaglibAttributes());
+            addAttributes(n.getTaglibAttributes());
             addAttributes(n.getNonTaglibXmlnsAttributes());
-	    addAttributes(n.getAttributes());
+            addAttributes(n.getAttributes());
 
-	    visitBody(n);
-	}
+            visitBody(n);
+        }
 
-	/*
-	 * Converts taglib directive into "xmlns:..." attribute of jsp:root
-	 * element.
-	 */
-	@Override
+        /*
+         * Converts taglib directive into "xmlns:..." attribute of jsp:root
+         * element.
+         */
+        @Override
     public void visit(Node.TaglibDirective n) throws JasperException {
-	    Attributes attrs = n.getAttributes();
-	    if (attrs != null) {
-		String qName = "xmlns:" + attrs.getValue("prefix");
-		/*
-		 * According to javadocs of org.xml.sax.helpers.AttributesImpl,
-		 * the addAttribute method does not check to see if the
-		 * specified attribute is already contained in the list: This
-		 * is the application's responsibility!
-		 */
-		if (rootAttrs.getIndex(qName) == -1) {
-		    String location = attrs.getValue("uri");
-		    if (location != null) {
+            Attributes attrs = n.getAttributes();
+            if (attrs != null) {
+                String qName = "xmlns:" + attrs.getValue("prefix");
+                /*
+                 * According to javadocs of org.xml.sax.helpers.AttributesImpl,
+                 * the addAttribute method does not check to see if the
+                 * specified attribute is already contained in the list: This
+                 * is the application's responsibility!
+                 */
+                if (rootAttrs.getIndex(qName) == -1) {
+                    String location = attrs.getValue("uri");
+                    if (location != null) {
                         if (location.startsWith("/")) {
                             location = URN_JSPTLD + location;
                         }
-			rootAttrs.addAttribute("", "", qName, "CDATA",
-					       location);
-		    } else {
-			location = attrs.getValue("tagdir");
-			rootAttrs.addAttribute("", "", qName, "CDATA",
-					       URN_JSPTAGDIR + location);
-		    }
-		}
-	    }
-	}
-
-	public String getJspIdPrefix() {
-	    return jspIdPrefix;
-	}
-
-	private void addAttributes(Attributes attrs) {
-	    if (attrs != null) {
-		int len = attrs.getLength();
-
-		for (int i=0; i<len; i++) {
+                        rootAttrs.addAttribute("", "", qName, "CDATA",
+                                               location);
+                    } else {
+                        location = attrs.getValue("tagdir");
+                        rootAttrs.addAttribute("", "", qName, "CDATA",
+                                               URN_JSPTAGDIR + location);
+                    }
+                }
+            }
+        }
+
+        public String getJspIdPrefix() {
+            return jspIdPrefix;
+        }
+
+        private void addAttributes(Attributes attrs) {
+            if (attrs != null) {
+                int len = attrs.getLength();
+
+                for (int i=0; i<len; i++) {
                     String qName = attrs.getQName(i);
-		    if ("version".equals(qName)) {
-			continue;
-		    }
+                    if ("version".equals(qName)) {
+                        continue;
+                    }
 
                     // Bugzilla 35252: http://issues.apache.org/bugzilla/show_bug.cgi?id=35252
                     if(rootAttrs.getIndex(qName) == -1) {
@@ -224,9 +224,9 @@ class PageDataImpl extends PageData implements TagConstants {
                                                attrs.getType(i),
                                                attrs.getValue(i));
                     }
-		}
-	    }
-	}
+                }
+            }
+        }
     }
 
 
@@ -235,156 +235,156 @@ class PageDataImpl extends PageData implements TagConstants {
      * each element a unique jsp:id attribute.
      */
     static class SecondPassVisitor extends Node.Visitor
-        	implements TagConstants {
-
-	private Node.Root root;
-	private StringBuilder buf;
-	private Compiler compiler;
-	private String jspIdPrefix;
-	private boolean resetDefaultNS = false;
-
-	// Current value of jsp:id attribute
-	private int jspId;
-
-	/*
-	 * Constructor
-	 */
-	public SecondPassVisitor(Node.Root root, StringBuilder buf,
-				 Compiler compiler, String jspIdPrefix) {
-	    this.root = root;
-	    this.buf = buf;
-	    this.compiler = compiler;
-	    this.jspIdPrefix = jspIdPrefix;
-	}
-
-	/*
-	 * Visits root node.
-	 */
-	@Override
+                implements TagConstants {
+
+        private Node.Root root;
+        private StringBuilder buf;
+        private Compiler compiler;
+        private String jspIdPrefix;
+        private boolean resetDefaultNS = false;
+
+        // Current value of jsp:id attribute
+        private int jspId;
+
+        /*
+         * Constructor
+         */
+        public SecondPassVisitor(Node.Root root, StringBuilder buf,
+                                 Compiler compiler, String jspIdPrefix) {
+            this.root = root;
+            this.buf = buf;
+            this.compiler = compiler;
+            this.jspIdPrefix = jspIdPrefix;
+        }
+
+        /*
+         * Visits root node.
+         */
+        @Override
     public void visit(Node.Root n) throws JasperException {
-	    if (n == this.root) {
-		// top-level page
-		appendXmlProlog();
-		appendTag(n);
-	    } else {
-		boolean resetDefaultNSSave = resetDefaultNS;
-		if (n.isXmlSyntax()) {
-		    resetDefaultNS = true;
-		}
-		visitBody(n);
-		resetDefaultNS = resetDefaultNSSave;
-	    }
-	}
-
-	/*
-	 * Visits jsp:root element of JSP page in XML syntax.
-	 *
-	 * Any nested jsp:root elements (from pages included via an
-	 * include directive) are ignored.
-	 */
-	@Override
+            if (n == this.root) {
+                // top-level page
+                appendXmlProlog();
+                appendTag(n);
+            } else {
+                boolean resetDefaultNSSave = resetDefaultNS;
+                if (n.isXmlSyntax()) {
+                    resetDefaultNS = true;
+                }
+                visitBody(n);
+                resetDefaultNS = resetDefaultNSSave;
+            }
+        }
+
+        /*
+         * Visits jsp:root element of JSP page in XML syntax.
+         *
+         * Any nested jsp:root elements (from pages included via an
+         * include directive) are ignored.
+         */
+        @Override
     public void visit(Node.JspRoot n) throws JasperException {
-	    visitBody(n);
-	}
+            visitBody(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.PageDirective n) throws JasperException {
-	    appendPageDirective(n);
-	}
+            appendPageDirective(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.IncludeDirective n) throws JasperException {
-	    // expand in place
-	    visitBody(n);
-	}
+            // expand in place
+            visitBody(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.Comment n) throws JasperException {
-	    // Comments are ignored in XML view
-	}
+            // Comments are ignored in XML view
+        }
 
-	@Override
+        @Override
     public void visit(Node.Declaration n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.Expression n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.Scriptlet n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.JspElement n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.ELExpression n) throws JasperException {
-	    if (!n.getRoot().isXmlSyntax()) {
-		buf.append("<").append(JSP_TEXT_ACTION);
-		buf.append(" ");
-	        buf.append(jspIdPrefix);
-		buf.append(":id=\"");
-		buf.append(jspId++).append("\">");
-	    }
-	    buf.append("${");
+            if (!n.getRoot().isXmlSyntax()) {
+                buf.append("<").append(JSP_TEXT_ACTION);
+                buf.append(" ");
+                buf.append(jspIdPrefix);
+                buf.append(":id=\"");
+                buf.append(jspId++).append("\">");
+            }
+            buf.append("${");
             buf.append(JspUtil.escapeXml(n.getText()));
-	    buf.append("}");
-	    if (!n.getRoot().isXmlSyntax()) {
-		buf.append(JSP_TEXT_ACTION_END);
-	    }
-	    buf.append("\n");
-	}
-
-	@Override
+            buf.append("}");
+            if (!n.getRoot().isXmlSyntax()) {
+                buf.append(JSP_TEXT_ACTION_END);
+            }
+            buf.append("\n");
+        }
+
+        @Override
     public void visit(Node.IncludeAction n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
     
-	@Override
+        @Override
     public void visit(Node.ForwardAction n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.GetProperty n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.SetProperty n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.ParamAction n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.ParamsAction n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.FallBackAction n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.UseBean n) throws JasperException {
-	    appendTag(n);
-	}
-	
-	@Override
+            appendTag(n);
+        }
+        
+        @Override
     public void visit(Node.PlugIn n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
 
         @Override
         public void visit(Node.NamedAttribute n) throws JasperException {
@@ -396,350 +396,350 @@ class PageDataImpl extends PageData implements TagConstants {
             appendTag(n);
         }
 
-	@Override
+        @Override
     public void visit(Node.CustomTag n) throws JasperException {
-	    boolean resetDefaultNSSave = resetDefaultNS;
-	    appendTag(n, resetDefaultNS);
-	    resetDefaultNS = resetDefaultNSSave;
-	}
+            boolean resetDefaultNSSave = resetDefaultNS;
+            appendTag(n, resetDefaultNS);
+            resetDefaultNS = resetDefaultNSSave;
+        }
 
-	@Override
+        @Override
     public void visit(Node.UninterpretedTag n) throws JasperException {
-	    boolean resetDefaultNSSave = resetDefaultNS;
-	    appendTag(n, resetDefaultNS);
-	    resetDefaultNS = resetDefaultNSSave;
-	}
+            boolean resetDefaultNSSave = resetDefaultNS;
+            appendTag(n, resetDefaultNS);
+            resetDefaultNS = resetDefaultNSSave;
+        }
 
-	@Override
+        @Override
     public void visit(Node.JspText n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.DoBodyAction n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
 
         @Override
         public void visit(Node.InvokeAction n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.TagDirective n) throws JasperException {
-	    appendTagDirective(n);
-	}
+            appendTagDirective(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.AttributeDirective n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
 
-	@Override
+        @Override
     public void visit(Node.VariableDirective n) throws JasperException {
-	    appendTag(n);
-	}
+            appendTag(n);
+        }
         
-	@Override
+        @Override
     public void visit(Node.TemplateText n) throws JasperException {
-	    /*
-	     * If the template text came from a JSP page written in JSP syntax,
-	     * create a jsp:text element for it (JSP 5.3.2).
-	     */
-	    appendText(n.getText(), !n.getRoot().isXmlSyntax());
-	}
-
-	/*
-	 * Appends the given tag, including its body, to the XML view.
-	 */
-	private void appendTag(Node n) throws JasperException {
-	    appendTag(n, false);
-	}
-
-	/*
-	 * Appends the given tag, including its body, to the XML view,
-	 * and optionally reset default namespace to "", if none specified.
-	 */
-	private void appendTag(Node n, boolean addDefaultNS)
-		throws JasperException {
-
-	    Node.Nodes body = n.getBody();
-	    String text = n.getText();
-
-	    buf.append("<").append(n.getQName());
-	    buf.append("\n");
-
-	    printAttributes(n, addDefaultNS);
-	    buf.append("  ").append(jspIdPrefix).append(":id").append("=\"");
-	    buf.append(jspId++).append("\"\n");
-
-	    if (ROOT_ACTION.equals(n.getLocalName()) || body != null
-		        || text != null) {
-		buf.append(">\n");
-		if (ROOT_ACTION.equals(n.getLocalName())) {
-		    if (compiler.getCompilationContext().isTagFile()) {
-			appendTagDirective();
-		    } else {
-			appendPageDirective();
-		    }
-		}
-		if (body != null) {
-		    body.visit(this);
-		} else {
-		    appendText(text, false);
-		}
-		buf.append("</" + n.getQName() + ">\n");
-	    } else {
-		buf.append("/>\n");
-	    }
-	}
-
-	/*
-	 * Appends the page directive with the given attributes to the XML
-	 * view.
-	 *
-	 * Since the import attribute of the page directive is the only page
-	 * attribute that is allowed to appear multiple times within the same
-	 * document, and since XML allows only single-value attributes,
-	 * the values of multiple import attributes must be combined into one,
-	 * separated by comma.
-	 *
-	 * If the given page directive contains just 'contentType' and/or
-	 * 'pageEncoding' attributes, we ignore it, as we've already appended
-	 * a page directive containing just these two attributes.
-	 */
-	private void appendPageDirective(Node.PageDirective n) {
-	    boolean append = false;
-	    Attributes attrs = n.getAttributes();
-	    int len = (attrs == null) ? 0 : attrs.getLength();
-	    for (int i=0; i<len; i++) {
-		String attrName = attrs.getQName(i);
-		if (!"pageEncoding".equals(attrName)
-		        && !"contentType".equals(attrName)) {
-		    append = true;
-		    break;
-		}
-	    }
-	    if (!append) {
-		return;
-	    }
-
-	    buf.append("<").append(n.getQName());
-	    buf.append("\n");
-
-	    // append jsp:id
-	    buf.append("  ").append(jspIdPrefix).append(":id").append("=\"");
-	    buf.append(jspId++).append("\"\n");
-
-	    // append remaining attributes
-	    for (int i=0; i<len; i++) {
-		String attrName = attrs.getQName(i);
-		if ("import".equals(attrName) || "contentType".equals(attrName)
-		        || "pageEncoding".equals(attrName)) {
-		    /*
-		     * Page directive's 'import' attribute is considered
-		     * further down, and its 'pageEncoding' and 'contentType'
-		     * attributes are ignored, since we've already appended
-		     * a new page directive containing just these two
-		     * attributes
-		     */
-		    continue;
-		}
-		String value = attrs.getValue(i);
-		buf.append("  ").append(attrName).append("=\"");
-		buf.append(JspUtil.getExprInXml(value)).append("\"\n");
-	    }
-	    if (n.getImports().size() > 0) {
-		// Concatenate names of imported classes/packages
-		boolean first = true;
-		ListIterator<String> iter = n.getImports().listIterator();
-		while (iter.hasNext()) {
-		    if (first) {
-			first = false;
-			buf.append("  import=\"");
-		    } else {
-			buf.append(",");
-		    }
-		    buf.append(JspUtil.getExprInXml(iter.next()));
-		}
-		buf.append("\"\n");
-	    }
-	    buf.append("/>\n");
-	}
-
-	/*
-	 * Appends a page directive with 'pageEncoding' and 'contentType'
-	 * attributes.
-	 *
-	 * The value of the 'pageEncoding' attribute is hard-coded
-	 * to UTF-8, whereas the value of the 'contentType' attribute, which
-	 * is identical to what the container will pass to
-	 * ServletResponse.setContentType(), is derived from the pageInfo.
-	 */
-	private void appendPageDirective() {
-	    buf.append("<").append(JSP_PAGE_DIRECTIVE_ACTION);
-	    buf.append("\n");
-
-	    // append jsp:id
-	    buf.append("  ").append(jspIdPrefix).append(":id").append("=\"");
-	    buf.append(jspId++).append("\"\n");
-	    buf.append("  ").append("pageEncoding").append("=\"UTF-8\"\n");
-	    buf.append("  ").append("contentType").append("=\"");
-	    buf.append(compiler.getPageInfo().getContentType()).append("\"\n");
-	    buf.append("/>\n");	    
-	}
-
-	/*
-	 * Appends the tag directive with the given attributes to the XML
-	 * view.
-	 *
-	 * If the given tag directive contains just a 'pageEncoding'
-	 * attributes, we ignore it, as we've already appended
-	 * a tag directive containing just this attributes.
-	 */
-	private void appendTagDirective(Node.TagDirective n)
-	        throws JasperException {
-
-	    boolean append = false;
-	    Attributes attrs = n.getAttributes();
-	    int len = (attrs == null) ? 0 : attrs.getLength();
-	    for (int i=0; i<len; i++) {
-		String attrName = attrs.getQName(i);
-		if (!"pageEncoding".equals(attrName)) {
-		    append = true;
-		    break;
-		}
-	    }
-	    if (!append) {
-		return;
-	    }
-
-	    appendTag(n);
-	}
-
-	/*
-	 * Appends a tag directive containing a single 'pageEncoding'
-	 * attribute whose value is hard-coded to UTF-8.
-	 */
-	private void appendTagDirective() {
-	    buf.append("<").append(JSP_TAG_DIRECTIVE_ACTION);
-	    buf.append("\n");
-
-	    // append jsp:id
-	    buf.append("  ").append(jspIdPrefix).append(":id").append("=\"");
-	    buf.append(jspId++).append("\"\n");
-	    buf.append("  ").append("pageEncoding").append("=\"UTF-8\"\n");
-	    buf.append("/>\n");	    
-	}
-
-	private void appendText(String text, boolean createJspTextElement) {
-	    if (createJspTextElement) {
-		buf.append("<").append(JSP_TEXT_ACTION);
-		buf.append("\n");
-
-		// append jsp:id
-		buf.append("  ").append(jspIdPrefix).append(":id").append("=\"");
-		buf.append(jspId++).append("\"\n");
-		buf.append(">\n");
-
-		appendCDATA(text);
-		buf.append(JSP_TEXT_ACTION_END);
-		buf.append("\n");
-	    } else {
-		appendCDATA(text);
-	    }
-	}
-	
-	/*
-	 * Appends the given text as a CDATA section to the XML view, unless
-	 * the text has already been marked as CDATA.
-	 */
-	private void appendCDATA(String text) {
-	    buf.append(CDATA_START_SECTION);
-	    buf.append(escapeCDATA(text));
-	    buf.append(CDATA_END_SECTION);
-	}
-
-	/*
-	 * Escapes any occurrences of "]]>" (by replacing them with "]]&gt;")
-	 * within the given text, so it can be included in a CDATA section.
-	 */
-	private String escapeCDATA(String text) {
+            /*
+             * If the template text came from a JSP page written in JSP syntax,
+             * create a jsp:text element for it (JSP 5.3.2).
+             */
+            appendText(n.getText(), !n.getRoot().isXmlSyntax());
+        }
+
+        /*
+         * Appends the given tag, including its body, to the XML view.
+         */
+        private void appendTag(Node n) throws JasperException {
+            appendTag(n, false);
+        }
+
+        /*
+         * Appends the given tag, including its body, to the XML view,
+         * and optionally reset default namespace to "", if none specified.
+         */
+        private void appendTag(Node n, boolean addDefaultNS)
+                throws JasperException {
+
+            Node.Nodes body = n.getBody();
+            String text = n.getText();
+
+            buf.append("<").append(n.getQName());
+            buf.append("\n");
+
+            printAttributes(n, addDefaultNS);
+            buf.append("  ").append(jspIdPrefix).append(":id").append("=\"");
+            buf.append(jspId++).append("\"\n");
+
+            if (ROOT_ACTION.equals(n.getLocalName()) || body != null
+                        || text != null) {
+                buf.append(">\n");
+                if (ROOT_ACTION.equals(n.getLocalName())) {
+                    if (compiler.getCompilationContext().isTagFile()) {
+                        appendTagDirective();
+                    } else {
+                        appendPageDirective();
+                    }
+                }
+                if (body != null) {
+                    body.visit(this);
+                } else {
+                    appendText(text, false);
+                }
+                buf.append("</" + n.getQName() + ">\n");
+            } else {
+                buf.append("/>\n");
+            }
+        }
+
+        /*
+         * Appends the page directive with the given attributes to the XML
+         * view.
+         *
+         * Since the import attribute of the page directive is the only page
+         * attribute that is allowed to appear multiple times within the same
+         * document, and since XML allows only single-value attributes,
+         * the values of multiple import attributes must be combined into one,
+         * separated by comma.
+         *
+         * If the given page directive contains just 'contentType' and/or
+         * 'pageEncoding' attributes, we ignore it, as we've already appended
+         * a page directive containing just these two attributes.
+         */
+        private void appendPageDirective(Node.PageDirective n) {
+            boolean append = false;
+            Attributes attrs = n.getAttributes();
+            int len = (attrs == null) ? 0 : attrs.getLength();
+            for (int i=0; i<len; i++) {
+                String attrName = attrs.getQName(i);
+                if (!"pageEncoding".equals(attrName)
+                        && !"contentType".equals(attrName)) {
+                    append = true;
+                    break;
+                }
+            }
+            if (!append) {
+                return;
+            }
+
+            buf.append("<").append(n.getQName());
+            buf.append("\n");
+
+            // append jsp:id
+            buf.append("  ").append(jspIdPrefix).append(":id").append("=\"");
+            buf.append(jspId++).append("\"\n");
+
+            // append remaining attributes
+            for (int i=0; i<len; i++) {
+                String attrName = attrs.getQName(i);
+                if ("import".equals(attrName) || "contentType".equals(attrName)
+                        || "pageEncoding".equals(attrName)) {
+                    /*
+                     * Page directive's 'import' attribute is considered
+                     * further down, and its 'pageEncoding' and 'contentType'
+                     * attributes are ignored, since we've already appended
+                     * a new page directive containing just these two
+                     * attributes
+                     */
+                    continue;
+                }
+                String value = attrs.getValue(i);
+                buf.append("  ").append(attrName).append("=\"");
+                buf.append(JspUtil.getExprInXml(value)).append("\"\n");
+            }
+            if (n.getImports().size() > 0) {
+                // Concatenate names of imported classes/packages
+                boolean first = true;
+                ListIterator<String> iter = n.getImports().listIterator();
+                while (iter.hasNext()) {
+                    if (first) {
+                        first = false;
+                        buf.append("  import=\"");
+                    } else {
+                        buf.append(",");
+                    }
+                    buf.append(JspUtil.getExprInXml(iter.next()));
+                }
+                buf.append("\"\n");
+            }
+            buf.append("/>\n");
+        }
+
+        /*
+         * Appends a page directive with 'pageEncoding' and 'contentType'
+         * attributes.
+         *
+         * The value of the 'pageEncoding' attribute is hard-coded
+         * to UTF-8, whereas the value of the 'contentType' attribute, which
+         * is identical to what the container will pass to
+         * ServletResponse.setContentType(), is derived from the pageInfo.
+         */
+        private void appendPageDirective() {
+            buf.append("<").append(JSP_PAGE_DIRECTIVE_ACTION);
+            buf.append("\n");
+
+            // append jsp:id
+            buf.append("  ").append(jspIdPrefix).append(":id").append("=\"");
+            buf.append(jspId++).append("\"\n");
+            buf.append("  ").append("pageEncoding").append("=\"UTF-8\"\n");
+            buf.append("  ").append("contentType").append("=\"");
+            buf.append(compiler.getPageInfo().getContentType()).append("\"\n");
+            buf.append("/>\n");            
+        }
+
+        /*
+         * Appends the tag directive with the given attributes to the XML
+         * view.
+         *
+         * If the given tag directive contains just a 'pageEncoding'
+         * attributes, we ignore it, as we've already appended
+         * a tag directive containing just this attributes.
+         */
+        private void appendTagDirective(Node.TagDirective n)
+                throws JasperException {
+
+            boolean append = false;
+            Attributes attrs = n.getAttributes();
+            int len = (attrs == null) ? 0 : attrs.getLength();
+            for (int i=0; i<len; i++) {
+                String attrName = attrs.getQName(i);
+                if (!"pageEncoding".equals(attrName)) {
+                    append = true;
+                    break;
+                }
+            }
+            if (!append) {
+                return;
+            }
+
+            appendTag(n);
+        }
+
+        /*
+         * Appends a tag directive containing a single 'pageEncoding'
+         * attribute whose value is hard-coded to UTF-8.
+         */
+        private void appendTagDirective() {
+            buf.append("<").append(JSP_TAG_DIRECTIVE_ACTION);
+            buf.append("\n");
+
+            // append jsp:id
+            buf.append("  ").append(jspIdPrefix).append(":id").append("=\"");
+            buf.append(jspId++).append("\"\n");
+            buf.append("  ").append("pageEncoding").append("=\"UTF-8\"\n");
+            buf.append("/>\n");            
+        }
+
+        private void appendText(String text, boolean createJspTextElement) {
+            if (createJspTextElement) {
+                buf.append("<").append(JSP_TEXT_ACTION);
+                buf.append("\n");
+
+                // append jsp:id
+                buf.append("  ").append(jspIdPrefix).append(":id").append("=\"");
+                buf.append(jspId++).append("\"\n");
+                buf.append(">\n");
+
+                appendCDATA(text);
+                buf.append(JSP_TEXT_ACTION_END);
+                buf.append("\n");
+            } else {
+                appendCDATA(text);
+            }
+        }
+        
+        /*
+         * Appends the given text as a CDATA section to the XML view, unless
+         * the text has already been marked as CDATA.
+         */
+        private void appendCDATA(String text) {
+            buf.append(CDATA_START_SECTION);
+            buf.append(escapeCDATA(text));
+            buf.append(CDATA_END_SECTION);
+        }
+
+        /*
+         * Escapes any occurrences of "]]>" (by replacing them with "]]&gt;")
+         * within the given text, so it can be included in a CDATA section.
+         */
+        private String escapeCDATA(String text) {
             if( text==null ) return "";
-	    int len = text.length();
-	    CharArrayWriter result = new CharArrayWriter(len);
-	    for (int i=0; i<len; i++) {
-		if (((i+2) < len)
-		        && (text.charAt(i) == ']')
-		        && (text.charAt(i+1) == ']')
-		        && (text.charAt(i+2) == '>')) {
-		    // match found
-		    result.write(']');
-		    result.write(']');
-		    result.write('&');
-		    result.write('g');
-		    result.write('t');
-		    result.write(';');
-		    i += 2;
-		} else {
-		    result.write(text.charAt(i));
-		}
-	    }
-	    return result.toString();
-	}
-
-	/*
-	 * Appends the attributes of the given Node to the XML view.
-	 */
-	private void printAttributes(Node n, boolean addDefaultNS) {
-
-	    /*
-	     * Append "xmlns" attributes that represent tag libraries
-	     */
-	    Attributes attrs = n.getTaglibAttributes();
-	    int len = (attrs == null) ? 0 : attrs.getLength();
-	    for (int i=0; i<len; i++) {
-		String name = attrs.getQName(i);
-		String value = attrs.getValue(i);
-		buf.append("  ").append(name).append("=\"").append(value).append("\"\n");
-	    }
-
-	    /*
-	     * Append "xmlns" attributes that do not represent tag libraries
-	     */
-	    attrs = n.getNonTaglibXmlnsAttributes();
-	    len = (attrs == null) ? 0 : attrs.getLength();
-	    boolean defaultNSSeen = false;
-	    for (int i=0; i<len; i++) {
-		String name = attrs.getQName(i);
-		String value = attrs.getValue(i);
-		buf.append("  ").append(name).append("=\"").append(value).append("\"\n");
-		defaultNSSeen |= "xmlns".equals(name);
-	    }
-	    if (addDefaultNS && !defaultNSSeen) {
-		buf.append("  xmlns=\"\"\n");
-	    }
-	    resetDefaultNS = false;
-
-	    /*
-	     * Append all other attributes
-	     */
-	    attrs = n.getAttributes();
-	    len = (attrs == null) ? 0 : attrs.getLength();
-	    for (int i=0; i<len; i++) {
-		String name = attrs.getQName(i);
-		String value = attrs.getValue(i);
-		buf.append("  ").append(name).append("=\"");
-		buf.append(JspUtil.getExprInXml(value)).append("\"\n");
-	    }
-	}
-
-	/*
-	 * Appends XML prolog with encoding declaration.
-	 */
-	private void appendXmlProlog() {
-	    buf.append("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n");
-	}
+            int len = text.length();
+            CharArrayWriter result = new CharArrayWriter(len);
+            for (int i=0; i<len; i++) {
+                if (((i+2) < len)
+                        && (text.charAt(i) == ']')
+                        && (text.charAt(i+1) == ']')
+                        && (text.charAt(i+2) == '>')) {
+                    // match found
+                    result.write(']');
+                    result.write(']');
+                    result.write('&');
+                    result.write('g');
+                    result.write('t');
+                    result.write(';');
+                    i += 2;
+                } else {
+                    result.write(text.charAt(i));
+                }
+            }
+            return result.toString();
+        }
+
+        /*
+         * Appends the attributes of the given Node to the XML view.
+         */
+        private void printAttributes(Node n, boolean addDefaultNS) {
+
+            /*
+             * Append "xmlns" attributes that represent tag libraries
+             */
+            Attributes attrs = n.getTaglibAttributes();
+            int len = (attrs == null) ? 0 : attrs.getLength();
+            for (int i=0; i<len; i++) {
+                String name = attrs.getQName(i);
+                String value = attrs.getValue(i);
+                buf.append("  ").append(name).append("=\"").append(value).append("\"\n");
+            }
+
+            /*
+             * Append "xmlns" attributes that do not represent tag libraries
+             */
+            attrs = n.getNonTaglibXmlnsAttributes();
+            len = (attrs == null) ? 0 : attrs.getLength();
+            boolean defaultNSSeen = false;
+            for (int i=0; i<len; i++) {
+                String name = attrs.getQName(i);
+                String value = attrs.getValue(i);
+                buf.append("  ").append(name).append("=\"").append(value).append("\"\n");
+                defaultNSSeen |= "xmlns".equals(name);
+            }
+            if (addDefaultNS && !defaultNSSeen) {
+                buf.append("  xmlns=\"\"\n");
+            }
+            resetDefaultNS = false;
+
+            /*
+             * Append all other attributes
+             */
+            attrs = n.getAttributes();
+            len = (attrs == null) ? 0 : attrs.getLength();
+            for (int i=0; i<len; i++) {
+                String name = attrs.getQName(i);
+                String value = attrs.getValue(i);
+                buf.append("  ").append(name).append("=\"");
+                buf.append(JspUtil.getExprInXml(value)).append("\"\n");
+            }
+        }
+
+        /*
+         * Appends XML prolog with encoding declaration.
+         */
+        private void appendXmlProlog() {
+            buf.append("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n");
+        }
     }
 }
 

==================================================
SmapGenerator.java
index 5bfc982250..3a213860e6 100644
--- a/java/org/apache/jasper/compiler/ServletWriter.java
+++ b/java/org/apache/jasper/compiler/ServletWriter.java
@@ -40,11 +40,11 @@ public class ServletWriter {
 
 
     public ServletWriter(PrintWriter writer) {
-	this.writer = writer;
+        this.writer = writer;
     }
 
     public void close() {
-	writer.close();
+        writer.close();
     }
 
     
@@ -58,15 +58,15 @@ public class ServletWriter {
     // -------------------- Formatting --------------------
 
     public void pushIndent() {
-	virtual_indent += TAB_WIDTH;
-	if (virtual_indent >= 0 && virtual_indent <= SPACES.length())
-	    indent = virtual_indent;
+        virtual_indent += TAB_WIDTH;
+        if (virtual_indent >= 0 && virtual_indent <= SPACES.length())
+            indent = virtual_indent;
     }
 
     public void popIndent() {
-	virtual_indent -= TAB_WIDTH;
-	if (virtual_indent >= 0 && virtual_indent <= SPACES.length())
-	    indent = virtual_indent;
+        virtual_indent -= TAB_WIDTH;
+        if (virtual_indent >= 0 && virtual_indent <= SPACES.length())
+            indent = virtual_indent;
     }
 
     /**
@@ -74,7 +74,7 @@ public class ServletWriter {
      */
     public void println(String s) {
         javaLine++;
-	writer.println(s);
+        writer.println(s);
     }
 
     /**
@@ -82,22 +82,22 @@ public class ServletWriter {
      */
     public void println() {
         javaLine++;
-	writer.println("");
+        writer.println("");
     }
 
     /**
      * Prints the current indention
      */
     public void printin() {
-	writer.print(SPACES.substring(0, indent));
+        writer.print(SPACES.substring(0, indent));
     }
 
     /**
      * Prints the current indention, followed by the given string
      */
     public void printin(String s) {
-	writer.print(SPACES.substring(0, indent));
-	writer.print(s);
+        writer.print(SPACES.substring(0, indent));
+        writer.print(s);
     }
 
     /**
@@ -105,8 +105,8 @@ public class ServletWriter {
      */
     public void printil(String s) {
         javaLine++;
-	writer.print(SPACES.substring(0, indent));
-	writer.println(s);
+        writer.print(SPACES.substring(0, indent));
+        writer.println(s);
     }
 
     /**
@@ -115,14 +115,14 @@ public class ServletWriter {
      * Use println() to print a '\n'.
      */
     public void print(char c) {
-	writer.print(c);
+        writer.print(c);
     }
 
     /**
      * Prints the given int.
      */
     public void print(int i) {
-	writer.print(i);
+        writer.print(i);
     }
 
     /**
@@ -132,7 +132,7 @@ public class ServletWriter {
      * off.
      */
     public void print(String s) {
-	writer.print(s);
+        writer.print(s);
     }
 
     /**
@@ -150,6 +150,6 @@ public class ServletWriter {
             index++;
         }
 
-	writer.print(s);
+        writer.print(s);
     }
 }

==================================================
SmapUtil.java
index 2c92bae0cf..47746ae4c4 100644
--- a/java/org/apache/jasper/compiler/SmapGenerator.java
+++ b/java/org/apache/jasper/compiler/SmapGenerator.java
@@ -59,7 +59,7 @@ public class SmapGenerator {
      * source file.  E.g., "foo$jsp.java".
      */
     public synchronized void setOutputFileName(String x) {
-	outputFileName = x;
+        outputFileName = x;
     }
 
     /**
@@ -75,10 +75,10 @@ public class SmapGenerator {
      *                overwritten
      */
     public synchronized void addStratum(SmapStratum stratum,
-					boolean defaultStratum) {
-	strata.add(stratum);
-	if (defaultStratum)
-	    this.defaultStratum = stratum.getStratumName();
+                                        boolean defaultStratum) {
+        strata.add(stratum);
+        if (defaultStratum)
+            this.defaultStratum = stratum.getStratumName();
     }
 
     /**
@@ -89,9 +89,9 @@ public class SmapGenerator {
      *                    that produced the <tt>smap</tt> to be embedded
      */
     public synchronized void addSmap(String smap, String stratumName) {
-	embedded.add("*O " + stratumName + "\n"
-		   + smap
-		   + "*C " + stratumName + "\n");
+        embedded.add("*O " + stratumName + "\n"
+                   + smap
+                   + "*C " + stratumName + "\n");
     }
 
     /**
@@ -101,42 +101,42 @@ public class SmapGenerator {
      * @param status If <tt>false</tt>, ignore any embedded SMAPs.
      */
     public void setDoEmbedded(boolean status) {
-	doEmbedded = status;
+        doEmbedded = status;
     }
 
     //*********************************************************************
     // Methods for serializing the logical SMAP
 
     public synchronized String getString() {
-	// check state and initialize buffer
-	if (outputFileName == null)
-	    throw new IllegalStateException();
+        // check state and initialize buffer
+        if (outputFileName == null)
+            throw new IllegalStateException();
         StringBuilder out = new StringBuilder();
 
-	// start the SMAP
-	out.append("SMAP\n");
-	out.append(outputFileName + '\n');
-	out.append(defaultStratum + '\n');
-
-	// include embedded SMAPs
-	if (doEmbedded) {
-	    int nEmbedded = embedded.size();
-	    for (int i = 0; i < nEmbedded; i++) {
-	        out.append(embedded.get(i));
-	    }
-	}
-
-	// print our StratumSections, FileSections, and LineSections
-	int nStrata = strata.size();
-	for (int i = 0; i < nStrata; i++) {
-	    SmapStratum s = strata.get(i);
-	    out.append(s.getString());
-	}
-
-	// end the SMAP
-	out.append("*E\n");
-
-	return out.toString();
+        // start the SMAP
+        out.append("SMAP\n");
+        out.append(outputFileName + '\n');
+        out.append(defaultStratum + '\n');
+
+        // include embedded SMAPs
+        if (doEmbedded) {
+            int nEmbedded = embedded.size();
+            for (int i = 0; i < nEmbedded; i++) {
+                out.append(embedded.get(i));
+            }
+        }
+
+        // print our StratumSections, FileSections, and LineSections
+        int nStrata = strata.size();
+        for (int i = 0; i < nStrata; i++) {
+            SmapStratum s = strata.get(i);
+            out.append(s.getString());
+        }
+
+        // end the SMAP
+        out.append("*E\n");
+
+        return out.toString();
     }
 
     @Override
@@ -146,27 +146,27 @@ public class SmapGenerator {
     // For testing (and as an example of use)...
 
     public static void main(String args[]) {
-	SmapGenerator g = new SmapGenerator();
-	g.setOutputFileName("foo.java");
-	SmapStratum s = new SmapStratum("JSP");
-	s.addFile("foo.jsp");
-	s.addFile("bar.jsp", "/foo/foo/bar.jsp");
-	s.addLineData(1, "foo.jsp", 1, 1, 1);
-	s.addLineData(2, "foo.jsp", 1, 6, 1);
-	s.addLineData(3, "foo.jsp", 2, 10, 5);
-	s.addLineData(20, "bar.jsp", 1, 30, 1);
-	g.addStratum(s, true);
-	System.out.print(g);
-
-	System.out.println("---");
-
-	SmapGenerator embedded = new SmapGenerator();
-	embedded.setOutputFileName("blargh.tier2");
-	s = new SmapStratum("Tier2");
-	s.addFile("1.tier2");
-	s.addLineData(1, "1.tier2", 1, 1, 1);
-	embedded.addStratum(s, true);
-	g.addSmap(embedded.toString(), "JSP");
-	System.out.println(g);
+        SmapGenerator g = new SmapGenerator();
+        g.setOutputFileName("foo.java");
+        SmapStratum s = new SmapStratum("JSP");
+        s.addFile("foo.jsp");
+        s.addFile("bar.jsp", "/foo/foo/bar.jsp");
+        s.addLineData(1, "foo.jsp", 1, 1, 1);
+        s.addLineData(2, "foo.jsp", 1, 6, 1);
+        s.addLineData(3, "foo.jsp", 2, 10, 5);
+        s.addLineData(20, "bar.jsp", 1, 30, 1);
+        g.addStratum(s, true);
+        System.out.print(g);
+
+        System.out.println("---");
+
+        SmapGenerator embedded = new SmapGenerator();
+        embedded.setOutputFileName("blargh.tier2");
+        s = new SmapStratum("Tier2");
+        s.addFile("1.tier2");
+        s.addLineData(1, "1.tier2", 1, 1, 1);
+        embedded.addStratum(s, true);
+        g.addSmap(embedded.toString(), "JSP");
+        System.out.println(g);
     }
 }

==================================================
TagPluginManager.java
index d7a9330391..615d4680bc 100644
--- a/java/org/apache/jasper/compiler/SmapUtil.java
+++ b/java/org/apache/jasper/compiler/SmapUtil.java
@@ -78,7 +78,7 @@ public class SmapUtil {
         
         /** Disable reading of input SMAP because:
             1. There is a bug here: getRealPath() is null if .jsp is in a jar
-        	Bugzilla 14660.
+               Bugzilla 14660.
             2. Mappings from other sources into .jsp files are not supported.
             TODO: fix 1. if 2. is not true.
         // determine if we have an input SMAP

==================================================
TextOptimizer.java
index c50fb3d8b3..a2c4592bfe 100644
--- a/java/org/apache/jasper/compiler/TagPluginManager.java
+++ b/java/org/apache/jasper/compiler/TagPluginManager.java
@@ -43,18 +43,18 @@ public class TagPluginManager {
     private PageInfo pageInfo;
 
     public TagPluginManager(ServletContext ctxt) {
-	this.ctxt = ctxt;
+        this.ctxt = ctxt;
     }
 
     public void apply(Node.Nodes page, ErrorDispatcher err, PageInfo pageInfo)
-	    throws JasperException {
+            throws JasperException {
 
-	init(err);
-	if (tagPlugins == null || tagPlugins.size() == 0) {
-	    return;
-	}
+        init(err);
+        if (tagPlugins == null || tagPlugins.size() == 0) {
+            return;
+        }
 
-	this.pageInfo = pageInfo;
+        this.pageInfo = pageInfo;
 
         page.visit(new Node.Visitor() {
             @Override
@@ -68,54 +68,54 @@ public class TagPluginManager {
     }
  
     private void init(ErrorDispatcher err) throws JasperException {
-	if (initialized)
-	    return;
-
-	InputStream is = ctxt.getResourceAsStream(TAG_PLUGINS_XML);
-	if (is == null)
-	    return;
-
-	TreeNode root = (new ParserUtils()).parseXMLDocument(TAG_PLUGINS_XML,
-							     is);
-	if (root == null) {
-	    return;
-	}
-
-	if (!TAG_PLUGINS_ROOT_ELEM.equals(root.getName())) {
-	    err.jspError("jsp.error.plugin.wrongRootElement", TAG_PLUGINS_XML,
-			 TAG_PLUGINS_ROOT_ELEM);
-	}
-
-	tagPlugins = new HashMap<String, TagPlugin>();
-	Iterator<TreeNode> pluginList = root.findChildren("tag-plugin");
-	while (pluginList.hasNext()) {
-	    TreeNode pluginNode = pluginList.next();
+        if (initialized)
+            return;
+
+        InputStream is = ctxt.getResourceAsStream(TAG_PLUGINS_XML);
+        if (is == null)
+            return;
+
+        TreeNode root = (new ParserUtils()).parseXMLDocument(TAG_PLUGINS_XML,
+                                                             is);
+        if (root == null) {
+            return;
+        }
+
+        if (!TAG_PLUGINS_ROOT_ELEM.equals(root.getName())) {
+            err.jspError("jsp.error.plugin.wrongRootElement", TAG_PLUGINS_XML,
+                         TAG_PLUGINS_ROOT_ELEM);
+        }
+
+        tagPlugins = new HashMap<String, TagPlugin>();
+        Iterator<TreeNode> pluginList = root.findChildren("tag-plugin");
+        while (pluginList.hasNext()) {
+            TreeNode pluginNode = pluginList.next();
             TreeNode tagClassNode = pluginNode.findChild("tag-class");
-	    if (tagClassNode == null) {
-		// Error
-		return;
-	    }
-	    String tagClass = tagClassNode.getBody().trim();
-	    TreeNode pluginClassNode = pluginNode.findChild("plugin-class");
-	    if (pluginClassNode == null) {
-		// Error
-		return;
-	    }
-
-	    String pluginClassStr = pluginClassNode.getBody();
-	    TagPlugin tagPlugin = null;
-	    try {
-		Class<?> pluginClass = Class.forName(pluginClassStr);
-		tagPlugin = (TagPlugin) pluginClass.newInstance();
-	    } catch (Exception e) {
-		throw new JasperException(e);
-	    }
-	    if (tagPlugin == null) {
-		return;
-	    }
-	    tagPlugins.put(tagClass, tagPlugin);
-	}
-	initialized = true;
+            if (tagClassNode == null) {
+                // Error
+                return;
+            }
+            String tagClass = tagClassNode.getBody().trim();
+            TreeNode pluginClassNode = pluginNode.findChild("plugin-class");
+            if (pluginClassNode == null) {
+                // Error
+                return;
+            }
+
+            String pluginClassStr = pluginClassNode.getBody();
+            TagPlugin tagPlugin = null;
+            try {
+                Class<?> pluginClass = Class.forName(pluginClassStr);
+                tagPlugin = (TagPlugin) pluginClass.newInstance();
+            } catch (Exception e) {
+                throw new JasperException(e);
+            }
+            if (tagPlugin == null) {
+                return;
+            }
+            tagPlugins.put(tagClass, tagPlugin);
+        }
+        initialized = true;
     }
 
     /**
@@ -125,31 +125,31 @@ public class TagPluginManager {
      * The given custom tag node will be manipulated by the plugin.
      */
     private void invokePlugin(Node.CustomTag n) {
-	TagPlugin tagPlugin = tagPlugins.get(n.getTagHandlerClass().getName());
-	if (tagPlugin == null) {
-	    return;
-	}
-
-	TagPluginContext tagPluginContext = new TagPluginContextImpl(n, pageInfo);
-	n.setTagPluginContext(tagPluginContext);
-	tagPlugin.doTag(tagPluginContext);
+        TagPlugin tagPlugin = tagPlugins.get(n.getTagHandlerClass().getName());
+        if (tagPlugin == null) {
+            return;
+        }
+
+        TagPluginContext tagPluginContext = new TagPluginContextImpl(n, pageInfo);
+        n.setTagPluginContext(tagPluginContext);
+        tagPlugin.doTag(tagPluginContext);
     }
 
     static class TagPluginContextImpl implements TagPluginContext {
-	private Node.CustomTag node;
-	private Node.Nodes curNodes;
-	private PageInfo pageInfo;
-	private HashMap<String, Object> pluginAttributes;
-
-	TagPluginContextImpl(Node.CustomTag n, PageInfo pageInfo) {
-	    this.node = n;
-	    this.pageInfo = pageInfo;
-	    curNodes = new Node.Nodes();
-	    n.setAtETag(curNodes);
-	    curNodes = new Node.Nodes();
-	    n.setAtSTag(curNodes);
-	    n.setUseTagPlugin(true);
-	    pluginAttributes = new HashMap<String, Object>();
+        private Node.CustomTag node;
+        private Node.Nodes curNodes;
+        private PageInfo pageInfo;
+        private HashMap<String, Object> pluginAttributes;
+
+        TagPluginContextImpl(Node.CustomTag n, PageInfo pageInfo) {
+            this.node = n;
+            this.pageInfo = pageInfo;
+            curNodes = new Node.Nodes();
+            n.setAtETag(curNodes);
+            curNodes = new Node.Nodes();
+            n.setAtSTag(curNodes);
+            n.setUseTagPlugin(true);
+            pluginAttributes = new HashMap<String, Object>();
         }
 
         public TagPluginContext getParentContext() {

==================================================
ELResolverImpl.java
index e106f2ce77..8b8d25426e 100644
--- a/java/org/apache/jasper/compiler/TextOptimizer.java
+++ b/java/org/apache/jasper/compiler/TextOptimizer.java
@@ -45,7 +45,7 @@ public class TextOptimizer {
             collectText();
         }
 
-	/*
+        /*
          * The following directives are ignored in text concatenation
          */
 
@@ -117,7 +117,7 @@ public class TextOptimizer {
         TextCatVisitor v = new TextCatVisitor(compiler);
         page.visit(v);
 
-	// Cleanup, in case the page ends with a template text
+        // Cleanup, in case the page ends with a template text
         v.collectText();
     }
 }

==================================================
ExpressionEvaluatorImpl.java
index 70dca5a086..ce408cf5d6 100644
--- a/java/org/apache/jasper/el/ELResolverImpl.java
+++ b/java/org/apache/jasper/el/ELResolverImpl.java
@@ -35,132 +35,132 @@ import javax.servlet.jsp.el.VariableResolver;
 import org.apache.jasper.Constants;
 
 public final class ELResolverImpl extends ELResolver {
-	private final static ELResolver DefaultResolver = new CompositeELResolver();
+    private final static ELResolver DefaultResolver = new CompositeELResolver();
 
-	static {
-		((CompositeELResolver) DefaultResolver).add(new MapELResolver());
-		((CompositeELResolver) DefaultResolver).add(new ResourceBundleELResolver());
-		((CompositeELResolver) DefaultResolver).add(new ListELResolver());
-		((CompositeELResolver) DefaultResolver).add(new ArrayELResolver());
-		((CompositeELResolver) DefaultResolver).add(new BeanELResolver());
-	}
+    static {
+        ((CompositeELResolver) DefaultResolver).add(new MapELResolver());
+        ((CompositeELResolver) DefaultResolver).add(new ResourceBundleELResolver());
+        ((CompositeELResolver) DefaultResolver).add(new ListELResolver());
+        ((CompositeELResolver) DefaultResolver).add(new ArrayELResolver());
+        ((CompositeELResolver) DefaultResolver).add(new BeanELResolver());
+    }
 
-	private final VariableResolver variableResolver;
+    private final VariableResolver variableResolver;
 
-	public ELResolverImpl(VariableResolver variableResolver) {
-		this.variableResolver = variableResolver;
-	}
+    public ELResolverImpl(VariableResolver variableResolver) {
+        this.variableResolver = variableResolver;
+    }
 
-	@Override
+    @Override
     public Object getValue(ELContext context, Object base, Object property)
-			throws NullPointerException, PropertyNotFoundException, ELException {
-		if (context == null) {
-			throw new NullPointerException();
-		}
-
-		if (base == null) {
-			context.setPropertyResolved(true);
-			if (property != null) {
-				try {
-					return this.variableResolver.resolveVariable(property
-							.toString());
-				} catch (javax.servlet.jsp.el.ELException e) {
-					throw new ELException(e.getMessage(), e.getCause());
-				}
-			}
-		}
-
-		if (!context.isPropertyResolved()) {
-			return getDefaultResolver().getValue(context, base, property);
-		}
-		return null;
-	}
-
-	@Override
+            throws NullPointerException, PropertyNotFoundException, ELException {
+        if (context == null) {
+            throw new NullPointerException();
+        }
+
+        if (base == null) {
+            context.setPropertyResolved(true);
+            if (property != null) {
+                try {
+                    return this.variableResolver.resolveVariable(property
+                            .toString());
+                } catch (javax.servlet.jsp.el.ELException e) {
+                    throw new ELException(e.getMessage(), e.getCause());
+                }
+            }
+        }
+
+        if (!context.isPropertyResolved()) {
+            return getDefaultResolver().getValue(context, base, property);
+        }
+        return null;
+    }
+
+    @Override
     public Class<?> getType(ELContext context, Object base, Object property)
-			throws NullPointerException, PropertyNotFoundException, ELException {
-		if (context == null) {
-			throw new NullPointerException();
-		}
-
-		if (base == null) {
-			context.setPropertyResolved(true);
-			if (property != null) {
-				try {
-					Object obj = this.variableResolver.resolveVariable(property
-							.toString());
-					return (obj != null) ? obj.getClass() : null;
-				} catch (javax.servlet.jsp.el.ELException e) {
-					throw new ELException(e.getMessage(), e.getCause());
-				}
-			}
-		}
-
-		if (!context.isPropertyResolved()) {
-			return getDefaultResolver().getType(context, base, property);
-		}
-		return null;
-	}
-
-	@Override
+            throws NullPointerException, PropertyNotFoundException, ELException {
+        if (context == null) {
+            throw new NullPointerException();
+        }
+
+        if (base == null) {
+            context.setPropertyResolved(true);
+            if (property != null) {
+                try {
+                    Object obj = this.variableResolver.resolveVariable(property
+                            .toString());
+                    return (obj != null) ? obj.getClass() : null;
+                } catch (javax.servlet.jsp.el.ELException e) {
+                    throw new ELException(e.getMessage(), e.getCause());
+                }
+            }
+        }
+
+        if (!context.isPropertyResolved()) {
+            return getDefaultResolver().getType(context, base, property);
+        }
+        return null;
+    }
+
+    @Override
     public void setValue(ELContext context, Object base, Object property,
-			Object value) throws NullPointerException,
-			PropertyNotFoundException, PropertyNotWritableException,
-			ELException {
-		if (context == null) {
-			throw new NullPointerException();
-		}
-
-		if (base == null) {
-			context.setPropertyResolved(true);
-			throw new PropertyNotWritableException(
-					"Legacy VariableResolver wrapped, not writable");
-		}
-
-		if (!context.isPropertyResolved()) {
-			getDefaultResolver().setValue(context, base, property, value);
-		}
-	}
-
-	@Override
+            Object value) throws NullPointerException,
+            PropertyNotFoundException, PropertyNotWritableException,
+            ELException {
+        if (context == null) {
+            throw new NullPointerException();
+        }
+
+        if (base == null) {
+            context.setPropertyResolved(true);
+            throw new PropertyNotWritableException(
+                    "Legacy VariableResolver wrapped, not writable");
+        }
+
+        if (!context.isPropertyResolved()) {
+            getDefaultResolver().setValue(context, base, property, value);
+        }
+    }
+
+    @Override
     public boolean isReadOnly(ELContext context, Object base, Object property)
-			throws NullPointerException, PropertyNotFoundException, ELException {
-		if (context == null) {
-			throw new NullPointerException();
-		}
+            throws NullPointerException, PropertyNotFoundException, ELException {
+        if (context == null) {
+            throw new NullPointerException();
+        }
 
-		if (base == null) {
-			context.setPropertyResolved(true);
-			return true;
-		}
+        if (base == null) {
+            context.setPropertyResolved(true);
+            return true;
+        }
 
-		return getDefaultResolver().isReadOnly(context, base, property);
-	}
+        return getDefaultResolver().isReadOnly(context, base, property);
+    }
 
-	@Override
+    @Override
     public Iterator<java.beans.FeatureDescriptor> getFeatureDescriptors(ELContext context, Object base) {
-		return getDefaultResolver().getFeatureDescriptors(context, base);
-	}
+        return getDefaultResolver().getFeatureDescriptors(context, base);
+    }
 
-	@Override
+    @Override
     public Class<?> getCommonPropertyType(ELContext context, Object base) {
-		if (base == null) {
-			return String.class;
-		}
-		return getDefaultResolver().getCommonPropertyType(context, base);
-	}
-
-	public static ELResolver getDefaultResolver() {
-	    if (Constants.IS_SECURITY_ENABLED) {
-	        CompositeELResolver defaultResolver = new CompositeELResolver();
-	        defaultResolver.add(new MapELResolver());
-	        defaultResolver.add(new ResourceBundleELResolver());
-	        defaultResolver.add(new ListELResolver());
-	        defaultResolver.add(new ArrayELResolver());
-	        defaultResolver.add(new BeanELResolver());
-	        return defaultResolver;
-	    } else {
-	        return DefaultResolver;
-	    }
-	}
+        if (base == null) {
+            return String.class;
+        }
+        return getDefaultResolver().getCommonPropertyType(context, base);
+    }
+
+    public static ELResolver getDefaultResolver() {
+        if (Constants.IS_SECURITY_ENABLED) {
+            CompositeELResolver defaultResolver = new CompositeELResolver();
+            defaultResolver.add(new MapELResolver());
+            defaultResolver.add(new ResourceBundleELResolver());
+            defaultResolver.add(new ListELResolver());
+            defaultResolver.add(new ArrayELResolver());
+            defaultResolver.add(new BeanELResolver());
+            return defaultResolver;
+        } else {
+            return DefaultResolver;
+        }
+    }
 }

==================================================
ExpressionImpl.java
index 3f83217bd3..d3fbf8a7c7 100644
--- a/java/org/apache/jasper/el/ExpressionEvaluatorImpl.java
+++ b/java/org/apache/jasper/el/ExpressionEvaluatorImpl.java
@@ -28,37 +28,37 @@ import javax.servlet.jsp.el.VariableResolver;
 @Deprecated
 public final class ExpressionEvaluatorImpl extends ExpressionEvaluator {
 
-	private final ExpressionFactory factory;
-	
-	public ExpressionEvaluatorImpl(ExpressionFactory factory) {
-		this.factory = factory;
-	}
+    private final ExpressionFactory factory;
+    
+    public ExpressionEvaluatorImpl(ExpressionFactory factory) {
+        this.factory = factory;
+    }
 
-	@Override
+    @Override
     public Expression parseExpression(String expression,
             @SuppressWarnings("unchecked") // API does not use generics
             Class expectedType,
-			FunctionMapper fMapper) throws ELException {
-		try {
-			ELContextImpl ctx =
-			    new ELContextImpl(ELResolverImpl.getDefaultResolver());
+            FunctionMapper fMapper) throws ELException {
+        try {
+            ELContextImpl ctx =
+                new ELContextImpl(ELResolverImpl.getDefaultResolver());
             if (fMapper != null) {
                 ctx.setFunctionMapper(new FunctionMapperImpl(fMapper));
             }
-			ValueExpression ve = this.factory.createValueExpression(ctx, expression, expectedType);
-			return new ExpressionImpl(ve);
-		} catch (javax.el.ELException e) {
-			throw new ELParseException(e.getMessage());
-		}
-	}
+            ValueExpression ve = this.factory.createValueExpression(ctx, expression, expectedType);
+            return new ExpressionImpl(ve);
+        } catch (javax.el.ELException e) {
+            throw new ELParseException(e.getMessage());
+        }
+    }
 
-	@Override
+    @Override
     public Object evaluate(String expression,
             @SuppressWarnings("unchecked") // API does not use generics
             Class expectedType,
-			VariableResolver vResolver, FunctionMapper fMapper)
-			throws ELException {
-		return this.parseExpression(expression, expectedType, fMapper).evaluate(vResolver);
-	}
+            VariableResolver vResolver, FunctionMapper fMapper)
+            throws ELException {
+        return this.parseExpression(expression, expectedType, fMapper).evaluate(vResolver);
+    }
 
 }

==================================================
FunctionMapperImpl.java
index eb221f364e..69f2d5eb3f 100644
--- a/java/org/apache/jasper/el/ExpressionImpl.java
+++ b/java/org/apache/jasper/el/ExpressionImpl.java
@@ -25,16 +25,16 @@ import javax.servlet.jsp.el.VariableResolver;
 @Deprecated
 public final class ExpressionImpl extends Expression {
 
-	private final ValueExpression ve;
-	
-	public ExpressionImpl(ValueExpression ve) {
-		this.ve = ve;
-	}
+    private final ValueExpression ve;
+    
+    public ExpressionImpl(ValueExpression ve) {
+        this.ve = ve;
+    }
 
-	@Override
+    @Override
     public Object evaluate(VariableResolver vResolver) throws ELException {
-		ELContext ctx = new ELContextImpl(new ELResolverImpl(vResolver));
-		return ve.getValue(ctx);
-	}
+        ELContext ctx = new ELContextImpl(new ELResolverImpl(vResolver));
+        return ve.getValue(ctx);
+    }
 
 }

==================================================
VariableResolverImpl.java
index a70ad4e531..d273c44cce 100644
--- a/java/org/apache/jasper/el/FunctionMapperImpl.java
+++ b/java/org/apache/jasper/el/FunctionMapperImpl.java
@@ -22,16 +22,16 @@ import javax.servlet.jsp.el.FunctionMapper;
 
 @Deprecated
 public final class FunctionMapperImpl extends javax.el.FunctionMapper {
-	
-	private final FunctionMapper fnMapper;
+    
+    private final FunctionMapper fnMapper;
 
-	public FunctionMapperImpl(FunctionMapper fnMapper) {
-		this.fnMapper = fnMapper;
-	}
+    public FunctionMapperImpl(FunctionMapper fnMapper) {
+        this.fnMapper = fnMapper;
+    }
 
-	@Override
+    @Override
     public Method resolveFunction(String prefix, String localName) {
-		return this.fnMapper.resolveFunction(prefix, localName);
-	}
+        return this.fnMapper.resolveFunction(prefix, localName);
+    }
 
 }

==================================================
HttpJspBase.java
index 0ae1b188f1..1115be3a93 100644
--- a/java/org/apache/jasper/el/VariableResolverImpl.java
+++ b/java/org/apache/jasper/el/VariableResolverImpl.java
@@ -23,14 +23,14 @@ import javax.servlet.jsp.el.VariableResolver;
 @Deprecated
 public final class VariableResolverImpl implements VariableResolver {
 
-	private final ELContext ctx;
-	
-	public VariableResolverImpl(ELContext ctx) {
-		this.ctx = ctx;
-	}
+    private final ELContext ctx;
+    
+    public VariableResolverImpl(ELContext ctx) {
+        this.ctx = ctx;
+    }
 
-	public Object resolveVariable(String pName) throws ELException {
-		return this.ctx.getELResolver().getValue(this.ctx, null, pName);
-	}
+    public Object resolveVariable(String pName) throws ELException {
+        return this.ctx.getELResolver().getValue(this.ctx, null, pName);
+    }
 
 }

==================================================
InstanceManagerFactory.java
index 207e670fdf..e6221c0c20 100644
--- a/java/org/apache/jasper/runtime/HttpJspBase.java
+++ b/java/org/apache/jasper/runtime/HttpJspBase.java
@@ -33,34 +33,29 @@ import org.apache.jasper.compiler.Localizer;
  *
  * @author Anil K. Vijendran
  */
-public abstract class HttpJspBase 
-    extends HttpServlet 
-    implements HttpJspPage 
-        
-    
-{
+public abstract class HttpJspBase extends HttpServlet implements HttpJspPage {
     
     protected HttpJspBase() {
     }
 
     @Override
     public final void init(ServletConfig config) 
-	throws ServletException 
+        throws ServletException 
     {
         super.init(config);
-	jspInit();
+        jspInit();
         _jspInit();
     }
     
     @Override
     public String getServletInfo() {
-	return Localizer.getMessage("jsp.engine.info");
+        return Localizer.getMessage("jsp.engine.info");
     }
 
     @Override
     public final void destroy() {
-	jspDestroy();
-	_jspDestroy();
+        jspDestroy();
+        _jspDestroy();
     }
 
     /**
@@ -68,7 +63,7 @@ public abstract class HttpJspBase
      */
     @Override
     public final void service(HttpServletRequest request, HttpServletResponse response) 
-	throws ServletException, IOException 
+        throws ServletException, IOException 
     {
         _jspService(request, response);
     }
@@ -86,6 +81,6 @@ public abstract class HttpJspBase
     }
 
     public abstract void _jspService(HttpServletRequest request, 
-				     HttpServletResponse response) 
-	throws ServletException, IOException;
+                                     HttpServletResponse response) 
+        throws ServletException, IOException;
 }

==================================================
JspApplicationContextImpl.java
index 04faae370a..b8661d358b 100644
--- a/java/org/apache/jasper/runtime/InstanceManagerFactory.java
+++ b/java/org/apache/jasper/runtime/InstanceManagerFactory.java
@@ -34,7 +34,7 @@ public class InstanceManagerFactory {
 
     public static InstanceManager getInstanceManager(ServletConfig config) {
         InstanceManager instanceManager = 
-        	(InstanceManager) config.getServletContext().getAttribute(InstanceManager.class.getName());
+                (InstanceManager) config.getServletContext().getAttribute(InstanceManager.class.getName());
         if (instanceManager == null) {
             throw new IllegalStateException("No org.apache.tomcat.InstanceManager set in ServletContext");
         }

==================================================
JspContextWrapper.java
index 9f85da2a25..c45966b54c 100644
--- a/java/org/apache/jasper/runtime/JspApplicationContextImpl.java
+++ b/java/org/apache/jasper/runtime/JspApplicationContextImpl.java
@@ -48,105 +48,105 @@ import org.apache.jasper.el.ELContextImpl;
  */
 public class JspApplicationContextImpl implements JspApplicationContext {
 
-	private final static String KEY = JspApplicationContextImpl.class.getName();
-
-	private final static ExpressionFactory expressionFactory =
-	    ExpressionFactory.newInstance();
-
-	private final List<ELContextListener> contextListeners = new ArrayList<ELContextListener>();
-
-	private final List<ELResolver> resolvers = new ArrayList<ELResolver>();
-
-	private boolean instantiated = false;
-
-	private ELResolver resolver;
-
-	public JspApplicationContextImpl() {
-
-	}
-
-	public void addELContextListener(ELContextListener listener) {
-		if (listener == null) {
-			throw new IllegalArgumentException("ELConextListener was null");
-		}
-		this.contextListeners.add(listener);
-	}
-
-	public static JspApplicationContextImpl getInstance(ServletContext context) {
-		if (context == null) {
-			throw new IllegalArgumentException("ServletContext was null");
-		}
-		JspApplicationContextImpl impl = (JspApplicationContextImpl) context
-				.getAttribute(KEY);
-		if (impl == null) {
-			impl = new JspApplicationContextImpl();
-			context.setAttribute(KEY, impl);
-		}
-		return impl;
-	}
-
-	public ELContextImpl createELContext(JspContext context) {
-		if (context == null) {
-			throw new IllegalArgumentException("JspContext was null");
-		}
-
-		// create ELContext for JspContext
-		final ELResolver r = this.createELResolver();
-		ELContextImpl ctx;
-		if (Constants.IS_SECURITY_ENABLED) {
-		    ctx = AccessController.doPrivileged(
-		            new PrivilegedAction<ELContextImpl>() {
-		                public ELContextImpl run() {
-		                    return new ELContextImpl(r);
-		                }
-		            });
-		} else {
-		    ctx = new ELContextImpl(r);
-		}
-		ctx.putContext(JspContext.class, context);
-
-		// alert all ELContextListeners
-		ELContextEvent event = new ELContextEvent(ctx);
-		for (int i = 0; i < this.contextListeners.size(); i++) {
-			this.contextListeners.get(i).contextCreated(event);
-		}
-
-		return ctx;
-	}
-
-	private ELResolver createELResolver() {
-		this.instantiated = true;
-		if (this.resolver == null) {
-			CompositeELResolver r = new CompositeELResolver();
-			r.add(new ImplicitObjectELResolver());
-			for (Iterator<ELResolver> itr = this.resolvers.iterator();
-			        itr.hasNext();) {
-				r.add(itr.next());
-			}
-			r.add(new MapELResolver());
-			r.add(new ResourceBundleELResolver());
-			r.add(new ListELResolver());
-			r.add(new ArrayELResolver());	
-			r.add(new BeanELResolver());
-			r.add(new ScopedAttributeELResolver());
-			this.resolver = r;
-		}
-		return this.resolver;
-	}
-
-	public void addELResolver(ELResolver resolver) throws IllegalStateException {
-		if (resolver == null) {
-			throw new IllegalArgumentException("ELResolver was null");
-		}
-		if (this.instantiated) {
-			throw new IllegalStateException(
-					"cannot call addELResolver after the first request has been made");
-		}
-		this.resolvers.add(resolver);
-	}
-
-	public ExpressionFactory getExpressionFactory() {
-		return expressionFactory;
-	}
+    private final static String KEY = JspApplicationContextImpl.class.getName();
+
+    private final static ExpressionFactory expressionFactory =
+        ExpressionFactory.newInstance();
+
+    private final List<ELContextListener> contextListeners = new ArrayList<ELContextListener>();
+
+    private final List<ELResolver> resolvers = new ArrayList<ELResolver>();
+
+    private boolean instantiated = false;
+
+    private ELResolver resolver;
+
+    public JspApplicationContextImpl() {
+
+    }
+
+    public void addELContextListener(ELContextListener listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("ELConextListener was null");
+        }
+        this.contextListeners.add(listener);
+    }
+
+    public static JspApplicationContextImpl getInstance(ServletContext context) {
+        if (context == null) {
+            throw new IllegalArgumentException("ServletContext was null");
+        }
+        JspApplicationContextImpl impl = (JspApplicationContextImpl) context
+                .getAttribute(KEY);
+        if (impl == null) {
+            impl = new JspApplicationContextImpl();
+            context.setAttribute(KEY, impl);
+        }
+        return impl;
+    }
+
+    public ELContextImpl createELContext(JspContext context) {
+        if (context == null) {
+            throw new IllegalArgumentException("JspContext was null");
+        }
+
+        // create ELContext for JspContext
+        final ELResolver r = this.createELResolver();
+        ELContextImpl ctx;
+        if (Constants.IS_SECURITY_ENABLED) {
+            ctx = AccessController.doPrivileged(
+                    new PrivilegedAction<ELContextImpl>() {
+                        public ELContextImpl run() {
+                            return new ELContextImpl(r);
+                        }
+                    });
+        } else {
+            ctx = new ELContextImpl(r);
+        }
+        ctx.putContext(JspContext.class, context);
+
+        // alert all ELContextListeners
+        ELContextEvent event = new ELContextEvent(ctx);
+        for (int i = 0; i < this.contextListeners.size(); i++) {
+            this.contextListeners.get(i).contextCreated(event);
+        }
+
+        return ctx;
+    }
+
+    private ELResolver createELResolver() {
+        this.instantiated = true;
+        if (this.resolver == null) {
+            CompositeELResolver r = new CompositeELResolver();
+            r.add(new ImplicitObjectELResolver());
+            for (Iterator<ELResolver> itr = this.resolvers.iterator();
+                    itr.hasNext();) {
+                r.add(itr.next());
+            }
+            r.add(new MapELResolver());
+            r.add(new ResourceBundleELResolver());
+            r.add(new ListELResolver());
+            r.add(new ArrayELResolver());    
+            r.add(new BeanELResolver());
+            r.add(new ScopedAttributeELResolver());
+            this.resolver = r;
+        }
+        return this.resolver;
+    }
+
+    public void addELResolver(ELResolver resolver) throws IllegalStateException {
+        if (resolver == null) {
+            throw new IllegalArgumentException("ELResolver was null");
+        }
+        if (this.instantiated) {
+            throw new IllegalStateException(
+                    "cannot call addELResolver after the first request has been made");
+        }
+        this.resolvers.add(resolver);
+    }
+
+    public ExpressionFactory getExpressionFactory() {
+        return expressionFactory;
+    }
 
 }

==================================================
JspWriterImpl.java
index 52c8e6c5e1..6aaf0d497c 100644
--- a/java/org/apache/jasper/runtime/JspContextWrapper.java
+++ b/java/org/apache/jasper/runtime/JspContextWrapper.java
@@ -59,438 +59,438 @@ import org.apache.jasper.util.Enumerator;
  */
 public class JspContextWrapper extends PageContext implements VariableResolver {
 
-	// Invoking JSP context
-	private PageContext invokingJspCtxt;
+    // Invoking JSP context
+    private PageContext invokingJspCtxt;
 
-	private transient HashMap<String, Object> pageAttributes;
+    private transient HashMap<String, Object> pageAttributes;
 
-	// ArrayList of NESTED scripting variables
-	private ArrayList<String> nestedVars;
+    // ArrayList of NESTED scripting variables
+    private ArrayList<String> nestedVars;
 
-	// ArrayList of AT_BEGIN scripting variables
-	private ArrayList<String> atBeginVars;
+    // ArrayList of AT_BEGIN scripting variables
+    private ArrayList<String> atBeginVars;
 
-	// ArrayList of AT_END scripting variables
-	private ArrayList<String> atEndVars;
+    // ArrayList of AT_END scripting variables
+    private ArrayList<String> atEndVars;
 
-	private Map<String,String> aliases;
+    private Map<String,String> aliases;
 
-	private HashMap<String, Object> originalNestedVars;
+    private HashMap<String, Object> originalNestedVars;
 
-	public JspContextWrapper(JspContext jspContext,
-	        ArrayList<String> nestedVars, ArrayList<String> atBeginVars,
-	        ArrayList<String> atEndVars, Map<String,String> aliases) {
-		this.invokingJspCtxt = (PageContext) jspContext;
-		this.nestedVars = nestedVars;
-		this.atBeginVars = atBeginVars;
-		this.atEndVars = atEndVars;
-		this.pageAttributes = new HashMap<String, Object>(16);
-		this.aliases = aliases;
+    public JspContextWrapper(JspContext jspContext,
+            ArrayList<String> nestedVars, ArrayList<String> atBeginVars,
+            ArrayList<String> atEndVars, Map<String,String> aliases) {
+        this.invokingJspCtxt = (PageContext) jspContext;
+        this.nestedVars = nestedVars;
+        this.atBeginVars = atBeginVars;
+        this.atEndVars = atEndVars;
+        this.pageAttributes = new HashMap<String, Object>(16);
+        this.aliases = aliases;
 
-		if (nestedVars != null) {
-			this.originalNestedVars = new HashMap<String, Object>(nestedVars.size());
-		}
-		syncBeginTagFile();
-	}
+        if (nestedVars != null) {
+            this.originalNestedVars = new HashMap<String, Object>(nestedVars.size());
+        }
+        syncBeginTagFile();
+    }
 
-	@Override
+    @Override
     public void initialize(Servlet servlet, ServletRequest request,
-			ServletResponse response, String errorPageURL,
-			boolean needsSession, int bufferSize, boolean autoFlush)
-			throws IOException, IllegalStateException, IllegalArgumentException {
-	}
+            ServletResponse response, String errorPageURL,
+            boolean needsSession, int bufferSize, boolean autoFlush)
+            throws IOException, IllegalStateException, IllegalArgumentException {
+    }
 
-	@Override
+    @Override
     public Object getAttribute(String name) {
 
-		if (name == null) {
-			throw new NullPointerException(Localizer
-					.getMessage("jsp.error.attribute.null_name"));
-		}
+        if (name == null) {
+            throw new NullPointerException(Localizer
+                    .getMessage("jsp.error.attribute.null_name"));
+        }
 
-		return pageAttributes.get(name);
-	}
+        return pageAttributes.get(name);
+    }
 
-	@Override
+    @Override
     public Object getAttribute(String name, int scope) {
 
-		if (name == null) {
-			throw new NullPointerException(Localizer
-					.getMessage("jsp.error.attribute.null_name"));
-		}
+        if (name == null) {
+            throw new NullPointerException(Localizer
+                    .getMessage("jsp.error.attribute.null_name"));
+        }
 
-		if (scope == PAGE_SCOPE) {
-			return pageAttributes.get(name);
-		}
+        if (scope == PAGE_SCOPE) {
+            return pageAttributes.get(name);
+        }
 
-		return invokingJspCtxt.getAttribute(name, scope);
-	}
+        return invokingJspCtxt.getAttribute(name, scope);
+    }
 
-	@Override
+    @Override
     public void setAttribute(String name, Object value) {
 
-		if (name == null) {
-			throw new NullPointerException(Localizer
-					.getMessage("jsp.error.attribute.null_name"));
-		}
+        if (name == null) {
+            throw new NullPointerException(Localizer
+                    .getMessage("jsp.error.attribute.null_name"));
+        }
 
-		if (value != null) {
-			pageAttributes.put(name, value);
-		} else {
-			removeAttribute(name, PAGE_SCOPE);
-		}
-	}
+        if (value != null) {
+            pageAttributes.put(name, value);
+        } else {
+            removeAttribute(name, PAGE_SCOPE);
+        }
+    }
 
-	@Override
+    @Override
     public void setAttribute(String name, Object value, int scope) {
 
-		if (name == null) {
-			throw new NullPointerException(Localizer
-					.getMessage("jsp.error.attribute.null_name"));
-		}
-
-		if (scope == PAGE_SCOPE) {
-			if (value != null) {
-				pageAttributes.put(name, value);
-			} else {
-				removeAttribute(name, PAGE_SCOPE);
-			}
-		} else {
-			invokingJspCtxt.setAttribute(name, value, scope);
-		}
-	}
-
-	@Override
+        if (name == null) {
+            throw new NullPointerException(Localizer
+                    .getMessage("jsp.error.attribute.null_name"));
+        }
+
+        if (scope == PAGE_SCOPE) {
+            if (value != null) {
+                pageAttributes.put(name, value);
+            } else {
+                removeAttribute(name, PAGE_SCOPE);
+            }
+        } else {
+            invokingJspCtxt.setAttribute(name, value, scope);
+        }
+    }
+
+    @Override
     public Object findAttribute(String name) {
 
-		if (name == null) {
-			throw new NullPointerException(Localizer
-					.getMessage("jsp.error.attribute.null_name"));
-		}
-
-		Object o = pageAttributes.get(name);
-		if (o == null) {
-			o = invokingJspCtxt.getAttribute(name, REQUEST_SCOPE);
-			if (o == null) {
-				if (getSession() != null) {
-					o = invokingJspCtxt.getAttribute(name, SESSION_SCOPE);
-				}
-				if (o == null) {
-					o = invokingJspCtxt.getAttribute(name, APPLICATION_SCOPE);
-				}
-			}
-		}
-
-		return o;
-	}
-
-	@Override
+        if (name == null) {
+            throw new NullPointerException(Localizer
+                    .getMessage("jsp.error.attribute.null_name"));
+        }
+
+        Object o = pageAttributes.get(name);
+        if (o == null) {
+            o = invokingJspCtxt.getAttribute(name, REQUEST_SCOPE);
+            if (o == null) {
+                if (getSession() != null) {
+                    o = invokingJspCtxt.getAttribute(name, SESSION_SCOPE);
+                }
+                if (o == null) {
+                    o = invokingJspCtxt.getAttribute(name, APPLICATION_SCOPE);
+                }
+            }
+        }
+
+        return o;
+    }
+
+    @Override
     public void removeAttribute(String name) {
 
-		if (name == null) {
-			throw new NullPointerException(Localizer
-					.getMessage("jsp.error.attribute.null_name"));
-		}
+        if (name == null) {
+            throw new NullPointerException(Localizer
+                    .getMessage("jsp.error.attribute.null_name"));
+        }
 
-		pageAttributes.remove(name);
-		invokingJspCtxt.removeAttribute(name, REQUEST_SCOPE);
-		if (getSession() != null) {
-			invokingJspCtxt.removeAttribute(name, SESSION_SCOPE);
-		}
-		invokingJspCtxt.removeAttribute(name, APPLICATION_SCOPE);
-	}
+        pageAttributes.remove(name);
+        invokingJspCtxt.removeAttribute(name, REQUEST_SCOPE);
+        if (getSession() != null) {
+            invokingJspCtxt.removeAttribute(name, SESSION_SCOPE);
+        }
+        invokingJspCtxt.removeAttribute(name, APPLICATION_SCOPE);
+    }
 
-	@Override
+    @Override
     public void removeAttribute(String name, int scope) {
 
-		if (name == null) {
-			throw new NullPointerException(Localizer
-					.getMessage("jsp.error.attribute.null_name"));
-		}
+        if (name == null) {
+            throw new NullPointerException(Localizer
+                    .getMessage("jsp.error.attribute.null_name"));
+        }
 
-		if (scope == PAGE_SCOPE) {
-			pageAttributes.remove(name);
-		} else {
-			invokingJspCtxt.removeAttribute(name, scope);
-		}
-	}
+        if (scope == PAGE_SCOPE) {
+            pageAttributes.remove(name);
+        } else {
+            invokingJspCtxt.removeAttribute(name, scope);
+        }
+    }
 
-	@Override
+    @Override
     public int getAttributesScope(String name) {
 
-		if (name == null) {
-			throw new NullPointerException(Localizer
-					.getMessage("jsp.error.attribute.null_name"));
-		}
+        if (name == null) {
+            throw new NullPointerException(Localizer
+                    .getMessage("jsp.error.attribute.null_name"));
+        }
 
-		if (pageAttributes.get(name) != null) {
-			return PAGE_SCOPE;
-		} else {
-			return invokingJspCtxt.getAttributesScope(name);
-		}
-	}
+        if (pageAttributes.get(name) != null) {
+            return PAGE_SCOPE;
+        } else {
+            return invokingJspCtxt.getAttributesScope(name);
+        }
+    }
 
-	@Override
+    @Override
     public Enumeration<String> getAttributeNamesInScope(int scope) {
-		if (scope == PAGE_SCOPE) {
-			return new Enumerator<String>(pageAttributes.keySet().iterator());
-		}
+        if (scope == PAGE_SCOPE) {
+            return new Enumerator<String>(pageAttributes.keySet().iterator());
+        }
 
-		return invokingJspCtxt.getAttributeNamesInScope(scope);
-	}
+        return invokingJspCtxt.getAttributeNamesInScope(scope);
+    }
 
-	@Override
+    @Override
     public void release() {
-		invokingJspCtxt.release();
-	}
+        invokingJspCtxt.release();
+    }
 
-	@Override
+    @Override
     public JspWriter getOut() {
-		return invokingJspCtxt.getOut();
-	}
+        return invokingJspCtxt.getOut();
+    }
 
-	@Override
+    @Override
     public HttpSession getSession() {
-		return invokingJspCtxt.getSession();
-	}
+        return invokingJspCtxt.getSession();
+    }
 
-	@Override
+    @Override
     public Object getPage() {
-		return invokingJspCtxt.getPage();
-	}
+        return invokingJspCtxt.getPage();
+    }
 
-	@Override
+    @Override
     public ServletRequest getRequest() {
-		return invokingJspCtxt.getRequest();
-	}
+        return invokingJspCtxt.getRequest();
+    }
 
-	@Override
+    @Override
     public ServletResponse getResponse() {
-		return invokingJspCtxt.getResponse();
-	}
+        return invokingJspCtxt.getResponse();
+    }
 
-	@Override
+    @Override
     public Exception getException() {
-		return invokingJspCtxt.getException();
-	}
+        return invokingJspCtxt.getException();
+    }
 
-	@Override
+    @Override
     public ServletConfig getServletConfig() {
-		return invokingJspCtxt.getServletConfig();
-	}
+        return invokingJspCtxt.getServletConfig();
+    }
 
-	@Override
+    @Override
     public ServletContext getServletContext() {
-		return invokingJspCtxt.getServletContext();
-	}
+        return invokingJspCtxt.getServletContext();
+    }
 
-	@Override
+    @Override
     public void forward(String relativeUrlPath) throws ServletException,
-			IOException {
-		invokingJspCtxt.forward(relativeUrlPath);
-	}
+            IOException {
+        invokingJspCtxt.forward(relativeUrlPath);
+    }
 
-	@Override
+    @Override
     public void include(String relativeUrlPath) throws ServletException,
-			IOException {
-		invokingJspCtxt.include(relativeUrlPath);
-	}
+            IOException {
+        invokingJspCtxt.include(relativeUrlPath);
+    }
 
-	@Override
+    @Override
     public void include(String relativeUrlPath, boolean flush)
-			throws ServletException, IOException {
-		invokingJspCtxt.include(relativeUrlPath, false);
-	}
+            throws ServletException, IOException {
+        invokingJspCtxt.include(relativeUrlPath, false);
+    }
 
-	@Override
-	@Deprecated
+    @Override
+    @Deprecated
     public VariableResolver getVariableResolver() {
-		return this;
-	}
+        return this;
+    }
 
-	@Override
+    @Override
     public BodyContent pushBody() {
-		return invokingJspCtxt.pushBody();
-	}
+        return invokingJspCtxt.pushBody();
+    }
 
-	@Override
+    @Override
     public JspWriter pushBody(Writer writer) {
-		return invokingJspCtxt.pushBody(writer);
-	}
+        return invokingJspCtxt.pushBody(writer);
+    }
 
-	@Override
+    @Override
     public JspWriter popBody() {
-		return invokingJspCtxt.popBody();
-	}
+        return invokingJspCtxt.popBody();
+    }
 
-	@Override
-	@Deprecated
+    @Override
+    @Deprecated
     public ExpressionEvaluator getExpressionEvaluator() {
-		return invokingJspCtxt.getExpressionEvaluator();
-	}
+        return invokingJspCtxt.getExpressionEvaluator();
+    }
 
-	@Override
+    @Override
     public void handlePageException(Exception ex) throws IOException,
-			ServletException {
-		// Should never be called since handleException() called with a
-		// Throwable in the generated servlet.
-		handlePageException((Throwable) ex);
-	}
+            ServletException {
+        // Should never be called since handleException() called with a
+        // Throwable in the generated servlet.
+        handlePageException((Throwable) ex);
+    }
 
-	@Override
+    @Override
     public void handlePageException(Throwable t) throws IOException,
-			ServletException {
-		invokingJspCtxt.handlePageException(t);
-	}
-
-	/**
-	 * VariableResolver interface
-	 */
-	@Deprecated
-	public Object resolveVariable(String pName) throws ELException {
-		ELContext ctx = this.getELContext();
-		return ctx.getELResolver().getValue(ctx, null, pName);
-	}
-
-	/**
-	 * Synchronize variables at begin of tag file
-	 */
-	public void syncBeginTagFile() {
-		saveNestedVariables();
-	}
-
-	/**
-	 * Synchronize variables before fragment invocation
-	 */
-	public void syncBeforeInvoke() {
-		copyTagToPageScope(VariableInfo.NESTED);
-		copyTagToPageScope(VariableInfo.AT_BEGIN);
-	}
-
-	/**
-	 * Synchronize variables at end of tag file
-	 */
-	public void syncEndTagFile() {
-		copyTagToPageScope(VariableInfo.AT_BEGIN);
-		copyTagToPageScope(VariableInfo.AT_END);
-		restoreNestedVariables();
-	}
-
-	/**
-	 * Copies the variables of the given scope from the virtual page scope of
-	 * this JSP context wrapper to the page scope of the invoking JSP context.
-	 * 
-	 * @param scope
-	 *            variable scope (one of NESTED, AT_BEGIN, or AT_END)
-	 */
-	private void copyTagToPageScope(int scope) {
-		Iterator<String> iter = null;
-
-		switch (scope) {
-		case VariableInfo.NESTED:
-			if (nestedVars != null) {
-				iter = nestedVars.iterator();
-			}
-			break;
-		case VariableInfo.AT_BEGIN:
-			if (atBeginVars != null) {
-				iter = atBeginVars.iterator();
-			}
-			break;
-		case VariableInfo.AT_END:
-			if (atEndVars != null) {
-				iter = atEndVars.iterator();
-			}
-			break;
-		}
-
-		while ((iter != null) && iter.hasNext()) {
-			String varName = iter.next();
-			Object obj = getAttribute(varName);
-			varName = findAlias(varName);
-			if (obj != null) {
-				invokingJspCtxt.setAttribute(varName, obj);
-			} else {
-				invokingJspCtxt.removeAttribute(varName, PAGE_SCOPE);
-			}
-		}
-	}
-
-	/**
-	 * Saves the values of any NESTED variables that are present in the invoking
-	 * JSP context, so they can later be restored.
-	 */
-	private void saveNestedVariables() {
-		if (nestedVars != null) {
-			Iterator<String> iter = nestedVars.iterator();
-			while (iter.hasNext()) {
-				String varName = iter.next();
-				varName = findAlias(varName);
-				Object obj = invokingJspCtxt.getAttribute(varName);
-				if (obj != null) {
-					originalNestedVars.put(varName, obj);
-				}
-			}
-		}
-	}
-
-	/**
-	 * Restores the values of any NESTED variables in the invoking JSP context.
-	 */
-	private void restoreNestedVariables() {
-		if (nestedVars != null) {
-			Iterator<String> iter = nestedVars.iterator();
-			while (iter.hasNext()) {
-				String varName = iter.next();
-				varName = findAlias(varName);
-				Object obj = originalNestedVars.get(varName);
-				if (obj != null) {
-					invokingJspCtxt.setAttribute(varName, obj);
-				} else {
-					invokingJspCtxt.removeAttribute(varName, PAGE_SCOPE);
-				}
-			}
-		}
-	}
-
-	/**
-	 * Checks to see if the given variable name is used as an alias, and if so,
-	 * returns the variable name for which it is used as an alias.
-	 * 
-	 * @param varName
-	 *            The variable name to check
-	 * @return The variable name for which varName is used as an alias, or
-	 *         varName if it is not being used as an alias
-	 */
-	private String findAlias(String varName) {
-
-		if (aliases == null)
-			return varName;
-
-		String alias = aliases.get(varName);
-		if (alias == null) {
-			return varName;
-		}
-		return alias;
-	}
-
-	//private ELContextImpl elContext;
-
-	@Override
+            ServletException {
+        invokingJspCtxt.handlePageException(t);
+    }
+
+    /**
+     * VariableResolver interface
+     */
+    @Deprecated
+    public Object resolveVariable(String pName) throws ELException {
+        ELContext ctx = this.getELContext();
+        return ctx.getELResolver().getValue(ctx, null, pName);
+    }
+
+    /**
+     * Synchronize variables at begin of tag file
+     */
+    public void syncBeginTagFile() {
+        saveNestedVariables();
+    }
+
+    /**
+     * Synchronize variables before fragment invocation
+     */
+    public void syncBeforeInvoke() {
+        copyTagToPageScope(VariableInfo.NESTED);
+        copyTagToPageScope(VariableInfo.AT_BEGIN);
+    }
+
+    /**
+     * Synchronize variables at end of tag file
+     */
+    public void syncEndTagFile() {
+        copyTagToPageScope(VariableInfo.AT_BEGIN);
+        copyTagToPageScope(VariableInfo.AT_END);
+        restoreNestedVariables();
+    }
+
+    /**
+     * Copies the variables of the given scope from the virtual page scope of
+     * this JSP context wrapper to the page scope of the invoking JSP context.
+     * 
+     * @param scope
+     *            variable scope (one of NESTED, AT_BEGIN, or AT_END)
+     */
+    private void copyTagToPageScope(int scope) {
+        Iterator<String> iter = null;
+
+        switch (scope) {
+        case VariableInfo.NESTED:
+            if (nestedVars != null) {
+                iter = nestedVars.iterator();
+            }
+            break;
+        case VariableInfo.AT_BEGIN:
+            if (atBeginVars != null) {
+                iter = atBeginVars.iterator();
+            }
+            break;
+        case VariableInfo.AT_END:
+            if (atEndVars != null) {
+                iter = atEndVars.iterator();
+            }
+            break;
+        }
+
+        while ((iter != null) && iter.hasNext()) {
+            String varName = iter.next();
+            Object obj = getAttribute(varName);
+            varName = findAlias(varName);
+            if (obj != null) {
+                invokingJspCtxt.setAttribute(varName, obj);
+            } else {
+                invokingJspCtxt.removeAttribute(varName, PAGE_SCOPE);
+            }
+        }
+    }
+
+    /**
+     * Saves the values of any NESTED variables that are present in the invoking
+     * JSP context, so they can later be restored.
+     */
+    private void saveNestedVariables() {
+        if (nestedVars != null) {
+            Iterator<String> iter = nestedVars.iterator();
+            while (iter.hasNext()) {
+                String varName = iter.next();
+                varName = findAlias(varName);
+                Object obj = invokingJspCtxt.getAttribute(varName);
+                if (obj != null) {
+                    originalNestedVars.put(varName, obj);
+                }
+            }
+        }
+    }
+
+    /**
+     * Restores the values of any NESTED variables in the invoking JSP context.
+     */
+    private void restoreNestedVariables() {
+        if (nestedVars != null) {
+            Iterator<String> iter = nestedVars.iterator();
+            while (iter.hasNext()) {
+                String varName = iter.next();
+                varName = findAlias(varName);
+                Object obj = originalNestedVars.get(varName);
+                if (obj != null) {
+                    invokingJspCtxt.setAttribute(varName, obj);
+                } else {
+                    invokingJspCtxt.removeAttribute(varName, PAGE_SCOPE);
+                }
+            }
+        }
+    }
+
+    /**
+     * Checks to see if the given variable name is used as an alias, and if so,
+     * returns the variable name for which it is used as an alias.
+     * 
+     * @param varName
+     *            The variable name to check
+     * @return The variable name for which varName is used as an alias, or
+     *         varName if it is not being used as an alias
+     */
+    private String findAlias(String varName) {
+
+        if (aliases == null)
+            return varName;
+
+        String alias = aliases.get(varName);
+        if (alias == null) {
+            return varName;
+        }
+        return alias;
+    }
+
+    //private ELContextImpl elContext;
+
+    @Override
     public ELContext getELContext() {
         // instead decorate!!!
         
         return this.invokingJspCtxt.getELContext();
         
         /*
-		if (this.elContext != null) {
-			JspFactory jspFact = JspFactory.getDefaultFactory();
-			ServletContext servletContext = this.getServletContext();
-			JspApplicationContextImpl jspCtx = (JspApplicationContextImpl) jspFact
-					.getJspApplicationContext(servletContext);
-			this.elContext = jspCtx.createELContext(this);
-		}
-		return this.elContext;
+        if (this.elContext != null) {
+            JspFactory jspFact = JspFactory.getDefaultFactory();
+            ServletContext servletContext = this.getServletContext();
+            JspApplicationContextImpl jspCtx = (JspApplicationContextImpl) jspFact
+                    .getJspApplicationContext(servletContext);
+            this.elContext = jspCtx.createELContext(this);
+        }
+        return this.elContext;
         */
-	}
+    }
 }

==================================================
PageContextImpl.java
index 6cb3a43053..3e5f9780e5 100644
--- a/java/org/apache/jasper/runtime/JspWriterImpl.java
+++ b/java/org/apache/jasper/runtime/JspWriterImpl.java
@@ -70,7 +70,7 @@ public class JspWriterImpl extends JspWriter {
      * buffer of the given size.
      *
      * @param  response A Servlet Response
-     * @param  sz   	Output-buffer size, a positive integer
+     * @param  sz       Output-buffer size, a positive integer
      *
      * @exception  IllegalArgumentException  If sz is <= 0
      */

==================================================
PerThreadTagHandlerPool.java
index cdae51157a..c030910a2b 100644
--- a/java/org/apache/jasper/runtime/PageContextImpl.java
+++ b/java/org/apache/jasper/runtime/PageContextImpl.java
@@ -70,919 +70,919 @@ import org.apache.jasper.util.Enumerator;
  */
 public class PageContextImpl extends PageContext {
 
-	private static final JspFactory jspf = JspFactory.getDefaultFactory(); 
+    private static final JspFactory jspf = JspFactory.getDefaultFactory(); 
 
-	private BodyContentImpl[] outs;
+    private BodyContentImpl[] outs;
 
-	private int depth;
+    private int depth;
 
-	// per-servlet state
-	private Servlet servlet;
+    // per-servlet state
+    private Servlet servlet;
 
-	private ServletConfig config;
+    private ServletConfig config;
 
-	private ServletContext context;
+    private ServletContext context;
 
-	private JspApplicationContextImpl applicationContext;
+    private JspApplicationContextImpl applicationContext;
 
-	private String errorPageURL;
+    private String errorPageURL;
 
-	// page-scope attributes
-	private transient HashMap<String, Object> attributes;
+    // page-scope attributes
+    private transient HashMap<String, Object> attributes;
 
-	// per-request state
-	private transient ServletRequest request;
+    // per-request state
+    private transient ServletRequest request;
 
-	private transient ServletResponse response;
+    private transient ServletResponse response;
 
-	private transient HttpSession session;
-	
-	private transient ELContextImpl elContext;
+    private transient HttpSession session;
+    
+    private transient ELContextImpl elContext;
 
-	private boolean isIncluded;
-	
-	
-	// initial output stream
-	private transient JspWriter out;
+    private boolean isIncluded;
+    
+    
+    // initial output stream
+    private transient JspWriter out;
 
-	private transient JspWriterImpl baseOut;
+    private transient JspWriterImpl baseOut;
 
-	/*
-	 * Constructor.
-	 */
-	PageContextImpl() {
-		this.outs = new BodyContentImpl[0];
-		this.attributes = new HashMap<String, Object>(16);
-		this.depth = -1;
-	}
+    /*
+     * Constructor.
+     */
+    PageContextImpl() {
+        this.outs = new BodyContentImpl[0];
+        this.attributes = new HashMap<String, Object>(16);
+        this.depth = -1;
+    }
 
-	@Override
+    @Override
     public void initialize(Servlet servlet, ServletRequest request,
-			ServletResponse response, String errorPageURL,
-			boolean needsSession, int bufferSize, boolean autoFlush)
-			throws IOException {
-
-		_initialize(servlet, request, response, errorPageURL, needsSession,
-				bufferSize, autoFlush);
-	}
-
-	private void _initialize(Servlet servlet, ServletRequest request,
-			ServletResponse response, String errorPageURL,
-			boolean needsSession, int bufferSize, boolean autoFlush) {
-
-		// initialize state
-		this.servlet = servlet;
-		this.config = servlet.getServletConfig();
-		this.context = config.getServletContext();
-		this.errorPageURL = errorPageURL;
-		this.request = request;
-		this.response = response;
-		
-		// initialize application context
-		this.applicationContext = JspApplicationContextImpl.getInstance(context);
-
-		// Setup session (if required)
-		if (request instanceof HttpServletRequest && needsSession)
-			this.session = ((HttpServletRequest) request).getSession();
-		if (needsSession && session == null)
-			throw new IllegalStateException(
-					"Page needs a session and none is available");
-
-		// initialize the initial out ...
-		depth = -1;
-		if (this.baseOut == null) {
-			this.baseOut = new JspWriterImpl(response, bufferSize, autoFlush);
-		} else {
-			this.baseOut.init(response, bufferSize, autoFlush);
-		}
-		this.out = baseOut;
-
-		// register names/values as per spec
-		setAttribute(OUT, this.out);
-		setAttribute(REQUEST, request);
-		setAttribute(RESPONSE, response);
-
-		if (session != null)
-			setAttribute(SESSION, session);
-
-		setAttribute(PAGE, servlet);
-		setAttribute(CONFIG, config);
-		setAttribute(PAGECONTEXT, this);
-		setAttribute(APPLICATION, context);
-
-		isIncluded = request.getAttribute("javax.servlet.include.servlet_path") != null;
-	}
-
-	@Override
+            ServletResponse response, String errorPageURL,
+            boolean needsSession, int bufferSize, boolean autoFlush)
+            throws IOException {
+
+        _initialize(servlet, request, response, errorPageURL, needsSession,
+                bufferSize, autoFlush);
+    }
+
+    private void _initialize(Servlet servlet, ServletRequest request,
+            ServletResponse response, String errorPageURL,
+            boolean needsSession, int bufferSize, boolean autoFlush) {
+
+        // initialize state
+        this.servlet = servlet;
+        this.config = servlet.getServletConfig();
+        this.context = config.getServletContext();
+        this.errorPageURL = errorPageURL;
+        this.request = request;
+        this.response = response;
+        
+        // initialize application context
+        this.applicationContext = JspApplicationContextImpl.getInstance(context);
+
+        // Setup session (if required)
+        if (request instanceof HttpServletRequest && needsSession)
+            this.session = ((HttpServletRequest) request).getSession();
+        if (needsSession && session == null)
+            throw new IllegalStateException(
+                    "Page needs a session and none is available");
+
+        // initialize the initial out ...
+        depth = -1;
+        if (this.baseOut == null) {
+            this.baseOut = new JspWriterImpl(response, bufferSize, autoFlush);
+        } else {
+            this.baseOut.init(response, bufferSize, autoFlush);
+        }
+        this.out = baseOut;
+
+        // register names/values as per spec
+        setAttribute(OUT, this.out);
+        setAttribute(REQUEST, request);
+        setAttribute(RESPONSE, response);
+
+        if (session != null)
+            setAttribute(SESSION, session);
+
+        setAttribute(PAGE, servlet);
+        setAttribute(CONFIG, config);
+        setAttribute(PAGECONTEXT, this);
+        setAttribute(APPLICATION, context);
+
+        isIncluded = request.getAttribute("javax.servlet.include.servlet_path") != null;
+    }
+
+    @Override
     public void release() {
-		out = baseOut;
-		try {
-			if (isIncluded) {
-				((JspWriterImpl) out).flushBuffer();
-				// push it into the including jspWriter
-			} else {
-				// Old code:
-				// out.flush();
-				// Do not flush the buffer even if we're not included (i.e.
-				// we are the main page. The servlet will flush it and close
-				// the stream.
-				((JspWriterImpl) out).flushBuffer();
-			}
-		} catch (IOException ex) {
+        out = baseOut;
+        try {
+            if (isIncluded) {
+                ((JspWriterImpl) out).flushBuffer();
+                // push it into the including jspWriter
+            } else {
+                // Old code:
+                // out.flush();
+                // Do not flush the buffer even if we're not included (i.e.
+                // we are the main page. The servlet will flush it and close
+                // the stream.
+                ((JspWriterImpl) out).flushBuffer();
+            }
+        } catch (IOException ex) {
             IllegalStateException ise = new IllegalStateException(Localizer.getMessage("jsp.error.flush"), ex);
             throw ise;
-		} finally {
-		    servlet = null;
-		    config = null;
-		    context = null;
-		    applicationContext = null;
-		    elContext = null;
-		    errorPageURL = null;
-		    request = null;
-		    response = null;
-		    depth = -1;
-		    baseOut.recycle();
-		    session = null;
-		    attributes.clear();
-        }
-	}
-
-	@Override
+        } finally {
+            servlet = null;
+            config = null;
+            context = null;
+            applicationContext = null;
+            elContext = null;
+            errorPageURL = null;
+            request = null;
+            response = null;
+            depth = -1;
+            baseOut.recycle();
+            session = null;
+            attributes.clear();
+        }
+    }
+
+    @Override
     public Object getAttribute(final String name) {
 
-		if (name == null) {
-			throw new NullPointerException(Localizer
-					.getMessage("jsp.error.attribute.null_name"));
-		}
-
-		if (SecurityUtil.isPackageProtectionEnabled()) {
-			return AccessController.doPrivileged(
-			        new PrivilegedAction<Object>() {
-				public Object run() {
-					return doGetAttribute(name);
-				}
-			});
-		} else {
-			return doGetAttribute(name);
-		}
-
-	}
-
-	private Object doGetAttribute(String name) {
-		return attributes.get(name);
-	}
-
-	@Override
+        if (name == null) {
+            throw new NullPointerException(Localizer
+                    .getMessage("jsp.error.attribute.null_name"));
+        }
+
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            return AccessController.doPrivileged(
+                    new PrivilegedAction<Object>() {
+                public Object run() {
+                    return doGetAttribute(name);
+                }
+            });
+        } else {
+            return doGetAttribute(name);
+        }
+
+    }
+
+    private Object doGetAttribute(String name) {
+        return attributes.get(name);
+    }
+
+    @Override
     public Object getAttribute(final String name, final int scope) {
 
-		if (name == null) {
-			throw new NullPointerException(Localizer
-					.getMessage("jsp.error.attribute.null_name"));
-		}
-
-		if (SecurityUtil.isPackageProtectionEnabled()) {
-			return AccessController.doPrivileged(
-			        new PrivilegedAction<Object>() {
-				public Object run() {
-					return doGetAttribute(name, scope);
-				}
-			});
-		} else {
-			return doGetAttribute(name, scope);
-		}
-
-	}
-
-	private Object doGetAttribute(String name, int scope) {
-		switch (scope) {
-		case PAGE_SCOPE:
-			return attributes.get(name);
-
-		case REQUEST_SCOPE:
-			return request.getAttribute(name);
-
-		case SESSION_SCOPE:
-			if (session == null) {
-				throw new IllegalStateException(Localizer
-						.getMessage("jsp.error.page.noSession"));
-			}
-			return session.getAttribute(name);
-
-		case APPLICATION_SCOPE:
-			return context.getAttribute(name);
-
-		default:
-			throw new IllegalArgumentException("Invalid scope");
-		}
-	}
-
-	@Override
+        if (name == null) {
+            throw new NullPointerException(Localizer
+                    .getMessage("jsp.error.attribute.null_name"));
+        }
+
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            return AccessController.doPrivileged(
+                    new PrivilegedAction<Object>() {
+                public Object run() {
+                    return doGetAttribute(name, scope);
+                }
+            });
+        } else {
+            return doGetAttribute(name, scope);
+        }
+
+    }
+
+    private Object doGetAttribute(String name, int scope) {
+        switch (scope) {
+        case PAGE_SCOPE:
+            return attributes.get(name);
+
+        case REQUEST_SCOPE:
+            return request.getAttribute(name);
+
+        case SESSION_SCOPE:
+            if (session == null) {
+                throw new IllegalStateException(Localizer
+                        .getMessage("jsp.error.page.noSession"));
+            }
+            return session.getAttribute(name);
+
+        case APPLICATION_SCOPE:
+            return context.getAttribute(name);
+
+        default:
+            throw new IllegalArgumentException("Invalid scope");
+        }
+    }
+
+    @Override
     public void setAttribute(final String name, final Object attribute) {
 
-		if (name == null) {
-			throw new NullPointerException(Localizer
-					.getMessage("jsp.error.attribute.null_name"));
-		}
-
-		if (SecurityUtil.isPackageProtectionEnabled()) {
-			AccessController.doPrivileged(new PrivilegedAction<Void>() {
-				public Void run() {
-					doSetAttribute(name, attribute);
-					return null;
-				}
-			});
-		} else {
-			doSetAttribute(name, attribute);
-		}
-	}
-
-	private void doSetAttribute(String name, Object attribute) {
-		if (attribute != null) {
-			attributes.put(name, attribute);
-		} else {
-			removeAttribute(name, PAGE_SCOPE);
-		}
-	}
-
-	@Override
+        if (name == null) {
+            throw new NullPointerException(Localizer
+                    .getMessage("jsp.error.attribute.null_name"));
+        }
+
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                public Void run() {
+                    doSetAttribute(name, attribute);
+                    return null;
+                }
+            });
+        } else {
+            doSetAttribute(name, attribute);
+        }
+    }
+
+    private void doSetAttribute(String name, Object attribute) {
+        if (attribute != null) {
+            attributes.put(name, attribute);
+        } else {
+            removeAttribute(name, PAGE_SCOPE);
+        }
+    }
+
+    @Override
     public void setAttribute(final String name, final Object o, final int scope) {
 
-		if (name == null) {
-			throw new NullPointerException(Localizer
-					.getMessage("jsp.error.attribute.null_name"));
-		}
-
-		if (SecurityUtil.isPackageProtectionEnabled()) {
-			AccessController.doPrivileged(new PrivilegedAction<Void>() {
-				public Void run() {
-					doSetAttribute(name, o, scope);
-					return null;
-				}
-			});
-		} else {
-			doSetAttribute(name, o, scope);
-		}
-
-	}
-
-	private void doSetAttribute(String name, Object o, int scope) {
-		if (o != null) {
-			switch (scope) {
-			case PAGE_SCOPE:
-				attributes.put(name, o);
-				break;
-
-			case REQUEST_SCOPE:
-				request.setAttribute(name, o);
-				break;
-
-			case SESSION_SCOPE:
-				if (session == null) {
-					throw new IllegalStateException(Localizer
-							.getMessage("jsp.error.page.noSession"));
-				}
-				session.setAttribute(name, o);
-				break;
-
-			case APPLICATION_SCOPE:
-				context.setAttribute(name, o);
-				break;
-
-			default:
-				throw new IllegalArgumentException("Invalid scope");
-			}
-		} else {
-			removeAttribute(name, scope);
-		}
-	}
-
-	@Override
+        if (name == null) {
+            throw new NullPointerException(Localizer
+                    .getMessage("jsp.error.attribute.null_name"));
+        }
+
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                public Void run() {
+                    doSetAttribute(name, o, scope);
+                    return null;
+                }
+            });
+        } else {
+            doSetAttribute(name, o, scope);
+        }
+
+    }
+
+    private void doSetAttribute(String name, Object o, int scope) {
+        if (o != null) {
+            switch (scope) {
+            case PAGE_SCOPE:
+                attributes.put(name, o);
+                break;
+
+            case REQUEST_SCOPE:
+                request.setAttribute(name, o);
+                break;
+
+            case SESSION_SCOPE:
+                if (session == null) {
+                    throw new IllegalStateException(Localizer
+                            .getMessage("jsp.error.page.noSession"));
+                }
+                session.setAttribute(name, o);
+                break;
+
+            case APPLICATION_SCOPE:
+                context.setAttribute(name, o);
+                break;
+
+            default:
+                throw new IllegalArgumentException("Invalid scope");
+            }
+        } else {
+            removeAttribute(name, scope);
+        }
+    }
+
+    @Override
     public void removeAttribute(final String name, final int scope) {
 
-		if (name == null) {
-			throw new NullPointerException(Localizer
-					.getMessage("jsp.error.attribute.null_name"));
-		}
-		if (SecurityUtil.isPackageProtectionEnabled()) {
-			AccessController.doPrivileged(new PrivilegedAction<Void>() {
-				public Void run() {
-					doRemoveAttribute(name, scope);
-					return null;
-				}
-			});
-		} else {
-			doRemoveAttribute(name, scope);
-		}
-	}
-
-	private void doRemoveAttribute(String name, int scope) {
-		switch (scope) {
-		case PAGE_SCOPE:
-			attributes.remove(name);
-			break;
-
-		case REQUEST_SCOPE:
-			request.removeAttribute(name);
-			break;
-
-		case SESSION_SCOPE:
-			if (session == null) {
-				throw new IllegalStateException(Localizer
-						.getMessage("jsp.error.page.noSession"));
-			}
-			session.removeAttribute(name);
-			break;
-
-		case APPLICATION_SCOPE:
-			context.removeAttribute(name);
-			break;
-
-		default:
-			throw new IllegalArgumentException("Invalid scope");
-		}
-	}
-
-	@Override
+        if (name == null) {
+            throw new NullPointerException(Localizer
+                    .getMessage("jsp.error.attribute.null_name"));
+        }
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                public Void run() {
+                    doRemoveAttribute(name, scope);
+                    return null;
+                }
+            });
+        } else {
+            doRemoveAttribute(name, scope);
+        }
+    }
+
+    private void doRemoveAttribute(String name, int scope) {
+        switch (scope) {
+        case PAGE_SCOPE:
+            attributes.remove(name);
+            break;
+
+        case REQUEST_SCOPE:
+            request.removeAttribute(name);
+            break;
+
+        case SESSION_SCOPE:
+            if (session == null) {
+                throw new IllegalStateException(Localizer
+                        .getMessage("jsp.error.page.noSession"));
+            }
+            session.removeAttribute(name);
+            break;
+
+        case APPLICATION_SCOPE:
+            context.removeAttribute(name);
+            break;
+
+        default:
+            throw new IllegalArgumentException("Invalid scope");
+        }
+    }
+
+    @Override
     public int getAttributesScope(final String name) {
 
-		if (name == null) {
-			throw new NullPointerException(Localizer
-					.getMessage("jsp.error.attribute.null_name"));
-		}
-
-		if (SecurityUtil.isPackageProtectionEnabled()) {
-			return (AccessController
-					.doPrivileged(new PrivilegedAction<Integer>() {
-						public Integer run() {
-							return new Integer(doGetAttributeScope(name));
-						}
-					})).intValue();
-		} else {
-			return doGetAttributeScope(name);
-		}
-	}
-
-	private int doGetAttributeScope(String name) {
-		if (attributes.get(name) != null)
-			return PAGE_SCOPE;
-
-		if (request.getAttribute(name) != null)
-			return REQUEST_SCOPE;
-
-		if (session != null) {
-		    try {
-		        if (session.getAttribute(name) != null)
-		            return SESSION_SCOPE;
-	        } catch(IllegalStateException ise) {
-	            // Session has been invalidated.
-		        // Ignore and fall through to application scope.
-		    }
-		}
-
-		if (context.getAttribute(name) != null)
-			return APPLICATION_SCOPE;
-
-		return 0;
-	}
-
-	@Override
+        if (name == null) {
+            throw new NullPointerException(Localizer
+                    .getMessage("jsp.error.attribute.null_name"));
+        }
+
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            return (AccessController
+                    .doPrivileged(new PrivilegedAction<Integer>() {
+                        public Integer run() {
+                            return new Integer(doGetAttributeScope(name));
+                        }
+                    })).intValue();
+        } else {
+            return doGetAttributeScope(name);
+        }
+    }
+
+    private int doGetAttributeScope(String name) {
+        if (attributes.get(name) != null)
+            return PAGE_SCOPE;
+
+        if (request.getAttribute(name) != null)
+            return REQUEST_SCOPE;
+
+        if (session != null) {
+            try {
+                if (session.getAttribute(name) != null)
+                    return SESSION_SCOPE;
+            } catch(IllegalStateException ise) {
+                // Session has been invalidated.
+                // Ignore and fall through to application scope.
+            }
+        }
+
+        if (context.getAttribute(name) != null)
+            return APPLICATION_SCOPE;
+
+        return 0;
+    }
+
+    @Override
     public Object findAttribute(final String name) {
-		if (SecurityUtil.isPackageProtectionEnabled()) {
-			return AccessController.doPrivileged(
-			        new PrivilegedAction<Object>() {
-				public Object run() {
-					if (name == null) {
-						throw new NullPointerException(Localizer
-								.getMessage("jsp.error.attribute.null_name"));
-					}
-
-					return doFindAttribute(name);
-				}
-			});
-		} else {
-			if (name == null) {
-				throw new NullPointerException(Localizer
-						.getMessage("jsp.error.attribute.null_name"));
-			}
-
-			return doFindAttribute(name);
-		}
-	}
-
-	private Object doFindAttribute(String name) {
-
-		Object o = attributes.get(name);
-		if (o != null)
-			return o;
-
-		o = request.getAttribute(name);
-		if (o != null)
-			return o;
-
-		if (session != null) {
-		    try {
-		        o = session.getAttribute(name);
-		    } catch(IllegalStateException ise) {
-		        // Session has been invalidated.
-		        // Ignore and fall through to application scope.
-	        }
-			if (o != null)
-				return o;
-		}
-
-		return context.getAttribute(name);
-	}
-
-	@Override
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            return AccessController.doPrivileged(
+                    new PrivilegedAction<Object>() {
+                public Object run() {
+                    if (name == null) {
+                        throw new NullPointerException(Localizer
+                                .getMessage("jsp.error.attribute.null_name"));
+                    }
+
+                    return doFindAttribute(name);
+                }
+            });
+        } else {
+            if (name == null) {
+                throw new NullPointerException(Localizer
+                        .getMessage("jsp.error.attribute.null_name"));
+            }
+
+            return doFindAttribute(name);
+        }
+    }
+
+    private Object doFindAttribute(String name) {
+
+        Object o = attributes.get(name);
+        if (o != null)
+            return o;
+
+        o = request.getAttribute(name);
+        if (o != null)
+            return o;
+
+        if (session != null) {
+            try {
+                o = session.getAttribute(name);
+            } catch(IllegalStateException ise) {
+                // Session has been invalidated.
+                // Ignore and fall through to application scope.
+            }
+            if (o != null)
+                return o;
+        }
+
+        return context.getAttribute(name);
+    }
+
+    @Override
     public Enumeration<String> getAttributeNamesInScope(final int scope) {
-		if (SecurityUtil.isPackageProtectionEnabled()) {
-			return AccessController.doPrivileged(
-			        new PrivilegedAction<Enumeration<String>>() {
-						public Enumeration<String> run() {
-							return doGetAttributeNamesInScope(scope);
-						}
-					});
-		} else {
-			return doGetAttributeNamesInScope(scope);
-		}
-	}
-
-	private Enumeration<String> doGetAttributeNamesInScope(int scope) {
-		switch (scope) {
-		case PAGE_SCOPE:
-			return new Enumerator<String>(attributes.keySet().iterator());
-
-		case REQUEST_SCOPE:
-			return request.getAttributeNames();
-
-		case SESSION_SCOPE:
-			if (session == null) {
-				throw new IllegalStateException(Localizer
-						.getMessage("jsp.error.page.noSession"));
-			}
-			return session.getAttributeNames();
-
-		case APPLICATION_SCOPE:
-			return context.getAttributeNames();
-
-		default:
-			throw new IllegalArgumentException("Invalid scope");
-		}
-	}
-
-	@Override
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            return AccessController.doPrivileged(
+                    new PrivilegedAction<Enumeration<String>>() {
+                        public Enumeration<String> run() {
+                            return doGetAttributeNamesInScope(scope);
+                        }
+                    });
+        } else {
+            return doGetAttributeNamesInScope(scope);
+        }
+    }
+
+    private Enumeration<String> doGetAttributeNamesInScope(int scope) {
+        switch (scope) {
+        case PAGE_SCOPE:
+            return new Enumerator<String>(attributes.keySet().iterator());
+
+        case REQUEST_SCOPE:
+            return request.getAttributeNames();
+
+        case SESSION_SCOPE:
+            if (session == null) {
+                throw new IllegalStateException(Localizer
+                        .getMessage("jsp.error.page.noSession"));
+            }
+            return session.getAttributeNames();
+
+        case APPLICATION_SCOPE:
+            return context.getAttributeNames();
+
+        default:
+            throw new IllegalArgumentException("Invalid scope");
+        }
+    }
+
+    @Override
     public void removeAttribute(final String name) {
 
-		if (name == null) {
-			throw new NullPointerException(Localizer
-					.getMessage("jsp.error.attribute.null_name"));
-		}
-
-		if (SecurityUtil.isPackageProtectionEnabled()) {
-			AccessController.doPrivileged(new PrivilegedAction<Void>() {
-				public Void run() {
-					doRemoveAttribute(name);
-					return null;
-				}
-			});
-		} else {
-			doRemoveAttribute(name);
-		}
-	}
-
-	private void doRemoveAttribute(String name) {
-	    removeAttribute(name, PAGE_SCOPE);
-	    removeAttribute(name, REQUEST_SCOPE);
-	    if( session != null ) {
-	        try {
-	            removeAttribute(name, SESSION_SCOPE);
-	        } catch(IllegalStateException ise) {
-	            // Session has been invalidated.
-	            // Ignore and fall throw to application scope.
-	        }
-	    }
-	    removeAttribute(name, APPLICATION_SCOPE);
-	}
-
-	@Override
+        if (name == null) {
+            throw new NullPointerException(Localizer
+                    .getMessage("jsp.error.attribute.null_name"));
+        }
+
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                public Void run() {
+                    doRemoveAttribute(name);
+                    return null;
+                }
+            });
+        } else {
+            doRemoveAttribute(name);
+        }
+    }
+
+    private void doRemoveAttribute(String name) {
+        removeAttribute(name, PAGE_SCOPE);
+        removeAttribute(name, REQUEST_SCOPE);
+        if( session != null ) {
+            try {
+                removeAttribute(name, SESSION_SCOPE);
+            } catch(IllegalStateException ise) {
+                // Session has been invalidated.
+                // Ignore and fall throw to application scope.
+            }
+        }
+        removeAttribute(name, APPLICATION_SCOPE);
+    }
+
+    @Override
     public JspWriter getOut() {
-		return out;
-	}
+        return out;
+    }
 
-	@Override
+    @Override
     public HttpSession getSession() {
-		return session;
-	}
+        return session;
+    }
 
-	public Servlet getServlet() {
-		return servlet;
-	}
+    public Servlet getServlet() {
+        return servlet;
+    }
 
-	@Override
+    @Override
     public ServletConfig getServletConfig() {
-		return config;
-	}
+        return config;
+    }
 
-	@Override
+    @Override
     public ServletContext getServletContext() {
-		return config.getServletContext();
-	}
+        return config.getServletContext();
+    }
 
-	@Override
+    @Override
     public ServletRequest getRequest() {
-		return request;
-	}
+        return request;
+    }
 
-	@Override
+    @Override
     public ServletResponse getResponse() {
-		return response;
-	}
-
-	/**
-	 * Returns the exception associated with this page context, if any. <p/>
-	 * Added wrapping for Throwables to avoid ClassCastException: see Bugzilla
-	 * 31171 for details.
-	 * 
-	 * @return The Exception associated with this page context, if any.
-	 */
-	@Override
+        return response;
+    }
+
+    /**
+     * Returns the exception associated with this page context, if any. <p/>
+     * Added wrapping for Throwables to avoid ClassCastException: see Bugzilla
+     * 31171 for details.
+     * 
+     * @return The Exception associated with this page context, if any.
+     */
+    @Override
     public Exception getException() {
-		Throwable t = JspRuntimeLibrary.getThrowable(request);
+        Throwable t = JspRuntimeLibrary.getThrowable(request);
 
-		// Only wrap if needed
-		if ((t != null) && (!(t instanceof Exception))) {
-			t = new JspException(t);
-		}
+        // Only wrap if needed
+        if ((t != null) && (!(t instanceof Exception))) {
+            t = new JspException(t);
+        }
 
-		return (Exception) t;
-	}
+        return (Exception) t;
+    }
 
-	@Override
+    @Override
     public Object getPage() {
-		return servlet;
-	}
-
-	private final String getAbsolutePathRelativeToContext(String relativeUrlPath) {
-		String path = relativeUrlPath;
-
-		if (!path.startsWith("/")) {
-			String uri = (String) request
-					.getAttribute("javax.servlet.include.servlet_path");
-			if (uri == null)
-				uri = ((HttpServletRequest) request).getServletPath();
-			String baseURI = uri.substring(0, uri.lastIndexOf('/'));
-			path = baseURI + '/' + path;
-		}
+        return servlet;
+    }
+
+    private final String getAbsolutePathRelativeToContext(String relativeUrlPath) {
+        String path = relativeUrlPath;
+
+        if (!path.startsWith("/")) {
+            String uri = (String) request
+                    .getAttribute("javax.servlet.include.servlet_path");
+            if (uri == null)
+                uri = ((HttpServletRequest) request).getServletPath();
+            String baseURI = uri.substring(0, uri.lastIndexOf('/'));
+            path = baseURI + '/' + path;
+        }
 
-		return path;
-	}
+        return path;
+    }
 
-	@Override
+    @Override
     public void include(String relativeUrlPath) throws ServletException,
-			IOException {
-		JspRuntimeLibrary
-				.include(request, response, relativeUrlPath, out, true);
-	}
+            IOException {
+        JspRuntimeLibrary
+                .include(request, response, relativeUrlPath, out, true);
+    }
 
-	@Override
+    @Override
     public void include(final String relativeUrlPath, final boolean flush)
-			throws ServletException, IOException {
-		if (SecurityUtil.isPackageProtectionEnabled()) {
-			try {
-				AccessController.doPrivileged(
-				        new PrivilegedExceptionAction<Void>() {
-					public Void run() throws Exception {
-						doInclude(relativeUrlPath, flush);
-						return null;
-					}
-				});
-			} catch (PrivilegedActionException e) {
-				Exception ex = e.getException();
-				if (ex instanceof IOException) {
-					throw (IOException) ex;
-				} else {
-					throw (ServletException) ex;
-				}
-			}
-		} else {
-			doInclude(relativeUrlPath, flush);
-		}
-	}
-
-	private void doInclude(String relativeUrlPath, boolean flush)
-			throws ServletException, IOException {
-		JspRuntimeLibrary.include(request, response, relativeUrlPath, out,
-				flush);
-	}
-
-	@Override
-	@Deprecated
+            throws ServletException, IOException {
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            try {
+                AccessController.doPrivileged(
+                        new PrivilegedExceptionAction<Void>() {
+                    public Void run() throws Exception {
+                        doInclude(relativeUrlPath, flush);
+                        return null;
+                    }
+                });
+            } catch (PrivilegedActionException e) {
+                Exception ex = e.getException();
+                if (ex instanceof IOException) {
+                    throw (IOException) ex;
+                } else {
+                    throw (ServletException) ex;
+                }
+            }
+        } else {
+            doInclude(relativeUrlPath, flush);
+        }
+    }
+
+    private void doInclude(String relativeUrlPath, boolean flush)
+            throws ServletException, IOException {
+        JspRuntimeLibrary.include(request, response, relativeUrlPath, out,
+                flush);
+    }
+
+    @Override
+    @Deprecated
     public VariableResolver getVariableResolver() {
-		return new VariableResolverImpl(this.getELContext());
-	}
+        return new VariableResolverImpl(this.getELContext());
+    }
 
-	@Override
+    @Override
     public void forward(final String relativeUrlPath) throws ServletException,
-			IOException {
-		if (SecurityUtil.isPackageProtectionEnabled()) {
-			try {
-				AccessController.doPrivileged(
-				        new PrivilegedExceptionAction<Void>() {
-					public Void run() throws Exception {
-						doForward(relativeUrlPath);
-						return null;
-					}
-				});
-			} catch (PrivilegedActionException e) {
-				Exception ex = e.getException();
-				if (ex instanceof IOException) {
-					throw (IOException) ex;
-				} else {
-					throw (ServletException) ex;
-				}
-			}
-		} else {
-			doForward(relativeUrlPath);
-		}
-	}
-
-	private void doForward(String relativeUrlPath) throws ServletException,
-			IOException {
-
-		// JSP.4.5 If the buffer was flushed, throw IllegalStateException
-		try {
-			out.clear();
-		} catch (IOException ex) {
-			IllegalStateException ise = new IllegalStateException(Localizer
-					.getMessage("jsp.error.attempt_to_clear_flushed_buffer"));
-			ise.initCause(ex);
-			throw ise;
-		}
-
-		// Make sure that the response object is not the wrapper for include
-		while (response instanceof ServletResponseWrapperInclude) {
-			response = ((ServletResponseWrapperInclude) response).getResponse();
-		}
-
-		final String path = getAbsolutePathRelativeToContext(relativeUrlPath);
-		String includeUri = (String) request
-				.getAttribute(Constants.INC_SERVLET_PATH);
-
-		if (includeUri != null)
-			request.removeAttribute(Constants.INC_SERVLET_PATH);
-		try {
-			context.getRequestDispatcher(path).forward(request, response);
-		} finally {
-			if (includeUri != null)
-				request.setAttribute(Constants.INC_SERVLET_PATH, includeUri);
-		}
-	}
-
-	@Override
+            IOException {
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            try {
+                AccessController.doPrivileged(
+                        new PrivilegedExceptionAction<Void>() {
+                    public Void run() throws Exception {
+                        doForward(relativeUrlPath);
+                        return null;
+                    }
+                });
+            } catch (PrivilegedActionException e) {
+                Exception ex = e.getException();
+                if (ex instanceof IOException) {
+                    throw (IOException) ex;
+                } else {
+                    throw (ServletException) ex;
+                }
+            }
+        } else {
+            doForward(relativeUrlPath);
+        }
+    }
+
+    private void doForward(String relativeUrlPath) throws ServletException,
+            IOException {
+
+        // JSP.4.5 If the buffer was flushed, throw IllegalStateException
+        try {
+            out.clear();
+        } catch (IOException ex) {
+            IllegalStateException ise = new IllegalStateException(Localizer
+                    .getMessage("jsp.error.attempt_to_clear_flushed_buffer"));
+            ise.initCause(ex);
+            throw ise;
+        }
+
+        // Make sure that the response object is not the wrapper for include
+        while (response instanceof ServletResponseWrapperInclude) {
+            response = ((ServletResponseWrapperInclude) response).getResponse();
+        }
+
+        final String path = getAbsolutePathRelativeToContext(relativeUrlPath);
+        String includeUri = (String) request
+                .getAttribute(Constants.INC_SERVLET_PATH);
+
+        if (includeUri != null)
+            request.removeAttribute(Constants.INC_SERVLET_PATH);
+        try {
+            context.getRequestDispatcher(path).forward(request, response);
+        } finally {
+            if (includeUri != null)
+                request.setAttribute(Constants.INC_SERVLET_PATH, includeUri);
+        }
+    }
+
+    @Override
     public BodyContent pushBody() {
-		return (BodyContent) pushBody(null);
-	}
+        return (BodyContent) pushBody(null);
+    }
 
-	@Override
+    @Override
     public JspWriter pushBody(Writer writer) {
-		depth++;
-		if (depth >= outs.length) {
-			BodyContentImpl[] newOuts = new BodyContentImpl[depth + 1];
-			for (int i = 0; i < outs.length; i++) {
-				newOuts[i] = outs[i];
-			}
-			newOuts[depth] = new BodyContentImpl(out);
-			outs = newOuts;
-		}
-
-		outs[depth].setWriter(writer);
-		out = outs[depth];
-
-		// Update the value of the "out" attribute in the page scope
-		// attribute namespace of this PageContext
-		setAttribute(OUT, out);
-
-		return outs[depth];
-	}
-
-	@Override
+        depth++;
+        if (depth >= outs.length) {
+            BodyContentImpl[] newOuts = new BodyContentImpl[depth + 1];
+            for (int i = 0; i < outs.length; i++) {
+                newOuts[i] = outs[i];
+            }
+            newOuts[depth] = new BodyContentImpl(out);
+            outs = newOuts;
+        }
+
+        outs[depth].setWriter(writer);
+        out = outs[depth];
+
+        // Update the value of the "out" attribute in the page scope
+        // attribute namespace of this PageContext
+        setAttribute(OUT, out);
+
+        return outs[depth];
+    }
+
+    @Override
     public JspWriter popBody() {
-		depth--;
-		if (depth >= 0) {
-			out = outs[depth];
-		} else {
-			out = baseOut;
-		}
-
-		// Update the value of the "out" attribute in the page scope
-		// attribute namespace of this PageContext
-		setAttribute(OUT, out);
-
-		return out;
-	}
-
-	/**
-	 * Provides programmatic access to the ExpressionEvaluator. The JSP
-	 * Container must return a valid instance of an ExpressionEvaluator that can
-	 * parse EL expressions.
-	 */
-	@Override
-	@Deprecated
+        depth--;
+        if (depth >= 0) {
+            out = outs[depth];
+        } else {
+            out = baseOut;
+        }
+
+        // Update the value of the "out" attribute in the page scope
+        // attribute namespace of this PageContext
+        setAttribute(OUT, out);
+
+        return out;
+    }
+
+    /**
+     * Provides programmatic access to the ExpressionEvaluator. The JSP
+     * Container must return a valid instance of an ExpressionEvaluator that can
+     * parse EL expressions.
+     */
+    @Override
+    @Deprecated
     public ExpressionEvaluator getExpressionEvaluator() {
-		return new ExpressionEvaluatorImpl(this.applicationContext.getExpressionFactory());
-	}
+        return new ExpressionEvaluatorImpl(this.applicationContext.getExpressionFactory());
+    }
 
-	@Override
+    @Override
     public void handlePageException(Exception ex) throws IOException,
-			ServletException {
-		// Should never be called since handleException() called with a
-		// Throwable in the generated servlet.
-		handlePageException((Throwable) ex);
-	}
+            ServletException {
+        // Should never be called since handleException() called with a
+        // Throwable in the generated servlet.
+        handlePageException((Throwable) ex);
+    }
 
-	@Override
+    @Override
     public void handlePageException(final Throwable t) throws IOException,
-			ServletException {
-		if (t == null)
-			throw new NullPointerException("null Throwable");
-
-		if (SecurityUtil.isPackageProtectionEnabled()) {
-			try {
-				AccessController.doPrivileged(
-				        new PrivilegedExceptionAction<Void>() {
-					public Void run() throws Exception {
-						doHandlePageException(t);
-						return null;
-					}
-				});
-			} catch (PrivilegedActionException e) {
-				Exception ex = e.getException();
-				if (ex instanceof IOException) {
-					throw (IOException) ex;
-				} else {
-					throw (ServletException) ex;
-				}
-			}
-		} else {
-			doHandlePageException(t);
-		}
-
-	}
-
-	private void doHandlePageException(Throwable t) throws IOException,
-			ServletException {
-
-		if (errorPageURL != null && !errorPageURL.equals("")) {
-
-			/*
-			 * Set request attributes. Do not set the
-			 * javax.servlet.error.exception attribute here (instead, set in the
-			 * generated servlet code for the error page) in order to prevent
-			 * the ErrorReportValve, which is invoked as part of forwarding the
-			 * request to the error page, from throwing it if the response has
-			 * not been committed (the response will have been committed if the
-			 * error page is a JSP page).
-			 */
-			request.setAttribute("javax.servlet.jsp.jspException", t);
-			request.setAttribute("javax.servlet.error.status_code",
-					new Integer(HttpServletResponse.SC_INTERNAL_SERVER_ERROR));
-			request.setAttribute("javax.servlet.error.request_uri",
-					((HttpServletRequest) request).getRequestURI());
-			request.setAttribute("javax.servlet.error.servlet_name", config
-					.getServletName());
-			try {
-				forward(errorPageURL);
-			} catch (IllegalStateException ise) {
-				include(errorPageURL);
-			}
-
-			// The error page could be inside an include.
-
-			Object newException = request
-					.getAttribute("javax.servlet.error.exception");
-
-			// t==null means the attribute was not set.
-			if ((newException != null) && (newException == t)) {
-				request.removeAttribute("javax.servlet.error.exception");
-			}
-
-			// now clear the error code - to prevent double handling.
-			request.removeAttribute("javax.servlet.error.status_code");
-			request.removeAttribute("javax.servlet.error.request_uri");
-			request.removeAttribute("javax.servlet.error.status_code");
-			request.removeAttribute("javax.servlet.jsp.jspException");
-
-		} else {
-			// Otherwise throw the exception wrapped inside a ServletException.
-			// Set the exception as the root cause in the ServletException
-			// to get a stack trace for the real problem
-			if (t instanceof IOException)
-				throw (IOException) t;
-			if (t instanceof ServletException)
-				throw (ServletException) t;
-			if (t instanceof RuntimeException)
-				throw (RuntimeException) t;
-
-			Throwable rootCause = null;
-			if (t instanceof JspException) {
-				rootCause = ((JspException) t).getCause();
-			} else if (t instanceof ELException) {
-				rootCause = ((ELException) t).getCause();
-			}
-
-			if (rootCause != null) {
-				throw new ServletException(t.getClass().getName() + ": "
-						+ t.getMessage(), rootCause);
-			}
-
-			throw new ServletException(t);
-		}
-	}
-
-	private static String XmlEscape(String s) {
-		if (s == null)
-			return null;
-		StringBuilder sb = new StringBuilder();
-		for (int i = 0; i < s.length(); i++) {
-			char c = s.charAt(i);
-			if (c == '<') {
-				sb.append("&lt;");
-			} else if (c == '>') {
-				sb.append("&gt;");
-			} else if (c == '\'') {
-				sb.append("&#039;"); // &apos;
-			} else if (c == '&') {
-				sb.append("&amp;");
-			} else if (c == '"') {
-				sb.append("&#034;"); // &quot;
-			} else {
-				sb.append(c);
-			}
-		}
-		return sb.toString();
-	}
-
-	/**
-	 * Proprietary method to evaluate EL expressions. XXX - This method should
-	 * go away once the EL interpreter moves out of JSTL and into its own
-	 * project. For now, this is necessary because the standard machinery is too
-	 * slow.
-	 * 
-	 * @param expression
-	 *            The expression to be evaluated
-	 * @param expectedType
-	 *            The expected resulting type
-	 * @param pageContext
-	 *            The page context
-	 * @param functionMap
-	 *            Maps prefix and name to Method
-	 * @return The result of the evaluation
-	 */
-	public static Object proprietaryEvaluate(final String expression,
-			final Class<?> expectedType, final PageContext pageContext,
-			final ProtectedFunctionMapper functionMap, final boolean escape)
-			throws ELException {
-		Object retValue;
+            ServletException {
+        if (t == null)
+            throw new NullPointerException("null Throwable");
+
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            try {
+                AccessController.doPrivileged(
+                        new PrivilegedExceptionAction<Void>() {
+                    public Void run() throws Exception {
+                        doHandlePageException(t);
+                        return null;
+                    }
+                });
+            } catch (PrivilegedActionException e) {
+                Exception ex = e.getException();
+                if (ex instanceof IOException) {
+                    throw (IOException) ex;
+                } else {
+                    throw (ServletException) ex;
+                }
+            }
+        } else {
+            doHandlePageException(t);
+        }
+
+    }
+
+    private void doHandlePageException(Throwable t) throws IOException,
+            ServletException {
+
+        if (errorPageURL != null && !errorPageURL.equals("")) {
+
+            /*
+             * Set request attributes. Do not set the
+             * javax.servlet.error.exception attribute here (instead, set in the
+             * generated servlet code for the error page) in order to prevent
+             * the ErrorReportValve, which is invoked as part of forwarding the
+             * request to the error page, from throwing it if the response has
+             * not been committed (the response will have been committed if the
+             * error page is a JSP page).
+             */
+            request.setAttribute("javax.servlet.jsp.jspException", t);
+            request.setAttribute("javax.servlet.error.status_code",
+                    new Integer(HttpServletResponse.SC_INTERNAL_SERVER_ERROR));
+            request.setAttribute("javax.servlet.error.request_uri",
+                    ((HttpServletRequest) request).getRequestURI());
+            request.setAttribute("javax.servlet.error.servlet_name", config
+                    .getServletName());
+            try {
+                forward(errorPageURL);
+            } catch (IllegalStateException ise) {
+                include(errorPageURL);
+            }
+
+            // The error page could be inside an include.
+
+            Object newException = request
+                    .getAttribute("javax.servlet.error.exception");
+
+            // t==null means the attribute was not set.
+            if ((newException != null) && (newException == t)) {
+                request.removeAttribute("javax.servlet.error.exception");
+            }
+
+            // now clear the error code - to prevent double handling.
+            request.removeAttribute("javax.servlet.error.status_code");
+            request.removeAttribute("javax.servlet.error.request_uri");
+            request.removeAttribute("javax.servlet.error.status_code");
+            request.removeAttribute("javax.servlet.jsp.jspException");
+
+        } else {
+            // Otherwise throw the exception wrapped inside a ServletException.
+            // Set the exception as the root cause in the ServletException
+            // to get a stack trace for the real problem
+            if (t instanceof IOException)
+                throw (IOException) t;
+            if (t instanceof ServletException)
+                throw (ServletException) t;
+            if (t instanceof RuntimeException)
+                throw (RuntimeException) t;
+
+            Throwable rootCause = null;
+            if (t instanceof JspException) {
+                rootCause = ((JspException) t).getCause();
+            } else if (t instanceof ELException) {
+                rootCause = ((ELException) t).getCause();
+            }
+
+            if (rootCause != null) {
+                throw new ServletException(t.getClass().getName() + ": "
+                        + t.getMessage(), rootCause);
+            }
+
+            throw new ServletException(t);
+        }
+    }
+
+    private static String XmlEscape(String s) {
+        if (s == null)
+            return null;
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < s.length(); i++) {
+            char c = s.charAt(i);
+            if (c == '<') {
+                sb.append("&lt;");
+            } else if (c == '>') {
+                sb.append("&gt;");
+            } else if (c == '\'') {
+                sb.append("&#039;"); // &apos;
+            } else if (c == '&') {
+                sb.append("&amp;");
+            } else if (c == '"') {
+                sb.append("&#034;"); // &quot;
+            } else {
+                sb.append(c);
+            }
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Proprietary method to evaluate EL expressions. XXX - This method should
+     * go away once the EL interpreter moves out of JSTL and into its own
+     * project. For now, this is necessary because the standard machinery is too
+     * slow.
+     * 
+     * @param expression
+     *            The expression to be evaluated
+     * @param expectedType
+     *            The expected resulting type
+     * @param pageContext
+     *            The page context
+     * @param functionMap
+     *            Maps prefix and name to Method
+     * @return The result of the evaluation
+     */
+    public static Object proprietaryEvaluate(final String expression,
+            final Class<?> expectedType, final PageContext pageContext,
+            final ProtectedFunctionMapper functionMap, final boolean escape)
+            throws ELException {
+        Object retValue;
         final ExpressionFactory exprFactory = jspf.getJspApplicationContext(pageContext.getServletContext()).getExpressionFactory();
-		if (SecurityUtil.isPackageProtectionEnabled()) {
-			try {
-				retValue = AccessController
-						.doPrivileged(new PrivilegedExceptionAction<Object>() {
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            try {
+                retValue = AccessController
+                        .doPrivileged(new PrivilegedExceptionAction<Object>() {
 
-							public Object run() throws Exception {
+                            public Object run() throws Exception {
                                 ELContextImpl ctx = (ELContextImpl) pageContext.getELContext();
                                 ctx.setFunctionMapper(new FunctionMapperImpl(functionMap));
-								ValueExpression ve = exprFactory.createValueExpression(ctx, expression, expectedType);
+                                ValueExpression ve = exprFactory.createValueExpression(ctx, expression, expectedType);
                                 return ve.getValue(ctx);
-							}
-						});
-			} catch (PrivilegedActionException ex) {
-				Exception realEx = ex.getException();
-				if (realEx instanceof ELException) {
-					throw (ELException) realEx;
-				} else {
-					throw new ELException(realEx);
-				}
-			}
-		} else {
+                            }
+                        });
+            } catch (PrivilegedActionException ex) {
+                Exception realEx = ex.getException();
+                if (realEx instanceof ELException) {
+                    throw (ELException) realEx;
+                } else {
+                    throw new ELException(realEx);
+                }
+            }
+        } else {
             ELContextImpl ctx = (ELContextImpl) pageContext.getELContext();
             ctx.setFunctionMapper(new FunctionMapperImpl(functionMap));
             ValueExpression ve = exprFactory.createValueExpression(ctx, expression, expectedType);
             retValue = ve.getValue(ctx);
-		}
-		if (escape && retValue != null) {
-			retValue = XmlEscape(retValue.toString());
-		}
+        }
+        if (escape && retValue != null) {
+            retValue = XmlEscape(retValue.toString());
+        }
 
-		return retValue;
-	}
+        return retValue;
+    }
 
-	@Override
+    @Override
     public ELContext getELContext() {
-		if (this.elContext == null) {
-			this.elContext = this.applicationContext.createELContext(this);
-		}
-		return this.elContext;
-	}
+        if (this.elContext == null) {
+            this.elContext = this.applicationContext.createELContext(this);
+        }
+        return this.elContext;
+    }
 
 }

==================================================
ServletResponseWrapperInclude.java
index 7e363e8829..4ce4684a72 100644
--- a/java/org/apache/jasper/runtime/PerThreadTagHandlerPool.java
+++ b/java/org/apache/jasper/runtime/PerThreadTagHandlerPool.java
@@ -93,12 +93,12 @@ public class PerThreadTagHandlerPool extends TagHandlerPool {
         if(ptd.current >=0 ) {
             return ptd.handlers[ptd.current--];
         } else {
-	    try {
-		return handlerClass.newInstance();
-	    } catch (Exception e) {
-		throw new JspException(e.getMessage(), e);
-	    }
-	}
+            try {
+                return handlerClass.newInstance();
+            } catch (Exception e) {
+                throw new JspException(e.getMessage(), e);
+            }
+        }
     }
 
     /**
@@ -111,8 +111,8 @@ public class PerThreadTagHandlerPool extends TagHandlerPool {
     @Override
     public void reuse(Tag handler) {
         PerThreadData ptd = perThread.get();
-	if (ptd.current < (ptd.handlers.length - 1)) {
-	    ptd.handlers[++ptd.current] = handler;
+        if (ptd.current < (ptd.handlers.length - 1)) {
+            ptd.handlers[++ptd.current] = handler;
         } else {
             handler.release();
         }
@@ -125,12 +125,12 @@ public class PerThreadTagHandlerPool extends TagHandlerPool {
     public void release() {        
         Enumeration<PerThreadData> enumeration = perThreadDataVector.elements();
         while (enumeration.hasMoreElements()) {
-	    PerThreadData ptd = enumeration.nextElement();
+            PerThreadData ptd = enumeration.nextElement();
             if (ptd.handlers != null) {
                 for (int i=ptd.current; i>=0; i--) {
                     if (ptd.handlers[i] != null) {
                         ptd.handlers[i].release();
-		    }
+                    }
                 }
             }
         }

==================================================
TagHandlerPool.java
index 85725ee1c7..0fa695dcc3 100644
--- a/java/org/apache/jasper/runtime/ServletResponseWrapperInclude.java
+++ b/java/org/apache/jasper/runtime/ServletResponseWrapperInclude.java
@@ -46,10 +46,10 @@ public class ServletResponseWrapperInclude extends HttpServletResponseWrapper {
     private JspWriter jspWriter;
 
     public ServletResponseWrapperInclude(ServletResponse response, 
-					 JspWriter jspWriter) {
-	super((HttpServletResponse)response);
-	this.printWriter = new PrintWriter(jspWriter);
-	this.jspWriter = jspWriter;
+                                         JspWriter jspWriter) {
+        super((HttpServletResponse)response);
+        this.printWriter = new PrintWriter(jspWriter);
+        this.jspWriter = jspWriter;
     }
 
     /**
@@ -57,12 +57,12 @@ public class ServletResponseWrapperInclude extends HttpServletResponseWrapper {
      */
     @Override
     public PrintWriter getWriter() throws IOException {
-	return printWriter;
+        return printWriter;
     }
 
     @Override
     public ServletOutputStream getOutputStream() throws IOException {
-	throw new IllegalStateException();
+        throw new IllegalStateException();
     }
 
     /**
@@ -71,9 +71,9 @@ public class ServletResponseWrapperInclude extends HttpServletResponseWrapper {
      */
     @Override
     public void resetBuffer() {
-	try {
-	    jspWriter.clearBuffer();
-	} catch (IOException ioe) {
-	}
+        try {
+            jspWriter.clearBuffer();
+        } catch (IOException ioe) {
+        }
     }
 }

==================================================
JspServlet.java
index 2f5c27ba4e..3c7aafb387 100644
--- a/java/org/apache/jasper/runtime/TagHandlerPool.java
+++ b/java/org/apache/jasper/runtime/TagHandlerPool.java
@@ -85,7 +85,7 @@ public class TagHandlerPool {
      * Constructs a tag handler pool with the default capacity.
      */
     public TagHandlerPool() {
-	// Nothing - jasper generated servlets call the other constructor,
+        // Nothing - jasper generated servlets call the other constructor,
         // this should be used in future + init .
     }
 
@@ -100,7 +100,7 @@ public class TagHandlerPool {
      * @throws JspException if a tag handler cannot be instantiated
      */
     public Tag get(Class<? extends Tag> handlerClass) throws JspException {
-    	Tag handler;
+        Tag handler;
         synchronized( this ) {
             if (current >= 0) {
                 handler = handlers[current--];
@@ -111,13 +111,13 @@ public class TagHandlerPool {
         // Out of sync block - there is no need for other threads to
         // wait for us to construct a tag for this thread.
         try {
-        	if (Constants.USE_INSTANCE_MANAGER_FOR_TAGS) {
-        		return (Tag) instanceManager.newInstance(handlerClass.getName(), handlerClass.getClassLoader());
-        	} else {
+            if (Constants.USE_INSTANCE_MANAGER_FOR_TAGS) {
+                return (Tag) instanceManager.newInstance(handlerClass.getName(), handlerClass.getClassLoader());
+            } else {
                 Tag instance = handlerClass.newInstance();
                 instanceManager.newInstance(instance);
                 return instance;
-        	}
+            }
         } catch (Exception e) {
             throw new JspException(e.getMessage(), e);
         }

==================================================
Util.java
index 95d9e76787..7c5b696ae3 100644
--- a/java/org/apache/jasper/servlet/JspServlet.java
+++ b/java/org/apache/jasper/servlet/JspServlet.java
@@ -194,11 +194,11 @@ public class JspServlet extends HttpServlet implements PeriodicEventListener {
         if (value.equals("true")) {
             return (true);             // ?jsp_precompile=true
         } else if (value.equals("false")) {
-	    // Spec says if jsp_precompile=false, the request should not
-	    // be delivered to the JSP page; the easiest way to implement
-	    // this is to set the flag to true, and precompile the page anyway.
-	    // This still conforms to the spec, since it says the
-	    // precompilation request can be ignored.
+            // Spec says if jsp_precompile=false, the request should not
+            // be delivered to the JSP page; the easiest way to implement
+            // this is to set the flag to true, and precompile the page anyway.
+            // This still conforms to the spec, since it says the
+            // precompilation request can be ignored.
             return (true);             // ?jsp_precompile=false
         } else {
             throw new ServletException("Cannot have request parameter " +
@@ -211,7 +211,7 @@ public class JspServlet extends HttpServlet implements PeriodicEventListener {
 
     @Override
     public void service (HttpServletRequest request, 
-    			 HttpServletResponse response)
+                             HttpServletResponse response)
                 throws ServletException, IOException {
 
         String jspUri = null;
@@ -228,7 +228,7 @@ public class JspServlet extends HttpServlet implements PeriodicEventListener {
             jspUri = (String) request.getAttribute(Constants.INC_SERVLET_PATH);
             if (jspUri != null) {
                 /*
-		 * Requested JSP has been target of
+                 * Requested JSP has been target of
                  * RequestDispatcher.include(). Its path is assembled from the
                  * relevant javax.servlet.include.* request attributes
                  */
@@ -251,7 +251,7 @@ public class JspServlet extends HttpServlet implements PeriodicEventListener {
             }
         }
 
-        if (log.isDebugEnabled()) {	    
+        if (log.isDebugEnabled()) {    
             log.debug("JspEngine --> " + jspUri);
             log.debug("\t     ServletPath: " + request.getServletPath());
             log.debug("\t        PathInfo: " + request.getPathInfo());

==================================================
ForEach.java
index bf6b2e58c5..4b034e2d81 100644
--- a/java/org/apache/jasper/tagplugins/jstl/Util.java
+++ b/java/org/apache/jasper/tagplugins/jstl/Util.java
@@ -156,7 +156,7 @@ public class Util {
             int sessionEnd = u.toString().indexOf(";", sessionStart + 1);
             if (sessionEnd == -1)
                 sessionEnd = u.toString().indexOf("?", sessionStart + 1);
-            if (sessionEnd == -1) 				// still
+            if (sessionEnd == -1) // still
                 sessionEnd = u.length();
             u.delete(sessionStart, sessionEnd);
         }
@@ -328,7 +328,7 @@ public class Util {
                 else
                     return bos.toString("ISO-8859-1");
             } else
-                return "";		// target didn't write anything
+                return ""; // target didn't write anything
         }
     }
     

==================================================
Param.java
index 49c9a3fcda..e5bab629cd 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/ForEach.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/ForEach.java
@@ -193,7 +193,7 @@ public final class ForEach implements TagPlugin {
             }
             ctxt.generateJavaSource("break;");
         }
-        ctxt.generateJavaSource("}");	// while
+        ctxt.generateJavaSource("}"); // while
     }
     
     /**

==================================================
ASCIIReader.java
index 42256b8693..1ba85ce757 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Param.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Param.java
@@ -72,6 +72,6 @@ public class Param implements TagPlugin {
         ctxt.generateJavaSource("        " + urlName + " = " + urlName + " + \"&\" + " + nameName + " + \"=\" + " + valueName + ";");
         ctxt.generateJavaSource("    }");
         ctxt.generateJavaSource("    pageContext.setAttribute(\"url_without_param\"," + urlName + ");");
-        ctxt.generateJavaSource("}");	
+        ctxt.generateJavaSource("}");
     }
 }

==================================================
EncodingMap.java
index 3c145bd71f..acb4c14af6 100644
--- a/java/org/apache/jasper/xmlparser/ASCIIReader.java
+++ b/java/org/apache/jasper/xmlparser/ASCIIReader.java
@@ -88,7 +88,7 @@ public class ASCIIReader
         int b0 = fInputStream.read();
         if (b0 > 0x80) {
             throw new IOException(Localizer.getMessage("jsp.error.xml.invalidASCII",
-						       Integer.toString(b0)));
+                                                       Integer.toString(b0)));
         }
         return b0;
     } // read():int
@@ -117,7 +117,7 @@ public class ASCIIReader
             int b0 = (0xff & fBuffer[i]); // Convert to unsigned
             if (b0 > 0x80) {
                 throw new IOException(Localizer.getMessage("jsp.error.xml.invalidASCII",
-							   Integer.toString(b0)));
+                                                           Integer.toString(b0)));
             }
             ch[offset + i] = (char)b0;
         }
@@ -150,7 +150,7 @@ public class ASCIIReader
      */
     @Override
     public boolean ready() throws IOException {
-	return false;
+        return false;
     } // ready()
 
     /**
@@ -158,7 +158,7 @@ public class ASCIIReader
      */
     @Override
     public boolean markSupported() {
-	return fInputStream.markSupported();
+        return fInputStream.markSupported();
     } // markSupported()
 
     /**
@@ -176,7 +176,7 @@ public class ASCIIReader
      */
     @Override
     public void mark(int readAheadLimit) throws IOException {
-	fInputStream.mark(readAheadLimit);
+        fInputStream.mark(readAheadLimit);
     } // mark(int)
 
     /**

==================================================
ParserUtils.java
index 367fb540b7..268e398da5 100644
--- a/java/org/apache/jasper/xmlparser/EncodingMap.java
+++ b/java/org/apache/jasper/xmlparser/EncodingMap.java
@@ -705,7 +705,7 @@ public class EncodingMap {
         fIANA2JavaMap.put("WINDOWS-31J",       "MS932");
         fIANA2JavaMap.put("CSWINDOWS31J",       "MS932");
 
-	    // Add support for Cp1252 and its friends
+        // Add support for Cp1252 and its friends
         fIANA2JavaMap.put("WINDOWS-1250",   "Cp1250");
         fIANA2JavaMap.put("WINDOWS-1251",   "Cp1251");
         fIANA2JavaMap.put("WINDOWS-1252",   "Cp1252");

==================================================
UCSReader.java
index f7688d3327..2bab0180fd 100644
--- a/java/org/apache/jasper/xmlparser/ParserUtils.java
+++ b/java/org/apache/jasper/xmlparser/ParserUtils.java
@@ -94,23 +94,23 @@ public class ParserUtils {
             builder.setEntityResolver(entityResolver);
             builder.setErrorHandler(errorHandler);
             document = builder.parse(is);
-	} catch (ParserConfigurationException ex) {
+        } catch (ParserConfigurationException ex) {
             throw new JasperException
                 (Localizer.getMessage("jsp.error.parse.xml", location), ex);
-	} catch (SAXParseException ex) {
+        } catch (SAXParseException ex) {
             throw new JasperException
                 (Localizer.getMessage("jsp.error.parse.xml.line",
-				      location,
-				      Integer.toString(ex.getLineNumber()),
-				      Integer.toString(ex.getColumnNumber())),
-		 ex);
-	} catch (SAXException sx) {
+                                      location,
+                                      Integer.toString(ex.getLineNumber()),
+                                      Integer.toString(ex.getColumnNumber())),
+                 ex);
+        } catch (SAXException sx) {
             throw new JasperException
                 (Localizer.getMessage("jsp.error.parse.xml", location), sx);
         } catch (IOException io) {
             throw new JasperException
                 (Localizer.getMessage("jsp.error.parse.xml", location), io);
-	}
+        }
 
         // Convert the resulting document to a graph of TreeNodes
         return (convert(null, document.getDocumentElement()));

==================================================
UTF8Reader.java
index d0de96528e..2f483aa66a 100644
--- a/java/org/apache/jasper/xmlparser/UCSReader.java
+++ b/java/org/apache/jasper/xmlparser/UCSReader.java
@@ -247,7 +247,7 @@ public class UCSReader extends Reader {
      */
     @Override
     public boolean ready() throws IOException {
-	return false;
+        return false;
     } // ready()
 
     /**
@@ -255,7 +255,7 @@ public class UCSReader extends Reader {
      */
     @Override
     public boolean markSupported() {
-	return fInputStream.markSupported();
+        return fInputStream.markSupported();
     } // markSupported()
 
     /**
@@ -273,7 +273,7 @@ public class UCSReader extends Reader {
      */
     @Override
     public void mark(int readAheadLimit) throws IOException {
-	fInputStream.mark(readAheadLimit);
+        fInputStream.mark(readAheadLimit);
     } // mark(int)
 
     /**

==================================================
XMLEncodingDetector.java
index d68b9f1e1a..30e7415095 100644
--- a/java/org/apache/jasper/xmlparser/UTF8Reader.java
+++ b/java/org/apache/jasper/xmlparser/UTF8Reader.java
@@ -545,7 +545,7 @@ public class UTF8Reader
      */
     @Override
     public boolean ready() throws IOException {
-	    return false;
+        return false;
     } // ready()
 
     /**
@@ -553,7 +553,7 @@ public class UTF8Reader
      */
     @Override
     public boolean markSupported() {
-	    return false;
+        return false;
     } // markSupported()
 
     /**
@@ -571,9 +571,9 @@ public class UTF8Reader
      */
     @Override
     public void mark(int readAheadLimit) throws IOException {
-	throw new IOException(
+        throw new IOException(
                 Localizer.getMessage("jsp.error.xml.operationNotSupported",
-				     "mark()", "UTF-8"));
+                                     "mark()", "UTF-8"));
     }
 
     /**
@@ -617,8 +617,8 @@ public class UTF8Reader
 
         throw new UTFDataFormatException(
                 Localizer.getMessage("jsp.error.xml.expectedByte",
-				     Integer.toString(position),
-				     Integer.toString(count)));
+                                     Integer.toString(position),
+                                     Integer.toString(count)));
 
     }
 
@@ -628,8 +628,8 @@ public class UTF8Reader
 
         throw new UTFDataFormatException(
                 Localizer.getMessage("jsp.error.xml.invalidByte",
-				     Integer.toString(position),
-				     Integer.toString(count)));
+                                     Integer.toString(position),
+                                     Integer.toString(count)));
     }
 
     /** Throws an exception for invalid surrogate bits. */
@@ -637,7 +637,7 @@ public class UTF8Reader
         
         throw new UTFDataFormatException(
                 Localizer.getMessage("jsp.error.xml.invalidHighSurrogate",
-				     Integer.toHexString(uuuuu)));
+                                     Integer.toHexString(uuuuu)));
     }
 
 } // class UTF8Reader

==================================================
