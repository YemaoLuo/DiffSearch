47bca26d50ca9a36f898665675c99281264b8295
==================================================
Fix a couple of issues identified when testing the latest code with the nonblocking/bytecounter example.
==================================================
Mark Thomas
==================================================
Wed Oct 21 12:33:04 2015 +0000
==================================================
Stream.java
index 98186e97d8..ca38f6f56e 100644
--- a/java/org/apache/coyote/http2/LocalStrings.properties
+++ b/java/org/apache/coyote/http2/LocalStrings.properties
@@ -72,6 +72,11 @@ stream.reset.debug=Connection [{0}], Stream [{1}], Reset due to [{2}]
 stream.reset.fail=Connection [{0}], Stream [{1}], Failed to reset stream
 stream.write=Connection [{0}], Stream [{1}]
 
+stream.inputBuffer.copy=Copying [{0}] bytes from inBuffer to outBuffer
+stream.inputBuffer.dispatch=Data added to inBuffer when read interest is registered. Triggering a read dispatch
+stream.inputBuffer.empty=The Stream input buffer is empty. Waiting for more data
+stream.inputBuffer.signal=Data added to inBuffer when read thread is waiting. Signalling that thread to continue
+
 stream.outputBuffer.flush.debug=Connection [{0}], Stream [{1}], flushing output with buffer at position [{2}], writeInProgress [{3}] and closed [{4}]
 
 streamProcessor.error.connection=Connection [{0}], Stream [{1}], An error occurred during processing that was fatal to the connection

==================================================
StreamProcessor.java
index 7b3c1456b5..55125cf2d6 100644
--- a/java/org/apache/coyote/http2/Stream.java
+++ b/java/org/apache/coyote/http2/Stream.java
@@ -21,7 +21,6 @@ import java.nio.ByteBuffer;
 import java.util.Iterator;
 
 import org.apache.coyote.ActionCode;
-import org.apache.coyote.ContainerThreadMarker;
 import org.apache.coyote.InputBuffer;
 import org.apache.coyote.OutputBuffer;
 import org.apache.coyote.Request;
@@ -563,6 +562,9 @@ public class Stream extends AbstractStream implements HeaderEmitter {
                 while (inBuffer.position() == 0 && !isInputFinished()) {
                     // Need to block until some data is written
                     try {
+                        if (log.isDebugEnabled()) {
+                            log.debug(sm.getString("stream.inputBuffer.empty"));
+                        }
                         inBuffer.wait();
                     } catch (InterruptedException e) {
                         // Possible shutdown / rst or similar. Use an
@@ -573,9 +575,14 @@ public class Stream extends AbstractStream implements HeaderEmitter {
                 }
 
                 if (inBuffer.position() > 0) {
-                    // Data remains in the in buffer. Copy it to the out buffer.
+                    // Data is available in the inBuffer. Copy it to the
+                    // outBuffer.
                     inBuffer.flip();
                     written = inBuffer.remaining();
+                    if (log.isDebugEnabled()) {
+                        log.debug(sm.getString("stream.inputBuffer.copy",
+                                Integer.toString(written)));
+                    }
                     inBuffer.get(outBuffer, 0, written);
                     inBuffer.clear();
                 } else if (isInputFinished()) {
@@ -596,14 +603,9 @@ public class Stream extends AbstractStream implements HeaderEmitter {
         }
 
 
-        boolean isReady() {
+        void registerReadInterest() {
             synchronized (inBuffer) {
-                if (inBuffer.position() == 0) {
-                    readInterest = true;
-                    return false;
-                } else {
-                    return true;
-                }
+                readInterest = true;
             }
         }
 
@@ -623,13 +625,20 @@ public class Stream extends AbstractStream implements HeaderEmitter {
          */
         synchronized boolean onDataAvailable() {
             if (readInterest) {
+                if (log.isDebugEnabled()) {
+                    log.debug(sm.getString("stream.inputBuffer.dispatch"));
+                }
                 readInterest = false;
                 coyoteRequest.action(ActionCode.DISPATCH_READ, null);
-                if (!ContainerThreadMarker.isContainerThread()) {
-                    coyoteRequest.action(ActionCode.DISPATCH_EXECUTE, null);
-                }
+                // Always need to dispatch since this thread is processing
+                // the incoming connection and streams are processed on their
+                // own.
+                coyoteRequest.action(ActionCode.DISPATCH_EXECUTE, null);
                 return true;
             } else {
+                if (log.isDebugEnabled()) {
+                    log.debug(sm.getString("stream.inputBuffer.signal"));
+                }
                 synchronized (inBuffer) {
                     inBuffer.notifyAll();
                 }

==================================================
