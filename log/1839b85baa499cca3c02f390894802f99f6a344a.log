1839b85baa499cca3c02f390894802f99f6a344a
==================================================
Update internal fork of Commons Pool 2
==================================================
Mark Thomas
==================================================
Fri May 13 16:48:56 2016 +0000
==================================================
BaseKeyedPooledObjectFactory.java
Update internal fork of Commons Pool 2

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1743698 13f79535-47bb-0310-9956-ffa450edef68



==================================================
BaseObject.java
index 69f8514ed2..129c55c20e 100644
--- a/java/org/apache/tomcat/dbcp/pool2/BaseKeyedPooledObjectFactory.java
+++ b/java/org/apache/tomcat/dbcp/pool2/BaseKeyedPooledObjectFactory.java
@@ -56,7 +56,7 @@ public abstract class BaseKeyedPooledObjectFactory<K,V> extends BaseObject
     public abstract PooledObject<V> wrap(V value);
 
     @Override
-    public PooledObject<V> makeObject(K key) throws Exception {
+    public PooledObject<V> makeObject(final K key) throws Exception {
         return wrap(create(key));
     }
 
@@ -69,7 +69,7 @@ public abstract class BaseKeyedPooledObjectFactory<K,V> extends BaseObject
      * @param p a {@code PooledObject} wrapping the the instance to be destroyed
      */
     @Override
-    public void destroyObject(K key, PooledObject<V> p)
+    public void destroyObject(final K key, final PooledObject<V> p)
         throws Exception {
     }
 
@@ -83,7 +83,7 @@ public abstract class BaseKeyedPooledObjectFactory<K,V> extends BaseObject
      * @return always <code>true</code> in the default implementation
      */
     @Override
-    public boolean validateObject(K key, PooledObject<V> p) {
+    public boolean validateObject(final K key, final PooledObject<V> p) {
         return true;
     }
 
@@ -96,7 +96,7 @@ public abstract class BaseKeyedPooledObjectFactory<K,V> extends BaseObject
      * @param p a {@code PooledObject} wrapping the the instance to be activated
      */
     @Override
-    public void activateObject(K key, PooledObject<V> p)
+    public void activateObject(final K key, final PooledObject<V> p)
         throws Exception {
     }
 
@@ -109,7 +109,7 @@ public abstract class BaseKeyedPooledObjectFactory<K,V> extends BaseObject
      * @param p a {@code PooledObject} wrapping the the instance to be passivated
      */
     @Override
-    public void passivateObject(K key, PooledObject<V> p)
+    public void passivateObject(final K key, final PooledObject<V> p)
         throws Exception {
     }
 }

==================================================
BaseObjectPool.java
index 47e001bcd1..87c6cce6a3 100644
--- a/java/org/apache/tomcat/dbcp/pool2/BaseObject.java
+++ b/java/org/apache/tomcat/dbcp/pool2/BaseObject.java
@@ -25,7 +25,7 @@ public abstract class BaseObject {
 
     @Override
     public String toString() {
-        StringBuilder builder = new StringBuilder();
+        final StringBuilder builder = new StringBuilder();
         builder.append(getClass().getSimpleName());
         builder.append(" [");
         toStringAppendFields(builder);
@@ -33,8 +33,13 @@ public abstract class BaseObject {
         return builder.toString();
     }
 
-    protected void toStringAppendFields(@SuppressWarnings("unused") StringBuilder builder) {
+    /**
+     * Used by sub-classes to include the fields defined by the sub-class in the
+     * {@link #toString()} output.
+     *
+     * @param builder Field names and values are appended to this object
+     */
+    protected void toStringAppendFields(final StringBuilder builder) {
         // do nothing by default, needed for b/w compatibility.
     }
-
 }

==================================================
BasePooledObjectFactory.java
index a85cf38997..ee11ee1569 100644
--- a/java/org/apache/tomcat/dbcp/pool2/BaseObjectPool.java
+++ b/java/org/apache/tomcat/dbcp/pool2/BaseObjectPool.java
@@ -118,7 +118,7 @@ public abstract class BaseObjectPool<T> extends BaseObject implements ObjectPool
     private volatile boolean closed = false;
 
     @Override
-    protected void toStringAppendFields(StringBuilder builder) {
+    protected void toStringAppendFields(final StringBuilder builder) {
         builder.append("closed=");
         builder.append(closed);
     }

==================================================
PoolUtils.java
index 6f2d66e344..e815191acd 100644
--- a/java/org/apache/tomcat/dbcp/pool2/BasePooledObjectFactory.java
+++ b/java/org/apache/tomcat/dbcp/pool2/BasePooledObjectFactory.java
@@ -64,7 +64,7 @@ public abstract class BasePooledObjectFactory<T> extends BaseObject implements P
      *  @param p ignored
      */
     @Override
-    public void destroyObject(PooledObject<T> p)
+    public void destroyObject(final PooledObject<T> p)
         throws Exception  {
     }
 
@@ -76,7 +76,7 @@ public abstract class BasePooledObjectFactory<T> extends BaseObject implements P
      * @return {@code true}
      */
     @Override
-    public boolean validateObject(PooledObject<T> p) {
+    public boolean validateObject(final PooledObject<T> p) {
         return true;
     }
 
@@ -86,7 +86,7 @@ public abstract class BasePooledObjectFactory<T> extends BaseObject implements P
      *  @param p ignored
      */
     @Override
-    public void activateObject(PooledObject<T> p) throws Exception {
+    public void activateObject(final PooledObject<T> p) throws Exception {
     }
 
     /**
@@ -95,7 +95,7 @@ public abstract class BasePooledObjectFactory<T> extends BaseObject implements P
      * @param p ignored
      */
     @Override
-    public void passivateObject(PooledObject<T> p)
+    public void passivateObject(final PooledObject<T> p)
         throws Exception {
     }
 }

==================================================
AbandonedConfig.java
index 7a36507b42..cf593d279f 100644
--- a/java/org/apache/tomcat/dbcp/pool2/PoolUtils.java
+++ b/java/org/apache/tomcat/dbcp/pool2/PoolUtils.java
@@ -66,7 +66,7 @@ public final class PoolUtils {
      * @throws VirtualMachineError
      *             if that is passed in
      */
-    public static void checkRethrow(Throwable t) {
+    public static void checkRethrow(final Throwable t) {
         if (t instanceof ThreadDeath) {
             throw (ThreadDeath) t;
         }
@@ -603,7 +603,7 @@ public final class PoolUtils {
                 }
                 success = true;
 
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 cancel();
             } finally {
                 // detect other types of Throwable and cancel this Timer
@@ -678,7 +678,7 @@ public final class PoolUtils {
                 }
                 success = true;
 
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 cancel();
 
             } finally {
@@ -750,7 +750,7 @@ public final class PoolUtils {
         @Override
         public T borrowObject() throws Exception, NoSuchElementException,
                 IllegalStateException {
-            WriteLock writeLock = readWriteLock.writeLock();
+            final WriteLock writeLock = readWriteLock.writeLock();
             writeLock.lock();
             try {
                 return pool.borrowObject();
@@ -764,11 +764,11 @@ public final class PoolUtils {
          */
         @Override
         public void returnObject(final T obj) {
-            WriteLock writeLock = readWriteLock.writeLock();
+            final WriteLock writeLock = readWriteLock.writeLock();
             writeLock.lock();
             try {
                 pool.returnObject(obj);
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 // swallowed as of Pool 2
             } finally {
                 writeLock.unlock();
@@ -780,11 +780,11 @@ public final class PoolUtils {
          */
         @Override
         public void invalidateObject(final T obj) {
-            WriteLock writeLock = readWriteLock.writeLock();
+            final WriteLock writeLock = readWriteLock.writeLock();
             writeLock.lock();
             try {
                 pool.invalidateObject(obj);
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 // swallowed as of Pool 2
             } finally {
                 writeLock.unlock();
@@ -797,7 +797,7 @@ public final class PoolUtils {
         @Override
         public void addObject() throws Exception, IllegalStateException,
                 UnsupportedOperationException {
-            WriteLock writeLock = readWriteLock.writeLock();
+            final WriteLock writeLock = readWriteLock.writeLock();
             writeLock.lock();
             try {
                 pool.addObject();
@@ -811,7 +811,7 @@ public final class PoolUtils {
          */
         @Override
         public int getNumIdle() {
-            ReadLock readLock = readWriteLock.readLock();
+            final ReadLock readLock = readWriteLock.readLock();
             readLock.lock();
             try {
                 return pool.getNumIdle();
@@ -825,7 +825,7 @@ public final class PoolUtils {
          */
         @Override
         public int getNumActive() {
-            ReadLock readLock = readWriteLock.readLock();
+            final ReadLock readLock = readWriteLock.readLock();
             readLock.lock();
             try {
                 return pool.getNumActive();
@@ -839,7 +839,7 @@ public final class PoolUtils {
          */
         @Override
         public void clear() throws Exception, UnsupportedOperationException {
-            WriteLock writeLock = readWriteLock.writeLock();
+            final WriteLock writeLock = readWriteLock.writeLock();
             writeLock.lock();
             try {
                 pool.clear();
@@ -853,11 +853,11 @@ public final class PoolUtils {
          */
         @Override
         public void close() {
-            WriteLock writeLock = readWriteLock.writeLock();
+            final WriteLock writeLock = readWriteLock.writeLock();
             writeLock.lock();
             try {
                 pool.close();
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 // swallowed as of Pool 2
             } finally {
                 writeLock.unlock();
@@ -924,7 +924,7 @@ public final class PoolUtils {
         @Override
         public V borrowObject(final K key) throws Exception,
                 NoSuchElementException, IllegalStateException {
-            WriteLock writeLock = readWriteLock.writeLock();
+            final WriteLock writeLock = readWriteLock.writeLock();
             writeLock.lock();
             try {
                 return keyedPool.borrowObject(key);
@@ -938,11 +938,11 @@ public final class PoolUtils {
          */
         @Override
         public void returnObject(final K key, final V obj) {
-            WriteLock writeLock = readWriteLock.writeLock();
+            final WriteLock writeLock = readWriteLock.writeLock();
             writeLock.lock();
             try {
                 keyedPool.returnObject(key, obj);
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 // swallowed
             } finally {
                 writeLock.unlock();
@@ -954,11 +954,11 @@ public final class PoolUtils {
          */
         @Override
         public void invalidateObject(final K key, final V obj) {
-            WriteLock writeLock = readWriteLock.writeLock();
+            final WriteLock writeLock = readWriteLock.writeLock();
             writeLock.lock();
             try {
                 keyedPool.invalidateObject(key, obj);
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 // swallowed as of Pool 2
             } finally {
                 writeLock.unlock();
@@ -971,7 +971,7 @@ public final class PoolUtils {
         @Override
         public void addObject(final K key) throws Exception,
                 IllegalStateException, UnsupportedOperationException {
-            WriteLock writeLock = readWriteLock.writeLock();
+            final WriteLock writeLock = readWriteLock.writeLock();
             writeLock.lock();
             try {
                 keyedPool.addObject(key);
@@ -985,7 +985,7 @@ public final class PoolUtils {
          */
         @Override
         public int getNumIdle(final K key) {
-            ReadLock readLock = readWriteLock.readLock();
+            final ReadLock readLock = readWriteLock.readLock();
             readLock.lock();
             try {
                 return keyedPool.getNumIdle(key);
@@ -999,7 +999,7 @@ public final class PoolUtils {
          */
         @Override
         public int getNumActive(final K key) {
-            ReadLock readLock = readWriteLock.readLock();
+            final ReadLock readLock = readWriteLock.readLock();
             readLock.lock();
             try {
                 return keyedPool.getNumActive(key);
@@ -1013,7 +1013,7 @@ public final class PoolUtils {
          */
         @Override
         public int getNumIdle() {
-            ReadLock readLock = readWriteLock.readLock();
+            final ReadLock readLock = readWriteLock.readLock();
             readLock.lock();
             try {
                 return keyedPool.getNumIdle();
@@ -1027,7 +1027,7 @@ public final class PoolUtils {
          */
         @Override
         public int getNumActive() {
-            ReadLock readLock = readWriteLock.readLock();
+            final ReadLock readLock = readWriteLock.readLock();
             readLock.lock();
             try {
                 return keyedPool.getNumActive();
@@ -1041,7 +1041,7 @@ public final class PoolUtils {
          */
         @Override
         public void clear() throws Exception, UnsupportedOperationException {
-            WriteLock writeLock = readWriteLock.writeLock();
+            final WriteLock writeLock = readWriteLock.writeLock();
             writeLock.lock();
             try {
                 keyedPool.clear();
@@ -1056,7 +1056,7 @@ public final class PoolUtils {
         @Override
         public void clear(final K key) throws Exception,
                 UnsupportedOperationException {
-            WriteLock writeLock = readWriteLock.writeLock();
+            final WriteLock writeLock = readWriteLock.writeLock();
             writeLock.lock();
             try {
                 keyedPool.clear(key);
@@ -1070,11 +1070,11 @@ public final class PoolUtils {
          */
         @Override
         public void close() {
-            WriteLock writeLock = readWriteLock.writeLock();
+            final WriteLock writeLock = readWriteLock.writeLock();
             writeLock.lock();
             try {
                 keyedPool.close();
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 // swallowed as of Pool 2
             } finally {
                 writeLock.unlock();
@@ -1464,7 +1464,7 @@ public final class PoolUtils {
                 } else {
                     pool.returnObject(obj);
                 }
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 // swallowed
             }
         }
@@ -1476,7 +1476,7 @@ public final class PoolUtils {
         public void invalidateObject(final T obj) {
             try {
                 pool.invalidateObject(obj);
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 // swallowed
             }
         }
@@ -1521,7 +1521,7 @@ public final class PoolUtils {
         public void close() {
             try {
                 pool.close();
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 // swallowed
             }
         }
@@ -1629,7 +1629,7 @@ public final class PoolUtils {
                 } else {
                     keyedPool.returnObject(key, obj);
                 }
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 // swallowed
             }
         }
@@ -1652,7 +1652,7 @@ public final class PoolUtils {
         public void invalidateObject(final K key, final V obj) {
             try {
                 keyedPool.invalidateObject(key, obj);
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 // swallowed
             }
         }
@@ -1722,7 +1722,7 @@ public final class PoolUtils {
         public void close() {
             try {
                 keyedPool.close();
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 // swallowed
             }
         }

==================================================
BaseGenericObjectPool.java
index 8cfd9587fd..b5c80076b0 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/AbandonedConfig.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/AbandonedConfig.java
@@ -55,7 +55,7 @@ public class AbandonedConfig {
      *   removed by borrowObject
      * @see #getRemoveAbandonedOnBorrow()
      */
-    public void setRemoveAbandonedOnBorrow(boolean removeAbandonedOnBorrow) {
+    public void setRemoveAbandonedOnBorrow(final boolean removeAbandonedOnBorrow) {
         this.removeAbandonedOnBorrow = removeAbandonedOnBorrow;
     }
 
@@ -92,7 +92,7 @@ public class AbandonedConfig {
      *   removed by pool maintenance
      * @see #getRemoveAbandonedOnMaintenance
      */
-    public void setRemoveAbandonedOnMaintenance(boolean removeAbandonedOnMaintenance) {
+    public void setRemoveAbandonedOnMaintenance(final boolean removeAbandonedOnMaintenance) {
         this.removeAbandonedOnMaintenance = removeAbandonedOnMaintenance;
     }
 
@@ -129,7 +129,7 @@ public class AbandonedConfig {
      * @param removeAbandonedTimeout new abandoned timeout in seconds
      * @see #getRemoveAbandonedTimeout()
      */
-    public void setRemoveAbandonedTimeout(int removeAbandonedTimeout) {
+    public void setRemoveAbandonedTimeout(final int removeAbandonedTimeout) {
         this.removeAbandonedTimeout = removeAbandonedTimeout;
     }
 
@@ -163,7 +163,7 @@ public class AbandonedConfig {
      * @see #getLogAbandoned()
      *
      */
-    public void setLogAbandoned(boolean logAbandoned) {
+    public void setLogAbandoned(final boolean logAbandoned) {
         this.logAbandoned = logAbandoned;
     }
 
@@ -190,7 +190,7 @@ public class AbandonedConfig {
      *
      * @param logWriter The new log writer
      */
-    public void setLogWriter(PrintWriter logWriter) {
+    public void setLogWriter(final PrintWriter logWriter) {
         this.logWriter = logWriter;
     }
 
@@ -226,7 +226,7 @@ public class AbandonedConfig {
      *                              the recording of a stack trace on every use
      *                              of a pooled object
      */
-    public void setUseUsageTracking(boolean useUsageTracking) {
+    public void setUseUsageTracking(final boolean useUsageTracking) {
         this.useUsageTracking = useUsageTracking;
     }
 
@@ -235,7 +235,7 @@ public class AbandonedConfig {
      */
     @Override
     public String toString() {
-        StringBuilder builder = new StringBuilder();
+        final StringBuilder builder = new StringBuilder();
         builder.append("AbandonedConfig [removeAbandonedOnBorrow=");
         builder.append(removeAbandonedOnBorrow);
         builder.append(", removeAbandonedOnMaintenance=");

==================================================
BaseObjectPoolConfig.java
index 40aa2870bb..2c93e3420c 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/BaseGenericObjectPool.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/BaseGenericObjectPool.java
@@ -127,8 +127,8 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      *                      overridden by the config
      * @param jmxNamePrefix Prefix to be used for JMX name for the new pool
      */
-    public BaseGenericObjectPool(BaseObjectPoolConfig config,
-            String jmxNameBase, String jmxNamePrefix) {
+    public BaseGenericObjectPool(final BaseObjectPoolConfig config,
+            final String jmxNameBase, final String jmxNamePrefix) {
         if (config.getJmxEnabled()) {
             this.oname = jmxRegister(config, jmxNameBase, jmxNamePrefix);
         } else {
@@ -139,7 +139,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
         this.creationStackTrace = getStackTrace(new Exception());
 
         // save the current TCCL (if any) to be used later by the evictor Thread
-        ClassLoader cl = Thread.currentThread().getContextClassLoader();
+        final ClassLoader cl = Thread.currentThread().getContextClassLoader();
         if (cl == null) {
             factoryClassLoader = null;
         } else {
@@ -176,7 +176,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      *
      * @see #getMaxTotal
      */
-    public final void setMaxTotal(int maxTotal) {
+    public final void setMaxTotal(final int maxTotal) {
         this.maxTotal = maxTotal;
     }
 
@@ -205,7 +205,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      *
      * @see #getBlockWhenExhausted
      */
-    public final void setBlockWhenExhausted(boolean blockWhenExhausted) {
+    public final void setBlockWhenExhausted(final boolean blockWhenExhausted) {
         this.blockWhenExhausted = blockWhenExhausted;
     }
 
@@ -240,7 +240,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      * @see #getMaxWaitMillis
      * @see #setBlockWhenExhausted
      */
-    public final void setMaxWaitMillis(long maxWaitMillis) {
+    public final void setMaxWaitMillis(final long maxWaitMillis) {
         this.maxWaitMillis = maxWaitMillis;
     }
 
@@ -283,7 +283,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      *
      * @see #getLifo()
      */
-    public final void setLifo(boolean lifo) {
+    public final void setLifo(final boolean lifo) {
         this.lifo = lifo;
     }
 
@@ -320,7 +320,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      *
      * @since 2.2
      */
-    public final void setTestOnCreate(boolean testOnCreate) {
+    public final void setTestOnCreate(final boolean testOnCreate) {
         this.testOnCreate = testOnCreate;
     }
 
@@ -355,7 +355,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      *
      * @see #getTestOnBorrow
      */
-    public final void setTestOnBorrow(boolean testOnBorrow) {
+    public final void setTestOnBorrow(final boolean testOnBorrow) {
         this.testOnBorrow = testOnBorrow;
     }
 
@@ -388,7 +388,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      *
      * @see #getTestOnReturn
      */
-    public final void setTestOnReturn(boolean testOnReturn) {
+    public final void setTestOnReturn(final boolean testOnReturn) {
         this.testOnReturn = testOnReturn;
     }
 
@@ -425,7 +425,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      * @see #getTestWhileIdle
      * @see #setTimeBetweenEvictionRunsMillis
      */
-    public final void setTestWhileIdle(boolean testWhileIdle) {
+    public final void setTestWhileIdle(final boolean testWhileIdle) {
         this.testWhileIdle = testWhileIdle;
     }
 
@@ -453,7 +453,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      * @see #getTimeBetweenEvictionRunsMillis
      */
     public final void setTimeBetweenEvictionRunsMillis(
-            long timeBetweenEvictionRunsMillis) {
+            final long timeBetweenEvictionRunsMillis) {
         this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
         startEvictor(timeBetweenEvictionRunsMillis);
     }
@@ -493,7 +493,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      * @see #getNumTestsPerEvictionRun
      * @see #setTimeBetweenEvictionRunsMillis
      */
-    public final void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
+    public final void setNumTestsPerEvictionRun(final int numTestsPerEvictionRun) {
         this.numTestsPerEvictionRun = numTestsPerEvictionRun;
     }
 
@@ -527,7 +527,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      * @see #setTimeBetweenEvictionRunsMillis
      */
     public final void setMinEvictableIdleTimeMillis(
-            long minEvictableIdleTimeMillis) {
+            final long minEvictableIdleTimeMillis) {
         this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
     }
 
@@ -568,7 +568,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      * @see #getSoftMinEvictableIdleTimeMillis
      */
     public final void setSoftMinEvictableIdleTimeMillis(
-            long softMinEvictableIdleTimeMillis) {
+            final long softMinEvictableIdleTimeMillis) {
         this.softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
     }
 
@@ -596,30 +596,31 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      * @see #getEvictionPolicyClassName()
      */
     public final void setEvictionPolicyClassName(
-            String evictionPolicyClassName) {
+            final String evictionPolicyClassName) {
         try {
             Class<?> clazz;
             try {
                 clazz = Class.forName(evictionPolicyClassName, true,
                         Thread.currentThread().getContextClassLoader());
-            } catch (ClassNotFoundException e) {
+            } catch (final ClassNotFoundException e) {
                 clazz = Class.forName(evictionPolicyClassName);
             }
-            Object policy = clazz.newInstance();
+            final Object policy = clazz.newInstance();
             if (policy instanceof EvictionPolicy<?>) {
                 @SuppressWarnings("unchecked") // safe, because we just checked the class
+                final
                 EvictionPolicy<T> evicPolicy = (EvictionPolicy<T>) policy;
                 this.evictionPolicy = evicPolicy;
             }
-        } catch (ClassNotFoundException e) {
+        } catch (final ClassNotFoundException e) {
             throw new IllegalArgumentException(
                     "Unable to create EvictionPolicy instance of type " +
                     evictionPolicyClassName, e);
-        } catch (InstantiationException e) {
+        } catch (final InstantiationException e) {
             throw new IllegalArgumentException(
                     "Unable to create EvictionPolicy instance of type " +
                     evictionPolicyClassName, e);
-        } catch (IllegalAccessException e) {
+        } catch (final IllegalAccessException e) {
             throw new IllegalArgumentException(
                     "Unable to create EvictionPolicy instance of type " +
                     evictionPolicyClassName, e);
@@ -683,7 +684,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      *
      * @param delay time in milliseconds before start and between eviction runs
      */
-    final void startEvictor(long delay) {
+    final void startEvictor(final long delay) {
         synchronized (evictionLock) {
             if (null != evictor) {
                 EvictionTimer.cancel(evictor);
@@ -847,7 +848,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      *                                      for no listener
      */
     public final void setSwallowedExceptionListener(
-            SwallowedExceptionListener swallowedExceptionListener) {
+            final SwallowedExceptionListener swallowedExceptionListener) {
         this.swallowedExceptionListener = swallowedExceptionListener;
     }
 
@@ -857,8 +858,8 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      *
      * @param e exception to be swallowed
      */
-    final void swallowException(Exception e) {
-        SwallowedExceptionListener listener = getSwallowedExceptionListener();
+    final void swallowException(final Exception e) {
+        final SwallowedExceptionListener listener = getSwallowedExceptionListener();
 
         if (listener == null) {
             return;
@@ -866,11 +867,11 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
 
         try {
             listener.onSwallowException(e);
-        } catch (OutOfMemoryError oome) {
+        } catch (final OutOfMemoryError oome) {
             throw oome;
-        } catch (VirtualMachineError vme) {
+        } catch (final VirtualMachineError vme) {
             throw vme;
-        } catch (Throwable t) {
+        } catch (final Throwable t) {
             // Ignore. Enjoy the irony.
         }
     }
@@ -880,7 +881,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      * @param p object borrowed from the pool
      * @param waitTime time (in milliseconds) that the borrowing thread had to wait
      */
-    final void updateStatsBorrow(PooledObject<T> p, long waitTime) {
+    final void updateStatsBorrow(final PooledObject<T> p, final long waitTime) {
         borrowedCount.incrementAndGet();
         idleTimes.add(p.getIdleTimeMillis());
         waitTimes.add(waitTime);
@@ -900,7 +901,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      * @param activeTime the amount of time (in milliseconds) that the returning
      * object was checked out
      */
-    final void updateStatsReturn(long activeTime) {
+    final void updateStatsReturn(final long activeTime) {
         returnedCount.incrementAndGet();
         activeTimes.add(activeTime);
     }
@@ -913,9 +914,9 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
             try {
                 ManagementFactory.getPlatformMBeanServer().unregisterMBean(
                         oname);
-            } catch (MBeanRegistrationException e) {
+            } catch (final MBeanRegistrationException e) {
                 swallowException(e);
-            } catch (InstanceNotFoundException e) {
+            } catch (final InstanceNotFoundException e) {
                 swallowException(e);
             }
         }
@@ -934,10 +935,10 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      * @param jmxNamePrefix name prefix
      * @return registered ObjectName, null if registration fails
      */
-    private ObjectName jmxRegister(BaseObjectPoolConfig config,
-            String jmxNameBase, String jmxNamePrefix) {
+    private ObjectName jmxRegister(final BaseObjectPoolConfig config,
+            final String jmxNameBase, String jmxNamePrefix) {
         ObjectName objectName = null;
-        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
+        final MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
         int i = 1;
         boolean registered = false;
         String base = config.getJmxNameBase();
@@ -957,7 +958,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
                 mbs.registerMBean(this, objName);
                 objectName = objName;
                 registered = true;
-            } catch (MalformedObjectNameException e) {
+            } catch (final MalformedObjectNameException e) {
                 if (BaseObjectPoolConfig.DEFAULT_JMX_NAME_PREFIX.equals(
                         jmxNamePrefix) && jmxNameBase.equals(base)) {
                     // Shouldn't happen. Skip registration if it does.
@@ -968,13 +969,13 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
                             BaseObjectPoolConfig.DEFAULT_JMX_NAME_PREFIX;
                     base = jmxNameBase;
                 }
-            } catch (InstanceAlreadyExistsException e) {
+            } catch (final InstanceAlreadyExistsException e) {
                 // Increment the index and try again
                 i++;
-            } catch (MBeanRegistrationException e) {
+            } catch (final MBeanRegistrationException e) {
                 // Shouldn't happen. Skip registration if it does.
                 registered = true;
-            } catch (NotCompliantMBeanException e) {
+            } catch (final NotCompliantMBeanException e) {
                 // Shouldn't happen. Skip registration if it does.
                 registered = true;
             }
@@ -987,12 +988,12 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
      * @param e exception to trace
      * @return exception stack trace as a string
      */
-    private String getStackTrace(Exception e) {
+    private String getStackTrace(final Exception e) {
         // Need the exception in string form to prevent the retention of
         // references to classes in the stack trace that could trigger a memory
         // leak in a container environment.
-        Writer w = new StringWriter();
-        PrintWriter pw = new PrintWriter(w);
+        final Writer w = new StringWriter();
+        final PrintWriter pw = new PrintWriter(w);
         e.printStackTrace(pw);
         return w.toString();
     }
@@ -1015,12 +1016,12 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
          */
         @Override
         public void run() {
-            ClassLoader savedClassLoader =
+            final ClassLoader savedClassLoader =
                     Thread.currentThread().getContextClassLoader();
             try {
                 if (factoryClassLoader != null) {
                     // Set the class loader for the factory
-                    ClassLoader cl = factoryClassLoader.get();
+                    final ClassLoader cl = factoryClassLoader.get();
                     if (cl == null) {
                         // The pool has been dereferenced and the class loader
                         // GC'd. Cancel this timer so the pool can be GC'd as
@@ -1034,9 +1035,9 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
                 // Evict from the pool
                 try {
                     evict();
-                } catch(Exception e) {
+                } catch(final Exception e) {
                     swallowException(e);
-                } catch(OutOfMemoryError oome) {
+                } catch(final OutOfMemoryError oome) {
                     // Log problem but give evictor thread a chance to continue
                     // in case error is recoverable
                     oome.printStackTrace(System.err);
@@ -1044,7 +1045,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
                 // Re-create idle instances.
                 try {
                     ensureMinIdle();
-                } catch (Exception e) {
+                } catch (final Exception e) {
                     swallowException(e);
                 }
             } finally {
@@ -1069,7 +1070,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
          *
          * @param size number of values to maintain in the cache.
          */
-        public StatsStore(int size) {
+        public StatsStore(final int size) {
             this.size = size;
             values = new AtomicLong[size];
             for (int i = 0; i < size; i++) {
@@ -1083,7 +1084,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
          *
          * @param value new value to add to the cache.
          */
-        public synchronized void add(long value) {
+        public synchronized void add(final long value) {
             values[index].set(value);
             index++;
             if (index == size) {
@@ -1100,7 +1101,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
             double result = 0;
             int counter = 0;
             for (int i = 0; i < size; i++) {
-                long value = values[i].get();
+                final long value = values[i].get();
                 if (value != -1) {
                     counter++;
                     result = result * ((counter - 1) / (double) counter) +
@@ -1112,7 +1113,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
 
         @Override
         public String toString() {
-            StringBuilder builder = new StringBuilder();
+            final StringBuilder builder = new StringBuilder();
             builder.append("StatsStore [values=");
             builder.append(Arrays.toString(values));
             builder.append(", size=");
@@ -1192,7 +1193,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
          *
          * @param instance object to wrap
          */
-        public IdentityWrapper(T instance) {
+        public IdentityWrapper(final T instance) {
             this.instance = instance;
         }
 
@@ -1203,8 +1204,9 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
 
         @Override
         @SuppressWarnings("rawtypes")
-        public boolean equals(Object other) {
-            return ((IdentityWrapper) other).instance == instance;
+        public boolean equals(final Object other) {
+            return  other instanceof IdentityWrapper &&
+                    ((IdentityWrapper) other).instance == instance;
         }
 
         /**
@@ -1216,7 +1218,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
 
         @Override
         public String toString() {
-            StringBuilder builder = new StringBuilder();
+            final StringBuilder builder = new StringBuilder();
             builder.append("IdentityWrapper [instance=");
             builder.append(instance);
             builder.append("]");
@@ -1225,7 +1227,7 @@ public abstract class BaseGenericObjectPool<T> extends BaseObject {
     }
 
     @Override
-    protected void toStringAppendFields(StringBuilder builder) {
+    protected void toStringAppendFields(final StringBuilder builder) {
         builder.append("maxTotal=");
         builder.append(maxTotal);
         builder.append(", blockWhenExhausted=");

==================================================
DefaultEvictionPolicy.java
index e9b1ca381c..51554e71d4 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/BaseObjectPoolConfig.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/BaseObjectPoolConfig.java
@@ -230,7 +230,7 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      * @see GenericObjectPool#getLifo()
      * @see GenericKeyedObjectPool#getLifo()
      */
-    public void setLifo(boolean lifo) {
+    public void setLifo(final boolean lifo) {
         this.lifo = lifo;
     }
 
@@ -244,7 +244,7 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      * @see GenericObjectPool#getFairness()
      * @see GenericKeyedObjectPool#getFairness()
      */
-    public void setFairness(boolean fairness) {
+    public void setFairness(final boolean fairness) {
         this.fairness = fairness;
     }
 
@@ -272,7 +272,7 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      * @see GenericObjectPool#getMaxWaitMillis()
      * @see GenericKeyedObjectPool#getMaxWaitMillis()
      */
-    public void setMaxWaitMillis(long maxWaitMillis) {
+    public void setMaxWaitMillis(final long maxWaitMillis) {
         this.maxWaitMillis = maxWaitMillis;
     }
 
@@ -300,7 +300,7 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      * @see GenericObjectPool#getMinEvictableIdleTimeMillis()
      * @see GenericKeyedObjectPool#getMinEvictableIdleTimeMillis()
      */
-    public void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
+    public void setMinEvictableIdleTimeMillis(final long minEvictableIdleTimeMillis) {
         this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
     }
 
@@ -332,7 +332,7 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      * @see GenericKeyedObjectPool#getSoftMinEvictableIdleTimeMillis()
      */
     public void setSoftMinEvictableIdleTimeMillis(
-            long softMinEvictableIdleTimeMillis) {
+            final long softMinEvictableIdleTimeMillis) {
         this.softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
     }
 
@@ -360,7 +360,7 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      * @see GenericObjectPool#getNumTestsPerEvictionRun()
      * @see GenericKeyedObjectPool#getNumTestsPerEvictionRun()
      */
-    public void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
+    public void setNumTestsPerEvictionRun(final int numTestsPerEvictionRun) {
         this.numTestsPerEvictionRun = numTestsPerEvictionRun;
     }
 
@@ -392,7 +392,7 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      *
      * @since 2.2
      */
-    public void setTestOnCreate(boolean testOnCreate) {
+    public void setTestOnCreate(final boolean testOnCreate) {
         this.testOnCreate = testOnCreate;
     }
 
@@ -420,7 +420,7 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      * @see GenericObjectPool#getTestOnBorrow()
      * @see GenericKeyedObjectPool#getTestOnBorrow()
      */
-    public void setTestOnBorrow(boolean testOnBorrow) {
+    public void setTestOnBorrow(final boolean testOnBorrow) {
         this.testOnBorrow = testOnBorrow;
     }
 
@@ -448,7 +448,7 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      * @see GenericObjectPool#getTestOnReturn()
      * @see GenericKeyedObjectPool#getTestOnReturn()
      */
-    public void setTestOnReturn(boolean testOnReturn) {
+    public void setTestOnReturn(final boolean testOnReturn) {
         this.testOnReturn = testOnReturn;
     }
 
@@ -476,7 +476,7 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      * @see GenericObjectPool#getTestWhileIdle()
      * @see GenericKeyedObjectPool#getTestWhileIdle()
      */
-    public void setTestWhileIdle(boolean testWhileIdle) {
+    public void setTestWhileIdle(final boolean testWhileIdle) {
         this.testWhileIdle = testWhileIdle;
     }
 
@@ -506,7 +506,7 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      * @see GenericKeyedObjectPool#getTimeBetweenEvictionRunsMillis()
      */
     public void setTimeBetweenEvictionRunsMillis(
-            long timeBetweenEvictionRunsMillis) {
+            final long timeBetweenEvictionRunsMillis) {
         this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
     }
 
@@ -534,7 +534,7 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      * @see GenericObjectPool#getEvictionPolicyClassName()
      * @see GenericKeyedObjectPool#getEvictionPolicyClassName()
      */
-    public void setEvictionPolicyClassName(String evictionPolicyClassName) {
+    public void setEvictionPolicyClassName(final String evictionPolicyClassName) {
         this.evictionPolicyClassName = evictionPolicyClassName;
     }
 
@@ -562,7 +562,7 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      * @see GenericObjectPool#getBlockWhenExhausted()
      * @see GenericKeyedObjectPool#getBlockWhenExhausted()
      */
-    public void setBlockWhenExhausted(boolean blockWhenExhausted) {
+    public void setBlockWhenExhausted(final boolean blockWhenExhausted) {
         this.blockWhenExhausted = blockWhenExhausted;
     }
 
@@ -584,7 +584,7 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      * @param jmxEnabled The new setting of {@code jmxEnabled}
      *        for this configuration instance
      */
-    public void setJmxEnabled(boolean jmxEnabled) {
+    public void setJmxEnabled(final boolean jmxEnabled) {
         this.jmxEnabled = jmxEnabled;
     }
 
@@ -610,7 +610,7 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      * @param jmxNameBase The new setting of {@code jmxNameBase}
      *        for this configuration instance
      */
-    public void setJmxNameBase(String jmxNameBase) {
+    public void setJmxNameBase(final String jmxNameBase) {
         this.jmxNameBase = jmxNameBase;
     }
 
@@ -634,12 +634,12 @@ public abstract class BaseObjectPoolConfig extends BaseObject implements Cloneab
      * @param jmxNamePrefix The new setting of {@code jmxNamePrefix}
      *        for this configuration instance
      */
-    public void setJmxNamePrefix(String jmxNamePrefix) {
+    public void setJmxNamePrefix(final String jmxNamePrefix) {
         this.jmxNamePrefix = jmxNamePrefix;
     }
 
     @Override
-    protected void toStringAppendFields(StringBuilder builder) {
+    protected void toStringAppendFields(final StringBuilder builder) {
         builder.append("lifo=");
         builder.append(lifo);
         builder.append(", fairness=");

==================================================
DefaultPooledObject.java
index a7842ab17d..fdacc6e877 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/DefaultEvictionPolicy.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/DefaultEvictionPolicy.java
@@ -40,8 +40,8 @@ import org.apache.tomcat.dbcp.pool2.PooledObject;
 public class DefaultEvictionPolicy<T> implements EvictionPolicy<T> {
 
     @Override
-    public boolean evict(EvictionConfig config, PooledObject<T> underTest,
-            int idleCount) {
+    public boolean evict(final EvictionConfig config, final PooledObject<T> underTest,
+            final int idleCount) {
 
         if ((config.getIdleSoftEvictTime() < underTest.getIdleTimeMillis() &&
                 config.getMinIdle() < idleCount) ||

==================================================
DefaultPooledObjectInfo.java
index 4e06abdeaf..8ffbd171e4 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/DefaultPooledObject.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/DefaultPooledObject.java
@@ -54,7 +54,7 @@ public class DefaultPooledObject<T> implements PooledObject<T> {
      *
      * @param object The object to wrap
      */
-    public DefaultPooledObject(T object) {
+    public DefaultPooledObject(final T object) {
         this.object = object;
     }
 
@@ -71,8 +71,8 @@ public class DefaultPooledObject<T> implements PooledObject<T> {
     @Override
     public long getActiveTimeMillis() {
         // Take copies to avoid threading issues
-        long rTime = lastReturnTime;
-        long bTime = lastBorrowTime;
+        final long rTime = lastReturnTime;
+        final long bTime = lastBorrowTime;
 
         if (rTime > bTime) {
             return rTime - bTime;
@@ -126,7 +126,7 @@ public class DefaultPooledObject<T> implements PooledObject<T> {
     }
 
     @Override
-    public int compareTo(PooledObject<T> other) {
+    public int compareTo(final PooledObject<T> other) {
         final long lastActiveDiff = this.getLastReturnTime() - other.getLastReturnTime();
         if (lastActiveDiff == 0) {
             // Make sure the natural ordering is broadly consistent with equals
@@ -141,7 +141,7 @@ public class DefaultPooledObject<T> implements PooledObject<T> {
 
     @Override
     public String toString() {
-        StringBuilder result = new StringBuilder();
+        final StringBuilder result = new StringBuilder();
         result.append("Object: ");
         result.append(object.toString());
         result.append(", State: ");
@@ -164,7 +164,7 @@ public class DefaultPooledObject<T> implements PooledObject<T> {
 
     @Override
     public synchronized boolean endEvictionTest(
-            Deque<PooledObject<T>> idleQueue) {
+            final Deque<PooledObject<T>> idleQueue) {
         if (state == PooledObjectState.EVICTION) {
             state = PooledObjectState.IDLE;
             return true;
@@ -238,14 +238,14 @@ public class DefaultPooledObject<T> implements PooledObject<T> {
     }
 
     @Override
-    public void printStackTrace(PrintWriter writer) {
+    public void printStackTrace(final PrintWriter writer) {
         boolean written = false;
-        Exception borrowedByCopy = this.borrowedBy;
+        final Exception borrowedByCopy = this.borrowedBy;
         if (borrowedByCopy != null) {
             borrowedByCopy.printStackTrace(writer);
             written = true;
         }
-        Exception usedByCopy = this.usedBy;
+        final Exception usedByCopy = this.usedBy;
         if (usedByCopy != null) {
             usedByCopy.printStackTrace(writer);
             written = true;
@@ -281,7 +281,7 @@ public class DefaultPooledObject<T> implements PooledObject<T> {
     }
 
     @Override
-    public void setLogAbandoned(boolean logAbandoned) {
+    public void setLogAbandoned(final boolean logAbandoned) {
         this.logAbandoned = logAbandoned;
     }
 

==================================================
EvictionConfig.java
index 2d1099877e..89871acbbb 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/DefaultPooledObjectInfo.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/DefaultPooledObjectInfo.java
@@ -37,7 +37,7 @@ public class DefaultPooledObjectInfo implements DefaultPooledObjectInfoMBean {
      *
      * @param pooledObject The pooled object that this instance will represent
      */
-    public DefaultPooledObjectInfo(PooledObject<?> pooledObject) {
+    public DefaultPooledObjectInfo(final PooledObject<?> pooledObject) {
         this.pooledObject = pooledObject;
     }
 
@@ -48,7 +48,7 @@ public class DefaultPooledObjectInfo implements DefaultPooledObjectInfoMBean {
 
     @Override
     public String getCreateTimeFormatted() {
-        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
+        final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
         return sdf.format(Long.valueOf(pooledObject.getCreateTime()));
     }
 
@@ -59,13 +59,13 @@ public class DefaultPooledObjectInfo implements DefaultPooledObjectInfoMBean {
 
     @Override
     public String getLastBorrowTimeFormatted() {
-        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
+        final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
         return sdf.format(Long.valueOf(pooledObject.getLastBorrowTime()));
     }
 
     @Override
     public String getLastBorrowTrace() {
-        StringWriter sw = new StringWriter();
+        final StringWriter sw = new StringWriter();
         pooledObject.printStackTrace(new PrintWriter(sw));
         return sw.toString();
     }
@@ -77,7 +77,7 @@ public class DefaultPooledObjectInfo implements DefaultPooledObjectInfoMBean {
 
     @Override
     public String getLastReturnTimeFormatted() {
-        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
+        final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
         return sdf.format(Long.valueOf(pooledObject.getLastReturnTime()));
     }
 
@@ -105,7 +105,7 @@ public class DefaultPooledObjectInfo implements DefaultPooledObjectInfoMBean {
      */
     @Override
     public String toString() {
-        StringBuilder builder = new StringBuilder();
+        final StringBuilder builder = new StringBuilder();
         builder.append("DefaultPooledObjectInfo [pooledObject=");
         builder.append(pooledObject);
         builder.append("]");

==================================================
EvictionTimer.java
index 089f47072b..49766f00bc 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/EvictionConfig.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/EvictionConfig.java
@@ -43,8 +43,8 @@ public class EvictionConfig {
      *        {@link GenericObjectPool#getMinIdle()} or
      *        {@link GenericKeyedObjectPool#getMinIdlePerKey()}
      */
-    public EvictionConfig(long poolIdleEvictTime, long poolIdleSoftEvictTime,
-            int minIdle) {
+    public EvictionConfig(final long poolIdleEvictTime, final long poolIdleSoftEvictTime,
+            final int minIdle) {
         if (poolIdleEvictTime > 0) {
             idleEvictTime = poolIdleEvictTime;
         } else {
@@ -101,7 +101,7 @@ public class EvictionConfig {
      */
     @Override
     public String toString() {
-        StringBuilder builder = new StringBuilder();
+        final StringBuilder builder = new StringBuilder();
         builder.append("EvictionConfig [idleEvictTime=");
         builder.append(idleEvictTime);
         builder.append(", idleSoftEvictTime=");

==================================================
GenericKeyedObjectPool.java
index a99b026581..455b269a15 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/EvictionTimer.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/EvictionTimer.java
@@ -58,11 +58,11 @@ class EvictionTimer {
      * @param delay     Delay in milliseconds before task is executed
      * @param period    Time in milliseconds between executions
      */
-    static synchronized void schedule(TimerTask task, long delay, long period) {
+    static synchronized void schedule(final TimerTask task, final long delay, final long period) {
         if (null == _timer) {
             // Force the new Timer thread to be created with a context class
             // loader set to the class loader that loaded this library
-            ClassLoader ccl = AccessController.doPrivileged(
+            final ClassLoader ccl = AccessController.doPrivileged(
                     new PrivilegedGetTccl());
             try {
                 AccessController.doPrivileged(new PrivilegedSetTccl(
@@ -80,7 +80,7 @@ class EvictionTimer {
      * Remove the specified eviction task from the timer.
      * @param task      Task to be scheduled
      */
-    static synchronized void cancel(TimerTask task) {
+    static synchronized void cancel(final TimerTask task) {
         task.cancel();
         _usageCount--;
         if (_usageCount == 0) {
@@ -115,7 +115,7 @@ class EvictionTimer {
          * Create a new PrivilegedSetTccl using the given classloader
          * @param classLoader ClassLoader to use
          */
-        PrivilegedSetTccl(ClassLoader cl) {
+        PrivilegedSetTccl(final ClassLoader cl) {
             this.classLoader = cl;
         }
 
@@ -130,7 +130,7 @@ class EvictionTimer {
 
         @Override
         public String toString() {
-            StringBuilder builder = new StringBuilder();
+            final StringBuilder builder = new StringBuilder();
             builder.append("PrivilegedSetTccl [classLoader=");
             builder.append(classLoader);
             builder.append("]");
@@ -162,7 +162,7 @@ class EvictionTimer {
      */
     @Override
     public String toString() {
-        StringBuilder builder = new StringBuilder();
+        final StringBuilder builder = new StringBuilder();
         builder.append("EvictionTimer []");
         return builder.toString();
     }

==================================================
GenericKeyedObjectPoolConfig.java
index 921dd336ce..9f7429ddce 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java
@@ -80,7 +80,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      * {@link GenericKeyedObjectPoolConfig}.
      * @param factory the factory to be used to create entries
      */
-    public GenericKeyedObjectPool(KeyedPooledObjectFactory<K,T> factory) {
+    public GenericKeyedObjectPool(final KeyedPooledObjectFactory<K,T> factory) {
         this(factory, new GenericKeyedObjectPoolConfig());
     }
 
@@ -94,8 +94,8 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      *                  the configuration object will not be reflected in the
      *                  pool.
      */
-    public GenericKeyedObjectPool(KeyedPooledObjectFactory<K,T> factory,
-            GenericKeyedObjectPoolConfig config) {
+    public GenericKeyedObjectPool(final KeyedPooledObjectFactory<K,T> factory,
+            final GenericKeyedObjectPoolConfig config) {
 
         super(config, ONAME_BASE, config.getJmxNamePrefix());
 
@@ -134,7 +134,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      *
      * @see #getMaxTotalPerKey
      */
-    public void setMaxTotalPerKey(int maxTotalPerKey) {
+    public void setMaxTotalPerKey(final int maxTotalPerKey) {
         this.maxTotalPerKey = maxTotalPerKey;
     }
 
@@ -175,7 +175,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      *
      * @see #getMaxIdlePerKey
      */
-    public void setMaxIdlePerKey(int maxIdlePerKey) {
+    public void setMaxIdlePerKey(final int maxIdlePerKey) {
         this.maxIdlePerKey = maxIdlePerKey;
     }
 
@@ -197,7 +197,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      * @see #getMaxIdlePerKey()
      * @see #setTimeBetweenEvictionRunsMillis
      */
-    public void setMinIdlePerKey(int minIdlePerKey) {
+    public void setMinIdlePerKey(final int minIdlePerKey) {
         this.minIdlePerKey = minIdlePerKey;
     }
 
@@ -219,7 +219,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      */
     @Override
     public int getMinIdlePerKey() {
-        int maxIdlePerKeySave = getMaxIdlePerKey();
+        final int maxIdlePerKeySave = getMaxIdlePerKey();
         if (this.minIdlePerKey > maxIdlePerKeySave) {
             return maxIdlePerKeySave;
         }
@@ -233,7 +233,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      *
      * @see GenericKeyedObjectPoolConfig
      */
-    public void setConfig(GenericKeyedObjectPoolConfig conf) {
+    public void setConfig(final GenericKeyedObjectPoolConfig conf) {
         setLifo(conf.getLifo());
         setMaxIdlePerKey(conf.getMaxIdlePerKey());
         setMaxTotalPerKey(conf.getMaxTotalPerKey());
@@ -271,7 +271,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      * {@inheritDoc}
      */
     @Override
-    public T borrowObject(K key) throws Exception {
+    public T borrowObject(final K key) throws Exception {
         return borrowObject(key, getMaxWaitMillis());
     }
 
@@ -331,30 +331,30 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      * @throws Exception if a keyed object instance cannot be returned due to an
      *                   error
      */
-    public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception {
+    public T borrowObject(final K key, final long borrowMaxWaitMillis) throws Exception {
         assertOpen();
 
         PooledObject<T> p = null;
 
         // Get local copy of current config so it is consistent for entire
         // method execution
-        boolean blockWhenExhausted = getBlockWhenExhausted();
+        final boolean blockWhenExhausted = getBlockWhenExhausted();
 
         boolean create;
-        long waitTime = System.currentTimeMillis();
-        ObjectDeque<T> objectDeque = register(key);
+        final long waitTime = System.currentTimeMillis();
+        final ObjectDeque<T> objectDeque = register(key);
 
         try {
             while (p == null) {
                 create = false;
-                if (blockWhenExhausted) {
-                    p = objectDeque.getIdleObjects().pollFirst();
-                    if (p == null) {
-                        p = create(key);
-                        if (p != null) {
-                            create = true;
-                        }
+                p = objectDeque.getIdleObjects().pollFirst();
+                if (p == null) {
+                    p = create(key);
+                    if (p != null) {
+                        create = true;
                     }
+                }
+                if (blockWhenExhausted) {
                     if (p == null) {
                         if (borrowMaxWaitMillis < 0) {
                             p = objectDeque.getIdleObjects().takeFirst();
@@ -367,37 +367,27 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
                         throw new NoSuchElementException(
                                 "Timeout waiting for idle object");
                     }
-                    if (!p.allocate()) {
-                        p = null;
-                    }
                 } else {
-                    p = objectDeque.getIdleObjects().pollFirst();
-                    if (p == null) {
-                        p = create(key);
-                        if (p != null) {
-                            create = true;
-                        }
-                    }
                     if (p == null) {
                         throw new NoSuchElementException("Pool exhausted");
                     }
-                    if (!p.allocate()) {
-                        p = null;
-                    }
+                }
+                if (!p.allocate()) {
+                    p = null;
                 }
 
                 if (p != null) {
                     try {
                         factory.activateObject(key, p);
-                    } catch (Exception e) {
+                    } catch (final Exception e) {
                         try {
                             destroy(key, p, true);
-                        } catch (Exception e1) {
+                        } catch (final Exception e1) {
                             // Ignore - activation failure is more important
                         }
                         p = null;
                         if (create) {
-                            NoSuchElementException nsee = new NoSuchElementException(
+                            final NoSuchElementException nsee = new NoSuchElementException(
                                     "Unable to activate object");
                             nsee.initCause(e);
                             throw nsee;
@@ -408,7 +398,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
                         Throwable validationThrowable = null;
                         try {
                             validate = factory.validateObject(key, p);
-                        } catch (Throwable t) {
+                        } catch (final Throwable t) {
                             PoolUtils.checkRethrow(t);
                             validationThrowable = t;
                         }
@@ -416,12 +406,12 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
                             try {
                                 destroy(key, p, true);
                                 destroyedByBorrowValidationCount.incrementAndGet();
-                            } catch (Exception e) {
+                            } catch (final Exception e) {
                                 // Ignore - validation failure is more important
                             }
                             p = null;
                             if (create) {
-                                NoSuchElementException nsee = new NoSuchElementException(
+                                final NoSuchElementException nsee = new NoSuchElementException(
                                         "Unable to validate object");
                                 nsee.initCause(validationThrowable);
                                 throw nsee;
@@ -464,11 +454,11 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      *                               returned to the pool multiple times
      */
     @Override
-    public void returnObject(K key, T obj) {
+    public void returnObject(final K key, final T obj) {
 
-        ObjectDeque<T> objectDeque = poolMap.get(key);
+        final ObjectDeque<T> objectDeque = poolMap.get(key);
 
-        PooledObject<T> p = objectDeque.getAllObjects().get(new IdentityWrapper<>(obj));
+        final PooledObject<T> p = objectDeque.getAllObjects().get(new IdentityWrapper<>(obj));
 
         if (p == null) {
             throw new IllegalStateException(
@@ -484,81 +474,80 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
             p.markReturning(); // Keep from being marked abandoned (once GKOP does this)
         }
 
-        long activeTime = p.getActiveTimeMillis();
+        final long activeTime = p.getActiveTimeMillis();
 
-        if (getTestOnReturn()) {
-            if (!factory.validateObject(key, p)) {
+        try {
+            if (getTestOnReturn()) {
+                if (!factory.validateObject(key, p)) {
+                    try {
+                        destroy(key, p, true);
+                    } catch (final Exception e) {
+                        swallowException(e);
+                    }
+                    if (objectDeque.idleObjects.hasTakeWaiters()) {
+                        try {
+                            addObject(key);
+                        } catch (final Exception e) {
+                            swallowException(e);
+                        }
+                    }
+                    return;
+                }
+            }
+
+            try {
+                factory.passivateObject(key, p);
+            } catch (final Exception e1) {
+                swallowException(e1);
                 try {
                     destroy(key, p, true);
-                } catch (Exception e) {
+                } catch (final Exception e) {
                     swallowException(e);
                 }
                 if (objectDeque.idleObjects.hasTakeWaiters()) {
                     try {
                         addObject(key);
-                    } catch (Exception e) {
+                    } catch (final Exception e) {
                         swallowException(e);
                     }
                 }
-                updateStatsReturn(activeTime);
                 return;
             }
-        }
 
-        try {
-            factory.passivateObject(key, p);
-        } catch (Exception e1) {
-            swallowException(e1);
-            try {
-                destroy(key, p, true);
-            } catch (Exception e) {
-                swallowException(e);
+            if (!p.deallocate()) {
+                throw new IllegalStateException(
+                        "Object has already been returned to this pool");
             }
-            if (objectDeque.idleObjects.hasTakeWaiters()) {
+
+            final int maxIdle = getMaxIdlePerKey();
+            final LinkedBlockingDeque<PooledObject<T>> idleObjects =
+                objectDeque.getIdleObjects();
+
+            if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
                 try {
-                    addObject(key);
-                } catch (Exception e) {
+                    destroy(key, p, true);
+                } catch (final Exception e) {
                     swallowException(e);
                 }
-            }
-            updateStatsReturn(activeTime);
-            return;
-        }
-
-        if (!p.deallocate()) {
-            throw new IllegalStateException(
-                    "Object has already been returned to this pool");
-        }
-
-        int maxIdle = getMaxIdlePerKey();
-        LinkedBlockingDeque<PooledObject<T>> idleObjects =
-            objectDeque.getIdleObjects();
-
-        if (isClosed() || maxIdle > -1 && maxIdle <= idleObjects.size()) {
-            try {
-                destroy(key, p, true);
-            } catch (Exception e) {
-                swallowException(e);
-            }
-        } else {
-            if (getLifo()) {
-                idleObjects.addFirst(p);
             } else {
-                idleObjects.addLast(p);
+                if (getLifo()) {
+                    idleObjects.addFirst(p);
+                } else {
+                    idleObjects.addLast(p);
+                }
+                if (isClosed()) {
+                    // Pool closed while object was being added to idle objects.
+                    // Make sure the returned object is destroyed rather than left
+                    // in the idle object pool (which would effectively be a leak)
+                    clear(key);
+                }
             }
-            if (isClosed()) {
-                // Pool closed while object was being added to idle objects.
-                // Make sure the returned object is destroyed rather than left
-                // in the idle object pool (which would effectively be a leak)
-                clear(key);
+        } finally {
+            if (hasBorrowWaiters()) {
+                reuseCapacity();
             }
+            updateStatsReturn(activeTime);
         }
-
-        if (hasBorrowWaiters()) {
-            reuseCapacity();
-        }
-
-        updateStatsReturn(activeTime);
     }
 
 
@@ -577,11 +566,11 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      *                               under the given key
      */
     @Override
-    public void invalidateObject(K key, T obj) throws Exception {
+    public void invalidateObject(final K key, final T obj) throws Exception {
 
-        ObjectDeque<T> objectDeque = poolMap.get(key);
+        final ObjectDeque<T> objectDeque = poolMap.get(key);
 
-        PooledObject<T> p = objectDeque.getAllObjects().get(new IdentityWrapper<>(obj));
+        final PooledObject<T> p = objectDeque.getAllObjects().get(new IdentityWrapper<>(obj));
         if (p == null) {
             throw new IllegalStateException(
                     "Object not currently part of this pool");
@@ -618,7 +607,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      */
     @Override
     public void clear() {
-        Iterator<K> iter = poolMap.keySet().iterator();
+        final Iterator<K> iter = poolMap.keySet().iterator();
 
         while (iter.hasNext()) {
             clear(iter.next());
@@ -635,12 +624,12 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      * @param key the key to clear
      */
     @Override
-    public void clear(K key) {
+    public void clear(final K key) {
 
-        ObjectDeque<T> objectDeque = register(key);
+        final ObjectDeque<T> objectDeque = register(key);
 
         try {
-            LinkedBlockingDeque<PooledObject<T>> idleObjects =
+            final LinkedBlockingDeque<PooledObject<T>> idleObjects =
                     objectDeque.getIdleObjects();
 
             PooledObject<T> p = idleObjects.poll();
@@ -648,7 +637,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
             while (p != null) {
                 try {
                     destroy(key, p, true);
-                } catch (Exception e) {
+                } catch (final Exception e) {
                     swallowException(e);
                 }
                 p = idleObjects.poll();
@@ -667,7 +656,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
 
     @Override
     public int getNumIdle() {
-        Iterator<ObjectDeque<T>> iter = poolMap.values().iterator();
+        final Iterator<ObjectDeque<T>> iter = poolMap.values().iterator();
         int result = 0;
 
         while (iter.hasNext()) {
@@ -679,7 +668,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
 
 
     @Override
-    public int getNumActive(K key) {
+    public int getNumActive(final K key) {
         final ObjectDeque<T> objectDeque = poolMap.get(key);
         if (objectDeque != null) {
             return objectDeque.getAllObjects().size() -
@@ -690,7 +679,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
 
 
     @Override
-    public int getNumIdle(K key) {
+    public int getNumIdle(final K key) {
         final ObjectDeque<T> objectDeque = poolMap.get(key);
         return objectDeque != null ? objectDeque.getIdleObjects().size() : 0;
     }
@@ -727,7 +716,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
             jmxUnregister();
 
             // Release any threads that were waiting for an object
-            Iterator<ObjectDeque<T>> iter = poolMap.values().iterator();
+            final Iterator<ObjectDeque<T>> iter = poolMap.values().iterator();
             while (iter.hasNext()) {
                 iter.next().getIdleObjects().interuptTakeWaiters();
             }
@@ -747,14 +736,15 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
         // build sorted map of idle objects
         final Map<PooledObject<T>, K> map = new TreeMap<>();
 
-        for (K k : poolMap.keySet()) {
-            ObjectDeque<T> queue = poolMap.get(k);
+        for (Map.Entry<K, ObjectDeque<T>> entry : poolMap.entrySet()) {
+            final K k = entry.getKey();
+            final ObjectDeque<T> deque = entry.getValue();
             // Protect against possible NPE if key has been removed in another
             // thread. Not worth locking the keys while this loop completes.
-            if (queue != null) {
+            if (deque != null) {
                 final LinkedBlockingDeque<PooledObject<T>> idleObjects =
-                    queue.getIdleObjects();
-                for (PooledObject<T> p : idleObjects) {
+                        deque.getIdleObjects();
+                for (final PooledObject<T> p : idleObjects) {
                     // each item into the map using the PooledObject object as the
                     // key. It then gets sorted based on the idle time
                     map.put(p, k);
@@ -765,22 +755,22 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
         // Now iterate created map and kill the first 15% plus one to account
         // for zero
         int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
-        Iterator<Map.Entry<PooledObject<T>, K>> iter =
+        final Iterator<Map.Entry<PooledObject<T>, K>> iter =
             map.entrySet().iterator();
 
         while (iter.hasNext() && itemsToRemove > 0) {
-            Map.Entry<PooledObject<T>, K> entry = iter.next();
+            final Map.Entry<PooledObject<T>, K> entry = iter.next();
             // kind of backwards on naming.  In the map, each key is the
             // PooledObject because it has the ordering with the timestamp
             // value.  Each value that the key references is the key of the
             // list it belongs to.
-            K key = entry.getValue();
-            PooledObject<T> p = entry.getKey();
+            final K key = entry.getValue();
+            final PooledObject<T> p = entry.getKey();
             // Assume the destruction succeeds
             boolean destroyed = true;
             try {
                 destroyed = destroy(key, p, false);
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 swallowException(e);
             }
             if (destroyed) {
@@ -809,8 +799,9 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
         int maxQueueLength = 0;
         LinkedBlockingDeque<PooledObject<T>> mostLoaded = null;
         K loadedKey = null;
-        for (K k : poolMap.keySet()) {
-            final ObjectDeque<T> deque = poolMap.get(k);
+        for (Map.Entry<K, ObjectDeque<T>> entry : poolMap.entrySet()) {
+            final K k = entry.getKey();
+            final ObjectDeque<T> deque = entry.getValue();
             if (deque != null) {
                 final LinkedBlockingDeque<PooledObject<T>> pool = deque.getIdleObjects();
                 final int queueLength = pool.getTakeQueueLength();
@@ -826,11 +817,11 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
         if (mostLoaded != null) {
             register(loadedKey);
             try {
-                PooledObject<T> p = create(loadedKey);
+                final PooledObject<T> p = create(loadedKey);
                 if (p != null) {
                     addIdleObject(loadedKey, p);
                 }
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 swallowException(e);
             } finally {
                 deregister(loadedKey);
@@ -846,8 +837,8 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      *         {@code false}
      */
     private boolean hasBorrowWaiters() {
-        for (K k : poolMap.keySet()) {
-            final ObjectDeque<T> deque = poolMap.get(k);
+        for (Map.Entry<K, ObjectDeque<T>> entry : poolMap.entrySet()) {
+            final ObjectDeque<T> deque = entry.getValue();
             if (deque != null) {
                 final LinkedBlockingDeque<PooledObject<T>> pool =
                     deque.getIdleObjects();
@@ -876,22 +867,22 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
         }
 
         PooledObject<T> underTest = null;
-        EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
+        final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
 
         synchronized (evictionLock) {
-            EvictionConfig evictionConfig = new EvictionConfig(
+            final EvictionConfig evictionConfig = new EvictionConfig(
                     getMinEvictableIdleTimeMillis(),
                     getSoftMinEvictableIdleTimeMillis(),
                     getMinIdlePerKey());
 
-            boolean testWhileIdle = getTestWhileIdle();
+            final boolean testWhileIdle = getTestWhileIdle();
 
             for (int i = 0, m = getNumTests(); i < m; i++) {
                 if(evictionIterator == null || !evictionIterator.hasNext()) {
                     if (evictionKeyIterator == null ||
                             !evictionKeyIterator.hasNext()) {
-                        List<K> keyCopy = new ArrayList<>();
-                        Lock readLock = keyLock.readLock();
+                        final List<K> keyCopy = new ArrayList<>();
+                        final Lock readLock = keyLock.readLock();
                         readLock.lock();
                         try {
                             keyCopy.addAll(poolKeyList);
@@ -902,7 +893,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
                     }
                     while (evictionKeyIterator.hasNext()) {
                         evictionKey = evictionKeyIterator.next();
-                        ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
+                        final ObjectDeque<T> objectDeque = poolMap.get(evictionKey);
                         if (objectDeque == null) {
                             continue;
                         }
@@ -923,7 +914,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
                 try {
                     underTest = evictionIterator.next();
                     idleObjects = evictionIterator.getIdleObjects();
-                } catch (NoSuchElementException nsee) {
+                } catch (final NoSuchElementException nsee) {
                     // Object was borrowed in another thread
                     // Don't count this as an eviction test so reduce i;
                     i--;
@@ -945,7 +936,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
                 try {
                     evict = evictionPolicy.evict(evictionConfig, underTest,
                             poolMap.get(evictionKey).getIdleObjects().size());
-                } catch (Throwable t) {
+                } catch (final Throwable t) {
                     // Slightly convoluted as SwallowedExceptionListener uses
                     // Exception rather than Throwable
                     PoolUtils.checkRethrow(t);
@@ -963,7 +954,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
                         try {
                             factory.activateObject(evictionKey, underTest);
                             active = true;
-                        } catch (Exception e) {
+                        } catch (final Exception e) {
                             destroy(evictionKey, underTest, true);
                             destroyedByEvictorCount.incrementAndGet();
                         }
@@ -974,7 +965,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
                             } else {
                                 try {
                                     factory.passivateObject(evictionKey, underTest);
-                                } catch (Exception e) {
+                                } catch (final Exception e) {
                                     destroy(evictionKey, underTest, true);
                                     destroyedByEvictorCount.incrementAndGet();
                                 }
@@ -999,15 +990,20 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      *
      * @throws Exception If the objection creation fails
      */
-    private PooledObject<T> create(K key) throws Exception {
+    private PooledObject<T> create(final K key) throws Exception {
         int maxTotalPerKeySave = getMaxTotalPerKey(); // Per key
-        int maxTotal = getMaxTotal();   // All keys
+        if (maxTotalPerKeySave < 0) {
+            maxTotalPerKeySave = Integer.MAX_VALUE;
+        }
+        final int maxTotal = getMaxTotal();   // All keys
+
+        final ObjectDeque<T> objectDeque = poolMap.get(key);
 
         // Check against the overall limit
         boolean loop = true;
 
         while (loop) {
-            int newNumTotal = numTotal.incrementAndGet();
+            final int newNumTotal = numTotal.incrementAndGet();
             if (maxTotal > -1 && newNumTotal > maxTotal) {
                 numTotal.decrementAndGet();
                 if (getNumIdle() == 0) {
@@ -1019,25 +1015,58 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
             }
         }
 
-        ObjectDeque<T> objectDeque = poolMap.get(key);
-        long newCreateCount = objectDeque.getCreateCount().incrementAndGet();
+        // Flag that indicates if create should:
+        // - TRUE:  call the factory to create an object
+        // - FALSE: return null
+        // - null:  loop and re-test the condition that determines whether to
+        //          call the factory
+        Boolean create = null;
+        while (create == null) {
+            synchronized (objectDeque.makeObjectCountLock) {
+                final long newCreateCount = objectDeque.getCreateCount().incrementAndGet();
+                // Check against the per key limit
+                if (newCreateCount > maxTotalPerKeySave) {
+                    // The key is currently at capacity or in the process of
+                    // making enough new objects to take it to capacity.
+                    objectDeque.getCreateCount().decrementAndGet();
+                    if (objectDeque.makeObjectCount == 0) {
+                        // There are no makeObject() calls in progress for this
+                        // key so the key is at capacity. Do not attempt to
+                        // create a new object. Return and wait for an object to
+                        // be returned.
+                        create = Boolean.FALSE;
+                    } else {
+                        // There are makeObject() calls in progress that might
+                        // bring the pool to capacity. Those calls might also
+                        // fail so wait until they complete and then re-test if
+                        // the pool is at capacity or not.
+                        objectDeque.makeObjectCountLock.wait();
+                    }
+                } else {
+                    // The pool is not at capacity. Create a new object.
+                    objectDeque.makeObjectCount++;
+                    create = Boolean.TRUE;
+                }
+            }
+        }
 
-        // Check against the per key limit
-        if (maxTotalPerKeySave > -1 && newCreateCount > maxTotalPerKeySave ||
-                newCreateCount > Integer.MAX_VALUE) {
+        if (!create.booleanValue()) {
             numTotal.decrementAndGet();
-            objectDeque.getCreateCount().decrementAndGet();
             return null;
         }
 
-
         PooledObject<T> p = null;
         try {
             p = factory.makeObject(key);
-        } catch (Exception e) {
+        } catch (final Exception e) {
             numTotal.decrementAndGet();
             objectDeque.getCreateCount().decrementAndGet();
             throw e;
+        } finally {
+            synchronized (objectDeque.makeObjectCountLock) {
+                objectDeque.makeObjectCount--;
+                objectDeque.makeObjectCountLock.notifyAll();
+            }
         }
 
         createdCount.incrementAndGet();
@@ -1055,13 +1084,13 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      * @return {@code true} if the object was destroyed, otherwise {@code false}
      * @throws Exception If the object destruction failed
      */
-    private boolean destroy(K key, PooledObject<T> toDestroy, boolean always)
+    private boolean destroy(final K key, final PooledObject<T> toDestroy, final boolean always)
             throws Exception {
 
-        ObjectDeque<T> objectDeque = register(key);
+        final ObjectDeque<T> objectDeque = register(key);
 
         try {
-            boolean isIdle = objectDeque.getIdleObjects().remove(toDestroy);
+            final boolean isIdle = objectDeque.getIdleObjects().remove(toDestroy);
 
             if (isIdle || always) {
                 objectDeque.getAllObjects().remove(new IdentityWrapper<>(toDestroy.getObject()));
@@ -1094,7 +1123,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      *         method returns without throwing an exception then it will never
      *         return null.
      */
-    private ObjectDeque<T> register(K k) {
+    private ObjectDeque<T> register(final K k) {
         Lock lock = keyLock.readLock();
         ObjectDeque<T> objectDeque = null;
         try {
@@ -1133,14 +1162,14 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      *
      * @param k The key to de-register
      */
-    private void deregister(K k) {
+    private void deregister(final K k) {
         ObjectDeque<T> objectDeque;
 
         objectDeque = poolMap.get(k);
-        long numInterested = objectDeque.getNumInterested().decrementAndGet();
+        final long numInterested = objectDeque.getNumInterested().decrementAndGet();
         if (numInterested == 0 && objectDeque.getCreateCount().get() == 0) {
             // Potential to remove key
-            Lock writeLock = keyLock.writeLock();
+            final Lock writeLock = keyLock.writeLock();
             writeLock.lock();
             try {
                 if (objectDeque.getCreateCount().get() == 0 &&
@@ -1159,12 +1188,12 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
 
     @Override
     void ensureMinIdle() throws Exception {
-        int minIdlePerKeySave = getMinIdlePerKey();
+        final int minIdlePerKeySave = getMinIdlePerKey();
         if (minIdlePerKeySave < 1) {
             return;
         }
 
-        for (K k : poolMap.keySet()) {
+        for (final K k : poolMap.keySet()) {
             ensureMinIdle(k);
         }
     }
@@ -1177,9 +1206,9 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      *
      * @throws Exception If a new object is required and cannot be created
      */
-    private void ensureMinIdle(K key) throws Exception {
+    private void ensureMinIdle(final K key) throws Exception {
         // Calculate current pool objects
-        ObjectDeque<T> objectDeque = poolMap.get(key);
+        final ObjectDeque<T> objectDeque = poolMap.get(key);
 
         // objectDeque == null is OK here. It is handled correctly by both
         // methods called below.
@@ -1189,7 +1218,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
         // as a loop limit and a second time inside the loop
         // to stop when another thread already returned the
         // needed objects
-        int deficit = calculateDeficit(objectDeque);
+        final int deficit = calculateDeficit(objectDeque);
 
         for (int i = 0; i < deficit && calculateDeficit(objectDeque) > 0; i++) {
             addObject(key);
@@ -1208,11 +1237,11 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      *                   fails.
      */
     @Override
-    public void addObject(K key) throws Exception {
+    public void addObject(final K key) throws Exception {
         assertOpen();
         register(key);
         try {
-            PooledObject<T> p = create(key);
+            final PooledObject<T> p = create(key);
             addIdleObject(key, p);
         } finally {
             deregister(key);
@@ -1227,11 +1256,11 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      *
      * @throws Exception If the associated factory fails to passivate the object
      */
-    private void addIdleObject(K key, PooledObject<T> p) throws Exception {
+    private void addIdleObject(final K key, final PooledObject<T> p) throws Exception {
 
         if (p != null) {
             factory.passivateObject(key, p);
-            LinkedBlockingDeque<PooledObject<T>> idleObjects =
+            final LinkedBlockingDeque<PooledObject<T>> idleObjects =
                     poolMap.get(key).getIdleObjects();
             if (getLifo()) {
                 idleObjects.addFirst(p);
@@ -1249,8 +1278,8 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      *
      * @throws Exception If the associated factory throws an exception
      */
-    public void preparePool(K key) throws Exception {
-        int minIdlePerKeySave = getMinIdlePerKey();
+    public void preparePool(final K key) throws Exception {
+        final int minIdlePerKeySave = getMinIdlePerKey();
         if (minIdlePerKeySave < 1) {
             return;
         }
@@ -1264,8 +1293,8 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      * @return The number of objects to test for validity
      */
     private int getNumTests() {
-        int totalIdle = getNumIdle();
-        int numTests = getNumTestsPerEvictionRun();
+        final int totalIdle = getNumIdle();
+        final int numTests = getNumTestsPerEvictionRun();
         if (numTests >= 0) {
             return Math.min(numTests, totalIdle);
         }
@@ -1281,15 +1310,15 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      *
      * @return The number of new objects to create
      */
-    private int calculateDeficit(ObjectDeque<T> objectDeque) {
+    private int calculateDeficit(final ObjectDeque<T> objectDeque) {
 
         if (objectDeque == null) {
             return getMinIdlePerKey();
         }
 
         // Used more than once so keep a local copy so the value is consistent
-        int maxTotal = getMaxTotal();
-        int maxTotalPerKeySave = getMaxTotalPerKey();
+        final int maxTotal = getMaxTotal();
+        final int maxTotalPerKeySave = getMaxTotalPerKey();
 
         int objectDefecit = 0;
 
@@ -1297,14 +1326,14 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
         // the number of pooled objects < maxTotalPerKey();
         objectDefecit = getMinIdlePerKey() - objectDeque.getIdleObjects().size();
         if (maxTotalPerKeySave > 0) {
-            int growLimit = Math.max(0,
+            final int growLimit = Math.max(0,
                     maxTotalPerKeySave - objectDeque.getIdleObjects().size());
             objectDefecit = Math.min(objectDefecit, growLimit);
         }
 
         // Take the maxTotal limit into account
         if (maxTotal > 0) {
-            int growLimit = Math.max(0, maxTotal - getNumActive() - getNumIdle());
+            final int growLimit = Math.max(0, maxTotal - getNumActive() - getNumIdle());
             objectDefecit = Math.min(objectDefecit, growLimit);
         }
 
@@ -1316,14 +1345,14 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
 
     @Override
     public Map<String,Integer> getNumActivePerKey() {
-        HashMap<String,Integer> result = new HashMap<>();
+        final HashMap<String,Integer> result = new HashMap<>();
 
-        Iterator<Entry<K,ObjectDeque<T>>> iter = poolMap.entrySet().iterator();
+        final Iterator<Entry<K,ObjectDeque<T>>> iter = poolMap.entrySet().iterator();
         while (iter.hasNext()) {
-            Entry<K,ObjectDeque<T>> entry = iter.next();
+            final Entry<K,ObjectDeque<T>> entry = iter.next();
             if (entry != null) {
-                K key = entry.getKey();
-                ObjectDeque<T> objectDequeue = entry.getValue();
+                final K key = entry.getKey();
+                final ObjectDeque<T> objectDequeue = entry.getValue();
                 if (key != null && objectDequeue != null) {
                     result.put(key.toString(), Integer.valueOf(
                             objectDequeue.getAllObjects().size() -
@@ -1347,7 +1376,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
         int result = 0;
 
         if (getBlockWhenExhausted()) {
-            Iterator<ObjectDeque<T>> iter = poolMap.values().iterator();
+            final Iterator<ObjectDeque<T>> iter = poolMap.values().iterator();
 
             while (iter.hasNext()) {
                 // Assume no overflow
@@ -1368,16 +1397,17 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      */
     @Override
     public Map<String,Integer> getNumWaitersByKey() {
-        Map<String,Integer> result = new HashMap<>();
+        final Map<String,Integer> result = new HashMap<>();
 
-        for (K key : poolMap.keySet()) {
-            ObjectDeque<T> queue = poolMap.get(key);
-            if (queue != null) {
+        for (Map.Entry<K, ObjectDeque<T>> entry : poolMap.entrySet()) {
+            final K k = entry.getKey();
+            final ObjectDeque<T> deque = entry.getValue();
+            if (deque != null) {
                 if (getBlockWhenExhausted()) {
-                    result.put(key.toString(), Integer.valueOf(
-                            queue.getIdleObjects().getTakeQueueLength()));
+                    result.put(k.toString(), Integer.valueOf(
+                            deque.getIdleObjects().getTakeQueueLength()));
                 } else {
-                    result.put(key.toString(), Integer.valueOf(0));
+                    result.put(k.toString(), Integer.valueOf(0));
                 }
             }
         }
@@ -1397,16 +1427,17 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
      */
     @Override
     public Map<String,List<DefaultPooledObjectInfo>> listAllObjects() {
-        Map<String,List<DefaultPooledObjectInfo>> result =
+        final Map<String,List<DefaultPooledObjectInfo>> result =
                 new HashMap<>();
 
-        for (K key : poolMap.keySet()) {
-            ObjectDeque<T> queue = poolMap.get(key);
-            if (queue != null) {
-                List<DefaultPooledObjectInfo> list =
+        for (Map.Entry<K, ObjectDeque<T>> entry : poolMap.entrySet()) {
+            final K k = entry.getKey();
+            final ObjectDeque<T> deque = entry.getValue();
+            if (deque != null) {
+                final List<DefaultPooledObjectInfo> list =
                         new ArrayList<>();
-                result.put(key.toString(), list);
-                for (PooledObject<T> p : queue.getAllObjects().values()) {
+                result.put(k.toString(), list);
+                for (final PooledObject<T> p : deque.getAllObjects().values()) {
                     list.add(new DefaultPooledObjectInfo(p));
                 }
             }
@@ -1430,6 +1461,9 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
          */
         private final AtomicInteger createCount = new AtomicInteger(0);
 
+        private long makeObjectCount = 0;
+        private final Object makeObjectCountLock = new Object();
+
         /*
          * The map is keyed on pooled instances, wrapped to ensure that
          * they work properly as keys.
@@ -1450,7 +1484,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
          * @param fairness true means client threads waiting to borrow / return instances
          * will be served as if waiting in a FIFO queue.
          */
-        public ObjectDeque(boolean fairness) {
+        public ObjectDeque(final boolean fairness) {
             idleObjects = new LinkedBlockingDeque<>(fairness);
         }
 
@@ -1493,7 +1527,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
 
         @Override
         public String toString() {
-            StringBuilder builder = new StringBuilder();
+            final StringBuilder builder = new StringBuilder();
             builder.append("ObjectDeque [idleObjects=");
             builder.append(idleObjects);
             builder.append(", createCount=");
@@ -1551,7 +1585,7 @@ public class GenericKeyedObjectPool<K,T> extends BaseGenericObjectPool<T>
         "org.apache.tomcat.dbcp.pool2:type=GenericKeyedObjectPool,name=";
 
     @Override
-    protected void toStringAppendFields(StringBuilder builder) {
+    protected void toStringAppendFields(final StringBuilder builder) {
         super.toStringAppendFields(builder);
         builder.append(", maxIdlePerKey=");
         builder.append(maxIdlePerKey);

==================================================
GenericObjectPool.java
index 8eacd914d3..dc40035955 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPoolConfig.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPoolConfig.java
@@ -89,7 +89,7 @@ public class GenericKeyedObjectPoolConfig extends BaseObjectPoolConfig {
      *
      * @see GenericKeyedObjectPool#setMaxTotal(int)
      */
-    public void setMaxTotal(int maxTotal) {
+    public void setMaxTotal(final int maxTotal) {
         this.maxTotal = maxTotal;
     }
 
@@ -115,7 +115,7 @@ public class GenericKeyedObjectPoolConfig extends BaseObjectPoolConfig {
      *
      * @see GenericKeyedObjectPool#setMaxTotalPerKey(int)
      */
-    public void setMaxTotalPerKey(int maxTotalPerKey) {
+    public void setMaxTotalPerKey(final int maxTotalPerKey) {
         this.maxTotalPerKey = maxTotalPerKey;
     }
 
@@ -141,7 +141,7 @@ public class GenericKeyedObjectPoolConfig extends BaseObjectPoolConfig {
      *
      * @see GenericKeyedObjectPool#setMinIdlePerKey(int)
      */
-    public void setMinIdlePerKey(int minIdlePerKey) {
+    public void setMinIdlePerKey(final int minIdlePerKey) {
         this.minIdlePerKey = minIdlePerKey;
     }
 
@@ -167,7 +167,7 @@ public class GenericKeyedObjectPoolConfig extends BaseObjectPoolConfig {
      *
      * @see GenericKeyedObjectPool#setMaxIdlePerKey(int)
      */
-    public void setMaxIdlePerKey(int maxIdlePerKey) {
+    public void setMaxIdlePerKey(final int maxIdlePerKey) {
         this.maxIdlePerKey = maxIdlePerKey;
     }
 
@@ -175,13 +175,13 @@ public class GenericKeyedObjectPoolConfig extends BaseObjectPoolConfig {
     public GenericKeyedObjectPoolConfig clone() {
         try {
             return (GenericKeyedObjectPoolConfig) super.clone();
-        } catch (CloneNotSupportedException e) {
+        } catch (final CloneNotSupportedException e) {
             throw new AssertionError(); // Can't happen
         }
     }
 
     @Override
-    protected void toStringAppendFields(StringBuilder builder) {
+    protected void toStringAppendFields(final StringBuilder builder) {
         super.toStringAppendFields(builder);
         builder.append(", minIdlePerKey=");
         builder.append(minIdlePerKey);

==================================================
GenericObjectPoolConfig.java
index d3bed4f18c..3e4975707b 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java
@@ -83,7 +83,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      * @param factory The object factory to be used to create object instances
      *                used by this pool
      */
-    public GenericObjectPool(PooledObjectFactory<T> factory) {
+    public GenericObjectPool(final PooledObjectFactory<T> factory) {
         this(factory, new GenericObjectPoolConfig());
     }
 
@@ -98,8 +98,8 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      *                  the configuration object will not be reflected in the
      *                  pool.
      */
-    public GenericObjectPool(PooledObjectFactory<T> factory,
-            GenericObjectPoolConfig config) {
+    public GenericObjectPool(final PooledObjectFactory<T> factory,
+            final GenericObjectPoolConfig config) {
 
         super(config, ONAME_BASE, config.getJmxNamePrefix());
 
@@ -129,8 +129,8 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      * @param abandonedConfig  Configuration for abandoned object identification
      *                         and removal.  The configuration is used by value.
      */
-    public GenericObjectPool(PooledObjectFactory<T> factory,
-            GenericObjectPoolConfig config, AbandonedConfig abandonedConfig) {
+    public GenericObjectPool(final PooledObjectFactory<T> factory,
+            final GenericObjectPoolConfig config, final AbandonedConfig abandonedConfig) {
         this(factory, config);
         setAbandonedConfig(abandonedConfig);
     }
@@ -170,7 +170,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      *
      * @see #getMaxIdle
      */
-    public void setMaxIdle(int maxIdle) {
+    public void setMaxIdle(final int maxIdle) {
         this.maxIdle = maxIdle;
     }
 
@@ -191,7 +191,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      * @see #getMaxIdle()
      * @see #getTimeBetweenEvictionRunsMillis()
      */
-    public void setMinIdle(int minIdle) {
+    public void setMinIdle(final int minIdle) {
         this.minIdle = minIdle;
     }
 
@@ -213,7 +213,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      */
     @Override
     public int getMinIdle() {
-        int maxIdleSave = getMaxIdle();
+        final int maxIdleSave = getMaxIdle();
         if (this.minIdle > maxIdleSave) {
             return maxIdleSave;
         }
@@ -241,7 +241,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      */
     @Override
     public boolean getLogAbandoned() {
-        AbandonedConfig ac = this.abandonedConfig;
+        final AbandonedConfig ac = this.abandonedConfig;
         return ac != null && ac.getLogAbandoned();
     }
 
@@ -256,7 +256,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      */
     @Override
     public boolean getRemoveAbandonedOnBorrow() {
-        AbandonedConfig ac = this.abandonedConfig;
+        final AbandonedConfig ac = this.abandonedConfig;
         return ac != null && ac.getRemoveAbandonedOnBorrow();
     }
 
@@ -270,7 +270,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      */
     @Override
     public boolean getRemoveAbandonedOnMaintenance() {
-        AbandonedConfig ac = this.abandonedConfig;
+        final AbandonedConfig ac = this.abandonedConfig;
         return ac != null && ac.getRemoveAbandonedOnMaintenance();
     }
 
@@ -285,7 +285,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      */
     @Override
     public int getRemoveAbandonedTimeout() {
-        AbandonedConfig ac = this.abandonedConfig;
+        final AbandonedConfig ac = this.abandonedConfig;
         return ac != null ? ac.getRemoveAbandonedTimeout() : Integer.MAX_VALUE;
     }
 
@@ -297,7 +297,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      *
      * @see GenericObjectPoolConfig
      */
-    public void setConfig(GenericObjectPoolConfig conf) {
+    public void setConfig(final GenericObjectPoolConfig conf) {
         setLifo(conf.getLifo());
         setMaxIdle(conf.getMaxIdle());
         setMinIdle(conf.getMinIdle());
@@ -324,7 +324,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      *
      * @see AbandonedConfig
      */
-    public void setAbandonedConfig(AbandonedConfig abandonedConfig) {
+    public void setAbandonedConfig(final AbandonedConfig abandonedConfig) {
         if (abandonedConfig == null) {
             this.abandonedConfig = null;
         } else {
@@ -404,10 +404,10 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      * @throws Exception if an object instance cannot be returned due to an
      *                   error
      */
-    public T borrowObject(long borrowMaxWaitMillis) throws Exception {
+    public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
         assertOpen();
 
-        AbandonedConfig ac = this.abandonedConfig;
+        final AbandonedConfig ac = this.abandonedConfig;
         if (ac != null && ac.getRemoveAbandonedOnBorrow() &&
                 (getNumIdle() < 2) &&
                 (getNumActive() > getMaxTotal() - 3) ) {
@@ -418,21 +418,21 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
 
         // Get local copy of current config so it is consistent for entire
         // method execution
-        boolean blockWhenExhausted = getBlockWhenExhausted();
+        final boolean blockWhenExhausted = getBlockWhenExhausted();
 
         boolean create;
-        long waitTime = System.currentTimeMillis();
+        final long waitTime = System.currentTimeMillis();
 
         while (p == null) {
             create = false;
-            if (blockWhenExhausted) {
-                p = idleObjects.pollFirst();
-                if (p == null) {
-                    p = create();
-                    if (p != null) {
-                        create = true;
-                    }
+            p = idleObjects.pollFirst();
+            if (p == null) {
+                p = create();
+                if (p != null) {
+                    create = true;
                 }
+            }
+            if (blockWhenExhausted) {
                 if (p == null) {
                     if (borrowMaxWaitMillis < 0) {
                         p = idleObjects.takeFirst();
@@ -445,37 +445,27 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
                     throw new NoSuchElementException(
                             "Timeout waiting for idle object");
                 }
-                if (!p.allocate()) {
-                    p = null;
-                }
             } else {
-                p = idleObjects.pollFirst();
-                if (p == null) {
-                    p = create();
-                    if (p != null) {
-                        create = true;
-                    }
-                }
                 if (p == null) {
                     throw new NoSuchElementException("Pool exhausted");
                 }
-                if (!p.allocate()) {
-                    p = null;
-                }
+            }
+            if (!p.allocate()) {
+                p = null;
             }
 
             if (p != null) {
                 try {
                     factory.activateObject(p);
-                } catch (Exception e) {
+                } catch (final Exception e) {
                     try {
                         destroy(p);
-                    } catch (Exception e1) {
+                    } catch (final Exception e1) {
                         // Ignore - activation failure is more important
                     }
                     p = null;
                     if (create) {
-                        NoSuchElementException nsee = new NoSuchElementException(
+                        final NoSuchElementException nsee = new NoSuchElementException(
                                 "Unable to activate object");
                         nsee.initCause(e);
                         throw nsee;
@@ -486,7 +476,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
                     Throwable validationThrowable = null;
                     try {
                         validate = factory.validateObject(p);
-                    } catch (Throwable t) {
+                    } catch (final Throwable t) {
                         PoolUtils.checkRethrow(t);
                         validationThrowable = t;
                     }
@@ -494,12 +484,12 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
                         try {
                             destroy(p);
                             destroyedByBorrowValidationCount.incrementAndGet();
-                        } catch (Exception e) {
+                        } catch (final Exception e) {
                             // Ignore - validation failure is more important
                         }
                         p = null;
                         if (create) {
-                            NoSuchElementException nsee = new NoSuchElementException(
+                            final NoSuchElementException nsee = new NoSuchElementException(
                                     "Unable to validate object");
                             nsee.initCause(validationThrowable);
                             throw nsee;
@@ -530,8 +520,8 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      * {@link org.apache.tomcat.dbcp.pool2.SwallowedExceptionListener}.
      */
     @Override
-    public void returnObject(T obj) {
-        PooledObject<T> p = allObjects.get(new IdentityWrapper<>(obj));
+    public void returnObject(final T obj) {
+        final PooledObject<T> p = allObjects.get(new IdentityWrapper<>(obj));
 
         if (p == null) {
             if (!isAbandonedConfig()) {
@@ -550,18 +540,18 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
             p.markReturning(); // Keep from being marked abandoned
         }
 
-        long activeTime = p.getActiveTimeMillis();
+        final long activeTime = p.getActiveTimeMillis();
 
         if (getTestOnReturn()) {
             if (!factory.validateObject(p)) {
                 try {
                     destroy(p);
-                } catch (Exception e) {
+                } catch (final Exception e) {
                     swallowException(e);
                 }
                 try {
                     ensureIdle(1, false);
-                } catch (Exception e) {
+                } catch (final Exception e) {
                     swallowException(e);
                 }
                 updateStatsReturn(activeTime);
@@ -571,16 +561,16 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
 
         try {
             factory.passivateObject(p);
-        } catch (Exception e1) {
+        } catch (final Exception e1) {
             swallowException(e1);
             try {
                 destroy(p);
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 swallowException(e);
             }
             try {
                 ensureIdle(1, false);
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 swallowException(e);
             }
             updateStatsReturn(activeTime);
@@ -592,11 +582,11 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
                     "Object has already been returned to this pool or is invalid");
         }
 
-        int maxIdleSave = getMaxIdle();
+        final int maxIdleSave = getMaxIdle();
         if (isClosed() || maxIdleSave > -1 && maxIdleSave <= idleObjects.size()) {
             try {
                 destroy(p);
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 swallowException(e);
             }
         } else {
@@ -626,8 +616,8 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      * @throws IllegalStateException if obj does not belong to this pool
      */
     @Override
-    public void invalidateObject(T obj) throws Exception {
-        PooledObject<T> p = allObjects.get(new IdentityWrapper<>(obj));
+    public void invalidateObject(final T obj) throws Exception {
+        final PooledObject<T> p = allObjects.get(new IdentityWrapper<>(obj));
         if (p == null) {
             if (isAbandonedConfig()) {
                 return;
@@ -668,7 +658,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
         while (p != null) {
             try {
                 destroy(p);
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 swallowException(e);
             }
             p = idleObjects.poll();
@@ -732,15 +722,15 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
         if (idleObjects.size() > 0) {
 
             PooledObject<T> underTest = null;
-            EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
+            final EvictionPolicy<T> evictionPolicy = getEvictionPolicy();
 
             synchronized (evictionLock) {
-                EvictionConfig evictionConfig = new EvictionConfig(
+                final EvictionConfig evictionConfig = new EvictionConfig(
                         getMinEvictableIdleTimeMillis(),
                         getSoftMinEvictableIdleTimeMillis(),
                         getMinIdle());
 
-                boolean testWhileIdle = getTestWhileIdle();
+                final boolean testWhileIdle = getTestWhileIdle();
 
                 for (int i = 0, m = getNumTests(); i < m; i++) {
                     if (evictionIterator == null || !evictionIterator.hasNext()) {
@@ -753,7 +743,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
 
                     try {
                         underTest = evictionIterator.next();
-                    } catch (NoSuchElementException nsee) {
+                    } catch (final NoSuchElementException nsee) {
                         // Object was borrowed in another thread
                         // Don't count this as an eviction test so reduce i;
                         i--;
@@ -775,7 +765,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
                     try {
                         evict = evictionPolicy.evict(evictionConfig, underTest,
                                 idleObjects.size());
-                    } catch (Throwable t) {
+                    } catch (final Throwable t) {
                         // Slightly convoluted as SwallowedExceptionListener uses
                         // Exception rather than Throwable
                         PoolUtils.checkRethrow(t);
@@ -793,7 +783,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
                             try {
                                 factory.activateObject(underTest);
                                 active = true;
-                            } catch (Exception e) {
+                            } catch (final Exception e) {
                                 destroy(underTest);
                                 destroyedByEvictorCount.incrementAndGet();
                             }
@@ -804,7 +794,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
                                 } else {
                                     try {
                                         factory.passivateObject(underTest);
-                                    } catch (Exception e) {
+                                    } catch (final Exception e) {
                                         destroy(underTest);
                                         destroyedByEvictorCount.incrementAndGet();
                                     }
@@ -819,7 +809,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
                 }
             }
         }
-        AbandonedConfig ac = this.abandonedConfig;
+        final AbandonedConfig ac = this.abandonedConfig;
         if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
             removeAbandoned(ac);
         }
@@ -851,10 +841,45 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      */
     private PooledObject<T> create() throws Exception {
         int localMaxTotal = getMaxTotal();
-        long newCreateCount = createCount.incrementAndGet();
-        if (localMaxTotal > -1 && newCreateCount > localMaxTotal ||
-                newCreateCount > Integer.MAX_VALUE) {
-            createCount.decrementAndGet();
+        // This simplifies the code later in this method
+        if (localMaxTotal < 0) {
+            localMaxTotal = Integer.MAX_VALUE;
+        }
+
+        // Flag that indicates if create should:
+        // - TRUE:  call the factory to create an object
+        // - FALSE: return null
+        // - null:  loop and re-test the condition that determines whether to
+        //          call the factory
+        Boolean create = null;
+        while (create == null) {
+            synchronized (makeObjectCountLock) {
+                final long newCreateCount = createCount.incrementAndGet();
+                if (newCreateCount > localMaxTotal) {
+                    // The pool is currently at capacity or in the process of
+                    // making enough new objects to take it to capacity.
+                    createCount.decrementAndGet();
+                    if (makeObjectCount == 0) {
+                        // There are no makeObject() calls in progress so the
+                        // pool is at capacity. Do not attempt to create a new
+                        // object. Return and wait for an object to be returned
+                        create = Boolean.FALSE;
+                    } else {
+                        // There are makeObject() calls in progress that might
+                        // bring the pool to capacity. Those calls might also
+                        // fail so wait until they complete and then re-test if
+                        // the pool is at capacity or not.
+                        makeObjectCountLock.wait();
+                    }
+                } else {
+                    // The pool is not at capacity. Create a new object.
+                    makeObjectCount++;
+                    create = Boolean.TRUE;
+                }
+            }
+        }
+
+        if (!create.booleanValue()) {
             return null;
         }
 
@@ -864,9 +889,14 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
         } catch (Exception e) {
             createCount.decrementAndGet();
             throw e;
+        } finally {
+            synchronized (makeObjectCountLock) {
+                makeObjectCount--;
+                makeObjectCountLock.notifyAll();
+            }
         }
 
-        AbandonedConfig ac = this.abandonedConfig;
+        final AbandonedConfig ac = this.abandonedConfig;
         if (ac != null && ac.getLogAbandoned()) {
             p.setLogAbandoned(true);
         }
@@ -879,17 +909,17 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
     /**
      * Destroys a wrapped pooled object.
      *
-     * @param toDestory The wrapped pooled object to destroy
+     * @param toDestroy The wrapped pooled object to destroy
      *
      * @throws Exception If the factory fails to destroy the pooled object
      *                   cleanly
      */
-    private void destroy(PooledObject<T> toDestory) throws Exception {
-        toDestory.invalidate();
-        idleObjects.remove(toDestory);
-        allObjects.remove(new IdentityWrapper<>(toDestory.getObject()));
+    private void destroy(final PooledObject<T> toDestroy) throws Exception {
+        toDestroy.invalidate();
+        idleObjects.remove(toDestroy);
+        allObjects.remove(new IdentityWrapper<>(toDestroy.getObject()));
         try {
-            factory.destroyObject(toDestory);
+            factory.destroyObject(toDestroy);
         } finally {
             destroyedCount.incrementAndGet();
             createCount.decrementAndGet();
@@ -913,13 +943,13 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      * @param always true means create instances even if the pool has no threads waiting
      * @throws Exception if the factory's makeObject throws
      */
-    private void ensureIdle(int idleCount, boolean always) throws Exception {
+    private void ensureIdle(final int idleCount, final boolean always) throws Exception {
         if (idleCount < 1 || isClosed() || (!always && !idleObjects.hasTakeWaiters())) {
             return;
         }
 
         while (idleObjects.size() < idleCount) {
-            PooledObject<T> p = create();
+            final PooledObject<T> p = create();
             if (p == null) {
                 // Can't create objects, no reason to think another call to
                 // create will work. Give up.
@@ -953,7 +983,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
             throw new IllegalStateException(
                     "Cannot add objects without a factory.");
         }
-        PooledObject<T> p = create();
+        final PooledObject<T> p = create();
         addIdleObject(p);
     }
 
@@ -966,7 +996,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      *
      * @throws Exception If the factory fails to passivate the object
      */
-    private void addIdleObject(PooledObject<T> p) throws Exception {
+    private void addIdleObject(final PooledObject<T> p) throws Exception {
         if (p != null) {
             factory.passivateObject(p);
             if (getLifo()) {
@@ -984,7 +1014,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      * @return The number of objects to test for validity
      */
     private int getNumTests() {
-        int numTestsPerEvictionRun = getNumTestsPerEvictionRun();
+        final int numTestsPerEvictionRun = getNumTestsPerEvictionRun();
         if (numTestsPerEvictionRun >= 0) {
             return Math.min(numTestsPerEvictionRun, idleObjects.size());
         }
@@ -998,15 +1028,15 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      *
      * @param ac The configuration to use to identify abandoned objects
      */
-    private void removeAbandoned(AbandonedConfig ac) {
+    private void removeAbandoned(final AbandonedConfig ac) {
         // Generate a list of abandoned objects to remove
         final long now = System.currentTimeMillis();
         final long timeout =
                 now - (ac.getRemoveAbandonedTimeout() * 1000L);
-        ArrayList<PooledObject<T>> remove = new ArrayList<>();
-        Iterator<PooledObject<T>> it = allObjects.values().iterator();
+        final ArrayList<PooledObject<T>> remove = new ArrayList<>();
+        final Iterator<PooledObject<T>> it = allObjects.values().iterator();
         while (it.hasNext()) {
-            PooledObject<T> pooledObject = it.next();
+            final PooledObject<T> pooledObject = it.next();
             synchronized (pooledObject) {
                 if (pooledObject.getState() == PooledObjectState.ALLOCATED &&
                         pooledObject.getLastUsedTime() <= timeout) {
@@ -1017,15 +1047,15 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
         }
 
         // Now remove the abandoned objects
-        Iterator<PooledObject<T>> itr = remove.iterator();
+        final Iterator<PooledObject<T>> itr = remove.iterator();
         while (itr.hasNext()) {
-            PooledObject<T> pooledObject = itr.next();
+            final PooledObject<T> pooledObject = itr.next();
             if (ac.getLogAbandoned()) {
                 pooledObject.printStackTrace(ac.getLogWriter());
             }
             try {
                 invalidateObject(pooledObject.getObject());
-            } catch (Exception e) {
+            } catch (final Exception e) {
                 e.printStackTrace();
             }
         }
@@ -1035,10 +1065,10 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
     //--- Usage tracking support -----------------------------------------------
 
     @Override
-    public void use(T pooledObject) {
-        AbandonedConfig ac = this.abandonedConfig;
+    public void use(final T pooledObject) {
+        final AbandonedConfig ac = this.abandonedConfig;
         if (ac != null && ac.getUseUsageTracking()) {
-            PooledObject<T> wrapper = allObjects.get(new IdentityWrapper<>(pooledObject));
+            final PooledObject<T> wrapper = allObjects.get(new IdentityWrapper<>(pooledObject));
             wrapper.use();
         }
     }
@@ -1074,10 +1104,10 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
     public String getFactoryType() {
         // Not thread safe. Accept that there may be multiple evaluations.
         if (factoryType == null) {
-            StringBuilder result = new StringBuilder();
+            final StringBuilder result = new StringBuilder();
             result.append(factory.getClass().getName());
             result.append('<');
-            Class<?> pooledObjectType =
+            final Class<?> pooledObjectType =
                     PoolImplUtils.getFactoryType(factory.getClass());
             result.append(pooledObjectType.getName());
             result.append('>');
@@ -1099,9 +1129,9 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      */
     @Override
     public Set<DefaultPooledObjectInfo> listAllObjects() {
-        Set<DefaultPooledObjectInfo> result =
+        final Set<DefaultPooledObjectInfo> result =
                 new HashSet<>(allObjects.size());
-        for (PooledObject<T> p : allObjects.values()) {
+        for (final PooledObject<T> p : allObjects.values()) {
             result.add(new DefaultPooledObjectInfo(p));
         }
         return result;
@@ -1133,6 +1163,8 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
      * {@link #_maxActive} objects created at any one time.
      */
     private final AtomicLong createCount = new AtomicLong(0);
+    private long makeObjectCount = 0;
+    private final Object makeObjectCountLock = new Object();
     private final LinkedBlockingDeque<PooledObject<T>> idleObjects;
 
     // JMX specific attributes
@@ -1143,7 +1175,7 @@ public class GenericObjectPool<T> extends BaseGenericObjectPool<T>
     private volatile AbandonedConfig abandonedConfig = null;
 
     @Override
-    protected void toStringAppendFields(StringBuilder builder) {
+    protected void toStringAppendFields(final StringBuilder builder) {
         super.toStringAppendFields(builder);
         builder.append(", factoryType=");
         builder.append(factoryType);

==================================================
InterruptibleReentrantLock.java
index 3286e0f362..7685c7cd63 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPoolConfig.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPoolConfig.java
@@ -75,7 +75,7 @@ public class GenericObjectPoolConfig extends BaseObjectPoolConfig {
      *
      * @see GenericObjectPool#setMaxTotal(int)
      */
-    public void setMaxTotal(int maxTotal) {
+    public void setMaxTotal(final int maxTotal) {
         this.maxTotal = maxTotal;
     }
 
@@ -102,7 +102,7 @@ public class GenericObjectPoolConfig extends BaseObjectPoolConfig {
      *
      * @see GenericObjectPool#setMaxIdle(int)
      */
-    public void setMaxIdle(int maxIdle) {
+    public void setMaxIdle(final int maxIdle) {
         this.maxIdle = maxIdle;
     }
 
@@ -129,7 +129,7 @@ public class GenericObjectPoolConfig extends BaseObjectPoolConfig {
      *
      * @see GenericObjectPool#setMinIdle(int)
      */
-    public void setMinIdle(int minIdle) {
+    public void setMinIdle(final int minIdle) {
         this.minIdle = minIdle;
     }
 
@@ -137,13 +137,13 @@ public class GenericObjectPoolConfig extends BaseObjectPoolConfig {
     public GenericObjectPoolConfig clone() {
         try {
             return (GenericObjectPoolConfig) super.clone();
-        } catch (CloneNotSupportedException e) {
+        } catch (final CloneNotSupportedException e) {
             throw new AssertionError(); // Can't happen
         }
     }
 
     @Override
-    protected void toStringAppendFields(StringBuilder builder) {
+    protected void toStringAppendFields(final StringBuilder builder) {
         super.toStringAppendFields(builder);
         builder.append(", maxTotal=");
         builder.append(maxTotal);

==================================================
LinkedBlockingDeque.java
index b328ac7afc..5a51b92577 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/InterruptibleReentrantLock.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/InterruptibleReentrantLock.java
@@ -39,7 +39,7 @@ class InterruptibleReentrantLock extends ReentrantLock {
      * @param fairness true means threads should acquire contended locks as if
      * waiting in a FIFO queue
      */
-    public InterruptibleReentrantLock(boolean fairness) {
+    public InterruptibleReentrantLock(final boolean fairness) {
         super(fairness);
     }
 
@@ -48,9 +48,9 @@ class InterruptibleReentrantLock extends ReentrantLock {
      *
      * @param condition the condition on which the threads are waiting.
      */
-    public void interruptWaiters(Condition condition) {
-        Collection<Thread> threads = getWaitingThreads(condition);
-        for (Thread thread : threads) {
+    public void interruptWaiters(final Condition condition) {
+        final Collection<Thread> threads = getWaitingThreads(condition);
+        for (final Thread thread : threads) {
             thread.interrupt();
         }
     }

==================================================
PoolImplUtils.java
index 2367cd0dff..e6c62c3643 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/LinkedBlockingDeque.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/LinkedBlockingDeque.java
@@ -118,7 +118,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
          * @param p Previous item
          * @param n Next item
          */
-        Node(E x, Node<E> p, Node<E> n) {
+        Node(final E x, final Node<E> p, final Node<E> n) {
             item = x;
             prev = p;
             next = n;
@@ -168,7 +168,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @param fairness true means threads waiting on the deque should be served
      * as if waiting in a FIFO request queue
      */
-    public LinkedBlockingDeque(boolean fairness) {
+    public LinkedBlockingDeque(final boolean fairness) {
         this(Integer.MAX_VALUE, fairness);
     }
 
@@ -178,7 +178,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @param capacity the capacity of this deque
      * @throws IllegalArgumentException if {@code capacity} is less than 1
      */
-    public LinkedBlockingDeque(int capacity) {
+    public LinkedBlockingDeque(final int capacity) {
         this(capacity, false);
     }
 
@@ -191,7 +191,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * as if waiting in a FIFO request queue
      * @throws IllegalArgumentException if {@code capacity} is less than 1
      */
-    public LinkedBlockingDeque(int capacity, boolean fairness) {
+    public LinkedBlockingDeque(final int capacity, final boolean fairness) {
         if (capacity <= 0) {
             throw new IllegalArgumentException();
         }
@@ -211,11 +211,11 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @throws NullPointerException if the specified collection or any
      *         of its elements are null
      */
-    public LinkedBlockingDeque(Collection<? extends E> c) {
+    public LinkedBlockingDeque(final Collection<? extends E> c) {
         this(Integer.MAX_VALUE);
         lock.lock(); // Never contended, but necessary for visibility
         try {
-            for (E e : c) {
+            for (final E e : c) {
                 if (e == null) {
                     throw new NullPointerException();
                 }
@@ -238,13 +238,13 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      *
      * @return {@code true} if successful, otherwise {@code false}
      */
-    private boolean linkFirst(E e) {
+    private boolean linkFirst(final E e) {
         // assert lock.isHeldByCurrentThread();
         if (count >= capacity) {
             return false;
         }
-        Node<E> f = first;
-        Node<E> x = new Node<>(e, null, f);
+        final Node<E> f = first;
+        final Node<E> x = new Node<>(e, null, f);
         first = x;
         if (last == null) {
             last = x;
@@ -263,13 +263,13 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      *
      * @return {@code true} if successful, otherwise {@code false}
      */
-    private boolean linkLast(E e) {
+    private boolean linkLast(final E e) {
         // assert lock.isHeldByCurrentThread();
         if (count >= capacity) {
             return false;
         }
-        Node<E> l = last;
-        Node<E> x = new Node<>(e, l, null);
+        final Node<E> l = last;
+        final Node<E> x = new Node<>(e, l, null);
         last = x;
         if (first == null) {
             first = x;
@@ -288,12 +288,12 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      */
     private E unlinkFirst() {
         // assert lock.isHeldByCurrentThread();
-        Node<E> f = first;
+        final Node<E> f = first;
         if (f == null) {
             return null;
         }
-        Node<E> n = f.next;
-        E item = f.item;
+        final Node<E> n = f.next;
+        final E item = f.item;
         f.item = null;
         f.next = f; // help GC
         first = n;
@@ -314,12 +314,12 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      */
     private E unlinkLast() {
         // assert lock.isHeldByCurrentThread();
-        Node<E> l = last;
+        final Node<E> l = last;
         if (l == null) {
             return null;
         }
-        Node<E> p = l.prev;
-        E item = l.item;
+        final Node<E> p = l.prev;
+        final E item = l.item;
         l.item = null;
         l.prev = l; // help GC
         last = p;
@@ -338,10 +338,10 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      *
      * @param x The node to unlink
      */
-    private void unlink(Node<E> x) {
+    private void unlink(final Node<E> x) {
         // assert lock.isHeldByCurrentThread();
-        Node<E> p = x.prev;
-        Node<E> n = x.next;
+        final Node<E> p = x.prev;
+        final Node<E> n = x.next;
         if (p == null) {
             unlinkFirst();
         } else if (n == null) {
@@ -363,7 +363,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * {@inheritDoc}
      */
     @Override
-    public void addFirst(E e) {
+    public void addFirst(final E e) {
         if (!offerFirst(e)) {
             throw new IllegalStateException("Deque full");
         }
@@ -373,7 +373,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * {@inheritDoc}
      */
     @Override
-    public void addLast(E e) {
+    public void addLast(final E e) {
         if (!offerLast(e)) {
             throw new IllegalStateException("Deque full");
         }
@@ -383,7 +383,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * {@inheritDoc}
      */
     @Override
-    public boolean offerFirst(E e) {
+    public boolean offerFirst(final E e) {
         if (e == null) {
             throw new NullPointerException();
         }
@@ -399,7 +399,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * {@inheritDoc}
      */
     @Override
-    public boolean offerLast(E e) {
+    public boolean offerLast(final E e) {
         if (e == null) {
             throw new NullPointerException();
         }
@@ -421,7 +421,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @throws InterruptedException if the thread is interrupted whilst waiting
      *         for space
      */
-    public void putFirst(E e) throws InterruptedException {
+    public void putFirst(final E e) throws InterruptedException {
         if (e == null) {
             throw new NullPointerException();
         }
@@ -445,7 +445,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @throws InterruptedException if the thread is interrupted whilst waiting
      *         for space
      */
-    public void putLast(E e) throws InterruptedException {
+    public void putLast(final E e) throws InterruptedException {
         if (e == null) {
             throw new NullPointerException();
         }
@@ -473,7 +473,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @throws InterruptedException if the thread is interrupted whilst waiting
      *         for space
      */
-    public boolean offerFirst(E e, long timeout, TimeUnit unit)
+    public boolean offerFirst(final E e, final long timeout, final TimeUnit unit)
         throws InterruptedException {
         if (e == null) {
             throw new NullPointerException();
@@ -507,7 +507,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @throws InterruptedException if the thread is interrupted whist waiting
      *         for space
      */
-    public boolean offerLast(E e, long timeout, TimeUnit unit)
+    public boolean offerLast(final E e, final long timeout, final TimeUnit unit)
         throws InterruptedException {
         if (e == null) {
             throw new NullPointerException();
@@ -532,7 +532,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      */
     @Override
     public E removeFirst() {
-        E x = pollFirst();
+        final E x = pollFirst();
         if (x == null) {
             throw new NoSuchElementException();
         }
@@ -544,7 +544,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      */
     @Override
     public E removeLast() {
-        E x = pollLast();
+        final E x = pollLast();
         if (x == null) {
             throw new NoSuchElementException();
         }
@@ -621,7 +621,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @return the unlinked element
      * @throws InterruptedException if the current thread is interrupted
      */
-    public E pollFirst(long timeout, TimeUnit unit)
+    public E pollFirst(final long timeout, final TimeUnit unit)
         throws InterruptedException {
         long nanos = unit.toNanos(timeout);
         lock.lockInterruptibly();
@@ -649,7 +649,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @return the unlinked element
      * @throws InterruptedException if the current thread is interrupted
      */
-    public E pollLast(long timeout, TimeUnit unit)
+    public E pollLast(final long timeout, final TimeUnit unit)
         throws InterruptedException {
         long nanos = unit.toNanos(timeout);
         lock.lockInterruptibly();
@@ -672,7 +672,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      */
     @Override
     public E getFirst() {
-        E x = peekFirst();
+        final E x = peekFirst();
         if (x == null) {
             throw new NoSuchElementException();
         }
@@ -684,7 +684,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      */
     @Override
     public E getLast() {
-        E x = peekLast();
+        final E x = peekLast();
         if (x == null) {
             throw new NoSuchElementException();
         }
@@ -712,7 +712,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
     }
 
     @Override
-    public boolean removeFirstOccurrence(Object o) {
+    public boolean removeFirstOccurrence(final Object o) {
         if (o == null) {
             return false;
         }
@@ -731,7 +731,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
     }
 
     @Override
-    public boolean removeLastOccurrence(Object o) {
+    public boolean removeLastOccurrence(final Object o) {
         if (o == null) {
             return false;
         }
@@ -755,7 +755,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * {@inheritDoc}
      */
     @Override
-    public boolean add(E e) {
+    public boolean add(final E e) {
         addLast(e);
         return true;
     }
@@ -764,7 +764,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * {@inheritDoc}
      */
     @Override
-    public boolean offer(E e) {
+    public boolean offer(final E e) {
         return offerLast(e);
     }
 
@@ -780,7 +780,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @throws InterruptedException if the thread is interrupted whilst waiting
      *         for space
      */
-    public void put(E e) throws InterruptedException {
+    public void put(final E e) throws InterruptedException {
         putLast(e);
     }
 
@@ -800,7 +800,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @throws InterruptedException if the thread is interrupted whilst waiting
      *         for space
      */
-    public boolean offer(E e, long timeout, TimeUnit unit)
+    public boolean offer(final E e, final long timeout, final TimeUnit unit)
         throws InterruptedException {
         return offerLast(e, timeout, unit);
     }
@@ -850,7 +850,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @return the unlinked element
      * @throws InterruptedException if the current thread is interrupted
      */
-    public E poll(long timeout, TimeUnit unit) throws InterruptedException {
+    public E poll(final long timeout, final TimeUnit unit) throws InterruptedException {
         return pollFirst(timeout, unit);
     }
 
@@ -911,7 +911,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @throws NullPointerException if c is null
      * @throws IllegalArgumentException if c is this instance
      */
-    public int drainTo(Collection<? super E> c) {
+    public int drainTo(final Collection<? super E> c) {
         return drainTo(c, Integer.MAX_VALUE);
     }
 
@@ -931,7 +931,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @throws NullPointerException if c is null
      * @throws IllegalArgumentException if c is this instance
      */
-    public int drainTo(Collection<? super E> c, int maxElements) {
+    public int drainTo(final Collection<? super E> c, final int maxElements) {
         if (c == null) {
             throw new NullPointerException();
         }
@@ -940,7 +940,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
         }
         lock.lock();
         try {
-            int n = Math.min(maxElements, count);
+            final int n = Math.min(maxElements, count);
             for (int i = 0; i < n; i++) {
                 c.add(first.item);   // In this order, in case add() throws.
                 unlinkFirst();
@@ -957,7 +957,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * {@inheritDoc}
      */
     @Override
-    public void push(E e) {
+    public void push(final E e) {
         addFirst(e);
     }
 
@@ -986,7 +986,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @return {@code true} if this deque changed as a result of the call
      */
     @Override
-    public boolean remove(Object o) {
+    public boolean remove(final Object o) {
         return removeFirstOccurrence(o);
     }
 
@@ -1014,7 +1014,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * @return {@code true} if this deque contains the specified element
      */
     @Override
-    public boolean contains(Object o) {
+    public boolean contains(final Object o) {
         if (o == null) {
             return false;
         }
@@ -1089,7 +1089,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
     public Object[] toArray() {
         lock.lock();
         try {
-            Object[] a = new Object[count];
+            final Object[] a = new Object[count];
             int k = 0;
             for (Node<E> p = first; p != null; p = p.next) {
                 a[k++] = p.item;
@@ -1145,7 +1145,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
         try {
             for (Node<E> f = first; f != null;) {
                 f.item = null;
-                Node<E> n = f.next;
+                final Node<E> n = f.next;
                 f.prev = null;
                 f.next = null;
                 f = n;
@@ -1248,15 +1248,16 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
             // Chains of deleted nodes ending in null or self-links
             // are possible if multiple interior nodes are removed.
             for (;;) {
-                Node<E> s = nextNode(n);
-                if (s == null)
+                final Node<E> s = nextNode(n);
+                if (s == null) {
                     return null;
-                else if (s.item != null)
+                } else if (s.item != null) {
                     return s;
-                else if (s == n)
+                } else if (s == n) {
                     return firstNode();
-                else
+                } else {
                     n = s;
+                }
             }
         }
 
@@ -1285,14 +1286,14 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
                 throw new NoSuchElementException();
             }
             lastRet = next;
-            E x = nextItem;
+            final E x = nextItem;
             advance();
             return x;
         }
 
         @Override
         public void remove() {
-            Node<E> n = lastRet;
+            final Node<E> n = lastRet;
             if (n == null) {
                 throw new IllegalStateException();
             }
@@ -1313,7 +1314,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
         @Override
         Node<E> firstNode() { return first; }
         @Override
-        Node<E> nextNode(Node<E> n) { return n.next; }
+        Node<E> nextNode(final Node<E> n) { return n.next; }
         }
 
     /** Descending iterator */
@@ -1321,7 +1322,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
         @Override
         Node<E> firstNode() { return last; }
         @Override
-        Node<E> nextNode(Node<E> n) { return n.prev; }
+        Node<E> nextNode(final Node<E> n) { return n.prev; }
     }
 
     /**
@@ -1331,7 +1332,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * {@code Object}) in the proper order, followed by a null
      * @param s the stream
      */
-    private void writeObject(java.io.ObjectOutputStream s)
+    private void writeObject(final java.io.ObjectOutputStream s)
         throws java.io.IOException {
         lock.lock();
         try {
@@ -1353,7 +1354,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
      * deserialize it).
      * @param s the stream
      */
-    private void readObject(java.io.ObjectInputStream s)
+    private void readObject(final java.io.ObjectInputStream s)
         throws java.io.IOException, ClassNotFoundException {
         s.defaultReadObject();
         count = 0;
@@ -1362,6 +1363,7 @@ class LinkedBlockingDeque<E> extends AbstractQueue<E>
         // Read in all elements and place in queue
         for (;;) {
             @SuppressWarnings("unchecked")
+            final
             E item = (E)s.readObject();
             if (item == null) {
                 break;

==================================================
PooledSoftReference.java
index 4a510ab581..2a818e6965 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/PoolImplUtils.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/PoolImplUtils.java
@@ -37,7 +37,7 @@ class PoolImplUtils {
      * @return the type of object the factory creates
      */
     @SuppressWarnings("rawtypes")
-    static Class<?> getFactoryType(Class<? extends PooledObjectFactory> factory) {
+    static Class<?> getFactoryType(final Class<? extends PooledObjectFactory> factory) {
         return (Class<?>) getGenericType(PooledObjectFactory.class, factory);
     }
 
@@ -52,17 +52,17 @@ class PoolImplUtils {
      *
      * @return concrete type used by the implementation
      */
-    private static <T> Object getGenericType(Class<T> type,
-            Class<? extends T> clazz) {
+    private static <T> Object getGenericType(final Class<T> type,
+            final Class<? extends T> clazz) {
 
         // Look to see if this class implements the generic interface
 
         // Get all the interfaces
-        Type[] interfaces = clazz.getGenericInterfaces();
-        for (Type iface : interfaces) {
+        final Type[] interfaces = clazz.getGenericInterfaces();
+        for (final Type iface : interfaces) {
             // Only need to check interfaces that use generics
             if (iface instanceof ParameterizedType) {
-                ParameterizedType pi = (ParameterizedType) iface;
+                final ParameterizedType pi = (ParameterizedType) iface;
                 // Look for the generic interface
                 if (pi.getRawType() instanceof Class) {
                     if (type.isAssignableFrom((Class<?>) pi.getRawType())) {
@@ -75,10 +75,11 @@ class PoolImplUtils {
 
         // Interface not found on this class. Look at the superclass.
         @SuppressWarnings("unchecked")
+        final
         Class<? extends T> superClazz =
                 (Class<? extends T>) clazz.getSuperclass();
 
-        Object result = getGenericType(type, superClazz);
+        final Object result = getGenericType(type, superClazz);
         if (result instanceof Class<?>) {
             // Superclass implements interface and defines explicit type for
             // generic
@@ -87,7 +88,7 @@ class PoolImplUtils {
             // Superclass implements interface and defines unknown type for
             // generic
             // Map that unknown type to the generic types defined in this class
-            ParameterizedType superClassType =
+            final ParameterizedType superClassType =
                     (ParameterizedType) clazz.getGenericSuperclass();
             return getTypeParameter(clazz,
                     superClassType.getActualTypeArguments()[
@@ -110,11 +111,11 @@ class PoolImplUtils {
      *         type parameter or an instance of {@link Integer} representing
      *         the index for the type in the definition of the defining class
      */
-    private static Object getTypeParameter(Class<?> clazz, Type argType) {
+    private static Object getTypeParameter(final Class<?> clazz, final Type argType) {
         if (argType instanceof Class<?>) {
             return argType;
         }
-        TypeVariable<?>[] tvs = clazz.getTypeParameters();
+        final TypeVariable<?>[] tvs = clazz.getTypeParameters();
         for (int i = 0; i < tvs.length; i++) {
             if (tvs[i].equals(argType)) {
                 return Integer.valueOf(i);

==================================================
SoftReferenceObjectPool.java
index 0a42c0bbdb..785ceb6678 100644
--- a/java/org/apache/tomcat/dbcp/pool2/impl/PooledSoftReference.java
+++ b/java/org/apache/tomcat/dbcp/pool2/impl/PooledSoftReference.java
@@ -38,7 +38,7 @@ public class PooledSoftReference<T> extends DefaultPooledObject<T> {
      *
      * @param reference SoftReference to be managed by the pool
      */
-    public PooledSoftReference(SoftReference<T> reference) {
+    public PooledSoftReference(final SoftReference<T> reference) {
         super(null);  // Null the hard reference in the parent
         this.reference = reference;
     }
@@ -61,7 +61,7 @@ public class PooledSoftReference<T> extends DefaultPooledObject<T> {
      */
     @Override
     public String toString() {
-        StringBuilder result = new StringBuilder();
+        final StringBuilder result = new StringBuilder();
         result.append("Referenced Object: ");
         result.append(getObject().toString());
         result.append(", State: ");
@@ -92,7 +92,7 @@ public class PooledSoftReference<T> extends DefaultPooledObject<T> {
      *
      * @param reference new reference
      */
-    public synchronized void setReference(SoftReference<T> reference) {
+    public synchronized void setReference(final SoftReference<T> reference) {
         this.reference = reference;
     }
 }

==================================================
