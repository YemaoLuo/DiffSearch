467298863ad1b166221b90b52980b1547e7653e0
==================================================
Revert r1716766 while I re-work it.
==================================================
Mark Thomas
==================================================
Thu Nov 26 21:35:04 2015 +0000
==================================================
AbstractProcessorLight.java
Revert r1716766 while I re-work it.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1716771 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AsyncStateMachine.java
index b0aa6ed191..90e0f159bd 100644
--- a/java/org/apache/coyote/AbstractProcessorLight.java
+++ b/java/org/apache/coyote/AbstractProcessorLight.java
@@ -54,6 +54,16 @@ public abstract class AbstractProcessorLight implements Processor {
                 // Do nothing here, just wait for it to get recycled
             } else if (isAsync() || isUpgrade()) {
                 state = dispatch(status);
+            } else if (state == SocketState.ASYNC_END) {
+                state = dispatch(status);
+                if (state == SocketState.OPEN) {
+                    // There may be pipe-lined data to read. If the data
+                    // isn't processed now, execution will exit this
+                    // loop and call release() which will recycle the
+                    // processor (and input buffer) deleting any
+                    // pipe-lined data. To avoid this, process it now.
+                    state = service(socketWrapper);
+                }
             } else if (status == SocketStatus.OPEN_WRITE) {
                 // Extra write event likely after async, ignore
                 state = SocketState.LONG;
@@ -63,18 +73,6 @@ public abstract class AbstractProcessorLight implements Processor {
 
             if (state != SocketState.CLOSED && isAsync()) {
                 state = asyncPostProcess();
-                if (state != SocketState.LONG) {
-                    // Async has ended.
-                    state = dispatch(status);
-                    if (state == SocketState.OPEN) {
-                        // There may be pipe-lined data to read. If the data
-                        // isn't processed now, execution will exit this
-                        // loop and call release() which will recycle the
-                        // processor (and input buffer) deleting any
-                        // pipe-lined data. To avoid this, process it now.
-                        state = service(socketWrapper);
-                    }
-                }
             }
 
             if (getLog().isDebugEnabled()) {
@@ -88,7 +86,8 @@ public abstract class AbstractProcessorLight implements Processor {
                 // dispatches to process.
                 dispatches = getIteratorAndClearDispatches();
             }
-        } while (dispatches != null && state != SocketState.CLOSED);
+        } while (state == SocketState.ASYNC_END ||
+                dispatches != null && state != SocketState.CLOSED);
 
         return state;
     }

==================================================
AbstractEndpoint.java
index e5c1572adf..37a3904c72 100644
--- a/java/org/apache/coyote/AsyncStateMachine.java
+++ b/java/org/apache/coyote/AsyncStateMachine.java
@@ -241,17 +241,17 @@ public class AsyncStateMachine {
         } else if (state == AsyncState.MUST_COMPLETE) {
             asyncCtxt.fireOnComplete();
             state = AsyncState.DISPATCHED;
-            return SocketState.OPEN;
+            return SocketState.ASYNC_END;
         } else if (state == AsyncState.COMPLETING) {
             asyncCtxt.fireOnComplete();
             state = AsyncState.DISPATCHED;
-            return SocketState.OPEN;
+            return SocketState.ASYNC_END;
         } else if (state == AsyncState.MUST_DISPATCH) {
             state = AsyncState.DISPATCHING;
-            return SocketState.OPEN;
+            return SocketState.ASYNC_END;
         } else if (state == AsyncState.DISPATCHING) {
             state = AsyncState.DISPATCHED;
-            return SocketState.OPEN;
+            return SocketState.ASYNC_END;
         } else if (state == AsyncState.STARTED) {
             // This can occur if an async listener does a dispatch to an async
             // servlet during onTimeout

==================================================
