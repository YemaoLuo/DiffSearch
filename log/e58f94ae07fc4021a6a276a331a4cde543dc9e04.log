e58f94ae07fc4021a6a276a331a4cde543dc9e04
==================================================
Add i18n for various util packages.
==================================================
Remy Maucherat
==================================================
Tue Dec 11 15:09:26 2018 +0000
==================================================
AbstractChunk.java
Add i18n for various util packages.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1848691 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ByteChunk.java
index 1573fd4473..75d5b58bf1 100644
--- a/java/org/apache/tomcat/util/buf/AbstractChunk.java
+++ b/java/org/apache/tomcat/util/buf/AbstractChunk.java
@@ -18,12 +18,15 @@ package org.apache.tomcat.util.buf;
 
 import java.io.Serializable;
 
+import org.apache.tomcat.util.res.StringManager;
+
 /**
  * Base class for the *Chunk implementation to reduce duplication.
  */
 public abstract class AbstractChunk implements Cloneable, Serializable {
 
     private static final long serialVersionUID = 1L;
+    protected static final StringManager sm = StringManager.getManager(AbstractChunk.class);
 
     /*
      * JVMs may limit the maximum array size to slightly less than

==================================================
CharChunk.java
index 85c75a75a7..d6c3d43a67 100644
--- a/java/org/apache/tomcat/util/buf/ByteChunk.java
+++ b/java/org/apache/tomcat/util/buf/ByteChunk.java
@@ -512,7 +512,7 @@ public final class ByteChunk extends AbstractChunk {
     public void flushBuffer() throws IOException {
         // assert out!=null
         if (out == null) {
-            throw new IOException("Buffer overflow, no sink " + getLimit() + " " + buff.length);
+            throw new IOException(sm.getString("chunk.overflow", getLimit(), buff.length));
         }
         out.realWriteBytes(buff, start, end - start);
         end = start;

==================================================
UDecoder.java
index 4f5903e5c0..a45004fa3f 100644
--- a/java/org/apache/tomcat/util/buf/LocalStrings.properties
+++ b/java/org/apache/tomcat/util/buf/LocalStrings.properties
@@ -19,9 +19,13 @@ byteBufferUtils.cleaner=Cannot use direct ByteBuffer cleaner, memory leaking may
 
 c2bConverter.recycleFailed=Failed to recycle the C2B Converter. Creating new BufferedWriter, WriteConvertor and IntermediateOutputStream.
 
+chunk.overflow=Buffer overflow and no sink is set, limit [{0}] and buffer length [{1}]
+
 hexUtils.fromHex.nonHex=The input must consist only of hex digits
 hexUtils.fromHex.oddDigits=The input must consist of an even number of hex digits
 
 uDecoder.convertHexDigit.notHex=[{0}] is not a hexadecimal digit
+uDecoder.eof=End of file (EOF)
+uDecoder.noSlash=The encoded slash character is not allowed
 uDecoder.urlDecode.conversionError=Failed to decode [{0}] using character set [{1}]
 uDecoder.urlDecode.missingDigit=Failed to decode [{0}] because the % character must be followed by two hexademical digits

==================================================
Base64.java
index 6403456032..6237dd392e 100644
--- a/java/org/apache/tomcat/util/buf/UDecoder.java
+++ b/java/org/apache/tomcat/util/buf/UDecoder.java
@@ -54,7 +54,7 @@ public final class UDecoder {
     }
 
     /** Unexpected end of data. */
-    private static final IOException EXCEPTION_EOF = new DecodeException("EOF");
+    private static final IOException EXCEPTION_EOF = new DecodeException(sm.getString("uDecoder.eof"));
 
     /** %xx with not-hex digit */
     private static final IOException EXCEPTION_NOT_HEX_DIGIT = new DecodeException(
@@ -277,7 +277,7 @@ public final class UDecoder {
                 char res = (char) Integer.parseInt(
                         str.substring(strPos + 1, strPos + 3), 16);
                 if (noSlash && (res == '/')) {
-                    throw new IllegalArgumentException("noSlash");
+                    throw new IllegalArgumentException(sm.getString("uDecoder.noSlash"));
                 }
                 dec.append(res);
                 strPos += 3;

==================================================
BaseNCodec.java
index 27fd701f01..9546e5099c 100644
--- a/java/org/apache/tomcat/util/codec/binary/Base64.java
+++ b/java/org/apache/tomcat/util/codec/binary/Base64.java
@@ -278,7 +278,7 @@ public class Base64 extends BaseNCodec {
         if (lineSeparator != null) {
             if (containsAlphabetOrPad(lineSeparator)) {
                 final String sep = StringUtils.newStringUtf8(lineSeparator);
-                throw new IllegalArgumentException("lineSeparator must not contain base64 characters: [" + sep + "]");
+                throw new IllegalArgumentException(sm.getString("base64.lineSeparator", sep));
             }
             if (lineLength > 0){ // null line-sep forces no chunking rather than throwing IAE
                 this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;
@@ -366,7 +366,7 @@ public class Base64 extends BaseNCodec {
                     }
                     break;
                 default:
-                    throw new IllegalStateException("Impossible modulus "+context.modulus);
+                    throw new IllegalStateException(sm.getString("base64.impossibleModulus", context.modulus));
             }
             context.currentLinePos += context.pos - savedPos; // keep track of current line position
             // if currentPos == 0 we are at the start of a line, so don't add CRLF
@@ -477,7 +477,7 @@ public class Base64 extends BaseNCodec {
                     buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
                     break;
                 default:
-                    throw new IllegalStateException("Impossible modulus "+context.modulus);
+                    throw new IllegalStateException(sm.getString("base64.impossibleModulus", context.modulus));
             }
         }
     }
@@ -652,10 +652,7 @@ public class Base64 extends BaseNCodec {
         final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
         final long len = b64.getEncodedLength(binaryData);
         if (len > maxResultSize) {
-            throw new IllegalArgumentException("Input array too big, the output array would be bigger (" +
-                len +
-                ") than the specified maximum size of " +
-                maxResultSize);
+            throw new IllegalArgumentException(sm.getString("base64.inputTooLarge", len, maxResultSize));
         }
 
         return b64.encode(binaryData);
@@ -722,7 +719,7 @@ public class Base64 extends BaseNCodec {
      */
     public static byte[] encodeInteger(final BigInteger bigInt) {
         if (bigInt == null) {
-            throw new NullPointerException("encodeInteger called with null parameter");
+            throw new NullPointerException(sm.getString("base64.nullEncodeParameter"));
         }
         return encodeBase64(toIntegerBytes(bigInt), false);
     }

==================================================
Digester.java
new file mode 100644
index 0000000000..1ae86a32fb
--- /dev/null
+++ b/java/org/apache/tomcat/util/codec/binary/LocalStrings.properties
@@ -0,0 +1,19 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+base64.impossibleModulus=Impossible modulus [{0}]
+base64.inputTooLarge=Input array too large, the output array would be bigger [{0}] than the specified maximum size of [{1}]
+base64.lineSeparator=Line separator must not contain base64 characters [{0}]
+base64.nullEncodeParameter=Cannot encode integer with null parameter

==================================================
FactoryCreateRule.java
index 4e3c8779b5..6b779fe76f 100644
--- a/java/org/apache/tomcat/util/digester/Digester.java
+++ b/java/org/apache/tomcat/util/digester/Digester.java
@@ -100,8 +100,7 @@ public class Digester extends DefaultHandler2 {
                     break;
                 } catch (Throwable t) {
                     ExceptionUtils.handleThrowable(t);
-                    LogFactory.getLog("org.apache.tomcat.util.digester.Digester")
-                            .error("Unable to load property source[" + className + "].", t);
+                    LogFactory.getLog(Digester.class).error(sm.getString("digester.propertySourceLoadError", className), t);
                 }
             }
         }
@@ -613,7 +612,7 @@ public class Digester extends DefaultHandler2 {
         try {
             parser = getFactory().newSAXParser();
         } catch (Exception e) {
-            log.error("Digester.getParser: ", e);
+            log.error(sm.getString("digester.createParserError"), e);
             return null;
         }
 
@@ -851,10 +850,10 @@ public class Digester extends DefaultHandler2 {
             try {
                 rule.finish();
             } catch (Exception e) {
-                log.error("Finish event threw exception", e);
+                log.error(sm.getString("digester.error.finish"), e);
                 throw createSAXException(e);
             } catch (Error e) {
-                log.error("Finish event threw error", e);
+                log.error(sm.getString("digester.error.finish"), e);
                 throw e;
             }
         }
@@ -913,19 +912,19 @@ public class Digester extends DefaultHandler2 {
                     }
                     rule.body(namespaceURI, name, bodyText);
                 } catch (Exception e) {
-                    log.error("Body event threw exception", e);
+                    log.error(sm.getString("digester.error.body"), e);
                     throw createSAXException(e);
                 } catch (Error e) {
-                    log.error("Body event threw error", e);
+                    log.error(sm.getString("digester.error.body"), e);
                     throw e;
                 }
             }
         } else {
             if (debug) {
-                log.debug("  No rules found matching '" + match + "'.");
+                log.debug(sm.getString("digester.noRulesFound", match));
             }
             if (rulesValidation) {
-                log.warn("  No rules found matching '" + match + "'.");
+                log.warn(sm.getString("digester.noRulesFound", match));
             }
         }
 
@@ -943,10 +942,10 @@ public class Digester extends DefaultHandler2 {
                     }
                     rule.end(namespaceURI, name);
                 } catch (Exception e) {
-                    log.error("End event threw exception", e);
+                    log.error(sm.getString("digester.error.end"), e);
                     throw createSAXException(e);
                 } catch (Error e) {
-                    log.error("End event threw error", e);
+                    log.error(sm.getString("digester.error.end"), e);
                     throw e;
                 }
             }
@@ -987,7 +986,7 @@ public class Digester extends DefaultHandler2 {
             if (stack.empty())
                 namespaces.remove(prefix);
         } catch (EmptyStackException e) {
-            throw createSAXException("endPrefixMapping popped too many times");
+            throw createSAXException(sm.getString("digester.emptyStackError"));
         }
 
     }
@@ -1173,16 +1172,16 @@ public class Digester extends DefaultHandler2 {
                     }
                     rule.begin(namespaceURI, name, list);
                 } catch (Exception e) {
-                    log.error("Begin event threw exception", e);
+                    log.error(sm.getString("digester.error.begin"), e);
                     throw createSAXException(e);
                 } catch (Error e) {
-                    log.error("Begin event threw error", e);
+                    log.error(sm.getString("digester.error.begin"), e);
                     throw e;
                 }
             }
         } else {
             if (debug) {
-                log.debug("  No rules found matching '" + match + "'.");
+                log.debug(sm.getString("digester.noRulesFound", match));
             }
         }
 
@@ -1353,13 +1352,11 @@ public class Digester extends DefaultHandler2 {
      */
     @Override
     public void error(SAXParseException exception) throws SAXException {
-
-        log.error("Parse Error at line " + exception.getLineNumber() + " column "
-                + exception.getColumnNumber() + ": " + exception.getMessage(), exception);
+        log.error(sm.getString("digester.parseError", exception.getLineNumber(),
+                exception.getColumnNumber()), exception);
         if (errorHandler != null) {
             errorHandler.error(exception);
         }
-
     }
 
 
@@ -1373,13 +1370,11 @@ public class Digester extends DefaultHandler2 {
      */
     @Override
     public void fatalError(SAXParseException exception) throws SAXException {
-
-        log.error("Parse Fatal Error at line " + exception.getLineNumber() + " column "
-                + exception.getColumnNumber() + ": " + exception.getMessage(), exception);
+        log.error(sm.getString("digester.parseErrorFatal", exception.getLineNumber(),
+                exception.getColumnNumber()), exception);
         if (errorHandler != null) {
             errorHandler.fatalError(exception);
         }
-
     }
 
 
@@ -1393,12 +1388,9 @@ public class Digester extends DefaultHandler2 {
      */
     @Override
     public void warning(SAXParseException exception) throws SAXException {
+        log.error(sm.getString("digester.parseWarning", exception.getLineNumber(),
+                exception.getColumnNumber()), exception);
         if (errorHandler != null) {
-            log.warn(
-                    "Parse Warning Error at line " + exception.getLineNumber() + " column "
-                            + exception.getColumnNumber() + ": " + exception.getMessage(),
-                    exception);
-
             errorHandler.warning(exception);
         }
 
@@ -1681,7 +1673,7 @@ public class Digester extends DefaultHandler2 {
         try {
             return stack.peek();
         } catch (EmptyStackException e) {
-            log.warn("Empty stack (returning null)");
+            log.warn(sm.getString("digester.emptyStack"));
             return null;
         }
     }
@@ -1700,7 +1692,7 @@ public class Digester extends DefaultHandler2 {
         try {
             return stack.peek(n);
         } catch (EmptyStackException e) {
-            log.warn("Empty stack (returning null)");
+            log.warn(sm.getString("digester.emptyStack"));
             return null;
         }
     }
@@ -1715,7 +1707,7 @@ public class Digester extends DefaultHandler2 {
         try {
             return stack.pop();
         } catch (EmptyStackException e) {
-            log.warn("Empty stack (returning null)");
+            log.warn(sm.getString("digester.emptyStack"));
             return null;
         }
     }
@@ -1792,7 +1784,7 @@ public class Digester extends DefaultHandler2 {
         try {
             return params.peek();
         } catch (EmptyStackException e) {
-            log.warn("Empty stack (returning null)");
+            log.warn(sm.getString("digester.emptyStack"));
             return null;
         }
     }
@@ -1813,7 +1805,7 @@ public class Digester extends DefaultHandler2 {
             }
             return params.pop();
         } catch (EmptyStackException e) {
-            log.warn("Empty stack (returning null)");
+            log.warn(sm.getString("digester.emptyStack"));
             return null;
         }
     }
@@ -1856,15 +1848,15 @@ public class Digester extends DefaultHandler2 {
             }
         }
         if (locator != null) {
-            String error = "Error at (" + locator.getLineNumber() + ", " + locator.getColumnNumber()
-                    + ") : " + message;
+            String error = sm.getString("digester.errorLocation",
+                    locator.getLineNumber(), locator.getColumnNumber(), message);
             if (e != null) {
                 return new SAXParseException(error, locator, e);
             } else {
                 return new SAXParseException(error, locator);
             }
         }
-        log.error("No Locator!");
+        log.error(sm.getString("digester.noLocator"));
         if (e != null) {
             return new SAXException(message, e);
         } else {

==================================================
ObjectCreateRule.java
index c65004d372..dafddc19a1 100644
--- a/java/org/apache/tomcat/util/digester/LocalStrings.properties
+++ b/java/org/apache/tomcat/util/digester/LocalStrings.properties
@@ -13,6 +13,24 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-digester.encodingInvalid=The encoding [{0}] is not recognised by the JRE and will be ignored
+digester.createParserError=Error creating SAX parser
+digester.emptyStack=Empty stack, returning null
+digester.emptyStackError=Empty stack
+digester.encodingInvalid=The encoding [{0}] is not recognized by the JRE and will be ignored
+digester.error.begin=Begin event threw exception
+digester.error.body=Body event threw exception
+digester.error.end=End event threw exception
+digester.error.finish=Finish event threw exception
+digester.errorLocation=Error at line [{0}] column [{1}]: [{2}]
 digester.failedToUpdateAttributes=Attribute [{0}] failed to update and remains [{1}]
 digester.failedToUpdateSystemProperty=System property [{0}] failed to update and remains [{1}]
+digester.parseError=Parse error at line [{0}] column [{1}]
+digester.parseErrorFatal=Parse fatal error at line [{0}] column [{1}]
+digester.parseWarning=Parse warning at line [{0}] column [{1}]
+digester.propertySourceLoadError=Error loading property source [{0}]
+digester.noLocator=No Locator
+digester.noRulesFound=No rules found matching [{0}]
+
+rule.createError=Error creating object: [{0}]
+rule.noClassName=No class name specified for [{0}] [{1}]
+rule.noProperty=Match [{0}] failed to set property [{1}] to [{2}]

==================================================
Rule.java
index c4d66e7b6c..b728ba6418 100644
--- a/java/org/apache/tomcat/util/digester/ObjectCreateRule.java
+++ b/java/org/apache/tomcat/util/digester/ObjectCreateRule.java
@@ -108,8 +108,7 @@ public class ObjectCreateRule extends Rule {
         }
 
         if (realClassName == null) {
-            throw new NullPointerException("No class name specified for " +
-                    namespace + " " + name);
+            throw new NullPointerException(sm.getString("rule.noClassName", namespace, name));
         }
 
         // Instantiate the new object and push it on the context stack

==================================================
SetPropertiesRule.java
index 8f7a2c0737..5c77de4f9c 100644
--- a/java/org/apache/tomcat/util/digester/Rule.java
+++ b/java/org/apache/tomcat/util/digester/Rule.java
@@ -16,6 +16,7 @@
  */
 package org.apache.tomcat.util.digester;
 
+import org.apache.tomcat.util.res.StringManager;
 import org.xml.sax.Attributes;
 
 /**
@@ -24,6 +25,8 @@ import org.xml.sax.Attributes;
  */
 public abstract class Rule {
 
+    protected static final StringManager sm = StringManager.getManager(Rule.class);
+
     // ----------------------------------------------------------- Constructors
 
     /**

==================================================
ConcurrentMessageDigest.java
index 3ad71f6539..03afccf3b7 100644
--- a/java/org/apache/tomcat/util/digester/SetPropertiesRule.java
+++ b/java/org/apache/tomcat/util/digester/SetPropertiesRule.java
@@ -72,9 +72,7 @@ public class SetPropertiesRule extends Rule {
             if (!digester.isFakeAttribute(top, name)
                     && !IntrospectionUtils.setProperty(top, name, value)
                     && digester.getRulesValidation()) {
-                digester.log.warn("[SetPropertiesRule]{" + digester.match +
-                        "} Setting property '" + name + "' to '" +
-                        value + "' did not find a matching property.");
+                digester.log.warn(sm.getString("rule.noProperty", digester.match, name, value));
             }
         }
 

==================================================
TaskQueue.java
new file mode 100644
index 0000000000..577cd38463
--- /dev/null
+++ b/java/org/apache/tomcat/util/security/LocalStrings.properties
@@ -0,0 +1,16 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+concurrentMessageDigest.noDigest=Digest algorithm unavailable

==================================================
ThreadPoolExecutor.java
index d61cf26856..63274dc29c 100644
--- a/java/org/apache/tomcat/util/threads/TaskQueue.java
+++ b/java/org/apache/tomcat/util/threads/TaskQueue.java
@@ -21,6 +21,8 @@ import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
 
+import org.apache.tomcat.util.res.StringManager;
+
 /**
  * As task queue specifically designed to run with a thread pool executor. The
  * task queue is optimised to properly utilize threads within a thread pool
@@ -31,6 +33,8 @@ import java.util.concurrent.TimeUnit;
 public class TaskQueue extends LinkedBlockingQueue<Runnable> {
 
     private static final long serialVersionUID = 1L;
+    protected static final StringManager sm = StringManager
+            .getManager("org.apache.tomcat.util.threads.res");
 
     private transient volatile ThreadPoolExecutor parent = null;
 
@@ -55,12 +59,12 @@ public class TaskQueue extends LinkedBlockingQueue<Runnable> {
     }
 
     public boolean force(Runnable o) {
-        if ( parent==null || parent.isShutdown() ) throw new RejectedExecutionException("Executor not running, can't force a command into the queue");
+        if ( parent==null || parent.isShutdown() ) throw new RejectedExecutionException(sm.getString("taskQueue.notRunning"));
         return super.offer(o); //forces the item onto the queue, to be used if the task is rejected
     }
 
     public boolean force(Runnable o, long timeout, TimeUnit unit) throws InterruptedException {
-        if ( parent==null || parent.isShutdown() ) throw new RejectedExecutionException("Executor not running, can't force a command into the queue");
+        if ( parent==null || parent.isShutdown() ) throw new RejectedExecutionException(sm.getString("taskQueue.notRunning"));
         return super.offer(o,timeout,unit); //forces the item onto the queue, to be used if the task is rejected
     }
 

==================================================
