a737b00d44b398339eb51030266bd8c90de662bc
==================================================
Lifecycle refactoring - Manager
==================================================
Mark Emlyn
==================================================
Sat Mar 6 13:03:11 2010 +0000
==================================================
BackupManager.java
Lifecycle refactoring - Manager
Lifecycle.START event fired too early in a number of cases
Added toString() for use in Lifecycle error messages

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@919756 13f79535-47bb-0310-9956-ffa450edef68



==================================================
DeltaManager.java
index 1f68f35081..a69d79718f 100644
--- a/java/org/apache/catalina/ha/session/BackupManager.java
+++ b/java/org/apache/catalina/ha/session/BackupManager.java
@@ -30,6 +30,7 @@ import org.apache.catalina.tribes.Channel;
 import org.apache.catalina.tribes.io.ReplicationStream;
 import org.apache.catalina.tribes.tipis.LazyReplicatedMap;
 import org.apache.catalina.tribes.tipis.AbstractReplicatedMap.MapOwner;
+import org.apache.catalina.util.LifecycleBase;
 
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
@@ -129,7 +130,7 @@ public class BackupManager extends StandardManager implements ClusterManager, Ma
     }
     
     public ClusterMessage requestCompleted(String sessionId) {
-        if ( !this.started ) return null;
+        if (!getState().isAvailable()) return null;
         LazyReplicatedMap map = (LazyReplicatedMap)sessions;
         map.replicate(sessionId,false);
         return null;
@@ -182,21 +183,22 @@ public class BackupManager extends StandardManager implements ClusterManager, Ma
     public String getName() {
         return this.name;
     }
+
+
     /**
-     * Prepare for the beginning of active use of the public methods of this
-     * component.  This method should be called after <code>configure()</code>,
-     * and before any of the public methods of the component are utilized.<BR>
-     * Starts the cluster communication channel, this will connect with the other nodes
-     * in the cluster, and request the current session state to be transferred to this node.
-     * @exception IllegalStateException if this component has already been
-     *  started
+     * Start this component and implement the requirements
+     * of {@link LifecycleBase#startInternal()}.
+     *
+     * Starts the cluster communication channel, this will connect with the
+     * other nodes in the cluster, and request the current session state to be
+     * transferred to this node.
+     * 
      * @exception LifecycleException if this component detects a fatal error
      *  that prevents this component from being used
      */
     @Override
-    public void start() throws LifecycleException {
-        if ( this.started ) return;
-        
+    protected synchronized void startInternal() throws LifecycleException {
+
         try {
             cluster.registerManager(this);
             CatalinaCluster catclust = cluster;
@@ -207,12 +209,12 @@ public class BackupManager extends StandardManager implements ClusterManager, Ma
                                                           getClassLoaders());
             map.setChannelSendOptions(mapSendOptions);
             this.sessions = map;
-            super.start();
-            this.started = true;
         }  catch ( Exception x ) {
             log.error("Unable to start BackupManager",x);
             throw new LifecycleException("Failed to start BackupManager",x);
         }
+
+        super.startInternal();
     }
     
     public String getMapName() {
@@ -222,33 +224,28 @@ public class BackupManager extends StandardManager implements ClusterManager, Ma
         return name;
     }
 
+
     /**
-     * Gracefully terminate the active use of the public methods of this
-     * component.  This method should be the last one called on a given
-     * instance of this component.<BR>
-     * This will disconnect the cluster communication channel and stop the listener thread.
-     * @exception IllegalStateException if this component has not been started
+     * Stop this component and implement the requirements
+     * of {@link LifecycleBase#stopInternal()}.
+     * 
+     * This will disconnect the cluster communication channel and stop the
+     * listener thread.
+     *
      * @exception LifecycleException if this component detects a fatal error
-     *  that needs to be reported
+     *  that prevents this component from being used
      */
     @Override
-    public void stop() throws LifecycleException
-    {
+    protected synchronized void stopInternal() throws LifecycleException {
+
+        super.stopInternal();
         
         LazyReplicatedMap map = (LazyReplicatedMap)sessions;
         if ( map!=null ) {
             map.breakdown();
         }
-        if ( !this.started ) return;
-        try {
-        } catch ( Exception x ){
-            log.error("Unable to stop BackupManager",x);
-            throw new LifecycleException("Failed to stop BackupManager",x);
-        } finally {
-            super.stop();
-        }
-        cluster.removeManager(this);
 
+        cluster.removeManager(this);
     }
 
     @Override

==================================================
SimpleTcpReplicationManager.java
index 42fcbfb680..69d4690a99 100644
--- a/java/org/apache/catalina/ha/session/LocalStrings_es.properties
+++ b/java/org/apache/catalina/ha/session/LocalStrings_es.properties
@@ -34,7 +34,6 @@ deltaManager.noCluster = Arrancando... no hay cl\u00FAster asociado con este con
 deltaManager.noMasterMember = Arrancando... sin otro miembro para el contexto [{0}] en dominio [{1}]
 deltaManager.noMembers = Gestor [{0}]\: saltando estado de transferencia. No hay miembros activos en grupo de cl\u00FAster.
 deltaManager.noSessionState = Gestor [{0}]\: No se ha recibido estado de sesi\u00F3n a las {1}, agotando tiempo tras {2} ms.
-deltaManager.notStarted = El gestor a\u00FAn no ha sido arrancado
 deltaManager.sendMessage.newSession = El gestor [{0}] env\u00EDa nueva sesi\u00F3n ({1})
 deltaManager.expireSessions = Gestor [{0}] expirando sesiones al apagar
 deltaManager.receiveMessage.accessed = Gestor [{0}]\: accedida sesi\u00F3n [{1}] recibida.

==================================================
ManagerBase.java
index 368819ba06..2c63b0f21d 100644
--- a/java/org/apache/catalina/session/LocalStrings_ja.properties
+++ b/java/org/apache/catalina/session/LocalStrings_ja.properties
@@ -33,13 +33,11 @@ managerBase.gotten=\u30e1\u30c3\u30bb\u30fc\u30b8\u30c0\u30a4\u30b8\u30a7\u30b9\
 managerBase.random=\u30af\u30e9\u30b9 {0} \u306e\u4e71\u6570\u767a\u751f\u5668\u306e\u521d\u671f\u5316\u306e\u4f8b\u5916\u3067\u3059
 managerBase.seeding=\u4e71\u6570\u767a\u751f\u5668\u30af\u30e9\u30b9 {0} \u306e\u30b7\u30fc\u30c9\u3092\u751f\u6210\u3057\u3066\u3044\u307e\u3059
 serverSession.value.iae=null\u5024\u3067\u3059
-standardManager.alreadyStarted=\u30de\u30cd\u30fc\u30b8\u30e3\u306f\u65e2\u306b\u8d77\u52d5\u3055\u308c\u3066\u3044\u307e\u3059
 standardManager.createSession.ise=createSession: \u30a2\u30af\u30c6\u30a3\u30d6\u30bb\u30c3\u30b7\u30e7\u30f3\u304c\u591a\u3059\u304e\u307e\u3059
 standardManager.expireException=processsExpire: \u30bb\u30c3\u30b7\u30e7\u30f3\u306e\u7d42\u4e86\u51e6\u7406\u4e2d\u306e\u4f8b\u5916\u3067\u3059
 standardManager.loading={0} \u304b\u3089\u6301\u7d9a\u3055\u308c\u305f\u30bb\u30c3\u30b7\u30e7\u30f3\u3092\u30ed\u30fc\u30c9\u3057\u3066\u3044\u307e\u3059
 standardManager.loading.cnfe=\u6301\u7d9a\u3055\u308c\u305f\u30bb\u30c3\u30b7\u30e7\u30f3\u3092\u30ed\u30fc\u30c9\u4e2d\u306bClassNotFoundException\u304c\u767a\u751f\u3057\u307e\u3057\u305f: {0}
 standardManager.loading.ioe=\u6301\u7d9a\u3055\u308c\u305f\u30bb\u30c3\u30b7\u30e7\u30f3\u3092\u30ed\u30fc\u30c9\u4e2d\u306eIOException\u3067\u3059: {0}
-standardManager.notStarted=\u30de\u30cd\u30fc\u30b8\u30e3\u306f\u307e\u3060\u8d77\u52d5\u3055\u308c\u3066\u3044\u307e\u305b\u3093
 standardManager.sessionTimeout=\u7121\u52b9\u306a\u30bb\u30c3\u30b7\u30e7\u30f3\u30bf\u30a4\u30e0\u30a2\u30a6\u30c8\u8a2d\u5b9a\u3067\u3059 {0}
 standardManager.unloading=\u6301\u7d9a\u3055\u308c\u305f\u30bb\u30c3\u30b7\u30e7\u30f3\u3092 {0} \u306b\u4fdd\u5b58\u3057\u307e\u3059
 standardManager.unloading.ioe=\u6301\u7d9a\u3055\u308c\u305f\u30bb\u30c3\u30b7\u30e7\u30f3\u306e\u4fdd\u5b58\u4e2d\u306eIOException\u3067\u3059: {0}

==================================================
PersistentManagerBase.java
index d0a35b32b1..c70ea4cf8d 100644
--- a/java/org/apache/catalina/session/ManagerBase.java
+++ b/java/org/apache/catalina/session/ManagerBase.java
@@ -49,6 +49,7 @@ import org.apache.catalina.Manager;
 import org.apache.catalina.Session;
 import org.apache.catalina.core.StandardContext;
 import org.apache.catalina.core.StandardHost;
+import org.apache.catalina.util.LifecycleBase;
 import org.apache.tomcat.util.res.StringManager;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
@@ -64,7 +65,9 @@ import org.apache.tomcat.util.modeler.Registry;
  * @version $Revision$ $Date$
  */
 
-public abstract class ManagerBase implements Manager, MBeanRegistration {
+public abstract class ManagerBase extends LifecycleBase
+        implements Manager, MBeanRegistration {
+
     private final Log log = LogFactory.getLog(ManagerBase.class); // must not be static
 
     // ----------------------------------------------------- Instance Variables
@@ -1261,6 +1264,24 @@ public abstract class ManagerBase implements Manager, MBeanRegistration {
         return s.getCreationTime();
     }
 
+    
+    /**
+     * Return a String rendering of this object.
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder(this.getClass().getName());
+        sb.append('[');
+        if (container == null) {
+            sb.append("Container is null");
+        } else {
+            sb.append(container.getName());
+        }
+        sb.append(']');
+        return sb.toString();
+    }
+    
+    
     // -------------------- JMX and Registration  --------------------
     protected String domain;
     protected ObjectName oname;

==================================================
StandardManager.java
index 660affb46b..41066a1e57 100644
--- a/java/org/apache/catalina/session/PersistentManagerBase.java
+++ b/java/org/apache/catalina/session/PersistentManagerBase.java
@@ -31,10 +31,10 @@ import org.apache.catalina.Container;
 import org.apache.catalina.Context;
 import org.apache.catalina.Lifecycle;
 import org.apache.catalina.LifecycleException;
-import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.LifecycleState;
 import org.apache.catalina.Session;
 import org.apache.catalina.Store;
-import org.apache.catalina.util.LifecycleSupport;
+import org.apache.catalina.util.LifecycleBase;
 
 import org.apache.catalina.security.SecurityUtil;
 import org.apache.juli.logging.Log;
@@ -53,9 +53,8 @@ import org.apache.juli.logging.LogFactory;
  * @version $Revision$ $Date$
  */
 
-public abstract class PersistentManagerBase
-    extends ManagerBase
-    implements Lifecycle, PropertyChangeListener {
+public abstract class PersistentManagerBase extends ManagerBase
+    implements PropertyChangeListener {
 
     private static final Log log = LogFactory.getLog(PersistentManagerBase.class);
 
@@ -139,12 +138,6 @@ public abstract class PersistentManagerBase
     private static final String info = "PersistentManagerBase/1.1";
 
 
-    /**
-     * The lifecycle event support for this component.
-     */
-    protected LifecycleSupport lifecycle = new LifecycleSupport(this);
-
-
     /**
      * The maximum number of active Sessions allowed, or -1 for no limit.
      */
@@ -157,12 +150,6 @@ public abstract class PersistentManagerBase
     private static String name = "PersistentManagerBase";
 
 
-    /**
-     * Has this component been started yet?
-     */
-    protected boolean started = false;
-
-
     /**
      * Store object which will manage the Session store.
      */
@@ -437,26 +424,6 @@ public abstract class PersistentManagerBase
     }
 
 
-    /**
-     * Get the started status.
-     */
-    protected boolean isStarted() {
-
-        return started;
-
-    }
-
-
-    /**
-     * Set the started flag
-     */
-    protected void setStarted(boolean started) {
-
-        this.started = started;
-
-    }
-
-
     /**
      * Set the Store object which will manage persistent Session
      * storage for this Manager.
@@ -932,65 +899,19 @@ public abstract class PersistentManagerBase
     }
 
 
-    // ------------------------------------------------------ Lifecycle Methods
-
-
-    /**
-     * Add a lifecycle event listener to this component.
-     *
-     * @param listener The listener to add
-     */
-    public void addLifecycleListener(LifecycleListener listener) {
-
-        lifecycle.addLifecycleListener(listener);
-
-    }
-
-
-    /**
-     * Get the lifecycle listeners associated with this lifecycle. If this 
-     * Lifecycle has no listeners registered, a zero-length array is returned.
-     */
-    public LifecycleListener[] findLifecycleListeners() {
-
-        return lifecycle.findLifecycleListeners();
-
-    }
-
-
-    /**
-     * Remove a lifecycle event listener from this component.
-     *
-     * @param listener The listener to remove
-     */
-    public void removeLifecycleListener(LifecycleListener listener) {
-
-        lifecycle.removeLifecycleListener(listener);
-
-    }
-
-
     /**
-     * Prepare for the beginning of active use of the public methods of this
-     * component.  This method should be called after <code>configure()</code>,
-     * and before any of the public methods of the component are utilized.
+     * Start this component and implement the requirements
+     * of {@link LifecycleBase#startInternal()}.
      *
      * @exception LifecycleException if this component detects a fatal error
      *  that prevents this component from being used
      */
-    public void start() throws LifecycleException {
+    @Override
+    protected synchronized void startInternal() throws LifecycleException {
 
-        // Validate and update our current component state
-        if (started) {
-            log.info(sm.getString("standardManager.alreadyStarted"));
-            return;
-        }
         if( ! initialized )
             init();
         
-        lifecycle.fireLifecycleEvent(START_EVENT, null);
-        started = true;
-
         // Force initialization of the random number generator
         if (log.isDebugEnabled())
             log.debug("Force random number initialization starting");
@@ -1003,31 +924,25 @@ public abstract class PersistentManagerBase
         else if (store instanceof Lifecycle)
             ((Lifecycle)store).start();
 
+        setState(LifecycleState.STARTING);
     }
 
 
     /**
-     * Gracefully terminate the active use of the public methods of this
-     * component.  This method should be the last one called on a given
-     * instance of this component.
+     * Stop this component and implement the requirements
+     * of {@link LifecycleBase#stopInternal()}.
      *
      * @exception LifecycleException if this component detects a fatal error
-     *  that needs to be reported
+     *  that prevents this component from being used
      */
-   public void stop() throws LifecycleException {
+    @Override
+    protected synchronized void stopInternal() throws LifecycleException {
 
         if (log.isDebugEnabled())
             log.debug("Stopping");
 
-        // Validate and update our current component state
-        if (!isStarted()) {
-            log.info(sm.getString("standardManager.notStarted"));
-            return;
-        }
+        setState(LifecycleState.STOPPING);
         
-        lifecycle.fireLifecycleEvent(STOP_EVENT, null);
-        setStarted(false);
-
         if (getStore() != null && saveOnRestart) {
             unload();
         } else {
@@ -1089,7 +1004,7 @@ public abstract class PersistentManagerBase
      */
     protected void processMaxIdleSwaps() {
 
-        if (!isStarted() || maxIdleSwap < 0)
+        if (!getState().isAvailable() || maxIdleSwap < 0)
             return;
 
         Session sessions[] = findSessions();
@@ -1132,7 +1047,7 @@ public abstract class PersistentManagerBase
      */
     protected void processMaxActiveSwaps() {
 
-        if (!isStarted() || getMaxActiveSessions() < 0)
+        if (!getState().isAvailable() || getMaxActiveSessions() < 0)
             return;
 
         Session sessions[] = findSessions();
@@ -1182,7 +1097,7 @@ public abstract class PersistentManagerBase
      */
     protected void processMaxIdleBackups() {
 
-        if (!isStarted() || maxIdleBackup < 0)
+        if (!getState().isAvailable() || maxIdleBackup < 0)
             return;
 
         Session sessions[] = findSessions();

==================================================
