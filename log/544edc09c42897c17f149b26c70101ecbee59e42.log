544edc09c42897c17f149b26c70101ecbee59e42
==================================================
First pass at getting HTTP upgrade working for APR/native. I'm testing this with WebSocket. Autobahn doesn't trigger a crash :) but there are a number of failures I still need to investigate :(
==================================================
Mark Emlyn
==================================================
Mon Jan 14 22:24:09 2013 +0000
==================================================
AbstractProcessor.java
First pass at getting HTTP upgrade working for APR/native. I'm testing this with WebSocket. Autobahn doesn't trigger a crash :) but there are a number of failures I still need to investigate :(

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1433175 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractServletInputStream.java
index 3e6a9ed696..d887c9ef23 100644
--- a/java/org/apache/coyote/http11/upgrade/AbstractProcessor.java
+++ b/java/org/apache/coyote/http11/upgrade/AbstractProcessor.java
@@ -89,7 +89,8 @@ public abstract class AbstractProcessor<S>
             // Unexpected state
             return SocketState.CLOSED;
         }
-        if (upgradeServletInputStream.isCloseRequired()) {
+        if (upgradeServletInputStream.isCloseRequired() ||
+                upgradeServletOutputStream.isCloseRequired()) {
             return SocketState.CLOSED;
         }
         return SocketState.UPGRADED;

==================================================
AbstractServletOutputStream.java
index a5a5db95fb..9a4923c369 100644
--- a/java/org/apache/coyote/http11/upgrade/AbstractServletInputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/AbstractServletInputStream.java
@@ -28,7 +28,7 @@ public abstract class AbstractServletInputStream extends ServletInputStream {
     protected static final StringManager sm =
             StringManager.getManager(Constants.Package);
 
-    private boolean closeRequired = false;
+    private volatile boolean closeRequired = false;
     // Start in blocking-mode
     private volatile Boolean ready = Boolean.TRUE;
     private volatile ReadListener listener = null;
@@ -124,6 +124,7 @@ public abstract class AbstractServletInputStream extends ServletInputStream {
 
     @Override
     public void close() throws IOException {
+        closeRequired = true;
         doClose();
     }
 
@@ -176,6 +177,11 @@ public abstract class AbstractServletInputStream extends ServletInputStream {
 
     protected abstract boolean doIsReady() throws IOException;
 
+    /**
+     * Abstract method to be overridden by concrete implementations. The base
+     * class will ensure that there are no concurrent calls to this method for
+     * the same socket.
+     */
     protected abstract int doRead(boolean block, byte[] b, int off, int len)
             throws IOException;
 

==================================================
AprServletInputStream.java
index ae46ffb4c3..6fd0f51a8d 100644
--- a/java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java
@@ -31,6 +31,7 @@ public abstract class AbstractServletOutputStream extends ServletOutputStream {
     private final Object fireListenerLock = new Object();
     private final Object writeLock = new Object();
 
+    private volatile boolean closeRequired = false;
     // Start in blocking-mode
     private volatile WriteListener listener = null;
     private volatile boolean fireListener = false;
@@ -61,6 +62,10 @@ public abstract class AbstractServletOutputStream extends ServletOutputStream {
         this.listener = listener;
     }
 
+    protected final boolean isCloseRequired() {
+        return closeRequired;
+    }
+
     @Override
     public void write(int b) throws IOException {
         preWriteChecks();
@@ -79,6 +84,7 @@ public abstract class AbstractServletOutputStream extends ServletOutputStream {
 
     @Override
     public void close() throws IOException {
+        closeRequired = true;
         doClose();
     }
 
@@ -132,6 +138,11 @@ public abstract class AbstractServletOutputStream extends ServletOutputStream {
         }
     }
 
+    /**
+     * Abstract method to be overridden by concrete implementations. The base
+     * class will ensure that there are no concurrent calls to this method for
+     * the same socket.
+     */
     protected abstract int doWrite(boolean block, byte[] b, int off, int len)
             throws IOException;
 

==================================================
AprServletOutputStream.java
index e559e68a49..540b43d5a3 100644
--- a/java/org/apache/coyote/http11/upgrade/AprServletInputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/AprServletInputStream.java
@@ -17,69 +17,93 @@
 package org.apache.coyote.http11.upgrade;
 
 import java.io.IOException;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
 
+import org.apache.tomcat.jni.Socket;
+import org.apache.tomcat.jni.Status;
 import org.apache.tomcat.util.net.SocketWrapper;
 
 public class AprServletInputStream extends AbstractServletInputStream {
 
+    private final SocketWrapper<Long> wrapper;
     private final long socket;
+    private final Lock blockingStatusReadLock;
+    private final WriteLock blockingStatusWriteLock;
+    private volatile boolean eagain = false;
 
 
     public AprServletInputStream(SocketWrapper<Long> wrapper) {
+        this.wrapper = wrapper;
         this.socket = wrapper.getSocket().longValue();
+        ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
+        this.blockingStatusReadLock = lock.readLock();
+        this.blockingStatusWriteLock =lock.writeLock();
     }
-/*
-    @Override
-    protected int doRead() throws IOException {
-        byte[] bytes = new byte[1];
-        int result = Socket.recv(socket, bytes, 0, 1);
-        if (result == -1) {
-            return -1;
-        } else {
-            return bytes[0] & 0xFF;
-        }
-    }
+
 
     @Override
-    protected int doRead(byte[] b, int off, int len) throws IOException {
-        boolean block = true;
-        if (!block) {
-            Socket.optSet(socket, Socket.APR_SO_NONBLOCK, -1);
-        }
+    protected int doRead(boolean block, byte[] b, int off, int len)
+            throws IOException {
+
+        boolean readDone = false;
+        int result = 0;
         try {
-            int result = Socket.recv(socket, b, off, len);
-            if (result > 0) {
-                return result;
-            } else if (-result == Status.EAGAIN) {
-                return 0;
-            } else {
-                throw new IOException(sm.getString("apr.error",
-                        Integer.valueOf(-result)));
+            blockingStatusReadLock.lock();
+            if (wrapper.getBlockingStatus() == block) {
+                result = Socket.recv(socket, b, off, len);
+                readDone = true;
             }
         } finally {
-            if (!block) {
-                Socket.optSet(socket, Socket.APR_SO_NONBLOCK, 0);
+            blockingStatusReadLock.unlock();
+        }
+
+        if (!readDone) {
+            try {
+                blockingStatusWriteLock.lock();
+                wrapper.setBlockingStatus(block);
+                // Set the current settings for this socket
+                Socket.optSet(socket, Socket.APR_SO_NONBLOCK, (block ? 0 : 1));
+                // Downgrade the lock
+                try {
+                    blockingStatusReadLock.lock();
+                    blockingStatusWriteLock.unlock();
+                    result = Socket.recv(socket, b, off, len);
+                } finally {
+                    blockingStatusReadLock.unlock();
+                }
+            } finally {
+                // Should have been released above but may not have been on some
+                // exception paths
+                if (blockingStatusWriteLock.isHeldByCurrentThread()) {
+                    blockingStatusWriteLock.unlock();
+                }
             }
         }
-    }
-}
-*/
 
-    @Override
-    protected int doRead(boolean block, byte[] b, int off, int len)
-            throws IOException {
-        // TODO Auto-generated method stub
-        return 0;
+        if (result > 0) {
+            eagain = false;
+            return result;
+        } else if (-result == Status.EAGAIN) {
+            eagain = true;
+            return 0;
+        } else {
+            throw new IOException(sm.getString("apr.read.error",
+                    Integer.valueOf(-result)));
+        }
     }
 
+
     @Override
     protected boolean doIsReady() {
-        // TODO Auto-generated method stub
-        return false;
+        return !eagain;
     }
 
+
     @Override
     protected void doClose() throws IOException {
-        // TODO Auto-generated method stub
+        // NO-OP
+        // Let AbstractProcessor trigger the close
     }
 }

==================================================
SocketWrapper.java
index d55dceaba7..521ded3fea 100644
--- a/java/org/apache/coyote/http11/upgrade/LocalStrings.properties
+++ b/java/org/apache/coyote/http11/upgrade/LocalStrings.properties
@@ -21,7 +21,8 @@ upgrade.sos.canWrite.ise=It is illegal to call canWrite() when the ServletOutput
 upgrade.sos.writeListener.null=It is illegal to pass null to setWriteListener()
 upgrade.sis.write.ise=It is illegal to call any of the write() methods in non-blocking mode without first checking that there is space available by calling canWrite()
 
-apr.error=Unexpected error [{0}] reading data from the APR/native socket.
+apr.read.error=Unexpected error [{0}] reading data from the APR/native socket.
+apr.write.error=Unexpected error [{0}] writing data to the APR/native socket.
 
 nio.eof.error=Unexpected EOF read on the socket
 

==================================================
