78a1b578e14799f5b73270240dafb6a500dabb72
==================================================
Implement a hard limit, the 'optimistic' sizing limit is way to optimistic, and can let the pool grow a bit too fast.
==================================================
Filip Hanik
==================================================
Sat May 2 04:57:47 2009 +0000
==================================================
ConnectionPool.java
Implement a hard limit, the 'optimistic' sizing limit is way to optimistic, and can let the pool grow a bit too fast.
A hard limit stays hard.
Clean up pooled connection a bit



git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@770890 13f79535-47bb-0310-9956-ffa450edef68



==================================================
PoolProperties.java
index 1989d5e886..d090aa78b5 100644
--- a/modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
+++ b/modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/ConnectionPool.java
@@ -56,7 +56,7 @@ public class ConnectionPool {
     //===============================================================================
     //         INSTANCE/QUICK ACCESS VARIABLE
     //===============================================================================
-    
+    private AtomicInteger size = new AtomicInteger(0);
     /**
      * All the information about the connection pool
      */
@@ -169,7 +169,7 @@ public class ConnectionPool {
      * @return int
      */
     public int getSize() {
-        return idle.size()+busy.size();
+        return size.get();
     }
 
     /**
@@ -409,7 +409,7 @@ public class ConnectionPool {
             if (jmxPool!=null) {
                 jmxPool.notify(org.apache.tomcat.jdbc.pool.jmx.ConnectionPool.NOTIFY_ABANDON, trace);
             }
-            con.abandon();
+            release(con);
             //we've asynchronously reduced the number of connections
             //we could have threads stuck in idle.poll(timeout) that will never be notified
             if (waitcount.get()>0) idle.offer(new PooledConnection(poolProperties,this));
@@ -429,6 +429,7 @@ public class ConnectionPool {
             con.lock();
             con.release();
         } finally {
+            size.addAndGet(-1);
             con.unlock();
         }
     }
@@ -463,7 +464,8 @@ public class ConnectionPool {
             //this is not 100% accurate since it doesn't use a shared
             //atomic variable - a connection can become idle while we are creating 
             //a new connection
-            if (busy.size() < getPoolProperties().getMaxActive()) {
+            if (size.get() < getPoolProperties().getMaxActive()) {
+                size.addAndGet(1);
                 return createConnection(now, con);
             } //end if
 
@@ -757,7 +759,7 @@ public class ConnectionPool {
                         continue;
                     if (!con.validate(PooledConnection.VALIDATE_IDLE)) {
                         idle.remove(con);
-                        con.release();
+                        release(con);
                     }
                 } finally {
                     con.unlock();

==================================================
PooledConnection.java
index 9d47b9b021..b28f411c30 100644
--- a/modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
+++ b/modules/jdbc-pool/java/org/apache/tomcat/jdbc/pool/PoolProperties.java
@@ -68,7 +68,7 @@ public class PoolProperties {
     protected String initSQL;
     protected boolean testOnConnect =false;
     protected String jdbcInterceptors=null;
-    protected boolean fairQueue = true;
+    protected boolean fairQueue = false;
     protected boolean useEquals = false;
     protected int abandonWhenPercentageFull = 0;
     protected long maxAge = 0;

==================================================
