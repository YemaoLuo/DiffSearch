c084c08f6ab727e5df59ea167155d3321977689e
==================================================
Iterate refactoring and test with CI
==================================================
remm remm@apache.org
==================================================
Fri Mar 1 20:57:36 2019 +0100
==================================================
Http11InputBuffer.java
Iterate refactoring and test with CI

Change HTTP/1.1 available so that it avoids reading, as it is correct
for isReady to return false if no data is available in buffers. Change
registerReadInterest to use a regular read rather than a keepalive read.


==================================================
Nio2Endpoint.java
index 2dc7c17993..15a7e83794 100644
--- a/java/org/apache/coyote/http11/Http11InputBuffer.java
+++ b/java/org/apache/coyote/http11/Http11InputBuffer.java
@@ -618,8 +618,10 @@ public class Http11InputBuffer implements InputBuffer, ApplicationBufferHandler
         }
 
         try {
-            fill(false);
-            available = byteBuffer.remaining();
+            if (wrapper.hasDataToRead()) {
+                fill(false);
+                available = byteBuffer.remaining();
+            }
         } catch (IOException ioe) {
             if (log.isDebugEnabled()) {
                 log.debug(sm.getString("iib.available.readFail"), ioe);

==================================================
SocketWrapperBase.java
index b1dbb7ca24..802023e8a2 100644
--- a/java/org/apache/tomcat/util/net/Nio2Endpoint.java
+++ b/java/org/apache/tomcat/util/net/Nio2Endpoint.java
@@ -476,6 +476,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel,AsynchronousS
         private final CompletionHandler<Integer, ByteBuffer> readCompletionHandler;
         private final Semaphore readPending = new Semaphore(1);
         private boolean readInterest = false; // Guarded by readCompletionHandler
+        private boolean readNotify = false;
 
         private final CompletionHandler<Integer, ByteBuffer> writeCompletionHandler;
         private final CompletionHandler<Long, ByteBuffer[]> gatheringWriteCompletionHandler;
@@ -493,6 +494,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel,AsynchronousS
                     failed(new ClosedChannelException(), attachment);
                     return;
                 }
+                readNotify = true;
                 getEndpoint().processSocket(attachment, SocketEvent.OPEN_READ, Nio2Endpoint.isInline());
             }
 
@@ -590,10 +592,10 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel,AsynchronousS
             this.readCompletionHandler = new CompletionHandler<Integer, ByteBuffer>() {
                 @Override
                 public void completed(Integer nBytes, ByteBuffer attachment) {
-                    boolean readNotify = false;
                     if (log.isDebugEnabled()) {
                         log.debug("Socket: [" + Nio2SocketWrapper.this + "], Interest: [" + readInterest + "]");
                     }
+                    readNotify = false;
                     synchronized (readCompletionHandler) {
                         if (nBytes.intValue() < 0) {
                             failed(new EOFException(), attachment);
@@ -742,6 +744,10 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel,AsynchronousS
         @Override
         public boolean isReadyForRead() throws IOException {
             synchronized (readCompletionHandler) {
+                if (readNotify) {
+                    return true;
+                }
+
                 if (!readPending.tryAcquire()) {
                     readInterest = true;
                     return false;
@@ -776,23 +782,29 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel,AsynchronousS
                 throw new IOException(sm.getString("socket.closed"));
             }
 
-            if (block) {
-                try {
-                    readPending.acquire();
-                } catch (InterruptedException e) {
-                    throw new IOException(e);
-                }
-            } else {
-                if (!readPending.tryAcquire()) {
-                    if (log.isDebugEnabled()) {
-                        log.debug("Socket: [" + this + "], Read in progress. Returning [0]");
+            if (!readNotify) {
+                if (block) {
+                    try {
+                        readPending.acquire();
+                    } catch (InterruptedException e) {
+                        throw new IOException(e);
+                    }
+                } else {
+                    if (!readPending.tryAcquire()) {
+                        if (log.isDebugEnabled()) {
+                            log.debug("Socket: [" + this + "], Read in progress. Returning [0]");
+                        }
+                        return 0;
                     }
-                    return 0;
                 }
             }
 
             int nRead = populateReadBuffer(b, off, len);
             if (nRead > 0) {
+                if (readNotify) {
+                    // The code that was notified is now reading its data
+                    readNotify = false;
+                }
                 // This may be sufficient to complete the request and we
                 // don't want to trigger another read since if there is no
                 // more data to read and this request takes a while to
@@ -810,7 +822,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel,AsynchronousS
                     socketBufferHandler.configureReadBufferForRead();
                     nRead = Math.min(nRead, len);
                     socketBufferHandler.getReadBuffer().get(b, off, nRead);
-                } else if (nRead == 0 && !block && ContainerThreadMarker.isContainerThread()) {
+                } else if (nRead == 0 && !block) {
                     readInterest = true;
                 }
                 if (log.isDebugEnabled()) {
@@ -829,23 +841,29 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel,AsynchronousS
                 throw new IOException(sm.getString("socket.closed"));
             }
 
-            if (block) {
-                try {
-                    readPending.acquire();
-                } catch (InterruptedException e) {
-                    throw new IOException(e);
-                }
-            } else {
-                if (!readPending.tryAcquire()) {
-                    if (log.isDebugEnabled()) {
-                        log.debug("Socket: [" + this + "], Read in progress. Returning [0]");
+            if (!readNotify) {
+                if (block) {
+                    try {
+                        readPending.acquire();
+                    } catch (InterruptedException e) {
+                        throw new IOException(e);
+                    }
+                } else {
+                    if (!readPending.tryAcquire()) {
+                        if (log.isDebugEnabled()) {
+                            log.debug("Socket: [" + this + "], Read in progress. Returning [0]");
+                        }
+                        return 0;
                     }
-                    return 0;
                 }
             }
 
             int nRead = populateReadBuffer(to);
             if (nRead > 0) {
+                if (readNotify) {
+                    // The code that was notified is now reading its data
+                    readNotify = false;
+                }
                 // This may be sufficient to complete the request and we
                 // don't want to trigger another read since if there is no
                 // more data to read and this request takes a while to
@@ -873,7 +891,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel,AsynchronousS
                     // data that was just read
                     if (nRead > 0) {
                         nRead = populateReadBuffer(to);
-                    } else if (nRead == 0 && !block && ContainerThreadMarker.isContainerThread()) {
+                    } else if (nRead == 0 && !block) {
                         readInterest = true;
                     }
                 }
@@ -1411,6 +1429,16 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel,AsynchronousS
         }
 
 
+        @Override
+        public boolean hasDataToRead() {
+            synchronized (readCompletionHandler) {
+                return !socketBufferHandler.isReadBufferEmpty() ||
+                        readNotify ||
+                        getError() != null;
+            }
+        }
+
+
         @Override
         public boolean hasDataToWrite() {
             synchronized (writeCompletionHandler) {
@@ -1476,11 +1504,24 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel,AsynchronousS
         @Override
         public void registerReadInterest() {
             synchronized (readCompletionHandler) {
-                if (readPending.availablePermits() == 0) {
+                // A notification is already being sent
+                if (readNotify) {
+                    return;
+                }
+                /*if (readPending.availablePermits() == 0) {
                     readInterest = true;
                 } else {
                     // If no read is pending, start waiting for data
                     awaitBytes();
+                }*/
+                readInterest = true;
+                if (readPending.tryAcquire()) {
+                    try {
+                        fillReadBuffer(false);
+                    } catch (IOException e) {
+                        // Will never happen
+                        setError(e);
+                    }
                 }
             }
         }
@@ -1720,11 +1761,6 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel,AsynchronousS
 
         @Override
         protected void doRun() {
-            if (SocketEvent.OPEN_WRITE != event) {
-                // Anything other than OPEN_WRITE is a genuine read or an
-                // error condition so for all of those release the semaphore
-                ((Nio2SocketWrapper) socketWrapper).releaseReadPending();
-            }
             boolean launch = false;
             try {
                 int handshake = -1;

==================================================
