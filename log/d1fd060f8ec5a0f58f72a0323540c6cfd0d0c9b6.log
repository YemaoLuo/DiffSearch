d1fd060f8ec5a0f58f72a0323540c6cfd0d0c9b6
==================================================
Reduce references to SocketWrapperBase.getEndpoint()
==================================================
Mark Thomas
==================================================
Wed Dec 14 11:07:03 2016 +0000
==================================================
Http11InputBuffer.java
Reduce references to SocketWrapperBase.getEndpoint()

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1774192 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http11Processor.java
index d911c7caf9..bf7ef28f55 100644
--- a/java/org/apache/coyote/http11/Http11InputBuffer.java
+++ b/java/org/apache/coyote/http11/Http11InputBuffer.java
@@ -320,10 +320,12 @@ public class Http11InputBuffer implements InputBuffer, ApplicationBufferHandler
      * @throws IOException If an exception occurs during the underlying socket
      * read operations, or if the given buffer is not big enough to accommodate
      * the whole line.
+     *
      * @return true if data is properly fed; false if no data is available
      * immediately and thread should be freed
      */
-    boolean parseRequestLine(boolean keptAlive) throws IOException {
+    boolean parseRequestLine(boolean keptAlive, int connectionTimeout, int keepAliveTimeout)
+            throws IOException {
 
         // check state
         if (!parsingRequestLine) {
@@ -341,7 +343,7 @@ public class Http11InputBuffer implements InputBuffer, ApplicationBufferHandler
                     if (keptAlive) {
                         // Haven't read any request data yet so use the keep-alive
                         // timeout.
-                        wrapper.setReadTimeout(wrapper.getEndpoint().getKeepAliveTimeout());
+                        wrapper.setReadTimeout(keepAliveTimeout);
                     }
                     if (!fill(false)) {
                         // A read is pending, so no longer in initial state
@@ -350,7 +352,7 @@ public class Http11InputBuffer implements InputBuffer, ApplicationBufferHandler
                     }
                     // At least one byte of the request has been received.
                     // Switch to the socket timeout.
-                    wrapper.setReadTimeout(wrapper.getEndpoint().getConnectionTimeout());
+                    wrapper.setReadTimeout(connectionTimeout);
                 }
                 if (!keptAlive && byteBuffer.position() == 0 && byteBuffer.limit() >= CLIENT_PREFACE_START.length - 1) {
                     boolean prefaceMatch = true;

==================================================
Http2UpgradeHandler.java
index 9c4fea0de5..fa5b7f85e0 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -375,7 +375,8 @@ public class Http11Processor extends AbstractProcessor {
 
             // Parsing the request header
             try {
-                if (!inputBuffer.parseRequestLine(keptAlive)) {
+                if (!inputBuffer.parseRequestLine(keptAlive, protocol.getConnectionTimeout(),
+                        protocol.getKeepAliveTimeout())) {
                     if (inputBuffer.getParsingRequestLinePhase() == -1) {
                         return SocketState.UPGRADING;
                     } else if (handleIncompleteRequestLineRead()) {

==================================================
StreamProcessor.java
index a3f2643b7a..3628793c16 100644
--- a/java/org/apache/coyote/http2/Http2UpgradeHandler.java
+++ b/java/org/apache/coyote/http2/Http2UpgradeHandler.java
@@ -276,11 +276,11 @@ class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeH
     void processStreamOnContainerThread(StreamProcessor streamProcessor, SocketEvent event) {
         StreamRunnable streamRunnable = new StreamRunnable(streamProcessor, event);
         if (streamConcurrency == null) {
-            socketWrapper.getEndpoint().getExecutor().execute(streamRunnable);
+            socketWrapper.getExecutor().execute(streamRunnable);
         } else {
             if (getStreamConcurrency() < maxConcurrentStreamExecution) {
                 increaseStreamConcurrency();
-                socketWrapper.getEndpoint().getExecutor().execute(streamRunnable);
+                socketWrapper.getExecutor().execute(streamRunnable);
             } else {
                 queuedRunnable.offer(streamRunnable);
             }
@@ -449,7 +449,7 @@ class Http2UpgradeHandler extends AbstractStream implements InternalHttpUpgradeH
             StreamRunnable streamRunnable = queuedRunnable.poll();
             if (streamRunnable != null) {
                 increaseStreamConcurrency();
-                socketWrapper.getEndpoint().getExecutor().execute(streamRunnable);
+                socketWrapper.getExecutor().execute(streamRunnable);
             }
         }
     }

==================================================
SocketWrapperBase.java
index 1a4280571c..b831e57ab6 100644
--- a/java/org/apache/coyote/http2/StreamProcessor.java
+++ b/java/org/apache/coyote/http2/StreamProcessor.java
@@ -45,8 +45,7 @@ class StreamProcessor extends AbstractProcessor {
 
     StreamProcessor(Http2UpgradeHandler handler, Stream stream, Adapter adapter,
             SocketWrapperBase<?> socketWrapper) {
-        super(socketWrapper.getEndpoint().getExecutor(), stream.getCoyoteRequest(),
-                stream.getCoyoteResponse());
+        super(socketWrapper.getExecutor(), stream.getCoyoteRequest(), stream.getCoyoteResponse());
         this.handler = handler;
         this.stream = stream;
         setAdapter(adapter);

==================================================
WsRemoteEndpointImplServer.java
index 8993c3e42c..920e4ffc31 100644
--- a/java/org/apache/tomcat/util/net/SocketWrapperBase.java
+++ b/java/org/apache/tomcat/util/net/SocketWrapperBase.java
@@ -20,6 +20,7 @@ import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.channels.CompletionHandler;
 import java.util.Iterator;
+import java.util.concurrent.Executor;
 import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Lock;
@@ -106,6 +107,10 @@ public abstract class SocketWrapperBase<E> {
         return endpoint;
     }
 
+    public Executor getExecutor() {
+        return endpoint.getExecutor();
+    }
+
     public IOException getError() { return error; }
     public void setError(IOException error) {
         // Not perfectly thread-safe but good enough. Just needs to ensure that

==================================================
