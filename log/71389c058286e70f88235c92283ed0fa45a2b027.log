71389c058286e70f88235c92283ed0fa45a2b027
==================================================
asyncStarted should be false once complete/dispatch in onTimeout
==================================================
Mark Thomas
==================================================
Thu Oct 10 16:57:55 2019 +0100
==================================================
AsyncStateMachine.java
asyncStarted should be false once complete/dispatch in onTimeout



==================================================
TestAsyncContextImpl.java
index 6d66567bdd..33cbff4813 100644
--- a/java/org/apache/coyote/AsyncStateMachine.java
+++ b/java/org/apache/coyote/AsyncStateMachine.java
@@ -321,8 +321,7 @@ class AsyncStateMachine {
     private synchronized boolean doComplete() {
         clearNonBlockingListeners();
         boolean triggerDispatch = false;
-        if (state == AsyncState.STARTING || state == AsyncState.TIMING_OUT ||
-                state == AsyncState.ERROR) {
+        if (state == AsyncState.STARTING || state == AsyncState.ERROR) {
             // Processing is on a container thread so no need to transfer
             // processing to a new container thread
             state = AsyncState.MUST_COMPLETE;
@@ -335,10 +334,13 @@ class AsyncStateMachine {
             // request/response associated with the AsyncContext so need a new
             // container thread to process the different request/response.
             triggerDispatch = true;
-        } else if (state == AsyncState.READ_WRITE_OP) {
+        } else if (state == AsyncState.READ_WRITE_OP || state == AsyncState.TIMING_OUT) {
             // Read/write operations can happen on or off a container thread but
             // while in this state the call to listener that triggers the
             // read/write will be in progress on a container thread.
+            // Processing of timeouts can happen on or off a container thread
+            // (on is much more likely) but while in this state the call that
+            // triggers the timeout will be in progress on a container thread.
             // The socket will be added to the poller when the container thread
             // exits the AbstractConnectionHandler.process() method so don't do
             // a dispatch here which would add it to the poller a second time.
@@ -383,8 +385,7 @@ class AsyncStateMachine {
     private synchronized boolean doDispatch() {
         clearNonBlockingListeners();
         boolean triggerDispatch = false;
-        if (state == AsyncState.STARTING || state == AsyncState.TIMING_OUT ||
-                state == AsyncState.ERROR) {
+        if (state == AsyncState.STARTING || state == AsyncState.ERROR) {
             // Processing is on a container thread so no need to transfer
             // processing to a new container thread
             state = AsyncState.MUST_DISPATCH;
@@ -397,10 +398,13 @@ class AsyncStateMachine {
             // request/response associated with the AsyncContext so need a new
             // container thread to process the different request/response.
             triggerDispatch = true;
-        } else if (state == AsyncState.READ_WRITE_OP) {
+        } else if (state == AsyncState.READ_WRITE_OP || state == AsyncState.TIMING_OUT) {
             // Read/write operations can happen on or off a container thread but
             // while in this state the call to listener that triggers the
             // read/write will be in progress on a container thread.
+            // Processing of timeouts can happen on or off a container thread
+            // (on is much more likely) but while in this state the call that
+            // triggers the timeout will be in progress on a container thread.
             // The socket will be added to the poller when the container thread
             // exits the AbstractConnectionHandler.process() method so don't do
             // a dispatch here which would add it to the poller a second time.

==================================================
