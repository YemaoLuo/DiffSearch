3ae57a4f111ef807792211972d65bc032f3a0658
==================================================
Refactoring to move common helper class to SocketWrapperBase. Also saves one object creation.
==================================================
Remy Maucherat
==================================================
Thu May 3 14:43:36 2018 +0000
==================================================
Http2AsyncUpgradeHandler.java
Refactoring to move common helper class to SocketWrapperBase. Also saves one object creation.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1830827 13f79535-47bb-0310-9956-ffa450edef68



==================================================
SocketWrapperBase.java
index c3ca417e37..dc0380ac71 100644
--- a/java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java
+++ b/java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java
@@ -33,9 +33,6 @@ import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.net.SendfileState;
 import org.apache.tomcat.util.net.SocketWrapperBase;
 import org.apache.tomcat.util.net.SocketWrapperBase.BlockingMode;
-import org.apache.tomcat.util.net.SocketWrapperBase.CompletionCheck;
-import org.apache.tomcat.util.net.SocketWrapperBase.CompletionHandlerCall;
-import org.apache.tomcat.util.net.SocketWrapperBase.CompletionState;
 
 public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
 
@@ -307,7 +304,7 @@ public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
                 ByteUtil.set31Bits(header, 5, sendfile.stream.getIdentifier().intValue());
                 sendfile.mappedBuffer.limit(sendfile.mappedBuffer.position() + frameSize);
                 socketWrapper.write(BlockingMode.SEMI_BLOCK, protocol.getWriteTimeout(),
-                        TimeUnit.MILLISECONDS, sendfile, COMPLETE_WRITE_WITH_COMPLETION,
+                        TimeUnit.MILLISECONDS, sendfile, SocketWrapperBase.COMPLETE_WRITE_WITH_COMPLETION,
                         new SendfileCompletionHandler(), ByteBuffer.wrap(header), sendfile.mappedBuffer);
                 try {
                     handleAsyncException();
@@ -321,19 +318,6 @@ public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
         }
     }
 
-    private static final CompletionCheck COMPLETE_WRITE_WITH_COMPLETION = new CompletionCheck() {
-        @Override
-        public CompletionHandlerCall callHandler(CompletionState state, ByteBuffer[] buffers,
-                int offset, int length) {
-            for (int i = 0; i < length; i++) {
-                if (buffers[offset + i].remaining() > 0) {
-                    return CompletionHandlerCall.CONTINUE;
-                }
-            }
-            return CompletionHandlerCall.DONE;
-        }
-    };
-
     protected class SendfileCompletionHandler implements CompletionHandler<Long, SendfileData> {
         @Override
         public void completed(Long nBytes, SendfileData sendfile) {
@@ -381,7 +365,7 @@ public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
                 ByteUtil.set31Bits(header, 5, sendfile.stream.getIdentifier().intValue());
                 sendfile.mappedBuffer.limit(sendfile.mappedBuffer.position() + frameSize);
                 socketWrapper.write(BlockingMode.SEMI_BLOCK, protocol.getWriteTimeout(),
-                        TimeUnit.MILLISECONDS, sendfile, COMPLETE_WRITE_WITH_COMPLETION,
+                        TimeUnit.MILLISECONDS, sendfile, SocketWrapperBase.COMPLETE_WRITE_WITH_COMPLETION,
                         this, ByteBuffer.wrap(header), sendfile.mappedBuffer);
                 try {
                     handleAsyncException();

==================================================
WsRemoteEndpointImplServer.java
index a84b898f0d..2479d6d3aa 100644
--- a/java/org/apache/tomcat/util/net/SocketWrapperBase.java
+++ b/java/org/apache/tomcat/util/net/SocketWrapperBase.java
@@ -867,6 +867,23 @@ public abstract class SocketWrapperBase<E> {
         }
     };
 
+    /**
+     * This utility CompletionCheck will cause the write to fully write
+     * all remaining data. The completion handler will then be called.
+     */
+    public static final CompletionCheck COMPLETE_WRITE_WITH_COMPLETION = new CompletionCheck() {
+        @Override
+        public CompletionHandlerCall callHandler(CompletionState state, ByteBuffer[] buffers,
+                int offset, int length) {
+            for (int i = 0; i < length; i++) {
+                if (buffers[offset + i].remaining() > 0) {
+                    return CompletionHandlerCall.CONTINUE;
+                }
+            }
+            return CompletionHandlerCall.DONE;
+        }
+    };
+
     /**
      * This utility CompletionCheck will cause the completion handler
      * to be called once some data has been read. If the operation

==================================================
