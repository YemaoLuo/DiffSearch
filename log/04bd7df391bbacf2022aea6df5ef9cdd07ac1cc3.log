04bd7df391bbacf2022aea6df5ef9cdd07ac1cc3
==================================================
Remove the 'integration' - ObjectManager and wrapping of DI frameworks. Lite is just a library/connector - doesn't need it, instead will integrate 
==================================================
Costin Manolache
==================================================
Tue May 25 06:12:38 2010 +0000
==================================================
TomcatSpring.java
Remove the 'integration' - ObjectManager and wrapping of DI frameworks. Lite is just a library/connector - doesn't need it, instead will integrate 
it with existing tomcat JNI model. I may add it back for an example of using tomcat-lite standalone, but for now it's better to avoid confusion.


git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@947932 13f79535-47bb-0310-9956-ffa450edef68



==================================================
DynamicObject.java
deleted file mode 100644
index f824b73875..0000000000
--- a/modules/tomcat-lite/examples/spring/tomcat-spring.xml
+++ /dev/null
@@ -1,55 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<beans xmlns="http://www.springframework.org/schema/beans"
-       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-       xsi:schemaLocation="http://www.springframework.org/schema/beans
-           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">
- 
-  
-<bean id="UserSessionManager" class="org.apache.tomcat.servlets.session.SimpleSessionManager"
-  scope="prototype" lazy-init="true"/>
-
-<bean id="WebappServletMapper" class="org.apache.tomcat.lite.WebappServletMapper"
-  scope="prototype" lazy-init="true"/>
-
-<bean id="WebappFilterMapper" class="org.apache.tomcat.lite.WebappFilterMapper"
-  scope="prototype" lazy-init="true"/>
-
-<bean id="UserTemplateClassMapper" class="org.apache.tomcat.servlets.jsp.JasperCompilerTemplateClassMapper"
-  scope="prototype" lazy-init="true"/>
-  
-<bean id="ContextPreinitListener" class="org.apache.tomcat.lite.webxml.TomcatLiteWebXmlConfig"
-  scope="prototype" lazy-init="true"/>
-  
-<bean id="default-servlet" class="org.apache.tomcat.servlets.file.WebdavServlet"
-  scope="prototype" lazy-init="true"/>
-
-<bean id="jspwildcard-servlet" class="org.apache.tomcat.servlets.jsp.WildcardTemplateServlet"
-  scope="prototype" lazy-init="true"/>
-
-<bean id="Context1" class="org.apache.tomcat.lite.ServletContextImpl" >
-    <property name="contextPath" value="/"/>
-    <property name="basePath" value="./webapps/ROOT"/>
-</bean>
-
-<bean id="Context2" class="org.apache.tomcat.lite.ServletContextImpl" >
-    <property name="contextPath" value="/examples"/>
-    <property name="basePath" value="./webapps/examples"/>
-</bean>
-
-
-  <bean id="connector1" class="org.apache.tomcat.lite.coyote.CoyoteHttp">
-    <property name="port" value="9999"/>
-  </bean>
-
-  <bean id="TomcatLite" class="org.apache.tomcat.lite.TomcatLite">
-    <property name="connector"><ref bean="connector1"/></property>
-    <property name="servletContexts">
-      <list>
-      	<ref bean="Context1"/>
-      	<ref bean="Context2"/>
-      </list>
-    </property>
-  </bean>
-
-</beans>
\ No newline at end of file

==================================================
ObjectManager.java
deleted file mode 100644
index d7c5128a78..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/integration/DynamicObject.java
+++ /dev/null
@@ -1,385 +0,0 @@
-/*
- */
-package org.apache.tomcat.integration;
-
-import java.lang.reflect.AccessibleObject;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-/**
- * Refactoring of IntrospectionUtils and modeler dynamic bean.
- * 
- * Unlike IntrospectionUtils, the method informations can be cached.
- * Also I hope this class will be simpler to use. 
- * There is no static cache.
- * 
- * @author Costin Manolache
- */
-public class DynamicObject {
-    // Based on MbeansDescriptorsIntrospectionSource
-
-    private static Logger log = Logger.getLogger(DynamicObject.class.getName());
-
-    private static Class<?> NO_PARAMS[] = new Class[0];
-
-
-    private static String strArray[] = new String[0];
-
-    private static Class<?>[] supportedTypes = new Class[] { Boolean.class,
-            Boolean.TYPE, Byte.class, Byte.TYPE, Character.class,
-            Character.TYPE, Short.class, Short.TYPE, Integer.class,
-            Integer.TYPE, Long.class, Long.TYPE, Float.class, Float.TYPE,
-            Double.class, Double.TYPE, String.class, strArray.getClass(),
-            BigDecimal.class, BigInteger.class, AtomicInteger.class,
-            AtomicLong.class, java.io.File.class, };
-
-    
-    private Class realClass;
-
-    // Method or Field
-    private Map<String, AccessibleObject> getAttMap;
-
-    public DynamicObject(Class beanClass) {
-        this.realClass = beanClass;
-        initCache();
-    }
-
-    private void initCache() {
-        Method methods[] = null;
-
-        getAttMap = new HashMap<String, AccessibleObject>();
-
-        methods = realClass.getMethods();
-        for (int j = 0; j < methods.length; ++j) {
-            if (ignorable(methods[j])) {
-                continue;
-            }
-            String name = methods[j].getName();
-
-            Class<?> params[] = methods[j].getParameterTypes();
-
-            if (name.startsWith("get") && params.length == 0) {
-                Class<?> ret = methods[j].getReturnType();
-                if (!supportedType(ret)) {
-                    if (log.isLoggable(Level.FINE))
-                        log.fine("Unsupported type " + methods[j]);
-                    continue;
-                }
-                name = unCapitalize(name.substring(3));
-
-                getAttMap.put(name, methods[j]);
-            } else if (name.startsWith("is") && params.length == 0) {
-                Class<?> ret = methods[j].getReturnType();
-                if (Boolean.TYPE != ret) {
-                    if (log.isLoggable(Level.FINE))
-                        log.fine("Unsupported type " + methods[j] + " " + ret);
-                    continue;
-                }
-                name = unCapitalize(name.substring(2));
-
-                getAttMap.put(name, methods[j]);
-            }
-        }
-        // non-private AtomicInteger and AtomicLong - stats
-        Field fields[] = realClass.getFields();
-        for (int j = 0; j < fields.length; ++j) {
-            if (fields[j].getType() == AtomicInteger.class) {
-                getAttMap.put(fields[j].getName(), fields[j]);
-            }
-        }
-        
-    }
-
-    public List<String> attributeNames() {
-        return new ArrayList<String>(getAttMap.keySet());
-    }
-
-
-    public Object invoke(Object proxy, String method) throws Exception {
-        Method executeM = null;
-        Class<?> c = proxy.getClass();
-        executeM = c.getMethod(method, NO_PARAMS);
-        if (executeM == null) {
-            throw new RuntimeException("No execute in " + proxy.getClass());
-        }
-        return executeM.invoke(proxy, (Object[]) null);
-    }
-
-    // TODO
-//    public Object invoke(String method, Object[] params) {
-//        return null;
-//    }
-
-    public Object getAttribute(Object o, String att) {
-        AccessibleObject m = getAttMap.get(att);
-        if (m instanceof Method) {
-            try {
-                return ((Method) m).invoke(o);
-            } catch (Throwable e) {
-                log.log(Level.INFO, "Error getting attribute " + realClass + " "
-                        + att, e);
-                return null;
-            }
-        } if (m instanceof Field) {
-            if (((Field) m).getType() == AtomicInteger.class) {
-                try {
-                    Object value = ((Field) m).get(o);
-                    return ((AtomicInteger) value).get();
-                } catch (Throwable e) {
-                    return null;
-                }
-            } else {
-                return null;
-            }
-        } else {
-            return null;
-        }
-    }
-
-    /** 
-     * Set an object-type attribute.
-     * 
-     * Use setProperty to use a string value and convert it to the 
-     * specific (primitive) type. 
-     */
-    public boolean setAttribute(Object proxy, String name, Object value) {
-        // TODO: use the cache...
-        String methodName = "set" + capitalize(name);
-        Method[] methods = proxy.getClass().getMethods();
-        for (Method m : methods) {
-            Class<?>[] paramT = m.getParameterTypes();
-            if (methodName.equals(m.getName())
-                    && paramT.length == 1
-                    && (value == null || paramT[0].isAssignableFrom(value
-                            .getClass()))) {
-                try {
-                    m.invoke(proxy, value);
-                    return true;
-                } catch (IllegalArgumentException e) {
-                    log.severe("Error setting: " + name + " "
-                            + proxy.getClass().getName() + " " + e);
-                } catch (IllegalAccessException e) {
-                    log.severe("Error setting: " + name + " "
-                            + proxy.getClass().getName() + " " + e);
-                } catch (InvocationTargetException e) {
-                    log.severe("Error setting: " + name + " "
-                            + proxy.getClass().getName() + " " + e);
-                }
-            }
-        }
-        return false;
-    }
-
-    public boolean setProperty(Object proxy, String name, String value) {
-        // TODO: use the cache...
-        String setter = "set" + capitalize(name);
-
-        try {
-            Method methods[] = proxy.getClass().getMethods();
-            
-            Method setPropertyMethod = null;
-
-            // First, the ideal case - a setFoo( String ) method
-            for (int i = 0; i < methods.length; i++) {
-                if (ignorable(methods[i])) {
-                    continue;
-                }
-                Class<?> paramT[] = methods[i].getParameterTypes();
-                if (setter.equals(methods[i].getName()) && paramT.length == 1) {
-                    if ("java.lang.String".equals(paramT[0].getName())) {
-                        methods[i].invoke(proxy, new Object[] { value });
-                        return true;
-                    } else {
-                        // match - find the type and invoke it
-                        Class<?> paramType = methods[i].getParameterTypes()[0];
-                        Object params[] = new Object[1];
-                        params[0] = convert(value, paramType);
-                        if (params[0] != null) {
-                            methods[i].invoke(proxy, params);
-                            return true;
-                        }
-                    }
-                }
-                // save "setProperty" for later
-                if ("setProperty".equals(methods[i].getName()) && 
-                        paramT.length == 2 &&
-                        paramT[0] == String.class &&
-                        paramT[1] == String.class) {
-                    setPropertyMethod = methods[i];
-                }
-            }
-
-            try {
-                Field field = proxy.getClass().getField(name);
-                if (field != null) {
-                    Object conv = convert(value, field.getType());
-                    if (conv != null) {
-                        field.set(proxy, conv);
-                        return true;
-                    }
-                }
-            } catch (NoSuchFieldException e) {
-                // ignore
-            }
-
-            // Ok, no setXXX found, try a setProperty("name", "value")
-            if (setPropertyMethod != null) {
-                Object params[] = new Object[2];
-                params[0] = name;
-                params[1] = value;
-                setPropertyMethod.invoke(proxy, params);
-                return true;
-            }
-
-        } catch (Throwable ex2) {
-            log.log(Level.WARNING, "IAE " + proxy + " " + name + " " + value,
-                    ex2);
-        }
-        return false;
-    }
-
-    // ----------- Helpers ------------------
-    
-    static Object convert(String object, Class<?> paramType) {
-        Object result = null;
-        if ("java.lang.String".equals(paramType.getName())) {
-            result = object;
-        } else if ("java.lang.Long".equals(paramType.getName())
-                || "long".equals(paramType.getName())) {
-            try {
-                result = Long.parseLong(object);
-            } catch (NumberFormatException ex) {
-            }
-            // Try a setFoo ( boolean )
-        } else if ("java.lang.Integer".equals(paramType.getName())
-                || "int".equals(paramType.getName())) {
-            try {
-                result = new Integer(object);
-            } catch (NumberFormatException ex) {
-            }
-            // Try a setFoo ( boolean )
-        } else if ("java.lang.Boolean".equals(paramType.getName())
-                || "boolean".equals(paramType.getName())) {
-            result = new Boolean(object);
-        } else {
-            log.info("Unknown type " + paramType.getName());
-        }
-        if (result == null) {
-            throw new IllegalArgumentException("Can't convert argument: "
-                    + object +  " to " + paramType );
-        }
-        return result;
-    }
-
-    /**
-     * Converts the first character of the given String into lower-case.
-     * 
-     * @param name
-     *            The string to convert
-     * @return String
-     */
-    static String unCapitalize(String name) {
-        if (name == null || name.length() == 0) {
-            return name;
-        }
-        char chars[] = name.toCharArray();
-        chars[0] = Character.toLowerCase(chars[0]);
-        return new String(chars);
-    }
-
-    /**
-     * Check if this class is one of the supported types. If the class is
-     * supported, returns true. Otherwise, returns false.
-     * 
-     * @param ret
-     *            The class to check
-     * @return boolean True if class is supported
-     */
-    static boolean supportedType(Class<?> ret) {
-        for (int i = 0; i < supportedTypes.length; i++) {
-            if (ret == supportedTypes[i]) {
-                return true;
-            }
-        }
-        if (isBeanCompatible(ret)) {
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Check if this class conforms to JavaBeans specifications. If the class is
-     * conformant, returns true.
-     * 
-     * @param javaType
-     *            The class to check
-     * @return boolean True if the class is compatible.
-     */
-    static boolean isBeanCompatible(Class<?> javaType) {
-        // Must be a non-primitive and non array
-        if (javaType.isArray() || javaType.isPrimitive()) {
-            return false;
-        }
-
-        // Anything in the java or javax package that
-        // does not have a defined mapping is excluded.
-        if (javaType.getName().startsWith("java.")
-                || javaType.getName().startsWith("javax.")) {
-            return false;
-        }
-
-        try {
-            javaType.getConstructor(new Class[] {});
-        } catch (java.lang.NoSuchMethodException e) {
-            return false;
-        }
-
-        // Make sure superclass is compatible
-        Class<?> superClass = javaType.getSuperclass();
-        if (superClass != null && superClass != java.lang.Object.class
-                && superClass != java.lang.Exception.class
-                && superClass != java.lang.Throwable.class) {
-            if (!isBeanCompatible(superClass)) {
-                return false;
-            }
-        }
-        return true;
-    }
-    
-    /**
-     * Reverse of Introspector.decapitalize
-     */
-    static String capitalize(String name) {
-        if (name == null || name.length() == 0) {
-            return name;
-        }
-        char chars[] = name.toCharArray();
-        chars[0] = Character.toUpperCase(chars[0]);
-        return new String(chars);
-    }
-
-    private boolean ignorable(Method method) {
-        if (Modifier.isStatic(method.getModifiers()))
-            return true;
-        if (!Modifier.isPublic(method.getModifiers())) {
-            return true;
-        }
-        if (method.getDeclaringClass() == Object.class)
-            return true;
-        return false;
-    }
-    
-    
-}

==================================================
JMXProxyServlet.java
deleted file mode 100644
index 299e387ddf..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/integration/ObjectManager.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.integration;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Tomcat is using JMX heavily for monitoring and config - but other 
- * apps embedding tomcat may have different preferences. There
- * is interest to use and better integrate with dependency injection
- * frameworks, OSGI. 
- * 
- * Tomcat will make call to this class when it creates contexts,
- * servlets, connectors - giving a chance to DI frameworks to inject,
- * and to JMX to expose the objects. 
- * 
- * Tomcat will also call this class when it needs a plugin, allowing
- * DI or frameworks to locate the dependency.
- * 
- * @author Costin Manolache
- */
-public class ObjectManager {
-    
-    /** 
-     * Attribute used to keep a reference to the object manager 
-     * in the context, for the use of servlets. 
-     */
-    public static final String ATTRIBUTE = "ObjectManager";
-
-    /**
-     * Register a named object with the framework. 
-     * 
-     * For example JMX will expose the object as an MBean.
-     * 
-     * The framework may inject properties - if it supports that.
-     */
-    public void bind(String name, Object o) {
-        for (ObjectManager p : children) {
-            p.bind(name, o);
-        }
-    }
-
-    /** 
-     * When an object is no longer in use.
-     */
-    public void unbind(String name) {
-        for (ObjectManager p : children) {
-            p.unbind(name);
-        }        
-    }
-
-    /**
-     * Create or get a new object with the given name.
-     */
-    public Object get(String key) {
-        for (ObjectManager p : children) {
-            Object o = p.get(key);
-            if (o != null) {
-                return o;
-            }
-        }        
-        return null;
-    }
-
-    /**
-     * Create or get a new object with the given name.
-     */
-    public String getProperty(String key) {
-        for (ObjectManager p : children) {
-            String o = p.getProperty(key);
-            if (o != null) {
-                return o;
-            }
-        }        
-        return null;
-    }
-
-    /**
-     * Helper for typed get.
-     */
-    public Object get(Class c) {
-        return get(c.getName());
-    }
-
-    /**
-     * ObjectManager delegates to providers. You can have multiple
-     * providers - for example JMX, DI and OSGI at the same time.
-     */
-    protected List<ObjectManager> children = 
-        new ArrayList<ObjectManager>(); 
-    
-    public void register(ObjectManager om) {
-        children.add(om);
-    }    
-}

==================================================
JmxObjectManagerSpi.java
deleted file mode 100644
index 0e653c790a..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/integration/jmx/JMXProxyServlet.java
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.tomcat.integration.jmx;
-
-
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.lang.management.ManagementFactory;
-import java.util.Iterator;
-import java.util.Set;
-import javax.management.MBeanServer;
-import javax.management.MBeanServerFactory;
-import javax.management.MalformedObjectNameException;
-import javax.management.ObjectName;
-import javax.management.MBeanInfo;
-import javax.management.MBeanAttributeInfo;
-import javax.management.Attribute;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-/**
- * This servlet will dump JMX attributes in a simple format
- * and implement proxy services for modeler.
- *
- * @author Costin Manolache
- */
-public class JMXProxyServlet extends HttpServlet  {
-    protected MBeanServer server = null;
-
-    /**
-     * Initialize this servlet.
-     */
-    public void init() throws ServletException {
-        // Retrieve the MBean serverif (server == null) {
-        if( MBeanServerFactory.findMBeanServer(null).size() > 0 ) {
-            server = MBeanServerFactory.findMBeanServer(null).get(0);
-        } else {
-            server = ManagementFactory.getPlatformMBeanServer();
-        }
-    }
-
-
-    /**
-     * Process a GET request for the specified resource.
-     *
-     * @param request The servlet request we are processing
-     * @param response The servlet response we are creating
-     *
-     * @exception IOException if an input/output error occurs
-     * @exception ServletException if a servlet-specified error occurs
-     */
-    public void doGet(HttpServletRequest request,
-                      HttpServletResponse response)
-        throws IOException, ServletException
-    {
-
-        response.setContentType("text/plain");
-
-        PrintWriter writer = response.getWriter();
-
-        if( server==null ) {
-            writer.println("Error - No mbean server");
-            return;
-        }
-
-        String qry=request.getParameter("set");
-        if( qry!= null ) {
-            String name=request.getParameter("att");
-            String val=request.getParameter("val");
-
-            setAttribute( writer, qry, name, val );
-            return;
-        }
-        qry=request.getParameter("get");
-        if( qry!= null ) {
-            String name=request.getParameter("att");
-            getAttribute( writer, qry, name );
-            return;
-        }        
-        qry=request.getParameter("qry");
-        if( qry == null ) {
-            qry = "*:*";
-        }
-
-        listBeans( writer, qry );
-
-    }
-
-    public void getAttribute(PrintWriter writer, String onameStr, String att) {
-        try {
-            ObjectName oname = new ObjectName(onameStr);
-            Object value = server.getAttribute(oname, att);
-            writer.println("OK - Attribute get '" + onameStr + "' - " + att
-                    + "= " + escape(value.toString()));
-        } catch (Exception ex) {
-            writer.println("Error - " + ex.toString());
-        }
-    }
-
-    public void setAttribute( PrintWriter writer,
-                              String onameStr, String att, String val )
-    {
-        try {
-            ObjectName oname=new ObjectName( onameStr );
-            String type = getType(oname, att);
-            if (type == null) {
-                writer.println("Not found");
-                return;
-            }
-            Object valueObj = convertValue(type, val );
-            server.setAttribute( oname, new Attribute(att, valueObj));
-            writer.println("OK - Attribute set");
-        } catch( Exception ex ) {
-            writer.println("Error - " + ex.toString());
-        }
-    }
-    
-    public String getType( ObjectName oname, String attName )
-    {
-        String type=null;
-        MBeanInfo info=null;
-        try {
-            info=server.getMBeanInfo(oname);
-        } catch (Exception e) {
-            return null;
-        }
-
-        MBeanAttributeInfo attInfo[]=info.getAttributes();
-        for( int i=0; i<attInfo.length; i++ ) {
-            if( attName.equals(attInfo[i].getName())) {
-                type=attInfo[i].getType();
-                return type;
-            }
-        }
-        return null;
-    }
-
-    public Object convertValue(String type, String value)
-    {
-        Object objValue=value;
-        
-        if( type==null || "java.lang.String".equals( type )) {
-            // string is default
-            objValue=value;
-        } else if( "javax.management.ObjectName".equals( type ) ||
-                "ObjectName".equals( type )) {
-            try {
-                objValue=new ObjectName( value );
-            } catch (MalformedObjectNameException e) {
-                return null;
-            }
-        } else if( "java.lang.Integer".equals( type ) ||
-                "int".equals( type )) {
-            objValue=new Integer( value );
-        } else if( "java.lang.Long".equals( type ) ||
-                "long".equals( type )) {
-            objValue=new Long( value );
-        } else if( "java.lang.Boolean".equals( type ) ||
-                "boolean".equals( type )) {
-            objValue=new Boolean( value );
-        }
-        return objValue;
-    }
-    
-    
-    public void listBeans( PrintWriter writer, String qry )
-    {
-
-        Set<ObjectName> names = null;
-        try {
-            names=server.queryNames(new ObjectName(qry), null);
-            writer.println("OK - Number of results: " + names.size());
-            writer.println();
-        } catch (Exception e) {
-            writer.println("Error - " + e.toString());
-            return;
-        }
-
-        Iterator<ObjectName> it=names.iterator();
-        while( it.hasNext()) {
-            ObjectName oname=it.next();
-            writer.println( "Name: " + oname.toString());
-
-            try {
-                MBeanInfo minfo=server.getMBeanInfo(oname);
-                // can't be null - I thinl
-                String code=minfo.getClassName();
-                if ("org.apache.commons.modeler.BaseModelMBean".equals(code)) {
-                    code=(String)server.getAttribute(oname, "modelerType");
-                }
-                writer.println("modelerType: " + code);
-
-                MBeanAttributeInfo attrs[]=minfo.getAttributes();
-                Object value=null;
-
-                for( int i=0; i< attrs.length; i++ ) {
-                    if( ! attrs[i].isReadable() ) continue;
-                    if( ! isSupported( attrs[i].getType() )) continue;
-                    String attName=attrs[i].getName();
-                    if( attName.indexOf( "=") >=0 ||
-                            attName.indexOf( ":") >=0 ||
-                            attName.indexOf( " ") >=0 ) {
-                        continue;
-                    }
-            
-                    try {
-                        value=server.getAttribute(oname, attName);
-                    } catch( Throwable t) {
-                        log("Error getting attribute " + oname +
-                            " " + attName + " " + t.toString());
-                        continue;
-                    }
-                    if( value==null ) continue;
-                    if( "modelerType".equals( attName)) continue;
-                    String valueString=value.toString();
-                    writer.println( attName + ": " + escape(valueString));
-                }
-            } catch (Exception e) {
-                // Ignore
-            }
-            writer.println();
-        }
-
-    }
-
-    public String escape(String value) {
-        // The only invalid char is \n
-        // We also need to keep the string short and split it with \nSPACE
-        // XXX TODO
-        int idx=value.indexOf( "\n" );
-        if( idx < 0 ) return value;
-
-        int prev=0;
-        StringBuffer sb=new StringBuffer();
-        while( idx >= 0 ) {
-            appendHead(sb, value, prev, idx);
-
-            sb.append( "\\n\n ");
-            prev=idx+1;
-            if( idx==value.length() -1 ) break;
-            idx=value.indexOf('\n', idx+1);
-        }
-        if( prev < value.length() )
-            appendHead( sb, value, prev, value.length());
-        return sb.toString();
-    }
-
-    private void appendHead( StringBuffer sb, String value, int start, int end) {
-        if (end < 1) return;
-
-        int pos=start;
-        while( end-pos > 78 ) {
-            sb.append( value.substring(pos, pos+78));
-            sb.append( "\n ");
-            pos=pos+78;
-        }
-        sb.append( value.substring(pos,end));
-    }
-
-    public boolean isSupported( String type ) {
-        return true;
-    }
-}

==================================================
UJmxHandler.java
deleted file mode 100644
index 02b4490738..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/integration/jmx/JmxObjectManagerSpi.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.integration.jmx;
-
-import java.lang.management.ManagementFactory;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.integration.ObjectManager;
-import org.apache.tomcat.util.modeler.Registry;
-
-/**
- * Plugin for integration with JMX.
- * 
- * All objects of interest are registered automatically.
- */
-public class JmxObjectManagerSpi extends ObjectManager implements Runnable {
-    Registry registry;
-    Logger log = Logger.getLogger("JmxObjectManager");
-    
-    public JmxObjectManagerSpi() {
-        registry = Registry.getRegistry(null, null);
-        registry.setMBeanServer(ManagementFactory.getPlatformMBeanServer());
-    }
-    
-    public void bind(String name, Object o) {
-        try {
-            registry.registerComponent(o, 
-                    ":name=\"" + name + "\"", null);
-        } catch (Exception e) {
-            log.severe("Error registering" + e);
-        }
-    }
-
-    public void unbind(String name) {
-        registry.unregisterComponent(":name=\"" + name + "\"");
-    }
-
-    @Override
-    public Object get(String key) {
-        return null;
-    }
-    
-    ObjectManager om;
-    
-    public void setObjectManager(ObjectManager om) {
-        this.om = om;
-    }
-
-    public void run() {
-        om.register(this);
-        // TODO: register existing objects in JMX
-    }
-}

==================================================
UJmxObjectManagerSpi.java
deleted file mode 100644
index 660131a276..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/integration/jmx/UJmxHandler.java
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.tomcat.integration.jmx;
-
-
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.util.Iterator;
-import java.util.Set;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.integration.DynamicObject;
-import org.apache.tomcat.lite.http.HttpRequest;
-import org.apache.tomcat.lite.http.HttpResponse;
-import org.apache.tomcat.lite.http.HttpWriter;
-import org.apache.tomcat.lite.http.HttpChannel.HttpService;
-
-/**
- * Send all registered JMX objects and properties as JSON.
- * 
- * Based on JMXProxy servlet, but:
- * - Async handler instead of servlet - so it works with 'raw' connector
- * - doesn't use JMX - integrates with the ObjectManager ( assuming OM 
- * provies a list of managed objects )
- * - all the reflection magic from modeler is implemented here.
- *
- * @author Costin Manolache
- */
-public class UJmxHandler implements HttpService {
-
-    protected static Logger log = Logger.getLogger(UJmxHandler.class.getName());
-    private UJmxObjectManagerSpi jmx;
-    
-    public UJmxHandler() {
-    }
-    
-    public UJmxHandler(UJmxObjectManagerSpi jmx) {
-        this.jmx = jmx;
-    }
-    
-    public void getAttribute(PrintWriter writer, String onameStr, String att) {
-        try {
-            Object bean = jmx.objects.get(onameStr);
-            Class beanClass = bean.getClass();
-            DynamicObject ci = jmx.getClassInfo(beanClass);
-            
-            Object value = ci.getAttribute(bean, att);
-            writer.println("OK - Attribute get '" + onameStr + "' - " + att
-                    + "= " + escape(value.toString()));
-        } catch (Exception ex) {
-            writer.println("Error - " + ex.toString());
-        }
-    }
-
-
-    public void setAttribute( PrintWriter writer,
-                              String onameStr, String att, String val )
-    {
-        try {
-            Object bean = jmx.objects.get(onameStr);
-            Class beanClass = bean.getClass();
-            DynamicObject ci = jmx.getClassInfo(beanClass);
-
-            ci.setProperty(bean, att, val);
-            writer.println("OK - Attribute set");
-        } catch( Exception ex ) {
-            writer.println("Error - " + ex.toString());
-        }
-    }
-
-    public void listBeans( PrintWriter writer, String qry, boolean json )
-    {
-        if (json) {
-            listBeansJson(writer, qry);
-            return;
-        }
-        Set<String> names = jmx.objects.keySet();
-        writer.println("OK - Number of results: " + names.size());
-        writer.println();
-        
-        Iterator<String> it=names.iterator();
-        while( it.hasNext()) {
-            String oname=it.next();
-            if (qry != null && oname.indexOf(qry) < 0) {
-                continue;
-            }
-            writer.println( "Name: " + oname);
-
-            try {
-                Object bean = jmx.objects.get(oname);
-                
-                Class beanClass = bean.getClass();
-                DynamicObject ci = jmx.getClassInfo(beanClass);
-                
-                writer.println("modelerType: " + beanClass.getName());
-
-                Object value=null;
-                for (String attName: ci.attributeNames()) {
-                    try {
-                        value = ci.getAttribute(bean, attName);
-                    } catch( Throwable t) {
-                        System.err.println("Error getting attribute " + oname +
-                            " " + attName + " " + t.toString());
-                        continue;
-                    }
-                    if( value==null ) continue;
-                    String valueString=value.toString();
-                    writer.println( attName + ": " + escape(valueString));
-                }
-            } catch (Exception e) {
-                // Ignore
-            }
-            writer.println();
-        }
-
-    }
-
-    private static void json(PrintWriter writer, String name, String value) {
-        writer.write("\"" + name +"\":" + "\"" + escapeJson(value) + "\",");
-    }
-    
-   private void listBeansJson(PrintWriter writer, String qry) {
-       Set<String> names = jmx.objects.keySet();
-       writer.println("[");
-       
-       Iterator<String> it=names.iterator();
-       while( it.hasNext()) {
-           writer.print("{");
-           String oname=it.next();
-           json(writer, "name", oname);
-
-           try {
-               Object bean = jmx.objects.get(oname);
-               Class beanClass = bean.getClass();
-               DynamicObject ci = jmx.getClassInfo(beanClass);
-               json(writer, "modelerType", beanClass.getName());
-
-               Object value=null;
-               for (String attName: ci.attributeNames()) {
-                   try {
-                       value = ci.getAttribute(bean, attName);
-                   } catch( Throwable t) {
-                       System.err.println("Error getting attribute " + oname +
-                           " " + attName + " " + t.toString());
-                       continue;
-                   }
-                   if( value==null ) continue;
-                   String valueString=value.toString();
-                   json(writer, attName, valueString);
-               }
-               writer.println("}");
-           } catch (Exception e) {
-               // Ignore
-           }
-       }
-       writer.println("]");
-   }
-   
-   public static String escapeJson(String value) {
-       return value;
-   }
-
-   public static String escape(String value) {
-        // The only invalid char is \n
-        // We also need to keep the string short and split it with \nSPACE
-        // XXX TODO
-        int idx=value.indexOf( "\n" );
-        if( idx < 0 ) return value;
-
-        int prev=0;
-        StringBuffer sb=new StringBuffer();
-        while( idx >= 0 ) {
-            appendHead(sb, value, prev, idx);
-
-            sb.append( "\\n\n ");
-            prev=idx+1;
-            if( idx==value.length() -1 ) break;
-            idx=value.indexOf('\n', idx+1);
-        }
-        if( prev < value.length() )
-            appendHead( sb, value, prev, value.length());
-        return sb.toString();
-    }
-
-    private static void appendHead( StringBuffer sb, String value, int start, int end) {
-        if (end < 1) return;
-
-        int pos=start;
-        while( end-pos > 78 ) {
-            sb.append( value.substring(pos, pos+78));
-            sb.append( "\n ");
-            pos=pos+78;
-        }
-        sb.append( value.substring(pos,end));
-    }
-
-    public boolean isSupported( String type ) {
-        return true;
-    }
-
-    @Override
-    public void service(HttpRequest request, HttpResponse httpRes)
-            throws IOException {
-        
-        httpRes.setContentType("text/plain");
-        HttpWriter out = httpRes.getBodyWriter();
-        PrintWriter writer = new PrintWriter(out);
-        
-        String qry = request.getParameter("set");
-        if( qry!= null ) {
-            String name=request.getParameter("att");
-            String val=request.getParameter("val");
-
-            setAttribute( writer, qry, name, val );
-            return;
-        }
-        qry=request.getParameter("get");
-        if( qry!= null ) {
-            String name=request.getParameter("att");
-            getAttribute( writer, qry, name );
-            return;
-        }        
-        qry=request.getParameter("qry");
-
-        listBeans( writer, qry, request.getParameter("json") != null);
-
-    }
-}

==================================================
AntProperties.java
deleted file mode 100644
index 3ba23e1771..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/integration/jmx/UJmxObjectManagerSpi.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.tomcat.integration.jmx;
-
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.integration.DynamicObject;
-import org.apache.tomcat.integration.ObjectManager;
-
-/**
- * Send all registered JMX objects and properties as JSON.
- * 
- * Based on JMXProxy servlet, but:
- * - Async handler instead of servlet - so it works with 'raw' connector
- * - doesn't use JMX - integrates with the ObjectManager ( assuming OM 
- * provies a list of managed objects )
- * - all the reflection magic from modeler is implemented here.
- *
- * @author Costin Manolache
- */
-public class UJmxObjectManagerSpi extends ObjectManager {
-
-    private static Logger log = Logger.getLogger(UJmxObjectManagerSpi.class.getName());
-    
-    private ObjectManager om;
-    
-    Map<Class, DynamicObject> types = new HashMap<Class, DynamicObject>();
-    
-    Map<String, Object> objects = new HashMap();
-    
-    @Override
-    public void bind(String name, Object o) {
-        if (objects.get(name) != null) {
-            log.warning("Duplicated name " + name);
-        }
-        objects.put(name, o);
-    }
-
-    @Override
-    public void unbind(String name) {
-        objects.remove(name);
-    }
-    
-    // Dynamic
-    public void setObjectManager(ObjectManager om) {
-        this.om = om;
-    }
-    
-    DynamicObject getClassInfo(Class beanClass) {
-        if (types.get(beanClass) != null) {
-            return types.get(beanClass);
-        }
-        DynamicObject res = new DynamicObject(beanClass);
-        types.put(beanClass, res);
-        return res;
-    }
-}

==================================================
Main.java
deleted file mode 100644
index 1d840bcd18..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/integration/simple/AntProperties.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- */
-package org.apache.tomcat.integration.simple;
-
-import java.util.Hashtable;
-
-/**
- * Extracted from IntrospectionHelper - a simple utility class to 
- * do ant style ${property} replacements on a string, using a map
- * holding properties. Also allows a hook for dynamic, on-demand 
- * properties.
- * 
- * @author Costin Manolache
- */
-public class AntProperties {
-    public static interface PropertySource {
-        public String getProperty(String key);
-    }
-
-    /**
-     * Replace ${NAME} with the property value
-     */
-    public static String replaceProperties(String value,
-            Hashtable<Object,Object> staticProp, PropertySource dynamicProp[]) {
-        if (value.indexOf("$") < 0) {
-            return value;
-        }
-        StringBuffer sb = new StringBuffer();
-        int prev = 0;
-        // assert value!=nil
-        int pos;
-        while ((pos = value.indexOf("$", prev)) >= 0) {
-            if (pos > 0) {
-                sb.append(value.substring(prev, pos));
-            }
-            if (pos == (value.length() - 1)) {
-                sb.append('$');
-                prev = pos + 1;
-            } else if (value.charAt(pos + 1) != '{') {
-                sb.append('$');
-                prev = pos + 1; // XXX
-            } else {
-                int endName = value.indexOf('}', pos);
-                if (endName < 0) {
-                    sb.append(value.substring(pos));
-                    prev = value.length();
-                    continue;
-                }
-                String n = value.substring(pos + 2, endName);
-                String v = null;
-                if (staticProp != null) {
-                    v = (String) staticProp.get(n);
-                }
-                if (v == null && dynamicProp != null) {
-                    for (int i = 0; i < dynamicProp.length; i++) {
-                        v = dynamicProp[i].getProperty(n);
-                        if (v != null) {
-                            break;
-                        }
-                    }
-                }
-                if (v == null)
-                    v = "${" + n + "}";
-
-                sb.append(v);
-                prev = endName + 1;
-            }
-        }
-        if (prev < value.length())
-            sb.append(value.substring(prev));
-        return sb.toString();
-    }
-
-
-}

==================================================
ServletHelper.java
deleted file mode 100644
index b19e4d4add..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/integration/simple/Main.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.integration.simple;
-
-
-/**
- * Replacement for tomcat-lite specific Main, using the simple 
- * injection. SimpleObjectManager also has support for simple 
- * command line processing - CLI is treated the same with 
- * properties from the config file. 
- * 
- * @author Costin Manolache
- */
-public class Main {
-    static boolean running = true;
-    static Object lock = new Object();
-    
-    public static void stop() {
-        running = false;
-        synchronized (lock) {
-            lock.notify();
-        }
-    }
-    
-    public static void waitStop() {
-        while (running) {
-            try {
-                synchronized (lock) {
-                    lock.wait();
-                }
-            } catch (InterruptedException e) {
-            }
-        }
-    }
-
-    public static void main(String args[]) 
-            throws Exception {
-        // '--config' will load a config file.
-        SimpleObjectManager om = new SimpleObjectManager(args);
-
-        String run = (String) om.getProperty("RUN");
-        if (run == null) {
-            // TODO: look for a pre-defined name in local dir, resource,
-            // manifest
-            System.err.println("Using default tomcat-lite configuration");
-
-            if (args.length == 0) {
-                System.err.println("Example command line:");
-                System.err.println("-context /:webapps/ROOT -Connector.port 9999");
-            }
-            
-            String cfgFile = "org/apache/tomcat/lite/config.properties";
-            om.loadResource(cfgFile);
-            run = (String) om.getProperty("RUN");
-        }
-        
-        String[] runNames = run.split(",");
-        for (String name: runNames) {
-            Object main = om.get(name);
-            if (main instanceof Runnable) {
-                ((Runnable) main).run();
-            }
-        }
-        
-    }    
-}

==================================================
SimpleObjectManager.java
deleted file mode 100644
index b6269d27d1..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/integration/simple/ServletHelper.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.integration.simple;
-
-import java.util.Enumeration;
-
-import javax.servlet.Servlet;
-import javax.servlet.ServletConfig;
-import javax.servlet.ServletContext;
-
-import org.apache.tomcat.integration.ObjectManager;
-
-public class ServletHelper {
-
-    public static ObjectManager getObjectManager(ServletContext ctx) {
-        // May be provided by container or a listener
-        ObjectManager om = (ObjectManager) ctx.getAttribute(ObjectManager.ATTRIBUTE);
-        if (om == null) {
-            // Default
-            SimpleObjectManager som = new SimpleObjectManager();
-            om = som;
-            
-            // All context init params are set
-            Enumeration namesE = ctx.getInitParameterNames();
-            while (namesE.hasMoreElements()) {
-                String n = (String) namesE.nextElement();
-                String v = ctx.getInitParameter(n);
-                som.getProperties().put(n, v);
-            }
-            
-            ctx.setAttribute(ObjectManager.ATTRIBUTE, om);
-            // load context settings
-        }
-        return om;
-    }
-
-    public static void initServlet(Servlet s) {
-        ServletConfig sc = s.getServletConfig();
-        String name = sc.getServletName();
-        String ctx = sc.getServletContext().getContextPath();
-        
-        // Servlets are named:...
-        
-        ObjectManager om = getObjectManager(sc.getServletContext());
-        
-        String dn = ctx + ":" + name;
-        
-        // If SimpleObjectManager ( or maybe other supporting dynamic config ):
-        if (om instanceof SimpleObjectManager) {
-            SimpleObjectManager som = (SimpleObjectManager) om;
-            
-            
-        }
-        
-        
-        om.bind(dn, s);
-        
-    }
-    
-}

==================================================
PropertiesSpiTest.java
deleted file mode 100644
index bb25aec269..0000000000
--- a/modules/tomcat-lite/java/org/apache/tomcat/integration/simple/SimpleObjectManager.java
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package org.apache.tomcat.integration.simple;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Properties;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import org.apache.tomcat.integration.DynamicObject;
-import org.apache.tomcat.integration.ObjectManager;
-
-/**
- * This is a very small 'dependency injection'/registry poor-man substitute, 
- * based on old tomcat IntrospectionUtils ( which is based on ant ).
- * Alternative would be to just pick one of spring/guice/etc and use it.
- * This class is a bit smaller and should be enough for simple use.
- * 
- * How it works: 
- *  - when bound, simple properties are injected in the objects using
- *  the old IntrospectionUtils, same as in original Tomcat server.xml
- *   
- *  - object creation using class name - properties injected as well.
- *  Similar with how server.xml or ant works.
- *  
- *  - it is based on a big Properties file, with command line arguments 
- *  merged in.
- *  
- * Tomcat doesn't require any of the features - they are just used to
- * allow configuration in 'default' mode, when no other framework is 
- * used.  
- * 
- * See the Spring example for an alternative. I believe most POJO frameworks
- * can be supported. 
- * 
- * @author Costin Manolache
- */
-public class SimpleObjectManager extends ObjectManager {
-    public static final String ARGS = "Main.args";
-
-    static Logger log = Logger.getLogger(SimpleObjectManager.class.getName());
-    
-    protected Properties props = new Properties();
-    protected Map<String, Object> objects = new HashMap();
-    
-    public SimpleObjectManager() {
-        // Register PropertiesSpi
-    }
-
-    public SimpleObjectManager(String[] args) {
-        this();
-        bind(ARGS, args);
-    }
-    
-    public void loadResource(String res) {
-        InputStream in = this.getClass().getClassLoader()
-            .getResourceAsStream(res);
-        if (in != null) {
-            load(in);
-        }
-    }
-    
-    public void register(ObjectManager om) {
-        super.register(om);
-    }
-    
-    public ObjectManager getObjectManager() {
-        return this;
-    }
-
-    public void load(InputStream is) {
-        try {
-            props.load(is);
-            processIncludes();
-        } catch (IOException e) {
-            throw new RuntimeException("Error loading default config");
-        }
-    }
-    
-    // resolve included "config". Very basic, just one, etc.
-    private void processIncludes() throws IOException {
-        String value = props.getProperty("config");
-        if (value == null) {
-            value = props.getProperty("include");
-            if (value != null) {
-                props.remove("include");
-            }
-        } else {
-            // avoid loop
-            props.remove("config");
-        }
-        if (value == null) {
-            return;
-        }
-        if (new File(value).exists()) {
-            load(new FileInputStream(value));                    
-        } else {
-            loadResource(value);
-        }
-    }
-    
-    public Properties getProperties() {
-        return props;
-    }
-    
-    @Override
-    public void unbind(String name) {
-        // Children
-        // TODO: call @destroy
-        super.unbind(name);
-    }
-
-    @Override
-    public void bind(String name, Object o) {
-        //log.info("Bound: " + name + " " + o);
-
-        if (ARGS.equals(name)) {
-            try {
-                processArgs((String[]) o, props);
-            } catch (IOException e) {
-                throw new RuntimeException(e);
-            }
-        }
-        
-        // TODO: can I make 'inject' public - Guice seems to 
-        // support this.
-        inject(name, o);
-        
-        // Children
-        super.bind(name, o);
-    }
-
-    @Override
-    public Object get(String key) {
-        // Use same syntax as Spring props.
-        Object res = null;
-        String prop = props.getProperty(key + ".(class)");
-        if (prop != null) {
-            res = loadClass(prop);
-        }
-
-        if (res == null) {
-            res = super.get(key);
-        }
-        
-        if (res == null) {
-            // Maybe it's just a class name
-            res = loadClass(key);
-        }
-        
-        if (res != null) {
-            inject(key, res);
-        }
-        return res;
-    }
-    
-    public String getProperty(String key) {
-        String prop = props.getProperty(key);
-        if (prop != null) {
-            return prop;
-        }
-        return super.getProperty(key);
-    }
-
-    private void inject(String name, Object o) {
-        // Simple injection of primitive types
-        String pref = name + ".";
-        int prefLen = pref.length();
-
-        DynamicObject dyno = new DynamicObject(o.getClass());
-        dyno.setAttribute(o, "ObjectManager", this);
-
-        for (Object kObj: props.keySet()) {
-            if (!(kObj instanceof String)) {continue;}
-            String k = (String) kObj;
-            if (k.startsWith(pref)) {
-                if (k.endsWith(")")) {
-                    continue; // special 
-                }
-                String value = props.getProperty(k);
-                value = AntProperties.replaceProperties(value, 
-                        props, null);
-                String p = k.substring(prefLen);
-                int idx = p.indexOf(".");
-                if (idx > 0) {
-                    // ignore suffix - indexed properties
-                    p = p.substring(0, idx);
-                }
-                dyno.setProperty(o, p, value);
-                if (log.isLoggable(Level.FINE)) {
-                    log.info("Setting: " + name + " " + k + " " + value);
-                }
-            }
-        }
-        
-
-        // We could do cooler things - inject objects, etc.
-    }
-    
-    
-    private Object loadClass(String className) {
-        try {
-            Class c = Class.forName(className);
-            if (c.isInterface()) {
-                return null;
-            }
-            Object ext = c.newInstance();
-            return ext;
-        } catch (Throwable e) {
-            return null;
-        }        
-    }
-    
-    /**
-     * Populate properties based on CLI:
-     *  -key value
-     *  --key=value
-     *  
-     *  --config=FILE - load a properties file
-     *  
-     * @param args
-     * @param p
-     * @param meta
-     * @return everything after the first non arg not starting with '-'
-     * @throws IOException 
-     */
-    public String[] processArgs(String[] args, Properties props) 
-            throws IOException {
-
-        for (int i = 0; i < args.length; i++) {
-            String arg = args[i];
-            if (arg.startsWith("--")) {
-                arg = arg.substring(2);
-            } else if (arg.startsWith("-")) {
-                arg = arg.substring(1);
-            } else {
-                String [] res = new String[args.length - i];
-                System.arraycopy(args, i, res, 0, res.length);
-                processIncludes();
-                return res;
-            }
-            
-            String name = arg; 
-            int eq = arg.indexOf("=");
-            String value = null;
-            if (eq > 0) {
-                name = arg.substring(0, eq);
-                value = arg.substring(eq + 1);
-            } else {
-                i++;
-                if (i >= args.length) {
-                    throw new RuntimeException("Missing param " + arg);
-                }
-                value = args[i];
-            }
-
-            props.put(name, value);
-            
-        }
-        
-        processIncludes();
-        return new String[] {};
-    }    
-}

==================================================
