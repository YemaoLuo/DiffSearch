ad5ae4509c24b365af60c529f3f831b806472644
==================================================
Make access of dispatcher list on socket wrapper thread safe
==================================================
Mark Emlyn
==================================================
Sat Oct 5 22:21:40 2013 +0000
==================================================
AbstractProtocol.java
Make access of dispatcher list on socket wrapper thread safe

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1529537 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractEndpoint.java
index beac2b97c9..8e6685a06b 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -18,6 +18,7 @@ package org.apache.coyote;
 
 import java.io.IOException;
 import java.net.InetAddress;
+import java.util.Iterator;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -616,14 +617,19 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
                 initSsl(wrapper, processor);
 
                 SocketState state = SocketState.CLOSED;
+                Iterator<DispatchType> dispatches = null;
                 do {
-                    if (wrapper.hasNextDispatch()) {
-                        // Associate with the processor with the connection as
-                        // these calls may result in a nested call to process()
-                        connections.put(socket, processor);
-                        DispatchType nextDispatch = wrapper.getNextDispatch();
-                        state = processor.asyncDispatch(
-                                nextDispatch.getSocketStatus());
+                    if (dispatches != null) {
+                        if (dispatches.hasNext()) {
+                            // Associate with the processor with the connection as
+                            // these calls may result in a nested call to process()
+                            connections.put(socket, processor);
+                            DispatchType nextDispatch = dispatches.next();
+                            state = processor.asyncDispatch(
+                                    nextDispatch.getSocketStatus());
+                        } else {
+                            dispatches = null;
+                        }
                     } else if (status == SocketStatus.DISCONNECT &&
                             !processor.isComet()) {
                         // Do nothing here, just wait for it to get recycled
@@ -670,9 +676,12 @@ public abstract class AbstractProtocol<S> implements ProtocolHandler,
                                 "], Status in: [" + status +
                                 "], State out: [" + state + "]");
                     }
+                    if (dispatches == null || !dispatches.hasNext()) {
+                        dispatches = wrapper.getIteratorAndClearDispatches();
+                    }
                 } while (state == SocketState.ASYNC_END ||
                         state == SocketState.UPGRADING ||
-                        wrapper.hasNextDispatch() && state != SocketState.CLOSED);
+                        dispatches.hasNext() && state != SocketState.CLOSED);
 
                 if (state == SocketState.LONG) {
                     // In the middle of processing a request/response. Keep the

==================================================
SocketWrapper.java
index a89c8aea27..68689af695 100644
--- a/java/org/apache/tomcat/util/net/AbstractEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AbstractEndpoint.java
@@ -23,6 +23,7 @@ import java.net.InetSocketAddress;
 import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.StringTokenizer;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
@@ -636,13 +637,11 @@ public abstract class AbstractEndpoint<S> {
 
 
     public void executeNonBlockingDispatches(SocketWrapper<S> socketWrapper) {
-        // Synchronise on the socket wrapper to ensure no other threads are
-        // working with the socket
-        synchronized (socketWrapper) {
-            while (socketWrapper.hasNextDispatch()) {
-                DispatchType dispatchType = socketWrapper.getNextDispatch();
-                processSocket(socketWrapper, dispatchType.getSocketStatus(), false);
-            }
+        Iterator<DispatchType> dispatches = socketWrapper.getIteratorAndClearDispatches();
+
+        while (dispatches.hasNext()) {
+            DispatchType dispatchType = dispatches.next();
+            processSocket(socketWrapper, dispatchType.getSocketStatus(), false);
         }
     }
 

==================================================
