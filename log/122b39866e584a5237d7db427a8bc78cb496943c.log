122b39866e584a5237d7db427a8bc78cb496943c
==================================================
Add support for JARs nested in WARs to the Jar abstraction used by the
==================================================
Mark Emlyn
==================================================
Mon Sep 16 13:08:40 2013 +0000
==================================================
FileUrlJar.java
Add support for JARs nested in WARs to the Jar abstraction used by the
JAR scanner.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1523623 13f79535-47bb-0310-9956-ffa450edef68



==================================================
FileUrlNestedJar.java
index d3f88f2cd7..0445aa8f18 100644
--- a/java/org/apache/tomcat/util/scan/FileUrlJar.java
+++ b/java/org/apache/tomcat/util/scan/FileUrlJar.java
@@ -26,8 +26,8 @@ import java.util.jar.JarFile;
 import java.util.zip.ZipEntry;
 
 /**
- * Implementation of {@link Jar} that is optimised for file based JAR URLs (e.g
- * URLs of the form jar:file:...).
+ * Implementation of {@link Jar} that is optimised for file based JAR URLs that
+ * refer directly to a JAR file (e.g URLs of the form jar:file: ... .jar!/) .
  */
 public class FileUrlJar implements Jar {
 

==================================================
JarFactory.java
new file mode 100644
index 0000000000..e878e81505
--- /dev/null
+++ b/java/org/apache/tomcat/util/scan/FileUrlNestedJar.java
@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.scan;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.JarURLConnection;
+import java.net.URL;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+
+
+/**
+ * Implementation of {@link Jar} that is optimised for file based JAR URLs that
+ * refer to a JAR file nested inside a WAR
+ * (e.g URLs of the form jar:file: ... .war!/ ... .jar).
+ */
+public class FileUrlNestedJar implements Jar {
+
+    private final JarFile warFile;
+    private final JarEntry jarEntry;
+    private NonClosingJarInputStream jarInputStream = null;
+    private JarEntry entry = null;
+
+    public FileUrlNestedJar(URL url) throws IOException {
+        JarURLConnection jarConn = (JarURLConnection) url.openConnection();
+        jarConn.setUseCaches(false);
+        warFile = jarConn.getJarFile();
+
+        String urlAsString = url.toString();
+        int pathStart = urlAsString.indexOf("!/") + 2;
+        String jarPath = urlAsString.substring(pathStart);
+        jarEntry = warFile.getJarEntry(jarPath);
+
+        jarInputStream = createJarInputStream();
+    }
+
+
+    @Override
+    public boolean entryExists(String name) throws IOException {
+        JarEntry entry = jarInputStream.getNextJarEntry();
+        while (entry != null) {
+            if (name.equals(entry.getName())) {
+                break;
+            }
+            entry = jarInputStream.getNextJarEntry();
+        }
+
+        return entry != null;
+    }
+
+
+    @Override
+    public InputStream getInputStream(String name) throws IOException {
+        JarEntry entry = jarInputStream.getNextJarEntry();
+        while (entry != null) {
+            if (name.equals(entry.getName())) {
+                break;
+            }
+            entry = jarInputStream.getNextJarEntry();
+        }
+
+        if (entry == null) {
+            return null;
+        } else {
+            return jarInputStream;
+        }
+    }
+
+
+    @Override
+    public void close() {
+        closeInner();
+        if (warFile != null) {
+            try {
+                warFile.close();
+            } catch (IOException e) {
+                // Ignore
+            }
+        }
+    }
+
+
+    private void closeInner() {
+        if (jarInputStream != null) {
+            try {
+                jarInputStream.reallyClose();
+            } catch (IOException ioe) {
+                // Ignore
+            }
+        }
+    }
+
+    private NonClosingJarInputStream createJarInputStream() throws IOException {
+        return new NonClosingJarInputStream(warFile.getInputStream(jarEntry));
+    }
+
+
+    @Override
+    public void nextEntry() {
+        try {
+            entry = jarInputStream.getNextJarEntry();
+        } catch (IOException ioe) {
+            entry = null;
+        }
+    }
+
+
+    @Override
+    public String getEntryName() {
+        if (entry == null) {
+            return null;
+        } else {
+            return entry.getName();
+        }
+    }
+
+
+    @Override
+    public InputStream getEntryInputStream() throws IOException {
+        return jarInputStream;
+    }
+
+
+    @Override
+    public void reset() throws IOException {
+        closeInner();
+        jarInputStream = createJarInputStream();
+    }
+}

==================================================
