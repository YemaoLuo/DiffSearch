37ce430113dd7a1ee736ebdfd139df03222d30ad
==================================================
Fix various issues highlighted when running the Autobahn test suite on Linux.
==================================================
Mark Emlyn
==================================================
Mon Jan 14 10:45:24 2013 +0000
==================================================
AbstractProtocol.java
Fix various issues highlighted when running the Autobahn test suite on Linux.
- Don't register the socket for a read when a write event completes (may lead to thread starvation)
- Use a dedicated lock rather than the ServletOutputStream to protect the writing of a WebSocket message
- Add a lock to protect the write buffer from concurrent calls to writeInternal()
- Add a lock to ensure a consistent view of buffer and fireListenerLock

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1432867 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AbstractServletOutputStream.java
index 7836720d42..3b196113ba 100644
--- a/java/org/apache/coyote/AbstractProtocol.java
+++ b/java/org/apache/coyote/AbstractProtocol.java
@@ -663,7 +663,14 @@ public abstract class AbstractProtocol implements ProtocolHandler,
                 } else if (state == SocketState.UPGRADED) {
                     // Need to keep the connection associated with the processor
                     connections.put(socket, processor);
-                    longPoll(wrapper, processor);
+                    // Don't add sockets back to the poller if this was a
+                    // non-blocking write otherwise the poller may trigger
+                    // multiple read events which may lead to thread starvation
+                    // in the connector. The write() method will add this this
+                    // socket to the poller if necessary.
+                    if (status != SocketStatus.OPEN_WRITE) {
+                        longPoll(wrapper, processor);
+                    }
                 } else {
                     // Connection closed. OK to recycle the processor. Upgrade
                     // processors are not recycled.

==================================================
WsRemoteEndpoint.java
index ec2b8cee7a..d4c197e569 100644
--- a/java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java
+++ b/java/org/apache/coyote/http11/upgrade/AbstractServletOutputStream.java
@@ -28,6 +28,8 @@ public abstract class AbstractServletOutputStream extends ServletOutputStream {
     protected static final StringManager sm =
             StringManager.getManager(Constants.Package);
 
+    private final Object fireListenerLock = new Object();
+    private final Object nioWriteLock = new Object();
 
     // Start in blocking-mode
     private volatile WriteListener listener = null;
@@ -41,9 +43,13 @@ public abstract class AbstractServletOutputStream extends ServletOutputStream {
                     sm.getString("upgrade.sos.canWrite.is"));
         }
 
-        boolean result = (buffer == null);
-        fireListener = !result;
-        return result;
+        // Make sure canWrite() and onWritePossible() have a consistent view of
+        // buffer and fireListener when determining if the listener should fire
+        synchronized (fireListenerLock) {
+            boolean result = (buffer == null);
+            fireListener = !result;
+            return result;
+        }
     }
 
     @Override
@@ -90,14 +96,21 @@ public abstract class AbstractServletOutputStream extends ServletOutputStream {
             doWrite(true, b, off, len);
         } else {
             // Non-blocking IO
-            int written = doWrite(false, b, off, len);
-            if (written < len) {
-                // TODO: - Reuse the buffer
-                //       - Only reallocate if it gets too big (>8k?)
-                buffer = new byte[len - written];
-                System.arraycopy(b, off + written, buffer, 0, len - written);
-            } else {
-                buffer = null;
+            // If the non-blocking read does not complete, doWrite() will add
+            // the socket back into the poller. The poller way trigger a new
+            // write event before this method has finished updating buffer. This
+            // sync makes sure that buffer is updated before the next write
+            // executes.
+            synchronized (nioWriteLock) {
+                int written = doWrite(false, b, off, len);
+                if (written < len) {
+                    // TODO: - Reuse the buffer
+                    //       - Only reallocate if it gets too big (>8k?)
+                    buffer = new byte[len - written];
+                    System.arraycopy(b, off + written, buffer, 0, len - written);
+                } else {
+                    buffer = null;
+                }
             }
         }
     }
@@ -109,9 +122,13 @@ public abstract class AbstractServletOutputStream extends ServletOutputStream {
         } catch (IOException ioe) {
             throw new RuntimeException(ioe);
         }
-        if (buffer == null && fireListener) {
-            fireListener = false;
-            listener.onWritePossible();
+        // Make sure canWrite() and onWritePossible() have a consistent view of
+        // buffer and fireListener when determining if the listener should fire
+        synchronized (fireListenerLock) {
+            if (buffer == null && fireListener) {
+                fireListener = false;
+                listener.onWritePossible();
+            }
         }
     }
 

==================================================
