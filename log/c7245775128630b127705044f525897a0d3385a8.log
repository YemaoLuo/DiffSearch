c7245775128630b127705044f525897a0d3385a8
==================================================
When AprEndpoint.write(boolean, ByteBuffer) is invoked with a non direct ByteBuffer then copy that ByteBuffer to the socket write buffer before transferring the data to the socket.
==================================================
Violeta Georgieva
==================================================
Wed Aug 31 10:49:10 2016 +0000
==================================================
AprEndpoint.java
When AprEndpoint.write(boolean, ByteBuffer) is invoked with a non direct ByteBuffer then copy that ByteBuffer to the socket write buffer before transferring the data to the socket.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1758580 13f79535-47bb-0310-9956-ffa450edef68



==================================================
SocketWrapperBase.java
index bfaab8eea9..ec0015c14a 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -2478,6 +2478,59 @@ public class AprEndpoint extends AbstractEndpoint<Long> implements SNICallBack {
         }
 
 
+        @Override
+        protected void writeByteBufferBlocking(ByteBuffer from) throws IOException {
+            if (from.isDirect()) {
+                super.writeByteBufferBlocking(from);
+            } else {
+                // The socket write buffer capacity is socket.appWriteBufSize
+                ByteBuffer writeBuffer = socketBufferHandler.getWriteBuffer();
+                int limit = writeBuffer.capacity();
+                while (from.remaining() >= limit) {
+                    socketBufferHandler.configureWriteBufferForWrite();
+                    transfer(from, writeBuffer);
+                    doWrite(true);
+                }
+
+                if (from.remaining() > 0) {
+                    socketBufferHandler.configureWriteBufferForWrite();
+                    transfer(from, writeBuffer);
+                }
+            }
+        }
+
+
+        @Override
+        protected boolean writeByteBufferNonBlocking(ByteBuffer from) throws IOException {
+            if (from.isDirect()) {
+                return super.writeByteBufferNonBlocking(from);
+            } else {
+                // The socket write buffer capacity is socket.appWriteBufSize
+                ByteBuffer writeBuffer = socketBufferHandler.getWriteBuffer();
+                int limit = writeBuffer.capacity();
+                while (from.remaining() >= limit) {
+                    socketBufferHandler.configureWriteBufferForWrite();
+                    transfer(from, writeBuffer);
+                    int newPosition = writeBuffer.position() + limit;
+                    doWrite(false);
+                    if (writeBuffer.position() != newPosition) {
+                        // Didn't write the whole amount of data in the last
+                        // non-blocking write.
+                        // Exit the loop.
+                        return true;
+                    }
+                }
+
+                if (from.remaining() > 0) {
+                    socketBufferHandler.configureWriteBufferForWrite();
+                    transfer(from, writeBuffer);
+                }
+
+                return false;
+            }
+        }
+
+
         @Override
         protected void doWrite(boolean block, ByteBuffer from) throws IOException {
             if (closed) {

==================================================
