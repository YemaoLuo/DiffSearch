f6bb87109e2bd0660ba90a9bab9350b463a2a827
==================================================
Update the internal fork of Commons DBCP 2 to 2.4.0.
==================================================
Mark Thomas
==================================================
Tue Jun 19 09:04:08 2018 +0000
==================================================
AbandonedTrace.java
index 653cb85be5..314fff96e2 100644
--- a/MERGE.txt
+++ b/MERGE.txt
@@ -66,10 +66,10 @@ DBCP
 ----
 DBCP2
 Sub-tree
-/commons/proper/dbcp/trunk/src/main/java/org/apache/commons/dbcp2
-/commons/proper/dbcp/trunk/src/main/resources/org/apache/commons/dbcp2
+src/main/java/org/apache/commons/dbcp2
+src/main/resources/org/apache/commons/dbcp2
 The SHA1 ID for the most recent commit to be merged to Tomcat is:
-8a71764a895b234bd1fc76553835ef4c974f22e1
+d7aa662fbbb99e536ae28c47d0c4e1d51e39d5b9
 
 Pool2
 Sub-tree

==================================================
BasicDataSource.java
index 9345482e10..ea6d5a2082 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/AbandonedTrace.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/AbandonedTrace.java
@@ -25,43 +25,43 @@ import java.util.List;
 import org.apache.tomcat.dbcp.pool2.TrackedUse;
 
 /**
- * Tracks db connection usage for recovering and reporting
- * abandoned db connections.
+ * Tracks db connection usage for recovering and reporting abandoned db connections.
+ * <p>
+ * The JDBC Connection, Statement, and ResultSet classes extend this class.
+ * </p>
  *
- * The JDBC Connection, Statement, and ResultSet classes
- * extend this class.
- *
- * @author Glenn L. Nielsen
  * @since 2.0
  */
 public class AbandonedTrace implements TrackedUse {
 
-    /** A list of objects created by children of this object */
+    /** A list of objects created by children of this object. */
     private final List<WeakReference<AbandonedTrace>> traceList = new ArrayList<>();
-    /** Last time this connection was used */
-    private volatile long lastUsed = 0;
+
+    /** Last time this connection was used. */
+    private volatile long lastUsedMillis = 0;
 
     /**
-     * Create a new AbandonedTrace without config and
-     * without doing abandoned tracing.
+     * Creates a new AbandonedTrace without config and without doing abandoned tracing.
      */
     public AbandonedTrace() {
         init(null);
     }
 
     /**
-     * Construct a new AbandonedTrace with a parent object.
+     * Constructs a new AbandonedTrace with a parent object.
      *
-     * @param parent AbandonedTrace parent object
+     * @param parent
+     *            AbandonedTrace parent object.
      */
     public AbandonedTrace(final AbandonedTrace parent) {
         init(parent);
     }
 
     /**
-     * Initialize abandoned tracing for this object.
+     * Initializes abandoned tracing for this object.
      *
-     * @param parent AbandonedTrace parent object
+     * @param parent
+     *            AbandonedTrace parent object.
      */
     private void init(final AbandonedTrace parent) {
         if (parent != null) {
@@ -70,37 +70,37 @@ public class AbandonedTrace implements TrackedUse {
     }
 
     /**
-     * Get the last time this object was used in ms.
+     * Gets the last time this object was used in milliseconds.
      *
-     * @return long time in ms
+     * @return long time in milliseconds.
      */
     @Override
     public long getLastUsed() {
-        return lastUsed;
+        return lastUsedMillis;
     }
 
     /**
-     * Set the time this object was last used to the
-     * current time in ms.
+     * Sets the time this object was last used to the current time in milliseconds.
      */
     protected void setLastUsed() {
-        lastUsed = System.currentTimeMillis();
+        lastUsedMillis = System.currentTimeMillis();
     }
 
     /**
-     * Set the time in ms this object was last used.
+     * Sets the time in milliseconds this object was last used.
      *
-     * @param time time in ms
+     * @param lastUsedMillis
+     *            time in milliseconds.
      */
-    protected void setLastUsed(final long time) {
-        lastUsed = time;
+    protected void setLastUsed(final long lastUsedMillis) {
+        this.lastUsedMillis = lastUsedMillis;
     }
 
     /**
-     * Add an object to the list of objects being
-     * traced.
+     * Adds an object to the list of objects being traced.
      *
-     * @param trace AbandonedTrace object to add
+     * @param trace
+     *            AbandonedTrace object to add.
      */
     protected void addTrace(final AbandonedTrace trace) {
         synchronized (this.traceList) {
@@ -110,19 +110,18 @@ public class AbandonedTrace implements TrackedUse {
     }
 
     /**
-     * Clear the list of objects being traced by this
-     * object.
+     * Clears the list of objects being traced by this object.
      */
     protected void clearTrace() {
-        synchronized(this.traceList) {
+        synchronized (this.traceList) {
             this.traceList.clear();
         }
     }
 
     /**
-     * Get a list of objects being traced by this object.
+     * Gets a list of objects being traced by this object.
      *
-     * @return List of objects
+     * @return List of objects.
      */
     protected List<AbandonedTrace> getTrace() {
         final int size = traceList.size();
@@ -133,12 +132,12 @@ public class AbandonedTrace implements TrackedUse {
         synchronized (this.traceList) {
             final Iterator<WeakReference<AbandonedTrace>> iter = traceList.iterator();
             while (iter.hasNext()) {
-                final WeakReference<AbandonedTrace> ref = iter.next();
-                if (ref.get() == null) {
+                final AbandonedTrace trace = iter.next().get();
+                if (trace == null) {
                     // Clean-up since we are here anyway
                     iter.remove();
                 } else {
-                    result.add(ref.get());
+                    result.add(trace);
                 }
             }
         }
@@ -146,19 +145,20 @@ public class AbandonedTrace implements TrackedUse {
     }
 
     /**
-     * Remove a child object this object is tracing.
+     * Removes a child object this object is tracing.
      *
-     * @param trace AbandonedTrace object to remove
+     * @param trace
+     *            AbandonedTrace object to remove.
      */
     protected void removeTrace(final AbandonedTrace trace) {
-        synchronized(this.traceList) {
+        synchronized (this.traceList) {
             final Iterator<WeakReference<AbandonedTrace>> iter = traceList.iterator();
             while (iter.hasNext()) {
-                final WeakReference<AbandonedTrace> ref = iter.next();
-                if (trace.equals(ref.get())) {
+                final AbandonedTrace traceInList = iter.next().get();
+                if (trace.equals(traceInList)) {
                     iter.remove();
                     break;
-                } else if (ref.get() == null) {
+                } else if (traceInList == null) {
                     // Clean-up since we are here anyway
                     iter.remove();
                 }

==================================================
BasicDataSourceFactory.java
index 5390ed24cf..d62cd02f37 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java
@@ -18,7 +18,6 @@ package org.apache.tomcat.dbcp.dbcp2;
 
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
-import java.lang.management.ManagementFactory;
 import java.nio.charset.StandardCharsets;
 import java.security.AccessController;
 import java.security.PrivilegedActionException;
@@ -33,17 +32,14 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Objects;
 import java.util.Properties;
 import java.util.Set;
 import java.util.logging.Logger;
 
-import javax.management.InstanceAlreadyExistsException;
-import javax.management.JMException;
 import javax.management.MBeanRegistration;
-import javax.management.MBeanRegistrationException;
 import javax.management.MBeanServer;
 import javax.management.MalformedObjectNameException;
-import javax.management.NotCompliantMBeanException;
 import javax.management.ObjectName;
 import javax.sql.DataSource;
 
@@ -57,14 +53,12 @@ import org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool;
 import org.apache.tomcat.dbcp.pool2.impl.GenericObjectPoolConfig;
 
 /**
- * <p>Basic implementation of <code>javax.sql.DataSource</code> that is
- * configured via JavaBeans properties.  This is not the only way to
- * combine the <em>commons-dbcp2</em> and <em>commons-pool2</em> packages,
- * but provides a "one stop shopping" solution for basic requirements.</p>
+ * <p>
+ * Basic implementation of <code>javax.sql.DataSource</code> that is configured via JavaBeans properties. This is not
+ * the only way to combine the <em>commons-dbcp2</em> and <em>commons-pool2</em> packages, but provides a "one stop
+ * shopping" solution for basic requirements.
+ * </p>
  *
- * @author Glenn L. Nielsen
- * @author Craig R. McClanahan
- * @author Dirk Verbeeck
  * @since 2.0
  */
 public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBeanRegistration, AutoCloseable {
@@ -119,21 +113,22 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Sets default auto-commit state of connections returned by this
-     * datasource.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Sets default auto-commit state of connections returned by this datasource.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param defaultAutoCommit default auto-commit value
+     * @param defaultAutoCommit
+     *            default auto-commit value
      */
     public void setDefaultAutoCommit(final Boolean defaultAutoCommit) {
         this.defaultAutoCommit = defaultAutoCommit;
     }
 
-
     /**
      * The default read-only state of connections created by this pool.
      */
@@ -150,14 +145,17 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Sets defaultReadonly property.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Sets defaultReadonly property.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param defaultReadOnly default read-only value
+     * @param defaultReadOnly
+     *            default read-only value
      */
     public void setDefaultReadOnly(final Boolean defaultReadOnly) {
         this.defaultReadOnly = defaultReadOnly;
@@ -166,8 +164,7 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     /**
      * The default TransactionIsolation state of connections created by this pool.
      */
-    private volatile int defaultTransactionIsolation =
-        PoolableConnectionFactory.UNKNOWN_TRANSACTIONISOLATION;
+    private volatile int defaultTransactionIsolation = PoolableConnectionFactory.UNKNOWN_TRANSACTIONISOLATION;
 
     /**
      * Returns the default transaction isolation state of returned connections.
@@ -181,47 +178,46 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Sets the default transaction isolation state for returned
-     * connections.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Sets the default transaction isolation state for returned connections.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param defaultTransactionIsolation the default transaction isolation
-     * state
+     * @param defaultTransactionIsolation
+     *            the default transaction isolation state
      * @see Connection#getTransactionIsolation
      */
     public void setDefaultTransactionIsolation(final int defaultTransactionIsolation) {
         this.defaultTransactionIsolation = defaultTransactionIsolation;
     }
 
-
-    private Integer defaultQueryTimeout;
+    private Integer defaultQueryTimeoutSeconds;
 
     /**
-     * Obtain the default query timeout that will be used for {@link java.sql.Statement Statement}s
-     * created from this connection. <code>null</code> means that the driver
-     * default will be used.
-     * @return the timoeut
+     * Gets the default query timeout that will be used for {@link java.sql.Statement Statement}s created from this
+     * connection. <code>null</code> means that the driver default will be used.
+     *
+     * @return The default query timeout in seconds.
      */
     public Integer getDefaultQueryTimeout() {
-        return defaultQueryTimeout;
+        return defaultQueryTimeoutSeconds;
     }
 
-
     /**
-     * Set the default query timeout that will be used for {@link java.sql.Statement Statement}s
-     * created from this connection. <code>null</code> means that the driver
-     * default will be used.
-     * @param defaultQueryTimeout The new default timeout
+     * Sets the default query timeout that will be used for {@link java.sql.Statement Statement}s created from this
+     * connection. <code>null</code> means that the driver default will be used.
+     *
+     * @param defaultQueryTimeoutSeconds
+     *            The default query timeout in seconds.
      */
-    public void setDefaultQueryTimeout(final Integer defaultQueryTimeout) {
-        this.defaultQueryTimeout = defaultQueryTimeout;
+    public void setDefaultQueryTimeout(final Integer defaultQueryTimeoutSeconds) {
+        this.defaultQueryTimeoutSeconds = defaultQueryTimeoutSeconds;
     }
 
-
     /**
      * The default "catalog" of connections created by this pool.
      */
@@ -238,34 +234,36 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Sets the default catalog.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Sets the default catalog.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param defaultCatalog the default catalog
+     * @param defaultCatalog
+     *            the default catalog
      */
     public void setDefaultCatalog(final String defaultCatalog) {
         if (defaultCatalog != null && defaultCatalog.trim().length() > 0) {
             this.defaultCatalog = defaultCatalog;
-        }
-        else {
+        } else {
             this.defaultCatalog = null;
         }
     }
 
     /**
-     * The property that controls if the pooled connections cache some state
-     * rather than query the database for current state to improve performance.
+     * The property that controls if the pooled connections cache some state rather than query the database for current
+     * state to improve performance.
      */
     private boolean cacheState = true;
 
     /**
      * Returns the state caching flag.
      *
-     * @return  the state caching flag
+     * @return the state caching flag
      */
     @Override
     public boolean getCacheState() {
@@ -275,7 +273,8 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     /**
      * Sets the state caching flag.
      *
-     * @param cacheState    The new value for the state caching flag
+     * @param cacheState
+     *            The new value for the state caching flag
      */
     public void setCacheState(final boolean cacheState) {
         this.cacheState = cacheState;
@@ -289,10 +288,9 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     /**
      * Returns the JDBC Driver that has been configured for use by this pool.
      * <p>
-     * Note: This getter only returns the last value set by a call to
-     * {@link #setDriver(Driver)}. It does not return any driver instance that
-     * may have been created from the value set via
-     * {@link #setDriverClassName(String)}.
+     * Note: This getter only returns the last value set by a call to {@link #setDriver(Driver)}. It does not return any
+     * driver instance that may have been created from the value set via {@link #setDriverClassName(String)}.
+     * </p>
      *
      * @return the JDBC Driver that has been configured for use by this pool
      */
@@ -303,12 +301,13 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     /**
      * Sets the JDBC Driver instance to use for this pool.
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param driver The driver to use
+     * @param driver
+     *            The JDBC Driver instance to use for this pool.
      */
     public synchronized void setDriver(final Driver driver) {
         this.driver = driver;
@@ -322,9 +321,9 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     /**
      * Returns the JDBC driver class name.
      * <p>
-     * Note: This getter only returns the last value set by a call to
-     * {@link #setDriverClassName(String)}. It does not return the class name of
-     * any driver that may have been set via {@link #setDriver(Driver)}.
+     * Note: This getter only returns the last value set by a call to {@link #setDriverClassName(String)}. It does not
+     * return the class name of any driver that may have been set via {@link #setDriver(Driver)}.
+     * </p>
      *
      * @return the JDBC driver class name
      */
@@ -334,74 +333,74 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Sets the JDBC driver class name.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Sets the JDBC driver class name.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param driverClassName the class name of the JDBC driver
+     * @param driverClassName
+     *            the class name of the JDBC driver
      */
     public synchronized void setDriverClassName(final String driverClassName) {
         if (driverClassName != null && driverClassName.trim().length() > 0) {
             this.driverClassName = driverClassName;
-        }
-        else {
+        } else {
             this.driverClassName = null;
         }
     }
 
     /**
-     * The class loader instance to use to load the JDBC driver. If not
-     * specified, {@link Class#forName(String)} is used to load the JDBC driver.
-     * If specified, {@link Class#forName(String, boolean, ClassLoader)} is
-     * used.
+     * The class loader instance to use to load the JDBC driver. If not specified, {@link Class#forName(String)} is used
+     * to load the JDBC driver. If specified, {@link Class#forName(String, boolean, ClassLoader)} is used.
      */
     private ClassLoader driverClassLoader;
 
     /**
-     * Returns the class loader specified for loading the JDBC driver. Returns
-     * <code>null</code> if no class loader has been explicitly specified.
+     * Returns the class loader specified for loading the JDBC driver. Returns <code>null</code> if no class loader has
+     * been explicitly specified.
      * <p>
-     * Note: This getter only returns the last value set by a call to
-     * {@link #setDriverClassLoader(ClassLoader)}. It does not return the class
-     * loader of any driver that may have been set via
-     * {@link #setDriver(Driver)}.
-     * @return the classloader
+     * Note: This getter only returns the last value set by a call to {@link #setDriverClassLoader(ClassLoader)}. It
+     * does not return the class loader of any driver that may have been set via {@link #setDriver(Driver)}.
+     * </p>
+     *
+     * @return The class loader specified for loading the JDBC driver.
      */
     public synchronized ClassLoader getDriverClassLoader() {
         return this.driverClassLoader;
     }
 
     /**
-     * <p>Sets the class loader to be used to load the JDBC driver.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Sets the class loader to be used to load the JDBC driver.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param driverClassLoader the class loader with which to load the JDBC
-     *                          driver
+     * @param driverClassLoader
+     *            the class loader with which to load the JDBC driver
      */
-    public synchronized void setDriverClassLoader(
-            final ClassLoader driverClassLoader) {
+    public synchronized void setDriverClassLoader(final ClassLoader driverClassLoader) {
         this.driverClassLoader = driverClassLoader;
     }
 
     /**
-     * True means that borrowObject returns the most recently used ("last in")
-     * connection in the pool (if there are idle connections available).  False
-     * means that the pool behaves as a FIFO queue - connections are taken from
-     * the idle instance pool in the order that they are returned to the pool.
+     * True means that borrowObject returns the most recently used ("last in") connection in the pool (if there are idle
+     * connections available). False means that the pool behaves as a FIFO queue - connections are taken from the idle
+     * instance pool in the order that they are returned to the pool.
      */
     private boolean lifo = BaseObjectPoolConfig.DEFAULT_LIFO;
 
     /**
      * Returns the LIFO property.
      *
-     * @return <code>true</code> if connection pool behaves as a LIFO queue.
+     * @return true if connection pool behaves as a LIFO queue.
      */
     @Override
     public synchronized boolean getLifo() {
@@ -409,10 +408,10 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Sets the LIFO property. True means the pool behaves as a LIFO queue;
-     * false means FIFO.
+     * Sets the LIFO property. True means the pool behaves as a LIFO queue; false means FIFO.
      *
-     * @param lifo the new value for the LIFO property
+     * @param lifo
+     *            the new value for the LIFO property
      */
     public synchronized void setLifo(final boolean lifo) {
         this.lifo = lifo;
@@ -422,16 +421,18 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * The maximum number of active connections that can be allocated from
-     * this pool at the same time, or negative for no limit.
+     * The maximum number of active connections that can be allocated from this pool at the same time, or negative for
+     * no limit.
      */
     private int maxTotal = GenericObjectPoolConfig.DEFAULT_MAX_TOTAL;
 
     /**
-     * <p>Returns the maximum number of active connections that can be
-     * allocated at the same time.
+     * <p>
+     * Returns the maximum number of active connections that can be allocated at the same time.
+     * </p>
+     * <p>
+     * A negative number means that there is no limit.
      * </p>
-     * <p>A negative number means that there is no limit.</p>
      *
      * @return the maximum number of active connections
      */
@@ -441,10 +442,11 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Sets the maximum total number of idle and borrows connections that can be
-     * active at the same time. Use a negative value for no limit.
+     * Sets the maximum total number of idle and borrows connections that can be active at the same time. Use a negative
+     * value for no limit.
      *
-     * @param maxTotal the new value for maxTotal
+     * @param maxTotal
+     *            the new value for maxTotal
      * @see #getMaxTotal()
      */
     public synchronized void setMaxTotal(final int maxTotal) {
@@ -455,22 +457,23 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * The maximum number of connections that can remain idle in the
-     * pool, without extra ones being destroyed, or negative for no limit.
-     * If maxIdle is set too low on heavily loaded systems it is possible you
-     * will see connections being closed and almost immediately new connections
-     * being opened. This is a result of the active threads momentarily closing
-     * connections faster than they are opening them, causing the number of idle
-     * connections to rise above maxIdle. The best value for maxIdle for heavily
-     * loaded system will vary but the default is a good starting point.
+     * The maximum number of connections that can remain idle in the pool, without extra ones being destroyed, or
+     * negative for no limit. If maxIdle is set too low on heavily loaded systems it is possible you will see
+     * connections being closed and almost immediately new connections being opened. This is a result of the active
+     * threads momentarily closing connections faster than they are opening them, causing the number of idle connections
+     * to rise above maxIdle. The best value for maxIdle for heavily loaded system will vary but the default is a good
+     * starting point.
      */
     private int maxIdle = GenericObjectPoolConfig.DEFAULT_MAX_IDLE;
 
     /**
-     * <p>Returns the maximum number of connections that can remain idle in the
-     * pool. Excess idle connections are destroyed on return to the pool.
+     * <p>
+     * Returns the maximum number of connections that can remain idle in the pool. Excess idle connections are destroyed
+     * on return to the pool.
+     * </p>
+     * <p>
+     * A negative value indicates that there is no limit
      * </p>
-     * <p>A negative value indicates that there is no limit</p>
      *
      * @return the maximum number of idle connections
      */
@@ -480,11 +483,12 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Sets the maximum number of connections that can remain idle in the
-     * pool. Excess idle connections are destroyed on return to the pool.
+     * Sets the maximum number of connections that can remain idle in the pool. Excess idle connections are destroyed on
+     * return to the pool.
      *
      * @see #getMaxIdle()
-     * @param maxIdle the new value for maxIdle
+     * @param maxIdle
+     *            the new value for maxIdle
      */
     public synchronized void setMaxIdle(final int maxIdle) {
         this.maxIdle = maxIdle;
@@ -494,19 +498,17 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * The minimum number of active connections that can remain idle in the
-     * pool, without extra ones being created when the evictor runs, or 0 to create none.
-     * The pool attempts to ensure that minIdle connections are available when the idle object evictor
-     * runs. The value of this property has no effect unless {@link #timeBetweenEvictionRunsMillis}
-     * has a positive value.
+     * The minimum number of active connections that can remain idle in the pool, without extra ones being created when
+     * the evictor runs, or 0 to create none. The pool attempts to ensure that minIdle connections are available when
+     * the idle object evictor runs. The value of this property has no effect unless
+     * {@link #timeBetweenEvictionRunsMillis} has a positive value.
      */
     private int minIdle = GenericObjectPoolConfig.DEFAULT_MIN_IDLE;
 
     /**
-     * Returns the minimum number of idle connections in the pool. The pool attempts
-     * to ensure that minIdle connections are available when the idle object evictor
-     * runs. The value of this property has no effect unless {@link #timeBetweenEvictionRunsMillis}
-     * has a positive value.
+     * Returns the minimum number of idle connections in the pool. The pool attempts to ensure that minIdle connections
+     * are available when the idle object evictor runs. The value of this property has no effect unless
+     * {@link #timeBetweenEvictionRunsMillis} has a positive value.
      *
      * @return the minimum number of idle connections
      * @see GenericObjectPool#getMinIdle()
@@ -517,24 +519,23 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Sets the minimum number of idle connections in the pool. The pool attempts
-     * to ensure that minIdle connections are available when the idle object evictor
-     * runs. The value of this property has no effect unless {@link #timeBetweenEvictionRunsMillis}
-     * has a positive value.
+     * Sets the minimum number of idle connections in the pool. The pool attempts to ensure that minIdle connections are
+     * available when the idle object evictor runs. The value of this property has no effect unless
+     * {@link #timeBetweenEvictionRunsMillis} has a positive value.
      *
-     * @param minIdle the new value for minIdle
+     * @param minIdle
+     *            the new value for minIdle
      * @see GenericObjectPool#setMinIdle(int)
      */
     public synchronized void setMinIdle(final int minIdle) {
-       this.minIdle = minIdle;
-       if (connectionPool != null) {
-           connectionPool.setMinIdle(minIdle);
-       }
+        this.minIdle = minIdle;
+        if (connectionPool != null) {
+            connectionPool.setMinIdle(minIdle);
+        }
     }
 
     /**
-     * The initial number of connections that are created when the pool
-     * is started.
+     * The initial number of connections that are created when the pool is started.
      */
     private int initialSize = 0;
 
@@ -549,32 +550,31 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Sets the initial size of the connection pool.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Sets the initial size of the connection pool.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param initialSize the number of connections created when the pool
-     * is initialized
+     * @param initialSize
+     *            the number of connections created when the pool is initialized
      */
     public synchronized void setInitialSize(final int initialSize) {
         this.initialSize = initialSize;
     }
 
     /**
-     * The maximum number of milliseconds that the pool will wait (when there
-     * are no available connections) for a connection to be returned before
-     * throwing an exception, or <= 0 to wait indefinitely.
+     * The maximum number of milliseconds that the pool will wait (when there are no available connections) for a
+     * connection to be returned before throwing an exception, or <= 0 to wait indefinitely.
      */
-    private long maxWaitMillis =
-            BaseObjectPoolConfig.DEFAULT_MAX_WAIT_MILLIS;
+    private long maxWaitMillis = BaseObjectPoolConfig.DEFAULT_MAX_WAIT_MILLIS;
 
     /**
-     * Returns the maximum number of milliseconds that the pool will wait
-     * for a connection to be returned before throwing an exception. A value
-     * less than or equal to zero means the pool is set to wait indefinitely.
+     * Returns the maximum number of milliseconds that the pool will wait for a connection to be returned before
+     * throwing an exception. A value less than or equal to zero means the pool is set to wait indefinitely.
      *
      * @return the maxWaitMillis property value
      */
@@ -584,10 +584,10 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Sets the MaxWaitMillis property. Use -1 to make the pool wait
-     * indefinitely.
+     * Sets the MaxWaitMillis property. Use -1 to make the pool wait indefinitely.
      *
-     * @param maxWaitMillis the new value for MaxWaitMillis
+     * @param maxWaitMillis
+     *            the new value for MaxWaitMillis
      * @see #getMaxWaitMillis()
      */
     public synchronized void setMaxWaitMillis(final long maxWaitMillis) {
@@ -598,15 +598,15 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Prepared statement pooling for this pool. When this property is set to <code>true</code>
-     * both PreparedStatements and CallableStatements are pooled.
+     * Prepared statement pooling for this pool. When this property is set to <code>true</code> both PreparedStatements
+     * and CallableStatements are pooled.
      */
     private boolean poolPreparedStatements = false;
 
     /**
      * Returns true if we are pooling statements.
      *
-     * @return <code>true</code> if prepared and callable statements are pooled
+     * @return true if prepared and callable statements are pooled
      */
     @Override
     public synchronized boolean isPoolPreparedStatements() {
@@ -614,32 +614,36 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Sets whether to pool statements or not.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Sets whether to pool statements or not.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param poolingStatements pooling on or off
+     * @param poolingStatements
+     *            pooling on or off
      */
     public synchronized void setPoolPreparedStatements(final boolean poolingStatements) {
         this.poolPreparedStatements = poolingStatements;
     }
 
     /**
-     * <p>The maximum number of open statements that can be allocated from
-     * the statement pool at the same time, or negative for no limit.  Since
-     * a connection usually only uses one or two statements at a time, this is
-     * mostly used to help detect resource leaks.</p>
-     *
-     * <p>Note: As of version 1.3, CallableStatements (those produced by {@link Connection#prepareCall})
-     * are pooled along with PreparedStatements (produced by {@link Connection#prepareStatement})
-     * and <code>maxOpenPreparedStatements</code> limits the total number of prepared or callable statements
-     * that may be in use at a given time.</p>
+     * <p>
+     * The maximum number of open statements that can be allocated from the statement pool at the same time, or negative
+     * for no limit. Since a connection usually only uses one or two statements at a time, this is mostly used to help
+     * detect resource leaks.
+     * </p>
+     * <p>
+     * Note: As of version 1.3, CallableStatements (those produced by {@link Connection#prepareCall}) are pooled along
+     * with PreparedStatements (produced by {@link Connection#prepareStatement}) and
+     * <code>maxOpenPreparedStatements</code> limits the total number of prepared or callable statements that may be in
+     * use at a given time.
+     * </p>
      */
-    private int maxOpenPreparedStatements =
-        GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL;
+    private int maxOpenPreparedStatements = GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL;
 
     /**
      * Gets the value of the <code>maxOpenPreparedStatements</code> property.
@@ -652,33 +656,32 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Sets the value of the <code>maxOpenPreparedStatements</code>
-     * property.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Sets the value of the <code>maxOpenPreparedStatements</code> property.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param maxOpenStatements the new maximum number of prepared statements
+     * @param maxOpenStatements
+     *            the new maximum number of prepared statements
      */
     public synchronized void setMaxOpenPreparedStatements(final int maxOpenStatements) {
         this.maxOpenPreparedStatements = maxOpenStatements;
     }
 
     /**
-     * The indication of whether objects will be validated as soon as they have
-     * been created by the pool. If the object fails to validate, the borrow
-     * operation that triggered the creation will fail.
+     * The indication of whether objects will be validated as soon as they have been created by the pool. If the object
+     * fails to validate, the borrow operation that triggered the creation will fail.
      */
     private boolean testOnCreate = false;
 
     /**
      * Returns the {@link #testOnCreate} property.
      *
-     * @return <code>true</code> if objects are validated immediately
-     *  after they are created by the pool
-     *
+     * @return true if objects are validated immediately after they are created by the pool
      * @see #testOnCreate
      */
     @Override
@@ -687,11 +690,11 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Sets the {@link #testOnCreate} property. This property determines
-     * whether or not the pool will validate objects immediately after they are
-     * created by the pool
+     * Sets the {@link #testOnCreate} property. This property determines whether or not the pool will validate objects
+     * immediately after they are created by the pool
      *
-     * @param testOnCreate new value for testOnCreate property
+     * @param testOnCreate
+     *            new value for testOnCreate property
      */
     public synchronized void setTestOnCreate(final boolean testOnCreate) {
         this.testOnCreate = testOnCreate;
@@ -701,17 +704,15 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * The indication of whether objects will be validated before being
-     * borrowed from the pool.  If the object fails to validate, it will be
-     * dropped from the pool, and we will attempt to borrow another.
+     * The indication of whether objects will be validated before being borrowed from the pool. If the object fails to
+     * validate, it will be dropped from the pool, and we will attempt to borrow another.
      */
     private boolean testOnBorrow = true;
 
     /**
      * Returns the {@link #testOnBorrow} property.
      *
-     * @return <code>true</code> if objects are validated before being
-     *  borrowed from the pool
+     * @return true if objects are validated before being borrowed from the pool
      *
      * @see #testOnBorrow
      */
@@ -721,11 +722,11 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Sets the {@link #testOnBorrow} property. This property determines
-     * whether or not the pool will validate objects before they are borrowed
-     * from the pool.
+     * Sets the {@link #testOnBorrow} property. This property determines whether or not the pool will validate objects
+     * before they are borrowed from the pool.
      *
-     * @param testOnBorrow new value for testOnBorrow property
+     * @param testOnBorrow
+     *            new value for testOnBorrow property
      */
     public synchronized void setTestOnBorrow(final boolean testOnBorrow) {
         this.testOnBorrow = testOnBorrow;
@@ -735,16 +736,14 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * The indication of whether objects will be validated before being
-     * returned to the pool.
+     * The indication of whether objects will be validated before being returned to the pool.
      */
     private boolean testOnReturn = false;
 
     /**
      * Returns the value of the {@link #testOnReturn} property.
      *
-     * @return <code>true</code> if objects are validated before being
-     *  returned to the pool
+     * @return true if objects are validated before being returned to the pool
      * @see #testOnReturn
      */
     public synchronized boolean getTestOnReturn() {
@@ -752,11 +751,11 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Sets the <code>testOnReturn</code> property. This property determines
-     * whether or not the pool will validate objects before they are returned
-     * to the pool.
+     * Sets the <code>testOnReturn</code> property. This property determines whether or not the pool will validate
+     * objects before they are returned to the pool.
      *
-     * @param testOnReturn new value for testOnReturn property
+     * @param testOnReturn
+     *            new value for testOnReturn property
      */
     public synchronized void setTestOnReturn(final boolean testOnReturn) {
         this.testOnReturn = testOnReturn;
@@ -766,16 +765,13 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * The number of milliseconds to sleep between runs of the idle object
-     * evictor thread.  When non-positive, no idle object evictor thread will
-     * be run.
+     * The number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive, no idle
+     * object evictor thread will be run.
      */
-    private long timeBetweenEvictionRunsMillis =
-        BaseObjectPoolConfig.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
+    private long timeBetweenEvictionRunsMillis = BaseObjectPoolConfig.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
 
     /**
-     * Returns the value of the {@link #timeBetweenEvictionRunsMillis}
-     * property.
+     * Returns the value of the {@link #timeBetweenEvictionRunsMillis} property.
      *
      * @return the time (in milliseconds) between evictor runs
      * @see #timeBetweenEvictionRunsMillis
@@ -788,7 +784,8 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     /**
      * Sets the {@link #timeBetweenEvictionRunsMillis} property.
      *
-     * @param timeBetweenEvictionRunsMillis the new time between evictor runs
+     * @param timeBetweenEvictionRunsMillis
+     *            the new time between evictor runs
      * @see #timeBetweenEvictionRunsMillis
      */
     public synchronized void setTimeBetweenEvictionRunsMillis(final long timeBetweenEvictionRunsMillis) {
@@ -799,17 +796,14 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * The number of objects to examine during each run of the idle object
-     * evictor thread (if any).
+     * The number of objects to examine during each run of the idle object evictor thread (if any).
      */
-    private int numTestsPerEvictionRun =
-        BaseObjectPoolConfig.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
+    private int numTestsPerEvictionRun = BaseObjectPoolConfig.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
 
     /**
      * Returns the value of the {@link #numTestsPerEvictionRun} property.
      *
-     * @return the number of objects to examine during idle object evictor
-     * runs
+     * @return the number of objects to examine during idle object evictor runs
      * @see #numTestsPerEvictionRun
      */
     @Override
@@ -820,8 +814,8 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     /**
      * Sets the value of the {@link #numTestsPerEvictionRun} property.
      *
-     * @param numTestsPerEvictionRun the new {@link #numTestsPerEvictionRun}
-     * value
+     * @param numTestsPerEvictionRun
+     *            the new {@link #numTestsPerEvictionRun} value
      * @see #numTestsPerEvictionRun
      */
     public synchronized void setNumTestsPerEvictionRun(final int numTestsPerEvictionRun) {
@@ -832,11 +826,10 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * The minimum amount of time an object may sit idle in the pool before it
-     * is eligible for eviction by the idle object evictor (if any).
+     * The minimum amount of time an object may sit idle in the pool before it is eligible for eviction by the idle
+     * object evictor (if any).
      */
-    private long minEvictableIdleTimeMillis =
-        BaseObjectPoolConfig.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
+    private long minEvictableIdleTimeMillis = BaseObjectPoolConfig.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
 
     /**
      * Returns the {@link #minEvictableIdleTimeMillis} property.
@@ -852,8 +845,8 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     /**
      * Sets the {@link #minEvictableIdleTimeMillis} property.
      *
-     * @param minEvictableIdleTimeMillis the minimum amount of time an object
-     * may sit idle in the pool
+     * @param minEvictableIdleTimeMillis
+     *            the minimum amount of time an object may sit idle in the pool
      * @see #minEvictableIdleTimeMillis
      */
     public synchronized void setMinEvictableIdleTimeMillis(final long minEvictableIdleTimeMillis) {
@@ -864,23 +857,20 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * The minimum amount of time a connection may sit idle in the pool before
-     * it is eligible for eviction by the idle object evictor, with the extra
-     * condition that at least "minIdle" connections remain in the pool.
-     * Note that {@code minEvictableIdleTimeMillis} takes precedence over this
-     * parameter.  See {@link #getSoftMinEvictableIdleTimeMillis()}.
+     * The minimum amount of time a connection may sit idle in the pool before it is eligible for eviction by the idle
+     * object evictor, with the extra condition that at least "minIdle" connections remain in the pool. Note that
+     * {@code minEvictableIdleTimeMillis} takes precedence over this parameter. See
+     * {@link #getSoftMinEvictableIdleTimeMillis()}.
      */
-    private long softMinEvictableIdleTimeMillis =
-        BaseObjectPoolConfig.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
+    private long softMinEvictableIdleTimeMillis = BaseObjectPoolConfig.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
 
     /**
-     * Sets the minimum amount of time a connection may sit idle in the pool
-     * before it is eligible for eviction by the idle object evictor, with the
-     * extra condition that at least "minIdle" connections remain in the pool.
+     * Sets the minimum amount of time a connection may sit idle in the pool before it is eligible for eviction by the
+     * idle object evictor, with the extra condition that at least "minIdle" connections remain in the pool.
      *
-     * @param softMinEvictableIdleTimeMillis minimum amount of time a
-     * connection may sit idle in the pool before it is eligible for eviction,
-     * assuming there are minIdle idle connections in the pool.
+     * @param softMinEvictableIdleTimeMillis
+     *            minimum amount of time a connection may sit idle in the pool before it is eligible for eviction,
+     *            assuming there are minIdle idle connections in the pool.
      * @see #getSoftMinEvictableIdleTimeMillis
      */
     public synchronized void setSoftMinEvictableIdleTimeMillis(final long softMinEvictableIdleTimeMillis) {
@@ -891,35 +881,33 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Returns the minimum amount of time a connection may sit idle in the
-     * pool before it is eligible for eviction by the idle object evictor, with
-     * the extra condition that at least "minIdle" connections remain in the
-     * pool.</p>
+     * <p>
+     * Returns the minimum amount of time a connection may sit idle in the pool before it is eligible for eviction by
+     * the idle object evictor, with the extra condition that at least "minIdle" connections remain in the pool.
+     * </p>
      *
-     * <p>When {@link #getMinEvictableIdleTimeMillis() minEvictableIdleTimeMillis}
-     * is set to a positive value, minEvictableIdleTimeMillis is examined
-     * first by the idle connection evictor - i.e. when idle connections are
-     * visited by the evictor, idle time is first compared against
-     * {@code minEvictableIdleTimeMillis} (without considering the number of idle
-     * connections in the pool) and then against
-     * {@code softMinEvictableIdleTimeMillis}, including the {@code minIdle},
-     * constraint.</p>
+     * <p>
+     * When {@link #getMinEvictableIdleTimeMillis() minEvictableIdleTimeMillis} is set to a positive value,
+     * minEvictableIdleTimeMillis is examined first by the idle connection evictor - i.e. when idle connections are
+     * visited by the evictor, idle time is first compared against {@code minEvictableIdleTimeMillis} (without
+     * considering the number of idle connections in the pool) and then against {@code softMinEvictableIdleTimeMillis},
+     * including the {@code minIdle}, constraint.
+     * </p>
      *
-     * @return minimum amount of time a connection may sit idle in the pool before
-     * it is eligible for eviction, assuming there are minIdle idle connections
-     * in the pool
+     * @return minimum amount of time a connection may sit idle in the pool before it is eligible for eviction, assuming
+     *         there are minIdle idle connections in the pool
      */
     @Override
     public synchronized long getSoftMinEvictableIdleTimeMillis() {
         return softMinEvictableIdleTimeMillis;
     }
 
-    private String evictionPolicyClassName =
-            BaseObjectPoolConfig.DEFAULT_EVICTION_POLICY_CLASS_NAME;
+    private String evictionPolicyClassName = BaseObjectPoolConfig.DEFAULT_EVICTION_POLICY_CLASS_NAME;
 
     /**
      * Gets the EvictionPolicy implementation in use with this connection pool.
-     * @return the eviction policy
+     *
+     * @return The EvictionPolicy implementation in use with this connection pool.
      */
     public synchronized String getEvictionPolicyClassName() {
         return evictionPolicyClassName;
@@ -928,11 +916,10 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     /**
      * Sets the EvictionPolicy implementation to use with this connection pool.
      *
-     * @param evictionPolicyClassName   The fully qualified class name of the
-     *                                  EvictionPolicy implementation
+     * @param evictionPolicyClassName
+     *            The fully qualified class name of the EvictionPolicy implementation
      */
-    public synchronized void setEvictionPolicyClassName(
-            final String evictionPolicyClassName) {
+    public synchronized void setEvictionPolicyClassName(final String evictionPolicyClassName) {
         if (connectionPool != null) {
             connectionPool.setEvictionPolicyClassName(evictionPolicyClassName);
         }
@@ -940,17 +927,15 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * The indication of whether objects will be validated by the idle object
-     * evictor (if any).  If an object fails to validate, it will be dropped
-     * from the pool.
+     * The indication of whether objects will be validated by the idle object evictor (if any). If an object fails to
+     * validate, it will be dropped from the pool.
      */
     private boolean testWhileIdle = false;
 
     /**
      * Returns the value of the {@link #testWhileIdle} property.
      *
-     * @return <code>true</code> if objects examined by
-     *  the idle object evictor are validated
+     * @return true if objects examined by the idle object evictor are validated
      * @see #testWhileIdle
      */
     @Override
@@ -959,10 +944,11 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Sets the <code>testWhileIdle</code> property. This property determines
-     * whether or not the idle object evictor will validate connections.
+     * Sets the <code>testWhileIdle</code> property. This property determines whether or not the idle object evictor
+     * will validate connections.
      *
-     * @param testWhileIdle new value for testWhileIdle property
+     * @param testWhileIdle
+     *            new value for testWhileIdle property
      */
     public synchronized void setTestWhileIdle(final boolean testWhileIdle) {
         this.testWhileIdle = testWhileIdle;
@@ -972,8 +958,7 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * [Read Only] The current number of active connections that have been
-     * allocated from this data source.
+     * [Read Only] The current number of active connections that have been allocated from this data source.
      *
      * @return the current number of active connections
      */
@@ -987,10 +972,8 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
         return 0;
     }
 
-
     /**
-     * [Read Only] The current number of idle connections that are waiting
-     * to be allocated from this data source.
+     * [Read Only] The current number of idle connections that are waiting to be allocated from this data source.
      *
      * @return the current number of idle connections
      */
@@ -1005,8 +988,7 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * The connection password to be passed to our JDBC driver to establish
-     * a connection.
+     * The connection password to be passed to our JDBC driver to establish a connection.
      */
     private volatile String password;
 
@@ -1021,30 +1003,31 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Sets the {@link #password}.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Sets the {@link #password}.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param password new value for the password
+     * @param password
+     *            new value for the password
      */
     public void setPassword(final String password) {
         this.password = password;
     }
 
     /**
-     * The connection URL to be passed to our JDBC driver to establish
-     * a connection.
+     * The connection URL to be passed to our JDBC driver to establish a connection.
      */
     private String url;
 
     /**
      * Returns the JDBC connection {@link #url} property.
      *
-     * @return the {@link #url} passed to the JDBC driver to establish
-     * connections
+     * @return the {@link #url} passed to the JDBC driver to establish connections
      */
     @Override
     public synchronized String getUrl() {
@@ -1052,62 +1035,63 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Sets the {@link #url}.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Sets the {@link #url}.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param url the new value for the JDBC connection url
+     * @param url
+     *            the new value for the JDBC connection url
      */
     public synchronized void setUrl(final String url) {
         this.url = url;
     }
 
     /**
-     * The connection username to be passed to our JDBC driver to
-     * establish a connection.
+     * The connection user name to be passed to our JDBC driver to establish a connection.
      */
-    private String username;
+    private String userName;
 
     /**
-     * Returns the JDBC connection {@link #username} property.
+     * Returns the JDBC connection {@link #userName} property.
      *
-     * @return the {@link #username} passed to the JDBC driver to establish
-     * connections
+     * @return the {@link #userName} passed to the JDBC driver to establish connections
      */
     @Override
     public String getUsername() {
-        return this.username;
+        return this.userName;
     }
 
     /**
-     * <p>Sets the {@link #username}.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Sets the {@link #userName}.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param username the new value for the JDBC connection username
+     * @param userName
+     *            the new value for the JDBC connection user name
      */
-    public void setUsername(final String username) {
-        this.username = username;
+    public void setUsername(final String userName) {
+        this.userName = userName;
     }
 
     /**
-     * The SQL query that will be used to validate connections from this pool
-     * before returning them to the caller.  If specified, this query
-     * <strong>MUST</strong> be an SQL SELECT statement that returns at least
-     * one row. If not specified, {@link Connection#isValid(int)} will be used
-     * to validate connections.
+     * The SQL query that will be used to validate connections from this pool before returning them to the caller. If
+     * specified, this query <strong>MUST</strong> be an SQL SELECT statement that returns at least one row. If not
+     * specified, {@link Connection#isValid(int)} will be used to validate connections.
      */
     private volatile String validationQuery;
 
     /**
-     * Returns the validation query used to validate connections before
-     * returning them.
+     * Returns the validation query used to validate connections before returning them.
      *
      * @return the SQL validation query
      * @see #validationQuery
@@ -1118,14 +1102,17 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Sets the {@link #validationQuery}.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Sets the {@link #validationQuery}.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param validationQuery the new value for the validation query
+     * @param validationQuery
+     *            the new value for the validation query
      */
     public void setValidationQuery(final String validationQuery) {
         if (validationQuery != null && validationQuery.trim().length() > 0) {
@@ -1138,7 +1125,7 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     /**
      * Timeout in seconds before connection validation queries fail.
      */
-    private volatile int validationQueryTimeout = -1;
+    private volatile int validationQueryTimeoutSeconds = -1;
 
     /**
      * Returns the validation query timeout.
@@ -1147,40 +1134,37 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
      */
     @Override
     public int getValidationQueryTimeout() {
-        return validationQueryTimeout;
+        return validationQueryTimeoutSeconds;
     }
 
     /**
-     * Sets the validation query timeout, the amount of time, in seconds, that
-     * connection validation will wait for a response from the database when
-     * executing a validation query.  Use a value less than or equal to 0 for
-     * no timeout.
+     * Sets the validation query timeout, the amount of time, in seconds, that connection validation will wait for a
+     * response from the database when executing a validation query. Use a value less than or equal to 0 for no timeout.
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param timeout new validation query timeout value in seconds
+     * @param validationQueryTimeoutSeconds
+     *            new validation query timeout value in seconds
      */
-    public void setValidationQueryTimeout(final int timeout) {
-        this.validationQueryTimeout = timeout;
+    public void setValidationQueryTimeout(final int validationQueryTimeoutSeconds) {
+        this.validationQueryTimeoutSeconds = validationQueryTimeoutSeconds;
     }
 
     /**
      * These SQL statements run once after a Connection is created.
      * <p>
-     * This property can be used for example to run ALTER SESSION SET
-     * NLS_SORT=XCYECH in an Oracle Database only once after connection
-     * creation.
+     * This property can be used for example to run ALTER SESSION SET NLS_SORT=XCYECH in an Oracle Database only once
+     * after connection creation.
      * </p>
      */
     private volatile List<String> connectionInitSqls;
 
     /**
-     * Returns the list of SQL statements executed when a physical connection
-     * is first created. Returns an empty list if there are no initialization
-     * statements configured.
+     * Returns the list of SQL statements executed when a physical connection is first created. Returns an empty list if
+     * there are no initialization statements configured.
      *
      * @return initialization SQL statements
      */
@@ -1193,8 +1177,7 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Provides the same data as {@link #getConnectionInitSqls()} but in an
-     * array so it is accessible via JMX.
+     * Provides the same data as {@link #getConnectionInitSqls()} but in an array so it is accessible via JMX.
      */
     @Override
     public String[] getConnectionInitSqlsAsArray() {
@@ -1203,22 +1186,21 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Sets the list of SQL statements to be executed when a physical
-     * connection is first created.
+     * Sets the list of SQL statements to be executed when a physical connection is first created.
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param connectionInitSqls Collection of SQL statements to execute
-     * on connection creation
+     * @param connectionInitSqls
+     *            Collection of SQL statements to execute on connection creation
      */
     public void setConnectionInitSqls(final Collection<String> connectionInitSqls) {
         if (connectionInitSqls != null && connectionInitSqls.size() > 0) {
             ArrayList<String> newVal = null;
             for (final String s : connectionInitSqls) {
-            if (s != null && s.trim().length() > 0) {
+                if (s != null && s.trim().length() > 0) {
                     if (newVal == null) {
                         newVal = new ArrayList<>();
                     }
@@ -1231,7 +1213,6 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
         }
     }
 
-
     /**
      * Controls access to the underlying connection.
      */
@@ -1240,8 +1221,7 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     /**
      * Returns the value of the accessToUnderlyingConnectionAllowed property.
      *
-     * @return true if access to the underlying connection is allowed, false
-     * otherwise.
+     * @return true if access to the underlying connection is allowed, false otherwise.
      */
     @Override
     public synchronized boolean isAccessToUnderlyingConnectionAllowed() {
@@ -1249,27 +1229,28 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Sets the value of the accessToUnderlyingConnectionAllowed property.
-     * It controls if the PoolGuard allows access to the underlying connection.
-     * (Default: false)</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Sets the value of the accessToUnderlyingConnectionAllowed property. It controls if the PoolGuard allows access to
+     * the underlying connection. (Default: false)
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param allow Access to the underlying connection is granted when true.
+     * @param allow
+     *            Access to the underlying connection is granted when true.
      */
     public synchronized void setAccessToUnderlyingConnectionAllowed(final boolean allow) {
         this.accessToUnderlyingConnectionAllowed = allow;
     }
 
-
     private long maxConnLifetimeMillis = -1;
 
     /**
-     * Returns the maximum permitted lifetime of a connection in milliseconds. A
-     * value of zero or less indicates an infinite lifetime.
+     * Returns the maximum permitted lifetime of a connection in milliseconds. A value of zero or less indicates an
+     * infinite lifetime.
      */
     @Override
     public long getMaxConnLifetimeMillis() {
@@ -1279,9 +1260,8 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     private boolean logExpiredConnections = true;
 
     /**
-     * When {@link #getMaxConnLifetimeMillis()} is set to limit connection lifetime,
-     * this property determines whether or not log messages are generated when the
-     * pool closes connections due to maximum lifetime exceeded.
+     * When {@link #getMaxConnLifetimeMillis()} is set to limit connection lifetime, this property determines whether or
+     * not log messages are generated when the pool closes connections due to maximum lifetime exceeded.
      *
      * @since 2.1
      */
@@ -1291,25 +1271,31 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Sets the maximum permitted lifetime of a connection in
-     * milliseconds. A value of zero or less indicates an infinite lifetime.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
-     * @param maxConnLifetimeMillis The maximum connection lifetime
+     * Sets the maximum permitted lifetime of a connection in milliseconds. A value of zero or less indicates an
+     * infinite lifetime.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
+     *
+     * @param maxConnLifetimeMillis
+     *            The maximum permitted lifetime of a connection in milliseconds.
      */
     public void setMaxConnLifetimeMillis(final long maxConnLifetimeMillis) {
         this.maxConnLifetimeMillis = maxConnLifetimeMillis;
     }
 
     /**
-     * When {@link #getMaxConnLifetimeMillis()} is set to limit connection lifetime,
-     * this property determines whether or not log messages are generated when the
-     * pool closes connections due to maximum lifetime exceeded.  Set this property
-     * to false to suppress log messages when connections expire.
-     * @param logExpiredConnections <code>true</code> to log expired connections
+     * When {@link #getMaxConnLifetimeMillis()} is set to limit connection lifetime, this property determines whether or
+     * not log messages are generated when the pool closes connections due to maximum lifetime exceeded. Set this
+     * property to false to suppress log messages when connections expire.
+     *
+     * @param logExpiredConnections
+     *            Whether or not log messages are generated when the pool closes connections due to maximum lifetime
+     *            exceeded.
      */
     public void setLogExpiredConnections(final boolean logExpiredConnections) {
         this.logExpiredConnections = logExpiredConnections;
@@ -1318,47 +1304,48 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     private String jmxName;
 
     /**
-     * @return the JMX name that has been requested for this DataSource. If the
-     * requested name is not valid, an alternative may be chosen.
+     * Returns the JMX name that has been requested for this DataSource. If the requested name is not valid, an
+     * alternative may be chosen.
+     *
+     * @return The JMX name that has been requested for this DataSource.
      */
     public String getJmxName() {
         return jmxName;
     }
 
     /**
-     * Sets the JMX name that has been requested for this DataSource. If the
-     * requested name is not valid, an alternative may be chosen. This
-     * DataSource will attempt to register itself using this name. If another
-     * component registers this DataSource with JMX and this name is valid this
-     * name will be used in preference to any specified by the other component.
-     * @param jmxName The JMX name
+     * Sets the JMX name that has been requested for this DataSource. If the requested name is not valid, an alternative
+     * may be chosen. This DataSource will attempt to register itself using this name. If another component registers
+     * this DataSource with JMX and this name is valid this name will be used in preference to any specified by the
+     * other component.
+     *
+     * @param jmxName
+     *            The JMX name that has been requested for this DataSource
      */
     public void setJmxName(final String jmxName) {
         this.jmxName = jmxName;
     }
 
-
     private boolean enableAutoCommitOnReturn = true;
 
     /**
-     * Returns the value of the flag that controls whether or not connections
-     * being returned to the pool will be checked and configured with
-     * {@link Connection#setAutoCommit(boolean) Connection.setAutoCommit(true)}
-     * if the auto commit setting is {@code false} when the connection
-     * is returned. It is <code>true</code> by default.
-     * @return <code>true</code> to commit automatically
+     * Returns the value of the flag that controls whether or not connections being returned to the pool will be checked
+     * and configured with {@link Connection#setAutoCommit(boolean) Connection.setAutoCommit(true)} if the auto commit
+     * setting is {@code false} when the connection is returned. It is <code>true</code> by default.
+     *
+     * @return Whether or not connections being returned to the pool will be checked and configured with auto-commit.
      */
     public boolean getEnableAutoCommitOnReturn() {
         return enableAutoCommitOnReturn;
     }
 
     /**
-     * Sets the value of the flag that controls whether or not connections
-     * being returned to the pool will be checked and configured with
-     * {@link Connection#setAutoCommit(boolean) Connection.setAutoCommit(true)}
-     * if the auto commit setting is {@code false} when the connection
-     * is returned. It is <code>true</code> by default.
-     * @param enableAutoCommitOnReturn The new value
+     * Sets the value of the flag that controls whether or not connections being returned to the pool will be checked
+     * and configured with {@link Connection#setAutoCommit(boolean) Connection.setAutoCommit(true)} if the auto commit
+     * setting is {@code false} when the connection is returned. It is <code>true</code> by default.
+     *
+     * @param enableAutoCommitOnReturn
+     *            Whether or not connections being returned to the pool will be checked and configured with auto-commit.
      */
     public void setEnableAutoCommitOnReturn(final boolean enableAutoCommitOnReturn) {
         this.enableAutoCommitOnReturn = enableAutoCommitOnReturn;
@@ -1367,20 +1354,21 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     private boolean rollbackOnReturn = true;
 
     /**
-     * Gets the current value of the flag that controls if a connection will be
-     * rolled back when it is returned to the pool if auto commit is not enabled
-     * and the connection is not read only.
-     * @return <code>true</code> to rollback non committed connections
+     * Gets the current value of the flag that controls whether a connection will be rolled back when it is returned to
+     * the pool if auto commit is not enabled and the connection is not read only.
+     *
+     * @return whether a connection will be rolled back when it is returned to the pool.
      */
     public boolean getRollbackOnReturn() {
         return rollbackOnReturn;
     }
 
     /**
-     * Sets the flag that controls if a connection will be rolled back when it
-     * is returned to the pool if auto commit is not enabled and the connection
-     * is not read only.
-     * @param rollbackOnReturn The new value
+     * Sets the flag that controls if a connection will be rolled back when it is returned to the pool if auto commit is
+     * not enabled and the connection is not read only.
+     *
+     * @param rollbackOnReturn
+     *            whether a connection will be rolled back when it is returned to the pool.
      */
     public void setRollbackOnReturn(final boolean rollbackOnReturn) {
         this.rollbackOnReturn = rollbackOnReturn;
@@ -1390,6 +1378,7 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
 
     /**
      * Returns the set of SQL_STATE codes considered to signal fatal conditions.
+     *
      * @return fatal disconnection state codes
      * @see #setDisconnectionSqlCodes(Collection)
      * @since 2.1
@@ -1403,9 +1392,8 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Provides the same data as {@link #getDisconnectionSqlCodes} but in an
-     * array so it is accessible via JMX.
-     * @return fatal disconnection state codes
+     * Provides the same data as {@link #getDisconnectionSqlCodes} but in an array so it is accessible via JMX.
+     *
      * @since 2.1
      */
     @Override
@@ -1417,30 +1405,30 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     /**
      * Sets the SQL_STATE codes considered to signal fatal conditions.
      * <p>
-     * Overrides the defaults in {@link Utils#DISCONNECTION_SQL_CODES}
-     * (plus anything starting with {@link Utils#DISCONNECTION_SQL_CODE_PREFIX}).
-     * If this property is non-null and {@link #getFastFailValidation()} is
-     * {@code true}, whenever connections created by this datasource generate exceptions
-     * with SQL_STATE codes in this list, they will be marked as "fatally disconnected"
-     * and subsequent validations will fail fast (no attempt at isValid or validation
-     * query).</p>
+     * Overrides the defaults in {@link Utils#DISCONNECTION_SQL_CODES} (plus anything starting with
+     * {@link Utils#DISCONNECTION_SQL_CODE_PREFIX}). If this property is non-null and {@link #getFastFailValidation()}
+     * is {@code true}, whenever connections created by this datasource generate exceptions with SQL_STATE codes in this
+     * list, they will be marked as "fatally disconnected" and subsequent validations will fail fast (no attempt at
+     * isValid or validation query).
+     * </p>
      * <p>
-     * If {@link #getFastFailValidation()} is {@code false} setting this property has no
-     * effect.</p>
+     * If {@link #getFastFailValidation()} is {@code false} setting this property has no effect.
+     * </p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: {@code getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter}.</p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: {@code getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter}.
+     * </p>
      *
-     * @param disconnectionSqlCodes SQL_STATE codes considered to signal fatal conditions
+     * @param disconnectionSqlCodes
+     *            SQL_STATE codes considered to signal fatal conditions
      * @since 2.1
      */
     public void setDisconnectionSqlCodes(final Collection<String> disconnectionSqlCodes) {
         if (disconnectionSqlCodes != null && disconnectionSqlCodes.size() > 0) {
             HashSet<String> newVal = null;
             for (final String s : disconnectionSqlCodes) {
-            if (s != null && s.trim().length() > 0) {
+                if (s != null && s.trim().length() > 0) {
                     if (newVal == null) {
                         newVal = new HashSet<>();
                     }
@@ -1456,9 +1444,8 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     private boolean fastFailValidation;
 
     /**
-     * True means that validation will fail immediately for connections that
-     * have previously thrown SQLExceptions with SQL_STATE indicating fatal
-     * disconnection errors.
+     * True means that validation will fail immediately for connections that have previously thrown SQLExceptions with
+     * SQL_STATE indicating fatal disconnection errors.
      *
      * @return true if connections created by this datasource will fast fail validation.
      * @see #setDisconnectionSqlCodes(Collection)
@@ -1471,16 +1458,14 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
 
     /**
      * @see #getFastFailValidation()
-     * @param fastFailValidation true means connections created by this factory will
-     * fast fail validation
+     * @param fastFailValidation
+     *            true means connections created by this factory will fast fail validation
      * @since 2.1
      */
     public void setFastFailValidation(final boolean fastFailValidation) {
         this.fastFailValidation = fastFailValidation;
     }
 
-    // ----------------------------------------------------- Instance Variables
-
     /**
      * The object pool that internally manages our connections.
      */
@@ -1491,10 +1476,9 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * The connection properties that will be sent to our JDBC driver when
-     * establishing new connections.  <strong>NOTE</strong> - The "user" and
-     * "password" properties will be passed explicitly, so they do not need
-     * to be included here.
+     * The connection properties that will be sent to our JDBC driver when establishing new connections.
+     * <strong>NOTE</strong> - The "user" and "password" properties will be passed explicitly, so they do not need to be
+     * included here.
      */
     private Properties connectionProperties = new Properties();
 
@@ -1504,26 +1488,24 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * The data source we will use to manage connections.  This object should
-     * be acquired <strong>ONLY</strong> by calls to the
-     * <code>createDataSource()</code> method.
+     * The data source we will use to manage connections. This object should be acquired <strong>ONLY</strong> by calls
+     * to the <code>createDataSource()</code> method.
      */
     private volatile DataSource dataSource;
 
     /**
      * The PrintWriter to which log messages should be directed.
      */
-    private volatile PrintWriter logWriter = new PrintWriter(new OutputStreamWriter(
-            System.out, StandardCharsets.UTF_8));
-
+    private volatile PrintWriter logWriter = new PrintWriter(
+            new OutputStreamWriter(System.out, StandardCharsets.UTF_8));
 
     // ----------------------------------------------------- DataSource Methods
 
-
     /**
-     * Create (if necessary) and return a connection to the database.
+     * Creates (if necessary) and return a connection to the database.
      *
-     * @throws SQLException if a database access error occurs
+     * @throws SQLException
+     *             if a database access error occurs
      * @return a database connection
      */
     @Override
@@ -1543,54 +1525,58 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
         return createDataSource().getConnection();
     }
 
-
     /**
-     * <strong>BasicDataSource does NOT support this method. </strong>
+     * <strong>BasicDataSource does NOT support this method.</strong>
      *
-     * @param user Database user on whose behalf the Connection
-     *   is being made
-     * @param pass The database user's password
+     * @param user
+     *            Database user on whose behalf the Connection is being made
+     * @param pass
+     *            The database user's password
      *
-     * @throws UnsupportedOperationException This is not supported
-     * @throws SQLException if a database access error occurs
+     * @throws UnsupportedOperationException
+     *             always thrown.
+     * @throws SQLException
+     *             if a database access error occurs
      * @return nothing - always throws UnsupportedOperationException
      */
     @Override
     public Connection getConnection(final String user, final String pass) throws SQLException {
-        // This method isn't supported by the PoolingDataSource returned by
-        // the createDataSource
+        // This method isn't supported by the PoolingDataSource returned by the createDataSource
         throw new UnsupportedOperationException("Not supported by BasicDataSource");
     }
 
-
     /**
-     * <strong>BasicDataSource does NOT support this method. </strong>
+     * <strong>BasicDataSource does NOT support this method.</strong>
      *
-     * <p>Returns the login timeout (in seconds) for connecting to the database.
+     * <p>
+     * Returns the login timeout (in seconds) for connecting to the database.
+     * </p>
+     * <p>
+     * Calls {@link #createDataSource()}, so has the side effect of initializing the connection pool.
      * </p>
-     * <p>Calls {@link #createDataSource()}, so has the side effect
-     * of initializing the connection pool.</p>
      *
-     * @throws SQLException if a database access error occurs
-     * @throws UnsupportedOperationException If the DataSource implementation
-     *   does not support the login timeout feature.
+     * @throws SQLException
+     *             if a database access error occurs
+     * @throws UnsupportedOperationException
+     *             If the DataSource implementation does not support the login timeout feature.
      * @return login timeout in seconds
      */
     @Override
     public int getLoginTimeout() throws SQLException {
-        // This method isn't supported by the PoolingDataSource returned by
-        // the createDataSource
+        // This method isn't supported by the PoolingDataSource returned by the createDataSource
         throw new UnsupportedOperationException("Not supported by BasicDataSource");
     }
 
-
     /**
-     * <p>Returns the log writer being used by this data source.</p>
      * <p>
-     * Calls {@link #createDataSource()}, so has the side effect
-     * of initializing the connection pool.</p>
+     * Returns the log writer being used by this data source.
+     * </p>
+     * <p>
+     * Calls {@link #createDataSource()}, so has the side effect of initializing the connection pool.
+     * </p>
      *
-     * @throws SQLException if a database access error occurs
+     * @throws SQLException
+     *             if a database access error occurs
      * @return log writer in use
      */
     @Override
@@ -1598,37 +1584,41 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
         return createDataSource().getLogWriter();
     }
 
-
     /**
      * <strong>BasicDataSource does NOT support this method. </strong>
      *
-     * <p>Set the login timeout (in seconds) for connecting to the
-     * database.</p>
      * <p>
-     * Calls {@link #createDataSource()}, so has the side effect
-     * of initializing the connection pool.</p>
+     * Set the login timeout (in seconds) for connecting to the database.
+     * </p>
+     * <p>
+     * Calls {@link #createDataSource()}, so has the side effect of initializing the connection pool.
+     * </p>
      *
-     * @param loginTimeout The new login timeout, or zero for no timeout
-     * @throws UnsupportedOperationException If the DataSource implementation
-     *   does not support the login timeout feature.
-     * @throws SQLException if a database access error occurs
+     * @param loginTimeout
+     *            The new login timeout, or zero for no timeout
+     * @throws UnsupportedOperationException
+     *             If the DataSource implementation does not support the login timeout feature.
+     * @throws SQLException
+     *             if a database access error occurs
      */
     @Override
     public void setLoginTimeout(final int loginTimeout) throws SQLException {
-        // This method isn't supported by the PoolingDataSource returned by
-        // the createDataSource
+        // This method isn't supported by the PoolingDataSource returned by the createDataSource
         throw new UnsupportedOperationException("Not supported by BasicDataSource");
     }
 
-
     /**
-     * <p>Sets the log writer being used by this data source.</p>
      * <p>
-     * Calls {@link #createDataSource()}, so has the side effect
-     * of initializing the connection pool.</p>
+     * Sets the log writer being used by this data source.
+     * </p>
+     * <p>
+     * Calls {@link #createDataSource()}, so has the side effect of initializing the connection pool.
+     * </p>
      *
-     * @param logWriter The new log writer
-     * @throws SQLException if a database access error occurs
+     * @param logWriter
+     *            The new log writer
+     * @throws SQLException
+     *             if a database access error occurs
      */
     @Override
     public void setLogWriter(final PrintWriter logWriter) throws SQLException {
@@ -1639,21 +1629,25 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     private AbandonedConfig abandonedConfig;
 
     /**
-     * <p>Flag to remove abandoned connections if they exceed the
-     * removeAbandonedTimeout when borrowObject is invoked.</p>
-     *
-     * <p>The default value is false.</p>
-     *
-     * <p>If set to true a connection is considered abandoned and eligible
-     * for removal if it has not been used for more than
-     * {@link #getRemoveAbandonedTimeout() removeAbandonedTimeout} seconds.</p>
-     *
-     * <p>Abandoned connections are identified and removed when
-     * {@link #getConnection()} is invoked and all of the following conditions hold:
+     * <p>
+     * Flag to remove abandoned connections if they exceed the removeAbandonedTimeout when borrowObject is invoked.
      * </p>
-     * <ul><li>{@link #getRemoveAbandonedOnBorrow()} </li>
-     *     <li>{@link #getNumActive()} &gt; {@link #getMaxTotal()} - 3 </li>
-     *     <li>{@link #getNumIdle()} &lt; 2 </li></ul>
+     * <p>
+     * The default value is false.
+     * </p>
+     * <p>
+     * If set to true a connection is considered abandoned and eligible for removal if it has not been used for more
+     * than {@link #getRemoveAbandonedTimeout() removeAbandonedTimeout} seconds.
+     * </p>
+     * <p>
+     * Abandoned connections are identified and removed when {@link #getConnection()} is invoked and all of the
+     * following conditions hold:
+     * </p>
+     * <ul>
+     * <li>{@link #getRemoveAbandonedOnBorrow()}</li>
+     * <li>{@link #getNumActive()} &gt; {@link #getMaxTotal()} - 3</li>
+     * <li>{@link #getNumIdle()} &lt; 2</li>
+     * </ul>
      *
      * @see #getRemoveAbandonedTimeout()
      */
@@ -1666,17 +1660,15 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * @param removeAbandonedOnMaintenance true means abandoned connections may
-     *                                     be removed on pool maintenance.
+     * @param removeAbandonedOnMaintenance
+     *            true means abandoned connections may be removed on pool maintenance.
      * @see #getRemoveAbandonedOnMaintenance()
      */
-    public void setRemoveAbandonedOnMaintenance(
-            final boolean removeAbandonedOnMaintenance) {
+    public void setRemoveAbandonedOnMaintenance(final boolean removeAbandonedOnMaintenance) {
         if (abandonedConfig == null) {
             abandonedConfig = new AbandonedConfig();
         }
-        abandonedConfig.setRemoveAbandonedOnMaintenance(
-                removeAbandonedOnMaintenance);
+        abandonedConfig.setRemoveAbandonedOnMaintenance(removeAbandonedOnMaintenance);
         final GenericObjectPool<?> gop = this.connectionPool;
         if (gop != null) {
             gop.setAbandonedConfig(abandonedConfig);
@@ -1684,14 +1676,18 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Flag to remove abandoned connections if they exceed the
-     * removeAbandonedTimeout during pool maintenance.</p>
+     * <p>
+     * Flag to remove abandoned connections if they exceed the removeAbandonedTimeout during pool maintenance.
+     * </p>
      *
-     * <p>The default value is false.</p>
+     * <p>
+     * The default value is false.
+     * </p>
      *
-     * <p>If set to true a connection is considered abandoned and eligible
-     * for removal if it has not been used for more than
-     * {@link #getRemoveAbandonedTimeout() removeAbandonedTimeout} seconds.</p>
+     * <p>
+     * If set to true a connection is considered abandoned and eligible for removal if it has not been used for more
+     * than {@link #getRemoveAbandonedTimeout() removeAbandonedTimeout} seconds.
+     * </p>
      *
      * @see #getRemoveAbandonedTimeout()
      */
@@ -1704,8 +1700,8 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * @param removeAbandonedOnBorrow true means abandoned connections may be
-     *                                removed when connections are borrowed from the pool.
+     * @param removeAbandonedOnBorrow
+     *            true means abandoned connections may be removed when connections are borrowed from the pool.
      * @see #getRemoveAbandonedOnBorrow()
      */
     public void setRemoveAbandonedOnBorrow(final boolean removeAbandonedOnBorrow) {
@@ -1720,21 +1716,24 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Timeout in seconds before an abandoned connection can be removed.</p>
-     *
-     * <p>Creating a Statement, PreparedStatement or CallableStatement or using
-     * one of these to execute a query (using one of the execute methods)
-     * resets the lastUsed property of the parent connection.</p>
-     *
-     * <p>Abandoned connection cleanup happens when:</p>
+     * <p>
+     * Timeout in seconds before an abandoned connection can be removed.
+     * </p>
+     * <p>
+     * Creating a Statement, PreparedStatement or CallableStatement or using one of these to execute a query (using one
+     * of the execute methods) resets the lastUsed property of the parent connection.
+     * </p>
+     * <p>
+     * Abandoned connection cleanup happens when:
+     * </p>
      * <ul>
-     * <li>{@link #getRemoveAbandonedOnBorrow()} or
-     *     {@link #getRemoveAbandonedOnMaintenance()} = true</li>
+     * <li>{@link #getRemoveAbandonedOnBorrow()} or {@link #getRemoveAbandonedOnMaintenance()} = true</li>
      * <li>{@link #getNumIdle() numIdle} &lt; 2</li>
      * <li>{@link #getNumActive() numActive} &gt; {@link #getMaxTotal() maxTotal} - 3</li>
      * </ul>
-     *
-     * <p>The default value is 300 seconds.</p>
+     * <p>
+     * The default value is 300 seconds.
+     * </p>
      */
     @Override
     public int getRemoveAbandonedTimeout() {
@@ -1745,14 +1744,17 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Sets the timeout in seconds before an abandoned connection can be
-     * removed.</p>
+     * <p>
+     * Sets the timeout in seconds before an abandoned connection can be removed.
+     * </p>
      *
-     * <p>Setting this property has no effect if
-     * {@link #getRemoveAbandonedOnBorrow()} and
-     * {@link #getRemoveAbandonedOnMaintenance()} are false.</p>
+     * <p>
+     * Setting this property has no effect if {@link #getRemoveAbandonedOnBorrow()} and
+     * {@link #getRemoveAbandonedOnMaintenance()} are false.
+     * </p>
      *
-     * @param removeAbandonedTimeout new abandoned timeout in seconds
+     * @param removeAbandonedTimeout
+     *            new abandoned timeout in seconds
      * @see #getRemoveAbandonedTimeout()
      * @see #getRemoveAbandonedOnBorrow()
      * @see #getRemoveAbandonedOnMaintenance()
@@ -1769,14 +1771,16 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * <p>Flag to log stack traces for application code which abandoned
-     * a Statement or Connection.
+     * <p>
+     * Flag to log stack traces for application code which abandoned a Statement or Connection.
      * </p>
-     * <p>Defaults to false.
+     * <p>
+     * Defaults to false.
+     * </p>
+     * <p>
+     * Logging of abandoned Statements and Connections adds overhead for every Connection open or new Statement because
+     * a stack trace has to be generated.
      * </p>
-     * <p>Logging of abandoned Statements and Connections adds overhead
-     * for every Connection open or new Statement because a stack
-     * trace has to be generated. </p>
      */
     @Override
     public boolean getLogAbandoned() {
@@ -1787,7 +1791,8 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * @param logAbandoned new logAbandoned property value
+     * @param logAbandoned
+     *            new logAbandoned property value
      */
     public void setLogAbandoned(final boolean logAbandoned) {
         if (abandonedConfig == null) {
@@ -1801,9 +1806,9 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Gets the log writer to be used by this configuration to log
-     * information on abandoned objects.
-     * @return the log writer
+     * Gets the print writer used by this configuration to log information on abandoned objects.
+     *
+     * @return The print writer used by this configuration to log information on abandoned objects.
      */
     public PrintWriter getAbandonedLogWriter() {
         if (abandonedConfig != null) {
@@ -1813,10 +1818,10 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Sets the log writer to be used by this configuration to log
-     * information on abandoned objects.
+     * Sets the print writer to be used by this configuration to log information on abandoned objects.
      *
-     * @param logWriter The new log writer
+     * @param logWriter
+     *            The new log writer
      */
     public void setAbandonedLogWriter(final PrintWriter logWriter) {
         if (abandonedConfig == null) {
@@ -1831,9 +1836,8 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
 
     /**
      * If the connection pool implements {@link org.apache.tomcat.dbcp.pool2.UsageTracking UsageTracking}, should the
-     * connection pool record a stack trace every time a method is called on a
-     * pooled connection and retain the most recent stack trace to aid debugging
-     * of abandoned connections?
+     * connection pool record a stack trace every time a method is called on a pooled connection and retain the most
+     * recent stack trace to aid debugging of abandoned connections?
      *
      * @return <code>true</code> if usage tracking is enabled
      */
@@ -1846,14 +1850,13 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * If the connection pool implements {@link org.apache.tomcat.dbcp.pool2.UsageTracking UsageTracking}, configure
-     * whether the connection pool should record a stack trace every time a
-     * method is called on a pooled connection and retain the most recent stack
-     * trace to aid debugging of abandoned connections.
+     * If the connection pool implements {@link org.apache.tomcat.dbcp.pool2.UsageTracking UsageTracking}, configure whether
+     * the connection pool should record a stack trace every time a method is called on a pooled connection and retain
+     * the most recent stack trace to aid debugging of abandoned connections.
      *
-     * @param   usageTracking    A value of <code>true</code> will enable
-     *                              the recording of a stack trace on every use
-     *                              of a pooled connection
+     * @param usageTracking
+     *            A value of <code>true</code> will enable the recording of a stack trace on every use of a pooled
+     *            connection
      */
     public void setAbandonedUsageTracking(final boolean usageTracking) {
         if (abandonedConfig == null) {
@@ -1866,26 +1869,25 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
         }
     }
 
-    // --------------------------------------------------------- Public Methods
-
     /**
-     * Add a custom connection property to the set that will be passed to our
-     * JDBC driver. This <strong>MUST</strong> be called before the first
-     * connection is retrieved (along with all the other configuration
-     * property setters). Calls to this method after the connection pool
-     * has been initialized have no effect.
+     * Adds a custom connection property to the set that will be passed to our JDBC driver. This <strong>MUST</strong>
+     * be called before the first connection is retrieved (along with all the other configuration property setters).
+     * Calls to this method after the connection pool has been initialized have no effect.
      *
-     * @param name Name of the custom connection property
-     * @param value Value of the custom connection property
+     * @param name
+     *            Name of the custom connection property
+     * @param value
+     *            Value of the custom connection property
      */
     public void addConnectionProperty(final String name, final String value) {
         connectionProperties.put(name, value);
     }
 
     /**
-     * Remove a custom connection property.
+     * Removes a custom connection property.
      *
-     * @param name Name of the custom connection property to remove
+     * @param name
+     *            Name of the custom connection property to remove
      * @see #addConnectionProperty(String, String)
      */
     public void removeConnectionProperty(final String name) {
@@ -1894,20 +1896,18 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
 
     /**
      * Sets the connection properties passed to driver.connect(...).
-     *
+     * <p>
      * Format of the string must be [propertyName=property;]*
+     * </p>
+     * <p>
+     * NOTE - The "user" and "password" properties will be added explicitly, so they do not need to be included here.
+     * </p>
      *
-     * NOTE - The "user" and "password" properties will be added
-     * explicitly, so they do not need to be included here.
-     *
-     * @param connectionProperties the connection properties used to
-     * create new connections
+     * @param connectionProperties
+     *            the connection properties used to create new connections
      */
     public void setConnectionProperties(final String connectionProperties) {
-        if (connectionProperties == null) {
-            throw new NullPointerException("connectionProperties is null");
-        }
-
+        Objects.requireNonNull(connectionProperties, "connectionProperties is null");
         final String[] entries = connectionProperties.split(";");
         final Properties properties = new Properties();
         for (final String entry : entries) {
@@ -1929,32 +1929,32 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     private boolean closed;
 
     /**
-     * <p>Closes and releases all idle connections that are currently stored in the connection pool
-     * associated with this data source.</p>
-     *
-     * <p>Connections that are checked out to clients when this method is invoked are not affected.
-     * When client applications subsequently invoke {@link Connection#close()} to return
-     * these connections to the pool, the underlying JDBC connections are closed.</p>
-     *
-     * <p>Attempts to acquire connections using {@link #getConnection()} after this method has been
-     * invoked result in SQLExceptions.</p>
-     *
-     * <p>This method is idempotent - i.e., closing an already closed BasicDataSource has no effect
-     * and does not generate exceptions.</p>
+     * <p>
+     * Closes and releases all idle connections that are currently stored in the connection pool associated with this
+     * data source.
+     * </p>
+     * <p>
+     * Connections that are checked out to clients when this method is invoked are not affected. When client
+     * applications subsequently invoke {@link Connection#close()} to return these connections to the pool, the
+     * underlying JDBC connections are closed.
+     * </p>
+     * <p>
+     * Attempts to acquire connections using {@link #getConnection()} after this method has been invoked result in
+     * SQLExceptions.
+     * </p>
+     * <p>
+     * This method is idempotent - i.e., closing an already closed BasicDataSource has no effect and does not generate
+     * exceptions.
+     * </p>
      *
-     * @throws SQLException if an error occurs closing idle connections
+     * @throws SQLException
+     *             if an error occurs closing idle connections
      */
     @Override
     public synchronized void close() throws SQLException {
-        if (registeredJmxName != null) {
-            final MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
-            try {
-                mbs.unregisterMBean(registeredJmxName);
-            } catch (final JMException e) {
-                log.warn("Failed to unregister the JMX name: " + registeredJmxName, e);
-            } finally {
-                registeredJmxName = null;
-            }
+        if (registeredJmxObjectName != null) {
+            registeredJmxObjectName.unregisterMBean();
+            registeredJmxObjectName = null;
         }
         closed = true;
         final GenericObjectPool<?> oldpool = connectionPool;
@@ -1964,15 +1964,16 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
             if (oldpool != null) {
                 oldpool.close();
             }
-        } catch(final RuntimeException e) {
+        } catch (final RuntimeException e) {
             throw e;
-        } catch(final Exception e) {
+        } catch (final Exception e) {
             throw new SQLException(Utils.getMessage("pool.close.fail"), e);
         }
     }
 
     /**
      * If true, this data source is closed and no more connections can be retrieved from this datasource.
+     *
      * @return true, if the data source is closed; false otherwise
      */
     @Override
@@ -1996,9 +1997,12 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Manually invalidates a connection, effectively requesting the pool to try
-     * to close it, remove it from the pool and reclaim pool capacity.
-     * @param connection The connection to close
+     * Manually invalidates a connection, effectively requesting the pool to try to close it, remove it from the pool
+     * and reclaim pool capacity.
+     *
+     * @param connection
+     *            The Connection to invalidate.
+     *
      * @throws IllegalStateException
      *             if invalidating the connection failed.
      * @since 2.1
@@ -2031,15 +2035,15 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
 
     // ------------------------------------------------------ Protected Methods
 
-
     /**
-     * <p>Create (if necessary) and return the internal data source we are
-     * using to manage our connections.</p>
-     * @return the data source
-     * @throws SQLException if the object pool cannot be created.
+     * <p>
+     * Creates (if necessary) and return the internal data source we are using to manage our connections.
+     * </p>
+     *
+     * @throws SQLException
+     *             if the object pool cannot be created.
      */
-    protected DataSource createDataSource()
-        throws SQLException {
+    protected DataSource createDataSource() throws SQLException {
         if (closed) {
             throw new SQLException("Data source is closed");
         }
@@ -2064,12 +2068,9 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
             boolean success = false;
             PoolableConnectionFactory poolableConnectionFactory;
             try {
-                poolableConnectionFactory = createPoolableConnectionFactory(
-                        driverConnectionFactory);
-                poolableConnectionFactory.setPoolStatements(
-                        poolPreparedStatements);
-                poolableConnectionFactory.setMaxOpenPreparedStatements(
-                        maxOpenPreparedStatements);
+                poolableConnectionFactory = createPoolableConnectionFactory(driverConnectionFactory);
+                poolableConnectionFactory.setPoolStatements(poolPreparedStatements);
+                poolableConnectionFactory.setMaxOpenPreparedStatements(maxOpenPreparedStatements);
                 success = true;
             } catch (final SQLException se) {
                 throw se;
@@ -2105,7 +2106,7 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
 
             // If initialSize > 0, preload the pool
             try {
-                for (int i = 0 ; i < initialSize ; i++) {
+                for (int i = 0; i < initialSize; i++) {
                     connectionPool.addObject();
                 }
             } catch (final Exception e) {
@@ -2122,24 +2123,17 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Creates a JDBC connection factory for this datasource.  The JDBC driver
-     * is loaded using the following algorithm:
+     * Creates a JDBC connection factory for this datasource. The JDBC driver is loaded using the following algorithm:
      * <ol>
-     * <li>If a Driver instance has been specified via
-     * {@link #setDriver(Driver)} use it</li>
-     * <li>If no Driver instance was specified and {@link #driverClassName} is
-     * specified that class is loaded using the {@link ClassLoader} of this
-     * class or, if {@link #driverClassLoader} is set, {@link #driverClassName}
-     * is loaded with the specified {@link ClassLoader}.</li>
-     * <li>If {@link #driverClassName} is specified and the previous attempt
-     * fails, the class is loaded using the context class loader of the current
-     * thread.</li>
-     * <li>If a driver still isn't loaded one is loaded via the
-     * {@link DriverManager} using the specified {@link #url}.
+     * <li>If a Driver instance has been specified via {@link #setDriver(Driver)} use it</li>
+     * <li>If no Driver instance was specified and {@link #driverClassName} is specified that class is loaded using the
+     * {@link ClassLoader} of this class or, if {@link #driverClassLoader} is set, {@link #driverClassName} is loaded
+     * with the specified {@link ClassLoader}.</li>
+     * <li>If {@link #driverClassName} is specified and the previous attempt fails, the class is loaded using the
+     * context class loader of the current thread.</li>
+     * <li>If a driver still isn't loaded one is loaded via the {@link DriverManager} using the specified {@link #url}.
      * </ol>
      * This method exists so subclasses can replace the implementation class.
-     * @return the connection factory
-     * @throws SQLException Error creating connection factory
      */
     protected ConnectionFactory createConnectionFactory() throws SQLException {
         // Load the JDBC driver class
@@ -2153,17 +2147,13 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
                         if (driverClassLoader == null) {
                             driverFromCCL = Class.forName(driverClassName);
                         } else {
-                            driverFromCCL = Class.forName(
-                                    driverClassName, true, driverClassLoader);
+                            driverFromCCL = Class.forName(driverClassName, true, driverClassLoader);
                         }
                     } catch (final ClassNotFoundException cnfe) {
-                        driverFromCCL = Thread.currentThread(
-                                ).getContextClassLoader().loadClass(
-                                        driverClassName);
+                        driverFromCCL = Thread.currentThread().getContextClassLoader().loadClass(driverClassName);
                     }
                 } catch (final Exception t) {
-                    final String message = "Cannot load JDBC driver class '" +
-                        driverClassName + "'";
+                    final String message = "Cannot load JDBC driver class '" + driverClassName + "'";
                     logWriter.println(message);
                     t.printStackTrace(logWriter);
                     throw new SQLException(message, t);
@@ -2183,9 +2173,8 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
                     }
                 }
             } catch (final Exception t) {
-                final String message = "Cannot create JDBC driver of class '" +
-                    (driverClassName != null ? driverClassName : "") +
-                    "' for connect URL '" + url + "'";
+                final String message = "Cannot create JDBC driver of class '"
+                        + (driverClassName != null ? driverClassName : "") + "' for connect URL '" + url + "'";
                 logWriter.println(message);
                 t.printStackTrace(logWriter);
                 throw new SQLException(message, t);
@@ -2193,7 +2182,7 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
         }
 
         // Set up the driver connection factory we will use
-        final String user = username;
+        final String user = userName;
         if (user != null) {
             connectionProperties.put("user", user);
         } else {
@@ -2207,27 +2196,26 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
             log("DBCP DataSource configured without a 'password'");
         }
 
-        final ConnectionFactory driverConnectionFactory =
-                new DriverConnectionFactory(driverToUse, url, connectionProperties);
+        final ConnectionFactory driverConnectionFactory = new DriverConnectionFactory(driverToUse, url,
+                connectionProperties);
         return driverConnectionFactory;
     }
 
     /**
-     * Creates a connection pool for this datasource.  This method only exists
-     * so subclasses can replace the implementation class.
-     *
-     * This implementation configures all pool properties other than
-     * timeBetweenEvictionRunsMillis.  Setting that property is deferred to
-     * {@link #startPoolMaintenance()}, since setting timeBetweenEvictionRunsMillis
-     * to a positive value causes {@link GenericObjectPool}'s eviction timer
-     * to be started.
-     * @param factory The connection factory
+     * Creates a connection pool for this datasource. This method only exists so subclasses can replace the
+     * implementation class.
+     * <p>
+     * This implementation configures all pool properties other than timeBetweenEvictionRunsMillis. Setting that
+     * property is deferred to {@link #startPoolMaintenance()}, since setting timeBetweenEvictionRunsMillis to a
+     * positive value causes {@link GenericObjectPool}'s eviction timer to be started.
+     * </p>
      */
     protected void createConnectionPool(final PoolableConnectionFactory factory) {
         // Create an object pool to contain our active connections
-        final GenericObjectPoolConfig<PoolableConnection> config = new GenericObjectPoolConfig<>();
+        final GenericObjectPoolConfig config = new GenericObjectPoolConfig();
         updateJmxName(config);
-        config.setJmxEnabled(registeredJmxName != null);  // Disable JMX on the underlying pool if the DS is not registered.
+        // Disable JMX on the underlying pool if the DS is not registered:
+        config.setJmxEnabled(registeredJmxObjectName != null);
         final GenericObjectPool<PoolableConnection> gop = createObjectPool(factory, config, abandonedConfig);
         gop.setMaxTotal(maxTotal);
         gop.setMaxIdle(maxIdle);
@@ -2250,21 +2238,21 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     /**
      * Creates an object pool used to provide pooling support for {@link Connection JDBC connections}.
      *
-     * @param factory         the object factory
-     * @param poolConfig      the object pool configuration
-     * @param abandonedConfig the abandoned objects configuration
+     * @param factory
+     *            the object factory
+     * @param poolConfig
+     *            the object pool configuration
+     * @param abandonedConfig
+     *            the abandoned objects configuration
      * @return a non-null instance
      */
-    protected  GenericObjectPool<PoolableConnection> createObjectPool(
-            final PoolableConnectionFactory factory, final GenericObjectPoolConfig<PoolableConnection> poolConfig,
-            final AbandonedConfig abandonedConfig) {
+    protected GenericObjectPool<PoolableConnection> createObjectPool(final PoolableConnectionFactory factory,
+            final GenericObjectPoolConfig poolConfig, final AbandonedConfig abandonedConfig) {
         GenericObjectPool<PoolableConnection> gop;
-        if (abandonedConfig != null &&
-                (abandonedConfig.getRemoveAbandonedOnBorrow() ||
-                        abandonedConfig.getRemoveAbandonedOnMaintenance())) {
+        if (abandonedConfig != null && (abandonedConfig.getRemoveAbandonedOnBorrow()
+                || abandonedConfig.getRemoveAbandonedOnMaintenance())) {
             gop = new GenericObjectPool<>(factory, poolConfig, abandonedConfig);
-        }
-        else {
+        } else {
             gop = new GenericObjectPool<>(factory, poolConfig);
         }
         return gop;
@@ -2280,7 +2268,7 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
             if (oldpool != null) {
                 oldpool.close();
             }
-        } catch(final Exception e) {
+        } catch (final Exception e) {
             /* Ignore */
         }
     }
@@ -2295,10 +2283,11 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Creates the actual data source instance.  This method only exists so
-     * that subclasses can replace the implementation class.
-     * @return the data source
-     * @throws SQLException if unable to create a datasource instance
+     * Creates the actual data source instance. This method only exists so that subclasses can replace the
+     * implementation class.
+     *
+     * @throws SQLException
+     *             if unable to create a datasource instance
      */
     protected DataSource createDataSourceInstance() throws SQLException {
         final PoolingDataSource<PoolableConnection> pds = new PoolingDataSource<>(connectionPool);
@@ -2307,20 +2296,22 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     }
 
     /**
-     * Creates the PoolableConnectionFactory and attaches it to the connection pool.  This method only exists
-     * so subclasses can replace the default implementation.
+     * Creates the PoolableConnectionFactory and attaches it to the connection pool. This method only exists so
+     * subclasses can replace the default implementation.
      *
-     * @param driverConnectionFactory JDBC connection factory
-     * @return the connection factory
-     * @throws SQLException if an error occurs creating the PoolableConnectionFactory
+     * @param driverConnectionFactory
+     *            JDBC connection factory
+     * @throws SQLException
+     *             if an error occurs creating the PoolableConnectionFactory
      */
-    protected PoolableConnectionFactory createPoolableConnectionFactory(
-            final ConnectionFactory driverConnectionFactory) throws SQLException {
+    protected PoolableConnectionFactory createPoolableConnectionFactory(final ConnectionFactory driverConnectionFactory)
+            throws SQLException {
         PoolableConnectionFactory connectionFactory = null;
         try {
-            connectionFactory = new PoolableConnectionFactory(driverConnectionFactory, registeredJmxName);
+            connectionFactory = new PoolableConnectionFactory(driverConnectionFactory,
+                    ObjectNameWrapper.unwrap(registeredJmxObjectName));
             connectionFactory.setValidationQuery(validationQuery);
-            connectionFactory.setValidationQueryTimeout(validationQueryTimeout);
+            connectionFactory.setValidationQueryTimeout(validationQueryTimeoutSeconds);
             connectionFactory.setConnectionInitSql(connectionInitSqls);
             connectionFactory.setDefaultReadOnly(defaultReadOnly);
             connectionFactory.setDefaultAutoCommit(defaultAutoCommit);
@@ -2344,8 +2335,8 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
         return connectionFactory;
     }
 
-    protected static void validateConnectionFactory(
-            final PoolableConnectionFactory connectionFactory) throws Exception {
+    protected static void validateConnectionFactory(final PoolableConnectionFactory connectionFactory)
+            throws Exception {
         PoolableConnection conn = null;
         PooledObject<PoolableConnection> p = null;
         try {
@@ -2354,8 +2345,7 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
             connectionFactory.activateObject(p);
             connectionFactory.validateConnection(conn);
             connectionFactory.passivateObject(p);
-        }
-        finally {
+        } finally {
             if (p != null) {
                 connectionFactory.destroyObject(p);
             }
@@ -2371,11 +2361,11 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
     /**
      * Actual name under which this component has been registered.
      */
-    private ObjectName registeredJmxName = null;
+    private ObjectNameWrapper registeredJmxObjectName;
 
     private void jmxRegister() {
         // Return immediately if this DataSource has already been registered
-        if (registeredJmxName != null) {
+        if (registeredJmxObjectName != null) {
             return;
         }
         // Return immediately if no JMX name has been specified
@@ -2383,39 +2373,27 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
         if (requestedName == null) {
             return;
         }
-        ObjectName oname;
         try {
-             oname = new ObjectName(requestedName);
+            ObjectNameWrapper.wrap(requestedName).registerMBean(this);
         } catch (final MalformedObjectNameException e) {
-            log.warn("The requested JMX name [" + requestedName +
-                    "] was not valid and will be ignored.");
-            return;
-        }
-
-        final MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
-        try {
-            mbs.registerMBean(this, oname);
-        } catch (InstanceAlreadyExistsException | MBeanRegistrationException
-                | NotCompliantMBeanException e) {
-            log.warn("Failed to complete JMX registration", e);
+            log.warn("The requested JMX name [" + requestedName + "] was not valid and will be ignored.");
         }
     }
 
     @Override
-    public ObjectName preRegister(final MBeanServer server, final ObjectName name) {
+    public ObjectName preRegister(final MBeanServer server, final ObjectName objectName) {
         final String requestedName = getJmxName();
         if (requestedName != null) {
             try {
-                registeredJmxName = new ObjectName(requestedName);
+                registeredJmxObjectName = ObjectNameWrapper.wrap(requestedName);
             } catch (final MalformedObjectNameException e) {
-                log.warn("The requested JMX name [" + requestedName +
-                        "] was not valid and will be ignored.");
+                log.warn("The requested JMX name [" + requestedName + "] was not valid and will be ignored.");
             }
         }
-        if (registeredJmxName == null) {
-            registeredJmxName = name;
+        if (registeredJmxObjectName == null) {
+            registeredJmxObjectName = ObjectNameWrapper.wrap(objectName);
         }
-        return registeredJmxName;
+        return ObjectNameWrapper.unwrap(registeredJmxObjectName);
     }
 
     @Override
@@ -2433,18 +2411,18 @@ public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBean
         // NO-OP
     }
 
-    private void updateJmxName(final GenericObjectPoolConfig<PoolableConnection> config) {
-        if (registeredJmxName == null) {
+    private void updateJmxName(final GenericObjectPoolConfig config) {
+        if (registeredJmxObjectName == null) {
             return;
         }
-        final StringBuilder base = new StringBuilder(registeredJmxName.toString());
+        final StringBuilder base = new StringBuilder(registeredJmxObjectName.toString());
         base.append(Constants.JMX_CONNECTION_POOL_BASE_EXT);
         config.setJmxNameBase(base.toString());
         config.setJmxNamePrefix(Constants.JMX_CONNECTION_POOL_PREFIX);
     }
 
     protected ObjectName getRegisteredJmxName() {
-        return registeredJmxName;
+        return ObjectNameWrapper.unwrap(registeredJmxObjectName);
     }
 
     /**

==================================================
BasicDataSourceMXBean.java
index 2fc1a3d0bf..671d01287c 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSourceFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSourceFactory.java
@@ -43,19 +43,16 @@ import org.apache.tomcat.dbcp.pool2.impl.BaseObjectPoolConfig;
 import org.apache.tomcat.dbcp.pool2.impl.GenericObjectPoolConfig;
 
 /**
- * <p>JNDI object factory that creates an instance of
- * <code>BasicDataSource</code> that has been configured based on the
- * <code>RefAddr</code> values of the specified <code>Reference</code>, which
- * must match the names and data types of the <code>BasicDataSource</code> bean
- * properties with the following exceptions:</p>
+ * <p>
+ * JNDI object factory that creates an instance of <code>BasicDataSource</code> that has been configured based on the
+ * <code>RefAddr</code> values of the specified <code>Reference</code>, which must match the names and data types of the
+ * <code>BasicDataSource</code> bean properties with the following exceptions:
+ * </p>
  * <ul>
- * <li><code>connectionInitSqls</code> must be passed to this factory as a
- *     single String using semi-colon to delimit the statements whereas
- *     <code>BasicDataSource</code> requires a collection of Strings.</li>
+ * <li><code>connectionInitSqls</code> must be passed to this factory as a single String using semi-colon to delimit the
+ * statements whereas <code>BasicDataSource</code> requires a collection of Strings.</li>
  * </ul>
  *
- * @author Craig R. McClanahan
- * @author Dirk Verbeeck
  * @since 2.0
  */
 public class BasicDataSourceFactory implements ObjectFactory {
@@ -66,7 +63,7 @@ public class BasicDataSourceFactory implements ObjectFactory {
     private static final String PROP_DEFAULTREADONLY = "defaultReadOnly";
     private static final String PROP_DEFAULTTRANSACTIONISOLATION = "defaultTransactionIsolation";
     private static final String PROP_DEFAULTCATALOG = "defaultCatalog";
-    private static final String PROP_CACHESTATE ="cacheState";
+    private static final String PROP_CACHESTATE = "cacheState";
     private static final String PROP_DRIVERCLASSNAME = "driverClassName";
     private static final String PROP_LIFO = "lifo";
     private static final String PROP_MAXTOTAL = "maxTotal";
@@ -91,8 +88,7 @@ public class BasicDataSourceFactory implements ObjectFactory {
     private static final String PROP_JMX_NAME = "jmxName";
 
     /**
-     * The property name for connectionInitSqls.
-     * The associated value String must be of the form [query;]*
+     * The property name for connectionInitSqls. The associated value String must be of the form [query;]*
      */
     private static final String PROP_CONNECTIONINITSQLS = "connectionInitSqls";
     private static final String PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED = "accessToUnderlyingConnectionAllowed";
@@ -117,99 +113,58 @@ public class BasicDataSourceFactory implements ObjectFactory {
     private static final String PROP_DISCONNECTION_SQL_CODES = "disconnectionSqlCodes";
 
     /*
-     * Block with obsolete properties from DBCP 1.x.
-     * Warn users that these are ignored and they should use the 2.x properties.
+     * Block with obsolete properties from DBCP 1.x. Warn users that these are ignored and they should use the 2.x
+     * properties.
      */
     private static final String NUPROP_MAXACTIVE = "maxActive";
     private static final String NUPROP_REMOVEABANDONED = "removeAbandoned";
     private static final String NUPROP_MAXWAIT = "maxWait";
 
     /*
-     * Block with properties expected in a DataSource
-     * This props will not be listed as ignored - we know that they may appear in Resource,
-     * and not listing them as ignored.
+     * Block with properties expected in a DataSource This props will not be listed as ignored - we know that they may
+     * appear in Resource, and not listing them as ignored.
      */
     private static final String SILENTPROP_FACTORY = "factory";
     private static final String SILENTPROP_SCOPE = "scope";
     private static final String SILENTPROP_SINGLETON = "singleton";
     private static final String SILENTPROP_AUTH = "auth";
 
-    private static final String[] ALL_PROPERTIES = {
-        PROP_DEFAULTAUTOCOMMIT,
-        PROP_DEFAULTREADONLY,
-        PROP_DEFAULTTRANSACTIONISOLATION,
-        PROP_DEFAULTCATALOG,
-        PROP_CACHESTATE,
-        PROP_DRIVERCLASSNAME,
-        PROP_LIFO,
-        PROP_MAXTOTAL,
-        PROP_MAXIDLE,
-        PROP_MINIDLE,
-        PROP_INITIALSIZE,
-        PROP_MAXWAITMILLIS,
-        PROP_TESTONCREATE,
-        PROP_TESTONBORROW,
-        PROP_TESTONRETURN,
-        PROP_TIMEBETWEENEVICTIONRUNSMILLIS,
-        PROP_NUMTESTSPEREVICTIONRUN,
-        PROP_MINEVICTABLEIDLETIMEMILLIS,
-        PROP_SOFTMINEVICTABLEIDLETIMEMILLIS,
-        PROP_EVICTIONPOLICYCLASSNAME,
-        PROP_TESTWHILEIDLE,
-        PROP_PASSWORD,
-        PROP_URL,
-        PROP_USERNAME,
-        PROP_VALIDATIONQUERY,
-        PROP_VALIDATIONQUERY_TIMEOUT,
-        PROP_CONNECTIONINITSQLS,
-        PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED,
-        PROP_REMOVEABANDONEDONBORROW,
-        PROP_REMOVEABANDONEDONMAINTENANCE,
-        PROP_REMOVEABANDONEDTIMEOUT,
-        PROP_LOGABANDONED,
-        PROP_ABANDONEDUSAGETRACKING,
-        PROP_POOLPREPAREDSTATEMENTS,
-        PROP_MAXOPENPREPAREDSTATEMENTS,
-        PROP_CONNECTIONPROPERTIES,
-        PROP_MAXCONNLIFETIMEMILLIS,
-        PROP_LOGEXPIREDCONNECTIONS,
-        PROP_ROLLBACK_ON_RETURN,
-        PROP_ENABLE_AUTOCOMMIT_ON_RETURN,
-        PROP_DEFAULT_QUERYTIMEOUT,
-        PROP_FASTFAIL_VALIDATION,
-        PROP_DISCONNECTION_SQL_CODES,
-        PROP_JMX_NAME
-    };
+    private static final String[] ALL_PROPERTIES = {PROP_DEFAULTAUTOCOMMIT, PROP_DEFAULTREADONLY,
+            PROP_DEFAULTTRANSACTIONISOLATION, PROP_DEFAULTCATALOG, PROP_CACHESTATE, PROP_DRIVERCLASSNAME, PROP_LIFO,
+            PROP_MAXTOTAL, PROP_MAXIDLE, PROP_MINIDLE, PROP_INITIALSIZE, PROP_MAXWAITMILLIS, PROP_TESTONCREATE,
+            PROP_TESTONBORROW, PROP_TESTONRETURN, PROP_TIMEBETWEENEVICTIONRUNSMILLIS, PROP_NUMTESTSPEREVICTIONRUN,
+            PROP_MINEVICTABLEIDLETIMEMILLIS, PROP_SOFTMINEVICTABLEIDLETIMEMILLIS, PROP_EVICTIONPOLICYCLASSNAME,
+            PROP_TESTWHILEIDLE, PROP_PASSWORD, PROP_URL, PROP_USERNAME, PROP_VALIDATIONQUERY,
+            PROP_VALIDATIONQUERY_TIMEOUT, PROP_CONNECTIONINITSQLS, PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED,
+            PROP_REMOVEABANDONEDONBORROW, PROP_REMOVEABANDONEDONMAINTENANCE, PROP_REMOVEABANDONEDTIMEOUT,
+            PROP_LOGABANDONED, PROP_ABANDONEDUSAGETRACKING, PROP_POOLPREPAREDSTATEMENTS, PROP_MAXOPENPREPAREDSTATEMENTS,
+            PROP_CONNECTIONPROPERTIES, PROP_MAXCONNLIFETIMEMILLIS, PROP_LOGEXPIREDCONNECTIONS, PROP_ROLLBACK_ON_RETURN,
+            PROP_ENABLE_AUTOCOMMIT_ON_RETURN, PROP_DEFAULT_QUERYTIMEOUT, PROP_FASTFAIL_VALIDATION,
+            PROP_DISCONNECTION_SQL_CODES, PROP_JMX_NAME };
 
     /**
-     * Obsolete properties from DBCP 1.x. with warning strings suggesting
-     * new properties. LinkedHashMap will guarantee that properties will be listed
-     * to output in order of insertion into map.
+     * Obsolete properties from DBCP 1.x. with warning strings suggesting new properties. LinkedHashMap will guarantee
+     * that properties will be listed to output in order of insertion into map.
      */
     private static final Map<String, String> NUPROP_WARNTEXT = new LinkedHashMap<>();
 
     static {
-        NUPROP_WARNTEXT.put(
-                NUPROP_MAXACTIVE,
+        NUPROP_WARNTEXT.put(NUPROP_MAXACTIVE,
                 "Property " + NUPROP_MAXACTIVE + " is not used in DBCP2, use " + PROP_MAXTOTAL + " instead. "
-                        + PROP_MAXTOTAL + " default value is " + GenericObjectPoolConfig.DEFAULT_MAX_TOTAL+".");
-        NUPROP_WARNTEXT.put(
-                NUPROP_REMOVEABANDONED,
-                "Property " + NUPROP_REMOVEABANDONED + " is not used in DBCP2,"
-                        + " use one or both of "
+                        + PROP_MAXTOTAL + " default value is " + GenericObjectPoolConfig.DEFAULT_MAX_TOTAL + ".");
+        NUPROP_WARNTEXT.put(NUPROP_REMOVEABANDONED,
+                "Property " + NUPROP_REMOVEABANDONED + " is not used in DBCP2," + " use one or both of "
                         + PROP_REMOVEABANDONEDONBORROW + " or " + PROP_REMOVEABANDONEDONMAINTENANCE + " instead. "
                         + "Both have default value set to false.");
-        NUPROP_WARNTEXT.put(
-                NUPROP_MAXWAIT,
-                "Property " + NUPROP_MAXWAIT + " is not used in DBCP2"
-                        + " , use " + PROP_MAXWAITMILLIS + " instead. "
-                        + PROP_MAXWAITMILLIS + " default value is " + BaseObjectPoolConfig.DEFAULT_MAX_WAIT_MILLIS+".");
+        NUPROP_WARNTEXT.put(NUPROP_MAXWAIT,
+                "Property " + NUPROP_MAXWAIT + " is not used in DBCP2" + " , use " + PROP_MAXWAITMILLIS + " instead. "
+                        + PROP_MAXWAITMILLIS + " default value is " + BaseObjectPoolConfig.DEFAULT_MAX_WAIT_MILLIS
+                        + ".");
     }
 
     /**
-     * Silent Properties.
-     * These properties will not be listed as ignored - we know that they may appear in JDBC Resource references,
-     * and we will not list them as ignored.
+     * Silent Properties. These properties will not be listed as ignored - we know that they may appear in JDBC Resource
+     * references, and we will not list them as ignored.
      */
     private static final List<String> SILENT_PROPERTIES = new ArrayList<>();
 
@@ -224,23 +179,28 @@ public class BasicDataSourceFactory implements ObjectFactory {
     // -------------------------------------------------- ObjectFactory Methods
 
     /**
-     * <p>Create and return a new <code>BasicDataSource</code> instance.  If no
-     * instance can be created, return <code>null</code> instead.</p>
+     * <p>
+     * Create and return a new <code>BasicDataSource</code> instance. If no instance can be created, return
+     * <code>null</code> instead.
+     * </p>
      *
-     * @param obj The possibly null object containing location or
-     *  reference information that can be used in creating an object
-     * @param name The name of this object relative to <code>nameCtx</code>
-     * @param nameCtx The context relative to which the <code>name</code>
-     *  parameter is specified, or <code>null</code> if <code>name</code>
-     *  is relative to the default initial context
-     * @param environment The possibly null environment that is used in
-     *  creating this object
+     * @param obj
+     *            The possibly null object containing location or reference information that can be used in creating an
+     *            object
+     * @param name
+     *            The name of this object relative to <code>nameCtx</code>
+     * @param nameCtx
+     *            The context relative to which the <code>name</code> parameter is specified, or <code>null</code> if
+     *            <code>name</code> is relative to the default initial context
+     * @param environment
+     *            The possibly null environment that is used in creating this object
      *
-     * @throws Exception if an exception occurs creating the instance
+     * @throws Exception
+     *             if an exception occurs creating the instance
      */
     @Override
-    public Object getObjectInstance(final Object obj, final Name name, final Context nameCtx, final Hashtable<?,?> environment)
-        throws Exception {
+    public Object getObjectInstance(final Object obj, final Name name, final Context nameCtx,
+            final Hashtable<?, ?> environment) throws Exception {
 
         // We only know how to deal with <code>javax.naming.Reference</code>s
         // that specify a class name of "javax.sql.DataSource"
@@ -272,33 +232,34 @@ public class BasicDataSourceFactory implements ObjectFactory {
             }
         }
 
-        return createDataSourceInstance(properties);
+        return createDataSource(properties);
     }
 
     /**
-     * Collects warnings and info messages.  Warnings are generated when an obsolete
-     * property is set.  Unknown properties generate info messages.
+     * Collects warnings and info messages. Warnings are generated when an obsolete property is set. Unknown properties
+     * generate info messages.
      *
-     * @param ref Reference to check properties of
-     * @param name Name provided to getObject
-     * @param warnings container for warning messages
-     * @param infoMessages container for info messages
+     * @param ref
+     *            Reference to check properties of
+     * @param name
+     *            Name provided to getObject
+     * @param warnings
+     *            container for warning messages
+     * @param infoMessages
+     *            container for info messages
      */
     private void validatePropertyNames(final Reference ref, final Name name, final List<String> warnings,
-                                      final List<String> infoMessages) {
+            final List<String> infoMessages) {
         final List<String> allPropsAsList = Arrays.asList(ALL_PROPERTIES);
         final String nameString = name != null ? "Name = " + name.toString() + " " : "";
-        if (NUPROP_WARNTEXT!=null && !NUPROP_WARNTEXT.keySet().isEmpty()) {
+        if (NUPROP_WARNTEXT != null && !NUPROP_WARNTEXT.keySet().isEmpty()) {
             for (final String propertyName : NUPROP_WARNTEXT.keySet()) {
                 final RefAddr ra = ref.get(propertyName);
                 if (ra != null && !allPropsAsList.contains(ra.getType())) {
                     final StringBuilder stringBuilder = new StringBuilder(nameString);
                     final String propertyValue = ra.getContent().toString();
-                    stringBuilder.append(NUPROP_WARNTEXT.get(propertyName))
-                            .append(" You have set value of \"")
-                            .append(propertyValue)
-                            .append("\" for \"")
-                            .append(propertyName)
+                    stringBuilder.append(NUPROP_WARNTEXT.get(propertyName)).append(" You have set value of \"")
+                            .append(propertyValue).append("\" for \"").append(propertyName)
                             .append("\" property, which is being ignored.");
                     warnings.add(stringBuilder.toString());
                 }
@@ -311,58 +272,28 @@ public class BasicDataSourceFactory implements ObjectFactory {
             final String propertyName = ra.getType();
             // If property name is not in the properties list, we haven't warned on it
             // and it is not in the "silent" list, tell user we are ignoring it.
-            if (!(allPropsAsList.contains(propertyName)
-                    || NUPROP_WARNTEXT.keySet().contains(propertyName)
+            if (!(allPropsAsList.contains(propertyName) || NUPROP_WARNTEXT.keySet().contains(propertyName)
                     || SILENT_PROPERTIES.contains(propertyName))) {
                 final String propertyValue = ra.getContent().toString();
                 final StringBuilder stringBuilder = new StringBuilder(nameString);
-                stringBuilder.append("Ignoring unknown property: ")
-                        .append("value of \"")
-                        .append(propertyValue)
-                        .append("\" for \"")
-                        .append(propertyName)
-                        .append("\" property");
+                stringBuilder.append("Ignoring unknown property: ").append("value of \"").append(propertyValue)
+                        .append("\" for \"").append(propertyName).append("\" property");
                 infoMessages.add(stringBuilder.toString());
             }
         }
     }
 
     /**
-     * Creates and configures a {@link BasicDataSource} instance based on the
-     * given properties.
+     * Creates and configures a {@link BasicDataSource} instance based on the given properties.
      *
-     * @param properties the datasource configuration properties
-     * @return the data source instance
-     * @throws Exception if an error occurs creating the data source
+     * @param properties
+     *            The data source configuration properties.
+     * @return A new a {@link BasicDataSource} instance based on the given properties.
+     * @throws Exception
+     *             Thrown when an error occurs creating the data source.
      */
     public static BasicDataSource createDataSource(final Properties properties) throws Exception {
-        return (new BasicDataSourceFactory()).createDataSourceInstance(properties);
-    }
-
-    /**
-     * Creates and configures a {@link BasicDataSource} instance based on the
-     * given properties.
-     * Note: duplicates the static createDataSource to avoid an API change
-     *
-     * @param properties the datasource configuration properties
-     * @return the data source instance
-     * @throws Exception if an error occurs creating the data source
-     */
-    public BasicDataSource createDataSourceInstance(final Properties properties) throws Exception {
         final BasicDataSource dataSource = new BasicDataSource();
-        configureDataSource(dataSource, properties);
-        return dataSource;
-    }
-
-    /**
-     * Configures a {@link BasicDataSource} instance based on the
-     * given properties.
-     *
-     * @param properties the datasource configuration properties
-     * @param dataSource the data source instance
-     * @throws Exception if an error occurs creating the data source
-     */
-    public void configureDataSource(final BasicDataSource dataSource, final Properties properties) throws Exception {
         String value = null;
 
         value = properties.getProperty(PROP_DEFAULTAUTOCOMMIT);
@@ -380,20 +311,15 @@ public class BasicDataSourceFactory implements ObjectFactory {
             int level = PoolableConnectionFactory.UNKNOWN_TRANSACTIONISOLATION;
             if ("NONE".equalsIgnoreCase(value)) {
                 level = Connection.TRANSACTION_NONE;
-            }
-            else if ("READ_COMMITTED".equalsIgnoreCase(value)) {
+            } else if ("READ_COMMITTED".equalsIgnoreCase(value)) {
                 level = Connection.TRANSACTION_READ_COMMITTED;
-            }
-            else if ("READ_UNCOMMITTED".equalsIgnoreCase(value)) {
+            } else if ("READ_UNCOMMITTED".equalsIgnoreCase(value)) {
                 level = Connection.TRANSACTION_READ_UNCOMMITTED;
-            }
-            else if ("REPEATABLE_READ".equalsIgnoreCase(value)) {
+            } else if ("REPEATABLE_READ".equalsIgnoreCase(value)) {
                 level = Connection.TRANSACTION_REPEATABLE_READ;
-            }
-            else if ("SERIALIZABLE".equalsIgnoreCase(value)) {
+            } else if ("SERIALIZABLE".equalsIgnoreCase(value)) {
                 level = Connection.TRANSACTION_SERIALIZABLE;
-            }
-            else {
+            } else {
                 try {
                     level = Integer.parseInt(value);
                 } catch (final NumberFormatException e) {
@@ -568,12 +494,12 @@ public class BasicDataSourceFactory implements ObjectFactory {
 
         value = properties.getProperty(PROP_CONNECTIONPROPERTIES);
         if (value != null) {
-          final Properties p = getProperties(value);
-          final Enumeration<?> e = p.propertyNames();
-          while (e.hasMoreElements()) {
-            final String propertyName = (String) e.nextElement();
-            dataSource.addConnectionProperty(propertyName, p.getProperty(propertyName));
-          }
+            final Properties p = getProperties(value);
+            final Enumeration<?> e = p.propertyNames();
+            while (e.hasMoreElements()) {
+                final String propertyName = (String) e.nextElement();
+                dataSource.addConnectionProperty(propertyName, p.getProperty(propertyName));
+            }
         }
 
         value = properties.getProperty(PROP_MAXCONNLIFETIMEMILLIS);
@@ -621,27 +547,35 @@ public class BasicDataSourceFactory implements ObjectFactory {
         if (dataSource.getInitialSize() > 0) {
             dataSource.getLogWriter();
         }
+
+        // Return the configured DataSource instance
+        return dataSource;
     }
 
     /**
-     * <p>Parse properties from the string. Format of the string must be [propertyName=property;]*<p>
+     * <p>
+     * Parse properties from the string. Format of the string must be [propertyName=property;]*
+     * <p>
+     *
      * @param propText
      * @return Properties
      * @throws Exception
      */
     private static Properties getProperties(final String propText) throws Exception {
-      final Properties p = new Properties();
-      if (propText != null) {
-        p.load(new ByteArrayInputStream(
-                propText.replace(';', '\n').getBytes(StandardCharsets.ISO_8859_1)));
-      }
-      return p;
+        final Properties p = new Properties();
+        if (propText != null) {
+            p.load(new ByteArrayInputStream(propText.replace(';', '\n').getBytes(StandardCharsets.ISO_8859_1)));
+        }
+        return p;
     }
 
     /**
      * Parse list of property values from a delimited string
-     * @param value delimited list of values
-     * @param delimiter character used to separate values in the list
+     *
+     * @param value
+     *            delimited list of values
+     * @param delimiter
+     *            character used to separate values in the list
      * @return String Collection of values
      */
     private static Collection<String> parseList(final String value, final char delimiter) {

==================================================
ConnectionFactory.java
index ed797ad7cc..0878d148e2 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSourceMXBean.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/BasicDataSourceMXBean.java
@@ -25,198 +25,231 @@ public interface BasicDataSourceMXBean {
 
     /**
      * See {@link BasicDataSource#getAbandonedUsageTracking()}
+     *
      * @return {@link BasicDataSource#getAbandonedUsageTracking()}
      */
     boolean getAbandonedUsageTracking();
 
     /**
      * See {@link BasicDataSource#getDefaultAutoCommit()}
+     *
      * @return {@link BasicDataSource#getDefaultAutoCommit()}
      */
     Boolean getDefaultAutoCommit();
 
     /**
      * See {@link BasicDataSource#getDefaultReadOnly()}
+     *
      * @return {@link BasicDataSource#getDefaultReadOnly()}
      */
     Boolean getDefaultReadOnly();
 
     /**
      * See {@link BasicDataSource#getDefaultTransactionIsolation()}
+     *
      * @return {@link BasicDataSource#getDefaultTransactionIsolation()}
      */
     int getDefaultTransactionIsolation();
 
     /**
      * See {@link BasicDataSource#getDefaultCatalog()}
+     *
      * @return {@link BasicDataSource#getDefaultCatalog()}
      */
     String getDefaultCatalog();
 
     /**
      * See {@link BasicDataSource#getCacheState()}
+     *
      * @return {@link BasicDataSource#getCacheState()}
      */
     boolean getCacheState();
 
     /**
      * See {@link BasicDataSource#getDriverClassName()}
+     *
      * @return {@link BasicDataSource#getDriverClassName()}
      */
     String getDriverClassName();
 
     /**
      * See {@link BasicDataSource#getLifo()}
+     *
      * @return {@link BasicDataSource#getLifo()}
      */
     boolean getLifo();
 
     /**
      * See {@link BasicDataSource#getMaxTotal()}
+     *
      * @return {@link BasicDataSource#getMaxTotal()}
      */
     int getMaxTotal();
 
     /**
      * See {@link BasicDataSource#getMaxIdle()}
+     *
      * @return {@link BasicDataSource#getMaxIdle()}
      */
     int getMaxIdle();
 
     /**
      * See {@link BasicDataSource#getMinIdle()}
+     *
      * @return {@link BasicDataSource#getMinIdle()}
      */
     int getMinIdle();
 
     /**
      * See {@link BasicDataSource#getInitialSize()}
+     *
      * @return {@link BasicDataSource#getInitialSize()}
      */
     int getInitialSize();
 
     /**
      * See {@link BasicDataSource#getMaxWaitMillis()}
+     *
      * @return {@link BasicDataSource#getMaxWaitMillis()}
      */
     long getMaxWaitMillis();
 
     /**
      * See {@link BasicDataSource#isPoolPreparedStatements()}
+     *
      * @return {@link BasicDataSource#isPoolPreparedStatements()}
      */
     boolean isPoolPreparedStatements();
 
     /**
      * See {@link BasicDataSource#getMaxOpenPreparedStatements()}
+     *
      * @return {@link BasicDataSource#getMaxOpenPreparedStatements()}
      */
     int getMaxOpenPreparedStatements();
 
     /**
      * See {@link BasicDataSource#getTestOnCreate()}
+     *
      * @return {@link BasicDataSource#getTestOnCreate()}
      */
     boolean getTestOnCreate();
 
     /**
      * See {@link BasicDataSource#getTestOnBorrow()}
+     *
      * @return {@link BasicDataSource#getTestOnBorrow()}
      */
     boolean getTestOnBorrow();
 
     /**
      * See {@link BasicDataSource#getTimeBetweenEvictionRunsMillis()}
+     *
      * @return {@link BasicDataSource#getTimeBetweenEvictionRunsMillis()}
      */
     long getTimeBetweenEvictionRunsMillis();
 
     /**
      * See {@link BasicDataSource#getNumTestsPerEvictionRun()}
+     *
      * @return {@link BasicDataSource#getNumTestsPerEvictionRun()}
      */
     int getNumTestsPerEvictionRun();
 
     /**
      * See {@link BasicDataSource#getMinEvictableIdleTimeMillis()}
+     *
      * @return {@link BasicDataSource#getMinEvictableIdleTimeMillis()}
      */
     long getMinEvictableIdleTimeMillis();
 
     /**
      * See {@link BasicDataSource#getSoftMinEvictableIdleTimeMillis()}
+     *
      * @return {@link BasicDataSource#getSoftMinEvictableIdleTimeMillis()}
      */
     long getSoftMinEvictableIdleTimeMillis();
 
     /**
      * See {@link BasicDataSource#getTestWhileIdle()}
+     *
      * @return {@link BasicDataSource#getTestWhileIdle()}
      */
     boolean getTestWhileIdle();
 
     /**
      * See {@link BasicDataSource#getNumActive()}
+     *
      * @return {@link BasicDataSource#getNumActive()}
      */
     int getNumActive();
 
     /**
      * See {@link BasicDataSource#getNumIdle()}
+     *
      * @return {@link BasicDataSource#getNumIdle()}
      */
     int getNumIdle();
 
     /**
      * See {@link BasicDataSource#getPassword()}
+     *
      * @return {@link BasicDataSource#getPassword()}
      */
     String getPassword();
 
     /**
      * See {@link BasicDataSource#getUrl()}
+     *
      * @return {@link BasicDataSource#getUrl()}
      */
     String getUrl();
 
     /**
      * See {@link BasicDataSource#getUsername()}
+     *
      * @return {@link BasicDataSource#getUsername()}
      */
     String getUsername();
 
     /**
      * See {@link BasicDataSource#getValidationQuery()}
+     *
      * @return {@link BasicDataSource#getValidationQuery()}
      */
     String getValidationQuery();
 
     /**
      * See {@link BasicDataSource#getValidationQueryTimeout()}
+     *
      * @return {@link BasicDataSource#getValidationQueryTimeout()}
      */
     int getValidationQueryTimeout();
 
     /**
      * See {@link BasicDataSource#getConnectionInitSqlsAsArray()}
+     *
      * @return {@link BasicDataSource#getConnectionInitSqlsAsArray()}
      */
     String[] getConnectionInitSqlsAsArray();
 
     /**
      * See {@link BasicDataSource#isAccessToUnderlyingConnectionAllowed()}
+     *
      * @return {@link BasicDataSource#isAccessToUnderlyingConnectionAllowed()}
      */
     boolean isAccessToUnderlyingConnectionAllowed();
 
     /**
      * See {@link BasicDataSource#getMaxConnLifetimeMillis()}
+     *
      * @return {@link BasicDataSource#getMaxConnLifetimeMillis()}
      */
     long getMaxConnLifetimeMillis();
 
     /**
      * See {@link BasicDataSource#getLogExpiredConnections()}
+     *
      * @return {@link BasicDataSource#getLogExpiredConnections()}
      * @since 2.1
      */
@@ -224,36 +257,42 @@ public interface BasicDataSourceMXBean {
 
     /**
      * See {@link BasicDataSource#getRemoveAbandonedOnBorrow()}
+     *
      * @return {@link BasicDataSource#getRemoveAbandonedOnBorrow()}
      */
     boolean getRemoveAbandonedOnBorrow();
 
     /**
      * See {@link BasicDataSource#getRemoveAbandonedOnMaintenance()}
+     *
      * @return {@link BasicDataSource#getRemoveAbandonedOnMaintenance()}
      */
     boolean getRemoveAbandonedOnMaintenance();
 
     /**
      * See {@link BasicDataSource#getRemoveAbandonedTimeout()}
+     *
      * @return {@link BasicDataSource#getRemoveAbandonedTimeout()}
      */
     int getRemoveAbandonedTimeout();
 
     /**
      * See {@link BasicDataSource#getLogAbandoned()}
+     *
      * @return {@link BasicDataSource#getLogAbandoned()}
      */
     boolean getLogAbandoned();
 
     /**
      * See {@link BasicDataSource#isClosed()}
+     *
      * @return {@link BasicDataSource#isClosed()}
      */
     boolean isClosed();
 
     /**
      * See {@link BasicDataSource#getFastFailValidation()}
+     *
      * @return {@link BasicDataSource#getFastFailValidation()}
      * @since 2.1
      */
@@ -261,6 +300,7 @@ public interface BasicDataSourceMXBean {
 
     /**
      * See {@link BasicDataSource#getDisconnectionSqlCodesAsArray()}
+     *
      * @return {@link BasicDataSource#getDisconnectionSqlCodesAsArray()}
      * @since 2.1
      */

==================================================
Constants.java
index 7dd96822bb..d01c3e43fa 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/ConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/ConnectionFactory.java
@@ -22,16 +22,15 @@ import java.sql.SQLException;
 /**
  * Abstract factory interface for creating {@link java.sql.Connection}s.
  *
- * @author Rodney Waldhoff
  * @since 2.0
  */
 public interface ConnectionFactory {
     /**
-     * Create a new {@link java.sql.Connection} in an
-     * implementation specific fashion.
+     * Create a new {@link java.sql.Connection} in an implementation specific fashion.
      *
      * @return a new {@link java.sql.Connection}
-     * @throws SQLException if a database error occurs creating the connection
+     * @throws SQLException
+     *             if a database error occurs creating the connection
      */
     Connection createConnection() throws SQLException;
 }

==================================================
DataSourceConnectionFactory.java
index dd3506dafd..d9278cf81c 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/Constants.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/Constants.java
@@ -17,19 +17,18 @@
 package org.apache.tomcat.dbcp.dbcp2;
 
 /**
- * Constants for use with JMX
+ * Constants for use with JMX.
+ *
  * @since 2.0
  */
 public class Constants {
+
     public static final String JMX_CONNECTION_POOL_BASE_EXT = ",connectionpool=";
     public static final String JMX_CONNECTION_POOL_PREFIX = "connections";
 
-    public static final String JMX_CONNECTION_BASE_EXT =
-            JMX_CONNECTION_POOL_BASE_EXT +
-            JMX_CONNECTION_POOL_PREFIX +
-            ",connection=";
+    public static final String JMX_CONNECTION_BASE_EXT = JMX_CONNECTION_POOL_BASE_EXT + JMX_CONNECTION_POOL_PREFIX
+            + ",connection=";
 
-    public static final String JMX_STATEMENT_POOL_BASE_EXT =
-            JMX_CONNECTION_BASE_EXT;
+    public static final String JMX_STATEMENT_POOL_BASE_EXT = JMX_CONNECTION_BASE_EXT;
     public static final String JMX_STATEMENT_POOL_PREFIX = ",statementpool=statements";
 }

==================================================
DelegatingCallableStatement.java
index 0a9e3a6d77..c56b5005bb 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DataSourceConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DataSourceConnectionFactory.java
@@ -24,29 +24,64 @@ import javax.sql.DataSource;
 /**
  * A {@link DataSource}-based implementation of {@link ConnectionFactory}.
  *
- * @author Rodney Waldhoff
  * @since 2.0
  */
 public class DataSourceConnectionFactory implements ConnectionFactory {
-    public DataSourceConnectionFactory(final DataSource source) {
-        this(source,null,null);
+
+    private final DataSource dataSource;
+
+    private final String userName;
+
+    private final char[] userPassword;
+
+    /**
+     * Constructs an instance for the given DataSource.
+     *
+     * @param dataSource
+     *            The DataSource for this factory.
+     */
+    public DataSourceConnectionFactory(final DataSource dataSource) {
+        this(dataSource, null, (char[]) null);
     }
 
-    public DataSourceConnectionFactory(final DataSource source, final String uname, final String passwd) {
-        _source = source;
-        _uname = uname;
-        _passwd = passwd;
+    /**
+     * Constructs an instance for the given DataSource.
+     *
+     * @param dataSource
+     *            The DataSource for this factory.
+     * @param userName
+     *            The user name.
+     * @param userPassword
+     *            The user password.
+     * @since 2.4.0
+     */
+    public DataSourceConnectionFactory(final DataSource dataSource, final String userName, final char[] userPassword) {
+        this.dataSource = dataSource;
+        this.userName = userName;
+        this.userPassword = userPassword;
+    }
+
+    /**
+     * Constructs an instance for the given DataSource.
+     *
+     * @param dataSource
+     *            The DataSource for this factory.
+     * @param userName
+     *            The user name.
+     * @param password
+     *            The user password.
+     */
+    public DataSourceConnectionFactory(final DataSource dataSource, final String userName, final String password) {
+        this.dataSource = dataSource;
+        this.userName = userName;
+        this.userPassword = Utils.toCharArray(password);
     }
 
     @Override
     public Connection createConnection() throws SQLException {
-        if(null == _uname && null == _passwd) {
-            return _source.getConnection();
+        if (null == userName && null == userPassword) {
+            return dataSource.getConnection();
         }
-        return _source.getConnection(_uname,_passwd);
+        return dataSource.getConnection(userName, Utils.toString(userPassword));
     }
-
-    private final String _uname;
-    private final String _passwd;
-    private final DataSource _source;
 }

==================================================
DelegatingConnection.java
index b9797e0f35..0466ec60c4 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DelegatingCallableStatement.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingCallableStatement.java
@@ -39,362 +39,882 @@ import java.util.Map;
 /**
  * A base delegating implementation of {@link CallableStatement}.
  * <p>
- * All of the methods from the {@link CallableStatement} interface
- * simply call the corresponding method on the "delegate"
- * provided in my constructor.
+ * All of the methods from the {@link CallableStatement} interface simply call the corresponding method on the
+ * "delegate" provided in my constructor.
+ * </p>
  * <p>
- * Extends AbandonedTrace to implement Statement tracking and
- * logging of code which created the Statement. Tracking the
- * Statement ensures that the Connection which created it can
- * close any open Statement's on Connection close.
+ * Extends AbandonedTrace to implement Statement tracking and logging of code which created the Statement. Tracking the
+ * Statement ensures that the Connection which created it can close any open Statement's on Connection close.
+ * </p>
  *
- * @author Glenn L. Nielsen
- * @author James House
- * @author Dirk Verbeeck
  * @since 2.0
  */
-public class DelegatingCallableStatement extends DelegatingPreparedStatement
-        implements CallableStatement {
+public class DelegatingCallableStatement extends DelegatingPreparedStatement implements CallableStatement {
 
     /**
-     * Create a wrapper for the Statement which traces this
-     * Statement to the Connection which created it and the
-     * code which created it.
+     * Creates a wrapper for the Statement which traces this Statement to the Connection which created it and the code
+     * which created it.
      *
-     * @param c the {@link DelegatingConnection} that created this statement
-     * @param s the {@link CallableStatement} to delegate all calls to
+     * @param c
+     *            the {@link DelegatingConnection} that created this statement
+     * @param s
+     *            the {@link CallableStatement} to delegate all calls to
      */
-    public DelegatingCallableStatement(final DelegatingConnection<?> c,
-                                       final CallableStatement s) {
+    public DelegatingCallableStatement(final DelegatingConnection<?> c, final CallableStatement s) {
         super(c, s);
     }
 
     @Override
-    public void registerOutParameter(final int parameterIndex, final int sqlType) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter( parameterIndex,  sqlType); } catch (final SQLException e) { handleException(e); } }
+    public void registerOutParameter(final int parameterIndex, final int sqlType) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().registerOutParameter(parameterIndex, sqlType);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void registerOutParameter(final int parameterIndex, final int sqlType, final int scale) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter( parameterIndex,  sqlType,  scale); } catch (final SQLException e) { handleException(e); } }
+    public void registerOutParameter(final int parameterIndex, final int sqlType, final int scale) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().registerOutParameter(parameterIndex, sqlType, scale);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public boolean wasNull() throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).wasNull(); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean wasNull() throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().wasNull();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public String getString(final int parameterIndex) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getString( parameterIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public String getString(final int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getString(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public boolean getBoolean(final int parameterIndex) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBoolean( parameterIndex); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean getBoolean(final int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getBoolean(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public byte getByte(final int parameterIndex) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getByte( parameterIndex); } catch (final SQLException e) { handleException(e); return 0; } }
+    public byte getByte(final int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getByte(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public short getShort(final int parameterIndex) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getShort( parameterIndex); } catch (final SQLException e) { handleException(e); return 0; } }
+    public short getShort(final int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getShort(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public int getInt(final int parameterIndex) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getInt( parameterIndex); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getInt(final int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getInt(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public long getLong(final int parameterIndex) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getLong( parameterIndex); } catch (final SQLException e) { handleException(e); return 0; } }
+    public long getLong(final int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getLong(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public float getFloat(final int parameterIndex) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getFloat( parameterIndex); } catch (final SQLException e) { handleException(e); return 0; } }
+    public float getFloat(final int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getFloat(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public double getDouble(final int parameterIndex) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDouble( parameterIndex); } catch (final SQLException e) { handleException(e); return 0; } }
+    public double getDouble(final int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getDouble(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     /** @deprecated Use {@link #getBigDecimal(int)} or {@link #getBigDecimal(String)} */
     @Override
     @Deprecated
-    public BigDecimal getBigDecimal(final int parameterIndex, final int scale) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBigDecimal( parameterIndex,  scale); } catch (final SQLException e) { handleException(e); return null; } }
+    public BigDecimal getBigDecimal(final int parameterIndex, final int scale) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getBigDecimal(parameterIndex, scale);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public byte[] getBytes(final int parameterIndex) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBytes( parameterIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public byte[] getBytes(final int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getBytes(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Date getDate(final int parameterIndex) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDate( parameterIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public Date getDate(final int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getDate(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Time getTime(final int parameterIndex) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTime( parameterIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public Time getTime(final int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getTime(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Timestamp getTimestamp(final int parameterIndex) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTimestamp( parameterIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public Timestamp getTimestamp(final int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getTimestamp(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Object getObject(final int parameterIndex) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getObject( parameterIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public Object getObject(final int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getObject(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public BigDecimal getBigDecimal(final int parameterIndex) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBigDecimal( parameterIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public BigDecimal getBigDecimal(final int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getBigDecimal(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Object getObject(final int i, final Map<String,Class<?>> map) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getObject( i, map); } catch (final SQLException e) { handleException(e); return null; } }
+    public Object getObject(final int i, final Map<String, Class<?>> map) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getObject(i, map);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Ref getRef(final int i) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getRef( i); } catch (final SQLException e) { handleException(e); return null; } }
+    public Ref getRef(final int i) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getRef(i);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Blob getBlob(final int i) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBlob( i); } catch (final SQLException e) { handleException(e); return null; } }
+    public Blob getBlob(final int i) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getBlob(i);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Clob getClob(final int i) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getClob( i); } catch (final SQLException e) { handleException(e); return null; } }
+    public Clob getClob(final int i) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getClob(i);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Array getArray(final int i) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getArray( i); } catch (final SQLException e) { handleException(e); return null; } }
+    public Array getArray(final int i) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getArray(i);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Date getDate(final int parameterIndex, final Calendar cal) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDate( parameterIndex,  cal); } catch (final SQLException e) { handleException(e); return null; } }
+    public Date getDate(final int parameterIndex, final Calendar cal) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getDate(parameterIndex, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Time getTime(final int parameterIndex, final Calendar cal) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTime( parameterIndex,  cal); } catch (final SQLException e) { handleException(e); return null; } }
+    public Time getTime(final int parameterIndex, final Calendar cal) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getTime(parameterIndex, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Timestamp getTimestamp(final int parameterIndex, final Calendar cal) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTimestamp( parameterIndex,  cal); } catch (final SQLException e) { handleException(e); return null; } }
+    public Timestamp getTimestamp(final int parameterIndex, final Calendar cal) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getTimestamp(parameterIndex, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public void registerOutParameter(final int paramIndex, final int sqlType, final String typeName) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter( paramIndex,  sqlType,  typeName); } catch (final SQLException e) { handleException(e); } }
+    public void registerOutParameter(final int paramIndex, final int sqlType, final String typeName)
+            throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().registerOutParameter(paramIndex, sqlType, typeName);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void registerOutParameter(final String parameterName, final int sqlType) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter(parameterName, sqlType); } catch (final SQLException e) { handleException(e); } }
+    public void registerOutParameter(final String parameterName, final int sqlType) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().registerOutParameter(parameterName, sqlType);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void registerOutParameter(final String parameterName, final int sqlType, final int scale) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter(parameterName, sqlType, scale); } catch (final SQLException e) { handleException(e); } }
+    public void registerOutParameter(final String parameterName, final int sqlType, final int scale)
+            throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().registerOutParameter(parameterName, sqlType, scale);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void registerOutParameter(final String parameterName, final int sqlType, final String typeName) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter(parameterName, sqlType, typeName); } catch (final SQLException e) { handleException(e); } }
+    public void registerOutParameter(final String parameterName, final int sqlType, final String typeName)
+            throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().registerOutParameter(parameterName, sqlType, typeName);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public URL getURL(final int parameterIndex) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getURL(parameterIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public URL getURL(final int parameterIndex) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getURL(parameterIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public void setURL(final String parameterName, final URL val) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setURL(parameterName, val); } catch (final SQLException e) { handleException(e); } }
+    public void setURL(final String parameterName, final URL val) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setURL(parameterName, val);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setNull(final String parameterName, final int sqlType) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setNull(parameterName, sqlType); } catch (final SQLException e) { handleException(e); } }
+    public void setNull(final String parameterName, final int sqlType) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setNull(parameterName, sqlType);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setBoolean(final String parameterName, final boolean x) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setBoolean(parameterName, x); } catch (final SQLException e) { handleException(e); } }
+    public void setBoolean(final String parameterName, final boolean x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setBoolean(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setByte(final String parameterName, final byte x) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setByte(parameterName, x); } catch (final SQLException e) { handleException(e); } }
+    public void setByte(final String parameterName, final byte x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setByte(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setShort(final String parameterName, final short x) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setShort(parameterName, x); } catch (final SQLException e) { handleException(e); } }
+    public void setShort(final String parameterName, final short x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setShort(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setInt(final String parameterName, final int x) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setInt(parameterName, x); } catch (final SQLException e) { handleException(e); } }
+    public void setInt(final String parameterName, final int x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setInt(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setLong(final String parameterName, final long x) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setLong(parameterName, x); } catch (final SQLException e) { handleException(e); } }
+    public void setLong(final String parameterName, final long x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setLong(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setFloat(final String parameterName, final float x) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setFloat(parameterName, x); } catch (final SQLException e) { handleException(e); } }
+    public void setFloat(final String parameterName, final float x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setFloat(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setDouble(final String parameterName, final double x) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setDouble(parameterName, x); } catch (final SQLException e) { handleException(e); } }
+    public void setDouble(final String parameterName, final double x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setDouble(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setBigDecimal(final String parameterName, final BigDecimal x) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setBigDecimal(parameterName, x); } catch (final SQLException e) { handleException(e); } }
+    public void setBigDecimal(final String parameterName, final BigDecimal x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setBigDecimal(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setString(final String parameterName, final String x) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setString(parameterName, x); } catch (final SQLException e) { handleException(e); } }
+    public void setString(final String parameterName, final String x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setString(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setBytes(final String parameterName, final byte [] x) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setBytes(parameterName, x); } catch (final SQLException e) { handleException(e); } }
+    public void setBytes(final String parameterName, final byte[] x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setBytes(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setDate(final String parameterName, final Date x) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setDate(parameterName, x); } catch (final SQLException e) { handleException(e); } }
+    public void setDate(final String parameterName, final Date x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setDate(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setTime(final String parameterName, final Time x) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setTime(parameterName, x); } catch (final SQLException e) { handleException(e); } }
+    public void setTime(final String parameterName, final Time x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setTime(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setTimestamp(final String parameterName, final Timestamp x) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setTimestamp(parameterName, x); } catch (final SQLException e) { handleException(e); } }
+    public void setTimestamp(final String parameterName, final Timestamp x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setTimestamp(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setAsciiStream(final String parameterName, final InputStream x, final int length) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setAsciiStream(parameterName, x, length); } catch (final SQLException e) { handleException(e); } }
+    public void setAsciiStream(final String parameterName, final InputStream x, final int length) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setAsciiStream(parameterName, x, length);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setBinaryStream(final String parameterName, final InputStream x, final int length) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setBinaryStream(parameterName, x, length); } catch (final SQLException e) { handleException(e); } }
+    public void setBinaryStream(final String parameterName, final InputStream x, final int length) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setBinaryStream(parameterName, x, length);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setObject(final String parameterName, final Object x, final int targetSqlType, final int scale) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setObject(parameterName, x, targetSqlType, scale); } catch (final SQLException e) { handleException(e); } }
+    public void setObject(final String parameterName, final Object x, final int targetSqlType, final int scale)
+            throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setObject(parameterName, x, targetSqlType, scale);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setObject(final String parameterName, final Object x, final int targetSqlType) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setObject(parameterName, x, targetSqlType); } catch (final SQLException e) { handleException(e); } }
+    public void setObject(final String parameterName, final Object x, final int targetSqlType) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setObject(parameterName, x, targetSqlType);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setObject(final String parameterName, final Object x) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setObject(parameterName, x); } catch (final SQLException e) { handleException(e); } }
+    public void setObject(final String parameterName, final Object x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setObject(parameterName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setCharacterStream(final String parameterName, final Reader reader, final int length) throws SQLException
-    { checkOpen(); ((CallableStatement)getDelegate()).setCharacterStream(parameterName, reader, length); }
+    public void setCharacterStream(final String parameterName, final Reader reader, final int length)
+            throws SQLException {
+        checkOpen();
+        getDelegateCallableStatement().setCharacterStream(parameterName, reader, length);
+    }
 
     @Override
-    public void setDate(final String parameterName, final Date x, final Calendar cal) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setDate(parameterName, x, cal); } catch (final SQLException e) { handleException(e); } }
+    public void setDate(final String parameterName, final Date x, final Calendar cal) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setDate(parameterName, x, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setTime(final String parameterName, final Time x, final Calendar cal) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setTime(parameterName, x, cal); } catch (final SQLException e) { handleException(e); } }
+    public void setTime(final String parameterName, final Time x, final Calendar cal) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setTime(parameterName, x, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setTimestamp(final String parameterName, final Timestamp x, final Calendar cal) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setTimestamp(parameterName, x, cal); } catch (final SQLException e) { handleException(e); } }
+    public void setTimestamp(final String parameterName, final Timestamp x, final Calendar cal) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setTimestamp(parameterName, x, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setNull(final String parameterName, final int sqlType, final String typeName) throws SQLException
-    { checkOpen(); try { ((CallableStatement)getDelegate()).setNull(parameterName, sqlType, typeName); } catch (final SQLException e) { handleException(e); } }
+    public void setNull(final String parameterName, final int sqlType, final String typeName) throws SQLException {
+        checkOpen();
+        try {
+            getDelegateCallableStatement().setNull(parameterName, sqlType, typeName);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public String getString(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getString(parameterName); } catch (final SQLException e) { handleException(e); return null; } }
+    public String getString(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getString(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public boolean getBoolean(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBoolean(parameterName); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean getBoolean(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getBoolean(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public byte getByte(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getByte(parameterName); } catch (final SQLException e) { handleException(e); return 0; } }
+    public byte getByte(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getByte(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public short getShort(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getShort(parameterName); } catch (final SQLException e) { handleException(e); return 0; } }
+    public short getShort(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getShort(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public int getInt(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getInt(parameterName); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getInt(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getInt(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public long getLong(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getLong(parameterName); } catch (final SQLException e) { handleException(e); return 0; } }
+    public long getLong(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getLong(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public float getFloat(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getFloat(parameterName); } catch (final SQLException e) { handleException(e); return 0; } }
+    public float getFloat(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getFloat(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public double getDouble(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDouble(parameterName); } catch (final SQLException e) { handleException(e); return 0; } }
+    public double getDouble(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getDouble(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public byte[] getBytes(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBytes(parameterName); } catch (final SQLException e) { handleException(e); return null; } }
+    public byte[] getBytes(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getBytes(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Date getDate(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDate(parameterName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Date getDate(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getDate(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Time getTime(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTime(parameterName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Time getTime(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getTime(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Timestamp getTimestamp(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTimestamp(parameterName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Timestamp getTimestamp(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getTimestamp(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Object getObject(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getObject(parameterName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Object getObject(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getObject(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public BigDecimal getBigDecimal(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBigDecimal(parameterName); } catch (final SQLException e) { handleException(e); return null; } }
+    public BigDecimal getBigDecimal(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getBigDecimal(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Object getObject(final String parameterName, final Map<String,Class<?>> map) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getObject(parameterName, map); } catch (final SQLException e) { handleException(e); return null; } }
+    public Object getObject(final String parameterName, final Map<String, Class<?>> map) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getObject(parameterName, map);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Ref getRef(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getRef(parameterName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Ref getRef(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getRef(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Blob getBlob(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBlob(parameterName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Blob getBlob(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getBlob(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Clob getClob(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getClob(parameterName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Clob getClob(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getClob(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Array getArray(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getArray(parameterName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Array getArray(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getArray(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Date getDate(final String parameterName, final Calendar cal) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDate(parameterName, cal); } catch (final SQLException e) { handleException(e); return null; } }
+    public Date getDate(final String parameterName, final Calendar cal) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getDate(parameterName, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
-    @Override
-    public Time getTime(final String parameterName, final Calendar cal) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTime(parameterName, cal); } catch (final SQLException e) { handleException(e); return null; } }
+    private CallableStatement getDelegateCallableStatement() {
+        return (CallableStatement) getDelegate();
+    }
 
     @Override
-    public Timestamp getTimestamp(final String parameterName, final Calendar cal) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTimestamp(parameterName, cal); } catch (final SQLException e) { handleException(e); return null; } }
+    public Time getTime(final String parameterName, final Calendar cal) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getTime(parameterName, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public URL getURL(final String parameterName) throws SQLException
-    { checkOpen(); try { return ((CallableStatement)getDelegate()).getURL(parameterName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Timestamp getTimestamp(final String parameterName, final Calendar cal) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getTimestamp(parameterName, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
+    @Override
+    public URL getURL(final String parameterName) throws SQLException {
+        checkOpen();
+        try {
+            return getDelegateCallableStatement().getURL(parameterName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
     public RowId getRowId(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return ((CallableStatement)getDelegate()).getRowId(parameterIndex);
-        }
-        catch (final SQLException e) {
+            return getDelegateCallableStatement().getRowId(parameterIndex);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -404,9 +924,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public RowId getRowId(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return ((CallableStatement)getDelegate()).getRowId(parameterName);
-        }
-        catch (final SQLException e) {
+            return getDelegateCallableStatement().getRowId(parameterName);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -416,9 +935,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public void setRowId(final String parameterName, final RowId value) throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setRowId(parameterName, value);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setRowId(parameterName, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -427,20 +945,19 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public void setNString(final String parameterName, final String value) throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setNString(parameterName, value);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setNString(parameterName, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setNCharacterStream(final String parameterName, final Reader reader, final long length) throws SQLException {
+    public void setNCharacterStream(final String parameterName, final Reader reader, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setNCharacterStream(parameterName, reader, length);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setNCharacterStream(parameterName, reader, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -449,9 +966,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public void setNClob(final String parameterName, final NClob value) throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setNClob(parameterName, value);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setNClob(parameterName, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -460,20 +976,19 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public void setClob(final String parameterName, final Reader reader, final long length) throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setClob(parameterName, reader, length);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setClob(parameterName, reader, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setBlob(final String parameterName, final InputStream inputStream, final long length) throws SQLException {
+    public void setBlob(final String parameterName, final InputStream inputStream, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setBlob(parameterName, inputStream, length);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setBlob(parameterName, inputStream, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -482,9 +997,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public void setNClob(final String parameterName, final Reader reader, final long length) throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setNClob(parameterName, reader, length);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setNClob(parameterName, reader, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -493,9 +1007,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public NClob getNClob(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return ((CallableStatement)getDelegate()).getNClob(parameterIndex);
-        }
-        catch (final SQLException e) {
+            return getDelegateCallableStatement().getNClob(parameterIndex);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -505,9 +1018,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public NClob getNClob(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return ((CallableStatement)getDelegate()).getNClob(parameterName);
-        }
-        catch (final SQLException e) {
+            return getDelegateCallableStatement().getNClob(parameterName);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -517,9 +1029,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public void setSQLXML(final String parameterName, final SQLXML value) throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setSQLXML(parameterName, value);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setSQLXML(parameterName, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -528,9 +1039,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public SQLXML getSQLXML(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return ((CallableStatement)getDelegate()).getSQLXML(parameterIndex);
-        }
-        catch (final SQLException e) {
+            return getDelegateCallableStatement().getSQLXML(parameterIndex);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -540,9 +1050,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public SQLXML getSQLXML(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return ((CallableStatement)getDelegate()).getSQLXML(parameterName);
-        }
-        catch (final SQLException e) {
+            return getDelegateCallableStatement().getSQLXML(parameterName);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -552,9 +1061,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public String getNString(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return ((CallableStatement)getDelegate()).getNString(parameterIndex);
-        }
-        catch (final SQLException e) {
+            return getDelegateCallableStatement().getNString(parameterIndex);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -564,9 +1072,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public String getNString(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return ((CallableStatement)getDelegate()).getNString(parameterName);
-        }
-        catch (final SQLException e) {
+            return getDelegateCallableStatement().getNString(parameterName);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -576,9 +1083,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public Reader getNCharacterStream(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return ((CallableStatement)getDelegate()).getNCharacterStream(parameterIndex);
-        }
-        catch (final SQLException e) {
+            return getDelegateCallableStatement().getNCharacterStream(parameterIndex);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -588,9 +1094,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public Reader getNCharacterStream(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return ((CallableStatement)getDelegate()).getNCharacterStream(parameterName);
-        }
-        catch (final SQLException e) {
+            return getDelegateCallableStatement().getNCharacterStream(parameterName);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -600,9 +1105,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public Reader getCharacterStream(final int parameterIndex) throws SQLException {
         checkOpen();
         try {
-            return ((CallableStatement)getDelegate()).getCharacterStream(parameterIndex);
-        }
-        catch (final SQLException e) {
+            return getDelegateCallableStatement().getCharacterStream(parameterIndex);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -612,9 +1116,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public Reader getCharacterStream(final String parameterName) throws SQLException {
         checkOpen();
         try {
-            return ((CallableStatement)getDelegate()).getCharacterStream(parameterName);
-        }
-        catch (final SQLException e) {
+            return getDelegateCallableStatement().getCharacterStream(parameterName);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -624,9 +1127,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public void setBlob(final String parameterName, final Blob blob) throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setBlob(parameterName, blob);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setBlob(parameterName, blob);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -635,42 +1137,41 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public void setClob(final String parameterName, final Clob clob) throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setClob(parameterName, clob);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setClob(parameterName, clob);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setAsciiStream(final String parameterName, final InputStream inputStream, final long length) throws SQLException {
+    public void setAsciiStream(final String parameterName, final InputStream inputStream, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setAsciiStream(parameterName, inputStream, length);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setAsciiStream(parameterName, inputStream, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setBinaryStream(final String parameterName, final InputStream inputStream, final long length) throws SQLException {
+    public void setBinaryStream(final String parameterName, final InputStream inputStream, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setBinaryStream(parameterName, inputStream, length);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setBinaryStream(parameterName, inputStream, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setCharacterStream(final String parameterName, final Reader reader, final long length) throws SQLException {
+    public void setCharacterStream(final String parameterName, final Reader reader, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setCharacterStream(parameterName, reader, length);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setCharacterStream(parameterName, reader, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -679,9 +1180,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public void setAsciiStream(final String parameterName, final InputStream inputStream) throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setAsciiStream(parameterName, inputStream);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setAsciiStream(parameterName, inputStream);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -690,9 +1190,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public void setBinaryStream(final String parameterName, final InputStream inputStream) throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setBinaryStream(parameterName, inputStream);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setBinaryStream(parameterName, inputStream);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -701,9 +1200,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public void setCharacterStream(final String parameterName, final Reader reader) throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setCharacterStream(parameterName, reader);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setCharacterStream(parameterName, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -712,9 +1210,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public void setNCharacterStream(final String parameterName, final Reader reader) throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setNCharacterStream(parameterName, reader);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setNCharacterStream(parameterName, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -723,9 +1220,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public void setClob(final String parameterName, final Reader reader) throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setClob(parameterName, reader);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setClob(parameterName, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -734,9 +1230,8 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public void setBlob(final String parameterName, final InputStream inputStream) throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setBlob(parameterName, inputStream);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setBlob(parameterName, inputStream);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -745,38 +1240,32 @@ public class DelegatingCallableStatement extends DelegatingPreparedStatement
     public void setNClob(final String parameterName, final Reader reader) throws SQLException {
         checkOpen();
         try {
-            ((CallableStatement)getDelegate()).setNClob(parameterName, reader);
-        }
-        catch (final SQLException e) {
+            getDelegateCallableStatement().setNClob(parameterName, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public <T> T getObject(final int parameterIndex, final Class<T> type)
-            throws SQLException {
+    public <T> T getObject(final int parameterIndex, final Class<T> type) throws SQLException {
         checkOpen();
         try {
-            return ((CallableStatement)getDelegate()).getObject(parameterIndex, type);
-}
-        catch (final SQLException e) {
+            return getDelegateCallableStatement().getObject(parameterIndex, type);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
     @Override
-    public <T> T getObject(final String parameterName, final Class<T> type)
-            throws SQLException {
+    public <T> T getObject(final String parameterName, final Class<T> type) throws SQLException {
         checkOpen();
         try {
-            return ((CallableStatement)getDelegate()).getObject(parameterName, type);
-        }
-        catch (final SQLException e) {
+            return getDelegateCallableStatement().getObject(parameterName, type);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
-
 }

==================================================
DelegatingDatabaseMetaData.java
index 3a19a7d594..735d267b5c 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DelegatingConnection.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingConnection.java
@@ -44,57 +44,48 @@ import java.util.concurrent.Executor;
 /**
  * A base delegating implementation of {@link Connection}.
  * <p>
- * All of the methods from the {@link Connection} interface
- * simply check to see that the {@link Connection} is active,
- * and call the corresponding method on the "delegate"
- * provided in my constructor.
+ * All of the methods from the {@link Connection} interface simply check to see that the {@link Connection} is active,
+ * and call the corresponding method on the "delegate" provided in my constructor.
+ * </p>
  * <p>
- * Extends AbandonedTrace to implement Connection tracking and
- * logging of code which created the Connection. Tracking the
- * Connection ensures that the AbandonedObjectPool can close
- * this connection and recycle it if its pool of connections
- * is nearing exhaustion and this connection's last usage is
- * older than the removeAbandonedTimeout.
+ * Extends AbandonedTrace to implement Connection tracking and logging of code which created the Connection. Tracking
+ * the Connection ensures that the AbandonedObjectPool can close this connection and recycle it if its pool of
+ * connections is nearing exhaustion and this connection's last usage is older than the removeAbandonedTimeout.
+ * </p>
  *
- * @param <C> the Connection type
+ * @param <C>
+ *            the Connection type
  *
- * @author Rodney Waldhoff
- * @author Glenn L. Nielsen
- * @author James House
- * @author Dirk Verbeeck
  * @since 2.0
  */
-public class DelegatingConnection<C extends Connection> extends AbandonedTrace
-        implements Connection {
+public class DelegatingConnection<C extends Connection> extends AbandonedTrace implements Connection {
 
-    private static final Map<String, ClientInfoStatus> EMPTY_FAILED_PROPERTIES =
-        Collections.<String, ClientInfoStatus>emptyMap();
+    private static final Map<String, ClientInfoStatus> EMPTY_FAILED_PROPERTIES = Collections
+            .<String, ClientInfoStatus>emptyMap();
 
     /** My delegate {@link Connection}. */
-    private volatile C _conn = null;
+    private volatile C connection;
 
-    private volatile boolean _closed = false;
+    private volatile boolean closed;
 
-    private boolean _cacheState = true;
-    private Boolean _autoCommitCached = null;
-    private Boolean _readOnlyCached = null;
-    private Integer defaultQueryTimeout = null;
+    private boolean cacheState = true;
+    private Boolean autoCommitCached;
+    private Boolean readOnlyCached;
+    private Integer defaultQueryTimeoutSeconds;
 
     /**
-     * Create a wrapper for the Connection which traces this
-     * Connection in the AbandonedObjectPool.
+     * Creates a wrapper for the Connection which traces this Connection in the AbandonedObjectPool.
      *
-     * @param c the {@link Connection} to delegate all calls to.
+     * @param c
+     *            the {@link Connection} to delegate all calls to.
      */
     public DelegatingConnection(final C c) {
         super();
-        _conn = c;
+        connection = c;
     }
 
-
     /**
-     * Returns a string representation of the metadata associated with
-     * the innermost delegate connection.
+     * Returns a string representation of the metadata associated with the innermost delegate connection.
      */
     @Override
     public String toString() {
@@ -105,8 +96,7 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
             try {
                 if (c.isClosed()) {
                     s = "connection is closed";
-                }
-                else {
+                } else {
                     final StringBuffer sb = new StringBuffer();
                     sb.append(hashCode());
                     final DatabaseMetaData meta = c.getMetaData();
@@ -120,8 +110,7 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
                         s = sb.toString();
                     }
                 }
-            }
-            catch (final SQLException ex) {
+            } catch (final SQLException ex) {
                 // Ignore
             }
         }
@@ -135,6 +124,7 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
 
     /**
      * Returns my underlying {@link Connection}.
+     *
      * @return my underlying {@link Connection}.
      */
     public C getDelegate() {
@@ -142,13 +132,14 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     }
 
     protected final C getDelegateInternal() {
-        return _conn;
+        return connection;
     }
 
     /**
      * Compares innermost delegate to the given connection.
      *
-     * @param c connection to compare innermost delegate with
+     * @param c
+     *            connection to compare innermost delegate with
      * @return true if innermost delegate equals <code>c</code>
      */
     public boolean innermostDelegateEquals(final Connection c) {
@@ -159,39 +150,35 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
         return innerCon.equals(c);
     }
 
-
     /**
-     * If my underlying {@link Connection} is not a
-     * {@code DelegatingConnection}, returns it,
-     * otherwise recursively invokes this method on
-     * my delegate.
+     * If my underlying {@link Connection} is not a {@code DelegatingConnection}, returns it, otherwise recursively
+     * invokes this method on my delegate.
      * <p>
-     * Hence this method will return the first
-     * delegate that is not a {@code DelegatingConnection},
-     * or {@code null} when no non-{@code DelegatingConnection}
-     * delegate can be found by traversing this chain.
+     * Hence this method will return the first delegate that is not a {@code DelegatingConnection}, or {@code null} when
+     * no non-{@code DelegatingConnection} delegate can be found by traversing this chain.
+     * </p>
      * <p>
-     * This method is useful when you may have nested
-     * {@code DelegatingConnection}s, and you want to make
-     * sure to obtain a "genuine" {@link Connection}.
-     * @return the connection
+     * This method is useful when you may have nested {@code DelegatingConnection}s, and you want to make sure to obtain
+     * a "genuine" {@link Connection}.
+     * </p>
+     *
+     * @return innermost delegate.
      */
     public Connection getInnermostDelegate() {
         return getInnermostDelegateInternal();
     }
 
-
     /**
-     * Although this method is public, it is part of the internal API and should
-     * not be used by clients. The signature of this method may change at any
-     * time including in ways that break backwards compatibility.
-     * @return the connection
+     * Although this method is public, it is part of the internal API and should not be used by clients. The signature
+     * of this method may change at any time including in ways that break backwards compatibility.
+     *
+     * @return innermost delegate.
      */
     public final Connection getInnermostDelegateInternal() {
-        Connection c = _conn;
-        while(c != null && c instanceof DelegatingConnection) {
-            c = ((DelegatingConnection<?>)c).getDelegateInternal();
-            if(this == c) {
+        Connection c = connection;
+        while (c != null && c instanceof DelegatingConnection) {
+            c = ((DelegatingConnection<?>) c).getDelegateInternal();
+            if (this == c) {
                 return null;
             }
         }
@@ -200,50 +187,50 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
 
     /**
      * Sets my delegate.
-     * @param c The connection
+     *
+     * @param connection
+     *            my delegate.
      */
-    public void setDelegate(final C c) {
-        _conn = c;
+    public void setDelegate(final C connection) {
+        this.connection = connection;
     }
 
     /**
-     * Closes the underlying connection, and close any Statements that were not
-     * explicitly closed. Sub-classes that override this method must:
+     * Closes the underlying connection, and close any Statements that were not explicitly closed. Sub-classes that
+     * override this method must:
      * <ol>
      * <li>Call passivate()</li>
-     * <li>Call close (or the equivalent appropriate action) on the wrapped
-     *     connection</li>
+     * <li>Call close (or the equivalent appropriate action) on the wrapped connection</li>
      * <li>Set _closed to <code>false</code></li>
      * </ol>
-     * @throws SQLException Error closing connection
      */
     @Override
     public void close() throws SQLException {
-        if (!_closed) {
+        if (!closed) {
             closeInternal();
         }
     }
 
     protected boolean isClosedInternal() {
-        return _closed;
+        return closed;
     }
 
     protected void setClosedInternal(final boolean closed) {
-        this._closed = closed;
+        this.closed = closed;
     }
 
     protected final void closeInternal() throws SQLException {
         try {
             passivate();
         } finally {
-            if (_conn != null) {
+            if (connection != null) {
                 try {
-                    _conn.close();
+                    connection.close();
                 } finally {
-                    _closed = true;
+                    closed = true;
                 }
             } else {
-                _closed = true;
+                closed = true;
             }
         }
     }
@@ -253,9 +240,8 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     }
 
     private void initializeStatement(final DelegatingStatement ds) throws SQLException {
-        if (defaultQueryTimeout != null &&
-                defaultQueryTimeout.intValue() != ds.getQueryTimeout()) {
-            ds.setQueryTimeout(defaultQueryTimeout.intValue());
+        if (defaultQueryTimeoutSeconds != null && defaultQueryTimeoutSeconds.intValue() != ds.getQueryTimeout()) {
+            ds.setQueryTimeout(defaultQueryTimeoutSeconds.intValue());
         }
     }
 
@@ -263,28 +249,24 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public Statement createStatement() throws SQLException {
         checkOpen();
         try {
-            final DelegatingStatement ds =
-                    new DelegatingStatement(this, _conn.createStatement());
+            final DelegatingStatement ds = new DelegatingStatement(this, connection.createStatement());
             initializeStatement(ds);
             return ds;
-        }
-        catch (final SQLException e) {
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
     @Override
-    public Statement createStatement(final int resultSetType,
-                                     final int resultSetConcurrency) throws SQLException {
+    public Statement createStatement(final int resultSetType, final int resultSetConcurrency) throws SQLException {
         checkOpen();
         try {
-            final DelegatingStatement ds = new DelegatingStatement(
-                    this, _conn.createStatement(resultSetType,resultSetConcurrency));
+            final DelegatingStatement ds = new DelegatingStatement(this,
+                    connection.createStatement(resultSetType, resultSetConcurrency));
             initializeStatement(ds);
             return ds;
-        }
-        catch (final SQLException e) {
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -294,29 +276,26 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public PreparedStatement prepareStatement(final String sql) throws SQLException {
         checkOpen();
         try {
-            final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(
-                    this, _conn.prepareStatement(sql));
+            final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(this,
+                    connection.prepareStatement(sql));
             initializeStatement(dps);
             return dps;
-        }
-        catch (final SQLException e) {
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
     @Override
-    public PreparedStatement prepareStatement(final String sql,
-                                              final int resultSetType,
-                                              final int resultSetConcurrency) throws SQLException {
+    public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency)
+            throws SQLException {
         checkOpen();
         try {
-            final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(
-                    this, _conn.prepareStatement(sql,resultSetType,resultSetConcurrency));
+            final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(this,
+                    connection.prepareStatement(sql, resultSetType, resultSetConcurrency));
             initializeStatement(dps);
             return dps;
-        }
-        catch (final SQLException e) {
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -326,221 +305,205 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public CallableStatement prepareCall(final String sql) throws SQLException {
         checkOpen();
         try {
-            final DelegatingCallableStatement dcs =
-                    new DelegatingCallableStatement(this, _conn.prepareCall(sql));
+            final DelegatingCallableStatement dcs = new DelegatingCallableStatement(this, connection.prepareCall(sql));
             initializeStatement(dcs);
             return dcs;
-        }
-        catch (final SQLException e) {
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
     @Override
-    public CallableStatement prepareCall(final String sql,
-                                         final int resultSetType,
-                                         final int resultSetConcurrency) throws SQLException {
+    public CallableStatement prepareCall(final String sql, final int resultSetType, final int resultSetConcurrency)
+            throws SQLException {
         checkOpen();
         try {
-            final DelegatingCallableStatement dcs = new DelegatingCallableStatement(
-                    this, _conn.prepareCall(sql, resultSetType,resultSetConcurrency));
+            final DelegatingCallableStatement dcs = new DelegatingCallableStatement(this,
+                    connection.prepareCall(sql, resultSetType, resultSetConcurrency));
             initializeStatement(dcs);
             return dcs;
-        }
-        catch (final SQLException e) {
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
-
     @Override
     public void clearWarnings() throws SQLException {
         checkOpen();
         try {
-            _conn.clearWarnings();
+            connection.clearWarnings();
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
-
     @Override
     public void commit() throws SQLException {
         checkOpen();
         try {
-            _conn.commit();
+            connection.commit();
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
-
     /**
      * Returns the state caching flag.
      *
-     * @return  the state caching flag
+     * @return the state caching flag
      */
     public boolean getCacheState() {
-        return _cacheState;
+        return cacheState;
     }
 
     @Override
     public boolean getAutoCommit() throws SQLException {
         checkOpen();
-        if (_cacheState && _autoCommitCached != null) {
-            return _autoCommitCached.booleanValue();
+        if (cacheState && autoCommitCached != null) {
+            return autoCommitCached.booleanValue();
         }
         try {
-            _autoCommitCached = Boolean.valueOf(_conn.getAutoCommit());
-            return _autoCommitCached.booleanValue();
+            autoCommitCached = Boolean.valueOf(connection.getAutoCommit());
+            return autoCommitCached.booleanValue();
         } catch (final SQLException e) {
             handleException(e);
             return false;
         }
     }
 
-
     @Override
     public String getCatalog() throws SQLException {
         checkOpen();
         try {
-            return _conn.getCatalog();
+            return connection.getCatalog();
         } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
-
     @Override
     public DatabaseMetaData getMetaData() throws SQLException {
         checkOpen();
         try {
-            return new DelegatingDatabaseMetaData(this, _conn.getMetaData());
+            return new DelegatingDatabaseMetaData(this, connection.getMetaData());
         } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
-
     @Override
     public int getTransactionIsolation() throws SQLException {
         checkOpen();
         try {
-            return _conn.getTransactionIsolation();
+            return connection.getTransactionIsolation();
         } catch (final SQLException e) {
             handleException(e);
             return -1;
         }
     }
 
-
     @Override
-    public Map<String,Class<?>> getTypeMap() throws SQLException {
+    public Map<String, Class<?>> getTypeMap() throws SQLException {
         checkOpen();
         try {
-            return _conn.getTypeMap();
+            return connection.getTypeMap();
         } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
-
     @Override
     public SQLWarning getWarnings() throws SQLException {
         checkOpen();
         try {
-            return _conn.getWarnings();
+            return connection.getWarnings();
         } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
-
     @Override
     public boolean isReadOnly() throws SQLException {
         checkOpen();
-        if (_cacheState && _readOnlyCached != null) {
-            return _readOnlyCached.booleanValue();
+        if (cacheState && readOnlyCached != null) {
+            return readOnlyCached.booleanValue();
         }
         try {
-            _readOnlyCached = Boolean.valueOf(_conn.isReadOnly());
-            return _readOnlyCached.booleanValue();
+            readOnlyCached = Boolean.valueOf(connection.isReadOnly());
+            return readOnlyCached.booleanValue();
         } catch (final SQLException e) {
             handleException(e);
             return false;
         }
     }
 
-
     @Override
     public String nativeSQL(final String sql) throws SQLException {
         checkOpen();
         try {
-            return _conn.nativeSQL(sql);
+            return connection.nativeSQL(sql);
         } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
-
     @Override
     public void rollback() throws SQLException {
         checkOpen();
         try {
-            _conn.rollback();
+            connection.rollback();
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
-
     /**
-     * Obtain the default query timeout that will be used for {@link Statement}s
-     * created from this connection. <code>null</code> means that the driver
-     * default will be used.
-     * @return the timeout
+     * Gets the default query timeout that will be used for {@link Statement}s created from this connection.
+     * <code>null</code> means that the driver default will be used.
+     *
+     * @return query timeout limit in seconds; zero means there is no limit.
      */
     public Integer getDefaultQueryTimeout() {
-        return defaultQueryTimeout;
+        return defaultQueryTimeoutSeconds;
     }
 
-
     /**
-     * Set the default query timeout that will be used for {@link Statement}s
-     * created from this connection. <code>null</code> means that the driver
-     * default will be used.
-     * @param defaultQueryTimeout The timeout value
+     * Sets the default query timeout that will be used for {@link Statement}s created from this connection.
+     * <code>null</code> means that the driver default will be used.
+     *
+     * @param defaultQueryTimeoutSeconds
+     *            the new query timeout limit in seconds; zero means there is no limit
      */
-    public void setDefaultQueryTimeout(final Integer defaultQueryTimeout) {
-        this.defaultQueryTimeout = defaultQueryTimeout;
+    public void setDefaultQueryTimeout(final Integer defaultQueryTimeoutSeconds) {
+        this.defaultQueryTimeoutSeconds = defaultQueryTimeoutSeconds;
     }
 
-
     /**
      * Sets the state caching flag.
      *
-     * @param cacheState    The new value for the state caching flag
+     * @param cacheState
+     *            The new value for the state caching flag
      */
     public void setCacheState(final boolean cacheState) {
-        this._cacheState = cacheState;
+        this.cacheState = cacheState;
     }
 
     /**
-     * Can be used to clear cached state when it is known that the underlying
-     * connection may have been accessed directly.
+     * Can be used to clear cached state when it is known that the underlying connection may have been accessed
+     * directly.
      */
     public void clearCachedState() {
-        _autoCommitCached = null;
-        _readOnlyCached = null;
-        if (_conn instanceof DelegatingConnection) {
-            ((DelegatingConnection<?>)_conn).clearCachedState();
+        autoCommitCached = null;
+        readOnlyCached = null;
+        if (connection instanceof DelegatingConnection) {
+            ((DelegatingConnection<?>) connection).clearCachedState();
         }
     }
 
@@ -548,51 +511,55 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public void setAutoCommit(final boolean autoCommit) throws SQLException {
         checkOpen();
         try {
-            _conn.setAutoCommit(autoCommit);
-            if (_cacheState) {
-                _autoCommitCached = Boolean.valueOf(autoCommit);
+            connection.setAutoCommit(autoCommit);
+            if (cacheState) {
+                autoCommitCached = Boolean.valueOf(autoCommit);
             }
         } catch (final SQLException e) {
-            _autoCommitCached = null;
+            autoCommitCached = null;
             handleException(e);
         }
     }
 
     @Override
-    public void setCatalog(final String catalog) throws SQLException
-    { checkOpen(); try { _conn.setCatalog(catalog); } catch (final SQLException e) { handleException(e); } }
+    public void setCatalog(final String catalog) throws SQLException {
+        checkOpen();
+        try {
+            connection.setCatalog(catalog);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
     public void setReadOnly(final boolean readOnly) throws SQLException {
         checkOpen();
         try {
-            _conn.setReadOnly(readOnly);
-            if (_cacheState) {
-                _readOnlyCached = Boolean.valueOf(readOnly);
+            connection.setReadOnly(readOnly);
+            if (cacheState) {
+                readOnlyCached = Boolean.valueOf(readOnly);
             }
         } catch (final SQLException e) {
-            _readOnlyCached = null;
+            readOnlyCached = null;
             handleException(e);
         }
     }
 
-
     @Override
     public void setTransactionIsolation(final int level) throws SQLException {
         checkOpen();
         try {
-            _conn.setTransactionIsolation(level);
+            connection.setTransactionIsolation(level);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
-
     @Override
-    public void setTypeMap(final Map<String,Class<?>> map) throws SQLException {
+    public void setTypeMap(final Map<String, Class<?>> map) throws SQLException {
         checkOpen();
         try {
-            _conn.setTypeMap(map);
+            connection.setTypeMap(map);
         } catch (final SQLException e) {
             handleException(e);
         }
@@ -600,31 +567,29 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
 
     @Override
     public boolean isClosed() throws SQLException {
-        return _closed || _conn == null || _conn.isClosed();
+        return closed || connection == null || connection.isClosed();
     }
 
     protected void checkOpen() throws SQLException {
-        if(_closed) {
-            if (null != _conn) {
+        if (closed) {
+            if (null != connection) {
                 String label = "";
                 try {
-                    label = _conn.toString();
+                    label = connection.toString();
                 } catch (final Exception ex) {
                     // ignore, leave label empty
                 }
-                throw new SQLException
-                    ("Connection " + label + " is closed.");
+                throw new SQLException("Connection " + label + " is closed.");
             }
-            throw new SQLException
-                ("Connection is null.");
+            throw new SQLException("Connection is null.");
         }
     }
 
     protected void activate() {
-        _closed = false;
+        closed = false;
         setLastUsed();
-        if(_conn instanceof DelegatingConnection) {
-            ((DelegatingConnection<?>)_conn).activate();
+        if (connection instanceof DelegatingConnection) {
+            ((DelegatingConnection<?>) connection).activate();
         }
     }
 
@@ -633,7 +598,7 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
         // Statement's when it is closed.
         // DBCP-288. Not all the traced objects will be statements
         final List<AbandonedTrace> traces = getTrace();
-        if(traces != null && traces.size() > 0) {
+        if (traces != null && traces.size() > 0) {
             final Iterator<AbandonedTrace> traceIter = traces.iterator();
             while (traceIter.hasNext()) {
                 final Object trace = traceIter.next();
@@ -650,126 +615,109 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
         setLastUsed(0);
     }
 
-
     @Override
     public int getHoldability() throws SQLException {
         checkOpen();
         try {
-            return _conn.getHoldability();
+            return connection.getHoldability();
         } catch (final SQLException e) {
             handleException(e);
             return 0;
         }
     }
 
-
     @Override
     public void setHoldability(final int holdability) throws SQLException {
         checkOpen();
         try {
-            _conn.setHoldability(holdability);
+            connection.setHoldability(holdability);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
-
     @Override
     public Savepoint setSavepoint() throws SQLException {
         checkOpen();
         try {
-            return _conn.setSavepoint();
+            return connection.setSavepoint();
         } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
-
     @Override
     public Savepoint setSavepoint(final String name) throws SQLException {
         checkOpen();
         try {
-            return _conn.setSavepoint(name);
+            return connection.setSavepoint(name);
         } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
-
     @Override
     public void rollback(final Savepoint savepoint) throws SQLException {
         checkOpen();
         try {
-            _conn.rollback(savepoint);
+            connection.rollback(savepoint);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
-
     @Override
-    public void releaseSavepoint(final Savepoint savepoint)
-            throws SQLException {
+    public void releaseSavepoint(final Savepoint savepoint) throws SQLException {
         checkOpen();
         try {
-            _conn.releaseSavepoint(savepoint);
+            connection.releaseSavepoint(savepoint);
         } catch (final SQLException e) {
             handleException(e);
         }
     }
 
-
     @Override
-    public Statement createStatement(final int resultSetType,
-                                     final int resultSetConcurrency,
-                                     final int resultSetHoldability) throws SQLException {
+    public Statement createStatement(final int resultSetType, final int resultSetConcurrency,
+            final int resultSetHoldability) throws SQLException {
         checkOpen();
         try {
             final DelegatingStatement ds = new DelegatingStatement(this,
-                    _conn.createStatement(resultSetType, resultSetConcurrency,
-                            resultSetHoldability));
+                    connection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability));
             initializeStatement(ds);
             return ds;
-        }
-        catch (final SQLException e) {
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
     @Override
-    public PreparedStatement prepareStatement(final String sql, final int resultSetType,
-                                              final int resultSetConcurrency,
-                                              final int resultSetHoldability) throws SQLException {
+    public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency,
+            final int resultSetHoldability) throws SQLException {
         checkOpen();
         try {
-            final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(
-                    this, _conn.prepareStatement(sql, resultSetType,
-                            resultSetConcurrency, resultSetHoldability));
+            final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(this,
+                    connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
             initializeStatement(dps);
             return dps;
-        }
-        catch (final SQLException e) {
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
     @Override
-    public CallableStatement prepareCall(final String sql, final int resultSetType,
-                                         final int resultSetConcurrency,
-                                         final int resultSetHoldability) throws SQLException {
+    public CallableStatement prepareCall(final String sql, final int resultSetType, final int resultSetConcurrency,
+            final int resultSetHoldability) throws SQLException {
         checkOpen();
         try {
-            final DelegatingCallableStatement dcs = new DelegatingCallableStatement(
-                    this, _conn.prepareCall(sql, resultSetType,
-                            resultSetConcurrency, resultSetHoldability));
+            final DelegatingCallableStatement dcs = new DelegatingCallableStatement(this,
+                    connection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
             initializeStatement(dcs);
             return dcs;
-        }
-        catch (final SQLException e) {
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -779,12 +727,11 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
         checkOpen();
         try {
-            final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(
-                    this, _conn.prepareStatement(sql, autoGeneratedKeys));
+            final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(this,
+                    connection.prepareStatement(sql, autoGeneratedKeys));
             initializeStatement(dps);
             return dps;
-        }
-        catch (final SQLException e) {
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -794,12 +741,11 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public PreparedStatement prepareStatement(final String sql, final int columnIndexes[]) throws SQLException {
         checkOpen();
         try {
-            final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(
-                    this, _conn.prepareStatement(sql, columnIndexes));
+            final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(this,
+                    connection.prepareStatement(sql, columnIndexes));
             initializeStatement(dps);
             return dps;
-        }
-        catch (final SQLException e) {
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -809,26 +755,24 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public PreparedStatement prepareStatement(final String sql, final String columnNames[]) throws SQLException {
         checkOpen();
         try {
-            final DelegatingPreparedStatement dps =  new DelegatingPreparedStatement(
-                    this, _conn.prepareStatement(sql, columnNames));
+            final DelegatingPreparedStatement dps = new DelegatingPreparedStatement(this,
+                    connection.prepareStatement(sql, columnNames));
             initializeStatement(dps);
             return dps;
-        }
-        catch (final SQLException e) {
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
-
     @Override
     public boolean isWrapperFor(final Class<?> iface) throws SQLException {
         if (iface.isAssignableFrom(getClass())) {
             return true;
-        } else if (iface.isAssignableFrom(_conn.getClass())) {
+        } else if (iface.isAssignableFrom(connection.getClass())) {
             return true;
         } else {
-            return _conn.isWrapperFor(iface);
+            return connection.isWrapperFor(iface);
         }
     }
 
@@ -836,10 +780,10 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public <T> T unwrap(final Class<T> iface) throws SQLException {
         if (iface.isAssignableFrom(getClass())) {
             return iface.cast(this);
-        } else if (iface.isAssignableFrom(_conn.getClass())) {
-            return iface.cast(_conn);
+        } else if (iface.isAssignableFrom(connection.getClass())) {
+            return iface.cast(connection);
         } else {
-            return _conn.unwrap(iface);
+            return connection.unwrap(iface);
         }
     }
 
@@ -847,9 +791,8 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public Array createArrayOf(final String typeName, final Object[] elements) throws SQLException {
         checkOpen();
         try {
-            return _conn.createArrayOf(typeName, elements);
-        }
-        catch (final SQLException e) {
+            return connection.createArrayOf(typeName, elements);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -859,9 +802,8 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public Blob createBlob() throws SQLException {
         checkOpen();
         try {
-            return _conn.createBlob();
-        }
-        catch (final SQLException e) {
+            return connection.createBlob();
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -871,9 +813,8 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public Clob createClob() throws SQLException {
         checkOpen();
         try {
-            return _conn.createClob();
-        }
-        catch (final SQLException e) {
+            return connection.createClob();
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -883,9 +824,8 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public NClob createNClob() throws SQLException {
         checkOpen();
         try {
-            return _conn.createNClob();
-        }
-        catch (final SQLException e) {
+            return connection.createNClob();
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -895,9 +835,8 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public SQLXML createSQLXML() throws SQLException {
         checkOpen();
         try {
-            return _conn.createSQLXML();
-        }
-        catch (final SQLException e) {
+            return connection.createSQLXML();
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -907,23 +846,21 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public Struct createStruct(final String typeName, final Object[] attributes) throws SQLException {
         checkOpen();
         try {
-            return _conn.createStruct(typeName, attributes);
-        }
-        catch (final SQLException e) {
+            return connection.createStruct(typeName, attributes);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
     @Override
-    public boolean isValid(final int timeout) throws SQLException {
+    public boolean isValid(final int timeoutSeconds) throws SQLException {
         if (isClosed()) {
             return false;
         }
         try {
-            return _conn.isValid(timeout);
-        }
-        catch (final SQLException e) {
+            return connection.isValid(timeoutSeconds);
+        } catch (final SQLException e) {
             handleException(e);
             return false;
         }
@@ -933,12 +870,10 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public void setClientInfo(final String name, final String value) throws SQLClientInfoException {
         try {
             checkOpen();
-            _conn.setClientInfo(name, value);
-        }
-        catch (final SQLClientInfoException e) {
+            connection.setClientInfo(name, value);
+        } catch (final SQLClientInfoException e) {
             throw e;
-        }
-        catch (final SQLException e) {
+        } catch (final SQLException e) {
             throw new SQLClientInfoException("Connection is closed.", EMPTY_FAILED_PROPERTIES, e);
         }
     }
@@ -947,12 +882,10 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public void setClientInfo(final Properties properties) throws SQLClientInfoException {
         try {
             checkOpen();
-            _conn.setClientInfo(properties);
-        }
-        catch (final SQLClientInfoException e) {
+            connection.setClientInfo(properties);
+        } catch (final SQLClientInfoException e) {
             throw e;
-        }
-        catch (final SQLException e) {
+        } catch (final SQLException e) {
             throw new SQLClientInfoException("Connection is closed.", EMPTY_FAILED_PROPERTIES, e);
         }
     }
@@ -961,9 +894,8 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public Properties getClientInfo() throws SQLException {
         checkOpen();
         try {
-            return _conn.getClientInfo();
-        }
-        catch (final SQLException e) {
+            return connection.getClientInfo();
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -973,9 +905,8 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public String getClientInfo(final String name) throws SQLException {
         checkOpen();
         try {
-            return _conn.getClientInfo(name);
-        }
-        catch (final SQLException e) {
+            return connection.getClientInfo(name);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -985,9 +916,8 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public void setSchema(final String schema) throws SQLException {
         checkOpen();
         try {
-            _conn.setSchema(schema);
-        }
-        catch (final SQLException e) {
+            connection.setSchema(schema);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -996,9 +926,8 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public String getSchema() throws SQLException {
         checkOpen();
         try {
-            return _conn.getSchema();
-        }
-        catch (final SQLException e) {
+            return connection.getSchema();
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -1008,21 +937,18 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public void abort(final Executor executor) throws SQLException {
         checkOpen();
         try {
-            _conn.abort(executor);
-        }
-        catch (final SQLException e) {
+            connection.abort(executor);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setNetworkTimeout(final Executor executor, final int milliseconds)
-            throws SQLException {
+    public void setNetworkTimeout(final Executor executor, final int milliseconds) throws SQLException {
         checkOpen();
         try {
-            _conn.setNetworkTimeout(executor, milliseconds);
-        }
-        catch (final SQLException e) {
+            connection.setNetworkTimeout(executor, milliseconds);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1031,9 +957,8 @@ public class DelegatingConnection<C extends Connection> extends AbandonedTrace
     public int getNetworkTimeout() throws SQLException {
         checkOpen();
         try {
-            return _conn.getNetworkTimeout();
-        }
-        catch (final SQLException e) {
+            return connection.getNetworkTimeout();
+        } catch (final SQLException e) {
             handleException(e);
             return 0;
         }

==================================================
DelegatingPreparedStatement.java
index 5723d49276..d58711d6a0 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DelegatingDatabaseMetaData.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingDatabaseMetaData.java
@@ -23,54 +23,67 @@ import java.sql.RowIdLifetime;
 import java.sql.SQLException;
 
 /**
- * <p>A base delegating implementation of {@link DatabaseMetaData}.</p>
+ * <p>
+ * A base delegating implementation of {@link DatabaseMetaData}.
+ * </p>
+ * <p>
+ * Methods that create {@link ResultSet} objects are wrapped to create {@link DelegatingResultSet} objects and the
+ * remaining methods simply call the corresponding method on the "delegate" provided in the constructor.
+ * </p>
  *
- * <p>Methods that create {@link ResultSet} objects are wrapped to
- * create {@link DelegatingResultSet} objects and the remaining methods
- * simply call the corresponding method on the "delegate"
- * provided in the constructor.</p>
  * @since 2.0
  */
 public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     /** My delegate {@link DatabaseMetaData} */
-    private final DatabaseMetaData _meta;
+    private final DatabaseMetaData databaseMetaData;
 
     /** The connection that created me. **/
-    private final DelegatingConnection<?> _conn;
+    private final DelegatingConnection<?> connection;
 
-    public DelegatingDatabaseMetaData(final DelegatingConnection<?> c,
-            final DatabaseMetaData m) {
+    /**
+     * Constructs a new instance for the given delegating connection and database meta data.
+     *
+     * @param connection
+     *            the delegating connection
+     * @param databaseMetaData
+     *            the database meta data
+     */
+    public DelegatingDatabaseMetaData(final DelegatingConnection<?> connection,
+            final DatabaseMetaData databaseMetaData) {
         super();
-        _conn = c;
-        _meta = m;
+        this.connection = connection;
+        this.databaseMetaData = databaseMetaData;
     }
 
+    /**
+     * Gets the underlying database meta data.
+     *
+     * @return The underlying database meta data.
+     */
     public DatabaseMetaData getDelegate() {
-        return _meta;
+        return databaseMetaData;
     }
 
     /**
-     * If my underlying {@link ResultSet} is not a
-     * {@code DelegatingResultSet}, returns it,
-     * otherwise recursively invokes this method on
-     * my delegate.
+     * If my underlying {@link ResultSet} is not a {@code DelegatingResultSet}, returns it, otherwise recursively
+     * invokes this method on my delegate.
      * <p>
-     * Hence this method will return the first
-     * delegate that is not a {@code DelegatingResultSet},
-     * or {@code null} when no non-{@code DelegatingResultSet}
-     * delegate can be found by traversing this chain.
+     * Hence this method will return the first delegate that is not a {@code DelegatingResultSet}, or {@code null} when
+     * no non-{@code DelegatingResultSet} delegate can be found by traversing this chain.
+     * </p>
      * <p>
-     * This method is useful when you may have nested
-     * {@code DelegatingResultSet}s, and you want to make
-     * sure to obtain a "genuine" {@link ResultSet}.
-     * @return the database meta data
+     * This method is useful when you may have nested {@code DelegatingResultSet}s, and you want to make sure to obtain
+     * a "genuine" {@link ResultSet}.
+     * </p>
+     *
+     * @return the innermost database meta data.
      */
     public DatabaseMetaData getInnermostDelegate() {
-        DatabaseMetaData m = _meta;
-        while(m != null && m instanceof DelegatingDatabaseMetaData) {
-            m = ((DelegatingDatabaseMetaData)m).getDelegate();
-            if(this == m) {
+        DatabaseMetaData m = databaseMetaData;
+        while (m != null && m instanceof DelegatingDatabaseMetaData) {
+            m = ((DelegatingDatabaseMetaData) m).getDelegate();
+            if (this == m) {
                 return null;
             }
         }
@@ -78,76 +91,94 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     }
 
     protected void handleException(final SQLException e) throws SQLException {
-        if (_conn != null) {
-            _conn.handleException(e);
-        }
-        else {
+        if (connection != null) {
+            connection.handleException(e);
+        } else {
             throw e;
         }
     }
 
     @Override
     public boolean allProceduresAreCallable() throws SQLException {
-        try { return _meta.allProceduresAreCallable(); }
-          catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.allProceduresAreCallable();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean allTablesAreSelectable() throws SQLException {
-        try { return _meta.allTablesAreSelectable(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.allTablesAreSelectable();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean dataDefinitionCausesTransactionCommit() throws SQLException {
-        try { return _meta.dataDefinitionCausesTransactionCommit(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.dataDefinitionCausesTransactionCommit();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean dataDefinitionIgnoredInTransactions() throws SQLException {
-        try { return _meta.dataDefinitionIgnoredInTransactions(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.dataDefinitionIgnoredInTransactions();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean deletesAreDetected(final int type) throws SQLException {
-        try { return _meta.deletesAreDetected(type); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.deletesAreDetected(type);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean doesMaxRowSizeIncludeBlobs() throws SQLException {
-        try { return _meta.doesMaxRowSizeIncludeBlobs(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.doesMaxRowSizeIncludeBlobs();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
-    public ResultSet getAttributes(final String catalog, final String schemaPattern,
-            final String typeNamePattern, final String attributeNamePattern)
-            throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getAttributes(final String catalog, final String schemaPattern, final String typeNamePattern,
+            final String attributeNamePattern) throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,_meta.getAttributes(
-                    catalog, schemaPattern, typeNamePattern,
-                    attributeNamePattern));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getAttributes(catalog, schemaPattern, typeNamePattern, attributeNamePattern));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
     }
 
     @Override
-    public ResultSet getBestRowIdentifier(final String catalog, final String schema,
-            final String table, final int scope, final boolean nullable) throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getBestRowIdentifier(final String catalog, final String schema, final String table,
+            final int scope, final boolean nullable) throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getBestRowIdentifier(catalog, schema, table, scope,
-                            nullable));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getBestRowIdentifier(catalog, schema, table, scope, nullable));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -155,55 +186,56 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public String getCatalogSeparator() throws SQLException {
-        try { return _meta.getCatalogSeparator(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getCatalogSeparator();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
     public String getCatalogTerm() throws SQLException {
-        try { return _meta.getCatalogTerm(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getCatalogTerm();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
     public ResultSet getCatalogs() throws SQLException {
-        _conn.checkOpen();
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getCatalogs());
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getCatalogs());
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
     }
 
     @Override
-    public ResultSet getColumnPrivileges(final String catalog, final String schema,
-            final String table, final String columnNamePattern) throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getColumnPrivileges(final String catalog, final String schema, final String table,
+            final String columnNamePattern) throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getColumnPrivileges(catalog, schema, table,
-                            columnNamePattern));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getColumnPrivileges(catalog, schema, table, columnNamePattern));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
     }
 
     @Override
-    public ResultSet getColumns(final String catalog, final String schemaPattern,
-            final String tableNamePattern, final String columnNamePattern)
-            throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getColumns(final String catalog, final String schemaPattern, final String tableNamePattern,
+            final String columnNamePattern) throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getColumns(catalog, schemaPattern, tableNamePattern,
-                            columnNamePattern));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getColumns(catalog, schemaPattern, tableNamePattern, columnNamePattern));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -211,21 +243,17 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public Connection getConnection() throws SQLException {
-        return _conn;
+        return connection;
     }
 
     @Override
-    public ResultSet getCrossReference(final String parentCatalog,
-            final String parentSchema, final String parentTable, final String foreignCatalog,
-            final String foreignSchema, final String foreignTable) throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getCrossReference(final String parentCatalog, final String parentSchema, final String parentTable,
+            final String foreignCatalog, final String foreignSchema, final String foreignTable) throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getCrossReference(parentCatalog, parentSchema,
-                            parentTable, foreignCatalog, foreignSchema,
-                            foreignTable));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getCrossReference(parentCatalog,
+                    parentSchema, parentTable, foreignCatalog, foreignSchema, foreignTable));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -233,61 +261,92 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public int getDatabaseMajorVersion() throws SQLException {
-        try { return _meta.getDatabaseMajorVersion(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getDatabaseMajorVersion();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getDatabaseMinorVersion() throws SQLException {
-        try { return _meta.getDatabaseMinorVersion(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getDatabaseMinorVersion();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public String getDatabaseProductName() throws SQLException {
-        try { return _meta.getDatabaseProductName(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getDatabaseProductName();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
     public String getDatabaseProductVersion() throws SQLException {
-        try { return _meta.getDatabaseProductVersion(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getDatabaseProductVersion();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
     public int getDefaultTransactionIsolation() throws SQLException {
-        try { return _meta.getDefaultTransactionIsolation(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getDefaultTransactionIsolation();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
-    public int getDriverMajorVersion() {return _meta.getDriverMajorVersion();}
+    public int getDriverMajorVersion() {
+        return databaseMetaData.getDriverMajorVersion();
+    }
 
     @Override
-    public int getDriverMinorVersion() {return _meta.getDriverMinorVersion();}
+    public int getDriverMinorVersion() {
+        return databaseMetaData.getDriverMinorVersion();
+    }
 
     @Override
     public String getDriverName() throws SQLException {
-        try { return _meta.getDriverName(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getDriverName();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
     public String getDriverVersion() throws SQLException {
-        try { return _meta.getDriverVersion(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getDriverVersion();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
     public ResultSet getExportedKeys(final String catalog, final String schema, final String table)
             throws SQLException {
-        _conn.checkOpen();
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getExportedKeys(catalog, schema, table));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getExportedKeys(catalog, schema, table));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -295,40 +354,45 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public String getExtraNameCharacters() throws SQLException {
-        try { return _meta.getExtraNameCharacters(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getExtraNameCharacters();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
     public String getIdentifierQuoteString() throws SQLException {
-        try { return _meta.getIdentifierQuoteString(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getIdentifierQuoteString();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
     public ResultSet getImportedKeys(final String catalog, final String schema, final String table)
             throws SQLException {
-        _conn.checkOpen();
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getImportedKeys(catalog, schema, table));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getImportedKeys(catalog, schema, table));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
     }
 
     @Override
-    public ResultSet getIndexInfo(final String catalog, final String schema, final String table,
-            final boolean unique, final boolean approximate) throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getIndexInfo(final String catalog, final String schema, final String table, final boolean unique,
+            final boolean approximate) throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getIndexInfo(catalog, schema, table, unique,
-                            approximate));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getIndexInfo(catalog, schema, table, unique, approximate));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -336,151 +400,241 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public int getJDBCMajorVersion() throws SQLException {
-        try { return _meta.getJDBCMajorVersion(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getJDBCMajorVersion();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getJDBCMinorVersion() throws SQLException {
-        try { return _meta.getJDBCMinorVersion(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getJDBCMinorVersion();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxBinaryLiteralLength() throws SQLException {
-        try { return _meta.getMaxBinaryLiteralLength(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxBinaryLiteralLength();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxCatalogNameLength() throws SQLException {
-        try { return _meta.getMaxCatalogNameLength(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxCatalogNameLength();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxCharLiteralLength() throws SQLException {
-        try { return _meta.getMaxCharLiteralLength(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxCharLiteralLength();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxColumnNameLength() throws SQLException {
-        try { return _meta.getMaxColumnNameLength(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxColumnNameLength();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxColumnsInGroupBy() throws SQLException {
-        try { return _meta.getMaxColumnsInGroupBy(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxColumnsInGroupBy();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxColumnsInIndex() throws SQLException {
-        try { return _meta.getMaxColumnsInIndex(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxColumnsInIndex();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxColumnsInOrderBy() throws SQLException {
-        try { return _meta.getMaxColumnsInOrderBy(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxColumnsInOrderBy();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxColumnsInSelect() throws SQLException {
-        try { return _meta.getMaxColumnsInSelect(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxColumnsInSelect();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxColumnsInTable() throws SQLException {
-        try { return _meta.getMaxColumnsInTable(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxColumnsInTable();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxConnections() throws SQLException {
-        try { return _meta.getMaxConnections(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxConnections();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxCursorNameLength() throws SQLException {
-        try { return _meta.getMaxCursorNameLength(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxCursorNameLength();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxIndexLength() throws SQLException {
-        try { return _meta.getMaxIndexLength(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxIndexLength();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxProcedureNameLength() throws SQLException {
-        try { return _meta.getMaxProcedureNameLength(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxProcedureNameLength();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxRowSize() throws SQLException {
-        try { return _meta.getMaxRowSize(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxRowSize();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxSchemaNameLength() throws SQLException {
-        try { return _meta.getMaxSchemaNameLength(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxSchemaNameLength();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxStatementLength() throws SQLException {
-        try { return _meta.getMaxStatementLength(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxStatementLength();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxStatements() throws SQLException {
-        try { return _meta.getMaxStatements(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxStatements();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxTableNameLength() throws SQLException {
-        try { return _meta.getMaxTableNameLength(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxTableNameLength();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxTablesInSelect() throws SQLException {
-        try { return _meta.getMaxTablesInSelect(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxTablesInSelect();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public int getMaxUserNameLength() throws SQLException {
-        try { return _meta.getMaxUserNameLength(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getMaxUserNameLength();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public String getNumericFunctions() throws SQLException {
-        try { return _meta.getNumericFunctions(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getNumericFunctions();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
-    public ResultSet getPrimaryKeys(final String catalog, final String schema, final String table)
-            throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getPrimaryKeys(final String catalog, final String schema, final String table) throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getPrimaryKeys(catalog, schema, table));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getPrimaryKeys(catalog, schema, table));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -488,15 +642,12 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public ResultSet getProcedureColumns(final String catalog, final String schemaPattern,
-            final String procedureNamePattern, final String columnNamePattern)
-            throws SQLException {
-        _conn.checkOpen();
+            final String procedureNamePattern, final String columnNamePattern) throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getProcedureColumns(catalog, schemaPattern,
-                            procedureNamePattern, columnNamePattern));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getProcedureColumns(catalog,
+                    schemaPattern, procedureNamePattern, columnNamePattern));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -504,20 +655,22 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public String getProcedureTerm() throws SQLException {
-        try { return _meta.getProcedureTerm(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getProcedureTerm();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
-    public ResultSet getProcedures(final String catalog, final String schemaPattern,
-            final String procedureNamePattern) throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getProcedures(final String catalog, final String schemaPattern, final String procedureNamePattern)
+            throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getProcedures(catalog, schemaPattern,
-                            procedureNamePattern));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getProcedures(catalog, schemaPattern, procedureNamePattern));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -525,36 +678,50 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public int getResultSetHoldability() throws SQLException {
-        try { return _meta.getResultSetHoldability(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getResultSetHoldability();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public String getSQLKeywords() throws SQLException {
-        try { return _meta.getSQLKeywords(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getSQLKeywords();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
     public int getSQLStateType() throws SQLException {
-        try { return _meta.getSQLStateType(); }
-        catch (final SQLException e) { handleException(e); return 0; }
+        try {
+            return databaseMetaData.getSQLStateType();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
     }
 
     @Override
     public String getSchemaTerm() throws SQLException {
-        try { return _meta.getSchemaTerm(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getSchemaTerm();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
     public ResultSet getSchemas() throws SQLException {
-        _conn.checkOpen();
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getSchemas());
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getSchemas());
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -562,41 +729,45 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public String getSearchStringEscape() throws SQLException {
-        try { return _meta.getSearchStringEscape(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getSearchStringEscape();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
     public String getStringFunctions() throws SQLException {
-        try { return _meta.getStringFunctions(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getStringFunctions();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
-    public ResultSet getSuperTables(final String catalog, final String schemaPattern,
-            final String tableNamePattern) throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getSuperTables(final String catalog, final String schemaPattern, final String tableNamePattern)
+            throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getSuperTables(catalog, schemaPattern,
-                            tableNamePattern));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getSuperTables(catalog, schemaPattern, tableNamePattern));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
     }
 
     @Override
-    public ResultSet getSuperTypes(final String catalog, final String schemaPattern,
-            final String typeNamePattern) throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getSuperTypes(final String catalog, final String schemaPattern, final String typeNamePattern)
+            throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getSuperTypes(catalog, schemaPattern,
-                            typeNamePattern));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getSuperTypes(catalog, schemaPattern, typeNamePattern));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -604,20 +775,22 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public String getSystemFunctions() throws SQLException {
-        try { return _meta.getSystemFunctions(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getSystemFunctions();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
-    public ResultSet getTablePrivileges(final String catalog, final String schemaPattern,
-            final String tableNamePattern) throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getTablePrivileges(final String catalog, final String schemaPattern, final String tableNamePattern)
+            throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getTablePrivileges(catalog, schemaPattern,
-                            tableNamePattern));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getTablePrivileges(catalog, schemaPattern, tableNamePattern));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -625,27 +798,23 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public ResultSet getTableTypes() throws SQLException {
-        _conn.checkOpen();
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getTableTypes());
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getTableTypes());
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
     }
 
     @Override
-    public ResultSet getTables(final String catalog, final String schemaPattern,
-            final String tableNamePattern, final String[] types) throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getTables(final String catalog, final String schemaPattern, final String tableNamePattern,
+            final String[] types) throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getTables(catalog, schemaPattern, tableNamePattern,
-                            types));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getTables(catalog, schemaPattern, tableNamePattern, types));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -653,33 +822,33 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public String getTimeDateFunctions() throws SQLException {
-        try { return _meta.getTimeDateFunctions(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getTimeDateFunctions();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
     public ResultSet getTypeInfo() throws SQLException {
-        _conn.checkOpen();
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getTypeInfo());
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getTypeInfo());
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
     }
 
     @Override
-    public ResultSet getUDTs(final String catalog, final String schemaPattern,
-            final String typeNamePattern, final int[] types) throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getUDTs(final String catalog, final String schemaPattern, final String typeNamePattern,
+            final int[] types) throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getUDTs(catalog, schemaPattern, typeNamePattern,
-                            types));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getUDTs(catalog, schemaPattern, typeNamePattern, types));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -687,25 +856,32 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public String getURL() throws SQLException {
-        try { return _meta.getURL(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getURL();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
     public String getUserName() throws SQLException {
-        try { return _meta.getUserName(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getUserName();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
-    public ResultSet getVersionColumns(final String catalog, final String schema,
-            final String table) throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getVersionColumns(final String catalog, final String schema, final String table)
+            throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getVersionColumns(catalog, schema, table));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getVersionColumns(catalog, schema, table));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -713,548 +889,902 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public boolean insertsAreDetected(final int type) throws SQLException {
-        try { return _meta.insertsAreDetected(type); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.insertsAreDetected(type);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean isCatalogAtStart() throws SQLException {
-        try { return _meta.isCatalogAtStart(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.isCatalogAtStart();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean isReadOnly() throws SQLException {
-        try { return _meta.isReadOnly(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.isReadOnly();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean locatorsUpdateCopy() throws SQLException {
-        try { return _meta.locatorsUpdateCopy(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.locatorsUpdateCopy();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean nullPlusNonNullIsNull() throws SQLException {
-        try { return _meta.nullPlusNonNullIsNull(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.nullPlusNonNullIsNull();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean nullsAreSortedAtEnd() throws SQLException {
-        try { return _meta.nullsAreSortedAtEnd(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.nullsAreSortedAtEnd();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean nullsAreSortedAtStart() throws SQLException {
-        try { return _meta.nullsAreSortedAtStart(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.nullsAreSortedAtStart();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean nullsAreSortedHigh() throws SQLException {
-        try { return _meta.nullsAreSortedHigh(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.nullsAreSortedHigh();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean nullsAreSortedLow() throws SQLException {
-        try { return _meta.nullsAreSortedLow(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.nullsAreSortedLow();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean othersDeletesAreVisible(final int type) throws SQLException {
-        try { return _meta.othersDeletesAreVisible(type); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.othersDeletesAreVisible(type);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean othersInsertsAreVisible(final int type) throws SQLException {
-        try { return _meta.othersInsertsAreVisible(type); }
-        catch (final SQLException e) { handleException(e); return false; }
-    }
+        try {
+            return databaseMetaData.othersInsertsAreVisible(type);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
     public boolean othersUpdatesAreVisible(final int type) throws SQLException {
-        try { return _meta.othersUpdatesAreVisible(type); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.othersUpdatesAreVisible(type);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean ownDeletesAreVisible(final int type) throws SQLException {
-        try { return _meta.ownDeletesAreVisible(type); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.ownDeletesAreVisible(type);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean ownInsertsAreVisible(final int type) throws SQLException {
-        try { return _meta.ownInsertsAreVisible(type); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.ownInsertsAreVisible(type);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean ownUpdatesAreVisible(final int type) throws SQLException {
-        try { return _meta.ownUpdatesAreVisible(type); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.ownUpdatesAreVisible(type);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean storesLowerCaseIdentifiers() throws SQLException {
-        try { return _meta.storesLowerCaseIdentifiers(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.storesLowerCaseIdentifiers();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean storesLowerCaseQuotedIdentifiers() throws SQLException {
-        try { return _meta.storesLowerCaseQuotedIdentifiers(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.storesLowerCaseQuotedIdentifiers();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean storesMixedCaseIdentifiers() throws SQLException {
-        try { return _meta.storesMixedCaseIdentifiers(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.storesMixedCaseIdentifiers();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean storesMixedCaseQuotedIdentifiers() throws SQLException {
-        try { return _meta.storesMixedCaseQuotedIdentifiers(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.storesMixedCaseQuotedIdentifiers();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean storesUpperCaseIdentifiers() throws SQLException {
-        try { return _meta.storesUpperCaseIdentifiers(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.storesUpperCaseIdentifiers();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean storesUpperCaseQuotedIdentifiers() throws SQLException {
-        try { return _meta.storesUpperCaseQuotedIdentifiers(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.storesUpperCaseQuotedIdentifiers();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsANSI92EntryLevelSQL() throws SQLException {
-        try { return _meta.supportsANSI92EntryLevelSQL(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsANSI92EntryLevelSQL();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsANSI92FullSQL() throws SQLException {
-        try { return _meta.supportsANSI92FullSQL(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsANSI92FullSQL();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsANSI92IntermediateSQL() throws SQLException {
-        try { return _meta.supportsANSI92IntermediateSQL(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsANSI92IntermediateSQL();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsAlterTableWithAddColumn() throws SQLException {
-        try { return _meta.supportsAlterTableWithAddColumn(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsAlterTableWithAddColumn();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsAlterTableWithDropColumn() throws SQLException {
-        try { return _meta.supportsAlterTableWithDropColumn(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsAlterTableWithDropColumn();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsBatchUpdates() throws SQLException {
-        try { return _meta.supportsBatchUpdates(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsBatchUpdates();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsCatalogsInDataManipulation() throws SQLException {
-        try { return _meta.supportsCatalogsInDataManipulation(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsCatalogsInDataManipulation();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsCatalogsInIndexDefinitions() throws SQLException {
-        try { return _meta.supportsCatalogsInIndexDefinitions(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsCatalogsInIndexDefinitions();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsCatalogsInPrivilegeDefinitions() throws SQLException {
-        try { return _meta.supportsCatalogsInPrivilegeDefinitions(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsCatalogsInPrivilegeDefinitions();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsCatalogsInProcedureCalls() throws SQLException {
-        try { return _meta.supportsCatalogsInProcedureCalls(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsCatalogsInProcedureCalls();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsCatalogsInTableDefinitions() throws SQLException {
-        try { return _meta.supportsCatalogsInTableDefinitions(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsCatalogsInTableDefinitions();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsColumnAliasing() throws SQLException {
-        try { return _meta.supportsColumnAliasing(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsColumnAliasing();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsConvert() throws SQLException {
-        try { return _meta.supportsConvert(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsConvert();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
-    public boolean supportsConvert(final int fromType, final int toType)
-            throws SQLException {
-        try { return _meta.supportsConvert(fromType, toType); }
-        catch (final SQLException e) { handleException(e); return false; }
+    public boolean supportsConvert(final int fromType, final int toType) throws SQLException {
+        try {
+            return databaseMetaData.supportsConvert(fromType, toType);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsCoreSQLGrammar() throws SQLException {
-        try { return _meta.supportsCoreSQLGrammar(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsCoreSQLGrammar();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsCorrelatedSubqueries() throws SQLException {
-        try { return _meta.supportsCorrelatedSubqueries(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsCorrelatedSubqueries();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
-    public boolean supportsDataDefinitionAndDataManipulationTransactions()
-            throws SQLException {
-        try { return _meta.supportsDataDefinitionAndDataManipulationTransactions(); }
-        catch (final SQLException e) { handleException(e); return false; }
+    public boolean supportsDataDefinitionAndDataManipulationTransactions() throws SQLException {
+        try {
+            return databaseMetaData.supportsDataDefinitionAndDataManipulationTransactions();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
-    public boolean supportsDataManipulationTransactionsOnly()
-            throws SQLException {
-        try { return _meta.supportsDataManipulationTransactionsOnly(); }
-        catch (final SQLException e) { handleException(e); return false; }
+    public boolean supportsDataManipulationTransactionsOnly() throws SQLException {
+        try {
+            return databaseMetaData.supportsDataManipulationTransactionsOnly();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsDifferentTableCorrelationNames() throws SQLException {
-        try { return _meta.supportsDifferentTableCorrelationNames(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsDifferentTableCorrelationNames();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsExpressionsInOrderBy() throws SQLException {
-        try { return _meta.supportsExpressionsInOrderBy(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsExpressionsInOrderBy();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsExtendedSQLGrammar() throws SQLException {
-        try { return _meta.supportsExtendedSQLGrammar(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsExtendedSQLGrammar();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsFullOuterJoins() throws SQLException {
-        try { return _meta.supportsFullOuterJoins(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsFullOuterJoins();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsGetGeneratedKeys() throws SQLException {
-        try { return _meta.supportsGetGeneratedKeys(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsGetGeneratedKeys();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsGroupBy() throws SQLException {
-        try { return _meta.supportsGroupBy(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsGroupBy();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsGroupByBeyondSelect() throws SQLException {
-        try { return _meta.supportsGroupByBeyondSelect(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsGroupByBeyondSelect();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsGroupByUnrelated() throws SQLException {
-        try { return _meta.supportsGroupByUnrelated(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsGroupByUnrelated();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsIntegrityEnhancementFacility() throws SQLException {
-        try { return _meta.supportsIntegrityEnhancementFacility(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsIntegrityEnhancementFacility();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsLikeEscapeClause() throws SQLException {
-        try { return _meta.supportsLikeEscapeClause(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsLikeEscapeClause();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsLimitedOuterJoins() throws SQLException {
-        try { return _meta.supportsLimitedOuterJoins(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsLimitedOuterJoins();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsMinimumSQLGrammar() throws SQLException {
-        try { return _meta.supportsMinimumSQLGrammar(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsMinimumSQLGrammar();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsMixedCaseIdentifiers() throws SQLException {
-        try { return _meta.supportsMixedCaseIdentifiers(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsMixedCaseIdentifiers();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {
-        try { return _meta.supportsMixedCaseQuotedIdentifiers(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsMixedCaseQuotedIdentifiers();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsMultipleOpenResults() throws SQLException {
-        try { return _meta.supportsMultipleOpenResults(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsMultipleOpenResults();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsMultipleResultSets() throws SQLException {
-        try { return _meta.supportsMultipleResultSets(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsMultipleResultSets();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsMultipleTransactions() throws SQLException {
-        try { return _meta.supportsMultipleTransactions(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsMultipleTransactions();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsNamedParameters() throws SQLException {
-        try { return _meta.supportsNamedParameters(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsNamedParameters();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsNonNullableColumns() throws SQLException {
-        try { return _meta.supportsNonNullableColumns(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsNonNullableColumns();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsOpenCursorsAcrossCommit() throws SQLException {
-        try { return _meta.supportsOpenCursorsAcrossCommit(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsOpenCursorsAcrossCommit();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsOpenCursorsAcrossRollback() throws SQLException {
-        try { return _meta.supportsOpenCursorsAcrossRollback(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsOpenCursorsAcrossRollback();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsOpenStatementsAcrossCommit() throws SQLException {
-        try { return _meta.supportsOpenStatementsAcrossCommit(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsOpenStatementsAcrossCommit();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsOpenStatementsAcrossRollback() throws SQLException {
-        try { return _meta.supportsOpenStatementsAcrossRollback(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsOpenStatementsAcrossRollback();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsOrderByUnrelated() throws SQLException {
-        try { return _meta.supportsOrderByUnrelated(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsOrderByUnrelated();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsOuterJoins() throws SQLException {
-        try { return _meta.supportsOuterJoins(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsOuterJoins();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsPositionedDelete() throws SQLException {
-        try { return _meta.supportsPositionedDelete(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsPositionedDelete();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsPositionedUpdate() throws SQLException {
-        try { return _meta.supportsPositionedUpdate(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsPositionedUpdate();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
-    public boolean supportsResultSetConcurrency(final int type, final int concurrency)
-            throws SQLException {
-        try { return _meta.supportsResultSetConcurrency(type, concurrency); }
-        catch (final SQLException e) { handleException(e); return false; }
+    public boolean supportsResultSetConcurrency(final int type, final int concurrency) throws SQLException {
+        try {
+            return databaseMetaData.supportsResultSetConcurrency(type, concurrency);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
-    public boolean supportsResultSetHoldability(final int holdability)
-            throws SQLException {
-        try { return _meta.supportsResultSetHoldability(holdability); }
-        catch (final SQLException e) { handleException(e); return false; }
+    public boolean supportsResultSetHoldability(final int holdability) throws SQLException {
+        try {
+            return databaseMetaData.supportsResultSetHoldability(holdability);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsResultSetType(final int type) throws SQLException {
-        try { return _meta.supportsResultSetType(type); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsResultSetType(type);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsSavepoints() throws SQLException {
-        try { return _meta.supportsSavepoints(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsSavepoints();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsSchemasInDataManipulation() throws SQLException {
-        try { return _meta.supportsSchemasInDataManipulation(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsSchemasInDataManipulation();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsSchemasInIndexDefinitions() throws SQLException {
-        try { return _meta.supportsSchemasInIndexDefinitions(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsSchemasInIndexDefinitions();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsSchemasInPrivilegeDefinitions() throws SQLException {
-        try { return _meta.supportsSchemasInPrivilegeDefinitions(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsSchemasInPrivilegeDefinitions();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsSchemasInProcedureCalls() throws SQLException {
-        try { return _meta.supportsSchemasInProcedureCalls(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsSchemasInProcedureCalls();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsSchemasInTableDefinitions() throws SQLException {
-        try { return _meta.supportsSchemasInTableDefinitions(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsSchemasInTableDefinitions();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsSelectForUpdate() throws SQLException {
-        try { return _meta.supportsSelectForUpdate(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsSelectForUpdate();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsStatementPooling() throws SQLException {
-        try { return _meta.supportsStatementPooling(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsStatementPooling();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsStoredProcedures() throws SQLException {
-        try { return _meta.supportsStoredProcedures(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsStoredProcedures();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsSubqueriesInComparisons() throws SQLException {
-        try { return _meta.supportsSubqueriesInComparisons(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsSubqueriesInComparisons();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsSubqueriesInExists() throws SQLException {
-        try { return _meta.supportsSubqueriesInExists(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsSubqueriesInExists();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsSubqueriesInIns() throws SQLException {
-        try { return _meta.supportsSubqueriesInIns(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsSubqueriesInIns();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsSubqueriesInQuantifieds() throws SQLException {
-        try { return _meta.supportsSubqueriesInQuantifieds(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsSubqueriesInQuantifieds();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsTableCorrelationNames() throws SQLException {
-        try { return _meta.supportsTableCorrelationNames(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsTableCorrelationNames();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
-    public boolean supportsTransactionIsolationLevel(final int level)
-            throws SQLException {
-        try { return _meta.supportsTransactionIsolationLevel(level); }
-        catch (final SQLException e) { handleException(e); return false; }
+    public boolean supportsTransactionIsolationLevel(final int level) throws SQLException {
+        try {
+            return databaseMetaData.supportsTransactionIsolationLevel(level);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsTransactions() throws SQLException {
-        try { return _meta.supportsTransactions(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsTransactions();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsUnion() throws SQLException {
-        try { return _meta.supportsUnion(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsUnion();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsUnionAll() throws SQLException {
-        try { return _meta.supportsUnionAll(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsUnionAll();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean updatesAreDetected(final int type) throws SQLException {
-        try { return _meta.updatesAreDetected(type); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.updatesAreDetected(type);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean usesLocalFilePerTable() throws SQLException {
-        try { return _meta.usesLocalFilePerTable(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.usesLocalFilePerTable();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean usesLocalFiles() throws SQLException {
-        try { return _meta.usesLocalFiles(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.usesLocalFiles();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     /* JDBC_4_ANT_KEY_BEGIN */
@@ -1263,10 +1793,10 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     public boolean isWrapperFor(final Class<?> iface) throws SQLException {
         if (iface.isAssignableFrom(getClass())) {
             return true;
-        } else if (iface.isAssignableFrom(_meta.getClass())) {
+        } else if (iface.isAssignableFrom(databaseMetaData.getClass())) {
             return true;
         } else {
-            return _meta.isWrapperFor(iface);
+            return databaseMetaData.isWrapperFor(iface);
         }
     }
 
@@ -1274,28 +1804,29 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     public <T> T unwrap(final Class<T> iface) throws SQLException {
         if (iface.isAssignableFrom(getClass())) {
             return iface.cast(this);
-        } else if (iface.isAssignableFrom(_meta.getClass())) {
-            return iface.cast(_meta);
+        } else if (iface.isAssignableFrom(databaseMetaData.getClass())) {
+            return iface.cast(databaseMetaData);
         } else {
-            return _meta.unwrap(iface);
+            return databaseMetaData.unwrap(iface);
         }
     }
 
     @Override
     public RowIdLifetime getRowIdLifetime() throws SQLException {
-        try { return _meta.getRowIdLifetime(); }
-        catch (final SQLException e) { handleException(e); throw new AssertionError(); }
+        try {
+            return databaseMetaData.getRowIdLifetime();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
     }
 
     @Override
-    public ResultSet getSchemas(final String catalog, final String schemaPattern)
-    throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getSchemas(final String catalog, final String schemaPattern) throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getSchemas(catalog, schemaPattern));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getSchemas(catalog, schemaPattern));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -1303,39 +1834,43 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public boolean autoCommitFailureClosesAllResultSets() throws SQLException {
-        try { return _meta.autoCommitFailureClosesAllResultSets(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.autoCommitFailureClosesAllResultSets();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public boolean supportsStoredFunctionsUsingCallSyntax() throws SQLException {
-        try { return _meta.supportsStoredFunctionsUsingCallSyntax(); }
-        catch (final SQLException e) { handleException(e); return false; }
+        try {
+            return databaseMetaData.supportsStoredFunctionsUsingCallSyntax();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
     }
 
     @Override
     public ResultSet getClientInfoProperties() throws SQLException {
-        _conn.checkOpen();
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getClientInfoProperties());
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getClientInfoProperties());
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
     }
 
     @Override
-    public ResultSet getFunctions(final String catalog, final String schemaPattern,
-            final String functionNamePattern) throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getFunctions(final String catalog, final String schemaPattern, final String functionNamePattern)
+            throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getFunctions(catalog, schemaPattern,
-                            functionNamePattern));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getFunctions(catalog, schemaPattern, functionNamePattern));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -1343,15 +1878,12 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public ResultSet getFunctionColumns(final String catalog, final String schemaPattern,
-            final String functionNamePattern, final String columnNamePattern)
-            throws SQLException {
-        _conn.checkOpen();
+            final String functionNamePattern, final String columnNamePattern) throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getFunctionColumns(catalog, schemaPattern,
-                            functionNamePattern, columnNamePattern));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection, databaseMetaData.getFunctionColumns(catalog,
+                    schemaPattern, functionNamePattern, columnNamePattern));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -1360,16 +1892,13 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
     /* JDBC_4_ANT_KEY_END */
 
     @Override
-    public ResultSet getPseudoColumns(final String catalog, final String schemaPattern,
-            final String tableNamePattern, final String columnNamePattern)
-            throws SQLException {
-        _conn.checkOpen();
+    public ResultSet getPseudoColumns(final String catalog, final String schemaPattern, final String tableNamePattern,
+            final String columnNamePattern) throws SQLException {
+        connection.checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(_conn,
-                    _meta.getPseudoColumns(catalog, schemaPattern,
-                            tableNamePattern, columnNamePattern));
-}
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(connection,
+                    databaseMetaData.getPseudoColumns(catalog, schemaPattern, tableNamePattern, columnNamePattern));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -1377,11 +1906,10 @@ public class DelegatingDatabaseMetaData implements DatabaseMetaData {
 
     @Override
     public boolean generatedKeyAlwaysReturned() throws SQLException {
-        _conn.checkOpen();
+        connection.checkOpen();
         try {
-            return _meta.generatedKeyAlwaysReturned();
-        }
-        catch (final SQLException e) {
+            return databaseMetaData.generatedKeyAlwaysReturned();
+        } catch (final SQLException e) {
             handleException(e);
             return false;
         }

==================================================
DelegatingResultSet.java
index ef6a806a75..ca50f67fd6 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DelegatingPreparedStatement.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingPreparedStatement.java
@@ -40,36 +40,27 @@ import java.util.Calendar;
 /**
  * A base delegating implementation of {@link PreparedStatement}.
  * <p>
- * All of the methods from the {@link PreparedStatement} interface
- * simply check to see that the {@link PreparedStatement} is active,
- * and call the corresponding method on the "delegate"
- * provided in my constructor.
+ * All of the methods from the {@link PreparedStatement} interface simply check to see that the
+ * {@link PreparedStatement} is active, and call the corresponding method on the "delegate" provided in my constructor.
  * <p>
- * Extends AbandonedTrace to implement Statement tracking and
- * logging of code which created the Statement. Tracking the
- * Statement ensures that the Connection which created it can
- * close any open Statement's on Connection close.
+ * Extends AbandonedTrace to implement Statement tracking and logging of code which created the Statement. Tracking the
+ * Statement ensures that the Connection which created it can close any open Statement's on Connection close.
  *
- * @author Rodney Waldhoff
- * @author Glenn L. Nielsen
- * @author James House
- * @author Dirk Verbeeck
  * @since 2.0
  */
-public class DelegatingPreparedStatement extends DelegatingStatement
-        implements PreparedStatement {
+public class DelegatingPreparedStatement extends DelegatingStatement implements PreparedStatement {
 
     /**
-     * Create a wrapper for the Statement which traces this
-     * Statement to the Connection which created it and the
-     * code which created it.
+     * Create a wrapper for the Statement which traces this Statement to the Connection which created it and the code
+     * which created it.
      *
-     * @param s the {@link PreparedStatement} to delegate all calls to.
-     * @param c the {@link DelegatingConnection} that created this statement.
+     * @param statement
+     *            the {@link PreparedStatement} to delegate all calls to.
+     * @param connection
+     *            the {@link DelegatingConnection} that created this statement.
      */
-    public DelegatingPreparedStatement(final DelegatingConnection<?> c,
-                                       final PreparedStatement s) {
-        super(c, s);
+    public DelegatingPreparedStatement(final DelegatingConnection<?> connection, final PreparedStatement statement) {
+        super(connection, statement);
     }
 
     @Override
@@ -79,9 +70,8 @@ public class DelegatingPreparedStatement extends DelegatingStatement
             getConnectionInternal().setLastUsed();
         }
         try {
-            return DelegatingResultSet.wrapResultSet(this,((PreparedStatement)getDelegate()).executeQuery());
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(this, getDelegatePreparedStatement().executeQuery());
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -94,98 +84,229 @@ public class DelegatingPreparedStatement extends DelegatingStatement
             getConnectionInternal().setLastUsed();
         }
         try {
-            return ((PreparedStatement) getDelegate()).executeUpdate();
+            return getDelegatePreparedStatement().executeUpdate();
         } catch (final SQLException e) {
             handleException(e);
             return 0;
         }
     }
 
+    private PreparedStatement getDelegatePreparedStatement() {
+        return (PreparedStatement) getDelegate();
+    }
+
     @Override
-    public void setNull(final int parameterIndex, final int sqlType) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setNull(parameterIndex,sqlType); } catch (final SQLException e) { handleException(e); } }
+    public void setNull(final int parameterIndex, final int sqlType) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setNull(parameterIndex, sqlType);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setBoolean(final int parameterIndex, final boolean x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setBoolean(parameterIndex,x); } catch (final SQLException e) { handleException(e); } }
+    public void setBoolean(final int parameterIndex, final boolean x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setBoolean(parameterIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setByte(final int parameterIndex, final byte x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setByte(parameterIndex,x); } catch (final SQLException e) { handleException(e); } }
+    public void setByte(final int parameterIndex, final byte x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setByte(parameterIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setShort(final int parameterIndex, final short x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setShort(parameterIndex,x); } catch (final SQLException e) { handleException(e); } }
+    public void setShort(final int parameterIndex, final short x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setShort(parameterIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setInt(final int parameterIndex, final int x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setInt(parameterIndex,x); } catch (final SQLException e) { handleException(e); } }
+    public void setInt(final int parameterIndex, final int x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setInt(parameterIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setLong(final int parameterIndex, final long x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setLong(parameterIndex,x); } catch (final SQLException e) { handleException(e); } }
+    public void setLong(final int parameterIndex, final long x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setLong(parameterIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setFloat(final int parameterIndex, final float x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setFloat(parameterIndex,x); } catch (final SQLException e) { handleException(e); } }
+    public void setFloat(final int parameterIndex, final float x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setFloat(parameterIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setDouble(final int parameterIndex, final double x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setDouble(parameterIndex,x); } catch (final SQLException e) { handleException(e); } }
+    public void setDouble(final int parameterIndex, final double x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setDouble(parameterIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setBigDecimal(final int parameterIndex, final BigDecimal x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setBigDecimal(parameterIndex,x); } catch (final SQLException e) { handleException(e); } }
+    public void setBigDecimal(final int parameterIndex, final BigDecimal x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setBigDecimal(parameterIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setString(final int parameterIndex, final String x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setString(parameterIndex,x); } catch (final SQLException e) { handleException(e); } }
+    public void setString(final int parameterIndex, final String x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setString(parameterIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setBytes(final int parameterIndex, final byte[] x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setBytes(parameterIndex,x); } catch (final SQLException e) { handleException(e); } }
+    public void setBytes(final int parameterIndex, final byte[] x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setBytes(parameterIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setDate(final int parameterIndex, final Date x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setDate(parameterIndex,x); } catch (final SQLException e) { handleException(e); } }
+    public void setDate(final int parameterIndex, final Date x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setDate(parameterIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setTime(final int parameterIndex, final Time x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setTime(parameterIndex,x); } catch (final SQLException e) { handleException(e); } }
+    public void setTime(final int parameterIndex, final Time x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setTime(parameterIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setTimestamp(final int parameterIndex, final Timestamp x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setTimestamp(parameterIndex,x); } catch (final SQLException e) { handleException(e); } }
+    public void setTimestamp(final int parameterIndex, final Timestamp x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setTimestamp(parameterIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setAsciiStream(final int parameterIndex, final InputStream x, final int length) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setAsciiStream(parameterIndex,x,length); } catch (final SQLException e) { handleException(e); } }
+    public void setAsciiStream(final int parameterIndex, final InputStream x, final int length) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setAsciiStream(parameterIndex, x, length);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     /** @deprecated Use setAsciiStream(), setCharacterStream() or setNCharacterStream() */
     @Deprecated
     @Override
-    public void setUnicodeStream(final int parameterIndex, final InputStream x, final int length) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setUnicodeStream(parameterIndex,x,length); } catch (final SQLException e) { handleException(e); } }
+    public void setUnicodeStream(final int parameterIndex, final InputStream x, final int length) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setUnicodeStream(parameterIndex, x, length);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setBinaryStream(final int parameterIndex, final InputStream x, final int length) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setBinaryStream(parameterIndex,x,length); } catch (final SQLException e) { handleException(e); } }
+    public void setBinaryStream(final int parameterIndex, final InputStream x, final int length) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setBinaryStream(parameterIndex, x, length);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void clearParameters() throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).clearParameters(); } catch (final SQLException e) { handleException(e); } }
+    public void clearParameters() throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().clearParameters();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setObject(final int parameterIndex, final Object x, final int targetSqlType, final int scale) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setObject(parameterIndex, x, targetSqlType, scale); } catch (final SQLException e) { handleException(e); } }
+    public void setObject(final int parameterIndex, final Object x, final int targetSqlType, final int scale)
+            throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setObject(parameterIndex, x, targetSqlType, scale);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setObject(final int parameterIndex, final Object x, final int targetSqlType) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setObject(parameterIndex, x, targetSqlType); } catch (final SQLException e) { handleException(e); } }
+    public void setObject(final int parameterIndex, final Object x, final int targetSqlType) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setObject(parameterIndex, x, targetSqlType);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setObject(final int parameterIndex, final Object x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setObject(parameterIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void setObject(final int parameterIndex, final Object x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setObject(parameterIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
     public boolean execute() throws SQLException {
@@ -194,7 +315,7 @@ public class DelegatingPreparedStatement extends DelegatingStatement
             getConnectionInternal().setLastUsed();
         }
         try {
-            return ((PreparedStatement) getDelegate()).execute();
+            return getDelegatePreparedStatement().execute();
         } catch (final SQLException e) {
             handleException(e);
             return false;
@@ -202,54 +323,123 @@ public class DelegatingPreparedStatement extends DelegatingStatement
     }
 
     @Override
-    public void addBatch() throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).addBatch(); } catch (final SQLException e) { handleException(e); } }
+    public void addBatch() throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().addBatch();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setCharacterStream(final int parameterIndex, final Reader reader, final int length) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setCharacterStream(parameterIndex,reader,length); } catch (final SQLException e) { handleException(e); } }
+    public void setCharacterStream(final int parameterIndex, final Reader reader, final int length)
+            throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setCharacterStream(parameterIndex, reader, length);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setRef(final int i, final Ref x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setRef(i,x); } catch (final SQLException e) { handleException(e); } }
+    public void setRef(final int i, final Ref x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setRef(i, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setBlob(final int i, final Blob x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setBlob(i,x); } catch (final SQLException e) { handleException(e); } }
+    public void setBlob(final int i, final Blob x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setBlob(i, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setClob(final int i, final Clob x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setClob(i,x); } catch (final SQLException e) { handleException(e); } }
+    public void setClob(final int i, final Clob x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setClob(i, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setArray(final int i, final Array x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setArray(i,x); } catch (final SQLException e) { handleException(e); } }
+    public void setArray(final int i, final Array x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setArray(i, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public ResultSetMetaData getMetaData() throws SQLException
-    { checkOpen(); try { return ((PreparedStatement)getDelegate()).getMetaData(); } catch (final SQLException e) { handleException(e); throw new AssertionError(); } }
+    public ResultSetMetaData getMetaData() throws SQLException {
+        checkOpen();
+        try {
+            return getDelegatePreparedStatement().getMetaData();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
 
     @Override
-    public void setDate(final int parameterIndex, final Date x, final Calendar cal) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setDate(parameterIndex,x,cal); } catch (final SQLException e) { handleException(e); } }
+    public void setDate(final int parameterIndex, final Date x, final Calendar cal) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setDate(parameterIndex, x, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setTime(final int parameterIndex, final Time x, final Calendar cal) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setTime(parameterIndex,x,cal); } catch (final SQLException e) { handleException(e); } }
+    public void setTime(final int parameterIndex, final Time x, final Calendar cal) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setTime(parameterIndex, x, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setTimestamp(final int parameterIndex, final Timestamp x, final Calendar cal) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setTimestamp(parameterIndex,x,cal); } catch (final SQLException e) { handleException(e); } }
+    public void setTimestamp(final int parameterIndex, final Timestamp x, final Calendar cal) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setTimestamp(parameterIndex, x, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setNull(final int paramIndex, final int sqlType, final String typeName) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setNull(paramIndex,sqlType,typeName); } catch (final SQLException e) { handleException(e); } }
+    public void setNull(final int paramIndex, final int sqlType, final String typeName) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setNull(paramIndex, sqlType, typeName);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     /**
      * Returns a String representation of this object.
      *
      * @return String
      */
+    @SuppressWarnings("resource")
     @Override
     public String toString() {
         final Statement statement = getDelegate();
@@ -257,21 +447,32 @@ public class DelegatingPreparedStatement extends DelegatingStatement
     }
 
     @Override
-    public void setURL(final int parameterIndex, final java.net.URL x) throws SQLException
-    { checkOpen(); try { ((PreparedStatement)getDelegate()).setURL(parameterIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void setURL(final int parameterIndex, final java.net.URL x) throws SQLException {
+        checkOpen();
+        try {
+            getDelegatePreparedStatement().setURL(parameterIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public java.sql.ParameterMetaData getParameterMetaData() throws SQLException
-    { checkOpen(); try { return ((PreparedStatement)getDelegate()).getParameterMetaData(); } catch (final SQLException e) { handleException(e); throw new AssertionError(); } }
-
+    public java.sql.ParameterMetaData getParameterMetaData() throws SQLException {
+        checkOpen();
+        try {
+            return getDelegatePreparedStatement().getParameterMetaData();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
 
     @Override
     public void setRowId(final int parameterIndex, final RowId value) throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setRowId(parameterIndex, value);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setRowId(parameterIndex, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -280,20 +481,19 @@ public class DelegatingPreparedStatement extends DelegatingStatement
     public void setNString(final int parameterIndex, final String value) throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setNString(parameterIndex, value);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setNString(parameterIndex, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setNCharacterStream(final int parameterIndex, final Reader value, final long length) throws SQLException {
+    public void setNCharacterStream(final int parameterIndex, final Reader value, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setNCharacterStream(parameterIndex, value, length);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setNCharacterStream(parameterIndex, value, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -302,9 +502,8 @@ public class DelegatingPreparedStatement extends DelegatingStatement
     public void setNClob(final int parameterIndex, final NClob value) throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setNClob(parameterIndex, value);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setNClob(parameterIndex, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -313,20 +512,19 @@ public class DelegatingPreparedStatement extends DelegatingStatement
     public void setClob(final int parameterIndex, final Reader reader, final long length) throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setClob(parameterIndex, reader, length);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setClob(parameterIndex, reader, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setBlob(final int parameterIndex, final InputStream inputStream, final long length) throws SQLException {
+    public void setBlob(final int parameterIndex, final InputStream inputStream, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setBlob(parameterIndex, inputStream, length);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setBlob(parameterIndex, inputStream, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -335,9 +533,8 @@ public class DelegatingPreparedStatement extends DelegatingStatement
     public void setNClob(final int parameterIndex, final Reader reader, final long length) throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setNClob(parameterIndex, reader, length);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setNClob(parameterIndex, reader, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -346,42 +543,41 @@ public class DelegatingPreparedStatement extends DelegatingStatement
     public void setSQLXML(final int parameterIndex, final SQLXML value) throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setSQLXML(parameterIndex, value);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setSQLXML(parameterIndex, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setAsciiStream(final int parameterIndex, final InputStream inputStream, final long length) throws SQLException {
+    public void setAsciiStream(final int parameterIndex, final InputStream inputStream, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setAsciiStream(parameterIndex, inputStream, length);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setAsciiStream(parameterIndex, inputStream, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setBinaryStream(final int parameterIndex, final InputStream inputStream, final long length) throws SQLException {
+    public void setBinaryStream(final int parameterIndex, final InputStream inputStream, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setBinaryStream(parameterIndex, inputStream, length);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setBinaryStream(parameterIndex, inputStream, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void setCharacterStream(final int parameterIndex, final Reader reader, final long length) throws SQLException {
+    public void setCharacterStream(final int parameterIndex, final Reader reader, final long length)
+            throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setCharacterStream(parameterIndex, reader, length);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setCharacterStream(parameterIndex, reader, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -390,9 +586,8 @@ public class DelegatingPreparedStatement extends DelegatingStatement
     public void setAsciiStream(final int parameterIndex, final InputStream inputStream) throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setAsciiStream(parameterIndex, inputStream);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setAsciiStream(parameterIndex, inputStream);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -401,9 +596,8 @@ public class DelegatingPreparedStatement extends DelegatingStatement
     public void setBinaryStream(final int parameterIndex, final InputStream inputStream) throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setBinaryStream(parameterIndex, inputStream);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setBinaryStream(parameterIndex, inputStream);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -412,9 +606,8 @@ public class DelegatingPreparedStatement extends DelegatingStatement
     public void setCharacterStream(final int parameterIndex, final Reader reader) throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setCharacterStream(parameterIndex, reader);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setCharacterStream(parameterIndex, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -423,9 +616,8 @@ public class DelegatingPreparedStatement extends DelegatingStatement
     public void setNCharacterStream(final int parameterIndex, final Reader reader) throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setNCharacterStream(parameterIndex, reader);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setNCharacterStream(parameterIndex, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -434,9 +626,8 @@ public class DelegatingPreparedStatement extends DelegatingStatement
     public void setClob(final int parameterIndex, final Reader reader) throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setClob(parameterIndex, reader);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setClob(parameterIndex, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -445,9 +636,8 @@ public class DelegatingPreparedStatement extends DelegatingStatement
     public void setBlob(final int parameterIndex, final InputStream inputStream) throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setBlob(parameterIndex, inputStream);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setBlob(parameterIndex, inputStream);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -456,9 +646,8 @@ public class DelegatingPreparedStatement extends DelegatingStatement
     public void setNClob(final int parameterIndex, final Reader reader) throws SQLException {
         checkOpen();
         try {
-            ((PreparedStatement)getDelegate()).setNClob(parameterIndex, reader);
-        }
-        catch (final SQLException e) {
+            getDelegatePreparedStatement().setNClob(parameterIndex, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }

==================================================
DelegatingStatement.java
index 448e92a72a..b7e1ba0fd7 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DelegatingResultSet.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingResultSet.java
@@ -42,104 +42,123 @@ import java.util.Map;
 /**
  * A base delegating implementation of {@link ResultSet}.
  * <p>
- * All of the methods from the {@link ResultSet} interface
- * simply call the corresponding method on the "delegate"
+ * All of the methods from the {@link ResultSet} interface simply call the corresponding method on the "delegate"
  * provided in my constructor.
+ * </p>
  * <p>
- * Extends AbandonedTrace to implement result set tracking and
- * logging of code which created the ResultSet. Tracking the
- * ResultSet ensures that the Statement which created it can
- * close any open ResultSet's on Statement close.
+ * Extends AbandonedTrace to implement result set tracking and logging of code which created the ResultSet. Tracking the
+ * ResultSet ensures that the Statement which created it can close any open ResultSet's on Statement close.
+ * </p>
  *
- * @author Glenn L. Nielsen
- * @author James House
- * @author Dirk Verbeeck
  * @since 2.0
  */
 public final class DelegatingResultSet extends AbandonedTrace implements ResultSet {
 
     /** My delegate. **/
-    private final ResultSet _res;
+    private final ResultSet resultSet;
 
     /** The Statement that created me, if any. **/
-    private Statement _stmt;
+    private Statement statement;
 
     /** The Connection that created me, if any. **/
-    private Connection _conn;
+    private Connection connection;
 
     /**
-     * Create a wrapper for the ResultSet which traces this
-     * ResultSet to the Statement which created it and the
-     * code which created it.
+     * Creates a wrapper for the ResultSet which traces this ResultSet to the Statement which created it and the code
+     * which created it.
      * <p>
-     * Private to ensure all construction is
-     * {@link #wrapResultSet(Statement, ResultSet)}
+     * Private to ensure all construction is {@link #wrapResultSet(Statement, ResultSet)}
+     * </p>
      *
-     * @param stmt Statement which created this ResultSet
-     * @param res ResultSet to wrap
+     * @param statement
+     *            The Statement which created the ResultSet.
+     * @param resultSet
+     *            The ResultSet to wrap.
      */
-    private DelegatingResultSet(final Statement stmt, final ResultSet res) {
-        super((AbandonedTrace)stmt);
-        this._stmt = stmt;
-        this._res = res;
+    private DelegatingResultSet(final Statement statement, final ResultSet resultSet) {
+        super((AbandonedTrace) statement);
+        this.statement = statement;
+        this.resultSet = resultSet;
     }
 
     /**
-     * Create a wrapper for the ResultSet which traces this
-     * ResultSet to the Connection which created it (via, for
+     * Creates a wrapper for the ResultSet which traces this ResultSet to the Connection which created it (via, for
      * example DatabaseMetadata, and the code which created it.
      * <p>
-     * Private to ensure all construction is
-     * {@link #wrapResultSet(Connection, ResultSet)}
+     * Private to ensure all construction is {@link #wrapResultSet(Connection, ResultSet)}
+     * </p>
      *
-     * @param conn Connection which created this ResultSet
-     * @param res ResultSet to wrap
+     * @param conn
+     *            Connection which created this ResultSet
+     * @param res
+     *            ResultSet to wrap
      */
     private DelegatingResultSet(final Connection conn, final ResultSet res) {
-        super((AbandonedTrace)conn);
-        this._conn = conn;
-        this._res = res;
+        super((AbandonedTrace) conn);
+        this.connection = conn;
+        this.resultSet = res;
     }
 
-    public static ResultSet wrapResultSet(final Statement stmt, final ResultSet rset) {
-        if(null == rset) {
+    /**
+     * Wraps the given result set in a delegate.
+     *
+     * @param statement
+     *            The Statement which created the ResultSet.
+     * @param resultSet
+     *            The ResultSet to wrap.
+     * @return a new delegate.
+     */
+    public static ResultSet wrapResultSet(final Statement statement, final ResultSet resultSet) {
+        if (null == resultSet) {
             return null;
         }
-        return new DelegatingResultSet(stmt,rset);
+        return new DelegatingResultSet(statement, resultSet);
     }
 
-    public static ResultSet wrapResultSet(final Connection conn, final ResultSet rset) {
-        if(null == rset) {
+    /**
+     * Wraps the given result set in a delegate.
+     *
+     * @param connection
+     *            The Connection which created the ResultSet.
+     * @param resultSet
+     *            The ResultSet to wrap.
+     * @return a new delegate.
+     */
+    public static ResultSet wrapResultSet(final Connection connection, final ResultSet resultSet) {
+        if (null == resultSet) {
             return null;
         }
-        return new DelegatingResultSet(conn,rset);
+        return new DelegatingResultSet(connection, resultSet);
     }
 
+    /**
+     * Gets my delegate.
+     *
+     * @return my delegate.
+     */
     public ResultSet getDelegate() {
-        return _res;
+        return resultSet;
     }
 
     /**
-     * If my underlying {@link ResultSet} is not a
-     * {@code DelegatingResultSet}, returns it,
-     * otherwise recursively invokes this method on
-     * my delegate.
+     * If my underlying {@link ResultSet} is not a {@code DelegatingResultSet}, returns it, otherwise recursively
+     * invokes this method on my delegate.
      * <p>
-     * Hence this method will return the first
-     * delegate that is not a {@code DelegatingResultSet},
-     * or {@code null} when no non-{@code DelegatingResultSet}
-     * delegate can be found by traversing this chain.
+     * Hence this method will return the first delegate that is not a {@code DelegatingResultSet}, or {@code null} when
+     * no non-{@code DelegatingResultSet} delegate can be found by traversing this chain.
+     * </p>
      * <p>
-     * This method is useful when you may have nested
-     * {@code DelegatingResultSet}s, and you want to make
-     * sure to obtain a "genuine" {@link ResultSet}.
-     * @return the result set
+     * This method is useful when you may have nested {@code DelegatingResultSet}s, and you want to make sure to obtain
+     * a "genuine" {@link ResultSet}.
+     * </p>
+     *
+     * @return the innermost delegate.
      */
     public ResultSet getInnermostDelegate() {
-        ResultSet r = _res;
-        while(r != null && r instanceof DelegatingResultSet) {
-            r = ((DelegatingResultSet)r).getDelegate();
-            if(this == r) {
+        ResultSet r = resultSet;
+        while (r != null && r instanceof DelegatingResultSet) {
+            r = ((DelegatingResultSet) r).getDelegate();
+            if (this == r) {
                 return null;
             }
         }
@@ -148,610 +167,1369 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
 
     @Override
     public Statement getStatement() throws SQLException {
-        return _stmt;
+        return statement;
     }
 
     /**
-     * Wrapper for close of ResultSet which removes this
-     * result set from being traced then calls close on
-     * the original ResultSet.
+     * Wrapper for close of ResultSet which removes this result set from being traced then calls close on the original
+     * ResultSet.
      */
     @Override
     public void close() throws SQLException {
         try {
-            if(_stmt != null) {
-                ((AbandonedTrace)_stmt).removeTrace(this);
-                _stmt = null;
+            if (statement != null) {
+                ((AbandonedTrace) statement).removeTrace(this);
+                statement = null;
             }
-            if(_conn != null) {
-                ((AbandonedTrace)_conn).removeTrace(this);
-                _conn = null;
+            if (connection != null) {
+                ((AbandonedTrace) connection).removeTrace(this);
+                connection = null;
             }
-            _res.close();
-        }
-        catch (final SQLException e) {
+            resultSet.close();
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     protected void handleException(final SQLException e) throws SQLException {
-        if (_stmt != null && _stmt instanceof DelegatingStatement) {
-            ((DelegatingStatement)_stmt).handleException(e);
-        }
-        else if (_conn != null && _conn instanceof DelegatingConnection) {
-            ((DelegatingConnection<?>)_conn).handleException(e);
-        }
-        else {
+        if (statement != null && statement instanceof DelegatingStatement) {
+            ((DelegatingStatement) statement).handleException(e);
+        } else if (connection != null && connection instanceof DelegatingConnection) {
+            ((DelegatingConnection<?>) connection).handleException(e);
+        } else {
             throw e;
         }
     }
 
     @Override
-    public boolean next() throws SQLException
-    { try { return _res.next(); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean next() throws SQLException {
+        try {
+            return resultSet.next();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public boolean wasNull() throws SQLException
-    { try { return _res.wasNull(); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean wasNull() throws SQLException {
+        try {
+            return resultSet.wasNull();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public String getString(final int columnIndex) throws SQLException
-    { try { return _res.getString(columnIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public String getString(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getString(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public boolean getBoolean(final int columnIndex) throws SQLException
-    { try { return _res.getBoolean(columnIndex); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean getBoolean(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getBoolean(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public byte getByte(final int columnIndex) throws SQLException
-    { try { return _res.getByte(columnIndex); } catch (final SQLException e) { handleException(e); return 0; } }
+    public byte getByte(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getByte(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public short getShort(final int columnIndex) throws SQLException
-    { try { return _res.getShort(columnIndex); } catch (final SQLException e) { handleException(e); return 0; } }
+    public short getShort(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getShort(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public int getInt(final int columnIndex) throws SQLException
-    { try { return _res.getInt(columnIndex); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getInt(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getInt(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public long getLong(final int columnIndex) throws SQLException
-    { try { return _res.getLong(columnIndex); } catch (final SQLException e) { handleException(e); return 0; } }
+    public long getLong(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getLong(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public float getFloat(final int columnIndex) throws SQLException
-    { try { return _res.getFloat(columnIndex); } catch (final SQLException e) { handleException(e); return 0; } }
+    public float getFloat(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getFloat(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public double getDouble(final int columnIndex) throws SQLException
-    { try { return _res.getDouble(columnIndex); } catch (final SQLException e) { handleException(e); return 0; } }
+    public double getDouble(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getDouble(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     /** @deprecated Use {@link #getBigDecimal(int)} */
     @Deprecated
     @Override
-    public BigDecimal getBigDecimal(final int columnIndex, final int scale) throws SQLException
-    { try { return _res.getBigDecimal(columnIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public BigDecimal getBigDecimal(final int columnIndex, final int scale) throws SQLException {
+        try {
+            return resultSet.getBigDecimal(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public byte[] getBytes(final int columnIndex) throws SQLException
-    { try { return _res.getBytes(columnIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public byte[] getBytes(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getBytes(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Date getDate(final int columnIndex) throws SQLException
-    { try { return _res.getDate(columnIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public Date getDate(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getDate(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Time getTime(final int columnIndex) throws SQLException
-    { try { return _res.getTime(columnIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public Time getTime(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getTime(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Timestamp getTimestamp(final int columnIndex) throws SQLException
-    { try { return _res.getTimestamp(columnIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public Timestamp getTimestamp(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getTimestamp(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public InputStream getAsciiStream(final int columnIndex) throws SQLException
-    { try { return _res.getAsciiStream(columnIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public InputStream getAsciiStream(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getAsciiStream(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     /** @deprecated Use {@link #getCharacterStream(int)} */
     @Deprecated
     @Override
-    public InputStream getUnicodeStream(final int columnIndex) throws SQLException
-    { try { return _res.getUnicodeStream(columnIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public InputStream getUnicodeStream(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getUnicodeStream(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public InputStream getBinaryStream(final int columnIndex) throws SQLException
-    { try { return _res.getBinaryStream(columnIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public InputStream getBinaryStream(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getBinaryStream(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public String getString(final String columnName) throws SQLException
-    { try { return _res.getString(columnName); } catch (final SQLException e) { handleException(e); return null; } }
+    public String getString(final String columnName) throws SQLException {
+        try {
+            return resultSet.getString(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public boolean getBoolean(final String columnName) throws SQLException
-    { try { return _res.getBoolean(columnName); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean getBoolean(final String columnName) throws SQLException {
+        try {
+            return resultSet.getBoolean(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public byte getByte(final String columnName) throws SQLException
-    { try { return _res.getByte(columnName); } catch (final SQLException e) { handleException(e); return 0; } }
+    public byte getByte(final String columnName) throws SQLException {
+        try {
+            return resultSet.getByte(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public short getShort(final String columnName) throws SQLException
-    { try { return _res.getShort(columnName); } catch (final SQLException e) { handleException(e); return 0; } }
+    public short getShort(final String columnName) throws SQLException {
+        try {
+            return resultSet.getShort(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public int getInt(final String columnName) throws SQLException
-    { try { return _res.getInt(columnName); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getInt(final String columnName) throws SQLException {
+        try {
+            return resultSet.getInt(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public long getLong(final String columnName) throws SQLException
-    { try { return _res.getLong(columnName); } catch (final SQLException e) { handleException(e); return 0; } }
+    public long getLong(final String columnName) throws SQLException {
+        try {
+            return resultSet.getLong(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public float getFloat(final String columnName) throws SQLException
-    { try { return _res.getFloat(columnName); } catch (final SQLException e) { handleException(e); return 0; } }
+    public float getFloat(final String columnName) throws SQLException {
+        try {
+            return resultSet.getFloat(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public double getDouble(final String columnName) throws SQLException
-    { try { return _res.getDouble(columnName); } catch (final SQLException e) { handleException(e); return 0; } }
+    public double getDouble(final String columnName) throws SQLException {
+        try {
+            return resultSet.getDouble(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     /** @deprecated Use {@link #getBigDecimal(String)} */
     @Deprecated
     @Override
-    public BigDecimal getBigDecimal(final String columnName, final int scale) throws SQLException
-    { try { return _res.getBigDecimal(columnName); } catch (final SQLException e) { handleException(e); return null; } }
+    public BigDecimal getBigDecimal(final String columnName, final int scale) throws SQLException {
+        try {
+            return resultSet.getBigDecimal(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public byte[] getBytes(final String columnName) throws SQLException
-    { try { return _res.getBytes(columnName); } catch (final SQLException e) { handleException(e); return null; } }
+    public byte[] getBytes(final String columnName) throws SQLException {
+        try {
+            return resultSet.getBytes(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Date getDate(final String columnName) throws SQLException
-    { try { return _res.getDate(columnName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Date getDate(final String columnName) throws SQLException {
+        try {
+            return resultSet.getDate(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Time getTime(final String columnName) throws SQLException
-    { try { return _res.getTime(columnName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Time getTime(final String columnName) throws SQLException {
+        try {
+            return resultSet.getTime(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Timestamp getTimestamp(final String columnName) throws SQLException
-    { try { return _res.getTimestamp(columnName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Timestamp getTimestamp(final String columnName) throws SQLException {
+        try {
+            return resultSet.getTimestamp(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public InputStream getAsciiStream(final String columnName) throws SQLException
-    { try { return _res.getAsciiStream(columnName); } catch (final SQLException e) { handleException(e); return null; } }
+    public InputStream getAsciiStream(final String columnName) throws SQLException {
+        try {
+            return resultSet.getAsciiStream(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     /** @deprecated Use {@link #getCharacterStream(String)} */
     @Deprecated
     @Override
-    public InputStream getUnicodeStream(final String columnName) throws SQLException
-    { try { return _res.getUnicodeStream(columnName); } catch (final SQLException e) { handleException(e); return null; } }
+    public InputStream getUnicodeStream(final String columnName) throws SQLException {
+        try {
+            return resultSet.getUnicodeStream(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public InputStream getBinaryStream(final String columnName) throws SQLException
-    { try { return _res.getBinaryStream(columnName); } catch (final SQLException e) { handleException(e); return null; } }
+    public InputStream getBinaryStream(final String columnName) throws SQLException {
+        try {
+            return resultSet.getBinaryStream(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public SQLWarning getWarnings() throws SQLException
-    { try { return _res.getWarnings(); } catch (final SQLException e) { handleException(e); return null; } }
+    public SQLWarning getWarnings() throws SQLException {
+        try {
+            return resultSet.getWarnings();
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public void clearWarnings() throws SQLException
-    { try { _res.clearWarnings(); } catch (final SQLException e) { handleException(e); } }
+    public void clearWarnings() throws SQLException {
+        try {
+            resultSet.clearWarnings();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public String getCursorName() throws SQLException
-    { try { return _res.getCursorName(); } catch (final SQLException e) { handleException(e); return null; } }
+    public String getCursorName() throws SQLException {
+        try {
+            return resultSet.getCursorName();
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public ResultSetMetaData getMetaData() throws SQLException
-    { try { return _res.getMetaData(); } catch (final SQLException e) { handleException(e); return null; } }
+    public ResultSetMetaData getMetaData() throws SQLException {
+        try {
+            return resultSet.getMetaData();
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Object getObject(final int columnIndex) throws SQLException
-    { try { return _res.getObject(columnIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public Object getObject(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getObject(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Object getObject(final String columnName) throws SQLException
-    { try { return _res.getObject(columnName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Object getObject(final String columnName) throws SQLException {
+        try {
+            return resultSet.getObject(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public int findColumn(final String columnName) throws SQLException
-    { try { return _res.findColumn(columnName); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int findColumn(final String columnName) throws SQLException {
+        try {
+            return resultSet.findColumn(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public Reader getCharacterStream(final int columnIndex) throws SQLException
-    { try { return _res.getCharacterStream(columnIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public Reader getCharacterStream(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getCharacterStream(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Reader getCharacterStream(final String columnName) throws SQLException
-    { try { return _res.getCharacterStream(columnName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Reader getCharacterStream(final String columnName) throws SQLException {
+        try {
+            return resultSet.getCharacterStream(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public BigDecimal getBigDecimal(final int columnIndex) throws SQLException
-    { try { return _res.getBigDecimal(columnIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public BigDecimal getBigDecimal(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getBigDecimal(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public BigDecimal getBigDecimal(final String columnName) throws SQLException
-    { try { return _res.getBigDecimal(columnName); } catch (final SQLException e) { handleException(e); return null; } }
+    public BigDecimal getBigDecimal(final String columnName) throws SQLException {
+        try {
+            return resultSet.getBigDecimal(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public boolean isBeforeFirst() throws SQLException
-    { try { return _res.isBeforeFirst(); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean isBeforeFirst() throws SQLException {
+        try {
+            return resultSet.isBeforeFirst();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public boolean isAfterLast() throws SQLException
-    { try { return _res.isAfterLast(); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean isAfterLast() throws SQLException {
+        try {
+            return resultSet.isAfterLast();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public boolean isFirst() throws SQLException
-    { try { return _res.isFirst(); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean isFirst() throws SQLException {
+        try {
+            return resultSet.isFirst();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public boolean isLast() throws SQLException
-    { try { return _res.isLast(); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean isLast() throws SQLException {
+        try {
+            return resultSet.isLast();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public void beforeFirst() throws SQLException
-    { try { _res.beforeFirst(); } catch (final SQLException e) { handleException(e); } }
+    public void beforeFirst() throws SQLException {
+        try {
+            resultSet.beforeFirst();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void afterLast() throws SQLException
-    { try { _res.afterLast(); } catch (final SQLException e) { handleException(e); } }
+    public void afterLast() throws SQLException {
+        try {
+            resultSet.afterLast();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public boolean first() throws SQLException
-    { try { return _res.first(); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean first() throws SQLException {
+        try {
+            return resultSet.first();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public boolean last() throws SQLException
-    { try { return _res.last(); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean last() throws SQLException {
+        try {
+            return resultSet.last();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public int getRow() throws SQLException
-    { try { return _res.getRow(); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getRow() throws SQLException {
+        try {
+            return resultSet.getRow();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public boolean absolute(final int row) throws SQLException
-    { try { return _res.absolute(row); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean absolute(final int row) throws SQLException {
+        try {
+            return resultSet.absolute(row);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public boolean relative(final int rows) throws SQLException
-    { try { return _res.relative(rows); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean relative(final int rows) throws SQLException {
+        try {
+            return resultSet.relative(rows);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public boolean previous() throws SQLException
-    { try { return _res.previous(); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean previous() throws SQLException {
+        try {
+            return resultSet.previous();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public void setFetchDirection(final int direction) throws SQLException
-    { try { _res.setFetchDirection(direction); } catch (final SQLException e) { handleException(e); } }
+    public void setFetchDirection(final int direction) throws SQLException {
+        try {
+            resultSet.setFetchDirection(direction);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public int getFetchDirection() throws SQLException
-    { try { return _res.getFetchDirection(); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getFetchDirection() throws SQLException {
+        try {
+            return resultSet.getFetchDirection();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public void setFetchSize(final int rows) throws SQLException
-    { try { _res.setFetchSize(rows); } catch (final SQLException e) { handleException(e); } }
+    public void setFetchSize(final int rows) throws SQLException {
+        try {
+            resultSet.setFetchSize(rows);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public int getFetchSize() throws SQLException
-    { try { return _res.getFetchSize(); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getFetchSize() throws SQLException {
+        try {
+            return resultSet.getFetchSize();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public int getType() throws SQLException
-    { try { return _res.getType(); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getType() throws SQLException {
+        try {
+            return resultSet.getType();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public int getConcurrency() throws SQLException
-    { try { return _res.getConcurrency(); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getConcurrency() throws SQLException {
+        try {
+            return resultSet.getConcurrency();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public boolean rowUpdated() throws SQLException
-    { try { return _res.rowUpdated(); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean rowUpdated() throws SQLException {
+        try {
+            return resultSet.rowUpdated();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public boolean rowInserted() throws SQLException
-    { try { return _res.rowInserted(); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean rowInserted() throws SQLException {
+        try {
+            return resultSet.rowInserted();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public boolean rowDeleted() throws SQLException
-    { try { return _res.rowDeleted(); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean rowDeleted() throws SQLException {
+        try {
+            return resultSet.rowDeleted();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public void updateNull(final int columnIndex) throws SQLException
-    { try { _res.updateNull(columnIndex); } catch (final SQLException e) { handleException(e); } }
+    public void updateNull(final int columnIndex) throws SQLException {
+        try {
+            resultSet.updateNull(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateBoolean(final int columnIndex, final boolean x) throws SQLException
-    { try { _res.updateBoolean(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateBoolean(final int columnIndex, final boolean x) throws SQLException {
+        try {
+            resultSet.updateBoolean(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateByte(final int columnIndex, final byte x) throws SQLException
-    { try { _res.updateByte(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateByte(final int columnIndex, final byte x) throws SQLException {
+        try {
+            resultSet.updateByte(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateShort(final int columnIndex, final short x) throws SQLException
-    { try { _res.updateShort(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateShort(final int columnIndex, final short x) throws SQLException {
+        try {
+            resultSet.updateShort(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateInt(final int columnIndex, final int x) throws SQLException
-    { try { _res.updateInt(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateInt(final int columnIndex, final int x) throws SQLException {
+        try {
+            resultSet.updateInt(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateLong(final int columnIndex, final long x) throws SQLException
-    { try { _res.updateLong(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateLong(final int columnIndex, final long x) throws SQLException {
+        try {
+            resultSet.updateLong(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateFloat(final int columnIndex, final float x) throws SQLException
-    { try { _res.updateFloat(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateFloat(final int columnIndex, final float x) throws SQLException {
+        try {
+            resultSet.updateFloat(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateDouble(final int columnIndex, final double x) throws SQLException
-    { try { _res.updateDouble(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateDouble(final int columnIndex, final double x) throws SQLException {
+        try {
+            resultSet.updateDouble(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateBigDecimal(final int columnIndex, final BigDecimal x) throws SQLException
-    { try { _res.updateBigDecimal(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateBigDecimal(final int columnIndex, final BigDecimal x) throws SQLException {
+        try {
+            resultSet.updateBigDecimal(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateString(final int columnIndex, final String x) throws SQLException
-    { try { _res.updateString(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateString(final int columnIndex, final String x) throws SQLException {
+        try {
+            resultSet.updateString(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateBytes(final int columnIndex, final byte[] x) throws SQLException
-    { try { _res.updateBytes(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateBytes(final int columnIndex, final byte[] x) throws SQLException {
+        try {
+            resultSet.updateBytes(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateDate(final int columnIndex, final Date x) throws SQLException
-    { try { _res.updateDate(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateDate(final int columnIndex, final Date x) throws SQLException {
+        try {
+            resultSet.updateDate(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateTime(final int columnIndex, final Time x) throws SQLException
-    { try { _res.updateTime(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateTime(final int columnIndex, final Time x) throws SQLException {
+        try {
+            resultSet.updateTime(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateTimestamp(final int columnIndex, final Timestamp x) throws SQLException
-    { try { _res.updateTimestamp(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateTimestamp(final int columnIndex, final Timestamp x) throws SQLException {
+        try {
+            resultSet.updateTimestamp(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateAsciiStream(final int columnIndex, final InputStream x, final int length) throws SQLException
-    { try { _res.updateAsciiStream(columnIndex, x, length); } catch (final SQLException e) { handleException(e); } }
+    public void updateAsciiStream(final int columnIndex, final InputStream x, final int length) throws SQLException {
+        try {
+            resultSet.updateAsciiStream(columnIndex, x, length);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateBinaryStream(final int columnIndex, final InputStream x, final int length) throws SQLException
-    { try { _res.updateBinaryStream(columnIndex, x, length); } catch (final SQLException e) { handleException(e); } }
+    public void updateBinaryStream(final int columnIndex, final InputStream x, final int length) throws SQLException {
+        try {
+            resultSet.updateBinaryStream(columnIndex, x, length);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateCharacterStream(final int columnIndex, final Reader x, final int length) throws SQLException
-    { try { _res.updateCharacterStream(columnIndex, x, length); } catch (final SQLException e) { handleException(e); } }
+    public void updateCharacterStream(final int columnIndex, final Reader x, final int length) throws SQLException {
+        try {
+            resultSet.updateCharacterStream(columnIndex, x, length);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateObject(final int columnIndex, final Object x, final int scale) throws SQLException
-    { try { _res.updateObject(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateObject(final int columnIndex, final Object x, final int scale) throws SQLException {
+        try {
+            resultSet.updateObject(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateObject(final int columnIndex, final Object x) throws SQLException
-    { try { _res.updateObject(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateObject(final int columnIndex, final Object x) throws SQLException {
+        try {
+            resultSet.updateObject(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateNull(final String columnName) throws SQLException
-    { try { _res.updateNull(columnName); } catch (final SQLException e) { handleException(e); } }
+    public void updateNull(final String columnName) throws SQLException {
+        try {
+            resultSet.updateNull(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateBoolean(final String columnName, final boolean x) throws SQLException
-    { try { _res.updateBoolean(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateBoolean(final String columnName, final boolean x) throws SQLException {
+        try {
+            resultSet.updateBoolean(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateByte(final String columnName, final byte x) throws SQLException
-    { try { _res.updateByte(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateByte(final String columnName, final byte x) throws SQLException {
+        try {
+            resultSet.updateByte(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateShort(final String columnName, final short x) throws SQLException
-    { try { _res.updateShort(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateShort(final String columnName, final short x) throws SQLException {
+        try {
+            resultSet.updateShort(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateInt(final String columnName, final int x) throws SQLException
-    { try { _res.updateInt(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateInt(final String columnName, final int x) throws SQLException {
+        try {
+            resultSet.updateInt(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateLong(final String columnName, final long x) throws SQLException
-    { try { _res.updateLong(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateLong(final String columnName, final long x) throws SQLException {
+        try {
+            resultSet.updateLong(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateFloat(final String columnName, final float x) throws SQLException
-    { try { _res.updateFloat(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateFloat(final String columnName, final float x) throws SQLException {
+        try {
+            resultSet.updateFloat(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateDouble(final String columnName, final double x) throws SQLException
-    { try { _res.updateDouble(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateDouble(final String columnName, final double x) throws SQLException {
+        try {
+            resultSet.updateDouble(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateBigDecimal(final String columnName, final BigDecimal x) throws SQLException
-    { try { _res.updateBigDecimal(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateBigDecimal(final String columnName, final BigDecimal x) throws SQLException {
+        try {
+            resultSet.updateBigDecimal(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateString(final String columnName, final String x) throws SQLException
-    { try { _res.updateString(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateString(final String columnName, final String x) throws SQLException {
+        try {
+            resultSet.updateString(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateBytes(final String columnName, final byte[] x) throws SQLException
-    { try { _res.updateBytes(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateBytes(final String columnName, final byte[] x) throws SQLException {
+        try {
+            resultSet.updateBytes(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateDate(final String columnName, final Date x) throws SQLException
-    { try { _res.updateDate(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateDate(final String columnName, final Date x) throws SQLException {
+        try {
+            resultSet.updateDate(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateTime(final String columnName, final Time x) throws SQLException
-    { try { _res.updateTime(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateTime(final String columnName, final Time x) throws SQLException {
+        try {
+            resultSet.updateTime(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateTimestamp(final String columnName, final Timestamp x) throws SQLException
-    { try { _res.updateTimestamp(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateTimestamp(final String columnName, final Timestamp x) throws SQLException {
+        try {
+            resultSet.updateTimestamp(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateAsciiStream(final String columnName, final InputStream x, final int length) throws SQLException
-    { try { _res.updateAsciiStream(columnName, x, length); } catch (final SQLException e) { handleException(e); } }
+    public void updateAsciiStream(final String columnName, final InputStream x, final int length) throws SQLException {
+        try {
+            resultSet.updateAsciiStream(columnName, x, length);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateBinaryStream(final String columnName, final InputStream x, final int length) throws SQLException
-    { try { _res.updateBinaryStream(columnName, x, length); } catch (final SQLException e) { handleException(e); } }
+    public void updateBinaryStream(final String columnName, final InputStream x, final int length) throws SQLException {
+        try {
+            resultSet.updateBinaryStream(columnName, x, length);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateCharacterStream(final String columnName, final Reader reader, final int length) throws SQLException
-    { try { _res.updateCharacterStream(columnName, reader, length); } catch (final SQLException e) { handleException(e); } }
+    public void updateCharacterStream(final String columnName, final Reader reader, final int length)
+            throws SQLException {
+        try {
+            resultSet.updateCharacterStream(columnName, reader, length);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateObject(final String columnName, final Object x, final int scale) throws SQLException
-    { try { _res.updateObject(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateObject(final String columnName, final Object x, final int scale) throws SQLException {
+        try {
+            resultSet.updateObject(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateObject(final String columnName, final Object x) throws SQLException
-    { try { _res.updateObject(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateObject(final String columnName, final Object x) throws SQLException {
+        try {
+            resultSet.updateObject(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void insertRow() throws SQLException
-    { try { _res.insertRow(); } catch (final SQLException e) { handleException(e); } }
+    public void insertRow() throws SQLException {
+        try {
+            resultSet.insertRow();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateRow() throws SQLException
-    { try { _res.updateRow(); } catch (final SQLException e) { handleException(e); } }
+    public void updateRow() throws SQLException {
+        try {
+            resultSet.updateRow();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void deleteRow() throws SQLException
-    { try { _res.deleteRow(); } catch (final SQLException e) { handleException(e); } }
+    public void deleteRow() throws SQLException {
+        try {
+            resultSet.deleteRow();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void refreshRow() throws SQLException
-    { try { _res.refreshRow(); } catch (final SQLException e) { handleException(e); } }
+    public void refreshRow() throws SQLException {
+        try {
+            resultSet.refreshRow();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void cancelRowUpdates() throws SQLException
-    { try { _res.cancelRowUpdates(); } catch (final SQLException e) { handleException(e); } }
+    public void cancelRowUpdates() throws SQLException {
+        try {
+            resultSet.cancelRowUpdates();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void moveToInsertRow() throws SQLException
-    { try { _res.moveToInsertRow(); } catch (final SQLException e) { handleException(e); } }
+    public void moveToInsertRow() throws SQLException {
+        try {
+            resultSet.moveToInsertRow();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void moveToCurrentRow() throws SQLException
-    { try { _res.moveToCurrentRow(); } catch (final SQLException e) { handleException(e); } }
+    public void moveToCurrentRow() throws SQLException {
+        try {
+            resultSet.moveToCurrentRow();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public Object getObject(final int i, final Map<String,Class<?>> map) throws SQLException
-    { try { return _res.getObject(i, map); } catch (final SQLException e) { handleException(e); return null; } }
+    public Object getObject(final int i, final Map<String, Class<?>> map) throws SQLException {
+        try {
+            return resultSet.getObject(i, map);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Ref getRef(final int i) throws SQLException
-    { try { return _res.getRef(i); } catch (final SQLException e) { handleException(e); return null; } }
+    public Ref getRef(final int i) throws SQLException {
+        try {
+            return resultSet.getRef(i);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Blob getBlob(final int i) throws SQLException
-    { try { return _res.getBlob(i); } catch (final SQLException e) { handleException(e); return null; } }
+    public Blob getBlob(final int i) throws SQLException {
+        try {
+            return resultSet.getBlob(i);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Clob getClob(final int i) throws SQLException
-    { try { return _res.getClob(i); } catch (final SQLException e) { handleException(e); return null; } }
+    public Clob getClob(final int i) throws SQLException {
+        try {
+            return resultSet.getClob(i);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Array getArray(final int i) throws SQLException
-    { try { return _res.getArray(i); } catch (final SQLException e) { handleException(e); return null; } }
+    public Array getArray(final int i) throws SQLException {
+        try {
+            return resultSet.getArray(i);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Object getObject(final String colName, final Map<String,Class<?>> map) throws SQLException
-    { try { return _res.getObject(colName, map); } catch (final SQLException e) { handleException(e); return null; } }
+    public Object getObject(final String colName, final Map<String, Class<?>> map) throws SQLException {
+        try {
+            return resultSet.getObject(colName, map);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Ref getRef(final String colName) throws SQLException
-    { try { return _res.getRef(colName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Ref getRef(final String colName) throws SQLException {
+        try {
+            return resultSet.getRef(colName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Blob getBlob(final String colName) throws SQLException
-    { try { return _res.getBlob(colName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Blob getBlob(final String colName) throws SQLException {
+        try {
+            return resultSet.getBlob(colName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Clob getClob(final String colName) throws SQLException
-    { try { return _res.getClob(colName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Clob getClob(final String colName) throws SQLException {
+        try {
+            return resultSet.getClob(colName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Array getArray(final String colName) throws SQLException
-    { try { return _res.getArray(colName); } catch (final SQLException e) { handleException(e); return null; } }
+    public Array getArray(final String colName) throws SQLException {
+        try {
+            return resultSet.getArray(colName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Date getDate(final int columnIndex, final Calendar cal) throws SQLException
-    { try { return _res.getDate(columnIndex, cal); } catch (final SQLException e) { handleException(e); return null; } }
+    public Date getDate(final int columnIndex, final Calendar cal) throws SQLException {
+        try {
+            return resultSet.getDate(columnIndex, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Date getDate(final String columnName, final Calendar cal) throws SQLException
-    { try { return _res.getDate(columnName, cal); } catch (final SQLException e) { handleException(e); return null; } }
+    public Date getDate(final String columnName, final Calendar cal) throws SQLException {
+        try {
+            return resultSet.getDate(columnName, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Time getTime(final int columnIndex, final Calendar cal) throws SQLException
-    { try { return _res.getTime(columnIndex, cal); } catch (final SQLException e) { handleException(e); return null; } }
+    public Time getTime(final int columnIndex, final Calendar cal) throws SQLException {
+        try {
+            return resultSet.getTime(columnIndex, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Time getTime(final String columnName, final Calendar cal) throws SQLException
-    { try { return _res.getTime(columnName, cal); } catch (final SQLException e) { handleException(e); return null; } }
+    public Time getTime(final String columnName, final Calendar cal) throws SQLException {
+        try {
+            return resultSet.getTime(columnName, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Timestamp getTimestamp(final int columnIndex, final Calendar cal) throws SQLException
-    { try { return _res.getTimestamp(columnIndex, cal); } catch (final SQLException e) { handleException(e); return null; } }
+    public Timestamp getTimestamp(final int columnIndex, final Calendar cal) throws SQLException {
+        try {
+            return resultSet.getTimestamp(columnIndex, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public Timestamp getTimestamp(final String columnName, final Calendar cal) throws SQLException
-    { try { return _res.getTimestamp(columnName, cal); } catch (final SQLException e) { handleException(e); return null; } }
-
+    public Timestamp getTimestamp(final String columnName, final Calendar cal) throws SQLException {
+        try {
+            return resultSet.getTimestamp(columnName, cal);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public java.net.URL getURL(final int columnIndex) throws SQLException
-    { try { return _res.getURL(columnIndex); } catch (final SQLException e) { handleException(e); return null; } }
+    public java.net.URL getURL(final int columnIndex) throws SQLException {
+        try {
+            return resultSet.getURL(columnIndex);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public java.net.URL getURL(final String columnName) throws SQLException
-    { try { return _res.getURL(columnName); } catch (final SQLException e) { handleException(e); return null; } }
+    public java.net.URL getURL(final String columnName) throws SQLException {
+        try {
+            return resultSet.getURL(columnName);
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
+        }
+    }
 
     @Override
-    public void updateRef(final int columnIndex, final Ref x) throws SQLException
-    { try { _res.updateRef(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateRef(final int columnIndex, final Ref x) throws SQLException {
+        try {
+            resultSet.updateRef(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateRef(final String columnName, final Ref x) throws SQLException
-    { try { _res.updateRef(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateRef(final String columnName, final Ref x) throws SQLException {
+        try {
+            resultSet.updateRef(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateBlob(final int columnIndex, final Blob x) throws SQLException
-    { try { _res.updateBlob(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateBlob(final int columnIndex, final Blob x) throws SQLException {
+        try {
+            resultSet.updateBlob(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateBlob(final String columnName, final Blob x) throws SQLException
-    { try { _res.updateBlob(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateBlob(final String columnName, final Blob x) throws SQLException {
+        try {
+            resultSet.updateBlob(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateClob(final int columnIndex, final Clob x) throws SQLException
-    { try { _res.updateClob(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateClob(final int columnIndex, final Clob x) throws SQLException {
+        try {
+            resultSet.updateClob(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateClob(final String columnName, final Clob x) throws SQLException
-    { try { _res.updateClob(columnName, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateClob(final String columnName, final Clob x) throws SQLException {
+        try {
+            resultSet.updateClob(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateArray(final int columnIndex, final Array x) throws SQLException
-    { try { _res.updateArray(columnIndex, x); } catch (final SQLException e) { handleException(e); } }
+    public void updateArray(final int columnIndex, final Array x) throws SQLException {
+        try {
+            resultSet.updateArray(columnIndex, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void updateArray(final String columnName, final Array x) throws SQLException
-    { try { _res.updateArray(columnName, x); } catch (final SQLException e) { handleException(e); } }
-
+    public void updateArray(final String columnName, final Array x) throws SQLException {
+        try {
+            resultSet.updateArray(columnName, x);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
     public boolean isWrapperFor(final Class<?> iface) throws SQLException {
         if (iface.isAssignableFrom(getClass())) {
             return true;
-        } else if (iface.isAssignableFrom(_res.getClass())) {
+        } else if (iface.isAssignableFrom(resultSet.getClass())) {
             return true;
         } else {
-            return _res.isWrapperFor(iface);
+            return resultSet.isWrapperFor(iface);
         }
     }
 
@@ -759,19 +1537,18 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     public <T> T unwrap(final Class<T> iface) throws SQLException {
         if (iface.isAssignableFrom(getClass())) {
             return iface.cast(this);
-        } else if (iface.isAssignableFrom(_res.getClass())) {
-            return iface.cast(_res);
+        } else if (iface.isAssignableFrom(resultSet.getClass())) {
+            return iface.cast(resultSet);
         } else {
-            return _res.unwrap(iface);
+            return resultSet.unwrap(iface);
         }
     }
 
     @Override
     public RowId getRowId(final int columnIndex) throws SQLException {
         try {
-            return _res.getRowId(columnIndex);
-        }
-        catch (final SQLException e) {
+            return resultSet.getRowId(columnIndex);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -780,9 +1557,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public RowId getRowId(final String columnLabel) throws SQLException {
         try {
-            return _res.getRowId(columnLabel);
-        }
-        catch (final SQLException e) {
+            return resultSet.getRowId(columnLabel);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -791,9 +1567,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateRowId(final int columnIndex, final RowId value) throws SQLException {
         try {
-            _res.updateRowId(columnIndex, value);
-        }
-        catch (final SQLException e) {
+            resultSet.updateRowId(columnIndex, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -801,9 +1576,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateRowId(final String columnLabel, final RowId value) throws SQLException {
         try {
-            _res.updateRowId(columnLabel, value);
-        }
-        catch (final SQLException e) {
+            resultSet.updateRowId(columnLabel, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -811,9 +1585,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public int getHoldability() throws SQLException {
         try {
-            return _res.getHoldability();
-        }
-        catch (final SQLException e) {
+            return resultSet.getHoldability();
+        } catch (final SQLException e) {
             handleException(e);
             return 0;
         }
@@ -822,9 +1595,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public boolean isClosed() throws SQLException {
         try {
-            return _res.isClosed();
-        }
-        catch (final SQLException e) {
+            return resultSet.isClosed();
+        } catch (final SQLException e) {
             handleException(e);
             return false;
         }
@@ -833,9 +1605,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateNString(final int columnIndex, final String value) throws SQLException {
         try {
-            _res.updateNString(columnIndex, value);
-        }
-        catch (final SQLException e) {
+            resultSet.updateNString(columnIndex, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -843,9 +1614,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateNString(final String columnLabel, final String value) throws SQLException {
         try {
-            _res.updateNString(columnLabel, value);
-        }
-        catch (final SQLException e) {
+            resultSet.updateNString(columnLabel, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -853,9 +1623,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateNClob(final int columnIndex, final NClob value) throws SQLException {
         try {
-            _res.updateNClob(columnIndex, value);
-        }
-        catch (final SQLException e) {
+            resultSet.updateNClob(columnIndex, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -863,9 +1632,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateNClob(final String columnLabel, final NClob value) throws SQLException {
         try {
-            _res.updateNClob(columnLabel, value);
-        }
-        catch (final SQLException e) {
+            resultSet.updateNClob(columnLabel, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -873,9 +1641,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public NClob getNClob(final int columnIndex) throws SQLException {
         try {
-            return _res.getNClob(columnIndex);
-        }
-        catch (final SQLException e) {
+            return resultSet.getNClob(columnIndex);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -884,9 +1651,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public NClob getNClob(final String columnLabel) throws SQLException {
         try {
-            return _res.getNClob(columnLabel);
-        }
-        catch (final SQLException e) {
+            return resultSet.getNClob(columnLabel);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -895,9 +1661,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public SQLXML getSQLXML(final int columnIndex) throws SQLException {
         try {
-            return _res.getSQLXML(columnIndex);
-        }
-        catch (final SQLException e) {
+            return resultSet.getSQLXML(columnIndex);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -906,9 +1671,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public SQLXML getSQLXML(final String columnLabel) throws SQLException {
         try {
-            return _res.getSQLXML(columnLabel);
-        }
-        catch (final SQLException e) {
+            return resultSet.getSQLXML(columnLabel);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -917,9 +1681,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateSQLXML(final int columnIndex, final SQLXML value) throws SQLException {
         try {
-            _res.updateSQLXML(columnIndex, value);
-        }
-        catch (final SQLException e) {
+            resultSet.updateSQLXML(columnIndex, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -927,9 +1690,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateSQLXML(final String columnLabel, final SQLXML value) throws SQLException {
         try {
-            _res.updateSQLXML(columnLabel, value);
-        }
-        catch (final SQLException e) {
+            resultSet.updateSQLXML(columnLabel, value);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -937,9 +1699,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public String getNString(final int columnIndex) throws SQLException {
         try {
-            return _res.getNString(columnIndex);
-        }
-        catch (final SQLException e) {
+            return resultSet.getNString(columnIndex);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -948,9 +1709,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public String getNString(final String columnLabel) throws SQLException {
         try {
-            return _res.getNString(columnLabel);
-        }
-        catch (final SQLException e) {
+            return resultSet.getNString(columnLabel);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -959,9 +1719,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public Reader getNCharacterStream(final int columnIndex) throws SQLException {
         try {
-            return _res.getNCharacterStream(columnIndex);
-        }
-        catch (final SQLException e) {
+            return resultSet.getNCharacterStream(columnIndex);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -970,110 +1729,109 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public Reader getNCharacterStream(final String columnLabel) throws SQLException {
         try {
-            return _res.getNCharacterStream(columnLabel);
-        }
-        catch (final SQLException e) {
+            return resultSet.getNCharacterStream(columnLabel);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
     @Override
-    public void updateNCharacterStream(final int columnIndex, final Reader reader, final long length) throws SQLException {
+    public void updateNCharacterStream(final int columnIndex, final Reader reader, final long length)
+            throws SQLException {
         try {
-            _res.updateNCharacterStream(columnIndex, reader, length);
-        }
-        catch (final SQLException e) {
+            resultSet.updateNCharacterStream(columnIndex, reader, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateNCharacterStream(final String columnLabel, final Reader reader, final long length) throws SQLException {
+    public void updateNCharacterStream(final String columnLabel, final Reader reader, final long length)
+            throws SQLException {
         try {
-            _res.updateNCharacterStream(columnLabel, reader, length);
-        }
-        catch (final SQLException e) {
+            resultSet.updateNCharacterStream(columnLabel, reader, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateAsciiStream(final int columnIndex, final InputStream inputStream, final long length) throws SQLException {
+    public void updateAsciiStream(final int columnIndex, final InputStream inputStream, final long length)
+            throws SQLException {
         try {
-            _res.updateAsciiStream(columnIndex, inputStream, length);
-        }
-        catch (final SQLException e) {
+            resultSet.updateAsciiStream(columnIndex, inputStream, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateBinaryStream(final int columnIndex, final InputStream inputStream, final long length) throws SQLException {
+    public void updateBinaryStream(final int columnIndex, final InputStream inputStream, final long length)
+            throws SQLException {
         try {
-            _res.updateBinaryStream(columnIndex, inputStream, length);
-        }
-        catch (final SQLException e) {
+            resultSet.updateBinaryStream(columnIndex, inputStream, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateCharacterStream(final int columnIndex, final Reader reader, final long length) throws SQLException {
+    public void updateCharacterStream(final int columnIndex, final Reader reader, final long length)
+            throws SQLException {
         try {
-            _res.updateCharacterStream(columnIndex, reader, length);
-        }
-        catch (final SQLException e) {
+            resultSet.updateCharacterStream(columnIndex, reader, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateAsciiStream(final String columnLabel, final InputStream inputStream, final long length) throws SQLException {
+    public void updateAsciiStream(final String columnLabel, final InputStream inputStream, final long length)
+            throws SQLException {
         try {
-            _res.updateAsciiStream(columnLabel, inputStream, length);
-        }
-        catch (final SQLException e) {
+            resultSet.updateAsciiStream(columnLabel, inputStream, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateBinaryStream(final String columnLabel, final InputStream inputStream, final long length) throws SQLException {
+    public void updateBinaryStream(final String columnLabel, final InputStream inputStream, final long length)
+            throws SQLException {
         try {
-            _res.updateBinaryStream(columnLabel, inputStream, length);
-        }
-        catch (final SQLException e) {
+            resultSet.updateBinaryStream(columnLabel, inputStream, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateCharacterStream(final String columnLabel, final Reader reader, final long length) throws SQLException {
+    public void updateCharacterStream(final String columnLabel, final Reader reader, final long length)
+            throws SQLException {
         try {
-            _res.updateCharacterStream(columnLabel, reader, length);
-        }
-        catch (final SQLException e) {
+            resultSet.updateCharacterStream(columnLabel, reader, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateBlob(final int columnIndex, final InputStream inputStream, final long length) throws SQLException {
+    public void updateBlob(final int columnIndex, final InputStream inputStream, final long length)
+            throws SQLException {
         try {
-            _res.updateBlob(columnIndex, inputStream, length);
-        }
-        catch (final SQLException e) {
+            resultSet.updateBlob(columnIndex, inputStream, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
 
     @Override
-    public void updateBlob(final String columnLabel, final InputStream inputStream, final long length) throws SQLException {
+    public void updateBlob(final String columnLabel, final InputStream inputStream, final long length)
+            throws SQLException {
         try {
-            _res.updateBlob(columnLabel, inputStream, length);
-        }
-        catch (final SQLException e) {
+            resultSet.updateBlob(columnLabel, inputStream, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1081,9 +1839,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateClob(final int columnIndex, final Reader reader, final long length) throws SQLException {
         try {
-            _res.updateClob(columnIndex, reader, length);
-        }
-        catch (final SQLException e) {
+            resultSet.updateClob(columnIndex, reader, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1091,9 +1848,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateClob(final String columnLabel, final Reader reader, final long length) throws SQLException {
         try {
-            _res.updateClob(columnLabel, reader, length);
-        }
-        catch (final SQLException e) {
+            resultSet.updateClob(columnLabel, reader, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1101,9 +1857,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateNClob(final int columnIndex, final Reader reader, final long length) throws SQLException {
         try {
-            _res.updateNClob(columnIndex, reader, length);
-        }
-        catch (final SQLException e) {
+            resultSet.updateNClob(columnIndex, reader, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1111,9 +1866,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateNClob(final String columnLabel, final Reader reader, final long length) throws SQLException {
         try {
-            _res.updateNClob(columnLabel, reader, length);
-        }
-        catch (final SQLException e) {
+            resultSet.updateNClob(columnLabel, reader, length);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1121,9 +1875,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateNCharacterStream(final int columnIndex, final Reader reader) throws SQLException {
         try {
-            _res.updateNCharacterStream(columnIndex, reader);
-        }
-        catch (final SQLException e) {
+            resultSet.updateNCharacterStream(columnIndex, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1131,9 +1884,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateNCharacterStream(final String columnLabel, final Reader reader) throws SQLException {
         try {
-            _res.updateNCharacterStream(columnLabel, reader);
-        }
-        catch (final SQLException e) {
+            resultSet.updateNCharacterStream(columnLabel, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1141,9 +1893,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateAsciiStream(final int columnIndex, final InputStream inputStream) throws SQLException {
         try {
-            _res.updateAsciiStream(columnIndex, inputStream);
-        }
-        catch (final SQLException e) {
+            resultSet.updateAsciiStream(columnIndex, inputStream);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1151,9 +1902,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateBinaryStream(final int columnIndex, final InputStream inputStream) throws SQLException {
         try {
-            _res.updateBinaryStream(columnIndex, inputStream);
-        }
-        catch (final SQLException e) {
+            resultSet.updateBinaryStream(columnIndex, inputStream);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1161,9 +1911,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateCharacterStream(final int columnIndex, final Reader reader) throws SQLException {
         try {
-            _res.updateCharacterStream(columnIndex, reader);
-        }
-        catch (final SQLException e) {
+            resultSet.updateCharacterStream(columnIndex, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1171,9 +1920,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateAsciiStream(final String columnLabel, final InputStream inputStream) throws SQLException {
         try {
-            _res.updateAsciiStream(columnLabel, inputStream);
-        }
-        catch (final SQLException e) {
+            resultSet.updateAsciiStream(columnLabel, inputStream);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1181,9 +1929,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateBinaryStream(final String columnLabel, final InputStream inputStream) throws SQLException {
         try {
-            _res.updateBinaryStream(columnLabel, inputStream);
-        }
-        catch (final SQLException e) {
+            resultSet.updateBinaryStream(columnLabel, inputStream);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1191,9 +1938,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateCharacterStream(final String columnLabel, final Reader reader) throws SQLException {
         try {
-            _res.updateCharacterStream(columnLabel, reader);
-        }
-        catch (final SQLException e) {
+            resultSet.updateCharacterStream(columnLabel, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1201,9 +1947,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateBlob(final int columnIndex, final InputStream inputStream) throws SQLException {
         try {
-            _res.updateBlob(columnIndex, inputStream);
-        }
-        catch (final SQLException e) {
+            resultSet.updateBlob(columnIndex, inputStream);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1211,9 +1956,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateBlob(final String columnLabel, final InputStream inputStream) throws SQLException {
         try {
-            _res.updateBlob(columnLabel, inputStream);
-        }
-        catch (final SQLException e) {
+            resultSet.updateBlob(columnLabel, inputStream);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1221,9 +1965,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateClob(final int columnIndex, final Reader reader) throws SQLException {
         try {
-            _res.updateClob(columnIndex, reader);
-        }
-        catch (final SQLException e) {
+            resultSet.updateClob(columnIndex, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1231,9 +1974,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateClob(final String columnLabel, final Reader reader) throws SQLException {
         try {
-            _res.updateClob(columnLabel, reader);
-        }
-        catch (final SQLException e) {
+            resultSet.updateClob(columnLabel, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1241,9 +1983,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateNClob(final int columnIndex, final Reader reader) throws SQLException {
         try {
-            _res.updateNClob(columnIndex, reader);
-        }
-        catch (final SQLException e) {
+            resultSet.updateNClob(columnIndex, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1251,9 +1992,8 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public void updateNClob(final String columnLabel, final Reader reader) throws SQLException {
         try {
-            _res.updateNClob(columnLabel, reader);
-        }
-        catch (final SQLException e) {
+            resultSet.updateNClob(columnLabel, reader);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -1261,23 +2001,25 @@ public final class DelegatingResultSet extends AbandonedTrace implements ResultS
     @Override
     public <T> T getObject(final int columnIndex, final Class<T> type) throws SQLException {
         try {
-            return _res.getObject(columnIndex, type);
-        }
-        catch (final SQLException e) {
+            return resultSet.getObject(columnIndex, type);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
     @Override
-    public <T> T getObject(final String columnLabel, final Class<T> type)
-            throws SQLException {
+    public <T> T getObject(final String columnLabel, final Class<T> type) throws SQLException {
         try {
-            return _res.getObject(columnLabel, type);
-        }
-        catch (final SQLException e) {
+            return resultSet.getObject(columnLabel, type);
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
+
+    @Override
+    public String toString() {
+        return super.toString() + "[_res=" + resultSet + ", _stmt=" + statement + ", _conn=" + connection + "]";
+    }
 }

==================================================
DriverConnectionFactory.java
index cfaa5861ed..fffc70f031 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DelegatingStatement.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DelegatingStatement.java
@@ -26,74 +26,68 @@ import java.util.List;
 /**
  * A base delegating implementation of {@link Statement}.
  * <p>
- * All of the methods from the {@link Statement} interface
- * simply check to see that the {@link Statement} is active,
- * and call the corresponding method on the "delegate"
- * provided in my constructor.
+ * All of the methods from the {@link Statement} interface simply check to see that the {@link Statement} is active, and
+ * call the corresponding method on the "delegate" provided in my constructor.
  * <p>
- * Extends AbandonedTrace to implement Statement tracking and
- * logging of code which created the Statement. Tracking the
- * Statement ensures that the Connection which created it can
- * close any open Statement's on Connection close.
+ * Extends AbandonedTrace to implement Statement tracking and logging of code which created the Statement. Tracking the
+ * Statement ensures that the Connection which created it can close any open Statement's on Connection close.
  *
- * @author Rodney Waldhoff
- * @author Glenn L. Nielsen
- * @author James House
- * @author Dirk Verbeeck
  * @since 2.0
  */
 public class DelegatingStatement extends AbandonedTrace implements Statement {
+
     /** My delegate. */
-    private Statement _stmt = null;
+    private Statement statement;
+
     /** The connection that created me. **/
-    private DelegatingConnection<?> _conn = null;
+    private DelegatingConnection<?> connection;
 
     /**
-     * Create a wrapper for the Statement which traces this
-     * Statement to the Connection which created it and the
-     * code which created it.
+     * Create a wrapper for the Statement which traces this Statement to the Connection which created it and the code
+     * which created it.
      *
-     * @param s the {@link Statement} to delegate all calls to.
-     * @param c the {@link DelegatingConnection} that created this statement.
+     * @param statement
+     *            the {@link Statement} to delegate all calls to.
+     * @param connection
+     *            the {@link DelegatingConnection} that created this statement.
      */
-    public DelegatingStatement(final DelegatingConnection<?> c, final Statement s) {
-        super(c);
-        _stmt = s;
-        _conn = c;
+    public DelegatingStatement(final DelegatingConnection<?> connection, final Statement statement) {
+        super(connection);
+        this.statement = statement;
+        this.connection = connection;
     }
 
     /**
      * Returns my underlying {@link Statement}.
+     *
      * @return my underlying {@link Statement}.
      * @see #getInnermostDelegate
      */
     public Statement getDelegate() {
-        return _stmt;
+        return statement;
     }
 
-
     /**
-     * If my underlying {@link Statement} is not a
-     * {@code DelegatingStatement}, returns it,
-     * otherwise recursively invokes this method on
-     * my delegate.
+     * If my underlying {@link Statement} is not a {@code DelegatingStatement}, returns it, otherwise recursively
+     * invokes this method on my delegate.
      * <p>
-     * Hence this method will return the first
-     * delegate that is not a {@code DelegatingStatement}
-     * or {@code null} when no non-{@code DelegatingStatement}
-     * delegate can be found by traversing this chain.
+     * Hence this method will return the first delegate that is not a {@code DelegatingStatement} or {@code null} when
+     * no non-{@code DelegatingStatement} delegate can be found by traversing this chain.
+     * </p>
      * <p>
-     * This method is useful when you may have nested
-     * {@code DelegatingStatement}s, and you want to make
-     * sure to obtain a "genuine" {@link Statement}.
+     * This method is useful when you may have nested {@code DelegatingStatement}s, and you want to make sure to obtain
+     * a "genuine" {@link Statement}.
+     * </p>
+     *
+     * @return The innermost delegate.
+     *
      * @see #getDelegate
-     * @return the statement
      */
     public Statement getInnermostDelegate() {
-        Statement s = _stmt;
-        while(s != null && s instanceof DelegatingStatement) {
-            s = ((DelegatingStatement)s).getDelegate();
-            if(this == s) {
+        Statement s = statement;
+        while (s != null && s instanceof DelegatingStatement) {
+            s = ((DelegatingStatement) s).getDelegate();
+            if (this == s) {
                 return null;
             }
         }
@@ -102,33 +96,32 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
 
     /**
      * Sets my delegate.
-     * @param s The statement
+     *
+     * @param statement
+     *            my delegate.
      */
-    public void setDelegate(final Statement s) {
-        _stmt = s;
+    public void setDelegate(final Statement statement) {
+        this.statement = statement;
     }
 
-    private boolean _closed = false;
+    private boolean closed = false;
 
     protected boolean isClosedInternal() {
-        return _closed;
+        return closed;
     }
 
     protected void setClosedInternal(final boolean closed) {
-        this._closed = closed;
+        this.closed = closed;
     }
 
     protected void checkOpen() throws SQLException {
-        if(isClosed()) {
-            throw new SQLException
-                (this.getClass().getName() + " with address: \"" +
-                this.toString() + "\" is closed.");
+        if (isClosed()) {
+            throw new SQLException(this.getClass().getName() + " with address: \"" + this.toString() + "\" is closed.");
         }
     }
 
     /**
-     * Close this DelegatingStatement, and close
-     * any ResultSets that were not explicitly closed.
+     * Close this DelegatingStatement, and close any ResultSets that were not explicitly closed.
      */
     @Override
     public void close() throws SQLException {
@@ -137,9 +130,9 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
         }
         try {
             try {
-                if (_conn != null) {
-                    _conn.removeTrace(this);
-                    _conn = null;
+                if (connection != null) {
+                    connection.removeTrace(this);
+                    connection = null;
                 }
 
                 // The JDBC spec requires that a statement close any open
@@ -147,7 +140,7 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
                 // FIXME The PreparedStatement we're wrapping should handle this for us.
                 // See bug 17301 for what could happen when ResultSets are closed twice.
                 final List<AbandonedTrace> resultSets = getTrace();
-                if( resultSets != null) {
+                if (resultSets != null) {
                     final ResultSet[] set = resultSets.toArray(new ResultSet[resultSets.size()]);
                     for (final ResultSet element : set) {
                         element.close();
@@ -155,38 +148,47 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
                     clearTrace();
                 }
 
-                if (_stmt != null) {
-                    _stmt.close();
+                if (statement != null) {
+                    statement.close();
                 }
-            }
-            catch (final SQLException e) {
+            } catch (final SQLException e) {
                 handleException(e);
             }
-        }
-        finally {
-            _closed = true;
-            _stmt = null;
+        } finally {
+            closed = true;
+            statement = null;
         }
     }
 
     protected void handleException(final SQLException e) throws SQLException {
-        if (_conn != null) {
-            _conn.handleException(e);
-        }
-        else {
+        if (connection != null) {
+            connection.handleException(e);
+        } else {
             throw e;
         }
     }
 
-    protected void activate() throws SQLException {
-        if(_stmt instanceof DelegatingStatement) {
-            ((DelegatingStatement)_stmt).activate();
+    /**
+     *
+     * @throws SQLException
+     *             thrown by the delegating statement.
+     * @since 2.4.0 made public, was protected in 2.3.0.
+     */
+    public void activate() throws SQLException {
+        if (statement instanceof DelegatingStatement) {
+            ((DelegatingStatement) statement).activate();
         }
     }
 
-    protected void passivate() throws SQLException {
-        if(_stmt instanceof DelegatingStatement) {
-            ((DelegatingStatement)_stmt).passivate();
+    /**
+     *
+     * @throws SQLException
+     *             thrown by the delegating statement.
+     * @since 2.4.0 made public, was protected in 2.3.0.
+     */
+    public void passivate() throws SQLException {
+        if (statement instanceof DelegatingStatement) {
+            ((DelegatingStatement) statement).passivate();
         }
     }
 
@@ -197,19 +199,18 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     }
 
     protected DelegatingConnection<?> getConnectionInternal() {
-        return _conn;
+        return connection;
     }
 
     @Override
     public ResultSet executeQuery(final String sql) throws SQLException {
         checkOpen();
-        if (_conn != null) {
-            _conn.setLastUsed();
+        if (connection != null) {
+            connection.setLastUsed();
         }
         try {
-            return DelegatingResultSet.wrapResultSet(this,_stmt.executeQuery(sql));
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(this, statement.executeQuery(sql));
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -219,9 +220,8 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     public ResultSet getResultSet() throws SQLException {
         checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(this,_stmt.getResultSet());
-        }
-        catch (final SQLException e) {
+            return DelegatingResultSet.wrapResultSet(this, statement.getResultSet());
+        } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
         }
@@ -230,68 +230,139 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     @Override
     public int executeUpdate(final String sql) throws SQLException {
         checkOpen();
-        if (_conn != null) {
-            _conn.setLastUsed();
+        if (connection != null) {
+            connection.setLastUsed();
         }
         try {
-            return _stmt.executeUpdate(sql);
+            return statement.executeUpdate(sql);
         } catch (final SQLException e) {
-            handleException(e); return 0;
+            handleException(e);
+            return 0;
         }
     }
 
     @Override
-    public int getMaxFieldSize() throws SQLException
-    { checkOpen(); try { return _stmt.getMaxFieldSize(); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getMaxFieldSize() throws SQLException {
+        checkOpen();
+        try {
+            return statement.getMaxFieldSize();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public void setMaxFieldSize(final int max) throws SQLException
-    { checkOpen(); try { _stmt.setMaxFieldSize(max); } catch (final SQLException e) { handleException(e); } }
+    public void setMaxFieldSize(final int max) throws SQLException {
+        checkOpen();
+        try {
+            statement.setMaxFieldSize(max);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public int getMaxRows() throws SQLException
-    { checkOpen(); try { return _stmt.getMaxRows(); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getMaxRows() throws SQLException {
+        checkOpen();
+        try {
+            return statement.getMaxRows();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public void setMaxRows(final int max) throws SQLException
-    { checkOpen(); try { _stmt.setMaxRows(max); } catch (final SQLException e) { handleException(e); } }
+    public void setMaxRows(final int max) throws SQLException {
+        checkOpen();
+        try {
+            statement.setMaxRows(max);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setEscapeProcessing(final boolean enable) throws SQLException
-    { checkOpen(); try { _stmt.setEscapeProcessing(enable); } catch (final SQLException e) { handleException(e); } }
+    public void setEscapeProcessing(final boolean enable) throws SQLException {
+        checkOpen();
+        try {
+            statement.setEscapeProcessing(enable);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public int getQueryTimeout() throws SQLException
-    { checkOpen(); try { return _stmt.getQueryTimeout(); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getQueryTimeout() throws SQLException {
+        checkOpen();
+        try {
+            return statement.getQueryTimeout();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public void setQueryTimeout(final int seconds) throws SQLException
-    { checkOpen(); try { _stmt.setQueryTimeout(seconds); } catch (final SQLException e) { handleException(e); } }
+    public void setQueryTimeout(final int seconds) throws SQLException {
+        checkOpen();
+        try {
+            statement.setQueryTimeout(seconds);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void cancel() throws SQLException
-    { checkOpen(); try { _stmt.cancel(); } catch (final SQLException e) { handleException(e); } }
+    public void cancel() throws SQLException {
+        checkOpen();
+        try {
+            statement.cancel();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public SQLWarning getWarnings() throws SQLException
-    { checkOpen(); try { return _stmt.getWarnings(); } catch (final SQLException e) { handleException(e); throw new AssertionError(); } }
+    public SQLWarning getWarnings() throws SQLException {
+        checkOpen();
+        try {
+            return statement.getWarnings();
+        } catch (final SQLException e) {
+            handleException(e);
+            throw new AssertionError();
+        }
+    }
 
     @Override
-    public void clearWarnings() throws SQLException
-    { checkOpen(); try { _stmt.clearWarnings(); } catch (final SQLException e) { handleException(e); } }
+    public void clearWarnings() throws SQLException {
+        checkOpen();
+        try {
+            statement.clearWarnings();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void setCursorName(final String name) throws SQLException
-    { checkOpen(); try { _stmt.setCursorName(name); } catch (final SQLException e) { handleException(e); } }
+    public void setCursorName(final String name) throws SQLException {
+        checkOpen();
+        try {
+            statement.setCursorName(name);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
     public boolean execute(final String sql) throws SQLException {
         checkOpen();
-        if (_conn != null) {
-            _conn.setLastUsed();
+        if (connection != null) {
+            connection.setLastUsed();
         }
         try {
-            return _stmt.execute(sql);
+            return statement.execute(sql);
         } catch (final SQLException e) {
             handleException(e);
             return false;
@@ -299,53 +370,119 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     }
 
     @Override
-    public int getUpdateCount() throws SQLException
-    { checkOpen(); try { return _stmt.getUpdateCount(); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getUpdateCount() throws SQLException {
+        checkOpen();
+        try {
+            return statement.getUpdateCount();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public boolean getMoreResults() throws SQLException
-    { checkOpen(); try { return _stmt.getMoreResults(); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean getMoreResults() throws SQLException {
+        checkOpen();
+        try {
+            return statement.getMoreResults();
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
-    public void setFetchDirection(final int direction) throws SQLException
-    { checkOpen(); try { _stmt.setFetchDirection(direction); } catch (final SQLException e) { handleException(e); } }
+    public void setFetchDirection(final int direction) throws SQLException {
+        checkOpen();
+        try {
+            statement.setFetchDirection(direction);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public int getFetchDirection() throws SQLException
-    { checkOpen(); try { return _stmt.getFetchDirection(); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getFetchDirection() throws SQLException {
+        checkOpen();
+        try {
+            return statement.getFetchDirection();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public void setFetchSize(final int rows) throws SQLException
-    { checkOpen(); try { _stmt.setFetchSize(rows); } catch (final SQLException e) { handleException(e); } }
+    public void setFetchSize(final int rows) throws SQLException {
+        checkOpen();
+        try {
+            statement.setFetchSize(rows);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public int getFetchSize() throws SQLException
-    { checkOpen(); try { return _stmt.getFetchSize(); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getFetchSize() throws SQLException {
+        checkOpen();
+        try {
+            return statement.getFetchSize();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public int getResultSetConcurrency() throws SQLException
-    { checkOpen(); try { return _stmt.getResultSetConcurrency(); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getResultSetConcurrency() throws SQLException {
+        checkOpen();
+        try {
+            return statement.getResultSetConcurrency();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public int getResultSetType() throws SQLException
-    { checkOpen(); try { return _stmt.getResultSetType(); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getResultSetType() throws SQLException {
+        checkOpen();
+        try {
+            return statement.getResultSetType();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     @Override
-    public void addBatch(final String sql) throws SQLException
-    { checkOpen(); try { _stmt.addBatch(sql); } catch (final SQLException e) { handleException(e); } }
+    public void addBatch(final String sql) throws SQLException {
+        checkOpen();
+        try {
+            statement.addBatch(sql);
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
-    public void clearBatch() throws SQLException
-    { checkOpen(); try { _stmt.clearBatch(); } catch (final SQLException e) { handleException(e); } }
+    public void clearBatch() throws SQLException {
+        checkOpen();
+        try {
+            statement.clearBatch();
+        } catch (final SQLException e) {
+            handleException(e);
+        }
+    }
 
     @Override
     public int[] executeBatch() throws SQLException {
         checkOpen();
-        if (_conn != null) {
-            _conn.setLastUsed();
+        if (connection != null) {
+            connection.setLastUsed();
         }
         try {
-            return _stmt.executeBatch();
+            return statement.executeBatch();
         } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
@@ -359,18 +496,25 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
      */
     @Override
     public String toString() {
-    return _stmt == null ? "NULL" : _stmt.toString();
+        return statement == null ? "NULL" : statement.toString();
     }
 
     @Override
-    public boolean getMoreResults(final int current) throws SQLException
-    { checkOpen(); try { return _stmt.getMoreResults(current); } catch (final SQLException e) { handleException(e); return false; } }
+    public boolean getMoreResults(final int current) throws SQLException {
+        checkOpen();
+        try {
+            return statement.getMoreResults(current);
+        } catch (final SQLException e) {
+            handleException(e);
+            return false;
+        }
+    }
 
     @Override
     public ResultSet getGeneratedKeys() throws SQLException {
         checkOpen();
         try {
-            return DelegatingResultSet.wrapResultSet(this, _stmt.getGeneratedKeys());
+            return DelegatingResultSet.wrapResultSet(this, statement.getGeneratedKeys());
         } catch (final SQLException e) {
             handleException(e);
             throw new AssertionError();
@@ -380,11 +524,11 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     @Override
     public int executeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
         checkOpen();
-        if (_conn != null) {
-            _conn.setLastUsed();
+        if (connection != null) {
+            connection.setLastUsed();
         }
         try {
-            return _stmt.executeUpdate(sql, autoGeneratedKeys);
+            return statement.executeUpdate(sql, autoGeneratedKeys);
         } catch (final SQLException e) {
             handleException(e);
             return 0;
@@ -394,11 +538,11 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     @Override
     public int executeUpdate(final String sql, final int columnIndexes[]) throws SQLException {
         checkOpen();
-        if (_conn != null) {
-            _conn.setLastUsed();
+        if (connection != null) {
+            connection.setLastUsed();
         }
         try {
-            return _stmt.executeUpdate(sql, columnIndexes);
+            return statement.executeUpdate(sql, columnIndexes);
         } catch (final SQLException e) {
             handleException(e);
             return 0;
@@ -408,11 +552,11 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     @Override
     public int executeUpdate(final String sql, final String columnNames[]) throws SQLException {
         checkOpen();
-        if (_conn != null) {
-            _conn.setLastUsed();
+        if (connection != null) {
+            connection.setLastUsed();
         }
         try {
-            return _stmt.executeUpdate(sql, columnNames);
+            return statement.executeUpdate(sql, columnNames);
         } catch (final SQLException e) {
             handleException(e);
             return 0;
@@ -422,11 +566,11 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     @Override
     public boolean execute(final String sql, final int autoGeneratedKeys) throws SQLException {
         checkOpen();
-        if (_conn != null) {
-            _conn.setLastUsed();
+        if (connection != null) {
+            connection.setLastUsed();
         }
         try {
-            return _stmt.execute(sql, autoGeneratedKeys);
+            return statement.execute(sql, autoGeneratedKeys);
         } catch (final SQLException e) {
             handleException(e);
             return false;
@@ -436,11 +580,11 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     @Override
     public boolean execute(final String sql, final int columnIndexes[]) throws SQLException {
         checkOpen();
-        if (_conn != null) {
-            _conn.setLastUsed();
+        if (connection != null) {
+            connection.setLastUsed();
         }
         try {
-            return _stmt.execute(sql, columnIndexes);
+            return statement.execute(sql, columnIndexes);
         } catch (final SQLException e) {
             handleException(e);
             return false;
@@ -450,11 +594,11 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     @Override
     public boolean execute(final String sql, final String columnNames[]) throws SQLException {
         checkOpen();
-        if (_conn != null) {
-            _conn.setLastUsed();
+        if (connection != null) {
+            connection.setLastUsed();
         }
         try {
-            return _stmt.execute(sql, columnNames);
+            return statement.execute(sql, columnNames);
         } catch (final SQLException e) {
             handleException(e);
             return false;
@@ -462,26 +606,32 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     }
 
     @Override
-    public int getResultSetHoldability() throws SQLException
-    { checkOpen(); try { return _stmt.getResultSetHoldability(); } catch (final SQLException e) { handleException(e); return 0; } }
+    public int getResultSetHoldability() throws SQLException {
+        checkOpen();
+        try {
+            return statement.getResultSetHoldability();
+        } catch (final SQLException e) {
+            handleException(e);
+            return 0;
+        }
+    }
 
     /*
      * Note was protected prior to JDBC 4
      */
     @Override
     public boolean isClosed() throws SQLException {
-        return _closed;
+        return closed;
     }
 
-
     @Override
     public boolean isWrapperFor(final Class<?> iface) throws SQLException {
         if (iface.isAssignableFrom(getClass())) {
             return true;
-        } else if (iface.isAssignableFrom(_stmt.getClass())) {
+        } else if (iface.isAssignableFrom(statement.getClass())) {
             return true;
         } else {
-            return _stmt.isWrapperFor(iface);
+            return statement.isWrapperFor(iface);
         }
     }
 
@@ -489,10 +639,10 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     public <T> T unwrap(final Class<T> iface) throws SQLException {
         if (iface.isAssignableFrom(getClass())) {
             return iface.cast(this);
-        } else if (iface.isAssignableFrom(_stmt.getClass())) {
-            return iface.cast(_stmt);
+        } else if (iface.isAssignableFrom(statement.getClass())) {
+            return iface.cast(statement);
         } else {
-            return _stmt.unwrap(iface);
+            return statement.unwrap(iface);
         }
     }
 
@@ -500,9 +650,8 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     public void setPoolable(final boolean poolable) throws SQLException {
         checkOpen();
         try {
-            _stmt.setPoolable(poolable);
-        }
-        catch (final SQLException e) {
+            statement.setPoolable(poolable);
+        } catch (final SQLException e) {
             handleException(e);
         }
     }
@@ -511,9 +660,8 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     public boolean isPoolable() throws SQLException {
         checkOpen();
         try {
-            return _stmt.isPoolable();
-        }
-        catch (final SQLException e) {
+            return statement.isPoolable();
+        } catch (final SQLException e) {
             handleException(e);
             return false;
         }
@@ -523,7 +671,7 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     public void closeOnCompletion() throws SQLException {
         checkOpen();
         try {
-            _stmt.closeOnCompletion();
+            statement.closeOnCompletion();
         } catch (final SQLException e) {
             handleException(e);
         }
@@ -533,7 +681,7 @@ public class DelegatingStatement extends AbandonedTrace implements Statement {
     public boolean isCloseOnCompletion() throws SQLException {
         checkOpen();
         try {
-            return _stmt.isCloseOnCompletion();
+            return statement.isCloseOnCompletion();
         } catch (final SQLException e) {
             handleException(e);
             return false;

==================================================
DriverManagerConnectionFactory.java
index 6daf2bb109..06f3bd9d99 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DriverConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DriverConnectionFactory.java
@@ -23,28 +23,38 @@ import java.util.Properties;
 /**
  * A {@link Driver}-based implementation of {@link ConnectionFactory}.
  *
- * @author Rodney Waldhoff
  * @since 2.0
  */
 public class DriverConnectionFactory implements ConnectionFactory {
-    public DriverConnectionFactory(final Driver driver, final String connectUri, final Properties props) {
-        _driver = driver;
-        _connectUri = connectUri;
-        _props = props;
+
+    private final String connectionString;
+    private final Driver driver;
+    private final Properties properties;
+
+    /**
+     * Constructs a connection factory for a given Driver.
+     *
+     * @param driver
+     *            The Driver.
+     * @param connectString
+     *            The connection string.
+     * @param properties
+     *            The connection properties.
+     */
+    public DriverConnectionFactory(final Driver driver, final String connectString, final Properties properties) {
+        this.driver = driver;
+        this.connectionString = connectString;
+        this.properties = properties;
     }
 
     @Override
     public Connection createConnection() throws SQLException {
-        return _driver.connect(_connectUri,_props);
+        return driver.connect(connectionString, properties);
     }
 
-    private final Driver _driver;
-    private final String _connectUri;
-    private final Properties _props;
-
     @Override
     public String toString() {
-        return this.getClass().getName() + " [" + String.valueOf(_driver) + ";" +
-                String.valueOf(_connectUri) + ";"  + String.valueOf(_props) + "]";
+        return this.getClass().getName() + " [" + String.valueOf(driver) + ";" + String.valueOf(connectionString) + ";"
+                + String.valueOf(properties) + "]";
     }
 }

==================================================
LifetimeExceededException.java
index cc40321526..7b6b060a04 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/DriverManagerConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/DriverManagerConnectionFactory.java
@@ -24,9 +24,6 @@ import java.util.Properties;
 /**
  * A {@link DriverManager}-based implementation of {@link ConnectionFactory}.
  *
- * @author Rodney Waldhoff
- * @author Ignacio J. Ortega
- * @author Dirk Verbeeck
  * @since 2.0
  */
 public class DriverManagerConnectionFactory implements ConnectionFactory {
@@ -40,57 +37,62 @@ public class DriverManagerConnectionFactory implements ConnectionFactory {
         DriverManager.getDrivers();
     }
 
-
     /**
      * Constructor for DriverManagerConnectionFactory.
-     * @param connectUri a database url of the form
-     * <code> jdbc:<em>subprotocol</em>:<em>subname</em></code>
+     *
+     * @param connectionUri
+     *            a database url of the form <code> jdbc:<em>subprotocol</em>:<em>subname</em></code>
      * @since 2.2
      */
-    public DriverManagerConnectionFactory(final String connectUri) {
-        _connectUri = connectUri;
-        _props = new Properties();
+    public DriverManagerConnectionFactory(final String connectionUri) {
+        this.connectionUri = connectionUri;
+        this.propeties = new Properties();
     }
 
     /**
      * Constructor for DriverManagerConnectionFactory.
-     * @param connectUri a database url of the form
-     * <code> jdbc:<em>subprotocol</em>:<em>subname</em></code>
-     * @param props a list of arbitrary string tag/value pairs as
-     * connection arguments; normally at least a "user" and "password"
-     * property should be included.
+     *
+     * @param connectionUri
+     *            a database url of the form <code> jdbc:<em>subprotocol</em>:<em>subname</em></code>
+     * @param properties
+     *            a list of arbitrary string tag/value pairs as connection arguments; normally at least a "user" and
+     *            "password" property should be included.
      */
-    public DriverManagerConnectionFactory(final String connectUri, final Properties props) {
-        _connectUri = connectUri;
-        _props = props;
+    public DriverManagerConnectionFactory(final String connectionUri, final Properties properties) {
+        this.connectionUri = connectionUri;
+        this.propeties = properties;
     }
 
     /**
      * Constructor for DriverManagerConnectionFactory.
-     * @param connectUri a database url of the form
-     * <code>jdbc:<em>subprotocol</em>:<em>subname</em></code>
-     * @param uname the database user
-     * @param passwd the user's password
+     *
+     * @param connectionUri
+     *            a database url of the form <code>jdbc:<em>subprotocol</em>:<em>subname</em></code>
+     * @param userName
+     *            the database user
+     * @param userPassword
+     *            the user's password
      */
-    public DriverManagerConnectionFactory(final String connectUri, final String uname, final String passwd) {
-        _connectUri = connectUri;
-        _uname = uname;
-        _passwd = passwd;
+    public DriverManagerConnectionFactory(final String connectionUri, final String userName,
+            final String userPassword) {
+        this.connectionUri = connectionUri;
+        this.userName = userName;
+        this.userPassword = userPassword;
     }
 
     @Override
     public Connection createConnection() throws SQLException {
-        if(null == _props) {
-            if(_uname == null && _passwd == null) {
-                return DriverManager.getConnection(_connectUri);
+        if (null == propeties) {
+            if (userName == null && userPassword == null) {
+                return DriverManager.getConnection(connectionUri);
             }
-            return DriverManager.getConnection(_connectUri,_uname,_passwd);
+            return DriverManager.getConnection(connectionUri, userName, userPassword);
         }
-        return DriverManager.getConnection(_connectUri,_props);
+        return DriverManager.getConnection(connectionUri, propeties);
     }
 
-    private String _connectUri = null;
-    private String _uname = null;
-    private String _passwd = null;
-    private Properties _props = null;
+    private final String connectionUri;
+    private String userName;
+    private String userPassword;
+    private Properties propeties;
 }

==================================================
ListException.java
index 53fd322378..2d440cba58 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/LifetimeExceededException.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/LifetimeExceededException.java
@@ -21,7 +21,7 @@ package org.apache.tomcat.dbcp.dbcp2;
  *
  * @since 2.1
  */
- class LifetimeExceededException extends Exception {
+class LifetimeExceededException extends Exception {
 
     private static final long serialVersionUID = -3783783104516492659L;
 
@@ -35,7 +35,8 @@ package org.apache.tomcat.dbcp.dbcp2;
     /**
      * Create a LifetimeExceededException with the given message.
      *
-     * @param message The message with which to create the exception
+     * @param message
+     *            The message with which to create the exception
      */
     public LifetimeExceededException(final String message) {
         super(message);

==================================================
ObjectNameWrapper.java
new file mode 100644
index 0000000000..1f6b8f7428
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/ListException.java
@@ -0,0 +1,57 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.util.List;
+
+/**
+ * An exception wrapping a list of exceptions.
+ *
+ * @since 2.4.0
+ */
+public class ListException extends Exception {
+
+    private static final long serialVersionUID = 1L;
+
+    private final List<Throwable> exceptionList;
+
+    /**
+     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently
+     * be initialized by a call to {@link #initCause}.
+     *
+     * @param message
+     *            the detail message. The detail message is saved for later retrieval by the {@link #getMessage()}
+     *            method.
+     * @param exceptionList
+     *            a list of exceptions.
+     */
+    public ListException(final String message, final List<Throwable> exceptionList) {
+        super(message);
+        this.exceptionList = exceptionList;
+    }
+
+    /**
+     * Gets the list of exceptions.
+     *
+     * @return the list of exceptions.
+     */
+    public List<Throwable> getExceptionList() {
+        return exceptionList;
+    }
+
+}

==================================================
PStmtKey.java
new file mode 100644
index 0000000000..f036989e98
--- /dev/null
+++ b/java/org/apache/tomcat/dbcp/dbcp2/ObjectNameWrapper.java
@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.tomcat.dbcp.dbcp2;
+
+import java.lang.management.ManagementFactory;
+
+import javax.management.MBeanServer;
+import javax.management.MalformedObjectNameException;
+import javax.management.ObjectName;
+
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+
+/**
+ * Internal wrapper class that allows JMX to be a noop if absent or disabled.
+ *
+ * @since 2.2.1
+ */
+class ObjectNameWrapper {
+
+    private static final Log log = LogFactory.getLog(ObjectNameWrapper.class);
+
+    private static MBeanServer MBEAN_SERVER = getPlatformMBeanServer();
+
+    private static MBeanServer getPlatformMBeanServer() {
+        try {
+            return ManagementFactory.getPlatformMBeanServer();
+        } catch (LinkageError | Exception e) {
+            // ignore - JMX not available
+            log.debug("Failed to get platform MBeanServer", e);
+            return null;
+        }
+    }
+
+    public static ObjectName unwrap(final ObjectNameWrapper wrapper) {
+        return wrapper == null ? null : wrapper.unwrap();
+    }
+
+    public static ObjectNameWrapper wrap(final ObjectName objectName) {
+        return new ObjectNameWrapper(objectName);
+    }
+
+    public static ObjectNameWrapper wrap(final String name) throws MalformedObjectNameException {
+        return wrap(new ObjectName(name));
+    }
+
+    private final ObjectName objectName;
+
+    public ObjectNameWrapper(final ObjectName objectName) {
+        this.objectName = objectName;
+    }
+
+    public void registerMBean(final Object object) {
+        if (MBEAN_SERVER == null || objectName == null) {
+            return;
+        }
+        try {
+            MBEAN_SERVER.registerMBean(object, objectName);
+        } catch (LinkageError | Exception e) {
+            log.warn("Failed to complete JMX registration for " + objectName, e);
+        }
+    }
+
+    public void unregisterMBean() {
+        if (MBEAN_SERVER == null || objectName == null) {
+            return;
+        }
+        if (MBEAN_SERVER.isRegistered(objectName)) {
+            try {
+                MBEAN_SERVER.unregisterMBean(objectName);
+            } catch (LinkageError | Exception e) {
+                log.warn("Failed to complete JMX unregistration for " + objectName, e);
+            }
+        }
+    }
+
+    public ObjectName unwrap() {
+        return objectName;
+    }
+
+}

==================================================
PoolableCallableStatement.java
index f986d68b7d..29cc510df2 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/PStmtKey.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PStmtKey.java
@@ -26,201 +26,419 @@ import org.apache.tomcat.dbcp.dbcp2.PoolingConnection.StatementType;
 
 /**
  * A key uniquely identifying {@link java.sql.PreparedStatement PreparedStatement}s.
+ *
  * @since 2.0
  */
 public class PStmtKey {
 
-    /** SQL defining Prepared or Callable Statement */
-    private final String _sql;
+    /**
+     * SQL defining Prepared or Callable Statement
+     */
+    private final String sql;
 
-    /** Result set type */
-    private final Integer _resultSetType;
+    /**
+     * Result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>, <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>,
+     * or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     */
+    private final Integer resultSetType;
 
-    /** Result set concurrency */
-    private final Integer _resultSetConcurrency;
+    /**
+     * Result set concurrency. A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     * <code>ResultSet.CONCUR_UPDATABLE</code>.
+     */
+    private final Integer resultSetConcurrency;
 
-    /** Result set holdability */
-    private final Integer _resultSetHoldability;
+    /**
+     * Result set holdability. One of the following <code>ResultSet</code> constants:
+     * <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>.
+     */
+    private final Integer resultSetHoldability;
 
     /** Database catalog */
-    private final String _catalog;
+    private final String catalog;
 
-    /** Auto generated keys */
-    private final Integer _autoGeneratedKeys;
+    /**
+     * A flag indicating whether auto-generated keys should be returned; one of
+     * <code>Statement.RETURN_GENERATED_KEYS</code> or <code>Statement.NO_GENERATED_KEYS</code>.
+     */
+    private final Integer autoGeneratedKeys;
 
-    /** column indexes */
-    private final int[] _columnIndexes;
+    /**
+     * An array of column indexes indicating the columns that should be returned from the inserted row or rows.
+     */
+    private final int[] columnIndexes;
 
-    /** column names */
-    private final String[] _columnNames;
+    /**
+     * An array of column names indicating the columns that should be returned from the inserted row or rows.
+     */
+    private final String[] columnNames;
 
-    /** Statement type */
-    private final StatementType _stmtType;
+    /**
+     * Statement type, prepared or callable.
+     */
+    private final StatementType statementType;
 
     /** Statement builder */
     private StatementBuilder builder;
 
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     */
     public PStmtKey(final String sql) {
         this(sql, null, StatementType.PREPARED_STATEMENT);
     }
 
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     */
     public PStmtKey(final String sql, final String catalog) {
         this(sql, catalog, StatementType.PREPARED_STATEMENT);
     }
 
-    public PStmtKey(final String sql, final String catalog, final StatementType stmtType) {
-        _sql = sql;
-        _catalog = catalog;
-        _stmtType = stmtType;
-        _autoGeneratedKeys = null;
-        _columnIndexes = null;
-        _columnNames = null;
-        _resultSetType = null;
-        _resultSetConcurrency = null;
-        _resultSetHoldability = null;
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param statementType
+     *            The SQL statement type, prepared or callable.
+     */
+    public PStmtKey(final String sql, final String catalog, final StatementType statementType) {
+        this.sql = sql;
+        this.catalog = catalog;
+        this.statementType = statementType;
+        this.autoGeneratedKeys = null;
+        this.columnIndexes = null;
+        this.columnNames = null;
+        this.resultSetType = null;
+        this.resultSetConcurrency = null;
+        this.resultSetHoldability = null;
         // create builder
-        if (stmtType == StatementType.PREPARED_STATEMENT) {
-            builder = new PreparedStatementSQL();
-        } else if (stmtType == StatementType.CALLABLE_STATEMENT) {
-            builder = new PreparedCallSQL();
+        if (statementType == StatementType.PREPARED_STATEMENT) {
+            this.builder = new PreparedStatementSQL();
+        } else if (statementType == StatementType.CALLABLE_STATEMENT) {
+            this.builder = new PreparedCallSQL();
         }
     }
 
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param autoGeneratedKeys
+     *            A flag indicating whether auto-generated keys should be returned; one of
+     *            <code>Statement.RETURN_GENERATED_KEYS</code> or <code>Statement.NO_GENERATED_KEYS</code>.
+     */
     public PStmtKey(final String sql, final String catalog, final int autoGeneratedKeys) {
         this(sql, catalog, StatementType.PREPARED_STATEMENT, Integer.valueOf(autoGeneratedKeys));
     }
 
-    public PStmtKey(final String sql, final String catalog, final StatementType stmtType, final Integer autoGeneratedKeys) {
-        _sql = sql;
-        _catalog = catalog;
-        _stmtType = stmtType;
-        _autoGeneratedKeys = autoGeneratedKeys;
-        _columnIndexes = null;
-        _columnNames = null;
-        _resultSetType = null;
-        _resultSetConcurrency = null;
-        _resultSetHoldability = null;
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param statementType
+     *            The SQL statement type, prepared or callable.
+     * @param autoGeneratedKeys
+     *            A flag indicating whether auto-generated keys should be returned; one of
+     *            <code>Statement.RETURN_GENERATED_KEYS</code> or <code>Statement.NO_GENERATED_KEYS</code>.
+     */
+    public PStmtKey(final String sql, final String catalog, final StatementType statementType,
+            final Integer autoGeneratedKeys) {
+        this.sql = sql;
+        this.catalog = catalog;
+        this.statementType = statementType;
+        this.autoGeneratedKeys = autoGeneratedKeys;
+        this.columnIndexes = null;
+        this.columnNames = null;
+        this.resultSetType = null;
+        this.resultSetConcurrency = null;
+        this.resultSetHoldability = null;
         // create builder
-        if (stmtType == StatementType.PREPARED_STATEMENT) {
-            builder = new PreparedStatementWithAutoGeneratedKeys();
-        } else if (stmtType == StatementType.CALLABLE_STATEMENT) {
-            builder = new PreparedCallSQL();
+        if (statementType == StatementType.PREPARED_STATEMENT) {
+            this.builder = new PreparedStatementWithAutoGeneratedKeys();
+        } else if (statementType == StatementType.CALLABLE_STATEMENT) {
+            this.builder = new PreparedCallSQL();
         }
     }
 
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param columnIndexes
+     *            An array of column indexes indicating the columns that should be returned from the inserted row or
+     *            rows.
+     */
     public PStmtKey(final String sql, final String catalog, final int[] columnIndexes) {
-        _sql = sql;
-        _catalog = catalog;
-        _stmtType = StatementType.PREPARED_STATEMENT;
-        _autoGeneratedKeys = null;
-        _columnIndexes = columnIndexes;
-        _columnNames = null;
-        _resultSetType = null;
-        _resultSetConcurrency = null;
-        _resultSetHoldability = null;
+        this.sql = sql;
+        this.catalog = catalog;
+        this.statementType = StatementType.PREPARED_STATEMENT;
+        this.autoGeneratedKeys = null;
+        this.columnIndexes = columnIndexes == null ? null : Arrays.copyOf(columnIndexes, columnIndexes.length);
+        this.columnNames = null;
+        this.resultSetType = null;
+        this.resultSetConcurrency = null;
+        this.resultSetHoldability = null;
         // create builder
-        builder = new PreparedStatementWithColumnIndexes();
+        this.builder = new PreparedStatementWithColumnIndexes();
     }
 
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param columnNames
+     *            An array of column names indicating the columns that should be returned from the inserted row or rows.
+     */
     public PStmtKey(final String sql, final String catalog, final String[] columnNames) {
-        _sql = sql;
-        _catalog = catalog;
-        _stmtType = StatementType.PREPARED_STATEMENT;
-        _autoGeneratedKeys = null;
-        _columnIndexes = null;
-        _columnNames = columnNames;
-        _resultSetType = null;
-        _resultSetConcurrency = null;
-        _resultSetHoldability = null;
+        this.sql = sql;
+        this.catalog = catalog;
+        this.statementType = StatementType.PREPARED_STATEMENT;
+        this.autoGeneratedKeys = null;
+        this.columnIndexes = null;
+        this.columnNames = columnNames == null ? null : Arrays.copyOf(columnNames, columnNames.length);
+        this.resultSetType = null;
+        this.resultSetConcurrency = null;
+        this.resultSetHoldability = null;
         // create builder
         builder = new PreparedStatementWithColumnNames();
     }
 
-    public  PStmtKey(final String sql, final int resultSetType, final int resultSetConcurrency) {
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param resultSetType
+     *            A result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     */
+    public PStmtKey(final String sql, final int resultSetType, final int resultSetConcurrency) {
         this(sql, null, resultSetType, resultSetConcurrency, StatementType.PREPARED_STATEMENT);
     }
 
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param resultSetType
+     *            A result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     */
     public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency) {
         this(sql, catalog, resultSetType, resultSetConcurrency, StatementType.PREPARED_STATEMENT);
     }
 
-    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency, final StatementType stmtType) {
-        _sql = sql;
-        _catalog = catalog;
-        _resultSetType = Integer.valueOf(resultSetType);
-        _resultSetConcurrency = Integer.valueOf(resultSetConcurrency);
-        _resultSetHoldability = null;
-        _stmtType = stmtType;
-        _autoGeneratedKeys = null;
-        _columnIndexes = null;
-        _columnNames = null;
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param resultSetType
+     *            A result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     * @param statementType
+     *            The SQL statement type, prepared or callable.
+     */
+    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency,
+            final StatementType statementType) {
+        this.sql = sql;
+        this.catalog = catalog;
+        this.resultSetType = Integer.valueOf(resultSetType);
+        this.resultSetConcurrency = Integer.valueOf(resultSetConcurrency);
+        this.resultSetHoldability = null;
+        this.statementType = statementType;
+        this.autoGeneratedKeys = null;
+        this.columnIndexes = null;
+        this.columnNames = null;
         // create builder
-        if (stmtType == StatementType.PREPARED_STATEMENT) {
-            builder = new PreparedStatementWithResultSetConcurrency();
-        } else if (stmtType == StatementType.CALLABLE_STATEMENT) {
-            builder = new PreparedCallWithResultSetConcurrency();
+        if (statementType == StatementType.PREPARED_STATEMENT) {
+            this.builder = new PreparedStatementWithResultSetConcurrency();
+        } else if (statementType == StatementType.CALLABLE_STATEMENT) {
+            this.builder = new PreparedCallWithResultSetConcurrency();
         }
     }
 
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param resultSetType
+     *            a result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>
+     * @param resultSetHoldability
+     *            One of the following <code>ResultSet</code> constants: <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code>
+     *            or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>.
+     */
     public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency,
             final int resultSetHoldability) {
         this(sql, catalog, resultSetType, resultSetConcurrency, resultSetHoldability, StatementType.PREPARED_STATEMENT);
     }
 
+    /**
+     * Constructs a key to uniquely identify a prepared statement.
+     *
+     * @param sql
+     *            The SQL statement.
+     * @param catalog
+     *            The catalog.
+     * @param resultSetType
+     *            a result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
+     * @param resultSetConcurrency
+     *            A concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     * @param resultSetHoldability
+     *            One of the following <code>ResultSet</code> constants: <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code>
+     *            or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>.
+     * @param statementType
+     *            The SQL statement type, prepared or callable.
+     */
     public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency,
-            final int resultSetHoldability, final StatementType stmtType) {
-        _sql = sql;
-        _catalog = catalog;
-        _resultSetType = Integer.valueOf(resultSetType);
-        _resultSetConcurrency = Integer.valueOf(resultSetConcurrency);
-        _resultSetHoldability = Integer.valueOf(resultSetHoldability);
-        _stmtType = stmtType;
-        _autoGeneratedKeys = null;
-        _columnIndexes = null;
-        _columnNames = null;
+            final int resultSetHoldability, final StatementType statementType) {
+        this.sql = sql;
+        this.catalog = catalog;
+        this.resultSetType = Integer.valueOf(resultSetType);
+        this.resultSetConcurrency = Integer.valueOf(resultSetConcurrency);
+        this.resultSetHoldability = Integer.valueOf(resultSetHoldability);
+        this.statementType = statementType;
+        this.autoGeneratedKeys = null;
+        this.columnIndexes = null;
+        this.columnNames = null;
         // create builder
-        if (stmtType == StatementType.PREPARED_STATEMENT) {
-            builder = new PreparedStatementWithResultSetHoldability();
-        } else if (stmtType == StatementType.CALLABLE_STATEMENT) {
-            builder = new PreparedCallWithResultSetHoldability();
+        if (statementType == StatementType.PREPARED_STATEMENT) {
+            this.builder = new PreparedStatementWithResultSetHoldability();
+        } else if (statementType == StatementType.CALLABLE_STATEMENT) {
+            this.builder = new PreparedCallWithResultSetHoldability();
         }
     }
 
-
+    /**
+     * Gets the SQL statement.
+     *
+     * @return the SQL statement.
+     */
     public String getSql() {
-        return _sql;
+        return sql;
     }
 
+    /**
+     * Gets the result set type, one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     * <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     *
+     * @return the result set type.
+     */
     public Integer getResultSetType() {
-        return _resultSetType;
+        return resultSetType;
     }
 
+    /**
+     * Gets the result set concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     * <code>ResultSet.CONCUR_UPDATABLE</code>.
+     *
+     * @return The result set concurrency type.
+     */
     public Integer getResultSetConcurrency() {
-        return _resultSetConcurrency;
+        return resultSetConcurrency;
     }
 
+    /**
+     * Gets the result set holdability, one of the following <code>ResultSet</code> constants:
+     * <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>.
+     *
+     * @return The result set holdability.
+     */
     public Integer getResultSetHoldability() {
-        return _resultSetHoldability;
+        return resultSetHoldability;
     }
 
+    /**
+     * Gets a flag indicating whether auto-generated keys should be returned; one of
+     * <code>Statement.RETURN_GENERATED_KEYS</code> or <code>Statement.NO_GENERATED_KEYS</code>.
+     *
+     * @return a flag indicating whether auto-generated keys should be returned.
+     */
     public Integer getAutoGeneratedKeys() {
-        return _autoGeneratedKeys;
+        return autoGeneratedKeys;
     }
 
+    /**
+     * Gets an array of column indexes indicating the columns that should be returned from the inserted row or rows.
+     *
+     * @return An array of column indexes.
+     */
     public int[] getColumnIndexes() {
-        return _columnIndexes;
+        return columnIndexes;
     }
 
+    /**
+     * Gets an array of column names indicating the columns that should be returned from the inserted row or rows.
+     *
+     * @return An array of column names.
+     */
     public String[] getColumnNames() {
-        return _columnNames;
+        return columnNames;
     }
 
+    /**
+     * The catalog.
+     *
+     * @return The catalog.
+     */
     public String getCatalog() {
-        return _catalog;
+        return catalog;
     }
 
+    /**
+     * The SQL statement type.
+     *
+     * @return The SQL statement type.
+     */
     public StatementType getStmtType() {
-        return _stmtType;
+        return statementType;
     }
 
     @Override
@@ -235,55 +453,55 @@ public class PStmtKey {
             return false;
         }
         final PStmtKey other = (PStmtKey) obj;
-        if (_catalog == null) {
-            if (other._catalog != null) {
+        if (catalog == null) {
+            if (other.catalog != null) {
                 return false;
             }
-        } else if (!_catalog.equals(other._catalog)) {
+        } else if (!catalog.equals(other.catalog)) {
             return false;
         }
-        if (_resultSetConcurrency == null) {
-            if (other._resultSetConcurrency != null) {
+        if (resultSetConcurrency == null) {
+            if (other.resultSetConcurrency != null) {
                 return false;
             }
-        } else if (!_resultSetConcurrency.equals(other._resultSetConcurrency)) {
+        } else if (!resultSetConcurrency.equals(other.resultSetConcurrency)) {
             return false;
         }
-        if (_resultSetType == null) {
-            if (other._resultSetType != null) {
+        if (resultSetType == null) {
+            if (other.resultSetType != null) {
                 return false;
             }
-        } else if (!_resultSetType.equals(other._resultSetType)) {
+        } else if (!resultSetType.equals(other.resultSetType)) {
             return false;
         }
-        if (_resultSetHoldability == null) {
-            if (other._resultSetHoldability != null) {
+        if (resultSetHoldability == null) {
+            if (other.resultSetHoldability != null) {
                 return false;
             }
-        } else if (!_resultSetHoldability.equals(other._resultSetHoldability)) {
+        } else if (!resultSetHoldability.equals(other.resultSetHoldability)) {
             return false;
         }
-        if (_autoGeneratedKeys == null) {
-            if (other._autoGeneratedKeys != null) {
+        if (autoGeneratedKeys == null) {
+            if (other.autoGeneratedKeys != null) {
                 return false;
             }
-        } else if (!_autoGeneratedKeys.equals(other._autoGeneratedKeys)) {
+        } else if (!autoGeneratedKeys.equals(other.autoGeneratedKeys)) {
             return false;
         }
-        if (!Arrays.equals(_columnIndexes, other._columnIndexes)) {
+        if (!Arrays.equals(columnIndexes, other.columnIndexes)) {
             return false;
         }
-        if (!Arrays.equals(_columnNames, other._columnNames)) {
+        if (!Arrays.equals(columnNames, other.columnNames)) {
             return false;
         }
-        if (_sql == null) {
-            if (other._sql != null) {
+        if (sql == null) {
+            if (other.sql != null) {
                 return false;
             }
-        } else if (!_sql.equals(other._sql)) {
+        } else if (!sql.equals(other.sql)) {
             return false;
         }
-        if (_stmtType != other._stmtType) {
+        if (statementType != other.statementType) {
             return false;
         }
         return true;
@@ -293,15 +511,15 @@ public class PStmtKey {
     public int hashCode() {
         final int prime = 31;
         int result = 1;
-        result = prime * result + (_catalog == null ? 0 : _catalog.hashCode());
-        result = prime * result + (_resultSetConcurrency == null ? 0 : _resultSetConcurrency.hashCode());
-        result = prime * result + (_resultSetType == null ? 0 : _resultSetType.hashCode());
-        result = prime * result + (_resultSetHoldability == null ? 0 : _resultSetHoldability.hashCode());
-        result = prime * result + (_sql == null ? 0 : _sql.hashCode());
-        result = prime * result + (_autoGeneratedKeys == null ? 0 : _autoGeneratedKeys.hashCode());
-        result = prime * result + Arrays.hashCode(_columnIndexes);
-        result = prime * result + Arrays.hashCode(_columnNames);
-        result = prime * result + _stmtType.hashCode();
+        result = prime * result + (catalog == null ? 0 : catalog.hashCode());
+        result = prime * result + (resultSetConcurrency == null ? 0 : resultSetConcurrency.hashCode());
+        result = prime * result + (resultSetType == null ? 0 : resultSetType.hashCode());
+        result = prime * result + (resultSetHoldability == null ? 0 : resultSetHoldability.hashCode());
+        result = prime * result + (sql == null ? 0 : sql.hashCode());
+        result = prime * result + (autoGeneratedKeys == null ? 0 : autoGeneratedKeys.hashCode());
+        result = prime * result + Arrays.hashCode(columnIndexes);
+        result = prime * result + Arrays.hashCode(columnNames);
+        result = prime * result + statementType.hashCode();
         return result;
     }
 
@@ -309,26 +527,35 @@ public class PStmtKey {
     public String toString() {
         final StringBuffer buf = new StringBuffer();
         buf.append("PStmtKey: sql=");
-        buf.append(_sql);
+        buf.append(sql);
         buf.append(", catalog=");
-        buf.append(_catalog);
+        buf.append(catalog);
         buf.append(", resultSetType=");
-        buf.append(_resultSetType);
+        buf.append(resultSetType);
         buf.append(", resultSetConcurrency=");
-        buf.append(_resultSetConcurrency);
+        buf.append(resultSetConcurrency);
         buf.append(", resultSetHoldability=");
-        buf.append(_resultSetHoldability);
+        buf.append(resultSetHoldability);
         buf.append(", autoGeneratedKeys=");
-        buf.append(_autoGeneratedKeys);
+        buf.append(autoGeneratedKeys);
         buf.append(", columnIndexes=");
-        buf.append(Arrays.toString(_columnIndexes));
+        buf.append(Arrays.toString(columnIndexes));
         buf.append(", columnNames=");
-        buf.append(Arrays.toString(_columnNames));
+        buf.append(Arrays.toString(columnNames));
         buf.append(", statementType=");
-        buf.append(_stmtType);
+        buf.append(statementType);
         return buf.toString();
     }
 
+    /**
+     * Creates a new Statement from the given Connection.
+     *
+     * @param connection
+     *            The Connection to use to create the statement.
+     * @return The statement.
+     * @throws SQLException
+     *             Thrown when there is a problem creating the statement.
+     */
     public Statement createStatement(final Connection connection) throws SQLException {
         if (builder == null) {
             throw new IllegalStateException("Prepared statement key is invalid.");
@@ -337,116 +564,111 @@ public class PStmtKey {
     }
 
     /**
-     * Interface for Prepared or Callable Statement
+     * Interface for Prepared or Callable Statement.
      */
     private interface StatementBuilder {
         public Statement createStatement(Connection connection) throws SQLException;
     }
 
     /**
-     * Builder for prepareStatement(String sql)
+     * Builder for prepareStatement(String sql).
      */
     private class PreparedStatementSQL implements StatementBuilder {
         @Override
         public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareStatement(_sql);
+            final PreparedStatement statement = connection.prepareStatement(sql);
             return statement;
         }
     }
 
     /**
-     * Builder for prepareStatement(String sql, int autoGeneratedKeys)
+     * Builder for prepareStatement(String sql, int autoGeneratedKeys).
      */
     private class PreparedStatementWithAutoGeneratedKeys implements StatementBuilder {
         @Override
         public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareStatement(
-                    _sql, _autoGeneratedKeys.intValue());
+            final PreparedStatement statement = connection.prepareStatement(sql, autoGeneratedKeys.intValue());
             return statement;
         }
     }
 
     /**
-     * Builder for prepareStatement(String sql, int[] columnIndexes)
+     * Builder for prepareStatement(String sql, int[] columnIndexes).
      */
     private class PreparedStatementWithColumnIndexes implements StatementBuilder {
         @Override
         public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareStatement(
-                    _sql, _columnIndexes);
+            final PreparedStatement statement = connection.prepareStatement(sql, columnIndexes);
             return statement;
         }
     }
 
     /**
-     * Builder for prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
+     * Builder for prepareStatement(String sql, int resultSetType, int resultSetConcurrency).
      */
     private class PreparedStatementWithResultSetConcurrency implements StatementBuilder {
         @Override
         public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareStatement(
-                    _sql, _resultSetType.intValue(), _resultSetConcurrency.intValue());
+            final PreparedStatement statement = connection.prepareStatement(sql, resultSetType.intValue(),
+                    resultSetConcurrency.intValue());
             return statement;
         }
     }
 
     /**
-     * Builder for prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability)
+     * Builder for prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability).
      */
     private class PreparedStatementWithResultSetHoldability implements StatementBuilder {
         @Override
         public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareStatement(
-                    _sql, _resultSetType.intValue(), _resultSetConcurrency.intValue(),
-                    _resultSetHoldability.intValue());
+            final PreparedStatement statement = connection.prepareStatement(sql, resultSetType.intValue(),
+                    resultSetConcurrency.intValue(), resultSetHoldability.intValue());
             return statement;
         }
     }
 
     /**
-     * Builder for prepareStatement(String sql, String[] columnNames)
+     * Builder for prepareStatement(String sql, String[] columnNames).
      */
     private class PreparedStatementWithColumnNames implements StatementBuilder {
         @Override
         public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareStatement(
-                    _sql, _columnNames);
+            final PreparedStatement statement = connection.prepareStatement(sql, columnNames);
             return statement;
         }
     }
 
     /**
-     * Builder for prepareCall(String sql)
+     * Builder for prepareCall(String sql).
      */
     private class PreparedCallSQL implements StatementBuilder {
         @Override
         public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareCall(_sql);
+            final PreparedStatement statement = connection.prepareCall(sql);
             return statement;
         }
     }
 
     /**
-     * Builder for prepareCall(String sql, int resultSetType, int resultSetConcurrency)
+     * Builder for prepareCall(String sql, int resultSetType, int resultSetConcurrency).
      */
     private class PreparedCallWithResultSetConcurrency implements StatementBuilder {
         @Override
         public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareCall(
-                    _sql, _resultSetType.intValue(), _resultSetConcurrency.intValue());
+            final PreparedStatement statement = connection.prepareCall(sql, resultSetType.intValue(),
+                    resultSetConcurrency.intValue());
             return statement;
         }
     }
 
     /**
-     * Builder for prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability)
+     * Builder for prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability).
      */
     private class PreparedCallWithResultSetHoldability implements StatementBuilder {
         @Override
         public Statement createStatement(final Connection connection) throws SQLException {
-            final PreparedStatement statement = connection.prepareCall(
-                    _sql, _resultSetType.intValue(), _resultSetConcurrency.intValue(),
-                    _resultSetHoldability.intValue());
+            final PreparedStatement statement = connection.prepareCall(sql, resultSetType.intValue(),
+                    resultSetConcurrency.intValue(), resultSetHoldability.intValue());
             return statement;
         }
     }

==================================================
PoolableConnection.java
index 9fb2bfd19c..486da288bc 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/PoolableCallableStatement.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolableCallableStatement.java
@@ -26,8 +26,8 @@ import java.util.List;
 import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
 
 /**
- * A {@link DelegatingCallableStatement} that cooperates with
- * {@link PoolingConnection} to implement a pool of {@link CallableStatement}s.
+ * A {@link DelegatingCallableStatement} that cooperates with {@link PoolingConnection} to implement a pool of
+ * {@link CallableStatement}s.
  * <p>
  * The {@link #close} method returns this statement to its containing pool. (See {@link PoolingConnection}.)
  *
@@ -39,75 +39,83 @@ public class PoolableCallableStatement extends DelegatingCallableStatement {
     /**
      * The {@link KeyedObjectPool} from which this CallableStatement was obtained.
      */
-    private final KeyedObjectPool<PStmtKey,DelegatingPreparedStatement> _pool;
+    private final KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> pool;
 
     /**
      * Key for this statement in the containing {@link KeyedObjectPool}.
      */
-    private final PStmtKey _key;
+    private final PStmtKey key;
 
     /**
      * Constructor.
      *
-     * @param stmt the underlying {@link CallableStatement}
-     * @param key the key for this statement in the {@link KeyedObjectPool}
-     * @param pool the {@link KeyedObjectPool} from which this CallableStatement was obtained
-     * @param conn the {@link DelegatingConnection} that created this CallableStatement
+     * @param callableStatement
+     *            the underlying {@link CallableStatement}
+     * @param key
+     *            the key for this statement in the {@link KeyedObjectPool}
+     * @param pool
+     *            the {@link KeyedObjectPool} from which this CallableStatement was obtained
+     * @param connection
+     *            the {@link DelegatingConnection} that created this CallableStatement
      */
-    public PoolableCallableStatement(final CallableStatement stmt, final PStmtKey key,
-            final KeyedObjectPool<PStmtKey,DelegatingPreparedStatement> pool,
-            final DelegatingConnection<Connection> conn) {
-        super(conn, stmt);
-        _pool = pool;
-        _key = key;
+    public PoolableCallableStatement(final CallableStatement callableStatement, final PStmtKey key,
+            final KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> pool,
+            final DelegatingConnection<Connection> connection) {
+        super(connection, callableStatement);
+        this.pool = pool;
+        this.key = key;
 
         // Remove from trace now because this statement will be
         // added by the activate method.
-        if(getConnectionInternal() != null) {
+        if (getConnectionInternal() != null) {
             getConnectionInternal().removeTrace(this);
         }
     }
 
     /**
-     * Returns the CallableStatement to the pool.  If {{@link #isClosed()}, this is a No-op.
+     * Returns the CallableStatement to the pool. If {{@link #isClosed()}, this is a No-op.
      */
     @Override
     public void close() throws SQLException {
         // calling close twice should have no effect
         if (!isClosed()) {
             try {
-                _pool.returnObject(_key,this);
-            } catch(final SQLException e) {
+                pool.returnObject(key, this);
+            } catch (final SQLException e) {
                 throw e;
-            } catch(final RuntimeException e) {
+            } catch (final RuntimeException e) {
                 throw e;
-            } catch(final Exception e) {
+            } catch (final Exception e) {
                 throw new SQLException("Cannot close CallableStatement (return to pool failed)", e);
             }
         }
     }
 
     /**
-     * Activates after retrieval from the pool. Adds a trace for this CallableStatement to the Connection
-     * that created it.
+     * Activates after retrieval from the pool. Adds a trace for this CallableStatement to the Connection that created
+     * it.
+     *
+     * @since 2.4.0 made public, was protected in 2.3.0.
      */
     @Override
-    protected void activate() throws SQLException {
+    public void activate() throws SQLException {
         setClosedInternal(false);
-        if( getConnectionInternal() != null ) {
-            getConnectionInternal().addTrace( this );
+        if (getConnectionInternal() != null) {
+            getConnectionInternal().addTrace(this);
         }
         super.activate();
     }
 
     /**
-     * Passivates to prepare for return to the pool.  Removes the trace associated with this CallableStatement
-     * from the Connection that created it.  Also closes any associated ResultSets.
+     * Passivates to prepare for return to the pool. Removes the trace associated with this CallableStatement from the
+     * Connection that created it. Also closes any associated ResultSets.
+     *
+     * @since 2.4.0 made public, was protected in 2.3.0.
      */
     @Override
-    protected void passivate() throws SQLException {
+    public void passivate() throws SQLException {
         setClosedInternal(true);
-        if( getConnectionInternal() != null ) {
+        if (getConnectionInternal() != null) {
             getConnectionInternal().removeTrace(this);
         }
 
@@ -116,7 +124,7 @@ public class PoolableCallableStatement extends DelegatingCallableStatement {
         // FIXME The PreparedStatement we're wrapping should handle this for us.
         // See DBCP-10 for what could happen when ResultSets are closed twice.
         final List<AbandonedTrace> resultSets = getTrace();
-        if(resultSets != null) {
+        if (resultSets != null) {
             final ResultSet[] set = resultSets.toArray(new ResultSet[resultSets.size()]);
             for (final ResultSet element : set) {
                 element.close();

==================================================
PoolableConnectionFactory.java
index 045f4896be..7be241b793 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/PoolableConnection.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolableConnection.java
@@ -24,7 +24,6 @@ import java.sql.SQLException;
 import java.util.Collection;
 
 import javax.management.InstanceAlreadyExistsException;
-import javax.management.InstanceNotFoundException;
 import javax.management.MBeanRegistrationException;
 import javax.management.MBeanServer;
 import javax.management.NotCompliantMBeanException;
@@ -33,19 +32,14 @@ import javax.management.ObjectName;
 import org.apache.tomcat.dbcp.pool2.ObjectPool;
 
 /**
- * A delegating connection that, rather than closing the underlying
- * connection, returns itself to an {@link ObjectPool} when
- * closed.
+ * A delegating connection that, rather than closing the underlying connection, returns itself to an {@link ObjectPool}
+ * when closed.
  *
- * @author Rodney Waldhoff
- * @author Glenn L. Nielsen
- * @author James House
  * @since 2.0
  */
-public class PoolableConnection extends DelegatingConnection<Connection>
-        implements PoolableConnectionMXBean {
+public class PoolableConnection extends DelegatingConnection<Connection> implements PoolableConnectionMXBean {
 
-    private static MBeanServer MBEAN_SERVER = null;
+    private static MBeanServer MBEAN_SERVER;
 
     static {
         try {
@@ -56,70 +50,75 @@ public class PoolableConnection extends DelegatingConnection<Connection>
     }
 
     /** The pool to which I should return. */
-    private final ObjectPool<PoolableConnection> _pool;
+    private final ObjectPool<PoolableConnection> pool;
 
-    private final ObjectName _jmxName;
+    private final ObjectNameWrapper jmxObjectName;
 
     // Use a prepared statement for validation, retaining the last used SQL to
     // check if the validation query has changed.
-    private PreparedStatement validationPreparedStatement = null;
-    private String lastValidationSql = null;
+    private PreparedStatement validationPreparedStatement;
+    private String lastValidationSql;
 
     /**
-     *  Indicate that unrecoverable SQLException was thrown when using this connection.
-     *  Such a connection should be considered broken and not pass validation in the future.
+     * Indicate that unrecoverable SQLException was thrown when using this connection. Such a connection should be
+     * considered broken and not pass validation in the future.
      */
-    private boolean _fatalSqlExceptionThrown = false;
+    private boolean fatalSqlExceptionThrown = false;
 
     /**
-     * SQL_STATE codes considered to signal fatal conditions. Overrides the
-     * defaults in {@link Utils#DISCONNECTION_SQL_CODES} (plus anything starting
-     * with {@link Utils#DISCONNECTION_SQL_CODE_PREFIX}).
+     * SQL_STATE codes considered to signal fatal conditions. Overrides the defaults in
+     * {@link Utils#DISCONNECTION_SQL_CODES} (plus anything starting with {@link Utils#DISCONNECTION_SQL_CODE_PREFIX}).
      */
-    private final Collection<String> _disconnectionSqlCodes;
+    private final Collection<String> disconnectionSqlCodes;
 
     /** Whether or not to fast fail validation after fatal connection errors */
-    private final boolean _fastFailValidation;
+    private final boolean fastFailValidation;
 
     /**
      *
-     * @param conn my underlying connection
-     * @param pool the pool to which I should return when closed
-     * @param jmxName JMX name
-     * @param disconnectSqlCodes SQL_STATE codes considered fatal disconnection errors
-     * @param fastFailValidation true means fatal disconnection errors cause subsequent
-     *        validations to fail immediately (no attempt to run query or isValid)
+     * @param conn
+     *            my underlying connection
+     * @param pool
+     *            the pool to which I should return when closed
+     * @param jmxObjectName
+     *            JMX name
+     * @param disconnectSqlCodes
+     *            SQL_STATE codes considered fatal disconnection errors
+     * @param fastFailValidation
+     *            true means fatal disconnection errors cause subsequent validations to fail immediately (no attempt to
+     *            run query or isValid)
      */
-    public PoolableConnection(final Connection conn,
-            final ObjectPool<PoolableConnection> pool, final ObjectName jmxName, final Collection<String> disconnectSqlCodes,
+    public PoolableConnection(final Connection conn, final ObjectPool<PoolableConnection> pool,
+            final ObjectName jmxObjectName, final Collection<String> disconnectSqlCodes,
             final boolean fastFailValidation) {
         super(conn);
-        _pool = pool;
-        _jmxName = jmxName;
-        _disconnectionSqlCodes = disconnectSqlCodes;
-        _fastFailValidation = fastFailValidation;
+        this.pool = pool;
+        this.jmxObjectName = ObjectNameWrapper.wrap(jmxObjectName);
+        this.disconnectionSqlCodes = disconnectSqlCodes;
+        this.fastFailValidation = fastFailValidation;
 
-        if (jmxName != null) {
+        if (jmxObjectName != null) {
             try {
-                MBEAN_SERVER.registerMBean(this, jmxName);
-            } catch (InstanceAlreadyExistsException |
-                    MBeanRegistrationException | NotCompliantMBeanException e) {
+                MBEAN_SERVER.registerMBean(this, jmxObjectName);
+            } catch (InstanceAlreadyExistsException | MBeanRegistrationException | NotCompliantMBeanException e) {
                 // For now, simply skip registration
             }
         }
     }
 
     /**
-    *
-    * @param conn my underlying connection
-    * @param pool the pool to which I should return when closed
-    * @param jmxName JMX name
-    */
-   public PoolableConnection(final Connection conn,
-           final ObjectPool<PoolableConnection> pool, final ObjectName jmxName) {
-       this(conn, pool, jmxName, null, false);
-   }
-
+     *
+     * @param conn
+     *            my underlying connection
+     * @param pool
+     *            the pool to which I should return when closed
+     * @param jmxName
+     *            JMX name
+     */
+    public PoolableConnection(final Connection conn, final ObjectPool<PoolableConnection> pool,
+            final ObjectName jmxName) {
+        this(conn, pool, jmxName, null, false);
+    }
 
     @Override
     protected void passivate() throws SQLException {
@@ -127,14 +126,12 @@ public class PoolableConnection extends DelegatingConnection<Connection>
         setClosedInternal(true);
     }
 
-
     /**
      * {@inheritDoc}
      * <p>
-     * This method should not be used by a client to determine whether or not a
-     * connection should be return to the connection pool (by calling
-     * {@link #close()}). Clients should always attempt to return a connection
-     * to the pool once it is no longer required.
+     * This method should not be used by a client to determine whether or not a connection should be return to the
+     * connection pool (by calling {@link #close()}). Clients should always attempt to return a connection to the pool
+     * once it is no longer required.
      */
     @Override
     public boolean isClosed() throws SQLException {
@@ -153,11 +150,10 @@ public class PoolableConnection extends DelegatingConnection<Connection>
         return false;
     }
 
-
     /**
      * Returns me to my pool.
      */
-     @Override
+    @Override
     public synchronized void close() throws SQLException {
         if (isClosedInternal()) {
             // already closed
@@ -169,8 +165,8 @@ public class PoolableConnection extends DelegatingConnection<Connection>
             isUnderlyingConnectionClosed = getDelegateInternal().isClosed();
         } catch (final SQLException e) {
             try {
-                _pool.invalidateObject(this);
-            } catch(final IllegalStateException ise) {
+                pool.invalidateObject(this);
+            } catch (final IllegalStateException ise) {
                 // pool is closed, so close the connection
                 passivate();
                 getInnermostDelegate().close();
@@ -180,18 +176,17 @@ public class PoolableConnection extends DelegatingConnection<Connection>
             throw new SQLException("Cannot close connection (isClosed check failed)", e);
         }
 
-        /* Can't set close before this code block since the connection needs to
-         * be open when validation runs. Can't set close after this code block
-         * since by then the connection will have been returned to the pool and
-         * may have been borrowed by another thread. Therefore, the close flag
-         * is set in passivate().
+        /*
+         * Can't set close before this code block since the connection needs to be open when validation runs. Can't set
+         * close after this code block since by then the connection will have been returned to the pool and may have
+         * been borrowed by another thread. Therefore, the close flag is set in passivate().
          */
         if (isUnderlyingConnectionClosed) {
             // Abnormal close: underlying connection closed unexpectedly, so we
             // must destroy this proxy
             try {
-                _pool.invalidateObject(this);
-            } catch(final IllegalStateException e) {
+                pool.invalidateObject(this);
+            } catch (final IllegalStateException e) {
                 // pool is closed, so close the connection
                 passivate();
                 getInnermostDelegate().close();
@@ -202,16 +197,16 @@ public class PoolableConnection extends DelegatingConnection<Connection>
             // Normal close: underlying connection is still open, so we
             // simply need to return this proxy to the pool
             try {
-                _pool.returnObject(this);
-            } catch(final IllegalStateException e) {
+                pool.returnObject(this);
+            } catch (final IllegalStateException e) {
                 // pool is closed, so close the connection
                 passivate();
                 getInnermostDelegate().close();
-            } catch(final SQLException e) {
+            } catch (final SQLException e) {
                 throw e;
-            } catch(final RuntimeException e) {
+            } catch (final RuntimeException e) {
                 throw e;
-            } catch(final Exception e) {
+            } catch (final Exception e) {
                 throw new SQLException("Cannot close connection (return to pool failed)", e);
             }
         }
@@ -222,15 +217,10 @@ public class PoolableConnection extends DelegatingConnection<Connection>
      */
     @Override
     public void reallyClose() throws SQLException {
-        if (_jmxName != null) {
-            try {
-                MBEAN_SERVER.unregisterMBean(_jmxName);
-            } catch (MBeanRegistrationException | InstanceNotFoundException e) {
-                // Ignore
-            }
+        if (jmxObjectName != null) {
+            jmxObjectName.unregisterMBean();
         }
 
-
         if (validationPreparedStatement != null) {
             try {
                 validationPreparedStatement.close();
@@ -242,10 +232,8 @@ public class PoolableConnection extends DelegatingConnection<Connection>
         super.closeInternal();
     }
 
-
     /**
-     * Expose the {@link #toString()} method via a bean getter so it can be read
-     * as a property via JMX.
+     * Expose the {@link #toString()} method via a bean getter so it can be read as a property via JMX.
      */
     @Override
     public String getToString() {
@@ -255,31 +243,31 @@ public class PoolableConnection extends DelegatingConnection<Connection>
     /**
      * Validates the connection, using the following algorithm:
      * <ol>
-     *   <li>If {@code fastFailValidation} (constructor argument) is {@code true} and
-     *       this connection has previously thrown a fatal disconnection exception,
-     *       a {@code SQLException} is thrown. </li>
-     *   <li>If {@code sql} is null, the driver's
-     *       #{@link Connection#isValid(int) isValid(timeout)} is called.
-     *       If it returns {@code false}, {@code SQLException} is thrown;
-     *       otherwise, this method returns successfully.</li>
-     *   <li>If {@code sql} is not null, it is executed as a query and if the resulting
-     *       {@code ResultSet} contains at least one row, this method returns
-     *       successfully.  If not, {@code SQLException} is thrown.</li>
+     * <li>If {@code fastFailValidation} (constructor argument) is {@code true} and this connection has previously
+     * thrown a fatal disconnection exception, a {@code SQLException} is thrown.</li>
+     * <li>If {@code sql} is null, the driver's #{@link Connection#isValid(int) isValid(timeout)} is called. If it
+     * returns {@code false}, {@code SQLException} is thrown; otherwise, this method returns successfully.</li>
+     * <li>If {@code sql} is not null, it is executed as a query and if the resulting {@code ResultSet} contains at
+     * least one row, this method returns successfully. If not, {@code SQLException} is thrown.</li>
      * </ol>
-     * @param sql validation query
-     * @param timeout validation timeout
-     * @throws SQLException if validation fails or an SQLException occurs during validation
+     *
+     * @param sql
+     *            The validation SQL query.
+     * @param timeoutSeconds
+     *            The validation timeout in seconds.
+     * @throws SQLException
+     *             Thrown when validation fails or an SQLException occurs during validation
      */
-    public void validate(final String sql, int timeout) throws SQLException {
-        if (_fastFailValidation && _fatalSqlExceptionThrown) {
+    public void validate(final String sql, int timeoutSeconds) throws SQLException {
+        if (fastFailValidation && fatalSqlExceptionThrown) {
             throw new SQLException(Utils.getMessage("poolableConnection.validate.fastFail"));
         }
 
         if (sql == null || sql.length() == 0) {
-            if (timeout < 0) {
-                timeout = 0;
+            if (timeoutSeconds < 0) {
+                timeoutSeconds = 0;
             }
-            if (!isValid(timeout)) {
+            if (!isValid(timeoutSeconds)) {
                 throw new SQLException("isValid() returned false");
             }
             return;
@@ -289,16 +277,15 @@ public class PoolableConnection extends DelegatingConnection<Connection>
             lastValidationSql = sql;
             // Has to be the innermost delegate else the prepared statement will
             // be closed when the pooled connection is passivated.
-            validationPreparedStatement =
-                    getInnermostDelegateInternal().prepareStatement(sql);
+            validationPreparedStatement = getInnermostDelegateInternal().prepareStatement(sql);
         }
 
-        if (timeout > 0) {
-            validationPreparedStatement.setQueryTimeout(timeout);
+        if (timeoutSeconds > 0) {
+            validationPreparedStatement.setQueryTimeout(timeoutSeconds);
         }
 
         try (ResultSet rs = validationPreparedStatement.executeQuery()) {
-            if(!rs.next()) {
+            if (!rs.next()) {
                 throw new SQLException("validationQuery didn't return a row");
             }
         } catch (final SQLException sqle) {
@@ -306,24 +293,27 @@ public class PoolableConnection extends DelegatingConnection<Connection>
         }
     }
 
-    /*
+    /**
      * Checks the SQLState of the input exception and any nested SQLExceptions it wraps.
+     * <p>
+     * If {@link #getDisconnectSqlCodes() disconnectSQLCodes} has been set, sql states are compared to those in the
+     * configured list of fatal exception codes. If this property is not set, codes are compared against the default
+     * codes in #{@link Utils.DISCONNECTION_SQL_CODES} and in this case anything starting with #{link
+     * Utils.DISCONNECTION_SQL_CODE_PREFIX} is considered a disconnection.
+     * </p>
      *
-     * If _disconnectSQLCodes has been set, sql states
-     * are compared to those in the configured list of fatal exception codes.  If this
-     * property is not set, codes are compared against the default codes in
-     * Utils.DISCONNECTION_SQL_CODES and in this case anything starting with
-     * Utils.DISCONNECTION_SQL_CODE_PREFIX is considered a disconnection.</p>
-     *
-     * @param e SQLException to be examined
+     * @param e
+     *            SQLException to be examined
      * @return true if the exception signals a disconnection
      */
     private boolean isDisconnectionSqlException(final SQLException e) {
         boolean fatalException = false;
         final String sqlState = e.getSQLState();
         if (sqlState != null) {
-            fatalException = _disconnectionSqlCodes == null ? sqlState.startsWith(Utils.DISCONNECTION_SQL_CODE_PREFIX)
-                    || Utils.DISCONNECTION_SQL_CODES.contains(sqlState) : _disconnectionSqlCodes.contains(sqlState);
+            fatalException = disconnectionSqlCodes == null
+                    ? sqlState.startsWith(Utils.DISCONNECTION_SQL_CODE_PREFIX)
+                            || Utils.DISCONNECTION_SQL_CODES.contains(sqlState)
+                    : disconnectionSqlCodes.contains(sqlState);
             if (!fatalException) {
                 final SQLException nextException = e.getNextException();
                 if (nextException != null && nextException != e) {
@@ -336,8 +326,7 @@ public class PoolableConnection extends DelegatingConnection<Connection>
 
     @Override
     protected void handleException(final SQLException e) throws SQLException {
-        _fatalSqlExceptionThrown |= isDisconnectionSqlException(e);
+        fatalSqlExceptionThrown |= isDisconnectionSqlException(e);
         super.handleException(e);
     }
 }
-

==================================================
PoolableConnectionMXBean.java
index c53553ed19..ec7d0942c4 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/PoolableConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolableConnectionFactory.java
@@ -21,6 +21,7 @@ import java.sql.Connection;
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.util.Collection;
+import java.util.Objects;
 import java.util.concurrent.atomic.AtomicLong;
 
 import javax.management.ObjectName;
@@ -36,149 +37,167 @@ import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool;
 import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPoolConfig;
 
 /**
- * A {@link PooledObjectFactory} that creates
- * {@link PoolableConnection}s.
+ * A {@link PooledObjectFactory} that creates {@link PoolableConnection}s.
  *
- * @author Rodney Waldhoff
- * @author Glenn L. Nielsen
- * @author James House
- * @author Dirk Verbeeck
  * @since 2.0
  */
-public class PoolableConnectionFactory
-        implements PooledObjectFactory<PoolableConnection> {
+public class PoolableConnectionFactory implements PooledObjectFactory<PoolableConnection> {
 
-    private static final Log log =
-            LogFactory.getLog(PoolableConnectionFactory.class);
+    private static final Log log = LogFactory.getLog(PoolableConnectionFactory.class);
 
     /**
-     * Create a new {@code PoolableConnectionFactory}.
-     * @param connFactory the {@link ConnectionFactory} from which to obtain
-     * @param dataSourceJmxName The JMX name
-     * base {@link Connection}s
+     * Creates a new {@code PoolableConnectionFactory}.
+     *
+     * @param connFactory
+     *            the {@link ConnectionFactory} from which to obtain base {@link Connection}s
+     * @param dataSourceJmxObjectName
+     *            The JMX object name, may be null.
      */
-    public PoolableConnectionFactory(final ConnectionFactory connFactory,
-            final ObjectName dataSourceJmxName) {
-        _connFactory = connFactory;
-        this.dataSourceJmxName = dataSourceJmxName;
+    public PoolableConnectionFactory(final ConnectionFactory connFactory, final ObjectName dataSourceJmxObjectName) {
+        this.connectionFactory = connFactory;
+        this.dataSourceJmxObjectName = dataSourceJmxObjectName;
     }
 
     /**
-     * Sets the query I use to {@link #validateObject validate} {@link Connection}s.
-     * Should return at least one row. If not specified,
-     * {@link Connection#isValid(int)} will be used to validate connections.
+     * Sets the query I use to {@link #validateObject validate} {@link Connection}s. Should return at least one row. If
+     * not specified, {@link Connection#isValid(int)} will be used to validate connections.
      *
-     * @param validationQuery a query to use to {@link #validateObject validate} {@link Connection}s.
+     * @param validationQuery
+     *            a query to use to {@link #validateObject validate} {@link Connection}s.
      */
     public void setValidationQuery(final String validationQuery) {
-        _validationQuery = validationQuery;
+        this.validationQuery = validationQuery;
     }
 
     /**
-     * Sets the validation query timeout, the amount of time, in seconds, that
-     * connection validation will wait for a response from the database when
-     * executing a validation query.  Use a value less than or equal to 0 for
-     * no timeout.
+     * Sets the validation query timeout, the amount of time, in seconds, that connection validation will wait for a
+     * response from the database when executing a validation query. Use a value less than or equal to 0 for no timeout.
      *
-     * @param timeout new validation query timeout value in seconds
+     * @param validationQueryTimeoutSeconds
+     *            new validation query timeout value in seconds
      */
-    public void setValidationQueryTimeout(final int timeout) {
-        _validationQueryTimeout = timeout;
+    public void setValidationQueryTimeout(final int validationQueryTimeoutSeconds) {
+        this.validationQueryTimeoutSeconds = validationQueryTimeoutSeconds;
     }
 
     /**
-     * Sets the SQL statements I use to initialize newly created {@link Connection}s.
-     * Using {@code null} turns off connection initialization.
-     * @param connectionInitSqls SQL statement to initialize {@link Connection}s.
+     * Sets the SQL statements I use to initialize newly created {@link Connection}s. Using {@code null} turns off
+     * connection initialization.
+     *
+     * @param connectionInitSqls
+     *            SQL statement to initialize {@link Connection}s.
      */
     public void setConnectionInitSql(final Collection<String> connectionInitSqls) {
-        _connectionInitSqls = connectionInitSqls;
+        this.connectionInitSqls = connectionInitSqls;
     }
 
     /**
      * Sets the {@link ObjectPool} in which to pool {@link Connection}s.
-     * @param pool the {@link ObjectPool} in which to pool those {@link Connection}s
+     *
+     * @param pool
+     *            the {@link ObjectPool} in which to pool those {@link Connection}s
      */
     public synchronized void setPool(final ObjectPool<PoolableConnection> pool) {
-        if(null != _pool && pool != _pool) {
+        if (null != this.pool && pool != this.pool) {
             try {
-                _pool.close();
-            } catch(final Exception e) {
+                this.pool.close();
+            } catch (final Exception e) {
                 // ignored !?!
             }
         }
-        _pool = pool;
+        this.pool = pool;
     }
 
     /**
      * Returns the {@link ObjectPool} in which {@link Connection}s are pooled.
+     *
      * @return the connection pool
      */
     public synchronized ObjectPool<PoolableConnection> getPool() {
-        return _pool;
+        return pool;
     }
 
     /**
      * Sets the default "read only" setting for borrowed {@link Connection}s
-     * @param defaultReadOnly the default "read only" setting for borrowed {@link Connection}s
+     *
+     * @param defaultReadOnly
+     *            the default "read only" setting for borrowed {@link Connection}s
      */
     public void setDefaultReadOnly(final Boolean defaultReadOnly) {
-        _defaultReadOnly = defaultReadOnly;
+        this.defaultReadOnly = defaultReadOnly;
     }
 
     /**
      * Sets the default "auto commit" setting for borrowed {@link Connection}s
-     * @param defaultAutoCommit the default "auto commit" setting for borrowed {@link Connection}s
+     *
+     * @param defaultAutoCommit
+     *            the default "auto commit" setting for borrowed {@link Connection}s
      */
     public void setDefaultAutoCommit(final Boolean defaultAutoCommit) {
-        _defaultAutoCommit = defaultAutoCommit;
+        this.defaultAutoCommit = defaultAutoCommit;
     }
 
     /**
      * Sets the default "Transaction Isolation" setting for borrowed {@link Connection}s
-     * @param defaultTransactionIsolation the default "Transaction Isolation" setting for returned {@link Connection}s
+     *
+     * @param defaultTransactionIsolation
+     *            the default "Transaction Isolation" setting for returned {@link Connection}s
      */
     public void setDefaultTransactionIsolation(final int defaultTransactionIsolation) {
-        _defaultTransactionIsolation = defaultTransactionIsolation;
+        this.defaultTransactionIsolation = defaultTransactionIsolation;
     }
 
     /**
      * Sets the default "catalog" setting for borrowed {@link Connection}s
-     * @param defaultCatalog the default "catalog" setting for borrowed {@link Connection}s
+     *
+     * @param defaultCatalog
+     *            the default "catalog" setting for borrowed {@link Connection}s
      */
     public void setDefaultCatalog(final String defaultCatalog) {
-        _defaultCatalog = defaultCatalog;
+        this.defaultCatalog = defaultCatalog;
     }
 
     public void setCacheState(final boolean cacheState) {
-        this._cacheState = cacheState;
+        this.cacheState = cacheState;
     }
 
     public void setPoolStatements(final boolean poolStatements) {
         this.poolStatements = poolStatements;
     }
 
+    /**
+     * Deprecated due to typo in method name.
+     *
+     * @param maxOpenPreparedStatements
+     *            The maximum number of open prepared statements.
+     * @deprecated Use {@link #setMaxOpenPreparedStatements(int)}.
+     */
     @Deprecated // Due to typo in method name.
     public void setMaxOpenPrepatedStatements(final int maxOpenPreparedStatements) {
         setMaxOpenPreparedStatements(maxOpenPreparedStatements);
     }
 
+    /**
+     * Sets the maximum number of open prepared statements.
+     *
+     * @param maxOpenPreparedStatements
+     *            The maximum number of open prepared statements.
+     */
     public void setMaxOpenPreparedStatements(final int maxOpenPreparedStatements) {
         this.maxOpenPreparedStatements = maxOpenPreparedStatements;
     }
 
     /**
-     * Sets the maximum lifetime in milliseconds of a connection after which the
-     * connection will always fail activation, passivation and validation. A
-     * value of zero or less indicates an infinite lifetime. The default value
-     * is -1.
-     * @param maxConnLifetimeMillis The maximum connection lifetime
+     * Sets the maximum lifetime in milliseconds of a connection after which the connection will always fail activation,
+     * passivation and validation. A value of zero or less indicates an infinite lifetime. The default value is -1.
+     *
+     * @param maxConnLifetimeMillis
+     *            The maximum lifetime in milliseconds.
      */
     public void setMaxConnLifetimeMillis(final long maxConnLifetimeMillis) {
         this.maxConnLifetimeMillis = maxConnLifetimeMillis;
     }
 
-
     public boolean isEnableAutoCommitOnReturn() {
         return enableAutoCommitOnReturn;
     }
@@ -187,7 +206,6 @@ public class PoolableConnectionFactory
         this.enableAutoCommitOnReturn = enableAutoCommitOnReturn;
     }
 
-
     public boolean isRollbackOnReturn() {
         return rollbackOnReturn;
     }
@@ -197,69 +215,68 @@ public class PoolableConnectionFactory
     }
 
     public Integer getDefaultQueryTimeout() {
-        return defaultQueryTimeout;
+        return defaultQueryTimeoutSeconds;
     }
 
-    public void setDefaultQueryTimeout(final Integer defaultQueryTimeout) {
-        this.defaultQueryTimeout = defaultQueryTimeout;
+    public void setDefaultQueryTimeout(final Integer defaultQueryTimeoutSeconds) {
+        this.defaultQueryTimeoutSeconds = defaultQueryTimeoutSeconds;
     }
 
     /**
      * SQL_STATE codes considered to signal fatal conditions.
      * <p>
-     * Overrides the defaults in {@link Utils#DISCONNECTION_SQL_CODES}
-     * (plus anything starting with {@link Utils#DISCONNECTION_SQL_CODE_PREFIX}).
-     * If this property is non-null and {@link #isFastFailValidation()} is
-     * {@code true}, whenever connections created by this factory generate exceptions
-     * with SQL_STATE codes in this list, they will be marked as "fatally disconnected"
-     * and subsequent validations will fail fast (no attempt at isValid or validation
-     * query).</p>
+     * Overrides the defaults in {@link Utils#DISCONNECTION_SQL_CODES} (plus anything starting with
+     * {@link Utils#DISCONNECTION_SQL_CODE_PREFIX}). If this property is non-null and {@link #isFastFailValidation()} is
+     * {@code true}, whenever connections created by this factory generate exceptions with SQL_STATE codes in this list,
+     * they will be marked as "fatally disconnected" and subsequent validations will fail fast (no attempt at isValid or
+     * validation query).
+     * </p>
      * <p>
-     * If {@link #isFastFailValidation()} is {@code false} setting this property has no
-     * effect.</p>
+     * If {@link #isFastFailValidation()} is {@code false} setting this property has no effect.
+     * </p>
      *
      * @return SQL_STATE codes overriding defaults
      * @since 2.1
      */
     public Collection<String> getDisconnectionSqlCodes() {
-        return _disconnectionSqlCodes;
+        return disconnectionSqlCodes;
     }
 
     /**
+     * @param disconnectionSqlCodes
+     *            The disconnection SQL codes.
      * @see #getDisconnectionSqlCodes()
-     * @param disconnectionSqlCodes The disconnection codes
      * @since 2.1
      */
     public void setDisconnectionSqlCodes(final Collection<String> disconnectionSqlCodes) {
-        _disconnectionSqlCodes = disconnectionSqlCodes;
+        this.disconnectionSqlCodes = disconnectionSqlCodes;
     }
 
     /**
-     * True means that validation will fail immediately for connections that
-     * have previously thrown SQLExceptions with SQL_STATE indicating fatal
-     * disconnection errors.
+     * True means that validation will fail immediately for connections that have previously thrown SQLExceptions with
+     * SQL_STATE indicating fatal disconnection errors.
      *
      * @return true if connections created by this factory will fast fail validation.
      * @see #setDisconnectionSqlCodes(Collection)
      * @since 2.1
      */
     public boolean isFastFailValidation() {
-        return _fastFailValidation;
+        return fastFailValidation;
     }
 
     /**
      * @see #isFastFailValidation()
-     * @param fastFailValidation true means connections created by this factory will
-     * fast fail validation
+     * @param fastFailValidation
+     *            true means connections created by this factory will fast fail validation
      * @since 2.1
      */
     public void setFastFailValidation(final boolean fastFailValidation) {
-        _fastFailValidation = fastFailValidation;
+        this.fastFailValidation = fastFailValidation;
     }
 
     @Override
     public PooledObject<PoolableConnection> makeObject() throws Exception {
-        Connection conn = _connFactory.createConnection();
+        Connection conn = connectionFactory.createConnection();
         if (conn == null) {
             throw new IllegalStateException("Connection factory returned null from createConnection");
         }
@@ -278,16 +295,16 @@ public class PoolableConnectionFactory
 
         final long connIndex = connectionIndex.getAndIncrement();
 
-        if(poolStatements) {
+        if (poolStatements) {
             conn = new PoolingConnection(conn);
-            final GenericKeyedObjectPoolConfig<DelegatingPreparedStatement> config = new GenericKeyedObjectPoolConfig<>();
+            final GenericKeyedObjectPoolConfig config = new GenericKeyedObjectPoolConfig();
             config.setMaxTotalPerKey(-1);
             config.setBlockWhenExhausted(false);
             config.setMaxWaitMillis(0);
             config.setMaxIdlePerKey(1);
             config.setMaxTotal(maxOpenPreparedStatements);
-            if (dataSourceJmxName != null) {
-                final StringBuilder base = new StringBuilder(dataSourceJmxName.toString());
+            if (dataSourceJmxObjectName != null) {
+                final StringBuilder base = new StringBuilder(dataSourceJmxObjectName.toString());
                 base.append(Constants.JMX_CONNECTION_BASE_EXT);
                 base.append(Long.toString(connIndex));
                 config.setJmxNameBase(base.toString());
@@ -295,40 +312,37 @@ public class PoolableConnectionFactory
             } else {
                 config.setJmxEnabled(false);
             }
-            final KeyedObjectPool<PStmtKey,DelegatingPreparedStatement> stmtPool =
-                    new GenericKeyedObjectPool<>((PoolingConnection)conn, config);
-            ((PoolingConnection)conn).setStatementPool(stmtPool);
-            ((PoolingConnection) conn).setCacheState(_cacheState);
+            final KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> stmtPool = new GenericKeyedObjectPool<>(
+                    (PoolingConnection) conn, config);
+            ((PoolingConnection) conn).setStatementPool(stmtPool);
+            ((PoolingConnection) conn).setCacheState(cacheState);
         }
 
         // Register this connection with JMX
         ObjectName connJmxName;
-        if (dataSourceJmxName == null) {
+        if (dataSourceJmxObjectName == null) {
             connJmxName = null;
         } else {
-            connJmxName = new ObjectName(dataSourceJmxName.toString() +
-                    Constants.JMX_CONNECTION_BASE_EXT + connIndex);
+            connJmxName = new ObjectName(
+                    dataSourceJmxObjectName.toString() + Constants.JMX_CONNECTION_BASE_EXT + connIndex);
         }
 
-        final PoolableConnection pc = new PoolableConnection(conn, _pool, connJmxName,
-                                      _disconnectionSqlCodes, _fastFailValidation);
-        pc.setCacheState(_cacheState);
+        final PoolableConnection pc = new PoolableConnection(conn, pool, connJmxName, disconnectionSqlCodes,
+                fastFailValidation);
+        pc.setCacheState(cacheState);
 
         return new DefaultPooledObject<>(pc);
     }
 
     protected void initializeConnection(final Connection conn) throws SQLException {
-        final Collection<String> sqls = _connectionInitSqls;
-        if(conn.isClosed()) {
+        final Collection<String> sqls = connectionInitSqls;
+        if (conn.isClosed()) {
             throw new SQLException("initializeConnection: connection closed");
         }
-        if(null != sqls) {
+        if (null != sqls) {
             try (Statement stmt = conn.createStatement()) {
                 for (final String sql : sqls) {
-                    if (sql == null) {
-                        throw new NullPointerException(
-                                "null connectionInitSqls element");
-                    }
+                    Objects.requireNonNull(sql, "null connectionInitSqls element");
                     stmt.execute(sql);
                 }
             }
@@ -336,8 +350,7 @@ public class PoolableConnectionFactory
     }
 
     @Override
-    public void destroyObject(final PooledObject<PoolableConnection> p)
-            throws Exception {
+    public void destroyObject(final PooledObject<PoolableConnection> p) throws Exception {
         p.getObject().reallyClose();
     }
 
@@ -350,23 +363,21 @@ public class PoolableConnectionFactory
             return true;
         } catch (final Exception e) {
             if (log.isDebugEnabled()) {
-                log.debug(Utils.getMessage(
-                        "poolableConnectionFactory.validateObject.fail"), e);
+                log.debug(Utils.getMessage("poolableConnectionFactory.validateObject.fail"), e);
             }
             return false;
         }
     }
 
     public void validateConnection(final PoolableConnection conn) throws SQLException {
-        if(conn.isClosed()) {
+        if (conn.isClosed()) {
             throw new SQLException("validateConnection: connection closed");
         }
-        conn.validate(_validationQuery, _validationQueryTimeout);
+        conn.validate(validationQuery, validationQueryTimeoutSeconds);
     }
 
     @Override
-    public void passivateObject(final PooledObject<PoolableConnection> p)
-            throws Exception {
+    public void passivateObject(final PooledObject<PoolableConnection> p) throws Exception {
 
         validateLifetime(p);
 
@@ -374,7 +385,7 @@ public class PoolableConnectionFactory
         Boolean connAutoCommit = null;
         if (rollbackOnReturn) {
             connAutoCommit = Boolean.valueOf(conn.getAutoCommit());
-            if(!connAutoCommit.booleanValue() && !conn.isReadOnly()) {
+            if (!connAutoCommit.booleanValue() && !conn.isReadOnly()) {
                 conn.rollback();
             }
         }
@@ -387,7 +398,7 @@ public class PoolableConnectionFactory
             if (connAutoCommit == null) {
                 connAutoCommit = Boolean.valueOf(conn.getAutoCommit());
             }
-            if(!connAutoCommit.booleanValue()) {
+            if (!connAutoCommit.booleanValue()) {
                 conn.setAutoCommit(true);
             }
         }
@@ -396,48 +407,41 @@ public class PoolableConnectionFactory
     }
 
     @Override
-    public void activateObject(final PooledObject<PoolableConnection> p)
-            throws Exception {
+    public void activateObject(final PooledObject<PoolableConnection> p) throws Exception {
 
         validateLifetime(p);
 
         final PoolableConnection conn = p.getObject();
         conn.activate();
 
-        if (_defaultAutoCommit != null &&
-                conn.getAutoCommit() != _defaultAutoCommit.booleanValue()) {
-            conn.setAutoCommit(_defaultAutoCommit.booleanValue());
+        if (defaultAutoCommit != null && conn.getAutoCommit() != defaultAutoCommit.booleanValue()) {
+            conn.setAutoCommit(defaultAutoCommit.booleanValue());
         }
-        if (_defaultTransactionIsolation != UNKNOWN_TRANSACTIONISOLATION &&
-                conn.getTransactionIsolation() != _defaultTransactionIsolation) {
-            conn.setTransactionIsolation(_defaultTransactionIsolation);
+        if (defaultTransactionIsolation != UNKNOWN_TRANSACTIONISOLATION
+                && conn.getTransactionIsolation() != defaultTransactionIsolation) {
+            conn.setTransactionIsolation(defaultTransactionIsolation);
         }
-        if (_defaultReadOnly != null &&
-                conn.isReadOnly() != _defaultReadOnly.booleanValue()) {
-            conn.setReadOnly(_defaultReadOnly.booleanValue());
+        if (defaultReadOnly != null && conn.isReadOnly() != defaultReadOnly.booleanValue()) {
+            conn.setReadOnly(defaultReadOnly.booleanValue());
         }
-        if (_defaultCatalog != null &&
-                !_defaultCatalog.equals(conn.getCatalog())) {
-            conn.setCatalog(_defaultCatalog);
+        if (defaultCatalog != null && !defaultCatalog.equals(conn.getCatalog())) {
+            conn.setCatalog(defaultCatalog);
         }
-        conn.setDefaultQueryTimeout(defaultQueryTimeout);
+        conn.setDefaultQueryTimeout(defaultQueryTimeoutSeconds);
     }
 
-    private void validateLifetime(final PooledObject<PoolableConnection> p)
-            throws Exception {
+    private void validateLifetime(final PooledObject<PoolableConnection> p) throws Exception {
         if (maxConnLifetimeMillis > 0) {
             final long lifetime = System.currentTimeMillis() - p.getCreateTime();
             if (lifetime > maxConnLifetimeMillis) {
-                throw new LifetimeExceededException(Utils.getMessage(
-                        "connectionFactory.lifetimeExceeded",
-                        Long.valueOf(lifetime),
-                        Long.valueOf(maxConnLifetimeMillis)));
+                throw new LifetimeExceededException(Utils.getMessage("connectionFactory.lifetimeExceeded",
+                        Long.valueOf(lifetime), Long.valueOf(maxConnLifetimeMillis)));
             }
         }
     }
 
     protected ConnectionFactory getConnectionFactory() {
-        return _connFactory;
+        return connectionFactory;
     }
 
     protected boolean getPoolStatements() {
@@ -449,38 +453,37 @@ public class PoolableConnectionFactory
     }
 
     protected boolean getCacheState() {
-        return _cacheState;
+        return cacheState;
     }
 
     protected ObjectName getDataSourceJmxName() {
-        return dataSourceJmxName;
+        return dataSourceJmxObjectName;
     }
 
     protected AtomicLong getConnectionIndex() {
         return connectionIndex;
     }
 
-    private final ConnectionFactory _connFactory;
-    private final ObjectName dataSourceJmxName;
-    private volatile String _validationQuery = null;
-    private volatile int _validationQueryTimeout = -1;
-    private Collection<String> _connectionInitSqls = null;
-    private Collection<String> _disconnectionSqlCodes = null;
-    private boolean _fastFailValidation = false;
-    private volatile ObjectPool<PoolableConnection> _pool = null;
-    private Boolean _defaultReadOnly = null;
-    private Boolean _defaultAutoCommit = null;
+    private final ConnectionFactory connectionFactory;
+    private final ObjectName dataSourceJmxObjectName;
+    private volatile String validationQuery;
+    private volatile int validationQueryTimeoutSeconds = -1;
+    private Collection<String> connectionInitSqls;
+    private Collection<String> disconnectionSqlCodes;
+    private boolean fastFailValidation;
+    private volatile ObjectPool<PoolableConnection> pool;
+    private Boolean defaultReadOnly;
+    private Boolean defaultAutoCommit;
     private boolean enableAutoCommitOnReturn = true;
     private boolean rollbackOnReturn = true;
-    private int _defaultTransactionIsolation = UNKNOWN_TRANSACTIONISOLATION;
-    private String _defaultCatalog;
-    private boolean _cacheState;
-    private boolean poolStatements = false;
-    private int maxOpenPreparedStatements =
-        GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL_PER_KEY;
+    private int defaultTransactionIsolation = UNKNOWN_TRANSACTIONISOLATION;
+    private String defaultCatalog;
+    private boolean cacheState;
+    private boolean poolStatements;
+    private int maxOpenPreparedStatements = GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL_PER_KEY;
     private long maxConnLifetimeMillis = -1;
     private final AtomicLong connectionIndex = new AtomicLong(0);
-    private Integer defaultQueryTimeout = null;
+    private Integer defaultQueryTimeoutSeconds;
 
     /**
      * Internal constant to indicate the level is not set.

==================================================
PoolablePreparedStatement.java
index dbf9f7ac70..eaa9fddf17 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/PoolableConnectionMXBean.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolableConnectionMXBean.java
@@ -19,41 +19,52 @@ package org.apache.tomcat.dbcp.dbcp2;
 import java.sql.SQLException;
 
 /**
- * Defines the attributes and methods that will be exposed via JMX for
- * {@link PoolableConnection} instances.
+ * Defines the attributes and methods that will be exposed via JMX for {@link PoolableConnection} instances.
+ *
  * @since 2.0
  */
 public interface PoolableConnectionMXBean {
     // Read-only properties
     boolean isClosed() throws SQLException;
-    //SQLWarning getWarnings() throws SQLException;
+
+    // SQLWarning getWarnings() throws SQLException;
     String getToString();
 
     // Read-write properties
     boolean getAutoCommit() throws SQLException;
+
     void setAutoCommit(boolean autoCommit) throws SQLException;
 
     boolean getCacheState();
+
     void setCacheState(boolean cacheState);
 
     String getCatalog() throws SQLException;
+
     void setCatalog(String catalog) throws SQLException;
 
     int getHoldability() throws SQLException;
+
     void setHoldability(int holdability) throws SQLException;
 
     boolean isReadOnly() throws SQLException;
+
     void setReadOnly(boolean readOnly) throws SQLException;
 
     String getSchema() throws SQLException;
+
     void setSchema(String schema) throws SQLException;
 
     int getTransactionIsolation() throws SQLException;
+
     void setTransactionIsolation(int level) throws SQLException;
 
     // Methods
     void clearCachedState();
+
     void clearWarnings() throws SQLException;
+
     void close() throws SQLException;
+
     void reallyClose() throws SQLException;
 }

==================================================
PoolingConnection.java
index 1b88f32593..29136d0255 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/PoolablePreparedStatement.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolablePreparedStatement.java
@@ -25,50 +25,51 @@ import java.util.List;
 import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
 
 /**
- * A {@link DelegatingPreparedStatement} that cooperates with
- * {@link PoolingConnection} to implement a pool of {@link PreparedStatement}s.
+ * A {@link DelegatingPreparedStatement} that cooperates with {@link PoolingConnection} to implement a pool of
+ * {@link PreparedStatement}s.
  * <p>
  * My {@link #close} method returns me to my containing pool. (See {@link PoolingConnection}.)
  *
- * @param <K> the key type
+ * @param <K>
+ *            the key type
  *
  * @see PoolingConnection
- * @author Rodney Waldhoff
- * @author Glenn L. Nielsen
- * @author James House
- * @author Dirk Verbeeck
  * @since 2.0
  */
 public class PoolablePreparedStatement<K> extends DelegatingPreparedStatement {
     /**
      * The {@link KeyedObjectPool} from which I was obtained.
      */
-    private final KeyedObjectPool<K, PoolablePreparedStatement<K>> _pool;
+    private final KeyedObjectPool<K, PoolablePreparedStatement<K>> pool;
 
     /**
      * My "key" as used by {@link KeyedObjectPool}.
      */
-    private final K _key;
+    private final K key;
 
     private volatile boolean batchAdded = false;
 
     /**
      * Constructor
-     * @param stmt my underlying {@link PreparedStatement}
-     * @param key my key" as used by {@link KeyedObjectPool}
-     * @param pool the {@link KeyedObjectPool} from which I was obtained.
-     * @param conn the {@link java.sql.Connection Connection} from which I was created
+     *
+     * @param stmt
+     *            my underlying {@link PreparedStatement}
+     * @param key
+     *            my key" as used by {@link KeyedObjectPool}
+     * @param pool
+     *            the {@link KeyedObjectPool} from which I was obtained.
+     * @param conn
+     *            the {@link java.sql.Connection Connection} from which I was created
      */
     public PoolablePreparedStatement(final PreparedStatement stmt, final K key,
-            final KeyedObjectPool<K, PoolablePreparedStatement<K>> pool,
-            final DelegatingConnection<?> conn) {
+            final KeyedObjectPool<K, PoolablePreparedStatement<K>> pool, final DelegatingConnection<?> conn) {
         super(conn, stmt);
-        _pool = pool;
-        _key = key;
+        this.pool = pool;
+        this.key = key;
 
         // Remove from trace now because this statement will be
         // added by the activate method.
-        if(getConnectionInternal() != null) {
+        if (getConnectionInternal() != null) {
             getConnectionInternal().removeTrace(this);
         }
     }
@@ -99,21 +100,21 @@ public class PoolablePreparedStatement<K> extends DelegatingPreparedStatement {
         // calling close twice should have no effect
         if (!isClosed()) {
             try {
-                _pool.returnObject(_key, this);
-            } catch(final SQLException e) {
+                pool.returnObject(key, this);
+            } catch (final SQLException e) {
                 throw e;
-            } catch(final RuntimeException e) {
+            } catch (final RuntimeException e) {
                 throw e;
-            } catch(final Exception e) {
+            } catch (final Exception e) {
                 throw new SQLException("Cannot close preparedstatement (return to pool failed)", e);
             }
         }
     }
 
     @Override
-    public void activate() throws SQLException{
+    public void activate() throws SQLException {
         setClosedInternal(false);
-        if(getConnectionInternal() != null) {
+        if (getConnectionInternal() != null) {
             getConnectionInternal().addTrace(this);
         }
         super.activate();
@@ -127,7 +128,7 @@ public class PoolablePreparedStatement<K> extends DelegatingPreparedStatement {
             clearBatch();
         }
         setClosedInternal(true);
-        if(getConnectionInternal() != null) {
+        if (getConnectionInternal() != null) {
             getConnectionInternal().removeTrace(this);
         }
 
@@ -136,7 +137,7 @@ public class PoolablePreparedStatement<K> extends DelegatingPreparedStatement {
         // FIXME The PreparedStatement we're wrapping should handle this for us.
         // See bug 17301 for what could happen when ResultSets are closed twice.
         final List<AbandonedTrace> resultSets = getTrace();
-        if( resultSets != null) {
+        if (resultSets != null) {
             final ResultSet[] set = resultSets.toArray(new ResultSet[resultSets.size()]);
             for (final ResultSet element : set) {
                 element.close();

==================================================
PoolingDataSource.java
index 436d8d1e7b..04d67fb621 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java
@@ -31,58 +31,79 @@ import org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject;
 /**
  * A {@link DelegatingConnection} that pools {@link PreparedStatement}s.
  * <p>
- * The {@link #prepareStatement} and {@link #prepareCall} methods, rather than
- * creating a new PreparedStatement each time, may actually pull the statement
- * from a pool of unused statements.
- * The {@link PreparedStatement#close} method of the returned statement doesn't
- * actually close the statement, but rather returns it to the pool.
- * (See {@link PoolablePreparedStatement}, {@link PoolableCallableStatement}.)
- *
+ * The {@link #prepareStatement} and {@link #prepareCall} methods, rather than creating a new PreparedStatement each
+ * time, may actually pull the statement from a pool of unused statements. The {@link PreparedStatement#close} method of
+ * the returned statement doesn't actually close the statement, but rather returns it to the pool. (See
+ * {@link PoolablePreparedStatement}, {@link PoolableCallableStatement}.)
+ * </p>
  *
  * @see PoolablePreparedStatement
- * @author Rodney Waldhoff
- * @author Dirk Verbeeck
  * @since 2.0
  */
 public class PoolingConnection extends DelegatingConnection<Connection>
-        implements KeyedPooledObjectFactory<PStmtKey,DelegatingPreparedStatement> {
+        implements KeyedPooledObjectFactory<PStmtKey, DelegatingPreparedStatement> {
 
     /**
-     * Pool of {@link PreparedStatement}s. and {@link CallableStatement}s
+     * Statement types.
+     *
+     * @since 2.0 protected enum.
+     * @since 2.4.0 public enum.
      */
-    private KeyedObjectPool<PStmtKey,DelegatingPreparedStatement> _pstmtPool = null;
+    public enum StatementType {
+
+        /**
+         * Callable statement.
+         */
+        CALLABLE_STATEMENT,
+
+        /**
+         * Prepared statement.
+         */
+        PREPARED_STATEMENT
+    }
+
+    /** Pool of {@link PreparedStatement}s. and {@link CallableStatement}s */
+    private KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> pstmtPool;
 
     /**
      * Constructor.
-     * @param c the underlying {@link Connection}.
+     *
+     * @param connection
+     *            the underlying {@link Connection}.
      */
-    public PoolingConnection(final Connection c) {
-        super(c);
+    public PoolingConnection(final Connection connection) {
+        super(connection);
     }
 
-
-    public void setStatementPool(
-            final KeyedObjectPool<PStmtKey,DelegatingPreparedStatement> pool) {
-        _pstmtPool = pool;
+    /**
+     * {@link KeyedPooledObjectFactory} method for activating pooled statements.
+     *
+     * @param key
+     *            ignored
+     * @param pooledObject
+     *            wrapped pooled statement to be activated
+     */
+    @Override
+    public void activateObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject)
+            throws Exception {
+        pooledObject.getObject().activate();
     }
 
-
     /**
-     * Close and free all {@link PreparedStatement}s or
-     * {@link CallableStatement}s from the pool, and close the underlying
-     * connection.
+     * Closes and frees all {@link PreparedStatement}s or {@link CallableStatement}s from the pool, and close the
+     * underlying connection.
      */
     @Override
     public synchronized void close() throws SQLException {
         try {
-            if (null != _pstmtPool) {
-                final KeyedObjectPool<PStmtKey,DelegatingPreparedStatement> oldpool = _pstmtPool;
-                _pstmtPool = null;
+            if (null != pstmtPool) {
+                final KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> oldpool = pstmtPool;
+                pstmtPool = null;
                 try {
                     oldpool.close();
-                } catch(final RuntimeException e) {
+                } catch (final RuntimeException e) {
                     throw e;
-                } catch(final Exception e) {
+                } catch (final Exception e) {
                     throw new SQLException("Cannot close connection", e);
                 }
             }
@@ -96,348 +117,166 @@ public class PoolingConnection extends DelegatingConnection<Connection>
     }
 
     /**
-     * Create or obtain a {@link PreparedStatement} from the pool.
-     * @param sql the sql string used to define the PreparedStatement
-     * @return a {@link PoolablePreparedStatement}
-     */
-    @Override
-    public PreparedStatement prepareStatement(final String sql) throws SQLException {
-        if (null == _pstmtPool) {
-            throw new SQLException(
-                    "Statement pool is null - closed or invalid PoolingConnection.");
-        }
-        try {
-            return _pstmtPool.borrowObject(createKey(sql));
-        } catch(final NoSuchElementException e) {
-            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
-        } catch(final RuntimeException e) {
-            throw e;
-        } catch(final Exception e) {
-            throw new SQLException("Borrow prepareStatement from pool failed", e);
-        }
-    }
-
-    @Override
-    public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
-        if (null == _pstmtPool) {
-            throw new SQLException(
-                    "Statement pool is null - closed or invalid PoolingConnection.");
-        }
-        try {
-            return _pstmtPool.borrowObject(createKey(sql, autoGeneratedKeys));
-        }
-        catch (final NoSuchElementException e) {
-            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
-        }
-        catch (final RuntimeException e) {
-            throw e;
-        }
-        catch (final Exception e) {
-            throw new SQLException("Borrow prepareStatement from pool failed", e);
-        }
-    }
-
-    /**
-     * Create or obtain a {@link PreparedStatement} from the pool.
-     * @param sql the sql string used to define the PreparedStatement
-     * @param resultSetType result set type
-     * @param resultSetConcurrency result set concurrency
-     * @return a {@link PoolablePreparedStatement}
-     * @throws SQLException An error occurred
-     */
-    @Override
-    public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
-        if (null == _pstmtPool) {
-            throw new SQLException(
-                    "Statement pool is null - closed or invalid PoolingConnection.");
-        }
-        try {
-            return _pstmtPool.borrowObject(createKey(sql,resultSetType,resultSetConcurrency));
-        } catch(final NoSuchElementException e) {
-            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
-        } catch(final RuntimeException e) {
-            throw e;
-        } catch(final Exception e) {
-            throw new SQLException("Borrow prepareStatement from pool failed", e);
-        }
-    }
-
-    /**
-     * Create or obtain a {@link CallableStatement} from the pool.
-     * @param sql the sql string used to define the CallableStatement
-     * @return a {@link PoolableCallableStatement}
-     * @throws SQLException An error occurred
-     */
-    @Override
-    public CallableStatement prepareCall(final String sql) throws SQLException {
-        try {
-            return (CallableStatement) _pstmtPool.borrowObject(createKey(sql, StatementType.CALLABLE_STATEMENT));
-        } catch (final NoSuchElementException e) {
-            throw new SQLException("MaxOpenCallableStatements limit reached", e);
-        } catch (final RuntimeException e) {
-            throw e;
-        } catch (final Exception e) {
-            throw new SQLException("Borrow callableStatement from pool failed", e);
-        }
-    }
-
-    /**
-     * Create or obtain a {@link CallableStatement} from the pool.
-     * @param sql the sql string used to define the CallableStatement
-     * @param resultSetType result set type
-     * @param resultSetConcurrency result set concurrency
-     * @return a {@link PoolableCallableStatement}
-     * @throws SQLException An error occurred
-     */
-    @Override
-    public CallableStatement prepareCall(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
-        try {
-            return (CallableStatement) _pstmtPool.borrowObject(createKey(sql, resultSetType,
-                            resultSetConcurrency, StatementType.CALLABLE_STATEMENT));
-        } catch (final NoSuchElementException e) {
-            throw new SQLException("MaxOpenCallableStatements limit reached", e);
-        } catch (final RuntimeException e) {
-            throw e;
-        } catch (final Exception e) {
-            throw new SQLException("Borrow callableStatement from pool failed", e);
-        }
-    }
-
-    /**
-     * Create or obtain a {@link PreparedStatement} from the pool.
-     * @param sql the sql string used to define the PreparedStatement
-     * @param resultSetType result set type
-     * @param resultSetConcurrency result set concurrency
-     * @param resultSetHoldability result set holdability
-     * @return a {@link PoolablePreparedStatement}
-     */
-    @Override
-    public PreparedStatement prepareStatement(final String sql, final int resultSetType,
-            final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
-        if (null == _pstmtPool) {
-            throw new SQLException(
-                    "Statement pool is null - closed or invalid PoolingConnection.");
-        }
-        try {
-            return _pstmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
-        } catch(final NoSuchElementException e) {
-            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
-        } catch(final RuntimeException e) {
-            throw e;
-        } catch(final Exception e) {
-            throw new SQLException("Borrow prepareStatement from pool failed", e);
-        }
-    }
-
-    /**
-     * Create or obtain a {@link PreparedStatement} from the pool.
-     * @param sql the sql string used to define the PreparedStatement
-     * @param columnIndexes column indexes
-     * @return a {@link PoolablePreparedStatement}
-     */
-    @Override
-    public PreparedStatement prepareStatement(final String sql, final int columnIndexes[])
-            throws SQLException {
-        if (null == _pstmtPool) {
-            throw new SQLException(
-                    "Statement pool is null - closed or invalid PoolingConnection.");
-        }
-        try {
-            return _pstmtPool.borrowObject(createKey(sql, columnIndexes));
-        } catch(final NoSuchElementException e) {
-            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
-        } catch(final RuntimeException e) {
-            throw e;
-        } catch(final Exception e) {
-            throw new SQLException("Borrow prepareStatement from pool failed", e);
-        }
-    }
-
-    /**
-     * Create or obtain a {@link PreparedStatement} from the pool.
-     * @param sql the sql string used to define the PreparedStatement
-     * @param columnNames column names
-     * @return a {@link PoolablePreparedStatement}
-     */
-    @Override
-    public PreparedStatement prepareStatement(final String sql, final String columnNames[])
-            throws SQLException {
-        if (null == _pstmtPool) {
-            throw new SQLException(
-                    "Statement pool is null - closed or invalid PoolingConnection.");
-        }
-        try {
-            return _pstmtPool.borrowObject(createKey(sql, columnNames));
-        } catch(final NoSuchElementException e) {
-            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
-        } catch(final RuntimeException e) {
-            throw e;
-        } catch(final Exception e) {
-            throw new SQLException("Borrow prepareStatement from pool failed", e);
-        }
-    }
-
-    /**
-     * Create or obtain a {@link CallableStatement} from the pool.
-     * @param sql the sql string used to define the CallableStatement
-     * @param resultSetType result set type
-     * @param resultSetConcurrency result set concurrency
-     * @param resultSetHoldability result set holdability
-     * @return a {@link PoolableCallableStatement}
-     * @throws SQLException if a {@link CallableStatement} cannot be obtained
-     *                      from the pool
+     * Creates a PStmtKey for the given arguments.
+     *
+     * @param sql
+     *            the SQL string used to define the statement
      */
-    @Override
-    public CallableStatement prepareCall(final String sql, final int resultSetType,
-            final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
-        try {
-            return (CallableStatement) _pstmtPool.borrowObject(createKey(sql, resultSetType,
-                            resultSetConcurrency, resultSetHoldability, StatementType.CALLABLE_STATEMENT));
-        } catch (final NoSuchElementException e) {
-            throw new SQLException("MaxOpenCallableStatements limit reached", e);
-        } catch (final RuntimeException e) {
-            throw e;
-        } catch (final Exception e) {
-            throw new SQLException("Borrow callableStatement from pool failed", e);
-        }
-    }
-
-    protected PStmtKey createKey(final String sql, final int autoGeneratedKeys) {
+    protected PStmtKey createKey(final String sql) {
         String catalog = null;
         try {
             catalog = getCatalog();
         } catch (final SQLException e) {
             // Ignored
         }
-        return new PStmtKey(normalizeSQL(sql), catalog, autoGeneratedKeys);
+        return new PStmtKey(normalizeSQL(sql), catalog);
     }
 
-    /**
-     * Create a PStmtKey for the given arguments.
-     * @param sql the sql string used to define the statement
-     * @param resultSetType result set type
-     * @param resultSetConcurrency result set concurrency
-     * @return the key
-     */
-    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency) {
+    protected PStmtKey createKey(final String sql, final int autoGeneratedKeys) {
         String catalog = null;
         try {
             catalog = getCatalog();
         } catch (final SQLException e) {
             // Ignored
         }
-        return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency);
+        return new PStmtKey(normalizeSQL(sql), catalog, autoGeneratedKeys);
     }
 
     /**
-     * Create a PStmtKey for the given arguments.
-     * @param sql the sql string used to define the statement
-     * @param resultSetType result set type
-     * @param resultSetConcurrency result set concurrency
-     * @param stmtType statement type
-     * @return the key
+     * Creates a PStmtKey for the given arguments.
+     *
+     * @param sql
+     *            the SQL string used to define the statement
+     * @param columnIndexes
+     *            column indexes
      */
-    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency, final StatementType stmtType) {
+    protected PStmtKey createKey(final String sql, final int columnIndexes[]) {
         String catalog = null;
         try {
             catalog = getCatalog();
         } catch (final SQLException e) {
             // Ignored
         }
-        return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency, stmtType);
+        return new PStmtKey(normalizeSQL(sql), catalog, columnIndexes);
     }
 
     /**
-     * Create a PStmtKey for the given arguments.
-     * @param sql the sql string used to define the statement
-     * @return the key
+     * Creates a PStmtKey for the given arguments.
+     *
+     * @param sql
+     *            the SQL string used to define the statement
+     * @param resultSetType
+     *            result set type
+     * @param resultSetConcurrency
+     *            result set concurrency
      */
-    protected PStmtKey createKey(final String sql) {
+    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency) {
         String catalog = null;
         try {
             catalog = getCatalog();
         } catch (final SQLException e) {
             // Ignored
         }
-        return new PStmtKey(normalizeSQL(sql), catalog);
+        return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency);
     }
 
     /**
-     * Create a PStmtKey for the given arguments.
-     * @param sql the SQL string used to define the statement
-     * @param stmtType statement type
-     * @return the key
+     * Creates a PStmtKey for the given arguments.
+     *
+     * @param sql
+     *            the SQL string used to define the statement
+     * @param resultSetType
+     *            result set type
+     * @param resultSetConcurrency
+     *            result set concurrency
+     * @param resultSetHoldability
+     *            result set holdability
      */
-    protected PStmtKey createKey(final String sql, final StatementType stmtType) {
+    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency,
+            final int resultSetHoldability) {
         String catalog = null;
         try {
             catalog = getCatalog();
         } catch (final SQLException e) {
             // Ignored
         }
-        return new PStmtKey(normalizeSQL(sql), catalog, stmtType, null);
+        return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency, resultSetHoldability);
     }
 
     /**
-     * Create a PStmtKey for the given arguments.
-     * @param sql the sql string used to define the statement
-     * @param resultSetType result set type
-     * @param resultSetConcurrency result set concurrency
-     * @param resultSetHoldability result set holdability
-     * @return a newly created key for the given arguments
+     * Creates a PStmtKey for the given arguments.
+     *
+     * @param sql
+     *            the SQL string used to define the statement
+     * @param resultSetType
+     *            result set type
+     * @param resultSetConcurrency
+     *            result set concurrency
+     * @param resultSetHoldability
+     *            result set holdability
+     * @param stmtType
+     *            statement type
      */
     protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency,
-            final int resultSetHoldability) {
+            final int resultSetHoldability, final StatementType stmtType) {
         String catalog = null;
         try {
             catalog = getCatalog();
         } catch (final SQLException e) {
             // Ignored
         }
-        return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency, resultSetHoldability);
+        return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency, resultSetHoldability,
+                stmtType);
     }
 
     /**
-     * Create a PStmtKey for the given arguments.
-     * @param sql the sql string used to define the statement
-     * @param resultSetType result set type
-     * @param resultSetConcurrency result set concurrency
-     * @param resultSetHoldability result set holdability
-     * @param stmtType statement type
-     * @return a newly created key for the given arguments
+     * Creates a PStmtKey for the given arguments.
+     *
+     * @param sql
+     *            the SQL string used to define the statement
+     * @param resultSetType
+     *            result set type
+     * @param resultSetConcurrency
+     *            result set concurrency
+     * @param stmtType
+     *            statement type
      */
     protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency,
-            final int resultSetHoldability, final StatementType stmtType) {
+            final StatementType stmtType) {
         String catalog = null;
         try {
             catalog = getCatalog();
         } catch (final SQLException e) {
             // Ignored
         }
-        return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency, resultSetHoldability,  stmtType);
+        return new PStmtKey(normalizeSQL(sql), catalog, resultSetType, resultSetConcurrency, stmtType);
     }
 
     /**
-     * Create a PStmtKey for the given arguments.
-     * @param sql the sql string used to define the statement
-     * @param columnIndexes column indexes
-     * @return a newly created key for the given arguments
+     * Creates a PStmtKey for the given arguments.
+     *
+     * @param sql
+     *            the SQL string used to define the statement
+     * @param stmtType
+     *            statement type
      */
-    protected PStmtKey createKey(final String sql, final int columnIndexes[]) {
+    protected PStmtKey createKey(final String sql, final StatementType stmtType) {
         String catalog = null;
         try {
             catalog = getCatalog();
         } catch (final SQLException e) {
             // Ignored
         }
-        return new PStmtKey(normalizeSQL(sql), catalog, columnIndexes);
+        return new PStmtKey(normalizeSQL(sql), catalog, stmtType, null);
     }
 
     /**
-     * Create a PStmtKey for the given arguments.
-     * @param sql the sql string used to define the statement
-     * @param columnNames column names
-     * @return a newly created key for the given arguments
+     * Creates a PStmtKey for the given arguments.
+     *
+     * @param sql
+     *            the SQL string used to define the statement
+     * @param columnNames
+     *            column names
      */
     protected PStmtKey createKey(final String sql, final String columnNames[]) {
         String catalog = null;
@@ -450,119 +289,327 @@ public class PoolingConnection extends DelegatingConnection<Connection>
     }
 
     /**
-     * Normalize the given SQL statement, producing a
-     * canonical form that is semantically equivalent to the original.
-     * @param sql The SQL statement
-     * @return the trimmed SQL statement
+     * {@link KeyedPooledObjectFactory} method for destroying PoolablePreparedStatements and PoolableCallableStatements.
+     * Closes the underlying statement.
+     *
+     * @param key
+     *            ignored
+     * @param pooledObject
+     *            the wrapped pooled statement to be destroyed.
      */
-    protected String normalizeSQL(final String sql) {
-        return sql.trim();
+    @Override
+    public void destroyObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject)
+            throws Exception {
+        pooledObject.getObject().getInnermostDelegate().close();
     }
 
     /**
-     * {@link KeyedPooledObjectFactory} method for creating
-     * {@link PoolablePreparedStatement}s or {@link PoolableCallableStatement}s.
-     * The <code>stmtType</code> field in the key determines whether
-     * a PoolablePreparedStatement or PoolableCallableStatement is created.
+     * {@link KeyedPooledObjectFactory} method for creating {@link PoolablePreparedStatement}s or
+     * {@link PoolableCallableStatement}s. The <code>stmtType</code> field in the key determines whether a
+     * PoolablePreparedStatement or PoolableCallableStatement is created.
      *
-     * @param key the key for the {@link PreparedStatement} to be created
-     * @return the object
-     * @throws Exception An error occurred
+     * @param key
+     *            the key for the {@link PreparedStatement} to be created
      * @see #createKey(String, int, int, StatementType)
      */
+    @SuppressWarnings("resource")
     @Override
-    public PooledObject<DelegatingPreparedStatement> makeObject(final PStmtKey key)
-            throws Exception {
-        if(null == key) {
+    public PooledObject<DelegatingPreparedStatement> makeObject(final PStmtKey key) throws Exception {
+        if (null == key) {
             throw new IllegalArgumentException("Prepared statement key is null or invalid.");
         }
-        if (key.getStmtType() == StatementType.PREPARED_STATEMENT ) {
+        if (key.getStmtType() == StatementType.PREPARED_STATEMENT) {
             final PreparedStatement statement = (PreparedStatement) key.createStatement(getDelegate());
-            @SuppressWarnings({"rawtypes", "unchecked"}) // Unable to find way to avoid this
-            final
-            PoolablePreparedStatement pps = new PoolablePreparedStatement(statement, key, _pstmtPool, this);
-            return new DefaultPooledObject<>(pps);
+            @SuppressWarnings({"rawtypes", "unchecked" }) // Unable to find way to avoid this
+            final PoolablePreparedStatement pps = new PoolablePreparedStatement(statement, key, pstmtPool, this);
+            return new DefaultPooledObject<DelegatingPreparedStatement>(pps);
         }
         final CallableStatement statement = (CallableStatement) key.createStatement(getDelegate());
-        final PoolableCallableStatement pcs = new PoolableCallableStatement(statement, key, _pstmtPool, this);
-        return new DefaultPooledObject<>(pcs);
+        final PoolableCallableStatement pcs = new PoolableCallableStatement(statement, key, pstmtPool, this);
+        return new DefaultPooledObject<DelegatingPreparedStatement>(pcs);
     }
 
     /**
-     * {@link KeyedPooledObjectFactory} method for destroying
-     * PoolablePreparedStatements and PoolableCallableStatements.
-     * Closes the underlying statement.
+     * Normalizes the given SQL statement, producing a canonical form that is semantically equivalent to the original.
+     */
+    protected String normalizeSQL(final String sql) {
+        return sql.trim();
+    }
+
+    /**
+     * {@link KeyedPooledObjectFactory} method for passivating {@link PreparedStatement}s or {@link CallableStatement}s.
+     * Invokes {@link PreparedStatement#clearParameters}.
      *
-     * @param key ignored
-     * @param p the wrapped pooled statement to be destroyed.
-     * @throws Exception An error occurred
+     * @param key
+     *            ignored
+     * @param pooledObject
+     *            a wrapped {@link PreparedStatement}
      */
     @Override
-    public void destroyObject(final PStmtKey key,
-            final PooledObject<DelegatingPreparedStatement> p)
+    public void passivateObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject)
             throws Exception {
-        p.getObject().getInnermostDelegate().close();
+        @SuppressWarnings("resource")
+        final DelegatingPreparedStatement dps = pooledObject.getObject();
+        dps.clearParameters();
+        dps.passivate();
     }
 
     /**
-     * {@link KeyedPooledObjectFactory} method for validating
-     * pooled statements. Currently always returns true.
+     * Creates or obtains a {@link CallableStatement} from the pool.
      *
-     * @param key ignored
-     * @param p ignored
-     * @return {@code true}
+     * @param sql
+     *            the SQL string used to define the CallableStatement
+     * @return a {@link PoolableCallableStatement}
+     * @throws SQLException
+     *             Wraps an underlying exception.
      */
     @Override
-    public boolean validateObject(final PStmtKey key,
-            final PooledObject<DelegatingPreparedStatement> p) {
-        return true;
+    public CallableStatement prepareCall(final String sql) throws SQLException {
+        try {
+            return (CallableStatement) pstmtPool.borrowObject(createKey(sql, StatementType.CALLABLE_STATEMENT));
+        } catch (final NoSuchElementException e) {
+            throw new SQLException("MaxOpenCallableStatements limit reached", e);
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Exception e) {
+            throw new SQLException("Borrow callableStatement from pool failed", e);
+        }
+    }
+
+    /**
+     * Creates or obtains a {@link CallableStatement} from the pool.
+     *
+     * @param sql
+     *            the SQL string used to define the CallableStatement
+     * @param resultSetType
+     *            result set type
+     * @param resultSetConcurrency
+     *            result set concurrency
+     * @return a {@link PoolableCallableStatement}
+     * @throws SQLException
+     *             Wraps an underlying exception.
+     */
+    @Override
+    public CallableStatement prepareCall(final String sql, final int resultSetType, final int resultSetConcurrency)
+            throws SQLException {
+        try {
+            return (CallableStatement) pstmtPool.borrowObject(
+                    createKey(sql, resultSetType, resultSetConcurrency, StatementType.CALLABLE_STATEMENT));
+        } catch (final NoSuchElementException e) {
+            throw new SQLException("MaxOpenCallableStatements limit reached", e);
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Exception e) {
+            throw new SQLException("Borrow callableStatement from pool failed", e);
+        }
     }
 
     /**
-     * {@link KeyedPooledObjectFactory} method for activating
-     * pooled statements.
+     * Creates or obtains a {@link CallableStatement} from the pool.
      *
-     * @param key ignored
-     * @param p wrapped pooled statement to be activated
-     * @throws Exception An error occurred
+     * @param sql
+     *            the SQL string used to define the CallableStatement
+     * @param resultSetType
+     *            result set type
+     * @param resultSetConcurrency
+     *            result set concurrency
+     * @param resultSetHoldability
+     *            result set holdability
+     * @return a {@link PoolableCallableStatement}
+     * @throws SQLException
+     *             Wraps an underlying exception.
      */
     @Override
-    public void activateObject(final PStmtKey key,
-            final PooledObject<DelegatingPreparedStatement> p) throws Exception {
-        p.getObject().activate();
+    public CallableStatement prepareCall(final String sql, final int resultSetType, final int resultSetConcurrency,
+            final int resultSetHoldability) throws SQLException {
+        try {
+            return (CallableStatement) pstmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency,
+                    resultSetHoldability, StatementType.CALLABLE_STATEMENT));
+        } catch (final NoSuchElementException e) {
+            throw new SQLException("MaxOpenCallableStatements limit reached", e);
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Exception e) {
+            throw new SQLException("Borrow callableStatement from pool failed", e);
+        }
     }
 
     /**
-     * {@link KeyedPooledObjectFactory} method for passivating
-     * {@link PreparedStatement}s or {@link CallableStatement}s.
-     * Invokes {@link PreparedStatement#clearParameters}.
+     * Creates or obtains a {@link PreparedStatement} from the pool.
      *
-     * @param key ignored
-     * @param p a wrapped {@link PreparedStatement}
-     * @throws Exception An error occurred
+     * @param sql
+     *            the SQL string used to define the PreparedStatement
+     * @return a {@link PoolablePreparedStatement}
      */
     @Override
-    public void passivateObject(final PStmtKey key,
-            final PooledObject<DelegatingPreparedStatement> p) throws Exception {
-        final DelegatingPreparedStatement dps = p.getObject();
-        dps.clearParameters();
-        dps.passivate();
+    public PreparedStatement prepareStatement(final String sql) throws SQLException {
+        if (null == pstmtPool) {
+            throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
+        }
+        try {
+            return pstmtPool.borrowObject(createKey(sql));
+        } catch (final NoSuchElementException e) {
+            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
+        }
+    }
+
+    @Override
+    public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
+        if (null == pstmtPool) {
+            throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
+        }
+        try {
+            return pstmtPool.borrowObject(createKey(sql, autoGeneratedKeys));
+        } catch (final NoSuchElementException e) {
+            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
+        }
+    }
+
+    /**
+     * Creates or obtains a {@link PreparedStatement} from the pool.
+     *
+     * @param sql
+     *            the SQL string used to define the PreparedStatement
+     * @param columnIndexes
+     *            column indexes
+     * @return a {@link PoolablePreparedStatement}
+     */
+    @Override
+    public PreparedStatement prepareStatement(final String sql, final int columnIndexes[]) throws SQLException {
+        if (null == pstmtPool) {
+            throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
+        }
+        try {
+            return pstmtPool.borrowObject(createKey(sql, columnIndexes));
+        } catch (final NoSuchElementException e) {
+            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
+        }
+    }
+
+    /**
+     * Creates or obtains a {@link PreparedStatement} from the pool.
+     *
+     * @param sql
+     *            the SQL string used to define the PreparedStatement
+     * @param resultSetType
+     *            result set type
+     * @param resultSetConcurrency
+     *            result set concurrency
+     * @return a {@link PoolablePreparedStatement}
+     */
+    @Override
+    public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency)
+            throws SQLException {
+        if (null == pstmtPool) {
+            throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
+        }
+        try {
+            return pstmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency));
+        } catch (final NoSuchElementException e) {
+            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
+        }
+    }
+
+    /**
+     * Creates or obtains a {@link PreparedStatement} from the pool.
+     *
+     * @param sql
+     *            the SQL string used to define the PreparedStatement
+     * @param resultSetType
+     *            result set type
+     * @param resultSetConcurrency
+     *            result set concurrency
+     * @param resultSetHoldability
+     *            result set holdability
+     * @return a {@link PoolablePreparedStatement}
+     */
+    @Override
+    public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency,
+            final int resultSetHoldability) throws SQLException {
+        if (null == pstmtPool) {
+            throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
+        }
+        try {
+            return pstmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
+        } catch (final NoSuchElementException e) {
+            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
+        }
+    }
+
+    /**
+     * Creates or obtains a {@link PreparedStatement} from the pool.
+     *
+     * @param sql
+     *            the SQL string used to define the PreparedStatement
+     * @param columnNames
+     *            column names
+     * @return a {@link PoolablePreparedStatement}
+     */
+    @Override
+    public PreparedStatement prepareStatement(final String sql, final String columnNames[]) throws SQLException {
+        if (null == pstmtPool) {
+            throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
+        }
+        try {
+            return pstmtPool.borrowObject(createKey(sql, columnNames));
+        } catch (final NoSuchElementException e) {
+            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
+        }
+    }
+
+    /**
+     * Sets the prepared statement pool.
+     *
+     * @param pool
+     *            the prepared statement pool.
+     */
+    public void setStatementPool(final KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> pool) {
+        pstmtPool = pool;
     }
 
     @Override
     public String toString() {
-        if (_pstmtPool != null ) {
-            return "PoolingConnection: " + _pstmtPool.toString();
+        if (pstmtPool != null) {
+            return "PoolingConnection: " + pstmtPool.toString();
         }
         return "PoolingConnection: null";
     }
 
     /**
-     * The possible statement types.
-     * @since 2.0
+     * {@link KeyedPooledObjectFactory} method for validating pooled statements. Currently always returns true.
+     *
+     * @param key
+     *            ignored
+     * @param pooledObject
+     *            ignored
+     * @return {@code true}
      */
-    protected static enum StatementType {
-        CALLABLE_STATEMENT,
-        PREPARED_STATEMENT
+    @Override
+    public boolean validateObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject) {
+        return true;
     }
 }

==================================================
PoolingDriver.java
index 9eee2f072b..70601b0fdd 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/PoolingDataSource.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolingDataSource.java
@@ -21,6 +21,7 @@ import java.sql.Connection;
 import java.sql.SQLException;
 import java.sql.SQLFeatureNotSupportedException;
 import java.util.NoSuchElementException;
+import java.util.Objects;
 import java.util.logging.Logger;
 
 import javax.sql.DataSource;
@@ -31,15 +32,11 @@ import org.apache.tomcat.dbcp.pool2.ObjectPool;
 import org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool;
 
 /**
- * A simple {@link DataSource} implementation that obtains
- * {@link Connection}s from the specified {@link ObjectPool}.
+ * A simple {@link DataSource} implementation that obtains {@link Connection}s from the specified {@link ObjectPool}.
  *
- * @param <C> The connection type
+ * @param <C>
+ *            The connection type
  *
- * @author Rodney Waldhoff
- * @author Glenn L. Nielsen
- * @author James House
- * @author Dirk Verbeeck
  * @since 2.0
  */
 public class PoolingDataSource<C extends Connection> implements DataSource, AutoCloseable {
@@ -47,40 +44,43 @@ public class PoolingDataSource<C extends Connection> implements DataSource, Auto
     private static final Log log = LogFactory.getLog(PoolingDataSource.class);
 
     /** Controls access to the underlying connection */
-    private boolean accessToUnderlyingConnectionAllowed = false;
+    private boolean accessToUnderlyingConnectionAllowed;
 
+    /**
+     * Constructs a new instance backed by the given connection pool.
+     *
+     * @param pool
+     *            the given connection pool.
+     */
     public PoolingDataSource(final ObjectPool<C> pool) {
-        if (null == pool) {
-            throw new NullPointerException("Pool must not be null.");
-        }
-        _pool = pool;
-        // Verify that _pool's factory refers back to it.  If not, log a warning and try to fix.
-        if (_pool instanceof GenericObjectPool<?>) {
-            final PoolableConnectionFactory pcf = (PoolableConnectionFactory) ((GenericObjectPool<?>) _pool).getFactory();
-            if (pcf == null) {
-                throw new NullPointerException("PoolableConnectionFactory must not be null.");
-            }
-            if (pcf.getPool() != _pool) {
+        Objects.requireNonNull(pool, "Pool must not be null.");
+        this.pool = pool;
+        // Verify that pool's factory refers back to it. If not, log a warning and try to fix.
+        if (this.pool instanceof GenericObjectPool<?>) {
+            final PoolableConnectionFactory pcf = (PoolableConnectionFactory) ((GenericObjectPool<?>) this.pool)
+                    .getFactory();
+            Objects.requireNonNull(pcf, "PoolableConnectionFactory must not be null.");
+            if (pcf.getPool() != this.pool) {
                 log.warn(Utils.getMessage("poolingDataSource.factoryConfig"));
                 @SuppressWarnings("unchecked") // PCF must have a pool of PCs
-                final
-                ObjectPool<PoolableConnection> p = (ObjectPool<PoolableConnection>) _pool;
+                final ObjectPool<PoolableConnection> p = (ObjectPool<PoolableConnection>) this.pool;
                 pcf.setPool(p);
             }
         }
     }
 
     /**
-     * Close and free all {@link Connection}s from the pool.
+     * Closes and free all {@link Connection}s from the pool.
+     *
      * @since 2.1
      */
     @Override
     public void close() throws Exception {
         try {
-            _pool.close();
-        } catch(final RuntimeException rte) {
+            pool.close();
+        } catch (final RuntimeException rte) {
             throw new RuntimeException(Utils.getMessage("pool.close.fail"), rte);
-        } catch(final Exception e) {
+        } catch (final Exception e) {
             throw new SQLException(Utils.getMessage("pool.close.fail"), e);
         }
     }
@@ -95,11 +95,11 @@ public class PoolingDataSource<C extends Connection> implements DataSource, Auto
     }
 
     /**
-     * Sets the value of the accessToUnderlyingConnectionAllowed property.
-     * It controls if the PoolGuard allows access to the underlying connection.
-     * (Default: false)
+     * Sets the value of the accessToUnderlyingConnectionAllowed property. It controls if the PoolGuard allows access to
+     * the underlying connection. (Default: false)
      *
-     * @param allow Access to the underlying connection is granted when true.
+     * @param allow
+     *            Access to the underlying connection is granted when true.
      */
     public void setAccessToUnderlyingConnectionAllowed(final boolean allow) {
         this.accessToUnderlyingConnectionAllowed = allow;
@@ -122,38 +122,40 @@ public class PoolingDataSource<C extends Connection> implements DataSource, Auto
         throw new SQLFeatureNotSupportedException();
     }
 
-    //--- DataSource methods -----------------------------------------
+    // --- DataSource methods -----------------------------------------
 
     /**
-     * Return a {@link java.sql.Connection} from my pool,
-     * according to the contract specified by {@link ObjectPool#borrowObject}.
+     * Returns a {@link java.sql.Connection} from my pool, according to the contract specified by
+     * {@link ObjectPool#borrowObject}.
      */
     @Override
     public Connection getConnection() throws SQLException {
         try {
-            final C conn = _pool.borrowObject();
+            final C conn = pool.borrowObject();
             if (conn == null) {
                 return null;
             }
             return new PoolGuardConnectionWrapper<>(conn);
-        } catch(final SQLException e) {
+        } catch (final SQLException e) {
             throw e;
-        } catch(final NoSuchElementException e) {
+        } catch (final NoSuchElementException e) {
             throw new SQLException("Cannot get a connection, pool error " + e.getMessage(), e);
-        } catch(final RuntimeException e) {
+        } catch (final RuntimeException e) {
             throw e;
-        } catch(final InterruptedException e) {
+        } catch (final InterruptedException e) {
             // Reset the interrupt status so it is visible to callers
             Thread.currentThread().interrupt();
             throw new SQLException("Cannot get a connection, general error", e);
-        } catch(final Exception e) {
+        } catch (final Exception e) {
             throw new SQLException("Cannot get a connection, general error", e);
         }
     }
 
     /**
      * Throws {@link UnsupportedOperationException}
-     * @throws UnsupportedOperationException This is unsupported
+     *
+     * @throws UnsupportedOperationException
+     *             always thrown
      */
     @Override
     public Connection getConnection(final String uname, final String passwd) throws SQLException {
@@ -162,18 +164,20 @@ public class PoolingDataSource<C extends Connection> implements DataSource, Auto
 
     /**
      * Returns my log writer.
+     *
      * @return my log writer
      * @see DataSource#getLogWriter
      */
     @Override
     public PrintWriter getLogWriter() {
-        return _logWriter;
+        return logWriter;
     }
 
     /**
      * Throws {@link UnsupportedOperationException}.
-     * @throws UnsupportedOperationException As this
-     *   implementation does not support this feature.
+     *
+     * @throws UnsupportedOperationException
+     *             As this implementation does not support this feature.
      */
     @Override
     public int getLoginTimeout() {
@@ -182,8 +186,9 @@ public class PoolingDataSource<C extends Connection> implements DataSource, Auto
 
     /**
      * Throws {@link UnsupportedOperationException}.
-     * @throws UnsupportedOperationException As this
-     *   implementation does not support this feature.
+     *
+     * @throws UnsupportedOperationException
+     *             As this implementation does not support this feature.
      */
     @Override
     public void setLoginTimeout(final int seconds) {
@@ -192,29 +197,29 @@ public class PoolingDataSource<C extends Connection> implements DataSource, Auto
 
     /**
      * Sets my log writer.
+     *
      * @see DataSource#setLogWriter
      */
     @Override
     public void setLogWriter(final PrintWriter out) {
-        _logWriter = out;
+        logWriter = out;
     }
 
     /** My log writer. */
-    private PrintWriter _logWriter = null;
+    private PrintWriter logWriter = null;
 
-    private final ObjectPool<C> _pool;
+    private final ObjectPool<C> pool;
 
     protected ObjectPool<C> getPool() {
-        return _pool;
+        return pool;
     }
 
     /**
-     * PoolGuardConnectionWrapper is a Connection wrapper that makes sure a
-     * closed connection cannot be used anymore.
+     * PoolGuardConnectionWrapper is a Connection wrapper that makes sure a closed connection cannot be used anymore.
+     *
      * @since 2.0
      */
-    private class PoolGuardConnectionWrapper<D extends Connection>
-            extends DelegatingConnection<D> {
+    private class PoolGuardConnectionWrapper<D extends Connection> extends DelegatingConnection<D> {
 
         PoolGuardConnectionWrapper(final D delegate) {
             super(delegate);
@@ -225,10 +230,7 @@ public class PoolingDataSource<C extends Connection> implements DataSource, Auto
          */
         @Override
         public D getDelegate() {
-            if (isAccessToUnderlyingConnectionAllowed()) {
-                return super.getDelegate();
-            }
-            return null;
+            return isAccessToUnderlyingConnectionAllowed() ? super.getDelegate() : null;
         }
 
         /**
@@ -236,10 +238,7 @@ public class PoolingDataSource<C extends Connection> implements DataSource, Auto
          */
         @Override
         public Connection getInnermostDelegate() {
-            if (isAccessToUnderlyingConnectionAllowed()) {
-                return super.getInnermostDelegate();
-            }
-            return null;
+            return isAccessToUnderlyingConnectionAllowed() ? super.getInnermostDelegate() : null;
         }
 
         @Override
@@ -252,10 +251,7 @@ public class PoolingDataSource<C extends Connection> implements DataSource, Auto
 
         @Override
         public boolean isClosed() throws SQLException {
-            if (getDelegateInternal() == null) {
-                return true;
-            }
-            return super.isClosed();
+            return getDelegateInternal() == null ? true : super.isClosed();
         }
     }
 }

==================================================
SwallowedExceptionLogger.java
index 5352ae1226..4c5b495628 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/PoolingDriver.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/PoolingDriver.java
@@ -30,107 +30,120 @@ import java.util.logging.Logger;
 
 import org.apache.tomcat.dbcp.pool2.ObjectPool;
 
-
 /**
- * A {@link Driver} implementation that obtains
- * {@link Connection}s from a registered
- * {@link ObjectPool}.
+ * A {@link Driver} implementation that obtains {@link Connection}s from a registered {@link ObjectPool}.
  *
- * @author Rodney Waldhoff
- * @author Dirk Verbeeck
  * @since 2.0
  */
 public class PoolingDriver implements Driver {
-    /**
-     * Register myself with the {@link DriverManager}.
-     */
+
+    /** Register myself with the {@link DriverManager}. */
     static {
         try {
             DriverManager.registerDriver(new PoolingDriver());
-        } catch(final Exception e) {
+        } catch (final Exception e) {
+            // ignore
         }
     }
 
-    /**
-     * The map of registered pools.
-     */
-    protected static final HashMap<String,ObjectPool<? extends Connection>> pools =
-            new HashMap<>();
+    /** The map of registered pools. */
+    protected static final HashMap<String, ObjectPool<? extends Connection>> pools = new HashMap<>();
 
-    /**
-     * Controls access to the underlying connection
-     */
+    /** Controls access to the underlying connection */
     private final boolean accessToUnderlyingConnectionAllowed;
 
+    /**
+     * Constructs a new driver with <code>accessToUnderlyingConnectionAllowed</code> enabled.
+     */
     public PoolingDriver() {
         this(true);
     }
 
     /**
      * For unit testing purposes.
-     * @param accessToUnderlyingConnectionAllowed The new flag
      */
     protected PoolingDriver(final boolean accessToUnderlyingConnectionAllowed) {
         this.accessToUnderlyingConnectionAllowed = accessToUnderlyingConnectionAllowed;
     }
 
-
     /**
      * Returns the value of the accessToUnderlyingConnectionAllowed property.
      *
-     * @return <code>true</code> if access to the underlying is allowed,
-     *  <code>false</code> otherwise.
+     * @return true if access to the underlying is allowed, false otherwise.
      */
     protected boolean isAccessToUnderlyingConnectionAllowed() {
         return accessToUnderlyingConnectionAllowed;
     }
 
-    public synchronized ObjectPool<? extends Connection> getConnectionPool(final String name)
-            throws SQLException {
+    /**
+     * Gets the connection pool for the given name.
+     *
+     * @param name
+     *            The pool name
+     * @return The pool
+     * @throws SQLException
+     *             Thrown when the named pool is not registered.
+     */
+    public synchronized ObjectPool<? extends Connection> getConnectionPool(final String name) throws SQLException {
         final ObjectPool<? extends Connection> pool = pools.get(name);
         if (null == pool) {
-            throw new SQLException("Pool not registered.");
+            throw new SQLException("Pool not registered: " + name);
         }
         return pool;
     }
 
-    public synchronized void registerPool(final String name,
-            final ObjectPool<? extends Connection> pool) {
-        pools.put(name,pool);
+    /**
+     * Registers a named pool.
+     *
+     * @param name
+     *            The pool name.
+     * @param pool
+     *            The pool.
+     */
+    public synchronized void registerPool(final String name, final ObjectPool<? extends Connection> pool) {
+        pools.put(name, pool);
     }
 
+    /**
+     * Closes a named pool.
+     *
+     * @param name
+     *            The pool name.
+     * @throws SQLException
+     *             Thrown when a problem is caught closing the pool.
+     */
     public synchronized void closePool(final String name) throws SQLException {
+        @SuppressWarnings("resource")
         final ObjectPool<? extends Connection> pool = pools.get(name);
         if (pool != null) {
             pools.remove(name);
             try {
                 pool.close();
-            }
-            catch (final Exception e) {
+            } catch (final Exception e) {
                 throw new SQLException("Error closing pool " + name, e);
             }
         }
     }
 
-    public synchronized String[] getPoolNames(){
+    /**
+     * Gets the pool names.
+     *
+     * @return the pool names.
+     */
+    public synchronized String[] getPoolNames() {
         final Set<String> names = pools.keySet();
         return names.toArray(new String[names.size()]);
     }
 
     @Override
     public boolean acceptsURL(final String url) throws SQLException {
-        try {
-            return url.startsWith(URL_PREFIX);
-        } catch(final NullPointerException e) {
-            return false;
-        }
+        return url == null ? false : url.startsWith(URL_PREFIX);
     }
 
     @Override
     public Connection connect(final String url, final Properties info) throws SQLException {
-        if(acceptsURL(url)) {
-            final ObjectPool<? extends Connection> pool =
-                getConnectionPool(url.substring(URL_PREFIX_LEN));
+        if (acceptsURL(url)) {
+            final ObjectPool<? extends Connection> pool = getConnectionPool(url.substring(URL_PREFIX_LEN));
 
             try {
                 final Connection conn = pool.borrowObject();
@@ -138,13 +151,13 @@ public class PoolingDriver implements Driver {
                     return null;
                 }
                 return new PoolGuardConnectionWrapper(pool, conn);
-            } catch(final SQLException e) {
+            } catch (final SQLException e) {
                 throw e;
-            } catch(final NoSuchElementException e) {
+            } catch (final NoSuchElementException e) {
                 throw new SQLException("Cannot get a connection, pool error: " + e.getMessage(), e);
-            } catch(final RuntimeException e) {
+            } catch (final RuntimeException e) {
                 throw e;
-            } catch(final Exception e) {
+            } catch (final Exception e) {
                 throw new SQLException("Cannot get a connection, general error: " + e.getMessage(), e);
             }
         }
@@ -159,24 +172,23 @@ public class PoolingDriver implements Driver {
     /**
      * Invalidates the given connection.
      *
-     * @param conn connection to invalidate
-     * @throws SQLException if the connection is not a
-     * <code>PoolGuardConnectionWrapper</code> or an error occurs invalidating
-     * the connection
+     * @param conn
+     *            connection to invalidate
+     * @throws SQLException
+     *             if the connection is not a <code>PoolGuardConnectionWrapper</code> or an error occurs invalidating
+     *             the connection
      */
     public void invalidateConnection(final Connection conn) throws SQLException {
         if (conn instanceof PoolGuardConnectionWrapper) { // normal case
             final PoolGuardConnectionWrapper pgconn = (PoolGuardConnectionWrapper) conn;
             @SuppressWarnings("unchecked")
-            final
-            ObjectPool<Connection> pool = (ObjectPool<Connection>) pgconn.pool;
+            final ObjectPool<Connection> pool = (ObjectPool<Connection>) pgconn.pool;
             try {
                 pool.invalidateObject(pgconn.getDelegateInternal());
+            } catch (final Exception e) {
+                // Ignore.
             }
-            catch (final Exception e) {
-            }
-        }
-        else {
+        } else {
             throw new SQLException("Invalid connection class");
         }
     }
@@ -202,7 +214,7 @@ public class PoolingDriver implements Driver {
     }
 
     /** My URL prefix */
-    protected static final String URL_PREFIX = "jdbc:apache:commons:dbcp:";
+    public static final String URL_PREFIX = "jdbc:apache:commons:dbcp:";
     protected static final int URL_PREFIX_LEN = URL_PREFIX.length();
 
     // version numbers
@@ -210,16 +222,15 @@ public class PoolingDriver implements Driver {
     protected static final int MINOR_VERSION = 0;
 
     /**
-     * PoolGuardConnectionWrapper is a Connection wrapper that makes sure a
-     * closed connection cannot be used anymore.
+     * PoolGuardConnectionWrapper is a Connection wrapper that makes sure a closed connection cannot be used anymore.
+     *
      * @since 2.0
      */
     private class PoolGuardConnectionWrapper extends DelegatingConnection<Connection> {
 
         private final ObjectPool<? extends Connection> pool;
 
-        PoolGuardConnectionWrapper(final ObjectPool<? extends Connection> pool,
-                final Connection delegate) {
+        PoolGuardConnectionWrapper(final ObjectPool<? extends Connection> pool, final Connection delegate) {
             super(delegate);
             this.pool = pool;
         }

==================================================
Utils.java
index 99f3ba72ba..99f0e1659a 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/SwallowedExceptionLogger.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/SwallowedExceptionLogger.java
@@ -21,29 +21,31 @@ import org.apache.tomcat.dbcp.pool2.SwallowedExceptionListener;
 
 /**
  * Class for logging swallowed exceptions.
+ *
  * @since 2.0
  */
-public class SwallowedExceptionLogger implements SwallowedExceptionListener{
+public class SwallowedExceptionLogger implements SwallowedExceptionListener {
 
     private final Log log;
     private final boolean logExpiredConnections;
 
     /**
-     * Create a SwallowedExceptionLogger with the given logger.  By default,
-     * expired connection logging is turned on.
+     * Create a SwallowedExceptionLogger with the given logger. By default, expired connection logging is turned on.
      *
-     * @param log logger
+     * @param log
+     *            logger
      */
     public SwallowedExceptionLogger(final Log log) {
         this(log, true);
     }
 
     /**
-     * Create a SwallowedExceptionLogger with the given logger and expired
-     * connection logging property.
+     * Create a SwallowedExceptionLogger with the given logger and expired connection logging property.
      *
-     * @param log logger
-     * @param logExpiredConnections false suppresses logging of expired connection events
+     * @param log
+     *            logger
+     * @param logExpiredConnections
+     *            false suppresses logging of expired connection events
      */
     public SwallowedExceptionLogger(final Log log, final boolean logExpiredConnections) {
         this.log = log;
@@ -53,8 +55,7 @@ public class SwallowedExceptionLogger implements SwallowedExceptionListener{
     @Override
     public void onSwallowException(final Exception e) {
         if (logExpiredConnections || !(e instanceof LifetimeExceededException)) {
-            log.warn(Utils.getMessage(
-                    "swallowedExceptionLogger.onSwallowedException"), e);
+            log.warn(Utils.getMessage("swallowedExceptionLogger.onSwallowedException"), e);
         }
     }
 }

==================================================
ConnectionImpl.java
index 90d7a0a4b3..0886b18e17 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/Utils.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/Utils.java
@@ -28,15 +28,18 @@ import java.util.Set;
 
 /**
  * Utility methods.
+ *
  * @since 2.0
  */
 public final class Utils {
 
-    private static final ResourceBundle messages = ResourceBundle.getBundle(
-            Utils.class.getPackage().getName() + ".LocalStrings");
+    private static final ResourceBundle messages = ResourceBundle
+            .getBundle(Utils.class.getPackage().getName() + ".LocalStrings");
 
-    public static final boolean IS_SECURITY_ENABLED =
-            System.getSecurityManager() != null;
+    /**
+     * Whether the security manager is enabled.
+     */
+    public static final boolean IS_SECURITY_ENABLED = System.getSecurityManager() != null;
 
     /** Any SQL_STATE starting with this value is considered a fatal disconnect */
     public static final String DISCONNECTION_SQL_CODE_PREFIX = "08";
@@ -44,12 +47,12 @@ public final class Utils {
     /**
      * SQL codes of fatal connection errors.
      * <ul>
-     *  <li>57P01 (ADMIN SHUTDOWN)</li>
-     *  <li>57P02 (CRASH SHUTDOWN)</li>
-     *  <li>57P03 (CANNOT CONNECT NOW)</li>
-     *  <li>01002 (SQL92 disconnect error)</li>
-     *  <li>JZ0C0 (Sybase disconnect error)</li>
-     *  <li>JZ0C1 (Sybase disconnect error)</li>
+     * <li>57P01 (ADMIN SHUTDOWN)</li>
+     * <li>57P02 (CRASH SHUTDOWN)</li>
+     * <li>57P03 (CANNOT CONNECT NOW)</li>
+     * <li>01002 (SQL92 disconnect error)</li>
+     * <li>JZ0C0 (Sybase disconnect error)</li>
+     * <li>JZ0C1 (Sybase disconnect error)</li>
      * </ul>
      */
     public static final Set<String> DISCONNECTION_SQL_CODES;
@@ -71,12 +74,13 @@ public final class Utils {
     /**
      * Closes the ResultSet (which may be null).
      *
-     * @param rset a ResultSet, may be {@code null}
+     * @param resultSet
+     *            a ResultSet, may be {@code null}
      */
-    public static void closeQuietly(final ResultSet rset) {
-        if (rset != null) {
+    public static void closeQuietly(final ResultSet resultSet) {
+        if (resultSet != null) {
             try {
-                rset.close();
+                resultSet.close();
             } catch (final Exception e) {
                 // ignored
             }
@@ -86,12 +90,13 @@ public final class Utils {
     /**
      * Closes the Connection (which may be null).
      *
-     * @param conn a Connection, may be {@code null}
+     * @param connection
+     *            a Connection, may be {@code null}
      */
-    public static void closeQuietly(final Connection conn) {
-        if (conn != null) {
+    public static void closeQuietly(final Connection connection) {
+        if (connection != null) {
             try {
-                conn.close();
+                connection.close();
             } catch (final Exception e) {
                 // ignored
             }
@@ -101,42 +106,67 @@ public final class Utils {
     /**
      * Closes the Statement (which may be null).
      *
-     * @param stmt a Statement, may be {@code null}
+     * @param statement
+     *            a Statement, may be {@code null}.
      */
-    public static void closeQuietly(final Statement stmt) {
-        if (stmt != null) {
+    public static void closeQuietly(final Statement statement) {
+        if (statement != null) {
             try {
-                stmt.close();
+                statement.close();
             } catch (final Exception e) {
                 // ignored
             }
         }
     }
 
-
     /**
-     * Obtain the correct i18n message for the given key.
-     * @param key The message key
-     * @return the message
+     * Gets the correct i18n message for the given key.
+     *
+     * @param key
+     *            The key to look up an i18n message.
+     * @return The i18n message.
      */
     public static String getMessage(final String key) {
         return getMessage(key, (Object[]) null);
     }
 
-
     /**
-     * Obtain the correct i18n message for the given key with placeholders
-     * replaced by the supplied arguments.
-     * @param key The message key
-     * @param args The arguments
-     * @return the message
+     * Gets the correct i18n message for the given key with placeholders replaced by the supplied arguments.
+     *
+     * @param key
+     *            A message key.
+     * @param args
+     *            The message arguments.
+     * @return An i18n message.
      */
     public static String getMessage(final String key, final Object... args) {
-        final String msg =  messages.getString(key);
+        final String msg = messages.getString(key);
         if (args == null || args.length == 0) {
             return msg;
         }
         final MessageFormat mf = new MessageFormat(msg);
         return mf.format(args, new StringBuffer(), null).toString();
     }
+
+    /**
+     * Converts the given String to a char[].
+     *
+     * @param value
+     *            may be null.
+     * @return a char[] or null.
+     */
+    public static char[] toCharArray(final String value) {
+        return value != null ? value.toCharArray() : null;
+    }
+
+    /**
+     * Converts the given char[] to a String.
+     *
+     * @param value
+     *            may be null.
+     * @return a String or null.
+     */
+    public static String toString(final char[] value) {
+        return value == null ? null : String.valueOf(value);
+    }
 }

==================================================
DriverAdapterCPDS.java
index 5e1af7e444..ca6498a299 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/ConnectionImpl.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/ConnectionImpl.java
@@ -17,26 +17,25 @@
 
 package org.apache.tomcat.dbcp.dbcp2.cpdsadapter;
 
+import java.sql.CallableStatement;
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 
+import org.apache.tomcat.dbcp.dbcp2.DelegatingCallableStatement;
 import org.apache.tomcat.dbcp.dbcp2.DelegatingConnection;
 import org.apache.tomcat.dbcp.dbcp2.DelegatingPreparedStatement;
 
 /**
- * This class is the <code>Connection</code> that will be returned
- * from <code>PooledConnectionImpl.getConnection()</code>.
- * Most methods are wrappers around the JDBC 1.x <code>Connection</code>.
- * A few exceptions include preparedStatement and close.
- * In accordance with the JDBC specification this Connection cannot
- * be used after closed() is called.  Any further usage will result in an
+ * This class is the <code>Connection</code> that will be returned from
+ * <code>PooledConnectionImpl.getConnection()</code>. Most methods are wrappers around the JDBC 1.x
+ * <code>Connection</code>. A few exceptions include preparedStatement and close. In accordance with the JDBC
+ * specification this Connection cannot be used after closed() is called. Any further usage will result in an
  * SQLException.
+ * <p>
+ * ConnectionImpl extends DelegatingConnection to enable access to the underlying connection.
+ * </p>
  *
- * ConnectionImpl extends DelegatingConnection to enable access to the
- * underlying connection.
- *
- * @author John D. McNally
  * @since 2.0
  */
 class ConnectionImpl extends DelegatingConnection<Connection> {
@@ -44,32 +43,34 @@ class ConnectionImpl extends DelegatingConnection<Connection> {
     private final boolean accessToUnderlyingConnectionAllowed;
 
     /** The object that instantiated this object */
-     private final PooledConnectionImpl pooledConnection;
+    private final PooledConnectionImpl pooledConnection;
 
     /**
      * Creates a <code>ConnectionImpl</code>.
      *
-     * @param pooledConnection The PooledConnection that is calling the ctor.
-     * @param connection The JDBC 1.x Connection to wrap.
-     * @param accessToUnderlyingConnectionAllowed if true, then access is allowed to the underlying connection
+     * @param pooledConnection
+     *            The PooledConnection that is calling the ctor.
+     * @param connection
+     *            The JDBC 1.x Connection to wrap.
+     * @param accessToUnderlyingConnectionAllowed
+     *            if true, then access is allowed to the underlying connection
      */
-    ConnectionImpl(final PooledConnectionImpl pooledConnection,
-            final Connection connection,
+    ConnectionImpl(final PooledConnectionImpl pooledConnection, final Connection connection,
             final boolean accessToUnderlyingConnectionAllowed) {
         super(connection);
         this.pooledConnection = pooledConnection;
-        this.accessToUnderlyingConnectionAllowed =
-            accessToUnderlyingConnectionAllowed;
+        this.accessToUnderlyingConnectionAllowed = accessToUnderlyingConnectionAllowed;
     }
 
     /**
-     * Marks the Connection as closed, and notifies the pool that the
-     * pooled connection is available.
-     * In accordance with the JDBC specification this Connection cannot
-     * be used after closed() is called.  Any further usage will result in an
-     * SQLException.
+     * Marks the Connection as closed, and notifies the pool that the pooled connection is available.
+     * <p>
+     * In accordance with the JDBC specification this Connection cannot be used after closed() is called. Any further
+     * usage will result in an SQLException.
+     * </p>
      *
-     * @throws SQLException The database connection couldn't be closed.
+     * @throws SQLException
+     *             The database connection couldn't be closed.
      */
     @Override
     public void close() throws SQLException {
@@ -84,106 +85,179 @@ class ConnectionImpl extends DelegatingConnection<Connection> {
     }
 
     /**
-     * If pooling of <code>PreparedStatement</code>s is turned on in the
-     * {@link DriverAdapterCPDS}, a pooled object may be returned, otherwise
-     * delegate to the wrapped JDBC 1.x {@link java.sql.Connection}.
+     * If pooling of <code>CallableStatement</code>s is turned on in the {@link DriverAdapterCPDS}, a pooled object may
+     * be returned, otherwise delegate to the wrapped JDBC 1.x {@link java.sql.Connection}.
      *
-     * @param sql SQL statement to be prepared
-     * @return the prepared statement
-     * @throws SQLException if this connection is closed or an error occurs
-     * in the wrapped connection.
+     * @param sql
+     *            an SQL statement that may contain one or more '?' parameter placeholders. Typically this statement is
+     *            specified using JDBC call escape syntax.
+     * @return a default <code>CallableStatement</code> object containing the pre-compiled SQL statement.
+     * @exception SQLException
+     *                Thrown if a database access error occurs or this method is called on a closed connection.
+     * @since 2.4.0
      */
     @Override
-    public PreparedStatement prepareStatement(final String sql) throws SQLException {
+    public CallableStatement prepareCall(final String sql) throws SQLException {
         checkOpen();
         try {
-            return new DelegatingPreparedStatement
-                (this, pooledConnection.prepareStatement(sql));
-        }
-        catch (final SQLException e) {
+            return new DelegatingCallableStatement(this, pooledConnection.prepareCall(sql));
+        } catch (final SQLException e) {
             handleException(e); // Does not return
             return null;
         }
     }
 
     /**
-     * If pooling of <code>PreparedStatement</code>s is turned on in the
-     * {@link DriverAdapterCPDS}, a pooled object may be returned, otherwise
-     * delegate to the wrapped JDBC 1.x {@link java.sql.Connection}.
+     * If pooling of <code>CallableStatement</code>s is turned on in the {@link DriverAdapterCPDS}, a pooled object may
+     * be returned, otherwise delegate to the wrapped JDBC 1.x {@link java.sql.Connection}.
      *
-     * @throws SQLException if this connection is closed or an error occurs
-     * in the wrapped connection.
+     * @param sql
+     *            a <code>String</code> object that is the SQL statement to be sent to the database; may contain on or
+     *            more '?' parameters.
+     * @param resultSetType
+     *            a result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            a concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     * @return a <code>CallableStatement</code> object containing the pre-compiled SQL statement that will produce
+     *         <code>ResultSet</code> objects with the given type and concurrency.
+     * @throws SQLException
+     *             Thrown if a database access error occurs, this method is called on a closed connection or the given
+     *             parameters are not <code>ResultSet</code> constants indicating type and concurrency.
+     * @since 2.4.0
      */
     @Override
-    public PreparedStatement prepareStatement(final String sql, final int resultSetType,
-                                              final int resultSetConcurrency)
+    public CallableStatement prepareCall(final String sql, final int resultSetType, final int resultSetConcurrency)
             throws SQLException {
         checkOpen();
         try {
-            return new DelegatingPreparedStatement
-                (this, pooledConnection.prepareStatement
-                    (sql,resultSetType,resultSetConcurrency));
-        }
-        catch (final SQLException e) {
-            handleException(e);
+            return new DelegatingCallableStatement(this,
+                    pooledConnection.prepareCall(sql, resultSetType, resultSetConcurrency));
+        } catch (final SQLException e) {
+            handleException(e); // Does not return
             return null;
         }
     }
 
+    /**
+     * If pooling of <code>CallableStatement</code>s is turned on in the {@link DriverAdapterCPDS}, a pooled object may
+     * be returned, otherwise delegate to the wrapped JDBC 1.x {@link java.sql.Connection}.
+     *
+     * @param sql
+     *            a <code>String</code> object that is the SQL statement to be sent to the database; may contain on or
+     *            more '?' parameters.
+     * @param resultSetType
+     *            one of the following <code>ResultSet</code> constants: <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            one of the following <code>ResultSet</code> constants: <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     * @param resultSetHoldability
+     *            one of the following <code>ResultSet</code> constants: <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code>
+     *            or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>.
+     * @return a new <code>CallableStatement</code> object, containing the pre-compiled SQL statement, that will
+     *         generate <code>ResultSet</code> objects with the given type, concurrency, and holdability.
+     * @throws SQLException
+     *             Thrown if a database access error occurs, this method is called on a closed connection or the given
+     *             parameters are not <code>ResultSet</code> constants indicating type, concurrency, and holdability.
+     * @since 2.4.0
+     */
     @Override
-    public PreparedStatement prepareStatement(final String sql, final int resultSetType,
-                                              final int resultSetConcurrency,
-                                              final int resultSetHoldability)
-            throws SQLException {
+    public CallableStatement prepareCall(final String sql, final int resultSetType, final int resultSetConcurrency,
+            final int resultSetHoldability) throws SQLException {
         checkOpen();
         try {
-            return new DelegatingPreparedStatement(this,
-                    pooledConnection.prepareStatement(sql, resultSetType,
-                            resultSetConcurrency, resultSetHoldability));
+            return new DelegatingCallableStatement(this,
+                    pooledConnection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
+        } catch (final SQLException e) {
+            handleException(e); // Does not return
+            return null;
         }
-        catch (final SQLException e) {
-            handleException(e);
+    }
+
+    /**
+     * If pooling of <code>PreparedStatement</code>s is turned on in the {@link DriverAdapterCPDS}, a pooled object may
+     * be returned, otherwise delegate to the wrapped JDBC 1.x {@link java.sql.Connection}.
+     *
+     * @param sql
+     *            SQL statement to be prepared
+     * @return the prepared statement
+     * @throws SQLException
+     *             if this connection is closed or an error occurs in the wrapped connection.
+     */
+    @Override
+    public PreparedStatement prepareStatement(final String sql) throws SQLException {
+        checkOpen();
+        try {
+            return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql));
+        } catch (final SQLException e) {
+            handleException(e); // Does not return
             return null;
         }
     }
 
+    /**
+     * If pooling of <code>PreparedStatement</code>s is turned on in the {@link DriverAdapterCPDS}, a pooled object may
+     * be returned, otherwise delegate to the wrapped JDBC 1.x {@link java.sql.Connection}.
+     *
+     * @throws SQLException
+     *             if this connection is closed or an error occurs in the wrapped connection.
+     */
     @Override
-    public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys)
+    public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency)
             throws SQLException {
         checkOpen();
         try {
             return new DelegatingPreparedStatement(this,
-                    pooledConnection.prepareStatement(sql, autoGeneratedKeys));
-        }
-        catch (final SQLException e) {
+                    pooledConnection.prepareStatement(sql, resultSetType, resultSetConcurrency));
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
     @Override
-    public PreparedStatement prepareStatement(final String sql, final int columnIndexes[])
-            throws SQLException {
+    public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency,
+            final int resultSetHoldability) throws SQLException {
         checkOpen();
         try {
             return new DelegatingPreparedStatement(this,
-                    pooledConnection.prepareStatement(sql, columnIndexes));
+                    pooledConnection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
         }
-        catch (final SQLException e) {
+    }
+
+    @Override
+    public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
+        checkOpen();
+        try {
+            return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, autoGeneratedKeys));
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
     }
 
     @Override
-    public PreparedStatement prepareStatement(final String sql, final String columnNames[])
-            throws SQLException {
+    public PreparedStatement prepareStatement(final String sql, final int columnIndexes[]) throws SQLException {
         checkOpen();
         try {
-            return new DelegatingPreparedStatement(this,
-                    pooledConnection.prepareStatement(sql, columnNames));
+            return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, columnIndexes));
+        } catch (final SQLException e) {
+            handleException(e);
+            return null;
         }
-        catch (final SQLException e) {
+    }
+
+    @Override
+    public PreparedStatement prepareStatement(final String sql, final String columnNames[]) throws SQLException {
+        checkOpen();
+        try {
+            return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, columnNames));
+        } catch (final SQLException e) {
             handleException(e);
             return null;
         }
@@ -195,6 +269,7 @@ class ConnectionImpl extends DelegatingConnection<Connection> {
 
     /**
      * If false, getDelegate() and getInnermostDelegate() will return null.
+     *
      * @return true if access is allowed to the underlying connection
      * @see ConnectionImpl
      */
@@ -204,6 +279,7 @@ class ConnectionImpl extends DelegatingConnection<Connection> {
 
     /**
      * Get the delegated connection, if allowed.
+     *
      * @return the internal connection, or null if access is not allowed.
      * @see #isAccessToUnderlyingConnectionAllowed()
      */
@@ -217,6 +293,7 @@ class ConnectionImpl extends DelegatingConnection<Connection> {
 
     /**
      * Get the innermost connection, if allowed.
+     *
      * @return the innermost internal connection, or null if access is not allowed.
      * @see #isAccessToUnderlyingConnectionAllowed()
      */

==================================================
PStmtKeyCPDS.java
index 55bd5afedf..ba9c2c2bc3 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/DriverAdapterCPDS.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/DriverAdapterCPDS.java
@@ -37,7 +37,9 @@ import javax.naming.spi.ObjectFactory;
 import javax.sql.ConnectionPoolDataSource;
 import javax.sql.PooledConnection;
 
-import org.apache.tomcat.dbcp.dbcp2.PoolablePreparedStatement;
+import org.apache.tomcat.dbcp.dbcp2.DelegatingPreparedStatement;
+import org.apache.tomcat.dbcp.dbcp2.PStmtKey;
+import org.apache.tomcat.dbcp.dbcp2.Utils;
 import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
 import org.apache.tomcat.dbcp.pool2.impl.BaseObjectPoolConfig;
 import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool;
@@ -45,92 +47,79 @@ import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPoolConfig;
 
 /**
  * <p>
- * An adapter for JDBC drivers that do not include an implementation
- * of {@link javax.sql.ConnectionPoolDataSource}, but still include a
- * {@link java.sql.DriverManager} implementation.
- * <code>ConnectionPoolDataSource</code>s are not used within general
- * applications.  They are used by <code>DataSource</code> implementations
- * that pool <code>Connection</code>s, such as
- * {@link org.apache.tomcat.dbcp.dbcp2.datasources.SharedPoolDataSource}.  A J2EE
- * container will normally provide some method of initializing the
- * <code>ConnectionPoolDataSource</code> whose attributes are presented
- * as bean getters/setters and then deploying it via JNDI.  It is then
- * available as a source of physical connections to the database, when
- * the pooling <code>DataSource</code> needs to create a new
- * physical connection.
+ * An adapter for JDBC drivers that do not include an implementation of {@link javax.sql.ConnectionPoolDataSource}, but
+ * still include a {@link java.sql.DriverManager} implementation. <code>ConnectionPoolDataSource</code>s are not used
+ * within general applications. They are used by <code>DataSource</code> implementations that pool
+ * <code>Connection</code>s, such as {@link org.apache.tomcat.dbcp.dbcp2.datasources.SharedPoolDataSource}. A J2EE container
+ * will normally provide some method of initializing the <code>ConnectionPoolDataSource</code> whose attributes are
+ * presented as bean getters/setters and then deploying it via JNDI. It is then available as a source of physical
+ * connections to the database, when the pooling <code>DataSource</code> needs to create a new physical connection.
  * </p>
- *
  * <p>
- * Although normally used within a JNDI environment, the DriverAdapterCPDS
- * can be instantiated and initialized as any bean and then attached
- * directly to a pooling <code>DataSource</code>.
- * <code>Jdbc2PoolDataSource</code> can use the
+ * Although normally used within a JNDI environment, the DriverAdapterCPDS can be instantiated and initialized as any
+ * bean and then attached directly to a pooling <code>DataSource</code>. <code>Jdbc2PoolDataSource</code> can use the
  * <code>ConnectionPoolDataSource</code> with or without the use of JNDI.
  * </p>
- *
  * <p>
- * The DriverAdapterCPDS also provides <code>PreparedStatement</code> pooling
- * which is not generally available in jdbc2
- * <code>ConnectionPoolDataSource</code> implementation, but is
- * addressed within the jdbc3 specification.  The <code>PreparedStatement</code>
- * pool in DriverAdapterCPDS has been in the dbcp package for some time, but
- * it has not undergone extensive testing in the configuration used here.
- * It should be considered experimental and can be toggled with the
- * poolPreparedStatements attribute.
+ * The DriverAdapterCPDS also provides <code>PreparedStatement</code> pooling which is not generally available in jdbc2
+ * <code>ConnectionPoolDataSource</code> implementation, but is addressed within the jdbc3 specification. The
+ * <code>PreparedStatement</code> pool in DriverAdapterCPDS has been in the dbcp package for some time, but it has not
+ * undergone extensive testing in the configuration used here. It should be considered experimental and can be toggled
+ * with the poolPreparedStatements attribute.
  * </p>
- *
  * <p>
- * The <a href="package-summary.html">package documentation</a> contains an
- * example using catalina and JNDI.  The <a
- * href="../datasources/package-summary.html">datasources package documentation</a>
- * shows how to use <code>DriverAdapterCPDS</code> as a source for
- * <code>Jdbc2PoolDataSource</code> without the use of JNDI.
+ * The <a href="package-summary.html">package documentation</a> contains an example using catalina and JNDI. The
+ * <a href="../datasources/package-summary.html">datasources package documentation</a> shows how to use
+ * <code>DriverAdapterCPDS</code> as a source for <code>Jdbc2PoolDataSource</code> without the use of JNDI.
  * </p>
  *
- * @author John D. McNally
  * @since 2.0
  */
-public class DriverAdapterCPDS
-    implements ConnectionPoolDataSource, Referenceable, Serializable,
-               ObjectFactory {
+public class DriverAdapterCPDS implements ConnectionPoolDataSource, Referenceable, Serializable, ObjectFactory {
 
-    private static final long serialVersionUID = -4820523787212147844L;
+    private static final String KEY_USER = "user";
 
+    private static final String KEY_PASSWORD = "password";
 
-    private static final String GET_CONNECTION_CALLED
-            = "A PooledConnection was already requested from this source, "
+    private static final long serialVersionUID = -4820523787212147844L;
+
+    private static final String GET_CONNECTION_CALLED = "A PooledConnection was already requested from this source, "
             + "further initialization is not allowed.";
 
     /** Description */
     private String description;
-    /** Password */
-    private String password;
+
     /** Url name */
     private String url;
+
     /** User name */
-    private String user;
+    private String userName;
+
+    /** User password */
+    private char[] userPassword;
+
     /** Driver class name */
     private String driver;
 
     /** Login TimeOut in seconds */
     private int loginTimeout;
+
     /** Log stream. NOT USED */
-    private transient PrintWriter logWriter = null;
+    private transient PrintWriter logWriter;
 
     // PreparedStatement pool properties
     private boolean poolPreparedStatements;
     private int maxIdle = 10;
-    private long _timeBetweenEvictionRunsMillis =
-            BaseObjectPoolConfig.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
-    private int _numTestsPerEvictionRun = -1;
-    private int _minEvictableIdleTimeMillis = -1;
-    private int _maxPreparedStatements = -1;
+    private long timeBetweenEvictionRunsMillis = BaseObjectPoolConfig.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
+    private int numTestsPerEvictionRun = -1;
+    private int minEvictableIdleTimeMillis = -1;
+    private int maxPreparedStatements = -1;
 
     /** Whether or not getConnection has been called */
-    private volatile boolean getConnectionCalled = false;
+    private volatile boolean getConnectionCalled;
 
     /** Connection properties passed to JDBC Driver */
-    private Properties connectionProperties = null;
+    private Properties connectionProperties;
 
     static {
         // Attempt to prevent deadlocks - see DBCP - 272
@@ -140,7 +129,7 @@ public class DriverAdapterCPDS
     /**
      * Controls access to the underlying connection
      */
-    private boolean accessToUnderlyingConnectionAllowed = false;
+    private boolean accessToUnderlyingConnectionAllowed;
 
     /**
      * Default no-arg constructor for Serialization
@@ -149,8 +138,7 @@ public class DriverAdapterCPDS
     }
 
     /**
-     * Attempt to establish a database connection using the default
-     * user and password.
+     * Attempts to establish a database connection using the default user and password.
      */
     @Override
     public PooledConnection getPooledConnection() throws SQLException {
@@ -159,68 +147,65 @@ public class DriverAdapterCPDS
 
     /**
      * Attempt to establish a database connection.
-     * @param username name to be used for the connection
-     * @param pass password to be used fur the connection
+     *
+     * @param pooledUserName
+     *            name to be used for the connection
+     * @param pooledUserPassword
+     *            password to be used fur the connection
      */
     @Override
-    public PooledConnection getPooledConnection(final String username, final String pass)
+    public PooledConnection getPooledConnection(final String pooledUserName, final String pooledUserPassword)
             throws SQLException {
         getConnectionCalled = true;
-        PooledConnectionImpl pci = null;
-        // Workaround for buggy WebLogic 5.1 classloader - ignore the
-        // exception upon first invocation.
+        PooledConnectionImpl pooledConnection = null;
+        // Workaround for buggy WebLogic 5.1 classloader - ignore the exception upon first invocation.
         try {
             if (connectionProperties != null) {
-                connectionProperties.put("user", username);
-                connectionProperties.put("password", pass);
-                pci = new PooledConnectionImpl(DriverManager.getConnection(
-                        getUrl(), connectionProperties));
+                update(connectionProperties, KEY_USER, pooledUserName);
+                update(connectionProperties, KEY_PASSWORD, pooledUserPassword);
+                pooledConnection = new PooledConnectionImpl(
+                        DriverManager.getConnection(getUrl(), connectionProperties));
             } else {
-                pci = new PooledConnectionImpl(DriverManager.getConnection(
-                        getUrl(), username, pass));
+                pooledConnection = new PooledConnectionImpl(
+                        DriverManager.getConnection(getUrl(), pooledUserName, pooledUserPassword));
             }
-            pci.setAccessToUnderlyingConnectionAllowed(isAccessToUnderlyingConnectionAllowed());
-        }
-        catch (final ClassCircularityError e)
-        {
+            pooledConnection.setAccessToUnderlyingConnectionAllowed(isAccessToUnderlyingConnectionAllowed());
+        } catch (final ClassCircularityError e) {
             if (connectionProperties != null) {
-                pci = new PooledConnectionImpl(DriverManager.getConnection(
-                        getUrl(), connectionProperties));
+                pooledConnection = new PooledConnectionImpl(
+                        DriverManager.getConnection(getUrl(), connectionProperties));
             } else {
-                pci = new PooledConnectionImpl(DriverManager.getConnection(
-                        getUrl(), username, pass));
+                pooledConnection = new PooledConnectionImpl(
+                        DriverManager.getConnection(getUrl(), pooledUserName, pooledUserPassword));
             }
-            pci.setAccessToUnderlyingConnectionAllowed(isAccessToUnderlyingConnectionAllowed());
+            pooledConnection.setAccessToUnderlyingConnectionAllowed(isAccessToUnderlyingConnectionAllowed());
         }
-        KeyedObjectPool<PStmtKeyCPDS, PoolablePreparedStatement<PStmtKeyCPDS>> stmtPool = null;
+        KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> stmtPool = null;
         if (isPoolPreparedStatements()) {
-            final GenericKeyedObjectPoolConfig<PoolablePreparedStatement<PStmtKeyCPDS>> config = new GenericKeyedObjectPoolConfig<>();
+            final GenericKeyedObjectPoolConfig config = new GenericKeyedObjectPoolConfig();
             config.setMaxTotalPerKey(Integer.MAX_VALUE);
             config.setBlockWhenExhausted(false);
             config.setMaxWaitMillis(0);
             config.setMaxIdlePerKey(getMaxIdle());
-            if (getMaxPreparedStatements() <= 0)
-            {
-                // since there is no limit, create a prepared statement pool with an eviction thread
-                //  evictor settings are the same as the connection pool settings.
+            if (getMaxPreparedStatements() <= 0) {
+                // since there is no limit, create a prepared statement pool with an eviction thread;
+                // evictor settings are the same as the connection pool settings.
                 config.setTimeBetweenEvictionRunsMillis(getTimeBetweenEvictionRunsMillis());
                 config.setNumTestsPerEvictionRun(getNumTestsPerEvictionRun());
                 config.setMinEvictableIdleTimeMillis(getMinEvictableIdleTimeMillis());
-            }
-            else
-            {
-                // since there is limit, create a prepared statement pool without an eviction thread
-                //  pool has LRU functionality so when the limit is reached, 15% of the pool is cleared.
-                // see org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool.clearOldest method
+            } else {
+                // since there is a limit, create a prepared statement pool without an eviction thread;
+                // pool has LRU functionality so when the limit is reached, 15% of the pool is cleared.
+                // see org.apache.commons.pool2.impl.GenericKeyedObjectPool.clearOldest method
                 config.setMaxTotal(getMaxPreparedStatements());
                 config.setTimeBetweenEvictionRunsMillis(-1);
                 config.setNumTestsPerEvictionRun(0);
                 config.setMinEvictableIdleTimeMillis(0);
             }
-            stmtPool = new GenericKeyedObjectPool<>(pci, config);
-            pci.setStatementPool(stmtPool);
+            stmtPool = new GenericKeyedObjectPool<>(pooledConnection, config);
+            pooledConnection.setStatementPool(stmtPool);
         }
-        return pci;
+        return pooledConnection;
     }
 
     @Override
@@ -243,29 +228,21 @@ public class DriverAdapterCPDS
 
         ref.add(new StringRefAddr("description", getDescription()));
         ref.add(new StringRefAddr("driver", getDriver()));
-        ref.add(new StringRefAddr("loginTimeout",
-                                  String.valueOf(getLoginTimeout())));
-        ref.add(new StringRefAddr("password", getPassword()));
-        ref.add(new StringRefAddr("user", getUser()));
+        ref.add(new StringRefAddr("loginTimeout", String.valueOf(getLoginTimeout())));
+        ref.add(new StringRefAddr(KEY_PASSWORD, getPassword()));
+        ref.add(new StringRefAddr(KEY_USER, getUser()));
         ref.add(new StringRefAddr("url", getUrl()));
 
-        ref.add(new StringRefAddr("poolPreparedStatements",
-                                  String.valueOf(isPoolPreparedStatements())));
-        ref.add(new StringRefAddr("maxIdle",
-                                  String.valueOf(getMaxIdle())));
-        ref.add(new StringRefAddr("timeBetweenEvictionRunsMillis",
-            String.valueOf(getTimeBetweenEvictionRunsMillis())));
-        ref.add(new StringRefAddr("numTestsPerEvictionRun",
-            String.valueOf(getNumTestsPerEvictionRun())));
-        ref.add(new StringRefAddr("minEvictableIdleTimeMillis",
-            String.valueOf(getMinEvictableIdleTimeMillis())));
-        ref.add(new StringRefAddr("maxPreparedStatements",
-            String.valueOf(getMaxPreparedStatements())));
+        ref.add(new StringRefAddr("poolPreparedStatements", String.valueOf(isPoolPreparedStatements())));
+        ref.add(new StringRefAddr("maxIdle", String.valueOf(getMaxIdle())));
+        ref.add(new StringRefAddr("timeBetweenEvictionRunsMillis", String.valueOf(getTimeBetweenEvictionRunsMillis())));
+        ref.add(new StringRefAddr("numTestsPerEvictionRun", String.valueOf(getNumTestsPerEvictionRun())));
+        ref.add(new StringRefAddr("minEvictableIdleTimeMillis", String.valueOf(getMinEvictableIdleTimeMillis())));
+        ref.add(new StringRefAddr("maxPreparedStatements", String.valueOf(getMaxPreparedStatements())));
 
         return ref;
     }
 
-
     // ----------------------------------------------------------------------
     // ObjectFactory implementation
 
@@ -273,14 +250,13 @@ public class DriverAdapterCPDS
      * implements ObjectFactory to create an instance of this class
      */
     @Override
-    public Object getObjectInstance(final Object refObj, final Name name,
-                                    final Context context, final Hashtable<?,?> env)
-            throws Exception {
+    public Object getObjectInstance(final Object refObj, final Name name, final Context context,
+            final Hashtable<?, ?> env) throws Exception {
         // The spec says to return null if we can't create an instance
         // of the reference
         DriverAdapterCPDS cpds = null;
         if (refObj instanceof Reference) {
-            final Reference ref = (Reference)refObj;
+            final Reference ref = (Reference) refObj;
             if (ref.getClassName().equals(getClass().getName())) {
                 RefAddr ra = ref.get("description");
                 if (ra != null && ra.getContent() != null) {
@@ -295,19 +271,18 @@ public class DriverAdapterCPDS
                 if (ra != null && ra.getContent() != null) {
                     setUrl(ra.getContent().toString());
                 }
-                ra = ref.get("user");
+                ra = ref.get(KEY_USER);
                 if (ra != null && ra.getContent() != null) {
                     setUser(ra.getContent().toString());
                 }
-                ra = ref.get("password");
+                ra = ref.get(KEY_PASSWORD);
                 if (ra != null && ra.getContent() != null) {
                     setPassword(ra.getContent().toString());
                 }
 
                 ra = ref.get("poolPreparedStatements");
                 if (ra != null && ra.getContent() != null) {
-                    setPoolPreparedStatements(Boolean.valueOf(
-                        ra.getContent().toString()).booleanValue());
+                    setPoolPreparedStatements(Boolean.valueOf(ra.getContent().toString()).booleanValue());
                 }
                 ra = ref.get("maxIdle");
                 if (ra != null && ra.getContent() != null) {
@@ -316,31 +291,26 @@ public class DriverAdapterCPDS
 
                 ra = ref.get("timeBetweenEvictionRunsMillis");
                 if (ra != null && ra.getContent() != null) {
-                    setTimeBetweenEvictionRunsMillis(
-                        Integer.parseInt(ra.getContent().toString()));
+                    setTimeBetweenEvictionRunsMillis(Integer.parseInt(ra.getContent().toString()));
                 }
 
                 ra = ref.get("numTestsPerEvictionRun");
                 if (ra != null && ra.getContent() != null) {
-                    setNumTestsPerEvictionRun(
-                        Integer.parseInt(ra.getContent().toString()));
+                    setNumTestsPerEvictionRun(Integer.parseInt(ra.getContent().toString()));
                 }
 
                 ra = ref.get("minEvictableIdleTimeMillis");
                 if (ra != null && ra.getContent() != null) {
-                    setMinEvictableIdleTimeMillis(
-                        Integer.parseInt(ra.getContent().toString()));
+                    setMinEvictableIdleTimeMillis(Integer.parseInt(ra.getContent().toString()));
                 }
                 ra = ref.get("maxPreparedStatements");
                 if (ra != null && ra.getContent() != null) {
-                    setMaxPreparedStatements(
-                        Integer.parseInt(ra.getContent().toString()));
+                    setMaxPreparedStatements(Integer.parseInt(ra.getContent().toString()));
                 }
 
                 ra = ref.get("accessToUnderlyingConnectionAllowed");
                 if (ra != null && ra.getContent() != null) {
-                    setAccessToUnderlyingConnectionAllowed(
-                            Boolean.valueOf(ra.getContent().toString()).booleanValue());
+                    setAccessToUnderlyingConnectionAllowed(Boolean.valueOf(ra.getContent().toString()).booleanValue());
                 }
 
                 cpds = this;
@@ -350,8 +320,7 @@ public class DriverAdapterCPDS
     }
 
     /**
-     * Throws an IllegalStateException, if a PooledConnection has already
-     * been requested.
+     * Throws an IllegalStateException, if a PooledConnection has already been requested.
      */
     private void assertInitializationAllowed() throws IllegalStateException {
         if (getConnectionCalled) {
@@ -372,35 +341,40 @@ public class DriverAdapterCPDS
     }
 
     /**
-     * <p>Sets the connection properties passed to the JDBC driver.</p>
+     * <p>
+     * Sets the connection properties passed to the JDBC driver.
+     * </p>
      *
-     * <p>If <code>props</code> contains "user" and/or "password"
-     * properties, the corresponding instance properties are set. If these
-     * properties are not present, they are filled in using
-     * {@link #getUser()}, {@link #getPassword()} when {@link #getPooledConnection()}
-     * is called, or using the actual parameters to the method call when
-     * {@link #getPooledConnection(String, String)} is called. Calls to
-     * {@link #setUser(String)} or {@link #setPassword(String)} overwrite the values
-     * of these properties if <code>connectionProperties</code> is not null.</p>
+     * <p>
+     * If <code>props</code> contains "user" and/or "password" properties, the corresponding instance properties are
+     * set. If these properties are not present, they are filled in using {@link #getUser()}, {@link #getPassword()}
+     * when {@link #getPooledConnection()} is called, or using the actual parameters to the method call when
+     * {@link #getPooledConnection(String, String)} is called. Calls to {@link #setUser(String)} or
+     * {@link #setPassword(String)} overwrite the values of these properties if <code>connectionProperties</code> is not
+     * null.
+     * </p>
      *
-     * @param props Connection properties to use when creating new connections.
-     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     * @param props
+     *            Connection properties to use when creating new connections.
+     * @throws IllegalStateException
+     *             if {@link #getPooledConnection()} has been called
      */
     public void setConnectionProperties(final Properties props) {
         assertInitializationAllowed();
         connectionProperties = props;
-        if (connectionProperties.containsKey("user")) {
-            setUser(connectionProperties.getProperty("user"));
-        }
-        if (connectionProperties.containsKey("password")) {
-            setPassword(connectionProperties.getProperty("password"));
+        if (connectionProperties != null) {
+            if (connectionProperties.containsKey(KEY_USER)) {
+                setUser(connectionProperties.getProperty(KEY_USER));
+            }
+            if (connectionProperties.containsKey(KEY_PASSWORD)) {
+                setPassword(connectionProperties.getProperty(KEY_PASSWORD));
+            }
         }
     }
 
     /**
-     * Gets the value of description.  This property is here for use by
-     * the code which will deploy this datasource.  It is not used
-     * internally.
+     * Gets the value of description. This property is here for use by the code which will deploy this datasource. It is
+     * not used internally.
      *
      * @return value of description, may be null.
      * @see #setDescription(String)
@@ -410,39 +384,66 @@ public class DriverAdapterCPDS
     }
 
     /**
-     * Sets the value of description.  This property is here for use by
-     * the code which will deploy this datasource.  It is not used
-     * internally.
+     * Sets the value of description. This property is here for use by the code which will deploy this datasource. It is
+     * not used internally.
      *
-     * @param v  Value to assign to description.
+     * @param v
+     *            Value to assign to description.
      */
-    public void setDescription(final String  v) {
+    public void setDescription(final String v) {
         this.description = v;
     }
 
     /**
      * Gets the value of password for the default user.
+     *
+     * @return value of password.
+     * @since 2.4.0
+     */
+    public char[] getPasswordCharArray() {
+        return userPassword;
+    }
+
+    /**
+     * Gets the value of password for the default user.
+     *
      * @return value of password.
      */
     public String getPassword() {
-        return password;
+        return Utils.toString(userPassword);
     }
 
     /**
      * Sets the value of password for the default user.
-     * @param v  Value to assign to password.
-     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     *
+     * @param userPassword
+     *            Value to assign to password.
+     * @throws IllegalStateException
+     *             if {@link #getPooledConnection()} has been called
      */
-    public void setPassword(final String v) {
+    public void setPassword(final char[] userPassword) {
         assertInitializationAllowed();
-        this.password = v;
-        if (connectionProperties != null) {
-            connectionProperties.setProperty("password", v);
-        }
+        this.userPassword = userPassword;
+        update(connectionProperties, KEY_PASSWORD, Utils.toString(userPassword));
+    }
+
+    /**
+     * Sets the value of password for the default user.
+     *
+     * @param userPassword
+     *            Value to assign to password.
+     * @throws IllegalStateException
+     *             if {@link #getPooledConnection()} has been called
+     */
+    public void setPassword(final String userPassword) {
+        assertInitializationAllowed();
+        this.userPassword = Utils.toCharArray(userPassword);
+        update(connectionProperties, KEY_PASSWORD, userPassword);
     }
 
     /**
      * Gets the value of url used to locate the database for this datasource.
+     *
      * @return value of url.
      */
     public String getUrl() {
@@ -451,37 +452,43 @@ public class DriverAdapterCPDS
 
     /**
      * Sets the value of URL string used to locate the database for this datasource.
-     * @param v  Value to assign to url.
-     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
-    */
+     *
+     * @param v
+     *            Value to assign to url.
+     * @throws IllegalStateException
+     *             if {@link #getPooledConnection()} has been called
+     */
     public void setUrl(final String v) {
         assertInitializationAllowed();
         this.url = v;
     }
 
     /**
-     * Gets the value of default user (login or username).
+     * Gets the value of default user (login or user name).
+     *
      * @return value of user.
      */
     public String getUser() {
-        return user;
+        return userName;
     }
 
     /**
-     * Sets the value of default user (login or username).
-     * @param v  Value to assign to user.
-     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     * Sets the value of default user (login or user name).
+     *
+     * @param v
+     *            Value to assign to user.
+     * @throws IllegalStateException
+     *             if {@link #getPooledConnection()} has been called
      */
     public void setUser(final String v) {
         assertInitializationAllowed();
-        this.user = v;
-        if (connectionProperties != null) {
-            connectionProperties.setProperty("user", v);
-        }
+        this.userName = v;
+        update(connectionProperties, KEY_USER, v);
     }
 
     /**
-     * Gets the driver classname.
+     * Gets the driver class name.
+     *
      * @return value of driver.
      */
     public String getDriver() {
@@ -489,11 +496,15 @@ public class DriverAdapterCPDS
     }
 
     /**
-     * Sets the driver classname.  Setting the driver classname cause the
-     * driver to be registered with the DriverManager.
-     * @param v  Value to assign to driver.
-     * @throws ClassNotFoundException Driver class was not found
-     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     * Sets the driver class name. Setting the driver class name cause the driver to be registered with the
+     * DriverManager.
+     *
+     * @param v
+     *            Value to assign to driver.
+     * @throws IllegalStateException
+     *             if {@link #getPooledConnection()} has been called
+     * @throws ClassNotFoundException
+     *             if the class cannot be located
      */
     public void setDriver(final String v) throws ClassNotFoundException {
         assertInitializationAllowed();
@@ -503,8 +514,8 @@ public class DriverAdapterCPDS
     }
 
     /**
-     * Gets the maximum time in seconds that this data source can wait
-     * while attempting to connect to a database. NOT USED.
+     * Gets the maximum time in seconds that this data source can wait while attempting to connect to a database. NOT
+     * USED.
      */
     @Override
     public int getLoginTimeout() {
@@ -520,8 +531,8 @@ public class DriverAdapterCPDS
     }
 
     /**
-     * Sets the maximum time in seconds that this data source will wait
-     * while attempting to connect to a database. NOT USED.
+     * Sets the maximum time in seconds that this data source will wait while attempting to connect to a database. NOT
+     * USED.
      */
     @Override
     public void setLoginTimeout(final int seconds) {
@@ -536,13 +547,12 @@ public class DriverAdapterCPDS
         logWriter = out;
     }
 
-
     // ------------------------------------------------------------------
     // PreparedStatement pool properties
 
-
     /**
      * Flag to toggle the pooling of <code>PreparedStatement</code>s
+     *
      * @return value of poolPreparedStatements.
      */
     public boolean isPoolPreparedStatements() {
@@ -551,17 +561,21 @@ public class DriverAdapterCPDS
 
     /**
      * Flag to toggle the pooling of <code>PreparedStatement</code>s
-     * @param v  true to pool statements.
-     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     *
+     * @param poolPreparedStatements
+     *            true to pool statements.
+     * @throws IllegalStateException
+     *             if {@link #getPooledConnection()} has been called
      */
-    public void setPoolPreparedStatements(final boolean v) {
+    public void setPoolPreparedStatements(final boolean poolPreparedStatements) {
         assertInitializationAllowed();
-        this.poolPreparedStatements = v;
+        this.poolPreparedStatements = poolPreparedStatements;
     }
 
     /**
-     * Gets the maximum number of statements that can remain idle in the
-     * pool, without extra ones being released, or negative for no limit.
+     * Gets the maximum number of statements that can remain idle in the pool, without extra ones being released, or
+     * negative for no limit.
+     *
      * @return the value of maxIdle
      */
     public int getMaxIdle() {
@@ -569,11 +583,13 @@ public class DriverAdapterCPDS
     }
 
     /**
-     * Gets the maximum number of statements that can remain idle in the
-     * pool, without extra ones being released, or negative for no limit.
+     * Gets the maximum number of statements that can remain idle in the pool, without extra ones being released, or
+     * negative for no limit.
      *
-     * @param maxIdle The maximum number of statements that can remain idle
-     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     * @param maxIdle
+     *            The maximum number of statements that can remain idle
+     * @throws IllegalStateException
+     *             if {@link #getPooledConnection()} has been called
      */
     public void setMaxIdle(final int maxIdle) {
         assertInitializationAllowed();
@@ -581,107 +597,106 @@ public class DriverAdapterCPDS
     }
 
     /**
-     * Gets the number of milliseconds to sleep between runs of the
-     * idle object evictor thread.
-     * When non-positive, no idle object evictor thread will be
-     * run.
+     * Gets the number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive, no
+     * idle object evictor thread will be run.
+     *
      * @return the value of the evictor thread timer
      * @see #setTimeBetweenEvictionRunsMillis(long)
      */
     public long getTimeBetweenEvictionRunsMillis() {
-        return _timeBetweenEvictionRunsMillis;
+        return timeBetweenEvictionRunsMillis;
     }
 
     /**
-     * Sets the number of milliseconds to sleep between runs of the
-     * idle object evictor thread.
-     * When non-positive, no idle object evictor thread will be
-     * run.
-     * @param timeBetweenEvictionRunsMillis The time between runs
+     * Sets the number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive, no
+     * idle object evictor thread will be run.
+     *
+     * @param timeBetweenEvictionRunsMillis
+     *            The number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive,
+     *            no idle object evictor thread will be run.
      * @see #getTimeBetweenEvictionRunsMillis()
-     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     * @throws IllegalStateException
+     *             if {@link #getPooledConnection()} has been called
      */
-    public void setTimeBetweenEvictionRunsMillis(
-            final long timeBetweenEvictionRunsMillis) {
+    public void setTimeBetweenEvictionRunsMillis(final long timeBetweenEvictionRunsMillis) {
         assertInitializationAllowed();
-        _timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
+        this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
     }
 
     /**
-     * Gets the number of statements to examine during each run of the
-     * idle object evictor thread (if any).
+     * Gets the number of statements to examine during each run of the idle object evictor thread (if any.)
      *
-     * @see #setNumTestsPerEvictionRun(int)
-     * @see #setTimeBetweenEvictionRunsMillis(long)
-     * @return the number of statements
+     * @see #setNumTestsPerEvictionRun
+     * @see #setTimeBetweenEvictionRunsMillis
+     * @return the number of statements to examine during each run of the idle object evictor thread (if any.)
      */
     public int getNumTestsPerEvictionRun() {
-        return _numTestsPerEvictionRun;
+        return numTestsPerEvictionRun;
     }
 
     /**
-     * Sets the number of statements to examine during each run of the
-     * idle object evictor thread (if any).
+     * Sets the number of statements to examine during each run of the idle object evictor thread (if any).
      * <p>
-     * When a negative value is supplied, <tt>ceil({*link #numIdle})/abs({*link #getNumTestsPerEvictionRun})</tt>
-     * tests will be run.  I.e., when the value is <i>-n</i>, roughly one <i>n</i>th of the
-     * idle objects will be tested per run.
+     * When a negative value is supplied, <tt>ceil({*link #numIdle})/abs({*link #getNumTestsPerEvictionRun})</tt> tests
+     * will be run. I.e., when the value is <i>-n</i>, roughly one <i>n</i>th of the idle objects will be tested per
+     * run.
+     * </p>
      *
-     * @param numTestsPerEvictionRun number of statements to examine per run
+     * @param numTestsPerEvictionRun
+     *            number of statements to examine per run
      * @see #getNumTestsPerEvictionRun()
      * @see #setTimeBetweenEvictionRunsMillis(long)
-     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     * @throws IllegalStateException
+     *             if {@link #getPooledConnection()} has been called
      */
     public void setNumTestsPerEvictionRun(final int numTestsPerEvictionRun) {
         assertInitializationAllowed();
-        _numTestsPerEvictionRun = numTestsPerEvictionRun;
+        this.numTestsPerEvictionRun = numTestsPerEvictionRun;
     }
 
     /**
-     * Gets the minimum amount of time a statement may sit idle in the pool
-     * before it is eligible for eviction by the idle object evictor
-     * (if any).
+     * Gets the minimum amount of time a statement may sit idle in the pool before it is eligible for eviction by the
+     * idle object evictor (if any).
      *
-     * @see #setMinEvictableIdleTimeMillis(int)
-     * @see #setTimeBetweenEvictionRunsMillis(long)
-     * @return the amount of time
+     * @see #setMinEvictableIdleTimeMillis
+     * @see #setTimeBetweenEvictionRunsMillis
+     * @return the minimum amount of time a statement may sit idle in the pool.
      */
     public int getMinEvictableIdleTimeMillis() {
-        return _minEvictableIdleTimeMillis;
+        return minEvictableIdleTimeMillis;
     }
 
     /**
-     * Sets the minimum amount of time a statement may sit idle in the pool
-     * before it is eligible for eviction by the idle object evictor
-     * (if any).
-     * When non-positive, no objects will be evicted from the pool
-     * due to idle time alone.
-     * @param minEvictableIdleTimeMillis minimum time to set (in ms)
+     * Sets the minimum amount of time a statement may sit idle in the pool before it is eligible for eviction by the
+     * idle object evictor (if any). When non-positive, no objects will be evicted from the pool due to idle time alone.
+     *
+     * @param minEvictableIdleTimeMillis
+     *            minimum time to set (in ms)
      * @see #getMinEvictableIdleTimeMillis()
      * @see #setTimeBetweenEvictionRunsMillis(long)
-     * @throws IllegalStateException if {@link #getPooledConnection()} has been called
+     * @throws IllegalStateException
+     *             if {@link #getPooledConnection()} has been called
      */
     public void setMinEvictableIdleTimeMillis(final int minEvictableIdleTimeMillis) {
         assertInitializationAllowed();
-        _minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
+        this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
     }
 
     /**
      * Returns the value of the accessToUnderlyingConnectionAllowed property.
      *
-     * @return <code>true</code> if access to the underlying is allowed,
-     *  <code>false</code> otherwise.
+     * @return true if access to the underlying is allowed, false otherwise.
      */
     public synchronized boolean isAccessToUnderlyingConnectionAllowed() {
         return this.accessToUnderlyingConnectionAllowed;
     }
 
     /**
-     * Sets the value of the accessToUnderlyingConnectionAllowed property.
-     * It controls if the PoolGuard allows access to the underlying connection.
-     * (Default: false)
+     * Sets the value of the accessToUnderlyingConnectionAllowed property. It controls if the PoolGuard allows access to
+     * the underlying connection. (Default: false)
      *
-     * @param allow Access to the underlying connection is granted when true.
+     * @param allow
+     *            Access to the underlying connection is granted when true.
      */
     public synchronized void setAccessToUnderlyingConnectionAllowed(final boolean allow) {
         this.accessToUnderlyingConnectionAllowed = allow;
@@ -692,18 +707,27 @@ public class DriverAdapterCPDS
      *
      * @return maxPrepartedStatements value
      */
-    public int getMaxPreparedStatements()
-    {
-        return _maxPreparedStatements;
+    public int getMaxPreparedStatements() {
+        return maxPreparedStatements;
     }
 
     /**
      * Sets the maximum number of prepared statements.
-     * @param maxPreparedStatements the new maximum number of prepared
-     * statements
+     *
+     * @param maxPreparedStatements
+     *            the new maximum number of prepared statements
      */
-    public void setMaxPreparedStatements(final int maxPreparedStatements)
-    {
-        _maxPreparedStatements = maxPreparedStatements;
+    public void setMaxPreparedStatements(final int maxPreparedStatements) {
+        this.maxPreparedStatements = maxPreparedStatements;
+    }
+
+    private void update(final Properties properties, final String key, final String value) {
+        if (properties != null) {
+            if (value == null) {
+                properties.remove(key);
+            } else {
+                properties.setProperty(key, value);
+            }
+        }
     }
 }

==================================================
PooledConnectionImpl.java
index 7d7144a613..2fe63f98d7 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/PStmtKeyCPDS.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/PStmtKeyCPDS.java
@@ -16,122 +16,38 @@
  */
 package org.apache.tomcat.dbcp.dbcp2.cpdsadapter;
 
-import java.util.Arrays;
-
 import org.apache.tomcat.dbcp.dbcp2.PStmtKey;
 
 /**
  * A key uniquely identifying a {@link java.sql.PreparedStatement PreparedStatement}.
+ *
  * @since 2.0
+ * @deprecated Use {@link PStmtKey}.
  */
+@Deprecated
 public class PStmtKeyCPDS extends PStmtKey {
-    private final Integer _resultSetHoldability;
-    private final int _columnIndexes[];
-    private final String _columnNames[];
-
     public PStmtKeyCPDS(final String sql) {
         super(sql);
-        _resultSetHoldability = null;
-        _columnIndexes = null;
-        _columnNames = null;
     }
 
     public PStmtKeyCPDS(final String sql, final int autoGeneratedKeys) {
         super(sql, null, autoGeneratedKeys);
-        _resultSetHoldability = null;
-        _columnIndexes = null;
-        _columnNames = null;
     }
 
     public PStmtKeyCPDS(final String sql, final int resultSetType, final int resultSetConcurrency) {
         super(sql, resultSetType, resultSetConcurrency);
-        _resultSetHoldability = null;
-        _columnIndexes = null;
-        _columnNames = null;
     }
 
     public PStmtKeyCPDS(final String sql, final int resultSetType, final int resultSetConcurrency,
             final int resultSetHoldability) {
         super(sql, resultSetType, resultSetConcurrency);
-        _resultSetHoldability = Integer.valueOf(resultSetHoldability);
-        _columnIndexes = null;
-        _columnNames = null;
     }
 
     public PStmtKeyCPDS(final String sql, final int columnIndexes[]) {
-        super(sql);
-        _columnIndexes = Arrays.copyOf(columnIndexes, columnIndexes.length);
-        _resultSetHoldability = null;
-        _columnNames = null;
+        super(sql, null, columnIndexes);
     }
 
     public PStmtKeyCPDS(final String sql, final String columnNames[]) {
-        super(sql);
-        _columnNames = Arrays.copyOf(columnNames, columnNames.length);
-        _resultSetHoldability = null;
-        _columnIndexes = null;
-    }
-
-
-    @Override
-    public boolean equals(final Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (!super.equals(obj)) {
-            return false;
-        }
-        if (getClass() != obj.getClass()) {
-            return false;
-        }
-        final PStmtKeyCPDS other = (PStmtKeyCPDS) obj;
-        if (!Arrays.equals(_columnIndexes, other._columnIndexes)) {
-            return false;
-        }
-        if (!Arrays.equals(_columnNames, other._columnNames)) {
-            return false;
-        }
-        if (_resultSetHoldability == null) {
-            if (other._resultSetHoldability != null) {
-                return false;
-            }
-        } else if (!_resultSetHoldability.equals(other._resultSetHoldability)) {
-            return false;
-        }
-        return true;
-    }
-
-
-    @Override
-    public int hashCode() {
-        final int prime = 31;
-        int result = super.hashCode();
-        result = prime * result + Arrays.hashCode(_columnIndexes);
-        result = prime * result + Arrays.hashCode(_columnNames);
-        result = prime * result + (_resultSetHoldability == null ? 0 : _resultSetHoldability.hashCode());
-        return result;
-    }
-
-
-    @Override
-    public String toString() {
-        final StringBuffer buf = new StringBuffer();
-        buf.append("PStmtKey: sql=");
-        buf.append(getSql());
-        buf.append(", catalog=");
-        buf.append(getCatalog());
-        buf.append(", resultSetType=");
-        buf.append(getResultSetType());
-        buf.append(", resultSetConcurrency=");
-        buf.append(getResultSetConcurrency());
-        buf.append(", statementType=");
-        buf.append(getStmtType());
-        buf.append(", resultSetHoldability=");
-        buf.append(_resultSetHoldability);
-        buf.append(", columnIndexes=");
-        buf.append(Arrays.toString(_columnIndexes));
-        buf.append(", columnNames=");
-        buf.append(Arrays.toString(_columnNames));
-        return buf.toString();
+        super(sql, null, columnNames);
     }
 }

==================================================
CPDSConnectionFactory.java
index 98269423de..18c11e3bc2 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/PooledConnectionImpl.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/cpdsadapter/PooledConnectionImpl.java
@@ -17,6 +17,7 @@
 
 package org.apache.tomcat.dbcp.dbcp2.cpdsadapter;
 
+import java.sql.CallableStatement;
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
@@ -28,67 +29,69 @@ import javax.sql.PooledConnection;
 import javax.sql.StatementEventListener;
 
 import org.apache.tomcat.dbcp.dbcp2.DelegatingConnection;
+import org.apache.tomcat.dbcp.dbcp2.DelegatingPreparedStatement;
+import org.apache.tomcat.dbcp.dbcp2.PStmtKey;
+import org.apache.tomcat.dbcp.dbcp2.PoolableCallableStatement;
 import org.apache.tomcat.dbcp.dbcp2.PoolablePreparedStatement;
+import org.apache.tomcat.dbcp.dbcp2.PoolingConnection.StatementType;
 import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
 import org.apache.tomcat.dbcp.pool2.KeyedPooledObjectFactory;
 import org.apache.tomcat.dbcp.pool2.PooledObject;
 import org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject;
 
 /**
- * Implementation of PooledConnection that is returned by
- * PooledConnectionDataSource.
+ * Implementation of PooledConnection that is returned by PooledConnectionDataSource.
  *
- * @author John D. McNally
  * @since 2.0
  */
 class PooledConnectionImpl
-        implements PooledConnection, KeyedPooledObjectFactory<PStmtKeyCPDS, PoolablePreparedStatement<PStmtKeyCPDS>> {
+        implements PooledConnection, KeyedPooledObjectFactory<PStmtKey, DelegatingPreparedStatement> {
 
-    private static final String CLOSED
-            = "Attempted to use PooledConnection after closed() was called.";
+    private static final String CLOSED = "Attempted to use PooledConnection after closed() was called.";
 
     /**
      * The JDBC database connection that represents the physical db connection.
      */
-    private Connection connection = null;
+    private Connection connection;
 
     /**
-     * A DelegatingConnection used to create a PoolablePreparedStatementStub
+     * A DelegatingConnection used to create a PoolablePreparedStatementStub.
      */
     private final DelegatingConnection<?> delegatingConnection;
 
     /**
      * The JDBC database logical connection.
      */
-    private Connection logicalConnection = null;
+    private Connection logicalConnection;
 
     /**
-     * ConnectionEventListeners
+     * ConnectionEventListeners.
      */
     private final Vector<ConnectionEventListener> eventListeners;
 
     /**
-     * StatementEventListeners
+     * StatementEventListeners.
      */
-    private final Vector<StatementEventListener> statementEventListeners =
-            new Vector<>();
+    private final Vector<StatementEventListener> statementEventListeners = new Vector<>();
 
     /**
-     * flag set to true, once close() is called.
+     * Flag set to true, once {@link #close()} is called.
      */
-    private boolean isClosed;
+    private boolean closed;
 
     /** My pool of {@link PreparedStatement}s. */
-    private KeyedObjectPool<PStmtKeyCPDS, PoolablePreparedStatement<PStmtKeyCPDS>> pstmtPool = null;
+    private KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> pStmtPool;
 
     /**
-     * Controls access to the underlying connection
+     * Controls access to the underlying connection.
      */
-    private boolean accessToUnderlyingConnectionAllowed = false;
+    private boolean accessToUnderlyingConnectionAllowed;
 
     /**
-     * Wrap the real connection.
-     * @param connection the connection to be wrapped
+     * Wraps the real connection.
+     *
+     * @param connection
+     *            the connection to be wrapped.
      */
     PooledConnectionImpl(final Connection connection) {
         this.connection = connection;
@@ -98,12 +101,21 @@ class PooledConnectionImpl
             this.delegatingConnection = new DelegatingConnection<>(connection);
         }
         eventListeners = new Vector<>();
-        isClosed = false;
+        closed = false;
     }
 
-    public void setStatementPool(
-            final KeyedObjectPool<PStmtKeyCPDS, PoolablePreparedStatement<PStmtKeyCPDS>> statementPool) {
-        pstmtPool = statementPool;
+    /**
+     * My {@link KeyedPooledObjectFactory} method for activating {@link PreparedStatement}s.
+     *
+     * @param key
+     *            Ignored.
+     * @param pooledObject
+     *            Ignored.
+     */
+    @Override
+    public void activateObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject)
+            throws Exception {
+        pooledObject.getObject().activate();
     }
 
     /**
@@ -126,22 +138,31 @@ class PooledConnectionImpl
     /* JDBC_4_ANT_KEY_END */
 
     /**
-     * Closes the physical connection and marks this
-     * <code>PooledConnection</code> so that it may not be used
-     * to generate any more logical <code>Connection</code>s.
+     * Throws an SQLException, if isClosed is true
+     */
+    private void assertOpen() throws SQLException {
+        if (closed) {
+            throw new SQLException(CLOSED);
+        }
+    }
+
+    /**
+     * Closes the physical connection and marks this <code>PooledConnection</code> so that it may not be used to
+     * generate any more logical <code>Connection</code>s.
      *
-     * @throws SQLException if an error occurs or the connection is already closed
+     * @throws SQLException
+     *             Thrown when an error occurs or the connection is already closed.
      */
     @Override
     public void close() throws SQLException {
         assertOpen();
-        isClosed = true;
+        closed = true;
         try {
-            if (pstmtPool != null) {
+            if (pStmtPool != null) {
                 try {
-                    pstmtPool.close();
+                    pStmtPool.close();
                 } finally {
-                    pstmtPool = null;
+                    pStmtPool = null;
                 }
             }
         } catch (final RuntimeException e) {
@@ -158,11 +179,115 @@ class PooledConnectionImpl
     }
 
     /**
-     * Throws an SQLException, if isClosed is true
+     * Creates a {@link PooledConnectionImpl.PStmtKey} for the given arguments.
      */
-    private void assertOpen() throws SQLException {
-        if (isClosed) {
-            throw new SQLException(CLOSED);
+    protected PStmtKey createKey(final String sql) {
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull());
+    }
+
+    /**
+     * Creates a {@link PooledConnectionImpl.PStmtKey} for the given arguments.
+     */
+    protected PStmtKey createKey(final String sql, final int autoGeneratedKeys) {
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), autoGeneratedKeys);
+    }
+
+    /**
+     * Creates a {@link PooledConnectionImpl.PStmtKey} for the given arguments.
+     */
+    protected PStmtKey createKey(final String sql, final int columnIndexes[]) {
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), columnIndexes);
+    }
+
+    /**
+     * Creates a {@link PooledConnectionImpl.PStmtKey} for the given arguments.
+     */
+    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency) {
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), resultSetType, resultSetConcurrency);
+    }
+
+    /**
+     * Creates a {@link PooledConnectionImpl.PStmtKey} for the given arguments.
+     */
+    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency,
+            final int resultSetHoldability) {
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), resultSetType, resultSetConcurrency,
+                resultSetHoldability);
+    }
+
+    /**
+     * Creates a {@link PooledConnectionImpl.PStmtKey} for the given arguments.
+     *
+     * @since 2.4.0
+     */
+    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency,
+            final int resultSetHoldability, final StatementType statementType) {
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), resultSetType, resultSetConcurrency,
+                resultSetHoldability, statementType);
+    }
+
+    /**
+     * Creates a {@link PooledConnectionImpl.PStmtKey} for the given arguments.
+     *
+     * @since 2.4.0
+     */
+    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency,
+            final StatementType statementType) {
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), resultSetType, resultSetConcurrency, statementType);
+    }
+
+    /**
+     * Creates a {@link PooledConnectionImpl.PStmtKey} for the given arguments.
+     */
+    protected PStmtKey createKey(final String sql, final StatementType statementType) {
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), statementType);
+    }
+
+    /**
+     * Creates a {@link PooledConnectionImpl.PStmtKey} for the given arguments.
+     */
+    protected PStmtKey createKey(final String sql, final String columnNames[]) {
+        return new PStmtKey(normalizeSQL(sql), getCatalogOrNull(), columnNames);
+    }
+
+    /**
+     * My {@link KeyedPooledObjectFactory} method for destroying {@link PreparedStatement}s.
+     *
+     * @param key
+     *            ignored
+     * @param pooledObject
+     *            the wrapped {@link PreparedStatement} to be destroyed.
+     */
+    @Override
+    public void destroyObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject)
+            throws Exception {
+        pooledObject.getObject().getInnermostDelegate().close();
+    }
+
+    /**
+     * Closes the physical connection and checks that the logical connection was closed as well.
+     */
+    @Override
+    protected void finalize() throws Throwable {
+        // Closing the Connection ensures that if anyone tries to use it,
+        // an error will occur.
+        try {
+            connection.close();
+        } catch (final Exception ignored) {
+            // ignore
+        }
+
+        // make sure the last connection is marked as closed
+        if (logicalConnection != null && !logicalConnection.isClosed()) {
+            throw new SQLException("PooledConnection was gc'ed, without its last Connection being closed.");
+        }
+    }
+
+    private String getCatalogOrNull() {
+        try {
+            return connection == null ? null : connection.getCatalog();
+        } catch (final SQLException e) {
+            return null;
         }
     }
 
@@ -170,7 +295,8 @@ class PooledConnectionImpl
      * Returns a JDBC connection.
      *
      * @return The database connection.
-     * @throws SQLException if the connection is not open or the previous logical connection is still open
+     * @throws SQLException
+     *             if the connection is not open or the previous logical connection is still open
      */
     @Override
     public Connection getConnection() throws SQLException {
@@ -179,54 +305,58 @@ class PooledConnectionImpl
         if (logicalConnection != null && !logicalConnection.isClosed()) {
             // should notify pool of error so the pooled connection can
             // be removed !FIXME!
-            throw new SQLException("PooledConnection was reused, without "
-                    + "its previous Connection being closed.");
+            throw new SQLException("PooledConnection was reused, without its previous Connection being closed.");
         }
 
         // the spec requires that this return a new Connection instance.
-        logicalConnection = new ConnectionImpl(
-                this, connection, isAccessToUnderlyingConnectionAllowed());
+        logicalConnection = new ConnectionImpl(this, connection, isAccessToUnderlyingConnectionAllowed());
         return logicalConnection;
     }
 
     /**
-     * {@inheritDoc}
+     * Returns the value of the accessToUnderlyingConnectionAllowed property.
+     *
+     * @return true if access to the underlying is allowed, false otherwise.
      */
-    @Override
-    public void removeConnectionEventListener(
-            final ConnectionEventListener listener) {
-        eventListeners.remove(listener);
-    }
-
-    /* JDBC_4_ANT_KEY_BEGIN */
-    @Override
-    public void removeStatementEventListener(final StatementEventListener listener) {
-        statementEventListeners.remove(listener);
+    public synchronized boolean isAccessToUnderlyingConnectionAllowed() {
+        return this.accessToUnderlyingConnectionAllowed;
     }
-    /* JDBC_4_ANT_KEY_END */
 
     /**
-     * Closes the physical connection and checks that the logical connection
-     * was closed as well.
+     * My {@link KeyedPooledObjectFactory} method for creating {@link PreparedStatement}s.
+     *
+     * @param key
+     *            The key for the {@link PreparedStatement} to be created.
      */
+    @SuppressWarnings("resource")
     @Override
-    protected void finalize() throws Throwable {
-        // Closing the Connection ensures that if anyone tries to use it,
-        // an error will occur.
-        try {
-            connection.close();
-        } catch (final Exception ignored) {
+    public PooledObject<DelegatingPreparedStatement> makeObject(final PStmtKey key) throws Exception {
+        if (null == key) {
+            throw new IllegalArgumentException("Prepared statement key is null or invalid.");
         }
-
-        // make sure the last connection is marked as closed
-        if (logicalConnection != null && !logicalConnection.isClosed()) {
-            throw new SQLException("PooledConnection was gc'ed, without"
-                    + "its last Connection being closed.");
+        if (key.getStmtType() == StatementType.PREPARED_STATEMENT) {
+            final PreparedStatement statement = (PreparedStatement) key.createStatement(connection);
+            @SuppressWarnings({"rawtypes", "unchecked" }) // Unable to find way to avoid this
+            final PoolablePreparedStatement pps = new PoolablePreparedStatement(statement, key, pStmtPool,
+                    delegatingConnection);
+            return new DefaultPooledObject<DelegatingPreparedStatement>(pps);
         }
+        final CallableStatement statement = (CallableStatement) key.createStatement(connection);
+        @SuppressWarnings("unchecked")
+        final PoolableCallableStatement pcs = new PoolableCallableStatement(statement, key, pStmtPool,
+                (DelegatingConnection<Connection>) delegatingConnection);
+        return new DefaultPooledObject<DelegatingPreparedStatement>(pcs);
     }
 
     /**
-     * sends a connectionClosed event.
+     * Normalizes the given SQL statement, producing a canonical form that is semantically equivalent to the original.
+     */
+    protected String normalizeSQL(final String sql) {
+        return sql.trim();
+    }
+
+    /**
+     * Sends a connectionClosed event.
      */
     void notifyListeners() {
         final ConnectionEvent event = new ConnectionEvent(this);
@@ -236,52 +366,132 @@ class PooledConnectionImpl
         }
     }
 
-    // -------------------------------------------------------------------
-    // The following code implements a PreparedStatement pool
-
     /**
-     * Create or obtain a {@link PreparedStatement} from my pool.
-     * @param sql the SQL statement
-     * @return a {@link PoolablePreparedStatement}
+     * My {@link KeyedPooledObjectFactory} method for passivating {@link PreparedStatement}s. Currently invokes
+     * {@link PreparedStatement#clearParameters}.
+     *
+     * @param key
+     *            ignored
+     * @param pooledObject
+     *            a wrapped {@link PreparedStatement}
      */
-    PreparedStatement prepareStatement(final String sql) throws SQLException {
-        if (pstmtPool == null) {
-            return connection.prepareStatement(sql);
+    @Override
+    public void passivateObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject)
+            throws Exception {
+        @SuppressWarnings("resource")
+        final DelegatingPreparedStatement dps = pooledObject.getObject();
+        dps.clearParameters();
+        dps.passivate();
+    }
+
+    /**
+     * Creates or obtains a {@link CallableStatement} from my pool.
+     *
+     * @param sql
+     *            an SQL statement that may contain one or more '?' parameter placeholders. Typically this statement is
+     *            specified using JDBC call escape syntax.
+     * @return a default <code>CallableStatement</code> object containing the pre-compiled SQL statement.
+     * @exception SQLException
+     *                Thrown if a database access error occurs or this method is called on a closed connection.
+     * @since 2.4.0
+     */
+    CallableStatement prepareCall(final String sql) throws SQLException {
+        if (pStmtPool == null) {
+            return connection.prepareCall(sql);
         }
         try {
-            return pstmtPool.borrowObject(createKey(sql));
+            return (CallableStatement) pStmtPool.borrowObject(createKey(sql, StatementType.CALLABLE_STATEMENT));
         } catch (final RuntimeException e) {
             throw e;
         } catch (final Exception e) {
-            throw new SQLException("Borrow prepareStatement from pool failed", e);
+            throw new SQLException("Borrow prepareCall from pool failed", e);
+        }
+    }
+
+    /**
+     * Creates or obtains a {@link CallableStatement} from my pool.
+     *
+     * @param sql
+     *            a <code>String</code> object that is the SQL statement to be sent to the database; may contain on or
+     *            more '?' parameters.
+     * @param resultSetType
+     *            a result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            a concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     * @return a <code>CallableStatement</code> object containing the pre-compiled SQL statement that will produce
+     *         <code>ResultSet</code> objects with the given type and concurrency.
+     * @throws SQLException
+     *             Thrown if a database access error occurs, this method is called on a closed connection or the given
+     *             parameters are not <code>ResultSet</code> constants indicating type and concurrency.
+     * @since 2.4.0
+     */
+    CallableStatement prepareCall(final String sql, final int resultSetType, final int resultSetConcurrency)
+            throws SQLException {
+        if (pStmtPool == null) {
+            return connection.prepareCall(sql, resultSetType, resultSetConcurrency);
+        }
+        try {
+            return (CallableStatement) pStmtPool.borrowObject(
+                    createKey(sql, resultSetType, resultSetConcurrency, StatementType.CALLABLE_STATEMENT));
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Exception e) {
+            throw new SQLException("Borrow prepareCall from pool failed", e);
         }
     }
 
     /**
-     * Create or obtain a {@link PreparedStatement} from my pool.
-     * @param sql a <code>String</code> object that is the SQL statement to
-     *            be sent to the database; may contain one or more '?' IN
-     *            parameters
-     * @param resultSetType a result set type; one of
-     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,
-     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or
-     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
-     * @param resultSetConcurrency a concurrency type; one of
-     *         <code>ResultSet.CONCUR_READ_ONLY</code> or
-     *         <code>ResultSet.CONCUR_UPDATABLE</code>
+     * Creates or obtains a {@link CallableStatement} from my pool.
      *
+     * @param sql
+     *            a <code>String</code> object that is the SQL statement to be sent to the database; may contain on or
+     *            more '?' parameters.
+     * @param resultSetType
+     *            one of the following <code>ResultSet</code> constants: <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            one of the following <code>ResultSet</code> constants: <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     * @param resultSetHoldability
+     *            one of the following <code>ResultSet</code> constants: <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code>
+     *            or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>.
+     * @return a new <code>CallableStatement</code> object, containing the pre-compiled SQL statement, that will
+     *         generate <code>ResultSet</code> objects with the given type, concurrency, and holdability.
+     * @throws SQLException
+     *             Thrown if a database access error occurs, this method is called on a closed connection or the given
+     *             parameters are not <code>ResultSet</code> constants indicating type, concurrency, and holdability.
+     * @since 2.4.0
+     */
+    CallableStatement prepareCall(final String sql, final int resultSetType, final int resultSetConcurrency,
+            final int resultSetHoldability) throws SQLException {
+        if (pStmtPool == null) {
+            return connection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
+        }
+        try {
+            return (CallableStatement) pStmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency,
+                    resultSetHoldability, StatementType.CALLABLE_STATEMENT));
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Exception e) {
+            throw new SQLException("Borrow prepareCall from pool failed", e);
+        }
+    }
+
+    /**
+     * Creates or obtains a {@link PreparedStatement} from my pool.
+     *
+     * @param sql
+     *            the SQL statement.
      * @return a {@link PoolablePreparedStatement}
-     * @see Connection#prepareStatement(String, int, int)
      */
-    PreparedStatement prepareStatement(final String sql, final int resultSetType,
-                                       final int resultSetConcurrency)
-            throws SQLException {
-        if (pstmtPool == null) {
-            return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
+    PreparedStatement prepareStatement(final String sql) throws SQLException {
+        if (pStmtPool == null) {
+            return connection.prepareStatement(sql);
         }
         try {
-            return pstmtPool.borrowObject(
-                    createKey(sql,resultSetType,resultSetConcurrency));
+            return pStmtPool.borrowObject(createKey(sql));
         } catch (final RuntimeException e) {
             throw e;
         } catch (final Exception e) {
@@ -290,23 +500,22 @@ class PooledConnectionImpl
     }
 
     /**
-     * Create or obtain a {@link PreparedStatement} from my pool.
-     * @param sql an SQL statement that may contain one or more '?' IN
-     *        parameter placeholders
-     * @param autoGeneratedKeys a flag indicating whether auto-generated keys
-     *        should be returned; one of
-     *        <code>Statement.RETURN_GENERATED_KEYS</code> or
-     *        <code>Statement.NO_GENERATED_KEYS</code>
+     * Creates or obtains a {@link PreparedStatement} from my pool.
+     *
+     * @param sql
+     *            an SQL statement that may contain one or more '?' IN parameter placeholders.
+     * @param autoGeneratedKeys
+     *            a flag indicating whether auto-generated keys should be returned; one of
+     *            <code>Statement.RETURN_GENERATED_KEYS</code> or <code>Statement.NO_GENERATED_KEYS</code>.
      * @return a {@link PoolablePreparedStatement}
      * @see Connection#prepareStatement(String, int)
      */
-    PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys)
-            throws SQLException {
-        if (pstmtPool == null) {
+    PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
+        if (pStmtPool == null) {
             return connection.prepareStatement(sql, autoGeneratedKeys);
         }
         try {
-            return pstmtPool.borrowObject(createKey(sql,autoGeneratedKeys));
+            return pStmtPool.borrowObject(createKey(sql, autoGeneratedKeys));
         } catch (final RuntimeException e) {
             throw e;
         } catch (final Exception e) {
@@ -314,16 +523,12 @@ class PooledConnectionImpl
         }
     }
 
-    PreparedStatement prepareStatement(final String sql, final int resultSetType,
-            final int resultSetConcurrency, final int resultSetHoldability)
-    throws SQLException {
-        if (pstmtPool == null) {
-            return connection.prepareStatement(sql, resultSetType,
-                    resultSetConcurrency, resultSetHoldability);
+    PreparedStatement prepareStatement(final String sql, final int columnIndexes[]) throws SQLException {
+        if (pStmtPool == null) {
+            return connection.prepareStatement(sql, columnIndexes);
         }
         try {
-            return pstmtPool.borrowObject(createKey(sql, resultSetType,
-                    resultSetConcurrency, resultSetHoldability));
+            return pStmtPool.borrowObject(createKey(sql, columnIndexes));
         } catch (final RuntimeException e) {
             throw e;
         } catch (final Exception e) {
@@ -331,13 +536,29 @@ class PooledConnectionImpl
         }
     }
 
-    PreparedStatement prepareStatement(final String sql, final int columnIndexes[])
-    throws SQLException {
-        if (pstmtPool == null) {
-            return connection.prepareStatement(sql, columnIndexes);
+    /**
+     * Creates or obtains a {@link PreparedStatement} from my pool.
+     *
+     * @param sql
+     *            a <code>String</code> object that is the SQL statement to be sent to the database; may contain one or
+     *            more '?' IN parameters.
+     * @param resultSetType
+     *            a result set type; one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
+     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>.
+     * @param resultSetConcurrency
+     *            a concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code> or
+     *            <code>ResultSet.CONCUR_UPDATABLE</code>.
+     *
+     * @return a {@link PoolablePreparedStatement}.
+     * @see Connection#prepareStatement(String, int, int)
+     */
+    PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency)
+            throws SQLException {
+        if (pStmtPool == null) {
+            return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
         }
         try {
-            return pstmtPool.borrowObject(createKey(sql, columnIndexes));
+            return pStmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency));
         } catch (final RuntimeException e) {
             throw e;
         } catch (final Exception e) {
@@ -345,13 +566,13 @@ class PooledConnectionImpl
         }
     }
 
-    PreparedStatement prepareStatement(final String sql, final String columnNames[])
-    throws SQLException {
-        if (pstmtPool == null) {
-            return connection.prepareStatement(sql, columnNames);
+    PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency,
+            final int resultSetHoldability) throws SQLException {
+        if (pStmtPool == null) {
+            return connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
         }
         try {
-            return pstmtPool.borrowObject(createKey(sql, columnNames));
+            return pStmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
         } catch (final RuntimeException e) {
             throw e;
         } catch (final Exception e) {
@@ -359,161 +580,60 @@ class PooledConnectionImpl
         }
     }
 
-    /**
-     * Create a {@link PStmtKeyCPDS} for the given arguments.
-     */
-    protected PStmtKeyCPDS createKey(final String sql, final int autoGeneratedKeys) {
-        return new PStmtKeyCPDS(normalizeSQL(sql), autoGeneratedKeys);
-    }
-
-    /**
-     * Create a {@link PStmtKeyCPDS} for the given arguments.
-     */
-    protected PStmtKeyCPDS createKey(final String sql, final int resultSetType,
-            final int resultSetConcurrency, final int resultSetHoldability) {
-        return new PStmtKeyCPDS(normalizeSQL(sql), resultSetType,
-                resultSetConcurrency, resultSetHoldability);
-    }
-
-    /**
-     * Create a {@link PStmtKeyCPDS} for the given arguments.
-     */
-    protected PStmtKeyCPDS createKey(final String sql, final int columnIndexes[]) {
-        return new PStmtKeyCPDS(normalizeSQL(sql), columnIndexes);
-    }
-
-    /**
-     * Create a {@link PStmtKeyCPDS} for the given arguments.
-     */
-    protected PStmtKeyCPDS createKey(final String sql, final String columnNames[]) {
-        return new PStmtKeyCPDS(normalizeSQL(sql), columnNames);
-    }
-
-    /**
-     * Create a {@link PStmtKeyCPDS} for the given arguments.
-     */
-    protected PStmtKeyCPDS createKey(final String sql, final int resultSetType,
-                               final int resultSetConcurrency) {
-        return new PStmtKeyCPDS(normalizeSQL(sql), resultSetType,
-                            resultSetConcurrency);
-    }
-
-    /**
-     * Create a {@link PStmtKeyCPDS} for the given arguments.
-     */
-    protected PStmtKeyCPDS createKey(final String sql) {
-        return new PStmtKeyCPDS(normalizeSQL(sql));
-    }
-
-    /**
-     * Normalize the given SQL statement, producing a
-     * canonical form that is semantically equivalent to the original.
-     */
-    protected String normalizeSQL(final String sql) {
-        return sql.trim();
-    }
-
-    /**
-     * My {@link KeyedPooledObjectFactory} method for creating
-     * {@link PreparedStatement}s.
-     * @param key the key for the {@link PreparedStatement} to be created
-     */
-    @Override
-    public PooledObject<PoolablePreparedStatement<PStmtKeyCPDS>> makeObject(final PStmtKeyCPDS key) throws Exception {
-        if (null == key) {
-            throw new IllegalArgumentException();
+    PreparedStatement prepareStatement(final String sql, final String columnNames[]) throws SQLException {
+        if (pStmtPool == null) {
+            return connection.prepareStatement(sql, columnNames);
         }
-        // _openPstmts++;
-        if (null == key.getResultSetType()
-                && null == key.getResultSetConcurrency()) {
-            if (null == key.getAutoGeneratedKeys()) {
-                return new DefaultPooledObject<>(new PoolablePreparedStatement<>(
-                        connection.prepareStatement(key.getSql()),
-                        key, pstmtPool, delegatingConnection));
-            }
-            return new DefaultPooledObject<>(new PoolablePreparedStatement<>(
-                            connection.prepareStatement(key.getSql(),
-                                    key.getAutoGeneratedKeys().intValue()),
-                            key, pstmtPool, delegatingConnection));
+        try {
+            return pStmtPool.borrowObject(createKey(sql, columnNames));
+        } catch (final RuntimeException e) {
+            throw e;
+        } catch (final Exception e) {
+            throw new SQLException("Borrow prepareStatement from pool failed", e);
         }
-        return new DefaultPooledObject<>(new PoolablePreparedStatement<>(
-                connection.prepareStatement(key.getSql(),
-                        key.getResultSetType().intValue(),
-                        key.getResultSetConcurrency().intValue()),
-                        key, pstmtPool, delegatingConnection));
-    }
-
-    /**
-     * My {@link KeyedPooledObjectFactory} method for destroying
-     * {@link PreparedStatement}s.
-     * @param key ignored
-     * @param p the wrapped {@link PreparedStatement} to be destroyed.
-     */
-    @Override
-    public void destroyObject(final PStmtKeyCPDS key,
-            final PooledObject<PoolablePreparedStatement<PStmtKeyCPDS>> p)
-            throws Exception {
-        p.getObject().getInnermostDelegate().close();
     }
 
     /**
-     * My {@link KeyedPooledObjectFactory} method for validating
-     * {@link PreparedStatement}s.
-     * @param key ignored
-     * @param p ignored
-     * @return {@code true}
+     * {@inheritDoc}
      */
     @Override
-    public boolean validateObject(final PStmtKeyCPDS key,
-            final PooledObject<PoolablePreparedStatement<PStmtKeyCPDS>> p) {
-        return true;
+    public void removeConnectionEventListener(final ConnectionEventListener listener) {
+        eventListeners.remove(listener);
     }
 
-    /**
-     * My {@link KeyedPooledObjectFactory} method for activating
-     * {@link PreparedStatement}s.
-     * @param key ignored
-     * @param p ignored
-     */
+    /* JDBC_4_ANT_KEY_BEGIN */
     @Override
-    public void activateObject(final PStmtKeyCPDS key,
-            final PooledObject<PoolablePreparedStatement<PStmtKeyCPDS>> p)
-            throws Exception {
-        p.getObject().activate();
+    public void removeStatementEventListener(final StatementEventListener listener) {
+        statementEventListeners.remove(listener);
     }
+    /* JDBC_4_ANT_KEY_END */
 
     /**
-     * My {@link KeyedPooledObjectFactory} method for passivating
-     * {@link PreparedStatement}s.  Currently invokes {@link PreparedStatement#clearParameters}.
-     * @param key ignored
-     * @param p a wrapped {@link PreparedStatement}
+     * Sets the value of the accessToUnderlyingConnectionAllowed property. It controls if the PoolGuard allows access to
+     * the underlying connection. (Default: false.)
+     *
+     * @param allow
+     *            Access to the underlying connection is granted when true.
      */
-    @Override
-    public void passivateObject(final PStmtKeyCPDS key,
-            final PooledObject<PoolablePreparedStatement<PStmtKeyCPDS>> p)
-            throws Exception {
-        final PoolablePreparedStatement<PStmtKeyCPDS> ppss = p.getObject();
-        ppss.clearParameters();
-        ppss.passivate();
+    public synchronized void setAccessToUnderlyingConnectionAllowed(final boolean allow) {
+        this.accessToUnderlyingConnectionAllowed = allow;
     }
 
-    /**
-     * Returns the value of the accessToUnderlyingConnectionAllowed property.
-     *
-     * @return true if access to the underlying is allowed, false otherwise.
-     */
-    public synchronized boolean isAccessToUnderlyingConnectionAllowed() {
-        return this.accessToUnderlyingConnectionAllowed;
+    public void setStatementPool(final KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> statementPool) {
+        pStmtPool = statementPool;
     }
 
     /**
-     * Sets the value of the accessToUnderlyingConnectionAllowed property.
-     * It controls if the PoolGuard allows access to the underlying connection.
-     * (Default: false)
+     * My {@link KeyedPooledObjectFactory} method for validating {@link PreparedStatement}s.
      *
-     * @param allow Access to the underlying connection is granted when true.
+     * @param key
+     *            Ignored.
+     * @param pooledObject
+     *            Ignored.
+     * @return {@code true}
      */
-    public synchronized void setAccessToUnderlyingConnectionAllowed(final boolean allow) {
-        this.accessToUnderlyingConnectionAllowed = allow;
+    @Override
+    public boolean validateObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject) {
+        return true;
     }
 }

==================================================
InstanceKeyDataSource.java
index 014db18804..bc42266ae7 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/datasources/CPDSConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/CPDSConnectionFactory.java
@@ -40,67 +40,86 @@ import org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject;
  * A {@link PooledObjectFactory} that creates
  * {@link org.apache.tomcat.dbcp.dbcp2.PoolableConnection PoolableConnection}s.
  *
- * @author John D. McNally
  * @since 2.0
  */
 class CPDSConnectionFactory
-        implements PooledObjectFactory<PooledConnectionAndInfo>,
-        ConnectionEventListener, PooledConnectionManager {
-
-    private static final String NO_KEY_MESSAGE
-            = "close() was called on a Connection, but "
-            + "I have no record of the underlying PooledConnection.";
-
-    private final ConnectionPoolDataSource _cpds;
-    private final String _validationQuery;
-    private final int _validationQueryTimeout;
-    private final boolean _rollbackAfterValidation;
-    private ObjectPool<PooledConnectionAndInfo> _pool;
-    private final String _username;
-    private String _password = null;
-    private long maxConnLifetimeMillis = -1;
+        implements PooledObjectFactory<PooledConnectionAndInfo>, ConnectionEventListener, PooledConnectionManager {
+
+    private static final String NO_KEY_MESSAGE = "close() was called on a Connection, but I have no record of the underlying PooledConnection.";
 
+    private final ConnectionPoolDataSource cpds;
+    private final String validationQuery;
+    private final int validationQueryTimeoutSeconds;
+    private final boolean rollbackAfterValidation;
+    private ObjectPool<PooledConnectionAndInfo> pool;
+    private final String userName;
+    private char[] userPassword;
+    private long maxConnLifetimeMillis = -1;
 
     /**
-     * Map of PooledConnections for which close events are ignored.
-     * Connections are muted when they are being validated.
+     * Map of PooledConnections for which close events are ignored. Connections are muted when they are being validated.
      */
-    private final Set<PooledConnection> validatingSet =
-            Collections.newSetFromMap(new ConcurrentHashMap<PooledConnection,Boolean>());
+    private final Set<PooledConnection> validatingSet = Collections
+            .newSetFromMap(new ConcurrentHashMap<PooledConnection, Boolean>());
 
     /**
      * Map of PooledConnectionAndInfo instances
      */
-    private final Map<PooledConnection, PooledConnectionAndInfo> pcMap =
-        new ConcurrentHashMap<>();
+    private final Map<PooledConnection, PooledConnectionAndInfo> pcMap = new ConcurrentHashMap<>();
+
+    /**
+     * Creates a new {@code PoolableConnectionFactory}.
+     *
+     * @param cpds
+     *            the ConnectionPoolDataSource from which to obtain PooledConnection's
+     * @param validationQuery
+     *            a query to use to {@link #validateObject validate} {@link Connection}s. Should return at least one
+     *            row. May be {@code null} in which case {@link Connection#isValid(int)} will be used to validate
+     *            connections.
+     * @param validationQueryTimeoutSeconds
+     *            Timeout in seconds before validation fails
+     * @param rollbackAfterValidation
+     *            whether a rollback should be issued after {@link #validateObject validating} {@link Connection}s.
+     * @param userName
+     *            The user name to use to create connections
+     * @param userPassword
+     *            The password to use to create connections
+     * @since 2.4.0
+     */
+    public CPDSConnectionFactory(final ConnectionPoolDataSource cpds, final String validationQuery,
+            final int validationQueryTimeoutSeconds, final boolean rollbackAfterValidation, final String userName,
+            final char[] userPassword) {
+        this.cpds = cpds;
+        this.validationQuery = validationQuery;
+        this.validationQueryTimeoutSeconds = validationQueryTimeoutSeconds;
+        this.userName = userName;
+        this.userPassword = userPassword;
+        this.rollbackAfterValidation = rollbackAfterValidation;
+    }
 
     /**
-     * Create a new {@code PoolableConnectionFactory}.
+     * Creates a new {@code PoolableConnectionFactory}.
      *
-     * @param cpds the ConnectionPoolDataSource from which to obtain
-     * PooledConnection's
-     * @param validationQuery a query to use to {@link #validateObject
-     * validate} {@link Connection}s. Should return at least one row.
-     * May be {@code null} in which case {@link Connection#isValid(int)} will
-     * be used to validate connections.
-     * @param validationQueryTimeout Timeout in seconds before validation fails
-     * @param rollbackAfterValidation whether a rollback should be issued
-     * after {@link #validateObject validating} {@link Connection}s.
-     * @param username The user name to use to create connections
-     * @param password The password to use to create connections
+     * @param cpds
+     *            the ConnectionPoolDataSource from which to obtain PooledConnection's
+     * @param validationQuery
+     *            a query to use to {@link #validateObject validate} {@link Connection}s. Should return at least one
+     *            row. May be {@code null} in which case {@link Connection#isValid(int)} will be used to validate
+     *            connections.
+     * @param validationQueryTimeoutSeconds
+     *            Timeout in seconds before validation fails
+     * @param rollbackAfterValidation
+     *            whether a rollback should be issued after {@link #validateObject validating} {@link Connection}s.
+     * @param userName
+     *            The user name to use to create connections
+     * @param userPassword
+     *            The password to use to create connections
      */
-    public CPDSConnectionFactory(final ConnectionPoolDataSource cpds,
-                                 final String validationQuery,
-                                 final int validationQueryTimeout,
-                                 final boolean rollbackAfterValidation,
-                                 final String username,
-                                 final String password) {
-        _cpds = cpds;
-        _validationQuery = validationQuery;
-        _validationQueryTimeout = validationQueryTimeout;
-        _username = username;
-        _password = password;
-        _rollbackAfterValidation = rollbackAfterValidation;
+    public CPDSConnectionFactory(final ConnectionPoolDataSource cpds, final String validationQuery,
+            final int validationQueryTimeoutSeconds, final boolean rollbackAfterValidation, final String userName,
+            final String userPassword) {
+        this(cpds, validationQuery, validationQueryTimeoutSeconds, rollbackAfterValidation, userName,
+                Utils.toCharArray(userPassword));
     }
 
     /**
@@ -109,16 +128,16 @@ class CPDSConnectionFactory
      * @return ObjectPool managing pooled connections
      */
     public ObjectPool<PooledConnectionAndInfo> getPool() {
-        return _pool;
+        return pool;
     }
 
     /**
      *
-     * @param pool the {@link ObjectPool} in which to pool those {@link
-     * Connection}s
+     * @param pool
+     *            the {@link ObjectPool} in which to pool those {@link Connection}s
      */
     public void setPool(final ObjectPool<PooledConnectionAndInfo> pool) {
-        this._pool = pool;
+        this.pool = pool;
     }
 
     @Override
@@ -126,10 +145,10 @@ class CPDSConnectionFactory
         PooledConnectionAndInfo pci;
         try {
             PooledConnection pc = null;
-            if (_username == null) {
-                pc = _cpds.getPooledConnection();
+            if (userName == null) {
+                pc = cpds.getPooledConnection();
             } else {
-                pc = _cpds.getPooledConnection(_username, _password);
+                pc = cpds.getPooledConnection(userName, Utils.toString(userPassword));
             }
 
             if (pc == null) {
@@ -139,7 +158,7 @@ class CPDSConnectionFactory
             // should we add this object as a listener or the pool.
             // consider the validateObject method in decision
             pc.addConnectionEventListener(this);
-            pci = new PooledConnectionAndInfo(pc, _username, _password);
+            pci = new PooledConnectionAndInfo(pc, userName, userPassword);
             pcMap.put(pc, pci);
         } catch (final SQLException e) {
             throw new RuntimeException(e.getMessage());
@@ -155,7 +174,7 @@ class CPDSConnectionFactory
         doDestroyObject(p.getObject());
     }
 
-    private void doDestroyObject(final PooledConnectionAndInfo pci) throws Exception{
+    private void doDestroyObject(final PooledConnectionAndInfo pci) throws Exception {
         final PooledConnection pc = pci.getPooledConnection();
         pc.removeConnectionEventListener(this);
         pcMap.remove(pc);
@@ -173,14 +192,14 @@ class CPDSConnectionFactory
         final PooledConnection pconn = p.getObject().getPooledConnection();
         Connection conn = null;
         validatingSet.add(pconn);
-        if (null == _validationQuery) {
-            int timeout = _validationQueryTimeout;
-            if (timeout < 0) {
-                timeout = 0;
+        if (null == validationQuery) {
+            int timeoutSeconds = validationQueryTimeoutSeconds;
+            if (timeoutSeconds < 0) {
+                timeoutSeconds = 0;
             }
             try {
                 conn = pconn.getConnection();
-                valid = conn.isValid(timeout);
+                valid = conn.isValid(timeoutSeconds);
             } catch (final SQLException e) {
                 valid = false;
             } finally {
@@ -198,13 +217,13 @@ class CPDSConnectionFactory
             try {
                 conn = pconn.getConnection();
                 stmt = conn.createStatement();
-                rset = stmt.executeQuery(_validationQuery);
+                rset = stmt.executeQuery(validationQuery);
                 if (rset.next()) {
                     valid = true;
                 } else {
                     valid = false;
                 }
-                if (_rollbackAfterValidation) {
+                if (rollbackAfterValidation) {
                     conn.rollback();
                 }
             } catch (final Exception e) {
@@ -220,14 +239,12 @@ class CPDSConnectionFactory
     }
 
     @Override
-    public void passivateObject(final PooledObject<PooledConnectionAndInfo> p)
-            throws Exception {
+    public void passivateObject(final PooledObject<PooledConnectionAndInfo> p) throws Exception {
         validateLifetime(p);
     }
 
     @Override
-    public void activateObject(final PooledObject<PooledConnectionAndInfo> p)
-            throws Exception {
+    public void activateObject(final PooledObject<PooledConnectionAndInfo> p) throws Exception {
         validateLifetime(p);
     }
 
@@ -236,10 +253,9 @@ class CPDSConnectionFactory
     // ***********************************************************************
 
     /**
-     * This will be called if the Connection returned by the getConnection
-     * method came from a PooledConnection, and the user calls the close()
-     * method of this connection object. What we need to do here is to
-     * release this PooledConnection from our pool...
+     * This will be called if the Connection returned by the getConnection method came from a PooledConnection, and the
+     * user calls the close() method of this connection object. What we need to do here is to release this
+     * PooledConnection from our pool...
      */
     @Override
     public void connectionClosed(final ConnectionEvent event) {
@@ -253,16 +269,14 @@ class CPDSConnectionFactory
             }
 
             try {
-                _pool.returnObject(pci);
+                pool.returnObject(pci);
             } catch (final Exception e) {
-                System.err.println("CLOSING DOWN CONNECTION AS IT COULD "
-                        + "NOT BE RETURNED TO THE POOL");
+                System.err.println("CLOSING DOWN CONNECTION AS IT COULD " + "NOT BE RETURNED TO THE POOL");
                 pc.removeConnectionEventListener(this);
                 try {
                     doDestroyObject(pci);
                 } catch (final Exception e2) {
-                    System.err.println("EXCEPTION WHILE DESTROYING OBJECT "
-                            + pci);
+                    System.err.println("EXCEPTION WHILE DESTROYING OBJECT " + pci);
                     e2.printStackTrace();
                 }
             }
@@ -270,16 +284,13 @@ class CPDSConnectionFactory
     }
 
     /**
-     * If a fatal error occurs, close the underlying physical connection so as
-     * not to be returned in the future
+     * If a fatal error occurs, close the underlying physical connection so as not to be returned in the future
      */
     @Override
     public void connectionErrorOccurred(final ConnectionEvent event) {
-        final PooledConnection pc = (PooledConnection)event.getSource();
+        final PooledConnection pc = (PooledConnection) event.getSource();
         if (null != event.getSQLException()) {
-            System.err.println(
-                    "CLOSING DOWN CONNECTION DUE TO INTERNAL ERROR ("
-                    + event.getSQLException() + ")");
+            System.err.println("CLOSING DOWN CONNECTION DUE TO INTERNAL ERROR (" + event.getSQLException() + ")");
         }
         pc.removeConnectionEventListener(this);
 
@@ -288,7 +299,7 @@ class CPDSConnectionFactory
             throw new IllegalStateException(NO_KEY_MESSAGE);
         }
         try {
-            _pool.invalidateObject(pci);
+            pool.invalidateObject(pci);
         } catch (final Exception e) {
             System.err.println("EXCEPTION WHILE DESTROYING OBJECT " + pci);
             e.printStackTrace();
@@ -300,10 +311,9 @@ class CPDSConnectionFactory
     // ***********************************************************************
 
     /**
-     * Invalidates the PooledConnection in the pool.  The CPDSConnectionFactory
-     * closes the connection and pool counters are updated appropriately.
-     * Also closes the pool.  This ensures that all idle connections are closed
-     * and connections that are checked out are closed on return.
+     * Invalidates the PooledConnection in the pool. The CPDSConnectionFactory closes the connection and pool counters
+     * are updated appropriately. Also closes the pool. This ensures that all idle connections are closed and
+     * connections that are checked out are closed on return.
      */
     @Override
     public void invalidate(final PooledConnection pc) throws SQLException {
@@ -312,8 +322,8 @@ class CPDSConnectionFactory
             throw new IllegalStateException(NO_KEY_MESSAGE);
         }
         try {
-            _pool.invalidateObject(pci);  // Destroy instance and update pool counters
-            _pool.close();  // Clear any other instances in this pool and kill others as they come back
+            pool.invalidateObject(pci); // Destroy instance and update pool counters
+            pool.close(); // Clear any other instances in this pool and kill others as they come back
         } catch (final Exception ex) {
             throw new SQLException("Error invalidating connection", ex);
         }
@@ -322,50 +332,58 @@ class CPDSConnectionFactory
     /**
      * Sets the database password used when creating new connections.
      *
-     * @param password new password
+     * @param userPassword
+     *            new password
+     */
+    public synchronized void setPassword(final char[] userPassword) {
+        this.userPassword = userPassword;
+    }
+
+    /**
+     * Sets the database password used when creating new connections.
+     *
+     * @param userPassword
+     *            new password
      */
     @Override
-    public synchronized void setPassword(final String password) {
-        _password = password;
+    public synchronized void setPassword(final String userPassword) {
+        this.userPassword = Utils.toCharArray(userPassword);
     }
 
     /**
-     * Sets the maximum lifetime in milliseconds of a connection after which the
-     * connection will always fail activation, passivation and validation.
+     * Sets the maximum lifetime in milliseconds of a connection after which the connection will always fail activation,
+     * passivation and validation.
      *
-     * @param maxConnLifetimeMillis A value of zero or less indicates an
-     *        infinite lifetime. The default value is -1.
+     * @param maxConnLifetimeMillis
+     *            A value of zero or less indicates an infinite lifetime. The default value is -1.
      */
     public void setMaxConnLifetimeMillis(final long maxConnLifetimeMillis) {
         this.maxConnLifetimeMillis = maxConnLifetimeMillis;
     }
 
     /**
-     * Verifies that the username matches the user whose connections are being managed by this
-     * factory and closes the pool if this is the case; otherwise does nothing.
+     * Verifies that the user name matches the user whose connections are being managed by this factory and closes the
+     * pool if this is the case; otherwise does nothing.
      */
     @Override
-    public void closePool(final String username) throws SQLException {
+    public void closePool(final String userName) throws SQLException {
         synchronized (this) {
-            if (username == null || !username.equals(_username)) {
+            if (userName == null || !userName.equals(this.userName)) {
                 return;
             }
         }
         try {
-            _pool.close();
+            pool.close();
         } catch (final Exception ex) {
             throw new SQLException("Error closing connection pool", ex);
         }
     }
 
-    private void validateLifetime(final PooledObject<PooledConnectionAndInfo> p)
-            throws Exception {
+    private void validateLifetime(final PooledObject<PooledConnectionAndInfo> p) throws Exception {
         if (maxConnLifetimeMillis > 0) {
             final long lifetime = System.currentTimeMillis() - p.getCreateTime();
             if (lifetime > maxConnLifetimeMillis) {
-                throw new Exception(Utils.getMessage(
-                        "connectionFactory.lifetimeExceeded",
-                        Long.valueOf(lifetime),
+                throw new Exception(Utils.getMessage("connectionFactory.lifetimeExceeded", Long.valueOf(lifetime),
                         Long.valueOf(maxConnLifetimeMillis)));
             }
         }

==================================================
InstanceKeyDataSourceFactory.java
index da225b9b62..444ec1ddb6 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/datasources/InstanceKeyDataSource.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/InstanceKeyDataSource.java
@@ -39,132 +39,104 @@ import org.apache.tomcat.dbcp.pool2.impl.BaseObjectPoolConfig;
 import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPoolConfig;
 
 /**
- * <p>The base class for <code>SharedPoolDataSource</code> and
- * <code>PerUserPoolDataSource</code>.  Many of the configuration properties
- * are shared and defined here.  This class is declared public in order
- * to allow particular usage with commons-beanutils; do not make direct
- * use of it outside of <em>commons-dbcp2</em>.
+ * <p>
+ * The base class for <code>SharedPoolDataSource</code> and <code>PerUserPoolDataSource</code>. Many of the
+ * configuration properties are shared and defined here. This class is declared public in order to allow particular
+ * usage with commons-beanutils; do not make direct use of it outside of <em>commons-dbcp2</em>.
  * </p>
  *
  * <p>
- * A J2EE container will normally provide some method of initializing the
- * <code>DataSource</code> whose attributes are presented
- * as bean getters/setters and then deploying it via JNDI.  It is then
- * available to an application as a source of pooled logical connections to
- * the database.  The pool needs a source of physical connections.  This
- * source is in the form of a <code>ConnectionPoolDataSource</code> that
- * can be specified via the {@link #setDataSourceName(String)} used to
- * lookup the source via JNDI.
+ * A J2EE container will normally provide some method of initializing the <code>DataSource</code> whose attributes are
+ * presented as bean getters/setters and then deploying it via JNDI. It is then available to an application as a source
+ * of pooled logical connections to the database. The pool needs a source of physical connections. This source is in the
+ * form of a <code>ConnectionPoolDataSource</code> that can be specified via the {@link #setDataSourceName(String)} used
+ * to lookup the source via JNDI.
  * </p>
  *
  * <p>
- * Although normally used within a JNDI environment, A DataSource
- * can be instantiated and initialized as any bean.  In this case the
- * <code>ConnectionPoolDataSource</code> will likely be instantiated in
- * a similar manner.  This class allows the physical source of connections
- * to be attached directly to this pool using the
+ * Although normally used within a JNDI environment, A DataSource can be instantiated and initialized as any bean. In
+ * this case the <code>ConnectionPoolDataSource</code> will likely be instantiated in a similar manner. This class
+ * allows the physical source of connections to be attached directly to this pool using the
  * {@link #setConnectionPoolDataSource(ConnectionPoolDataSource)} method.
  * </p>
  *
  * <p>
- * The dbcp package contains an adapter,
- * {@link org.apache.tomcat.dbcp.dbcp2.cpdsadapter.DriverAdapterCPDS},
- * that can be used to allow the use of <code>DataSource</code>'s based on this
- * class with JDBC driver implementations that do not supply a
- * <code>ConnectionPoolDataSource</code>, but still
- * provide a {@link java.sql.Driver} implementation.
+ * The dbcp package contains an adapter, {@link org.apache.tomcat.dbcp.dbcp2.cpdsadapter.DriverAdapterCPDS}, that can be
+ * used to allow the use of <code>DataSource</code>'s based on this class with JDBC driver implementations that do not
+ * supply a <code>ConnectionPoolDataSource</code>, but still provide a {@link java.sql.Driver} implementation.
  * </p>
  *
  * <p>
- * The <a href="package-summary.html">package documentation</a> contains an
- * example using Apache Tomcat and JNDI and it also contains a non-JNDI example.
+ * The <a href="package-summary.html">package documentation</a> contains an example using Apache Tomcat and JNDI and it
+ * also contains a non-JNDI example.
  * </p>
  *
- * @author John D. McNally
  * @since 2.0
  */
-public abstract class InstanceKeyDataSource
-        implements DataSource, Referenceable, Serializable, AutoCloseable {
+public abstract class InstanceKeyDataSource implements DataSource, Referenceable, Serializable, AutoCloseable {
 
     private static final long serialVersionUID = -6819270431752240878L;
 
-    private static final String GET_CONNECTION_CALLED
-            = "A Connection was already requested from this source, "
+    private static final String GET_CONNECTION_CALLED = "A Connection was already requested from this source, "
             + "further initialization is not allowed.";
-    private static final String BAD_TRANSACTION_ISOLATION
-        = "The requested TransactionIsolation level is invalid.";
+    private static final String BAD_TRANSACTION_ISOLATION = "The requested TransactionIsolation level is invalid.";
 
     /**
-    * Internal constant to indicate the level is not set.
-    */
+     * Internal constant to indicate the level is not set.
+     */
     protected static final int UNKNOWN_TRANSACTIONISOLATION = -1;
 
     /** Guards property setters - once true, setters throw IllegalStateException */
-    private volatile boolean getConnectionCalled = false;
+    private volatile boolean getConnectionCalled;
 
     /** Underlying source of PooledConnections */
-    private ConnectionPoolDataSource dataSource = null;
+    private ConnectionPoolDataSource dataSource;
 
     /** DataSource Name used to find the ConnectionPoolDataSource */
-    private String dataSourceName = null;
+    private String dataSourceName;
 
     /** Description */
-    private String description = null;
+    private String description;
 
     /** Environment that may be used to set up a jndi initial context. */
-    private Properties jndiEnvironment = null;
+    private Properties jndiEnvironment;
 
     /** Login TimeOut in seconds */
-    private int loginTimeout = 0;
+    private int loginTimeout;
 
     /** Log stream */
-    private PrintWriter logWriter = null;
+    private PrintWriter logWriter;
 
     /** Instance key */
-    private String instanceKey = null;
+    private String instanceKey;
 
     // Pool properties
-    private boolean defaultBlockWhenExhausted =
-            BaseObjectPoolConfig.DEFAULT_BLOCK_WHEN_EXHAUSTED;
-    private String defaultEvictionPolicyClassName =
-            BaseObjectPoolConfig.DEFAULT_EVICTION_POLICY_CLASS_NAME;
+    private boolean defaultBlockWhenExhausted = BaseObjectPoolConfig.DEFAULT_BLOCK_WHEN_EXHAUSTED;
+    private String defaultEvictionPolicyClassName = BaseObjectPoolConfig.DEFAULT_EVICTION_POLICY_CLASS_NAME;
     private boolean defaultLifo = BaseObjectPoolConfig.DEFAULT_LIFO;
-    private int defaultMaxIdle =
-            GenericKeyedObjectPoolConfig.DEFAULT_MAX_IDLE_PER_KEY;
-    private int defaultMaxTotal =
-            GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL;
-    private long defaultMaxWaitMillis =
-            BaseObjectPoolConfig.DEFAULT_MAX_WAIT_MILLIS;
-    private long defaultMinEvictableIdleTimeMillis =
-            BaseObjectPoolConfig.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
-    private int defaultMinIdle =
-            GenericKeyedObjectPoolConfig.DEFAULT_MIN_IDLE_PER_KEY;
-    private int defaultNumTestsPerEvictionRun =
-            BaseObjectPoolConfig.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
-    private long defaultSoftMinEvictableIdleTimeMillis =
-            BaseObjectPoolConfig.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
-    private boolean defaultTestOnCreate =
-            BaseObjectPoolConfig.DEFAULT_TEST_ON_CREATE;
-    private boolean defaultTestOnBorrow =
-            BaseObjectPoolConfig.DEFAULT_TEST_ON_BORROW;
-    private boolean defaultTestOnReturn =
-            BaseObjectPoolConfig.DEFAULT_TEST_ON_RETURN;
-    private boolean defaultTestWhileIdle =
-            BaseObjectPoolConfig.DEFAULT_TEST_WHILE_IDLE;
-    private long defaultTimeBetweenEvictionRunsMillis =
-            BaseObjectPoolConfig.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
+    private int defaultMaxIdle = GenericKeyedObjectPoolConfig.DEFAULT_MAX_IDLE_PER_KEY;
+    private int defaultMaxTotal = GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL;
+    private long defaultMaxWaitMillis = BaseObjectPoolConfig.DEFAULT_MAX_WAIT_MILLIS;
+    private long defaultMinEvictableIdleTimeMillis = BaseObjectPoolConfig.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
+    private int defaultMinIdle = GenericKeyedObjectPoolConfig.DEFAULT_MIN_IDLE_PER_KEY;
+    private int defaultNumTestsPerEvictionRun = BaseObjectPoolConfig.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
+    private long defaultSoftMinEvictableIdleTimeMillis = BaseObjectPoolConfig.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
+    private boolean defaultTestOnCreate = BaseObjectPoolConfig.DEFAULT_TEST_ON_CREATE;
+    private boolean defaultTestOnBorrow = BaseObjectPoolConfig.DEFAULT_TEST_ON_BORROW;
+    private boolean defaultTestOnReturn = BaseObjectPoolConfig.DEFAULT_TEST_ON_RETURN;
+    private boolean defaultTestWhileIdle = BaseObjectPoolConfig.DEFAULT_TEST_WHILE_IDLE;
+    private long defaultTimeBetweenEvictionRunsMillis = BaseObjectPoolConfig.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
 
     // Connection factory properties
-    private String validationQuery = null;
-    private int validationQueryTimeout = -1;
-    private boolean rollbackAfterValidation = false;
+    private String validationQuery;
+    private int validationQueryTimeoutSeconds = -1;
+    private boolean rollbackAfterValidation;
     private long maxConnLifetimeMillis = -1;
 
     // Connection properties
-    private Boolean defaultAutoCommit = null;
+    private Boolean defaultAutoCommit;
     private int defaultTransactionIsolation = UNKNOWN_TRANSACTIONISOLATION;
-    private Boolean defaultReadOnly = null;
-
+    private Boolean defaultReadOnly;
 
     /**
      * Default no-arg constructor for Serialization
@@ -173,18 +145,16 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Throws an IllegalStateException, if a PooledConnection has already
-     * been requested.
+     * Throws an IllegalStateException, if a PooledConnection has already been requested.
      */
-    protected void assertInitializationAllowed()
-        throws IllegalStateException {
+    protected void assertInitializationAllowed() throws IllegalStateException {
         if (getConnectionCalled) {
             throw new IllegalStateException(GET_CONNECTION_CALLED);
         }
     }
 
     /**
-     * Close the connection pool being maintained by this datasource.
+     * Closes the connection pool being maintained by this datasource.
      */
     @Override
     public abstract void close() throws Exception;
@@ -208,24 +178,25 @@ public abstract class InstanceKeyDataSource
         throw new SQLFeatureNotSupportedException();
     }
 
-
     // -------------------------------------------------------------------
     // Properties
 
     /**
-     * @return the default value for
-     * {@link GenericKeyedObjectPoolConfig#getBlockWhenExhausted()} for each per
-     * user pool.
+     * Gets the default value for {@link GenericKeyedObjectPoolConfig#getBlockWhenExhausted()} for each per user pool.
+     *
+     * @return The default value for {@link GenericKeyedObjectPoolConfig#getBlockWhenExhausted()} for each per user
+     *         pool.
      */
     public boolean getDefaultBlockWhenExhausted() {
         return this.defaultBlockWhenExhausted;
     }
 
     /**
-     * Sets the default value for
-     * {@link GenericKeyedObjectPoolConfig#getBlockWhenExhausted()} for each per
-     * user pool.
-     * @param blockWhenExhausted The new value
+     * Sets the default value for {@link GenericKeyedObjectPoolConfig#getBlockWhenExhausted()} for each per user pool.
+     *
+     * @param blockWhenExhausted
+     *            The default value for {@link GenericKeyedObjectPoolConfig#getBlockWhenExhausted()} for each per user
+     *            pool.
      */
     public void setDefaultBlockWhenExhausted(final boolean blockWhenExhausted) {
         assertInitializationAllowed();
@@ -233,38 +204,43 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * @return the default value for
-     * {@link GenericKeyedObjectPoolConfig#getEvictionPolicyClassName()} for
-     * each per user pool.
+     * Gets the default value for {@link GenericKeyedObjectPoolConfig#getEvictionPolicyClassName()} for each per user
+     * pool.
+     *
+     * @return The default value for {@link GenericKeyedObjectPoolConfig#getEvictionPolicyClassName()} for each per user
+     *         pool.
      */
     public String getDefaultEvictionPolicyClassName() {
         return this.defaultEvictionPolicyClassName;
     }
 
     /**
-     * Sets the default value for
-     * {@link GenericKeyedObjectPoolConfig#getEvictionPolicyClassName()} for
-     * each per user pool.
-     * @param evictionPolicyClassName The new value
+     * Sets the default value for {@link GenericKeyedObjectPoolConfig#getEvictionPolicyClassName()} for each per user
+     * pool.
+     *
+     * @param evictionPolicyClassName
+     *            The default value for {@link GenericKeyedObjectPoolConfig#getEvictionPolicyClassName()} for each per
+     *            user pool.
      */
-    public void setDefaultEvictionPolicyClassName(
-            final String evictionPolicyClassName) {
+    public void setDefaultEvictionPolicyClassName(final String evictionPolicyClassName) {
         assertInitializationAllowed();
         this.defaultEvictionPolicyClassName = evictionPolicyClassName;
     }
 
     /**
-     * @return the default value for
-     * {@link GenericKeyedObjectPoolConfig#getLifo()} for each per user pool.
+     * Gets the default value for {@link GenericKeyedObjectPoolConfig#getLifo()} for each per user pool.
+     *
+     * @return The default value for {@link GenericKeyedObjectPoolConfig#getLifo()} for each per user pool.
      */
     public boolean getDefaultLifo() {
         return this.defaultLifo;
     }
 
     /**
-     * Sets the default value for
-     * {@link GenericKeyedObjectPoolConfig#getLifo()} for each per user pool.
-     * @param lifo The new value
+     * Sets the default value for {@link GenericKeyedObjectPoolConfig#getLifo()} for each per user pool.
+     *
+     * @param lifo
+     *            The default value for {@link GenericKeyedObjectPoolConfig#getLifo()} for each per user pool.
      */
     public void setDefaultLifo(final boolean lifo) {
         assertInitializationAllowed();
@@ -272,19 +248,19 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * @return the default value for
-     * {@link GenericKeyedObjectPoolConfig#getMaxIdlePerKey()} for each per user
-     * pool.
+     * Gets the default value for {@link GenericKeyedObjectPoolConfig#getMaxIdlePerKey()} for each per user pool.
+     *
+     * @return The default value for {@link GenericKeyedObjectPoolConfig#getMaxIdlePerKey()} for each per user pool.
      */
     public int getDefaultMaxIdle() {
         return this.defaultMaxIdle;
     }
 
     /**
-     * Sets the default value for
-     * {@link GenericKeyedObjectPoolConfig#getMaxIdlePerKey()} for each per user
-     * pool.
-     * @param maxIdle The new value
+     * Sets the default value for {@link GenericKeyedObjectPoolConfig#getMaxIdlePerKey()} for each per user pool.
+     *
+     * @param maxIdle
+     *            The default value for {@link GenericKeyedObjectPoolConfig#getMaxIdlePerKey()} for each per user pool.
      */
     public void setDefaultMaxIdle(final int maxIdle) {
         assertInitializationAllowed();
@@ -292,19 +268,19 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * @return the default value for
-     * {@link GenericKeyedObjectPoolConfig#getMaxTotalPerKey()} for each per
-     * user pool.
+     * Gets the default value for {@link GenericKeyedObjectPoolConfig#getMaxTotalPerKey()} for each per user pool.
+     *
+     * @return The default value for {@link GenericKeyedObjectPoolConfig#getMaxTotalPerKey()} for each per user pool.
      */
     public int getDefaultMaxTotal() {
         return this.defaultMaxTotal;
     }
 
     /**
-     * Sets the default value for
-     * {@link GenericKeyedObjectPoolConfig#getMaxTotalPerKey()} for each per
-     * user pool.
-     * @param maxTotal The new value
+     * Sets the default value for {@link GenericKeyedObjectPoolConfig#getMaxTotalPerKey()} for each per user pool.
+     *
+     * @param maxTotal
+     *            The default value for {@link GenericKeyedObjectPoolConfig#getMaxTotalPerKey()} for each per user pool.
      */
     public void setDefaultMaxTotal(final int maxTotal) {
         assertInitializationAllowed();
@@ -312,19 +288,19 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * @return the default value for
-     * {@link GenericKeyedObjectPoolConfig#getMaxWaitMillis()} for each per user
-     * pool.
+     * Gets the default value for {@link GenericKeyedObjectPoolConfig#getMaxWaitMillis()} for each per user pool.
+     *
+     * @return The default value for {@link GenericKeyedObjectPoolConfig#getMaxWaitMillis()} for each per user pool.
      */
     public long getDefaultMaxWaitMillis() {
         return this.defaultMaxWaitMillis;
     }
 
     /**
-     * Sets the default value for
-     * {@link GenericKeyedObjectPoolConfig#getMaxWaitMillis()} for each per user
-     * pool.
-     * @param maxWaitMillis The new value
+     * Sets the default value for {@link GenericKeyedObjectPoolConfig#getMaxWaitMillis()} for each per user pool.
+     *
+     * @param maxWaitMillis
+     *            The default value for {@link GenericKeyedObjectPoolConfig#getMaxWaitMillis()} for each per user pool.
      */
     public void setDefaultMaxWaitMillis(final long maxWaitMillis) {
         assertInitializationAllowed();
@@ -332,40 +308,43 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * @return the default value for
-     * {@link GenericKeyedObjectPoolConfig#getMinEvictableIdleTimeMillis()} for
-     * each per user pool.
+     * Gets the default value for {@link GenericKeyedObjectPoolConfig#getMinEvictableIdleTimeMillis()} for each per user
+     * pool.
+     *
+     * @return The default value for {@link GenericKeyedObjectPoolConfig#getMinEvictableIdleTimeMillis()} for each per
+     *         user pool.
      */
     public long getDefaultMinEvictableIdleTimeMillis() {
         return this.defaultMinEvictableIdleTimeMillis;
     }
 
     /**
-     * Sets the default value for
-     * {@link GenericKeyedObjectPoolConfig#getMinEvictableIdleTimeMillis()} for
-     * each per user pool.
-     * @param minEvictableIdleTimeMillis The new value
+     * Sets the default value for {@link GenericKeyedObjectPoolConfig#getMinEvictableIdleTimeMillis()} for each per user
+     * pool.
+     *
+     * @param minEvictableIdleTimeMillis
+     *            The default value for {@link GenericKeyedObjectPoolConfig#getMinEvictableIdleTimeMillis()} for each
+     *            per user pool.
      */
-    public void setDefaultMinEvictableIdleTimeMillis(
-            final long minEvictableIdleTimeMillis) {
+    public void setDefaultMinEvictableIdleTimeMillis(final long minEvictableIdleTimeMillis) {
         assertInitializationAllowed();
         this.defaultMinEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
     }
 
     /**
-     * @return the default value for
-     * {@link GenericKeyedObjectPoolConfig#getMinIdlePerKey()} for each per user
-     * pool.
+     * Gets the default value for {@link GenericKeyedObjectPoolConfig#getMinIdlePerKey()} for each per user pool.
+     *
+     * @return The default value for {@link GenericKeyedObjectPoolConfig#getMinIdlePerKey()} for each per user pool.
      */
     public int getDefaultMinIdle() {
         return this.defaultMinIdle;
     }
 
     /**
-     * Sets the default value for
-     * {@link GenericKeyedObjectPoolConfig#getMinIdlePerKey()} for each per user
-     * pool.
-     * @param minIdle The new value
+     * Sets the default value for {@link GenericKeyedObjectPoolConfig#getMinIdlePerKey()} for each per user pool.
+     *
+     * @param minIdle
+     *            The default value for {@link GenericKeyedObjectPoolConfig#getMinIdlePerKey()} for each per user pool.
      */
     public void setDefaultMinIdle(final int minIdle) {
         assertInitializationAllowed();
@@ -373,19 +352,23 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * @return the default value for
-     * {@link GenericKeyedObjectPoolConfig#getNumTestsPerEvictionRun()} for each
-     * per user pool.
+     * Gets the default value for {@link GenericKeyedObjectPoolConfig#getNumTestsPerEvictionRun()} for each per user
+     * pool.
+     *
+     * @return The default value for {@link GenericKeyedObjectPoolConfig#getNumTestsPerEvictionRun()} for each per user
+     *         pool.
      */
     public int getDefaultNumTestsPerEvictionRun() {
         return this.defaultNumTestsPerEvictionRun;
     }
 
     /**
-     * Sets the default value for
-     * {@link GenericKeyedObjectPoolConfig#getNumTestsPerEvictionRun()} for each
-     * per user pool.
-     * @param numTestsPerEvictionRun The new value
+     * Sets the default value for {@link GenericKeyedObjectPoolConfig#getNumTestsPerEvictionRun()} for each per user
+     * pool.
+     *
+     * @param numTestsPerEvictionRun
+     *            The default value for {@link GenericKeyedObjectPoolConfig#getNumTestsPerEvictionRun()} for each per
+     *            user pool.
      */
     public void setDefaultNumTestsPerEvictionRun(final int numTestsPerEvictionRun) {
         assertInitializationAllowed();
@@ -393,37 +376,47 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * @return the default value for
-     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getSoftMinEvictableIdleTimeMillis()} for each
-     * per user pool.
+     * Gets the default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     * GenericObjectPool#getSoftMinEvictableIdleTimeMillis()} for each per user pool.
+     *
+     * @return The default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     *         GenericObjectPool#getSoftMinEvictableIdleTimeMillis()} for each per user pool.
      */
     public long getDefaultSoftMinEvictableIdleTimeMillis() {
         return this.defaultSoftMinEvictableIdleTimeMillis;
     }
 
     /**
-     * Sets the default value for
-     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getSoftMinEvictableIdleTimeMillis()} for each per user pool.
-     * @param softMinEvictableIdleTimeMillis The new value
+     * Sets the default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     * GenericObjectPool#getSoftMinEvictableIdleTimeMillis()} for each per user pool.
+     *
+     * @param softMinEvictableIdleTimeMillis
+     *            The default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     *            GenericObjectPool#getSoftMinEvictableIdleTimeMillis()} for each per user pool.
      */
-    public void setDefaultSoftMinEvictableIdleTimeMillis(
-            final long softMinEvictableIdleTimeMillis) {
+    public void setDefaultSoftMinEvictableIdleTimeMillis(final long softMinEvictableIdleTimeMillis) {
         assertInitializationAllowed();
         this.defaultSoftMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
     }
 
     /**
-     * @return the default value for
-     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestOnCreate()} for each per user pool.
+     * Gets the default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     * GenericObjectPool#getTestOnCreate()} for each per user pool.
+     *
+     * @return The default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     *         GenericObjectPool#getTestOnCreate()} for each per user pool.
      */
     public boolean getDefaultTestOnCreate() {
         return this.defaultTestOnCreate;
     }
 
     /**
-     * Sets the default value for
-     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestOnCreate()} for each per user pool.
-     * @param testOnCreate The new value
+     * Sets the default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     * GenericObjectPool#getTestOnCreate()} for each per user pool.
+     *
+     * @param testOnCreate
+     *            The default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     *            GenericObjectPool#getTestOnCreate()} for each per user pool.
      */
     public void setDefaultTestOnCreate(final boolean testOnCreate) {
         assertInitializationAllowed();
@@ -431,17 +424,23 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * @return the default value for
-     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestOnBorrow()} for each per user pool.
+     * Gets the default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     * GenericObjectPool#getTestOnBorrow()} for each per user pool.
+     *
+     * @return The default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     *         GenericObjectPool#getTestOnBorrow()} for each per user pool.
      */
     public boolean getDefaultTestOnBorrow() {
         return this.defaultTestOnBorrow;
     }
 
     /**
-     * Sets the default value for
-     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestOnBorrow()} for each per user pool.
-     * @param testOnBorrow The new value
+     * Sets the default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     * GenericObjectPool#getTestOnBorrow()} for each per user pool.
+     *
+     * @param testOnBorrow
+     *            The default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     *            GenericObjectPool#getTestOnBorrow()} for each per user pool.
      */
     public void setDefaultTestOnBorrow(final boolean testOnBorrow) {
         assertInitializationAllowed();
@@ -449,17 +448,23 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * @return the default value for
-     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestOnReturn()} for each per user pool.
+     * Gets the default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     * GenericObjectPool#getTestOnReturn()} for each per user pool.
+     *
+     * @return The default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     *         GenericObjectPool#getTestOnReturn()} for each per user pool.
      */
     public boolean getDefaultTestOnReturn() {
         return this.defaultTestOnReturn;
     }
 
     /**
-     * Sets the default value for
-     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestOnReturn()} for each per user pool.
-     * @param testOnReturn The new value
+     * Sets the default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     * GenericObjectPool#getTestOnReturn()} for each per user pool.
+     *
+     * @param testOnReturn
+     *            The default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     *            GenericObjectPool#getTestOnReturn()} for each per user pool.
      */
     public void setDefaultTestOnReturn(final boolean testOnReturn) {
         assertInitializationAllowed();
@@ -467,17 +472,23 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * @return the default value for
-     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestWhileIdle()} for each per user pool.
+     * Gets the default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     * GenericObjectPool#getTestWhileIdle()} for each per user pool.
+     *
+     * @return The default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     *         GenericObjectPool#getTestWhileIdle()} for each per user pool.
      */
     public boolean getDefaultTestWhileIdle() {
         return this.defaultTestWhileIdle;
     }
 
     /**
-     * Sets the default value for
-     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTestWhileIdle()} for each per user pool.
-     * @param testWhileIdle The new value
+     * Sets the default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     * GenericObjectPool#getTestWhileIdle()} for each per user pool.
+     *
+     * @param testWhileIdle
+     *            The default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     *            GenericObjectPool#getTestWhileIdle()} for each per user pool.
      */
     public void setDefaultTestWhileIdle(final boolean testWhileIdle) {
         assertInitializationAllowed();
@@ -485,29 +496,32 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * @return the default value for
-     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTimeBetweenEvictionRunsMillis ()} for each
-     * per user pool.
+     * Gets the default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     * GenericObjectPool#getTimeBetweenEvictionRunsMillis ()} for each per user pool.
+     *
+     * @return The default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     *         GenericObjectPool#getTimeBetweenEvictionRunsMillis ()} for each per user pool.
      */
-    public long getDefaultTimeBetweenEvictionRunsMillis () {
-        return this.defaultTimeBetweenEvictionRunsMillis ;
+    public long getDefaultTimeBetweenEvictionRunsMillis() {
+        return this.defaultTimeBetweenEvictionRunsMillis;
     }
 
     /**
-     * Sets the default value for
-     * {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool GenericObjectPool#getTimeBetweenEvictionRunsMillis ()} for each
-     * per user pool.
-     * @param timeBetweenEvictionRunsMillis The new value
+     * Sets the default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     * GenericObjectPool#getTimeBetweenEvictionRunsMillis ()} for each per user pool.
+     *
+     * @param timeBetweenEvictionRunsMillis
+     *            The default value for {@link org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool
+     *            GenericObjectPool#getTimeBetweenEvictionRunsMillis ()} for each per user pool.
      */
-    public void setDefaultTimeBetweenEvictionRunsMillis (
-            final long timeBetweenEvictionRunsMillis ) {
+    public void setDefaultTimeBetweenEvictionRunsMillis(final long timeBetweenEvictionRunsMillis) {
         assertInitializationAllowed();
-        this.defaultTimeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis ;
+        this.defaultTimeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
     }
 
     /**
-     * Get the value of connectionPoolDataSource.  This method will return
-     * null, if the backing datasource is being accessed via jndi.
+     * Gets the value of connectionPoolDataSource. This method will return null, if the backing datasource is being
+     * accessed via jndi.
      *
      * @return value of connectionPoolDataSource.
      */
@@ -516,30 +530,27 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Set the backend ConnectionPoolDataSource.  This property should not be
-     * set if using jndi to access the datasource.
+     * Sets the backend ConnectionPoolDataSource. This property should not be set if using jndi to access the
+     * datasource.
      *
-     * @param v  Value to assign to connectionPoolDataSource.
+     * @param v
+     *            Value to assign to connectionPoolDataSource.
      */
     public void setConnectionPoolDataSource(final ConnectionPoolDataSource v) {
         assertInitializationAllowed();
         if (dataSourceName != null) {
-            throw new IllegalStateException(
-                "Cannot set the DataSource, if JNDI is used.");
+            throw new IllegalStateException("Cannot set the DataSource, if JNDI is used.");
         }
-        if (dataSource != null)
-        {
-            throw new IllegalStateException(
-                "The CPDS has already been set. It cannot be altered.");
+        if (dataSource != null) {
+            throw new IllegalStateException("The CPDS has already been set. It cannot be altered.");
         }
         dataSource = v;
         instanceKey = InstanceKeyDataSourceFactory.registerNewInstance(this);
     }
 
     /**
-     * Get the name of the ConnectionPoolDataSource which backs this pool.
-     * This name is used to look up the datasource from a jndi service
-     * provider.
+     * Gets the name of the ConnectionPoolDataSource which backs this pool. This name is used to look up the datasource
+     * from a jndi service provider.
      *
      * @return value of dataSourceName.
      */
@@ -548,35 +559,29 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Set the name of the ConnectionPoolDataSource which backs this pool.
-     * This name is used to look up the datasource from a jndi service
-     * provider.
+     * Sets the name of the ConnectionPoolDataSource which backs this pool. This name is used to look up the datasource
+     * from a jndi service provider.
      *
-     * @param v  Value to assign to dataSourceName.
+     * @param v
+     *            Value to assign to dataSourceName.
      */
     public void setDataSourceName(final String v) {
         assertInitializationAllowed();
         if (dataSource != null) {
-            throw new IllegalStateException(
-                "Cannot set the JNDI name for the DataSource, if already " +
-                "set using setConnectionPoolDataSource.");
+            throw new IllegalStateException("Cannot set the JNDI name for the DataSource, if already "
+                    + "set using setConnectionPoolDataSource.");
         }
-        if (dataSourceName != null)
-        {
-            throw new IllegalStateException(
-                "The DataSourceName has already been set. " +
-                "It cannot be altered.");
+        if (dataSourceName != null) {
+            throw new IllegalStateException("The DataSourceName has already been set. " + "It cannot be altered.");
         }
         this.dataSourceName = v;
         instanceKey = InstanceKeyDataSourceFactory.registerNewInstance(this);
     }
 
     /**
-     * Get the value of defaultAutoCommit, which defines the state of
-     * connections handed out from this pool.  The value can be changed
-     * on the Connection using Connection.setAutoCommit(boolean).
-     * The default is <code>null</code> which will use the default value for the
-     * drive.
+     * Gets the value of defaultAutoCommit, which defines the state of connections handed out from this pool. The value
+     * can be changed on the Connection using Connection.setAutoCommit(boolean). The default is <code>null</code> which
+     * will use the default value for the drive.
      *
      * @return value of defaultAutoCommit.
      */
@@ -585,13 +590,12 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Set the value of defaultAutoCommit, which defines the state of
-     * connections handed out from this pool.  The value can be changed
-     * on the Connection using Connection.setAutoCommit(boolean).
-     * The default is <code>null</code> which will use the default value for the
-     * drive.
+     * Sets the value of defaultAutoCommit, which defines the state of connections handed out from this pool. The value
+     * can be changed on the Connection using Connection.setAutoCommit(boolean). The default is <code>null</code> which
+     * will use the default value for the drive.
      *
-     * @param v  Value to assign to defaultAutoCommit.
+     * @param v
+     *            Value to assign to defaultAutoCommit.
      */
     public void setDefaultAutoCommit(final Boolean v) {
         assertInitializationAllowed();
@@ -599,11 +603,9 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Get the value of defaultReadOnly, which defines the state of
-     * connections handed out from this pool.  The value can be changed
-     * on the Connection using Connection.setReadOnly(boolean).
-     * The default is <code>null</code> which will use the default value for the
-     * drive.
+     * Gets the value of defaultReadOnly, which defines the state of connections handed out from this pool. The value
+     * can be changed on the Connection using Connection.setReadOnly(boolean). The default is <code>null</code> which
+     * will use the default value for the drive.
      *
      * @return value of defaultReadOnly.
      */
@@ -612,13 +614,12 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Set the value of defaultReadOnly, which defines the state of
-     * connections handed out from this pool.  The value can be changed
-     * on the Connection using Connection.setReadOnly(boolean).
-     * The default is <code>null</code> which will use the default value for the
-     * drive.
+     * Sets the value of defaultReadOnly, which defines the state of connections handed out from this pool. The value
+     * can be changed on the Connection using Connection.setReadOnly(boolean). The default is <code>null</code> which
+     * will use the default value for the drive.
      *
-     * @param v  Value to assign to defaultReadOnly.
+     * @param v
+     *            Value to assign to defaultReadOnly.
      */
     public void setDefaultReadOnly(final Boolean v) {
         assertInitializationAllowed();
@@ -626,10 +627,9 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Get the value of defaultTransactionIsolation, which defines the state of
-     * connections handed out from this pool.  The value can be changed
-     * on the Connection using Connection.setTransactionIsolation(int).
-     * If this method returns -1, the default is JDBC driver dependent.
+     * Gets the value of defaultTransactionIsolation, which defines the state of connections handed out from this pool.
+     * The value can be changed on the Connection using Connection.setTransactionIsolation(int). If this method returns
+     * -1, the default is JDBC driver dependent.
      *
      * @return value of defaultTransactionIsolation.
      */
@@ -638,12 +638,12 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Set the value of defaultTransactionIsolation, which defines the state of
-     * connections handed out from this pool.  The value can be changed
-     * on the Connection using Connection.setTransactionIsolation(int).
-     * The default is JDBC driver dependent.
+     * Sets the value of defaultTransactionIsolation, which defines the state of connections handed out from this pool.
+     * The value can be changed on the Connection using Connection.setTransactionIsolation(int). The default is JDBC
+     * driver dependent.
      *
-     * @param v  Value to assign to defaultTransactionIsolation
+     * @param v
+     *            Value to assign to defaultTransactionIsolation
      */
     public void setDefaultTransactionIsolation(final int v) {
         assertInitializationAllowed();
@@ -661,9 +661,8 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Get the description.  This property is defined by JDBC as for use with
-     * GUI (or other) tools that might deploy the datasource.  It serves no
-     * internal purpose.
+     * Gets the description. This property is defined by JDBC as for use with GUI (or other) tools that might deploy the
+     * datasource. It serves no internal purpose.
      *
      * @return value of description.
      */
@@ -672,11 +671,11 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Set the description.  This property is defined by JDBC as for use with
-     * GUI (or other) tools that might deploy the datasource.  It serves no
-     * internal purpose.
+     * Sets the description. This property is defined by JDBC as for use with GUI (or other) tools that might deploy the
+     * datasource. It serves no internal purpose.
      *
-     * @param v  Value to assign to description.
+     * @param v
+     *            Value to assign to description.
      */
     public void setDescription(final String v) {
         this.description = v;
@@ -687,10 +686,11 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Get the value of jndiEnvironment which is used when instantiating
-     * a jndi InitialContext.  This InitialContext is used to locate the
-     * backend ConnectionPoolDataSource.
-     * @param key The environment property name
+     * Gets the value of jndiEnvironment which is used when instantiating a JNDI InitialContext. This InitialContext is
+     * used to locate the backend ConnectionPoolDataSource.
+     *
+     * @param key
+     *            JNDI environment key.
      * @return value of jndiEnvironment.
      */
     public String getJndiEnvironment(final String key) {
@@ -702,12 +702,13 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Sets the value of the given JNDI environment property to be used when
-     * instantiating a JNDI InitialContext. This InitialContext is used to
-     * locate the backend ConnectionPoolDataSource.
+     * Sets the value of the given JNDI environment property to be used when instantiating a JNDI InitialContext. This
+     * InitialContext is used to locate the backend ConnectionPoolDataSource.
      *
-     * @param key the JNDI environment property to set.
-     * @param value the value assigned to specified JNDI environment property.
+     * @param key
+     *            the JNDI environment property to set.
+     * @param value
+     *            the value assigned to specified JNDI environment property.
      */
     public void setJndiEnvironment(final String key, final String value) {
         if (jndiEnvironment == null) {
@@ -717,12 +718,11 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Sets the JNDI environment to be used when instantiating a JNDI
-     * InitialContext. This InitialContext is used to locate the backend
-     * ConnectionPoolDataSource.
+     * Sets the JNDI environment to be used when instantiating a JNDI InitialContext. This InitialContext is used to
+     * locate the backend ConnectionPoolDataSource.
      *
-     * @param properties the JNDI environment property to set which will
-     *                   overwrite any current settings
+     * @param properties
+     *            the JNDI environment property to set which will overwrite any current settings
      */
     void setJndiEnvironment(final Properties properties) {
         if (jndiEnvironment == null) {
@@ -734,7 +734,8 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Get the value of loginTimeout.
+     * Gets the value of loginTimeout.
+     *
      * @return value of loginTimeout.
      */
     @Override
@@ -743,8 +744,10 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Set the value of loginTimeout.
-     * @param v  Value to assign to loginTimeout.
+     * Sets the value of loginTimeout.
+     *
+     * @param v
+     *            Value to assign to loginTimeout.
      */
     @Override
     public void setLoginTimeout(final int v) {
@@ -752,21 +755,23 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Get the value of logWriter.
+     * Gets the value of logWriter.
+     *
      * @return value of logWriter.
      */
     @Override
     public PrintWriter getLogWriter() {
         if (logWriter == null) {
-            logWriter = new PrintWriter(
-                    new OutputStreamWriter(System.out, StandardCharsets.UTF_8));
+            logWriter = new PrintWriter(new OutputStreamWriter(System.out, StandardCharsets.UTF_8));
         }
         return logWriter;
     }
 
     /**
-     * Set the value of logWriter.
-     * @param v  Value to assign to logWriter.
+     * Sets the value of logWriter.
+     *
+     * @param v
+     *            Value to assign to logWriter.
      */
     @Override
     public void setLogWriter(final PrintWriter v) {
@@ -774,24 +779,25 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * The SQL query that will be used to validate connections from this pool
-     * before returning them to the caller.  If specified, this query
-     * <strong>MUST</strong> be an SQL SELECT statement that returns at least
-     * one row. If not specified, {@link Connection#isValid(int)} will be used
-     * to validate connections.
-     * @return the validation query
+     * Gets the SQL query that will be used to validate connections from this pool before returning them to the caller.
+     * If specified, this query <strong>MUST</strong> be an SQL SELECT statement that returns at least one row. If not
+     * specified, {@link Connection#isValid(int)} will be used to validate connections.
+     *
+     * @return The SQL query that will be used to validate connections from this pool before returning them to the
+     *         caller.
      */
     public String getValidationQuery() {
         return this.validationQuery;
     }
 
     /**
-     * The SQL query that will be used to validate connections from this pool
-     * before returning them to the caller.  If specified, this query
-     * <strong>MUST</strong> be an SQL SELECT statement that returns at least
-     * one row. If not specified, connections will be validated using
-     * {@link Connection#isValid(int)}.
-     * @param validationQuery The validation query
+     * Sets the SQL query that will be used to validate connections from this pool before returning them to the caller.
+     * If specified, this query <strong>MUST</strong> be an SQL SELECT statement that returns at least one row. If not
+     * specified, connections will be validated using {@link Connection#isValid(int)}.
+     *
+     * @param validationQuery
+     *            The SQL query that will be used to validate connections from this pool before returning them to the
+     *            caller.
      */
     public void setValidationQuery(final String validationQuery) {
         assertInitializationAllowed();
@@ -799,41 +805,41 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * @return the timeout in seconds before the validation query fails.
+     * Returns the timeout in seconds before the validation query fails.
+     *
+     * @return The timeout in seconds before the validation query fails.
      */
     public int getValidationQueryTimeout() {
-        return validationQueryTimeout;
+        return validationQueryTimeoutSeconds;
     }
 
     /**
      * Sets the timeout in seconds before the validation query fails.
      *
-     * @param validationQueryTimeout    The new timeout in seconds
+     * @param validationQueryTimeoutSeconds
+     *            The new timeout in seconds
      */
-    public void setValidationQueryTimeout(final int validationQueryTimeout) {
-        this.validationQueryTimeout = validationQueryTimeout;
+    public void setValidationQueryTimeout(final int validationQueryTimeoutSeconds) {
+        this.validationQueryTimeoutSeconds = validationQueryTimeoutSeconds;
     }
 
     /**
-     * Whether a rollback will be issued after executing the SQL query
-     * that will be used to validate connections from this pool
-     * before returning them to the caller.
+     * Whether a rollback will be issued after executing the SQL query that will be used to validate connections from
+     * this pool before returning them to the caller.
      *
-     * @return true if a rollback will be issued after executing the
-     * validation query
+     * @return true if a rollback will be issued after executing the validation query
      */
     public boolean isRollbackAfterValidation() {
         return this.rollbackAfterValidation;
     }
 
     /**
-     * Whether a rollback will be issued after executing the SQL query
-     * that will be used to validate connections from this pool
-     * before returning them to the caller. Default behavior is NOT
-     * to issue a rollback. The setting will only have an effect
-     * if a validation query is set
+     * Whether a rollback will be issued after executing the SQL query that will be used to validate connections from
+     * this pool before returning them to the caller. Default behavior is NOT to issue a rollback. The setting will only
+     * have an effect if a validation query is set
      *
-     * @param rollbackAfterValidation new property value
+     * @param rollbackAfterValidation
+     *            new property value
      */
     public void setRollbackAfterValidation(final boolean rollbackAfterValidation) {
         assertInitializationAllowed();
@@ -841,22 +847,30 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * @return the maximum permitted lifetime of a connection in milliseconds. A
-     * value of zero or less indicates an infinite lifetime.
+     * Returns the maximum permitted lifetime of a connection in milliseconds. A value of zero or less indicates an
+     * infinite lifetime.
+     *
+     * @return The maximum permitted lifetime of a connection in milliseconds. A value of zero or less indicates an
+     *         infinite lifetime.
      */
     public long getMaxConnLifetimeMillis() {
         return maxConnLifetimeMillis;
     }
 
     /**
-     * <p>Sets the maximum permitted lifetime of a connection in
-     * milliseconds. A value of zero or less indicates an infinite lifetime.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
-     * @param maxConnLifetimeMillis The maximum connection lifetime
+     * Sets the maximum permitted lifetime of a connection in milliseconds. A value of zero or less indicates an
+     * infinite lifetime.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
+     *
+     * @param maxConnLifetimeMillis
+     *            The maximum permitted lifetime of a connection in milliseconds. A value of zero or less indicates an
+     *            infinite lifetime.
      */
     public void setMaxConnLifetimeMillis(final long maxConnLifetimeMillis) {
         this.maxConnLifetimeMillis = maxConnLifetimeMillis;
@@ -869,9 +883,7 @@ public abstract class InstanceKeyDataSource
     // DataSource implementation
 
     /**
-     * Attempt to establish a database connection.
-     * @return the connection
-     * @throws SQLException Connection failed
+     * Attempts to establish a database connection.
      */
     @Override
     public Connection getConnection() throws SQLException {
@@ -879,32 +891,26 @@ public abstract class InstanceKeyDataSource
     }
 
     /**
-     * Attempt to retrieve a database connection using {@link #getPooledConnectionAndInfo(String, String)}
-     * with the provided username and password.  The password on the {@link PooledConnectionAndInfo}
-     * instance returned by <code>getPooledConnectionAndInfo</code> is compared to the <code>password</code>
-     * parameter.  If the comparison fails, a database connection using the supplied username and password
-     * is attempted.  If the connection attempt fails, an SQLException is thrown, indicating that the given password
-     * did not match the password used to create the pooled connection.  If the connection attempt succeeds, this
-     * means that the database password has been changed.  In this case, the <code>PooledConnectionAndInfo</code>
-     * instance retrieved with the old password is destroyed and the <code>getPooledConnectionAndInfo</code> is
-     * repeatedly invoked until a <code>PooledConnectionAndInfo</code> instance with the new password is returned.
-     * @param username The user name to use to connect
-     * @param password The password
-     * @return the connection
-     * @throws SQLException Connection failed
+     * Attempts to retrieve a database connection using {@link #getPooledConnectionAndInfo(String, String)} with the
+     * provided user name and password. The password on the {@link PooledConnectionAndInfo} instance returned by
+     * <code>getPooledConnectionAndInfo</code> is compared to the <code>password</code> parameter. If the comparison
+     * fails, a database connection using the supplied user name and password is attempted. If the connection attempt
+     * fails, an SQLException is thrown, indicating that the given password did not match the password used to create
+     * the pooled connection. If the connection attempt succeeds, this means that the database password has been
+     * changed. In this case, the <code>PooledConnectionAndInfo</code> instance retrieved with the old password is
+     * destroyed and the <code>getPooledConnectionAndInfo</code> is repeatedly invoked until a
+     * <code>PooledConnectionAndInfo</code> instance with the new password is returned.
      */
     @Override
-    public Connection getConnection(final String username, final String password)
-            throws SQLException {
+    public Connection getConnection(final String userName, final String userPassword) throws SQLException {
         if (instanceKey == null) {
             throw new SQLException("Must set the ConnectionPoolDataSource "
-                    + "through setDataSourceName or setConnectionPoolDataSource"
-                    + " before calling getConnection.");
+                    + "through setDataSourceName or setConnectionPoolDataSource" + " before calling getConnection.");
         }
         getConnectionCalled = true;
         PooledConnectionAndInfo info = null;
         try {
-            info = getPooledConnectionAndInfo(username, password);
+            info = getPooledConnectionAndInfo(userName, userPassword);
         } catch (final NoSuchElementException e) {
             closeDueToException(info);
             throw new SQLException("Cannot borrow connection from pool", e);
@@ -919,18 +925,17 @@ public abstract class InstanceKeyDataSource
             throw new SQLException("Cannot borrow connection from pool", e);
         }
 
-        if (!(null == password ? null == info.getPassword()
-                : password.equals(info.getPassword()))) {  // Password on PooledConnectionAndInfo does not match
+        // Password on PooledConnectionAndInfo does not match
+        if (!(null == userPassword ? null == info.getPassword() : userPassword.equals(info.getPassword()))) {
             try { // See if password has changed by attempting connection
-                testCPDS(username, password);
+                testCPDS(userName, userPassword);
             } catch (final SQLException ex) {
                 // Password has not changed, so refuse client, but return connection to the pool
                 closeDueToException(info);
-                throw new SQLException("Given password did not match password used"
-                                       + " to create the PooledConnection.", ex);
-            } catch (final javax.naming.NamingException ne) {
                 throw new SQLException(
-                        "NamingException encountered connecting to database", ne);
+                        "Given password did not match password used" + " to create the PooledConnection.", ex);
+            } catch (final javax.naming.NamingException ne) {
+                throw new SQLException("NamingException encountered connecting to database", ne);
             }
             /*
              * Password must have changed -> destroy connection and keep retrying until we get a new, good one,
@@ -938,12 +943,14 @@ public abstract class InstanceKeyDataSource
              */
             final UserPassKey upkey = info.getUserPassKey();
             final PooledConnectionManager manager = getConnectionManager(upkey);
-            manager.invalidate(info.getPooledConnection()); // Destroy and remove from pool
-            manager.setPassword(upkey.getPassword()); // Reset the password on the factory if using CPDSConnectionFactory
+            // Destroy and remove from pool
+            manager.invalidate(info.getPooledConnection());
+            // Reset the password on the factory if using CPDSConnectionFactory
+            manager.setPassword(upkey.getPassword());
             info = null;
             for (int i = 0; i < 10; i++) { // Bound the number of retries - only needed if bad instances return
                 try {
-                    info = getPooledConnectionAndInfo(username, password);
+                    info = getPooledConnectionAndInfo(userName, userPassword);
                 } catch (final NoSuchElementException e) {
                     closeDueToException(info);
                     throw new SQLException("Cannot borrow connection from pool", e);
@@ -957,7 +964,7 @@ public abstract class InstanceKeyDataSource
                     closeDueToException(info);
                     throw new SQLException("Cannot borrow connection from pool", e);
                 }
-                if (info != null && password != null && password.equals(info.getPassword())) {
+                if (info != null && userPassword != null && userPassword.equals(info.getPassword())) {
                     break;
                 }
                 if (info != null) {
@@ -972,27 +979,23 @@ public abstract class InstanceKeyDataSource
 
         final Connection con = info.getPooledConnection().getConnection();
         try {
-            setupDefaults(con, username);
+            setupDefaults(con, userName);
             con.clearWarnings();
             return con;
         } catch (final SQLException ex) {
             try {
                 con.close();
             } catch (final Exception exc) {
-                getLogWriter().println(
-                     "ignoring exception during close: " + exc);
+                getLogWriter().println("ignoring exception during close: " + exc);
             }
             throw ex;
         }
     }
 
-    protected abstract PooledConnectionAndInfo
-        getPooledConnectionAndInfo(String username, String password)
-        throws SQLException;
-
-    protected abstract void setupDefaults(Connection con, String username)
-        throws SQLException;
+    protected abstract PooledConnectionAndInfo getPooledConnectionAndInfo(String userName, String userPassword)
+            throws SQLException;
 
+    protected abstract void setupDefaults(Connection connection, String userName) throws SQLException;
 
     private void closeDueToException(final PooledConnectionAndInfo info) {
         if (info != null) {
@@ -1000,17 +1003,16 @@ public abstract class InstanceKeyDataSource
                 info.getPooledConnection().getConnection().close();
             } catch (final Exception e) {
                 // do not throw this exception because we are in the middle
-                // of handling another exception.  But record it because
+                // of handling another exception. But record it because
                 // it potentially leaks connections from the pool.
-                getLogWriter().println("[ERROR] Could not return connection to "
-                    + "pool during exception handling. " + e.getMessage());
+                getLogWriter().println("[ERROR] Could not return connection to " + "pool during exception handling. "
+                        + e.getMessage());
             }
         }
     }
 
-    protected ConnectionPoolDataSource
-        testCPDS(final String username, final String password)
-        throws javax.naming.NamingException, SQLException {
+    protected ConnectionPoolDataSource testCPDS(final String userName, final String userPassword)
+            throws javax.naming.NamingException, SQLException {
         // The source of physical db connections
         ConnectionPoolDataSource cpds = this.dataSource;
         if (cpds == null) {
@@ -1024,33 +1026,27 @@ public abstract class InstanceKeyDataSource
             if (ds instanceof ConnectionPoolDataSource) {
                 cpds = (ConnectionPoolDataSource) ds;
             } else {
-                throw new SQLException("Illegal configuration: "
-                    + "DataSource " + dataSourceName
-                    + " (" + ds.getClass().getName() + ")"
-                    + " doesn't implement javax.sql.ConnectionPoolDataSource");
+                throw new SQLException("Illegal configuration: " + "DataSource " + dataSourceName + " ("
+                        + ds.getClass().getName() + ")" + " doesn't implement javax.sql.ConnectionPoolDataSource");
             }
         }
 
-        // try to get a connection with the supplied username/password
+        // try to get a connection with the supplied userName/password
         PooledConnection conn = null;
         try {
-            if (username != null) {
-                conn = cpds.getPooledConnection(username, password);
-            }
-            else {
+            if (userName != null) {
+                conn = cpds.getPooledConnection(userName, userPassword);
+            } else {
                 conn = cpds.getPooledConnection();
             }
             if (conn == null) {
-                throw new SQLException(
-                    "Cannot connect using the supplied username/password");
+                throw new SQLException("Cannot connect using the supplied userName/password");
             }
-        }
-        finally {
+        } finally {
             if (conn != null) {
                 try {
                     conn.close();
-                }
-                catch (final SQLException e) {
+                } catch (final SQLException e) {
                     // at least we could connect
                 }
             }

==================================================
KeyedCPDSConnectionFactory.java
index 393eeae1ea..1c60838c85 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/datasources/InstanceKeyDataSourceFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/InstanceKeyDataSourceFactory.java
@@ -19,8 +19,10 @@ package org.apache.tomcat.dbcp.dbcp2.datasources;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.ObjectInputStream;
+import java.util.ArrayList;
 import java.util.Hashtable;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Properties;
@@ -32,22 +34,22 @@ import javax.naming.RefAddr;
 import javax.naming.Reference;
 import javax.naming.spi.ObjectFactory;
 
+import org.apache.tomcat.dbcp.dbcp2.ListException;
+
 /**
- * A JNDI ObjectFactory which creates <code>SharedPoolDataSource</code>s
- * or <code>PerUserPoolDataSource</code>s
+ * A JNDI ObjectFactory which creates <code>SharedPoolDataSource</code>s or <code>PerUserPoolDataSource</code>s
  *
  * @since 2.0
  */
 abstract class InstanceKeyDataSourceFactory implements ObjectFactory {
 
-    private static final Map<String, InstanceKeyDataSource> instanceMap =
-            new ConcurrentHashMap<>();
+    private static final Map<String, InstanceKeyDataSource> instanceMap = new ConcurrentHashMap<>();
 
     static synchronized String registerNewInstance(final InstanceKeyDataSource ds) {
         int max = 0;
-        final Iterator<String> i = instanceMap.keySet().iterator();
-        while (i.hasNext()) {
-            final String s = i.next();
+        final Iterator<String> iterator = instanceMap.keySet().iterator();
+        while (iterator.hasNext()) {
+            final String s = iterator.next();
             if (s != null) {
                 try {
                     max = Math.max(max, Integer.parseInt(s));
@@ -57,8 +59,8 @@ abstract class InstanceKeyDataSourceFactory implements ObjectFactory {
             }
         }
         final String instanceKey = String.valueOf(max + 1);
-        // put a placeholder here for now, so other instances will not
-        // take our key.  we will replace with a pool when ready.
+        // Put a placeholder here for now, so other instances will not
+        // take our key. We will replace with a pool when ready.
         instanceMap.put(instanceKey, ds);
         return instanceKey;
     }
@@ -70,57 +72,70 @@ abstract class InstanceKeyDataSourceFactory implements ObjectFactory {
     }
 
     /**
-     * Close all pools associated with this class.
-     * @throws Exception Close exception
+     * Closes all pools associated with this class.
+     *
+     * @throws Exception
+     *             a {@link ListException} containing all exceptions thrown by {@link InstanceKeyDataSource#close()}
+     * @see InstanceKeyDataSource#close()
+     * @see ListException
+     * @since 2.4.0 throws a {@link ListException} instead of, in 2.3.0 and before, the first exception thrown by
+     *        {@link InstanceKeyDataSource#close()}.
      */
     public static void closeAll() throws Exception {
-        //Get iterator to loop over all instances of this datasource.
-        final Iterator<Entry<String,InstanceKeyDataSource>> instanceIterator =
-            instanceMap.entrySet().iterator();
+        // Get iterator to loop over all instances of this data source.
+        final List<Throwable> exceptionList = new ArrayList<>(instanceMap.size());
+        final Iterator<Entry<String, InstanceKeyDataSource>> instanceIterator = instanceMap.entrySet().iterator();
         while (instanceIterator.hasNext()) {
-            instanceIterator.next().getValue().close();
+            // Bullet-proof to avoid anything else but problems from InstanceKeyDataSource#close().
+            final Entry<String, InstanceKeyDataSource> next = instanceIterator.next();
+            if (next != null) {
+                @SuppressWarnings("resource")
+                final InstanceKeyDataSource value = next.getValue();
+                if (value != null) {
+                    try {
+                        value.close();
+                    } catch (final Exception e) {
+                        exceptionList.add(e);
+                    }
+                }
+            }
         }
         instanceMap.clear();
+        if (!exceptionList.isEmpty()) {
+            throw new ListException("Could not close all InstanceKeyDataSource instances.", exceptionList);
+        }
     }
 
-
     /**
-     * Implements ObjectFactory to create an instance of SharedPoolDataSource
-     * or PerUserPoolDataSource.
+     * Implements ObjectFactory to create an instance of SharedPoolDataSource or PerUserPoolDataSource
      */
     @Override
-    public Object getObjectInstance(final Object refObj, final Name name,
-                                    final Context context, final Hashtable<?,?> env)
-        throws IOException, ClassNotFoundException {
+    public Object getObjectInstance(final Object refObj, final Name name, final Context context,
+            final Hashtable<?, ?> env) throws IOException, ClassNotFoundException {
         // The spec says to return null if we can't create an instance
         // of the reference
         Object obj = null;
         if (refObj instanceof Reference) {
             final Reference ref = (Reference) refObj;
             if (isCorrectClass(ref.getClassName())) {
-                final RefAddr ra = ref.get("instanceKey");
-                if (ra != null && ra.getContent() != null) {
+                final RefAddr refAddr = ref.get("instanceKey");
+                if (refAddr != null && refAddr.getContent() != null) {
                     // object was bound to jndi via Referenceable api.
-                    obj = instanceMap.get(ra.getContent());
-                }
-                else
-                {
-                    // tomcat jndi creates a Reference out of server.xml
+                    obj = instanceMap.get(refAddr.getContent());
+                } else {
+                    // Tomcat JNDI creates a Reference out of server.xml
                     // <ResourceParam> configuration and passes it to an
                     // instance of the factory given in server.xml.
                     String key = null;
-                    if (name != null)
-                    {
+                    if (name != null) {
                         key = name.toString();
                         obj = instanceMap.get(key);
                     }
-                    if (obj == null)
-                    {
+                    if (obj == null) {
                         final InstanceKeyDataSource ds = getNewInstance(ref);
                         setCommonProperties(ref, ds);
                         obj = ds;
-                        if (key != null)
-                        {
+                        if (key != null) {
                             instanceMap.put(key, ds);
                         }
                     }
@@ -130,197 +145,161 @@ abstract class InstanceKeyDataSourceFactory implements ObjectFactory {
         return obj;
     }
 
-    private void setCommonProperties(final Reference ref,
-                                     final InstanceKeyDataSource ikds)
-        throws IOException, ClassNotFoundException {
+    private void setCommonProperties(final Reference ref, final InstanceKeyDataSource ikds)
+            throws IOException, ClassNotFoundException {
 
-        RefAddr ra = ref.get("dataSourceName");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDataSourceName(ra.getContent().toString());
+        RefAddr refAddr = ref.get("dataSourceName");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDataSourceName(refAddr.getContent().toString());
         }
 
-        ra = ref.get("description");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDescription(ra.getContent().toString());
+        refAddr = ref.get("description");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDescription(refAddr.getContent().toString());
         }
 
-        ra = ref.get("jndiEnvironment");
-        if (ra != null  && ra.getContent() != null) {
-            final byte[] serialized = (byte[]) ra.getContent();
+        refAddr = ref.get("jndiEnvironment");
+        if (refAddr != null && refAddr.getContent() != null) {
+            final byte[] serialized = (byte[]) refAddr.getContent();
             ikds.setJndiEnvironment((Properties) deserialize(serialized));
         }
 
-        ra = ref.get("loginTimeout");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setLoginTimeout(
-                Integer.parseInt(ra.getContent().toString()));
+        refAddr = ref.get("loginTimeout");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setLoginTimeout(Integer.parseInt(refAddr.getContent().toString()));
         }
 
         // Pool properties
-        ra = ref.get("blockWhenExhausted");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultBlockWhenExhausted(Boolean.valueOf(
-                ra.getContent().toString()).booleanValue());
+        refAddr = ref.get("blockWhenExhausted");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultBlockWhenExhausted(Boolean.valueOf(refAddr.getContent().toString()).booleanValue());
         }
 
-        ra = ref.get("evictionPolicyClassName");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultEvictionPolicyClassName(ra.getContent().toString());
+        refAddr = ref.get("evictionPolicyClassName");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultEvictionPolicyClassName(refAddr.getContent().toString());
         }
 
         // Pool properties
-        ra = ref.get("lifo");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultLifo(Boolean.valueOf(
-                ra.getContent().toString()).booleanValue());
+        refAddr = ref.get("lifo");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultLifo(Boolean.valueOf(refAddr.getContent().toString()).booleanValue());
         }
 
-        ra = ref.get("maxIdlePerKey");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultMaxIdle(
-                Integer.parseInt(ra.getContent().toString()));
+        refAddr = ref.get("maxIdlePerKey");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultMaxIdle(Integer.parseInt(refAddr.getContent().toString()));
         }
 
-        ra = ref.get("maxTotalPerKey");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultMaxTotal(
-                Integer.parseInt(ra.getContent().toString()));
+        refAddr = ref.get("maxTotalPerKey");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultMaxTotal(Integer.parseInt(refAddr.getContent().toString()));
         }
 
-        ra = ref.get("maxWaitMillis");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultMaxWaitMillis(
-                Long.parseLong(ra.getContent().toString()));
+        refAddr = ref.get("maxWaitMillis");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultMaxWaitMillis(Long.parseLong(refAddr.getContent().toString()));
         }
 
-        ra = ref.get("minEvictableIdleTimeMillis");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultMinEvictableIdleTimeMillis(
-                Long.parseLong(ra.getContent().toString()));
+        refAddr = ref.get("minEvictableIdleTimeMillis");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultMinEvictableIdleTimeMillis(Long.parseLong(refAddr.getContent().toString()));
         }
 
-        ra = ref.get("minIdlePerKey");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultMinIdle(
-                Integer.parseInt(ra.getContent().toString()));
+        refAddr = ref.get("minIdlePerKey");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultMinIdle(Integer.parseInt(refAddr.getContent().toString()));
         }
 
-        ra = ref.get("numTestsPerEvictionRun");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultNumTestsPerEvictionRun(
-                Integer.parseInt(ra.getContent().toString()));
+        refAddr = ref.get("numTestsPerEvictionRun");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultNumTestsPerEvictionRun(Integer.parseInt(refAddr.getContent().toString()));
         }
 
-        ra = ref.get("softMinEvictableIdleTimeMillis");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultSoftMinEvictableIdleTimeMillis(
-                Long.parseLong(ra.getContent().toString()));
+        refAddr = ref.get("softMinEvictableIdleTimeMillis");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultSoftMinEvictableIdleTimeMillis(Long.parseLong(refAddr.getContent().toString()));
         }
 
-        ra = ref.get("testOnCreate");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultTestOnCreate(Boolean.valueOf(
-                ra.getContent().toString()).booleanValue());
+        refAddr = ref.get("testOnCreate");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultTestOnCreate(Boolean.valueOf(refAddr.getContent().toString()).booleanValue());
         }
 
-        ra = ref.get("testOnBorrow");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultTestOnBorrow(Boolean.valueOf(
-                ra.getContent().toString()).booleanValue());
+        refAddr = ref.get("testOnBorrow");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultTestOnBorrow(Boolean.valueOf(refAddr.getContent().toString()).booleanValue());
         }
 
-        ra = ref.get("testOnReturn");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultTestOnReturn(Boolean.valueOf(
-                ra.getContent().toString()).booleanValue());
+        refAddr = ref.get("testOnReturn");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultTestOnReturn(Boolean.valueOf(refAddr.getContent().toString()).booleanValue());
         }
 
-        ra = ref.get("testWhileIdle");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultTestWhileIdle(Boolean.valueOf(
-                ra.getContent().toString()).booleanValue());
+        refAddr = ref.get("testWhileIdle");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultTestWhileIdle(Boolean.valueOf(refAddr.getContent().toString()).booleanValue());
         }
 
-        ra = ref.get("timeBetweenEvictionRunsMillis");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultTimeBetweenEvictionRunsMillis(
-                Long.parseLong(ra.getContent().toString()));
+        refAddr = ref.get("timeBetweenEvictionRunsMillis");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultTimeBetweenEvictionRunsMillis(Long.parseLong(refAddr.getContent().toString()));
         }
 
-
         // Connection factory properties
 
-        ra = ref.get("validationQuery");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setValidationQuery(ra.getContent().toString());
+        refAddr = ref.get("validationQuery");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setValidationQuery(refAddr.getContent().toString());
         }
 
-        ra = ref.get("validationQueryTimeout");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setValidationQueryTimeout(Integer.parseInt(
-                    ra.getContent().toString()));
+        refAddr = ref.get("validationQueryTimeout");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setValidationQueryTimeout(Integer.parseInt(refAddr.getContent().toString()));
         }
 
-        ra = ref.get("rollbackAfterValidation");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setRollbackAfterValidation(Boolean.valueOf(
-                ra.getContent().toString()).booleanValue());
+        refAddr = ref.get("rollbackAfterValidation");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setRollbackAfterValidation(Boolean.valueOf(refAddr.getContent().toString()).booleanValue());
         }
 
-        ra = ref.get("maxConnLifetimeMillis");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setMaxConnLifetimeMillis(
-                Long.parseLong(ra.getContent().toString()));
+        refAddr = ref.get("maxConnLifetimeMillis");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setMaxConnLifetimeMillis(Long.parseLong(refAddr.getContent().toString()));
         }
 
-
         // Connection properties
 
-        ra = ref.get("defaultAutoCommit");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultAutoCommit(Boolean.valueOf(ra.getContent().toString()));
+        refAddr = ref.get("defaultAutoCommit");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultAutoCommit(Boolean.valueOf(refAddr.getContent().toString()));
         }
 
-        ra = ref.get("defaultTransactionIsolation");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultTransactionIsolation(
-                Integer.parseInt(ra.getContent().toString()));
+        refAddr = ref.get("defaultTransactionIsolation");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultTransactionIsolation(Integer.parseInt(refAddr.getContent().toString()));
         }
 
-        ra = ref.get("defaultReadOnly");
-        if (ra != null && ra.getContent() != null) {
-            ikds.setDefaultReadOnly(Boolean.valueOf(ra.getContent().toString()));
+        refAddr = ref.get("defaultReadOnly");
+        if (refAddr != null && refAddr.getContent() != null) {
+            ikds.setDefaultReadOnly(Boolean.valueOf(refAddr.getContent().toString()));
         }
     }
 
-
     /**
-     * @param className The class name
-     * @return true if and only if className is the value returned
-     * from getClass().getName().toString()
+     * @return true if and only if className is the value returned from getClass().getName().toString()
      */
     protected abstract boolean isCorrectClass(String className);
 
     /**
-     * Creates an instance of the subclass and sets any properties
-     * contained in the Reference.
-     * @param ref The reference
-     * @return the data source
-     * @throws IOException IO error
-     * @throws ClassNotFoundException Couldn't load data source implementation
+     * Creates an instance of the subclass and sets any properties contained in the Reference.
      */
-    protected abstract InstanceKeyDataSource getNewInstance(Reference ref)
-        throws IOException, ClassNotFoundException;
+    protected abstract InstanceKeyDataSource getNewInstance(Reference ref) throws IOException, ClassNotFoundException;
 
     /**
-     * Used to set some properties saved within a Reference.
-     * @param data Object data
-     * @return the deserialized object
-     * @throws IOException Stream error
-     * @throws ClassNotFoundException Couldn't load object class
+     * Sets some properties saved within a Reference
      */
-    protected static final Object deserialize(final byte[] data)
-        throws IOException, ClassNotFoundException {
+    protected static final Object deserialize(final byte[] data) throws IOException, ClassNotFoundException {
         ObjectInputStream in = null;
         try {
             in = new ObjectInputStream(new ByteArrayInputStream(data));
@@ -330,9 +309,9 @@ abstract class InstanceKeyDataSourceFactory implements ObjectFactory {
                 try {
                     in.close();
                 } catch (final IOException ex) {
+                    // ignore
                 }
             }
         }
     }
 }
-

==================================================
PerUserPoolDataSource.java
index 23e5bc4ab7..3f15b790d1 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/datasources/KeyedCPDSConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/KeyedCPDSConnectionFactory.java
@@ -38,66 +38,59 @@ import org.apache.tomcat.dbcp.pool2.PooledObject;
 import org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject;
 
 /**
- * A {@link KeyedPooledObjectFactory} that creates
- * {@link org.apache.tomcat.dbcp.dbcp2.PoolableConnection PoolableConnection}s.
+ * A {@link KeyedPooledObjectFactory} that creates {@link org.apache.tomcat.dbcp.dbcp2.PoolableConnection
+ * PoolableConnection}s.
  *
- * @author John D. McNally
  * @since 2.0
  */
-class KeyedCPDSConnectionFactory
-    implements KeyedPooledObjectFactory<UserPassKey,PooledConnectionAndInfo>,
-    ConnectionEventListener, PooledConnectionManager {
+class KeyedCPDSConnectionFactory implements KeyedPooledObjectFactory<UserPassKey, PooledConnectionAndInfo>,
+        ConnectionEventListener, PooledConnectionManager {
 
-    private static final String NO_KEY_MESSAGE
-            = "close() was called on a Connection, but "
+    private static final String NO_KEY_MESSAGE = "close() was called on a Connection, but "
             + "I have no record of the underlying PooledConnection.";
 
-    private final ConnectionPoolDataSource _cpds;
-    private final String _validationQuery;
-    private final int _validationQueryTimeout;
-    private final boolean _rollbackAfterValidation;
-    private KeyedObjectPool<UserPassKey,PooledConnectionAndInfo> _pool;
+    private final ConnectionPoolDataSource cpds;
+    private final String validationQuery;
+    private final int validationQueryTimeoutSeconds;
+    private final boolean rollbackAfterValidation;
+    private KeyedObjectPool<UserPassKey, PooledConnectionAndInfo> pool;
     private long maxConnLifetimeMillis = -1;
 
     /**
-     * Map of PooledConnections for which close events are ignored.
-     * Connections are muted when they are being validated.
+     * Map of PooledConnections for which close events are ignored. Connections are muted when they are being validated.
      */
-    private final Set<PooledConnection> validatingSet =
-            Collections.newSetFromMap(new ConcurrentHashMap<PooledConnection,Boolean>());
+    private final Set<PooledConnection> validatingSet = Collections
+            .newSetFromMap(new ConcurrentHashMap<PooledConnection, Boolean>());
 
     /**
      * Map of PooledConnectionAndInfo instances
      */
-    private final Map<PooledConnection, PooledConnectionAndInfo> pcMap =
-        new ConcurrentHashMap<>();
-
+    private final Map<PooledConnection, PooledConnectionAndInfo> pcMap = new ConcurrentHashMap<>();
 
     /**
      * Create a new {@code KeyedPoolableConnectionFactory}.
-     * @param cpds the ConnectionPoolDataSource from which to obtain
-     * PooledConnections
-     * @param validationQuery a query to use to {@link #validateObject validate}
-     * {@link Connection}s.  Should return at least one row. May be
-     * {@code null} in which case3 {@link Connection#isValid(int)} will be used
-     * to validate connections.
-     * @param validationQueryTimeout The time, in seconds, to allow for the
-     *        validation query to complete
-     * @param rollbackAfterValidation whether a rollback should be issued after
-     * {@link #validateObject validating} {@link Connection}s.
+     *
+     * @param cpds
+     *            the ConnectionPoolDataSource from which to obtain PooledConnections
+     * @param validationQuery
+     *            a query to use to {@link #validateObject validate} {@link Connection}s. Should return at least one
+     *            row. May be {@code null} in which case3 {@link Connection#isValid(int)} will be used to validate
+     *            connections.
+     * @param validationQueryTimeoutSeconds
+     *            The time, in seconds, to allow for the validation query to complete
+     * @param rollbackAfterValidation
+     *            whether a rollback should be issued after {@link #validateObject validating} {@link Connection}s.
      */
-    public KeyedCPDSConnectionFactory(final ConnectionPoolDataSource cpds,
-                                      final String validationQuery,
-                                      final int validationQueryTimeout,
-                                      final boolean rollbackAfterValidation) {
-        _cpds = cpds;
-        _validationQuery = validationQuery;
-        _validationQueryTimeout = validationQueryTimeout;
-        _rollbackAfterValidation = rollbackAfterValidation;
+    public KeyedCPDSConnectionFactory(final ConnectionPoolDataSource cpds, final String validationQuery,
+            final int validationQueryTimeoutSeconds, final boolean rollbackAfterValidation) {
+        this.cpds = cpds;
+        this.validationQuery = validationQuery;
+        this.validationQueryTimeoutSeconds = validationQueryTimeoutSeconds;
+        this.rollbackAfterValidation = rollbackAfterValidation;
     }
 
-    public void setPool(final KeyedObjectPool<UserPassKey,PooledConnectionAndInfo> pool) {
-        this._pool = pool;
+    public void setPool(final KeyedObjectPool<UserPassKey, PooledConnectionAndInfo> pool) {
+        this.pool = pool;
     }
 
     /**
@@ -105,29 +98,30 @@ class KeyedCPDSConnectionFactory
      *
      * @return KeyedObjectPool managing pooled connections
      */
-    public KeyedObjectPool<UserPassKey,PooledConnectionAndInfo> getPool() {
-        return _pool;
+    public KeyedObjectPool<UserPassKey, PooledConnectionAndInfo> getPool() {
+        return pool;
     }
 
     /**
      * Creates a new {@link PooledConnectionAndInfo} from the given {@link UserPassKey}.
      *
-     * @param upkey {@link UserPassKey} containing user credentials
-     * @throws SQLException if the connection could not be created.
+     * @param upkey
+     *            {@link UserPassKey} containing user credentials
+     * @throws SQLException
+     *             if the connection could not be created.
      * @see org.apache.tomcat.dbcp.pool2.KeyedPooledObjectFactory#makeObject(java.lang.Object)
      */
     @Override
-    public synchronized PooledObject<PooledConnectionAndInfo> makeObject(final UserPassKey upkey)
-            throws Exception {
+    public synchronized PooledObject<PooledConnectionAndInfo> makeObject(final UserPassKey upkey) throws Exception {
         PooledConnectionAndInfo pci = null;
 
         PooledConnection pc = null;
-        final String username = upkey.getUsername();
+        final String userName = upkey.getUsername();
         final String password = upkey.getPassword();
-        if (username == null) {
-            pc = _cpds.getPooledConnection();
+        if (userName == null) {
+            pc = cpds.getPooledConnection();
         } else {
-            pc = _cpds.getPooledConnection(username, password);
+            pc = cpds.getPooledConnection(userName, password);
         }
 
         if (pc == null) {
@@ -137,7 +131,7 @@ class KeyedCPDSConnectionFactory
         // should we add this object as a listener or the pool.
         // consider the validateObject method in decision
         pc.addConnectionEventListener(this);
-        pci = new PooledConnectionAndInfo(pc, username, password);
+        pci = new PooledConnectionAndInfo(pc, userName, upkey.getPasswordCharArray());
         pcMap.put(pc, pci);
 
         return new DefaultPooledObject<>(pci);
@@ -147,8 +141,7 @@ class KeyedCPDSConnectionFactory
      * Closes the PooledConnection and stops listening for events from it.
      */
     @Override
-    public void destroyObject(final UserPassKey key, final PooledObject<PooledConnectionAndInfo> p)
-            throws Exception {
+    public void destroyObject(final UserPassKey key, final PooledObject<PooledConnectionAndInfo> p) throws Exception {
         final PooledConnection pc = p.getObject().getPooledConnection();
         pc.removeConnectionEventListener(this);
         pcMap.remove(pc);
@@ -158,31 +151,31 @@ class KeyedCPDSConnectionFactory
     /**
      * Validates a pooled connection.
      *
-     * @param key ignored
-     * @param p wrapped {@link PooledConnectionAndInfo} containing the
-     *          connection to validate
+     * @param key
+     *            ignored
+     * @param pooledObject
+     *            wrapped {@link PooledConnectionAndInfo} containing the connection to validate
      * @return true if validation succeeds
      */
     @Override
-    public boolean validateObject(final UserPassKey key,
-            final PooledObject<PooledConnectionAndInfo> p) {
+    public boolean validateObject(final UserPassKey key, final PooledObject<PooledConnectionAndInfo> pooledObject) {
         try {
-            validateLifetime(p);
+            validateLifetime(pooledObject);
         } catch (final Exception e) {
             return false;
         }
         boolean valid = false;
-        final PooledConnection pconn = p.getObject().getPooledConnection();
+        final PooledConnection pconn = pooledObject.getObject().getPooledConnection();
         Connection conn = null;
         validatingSet.add(pconn);
-        if (null == _validationQuery) {
-            int timeout = _validationQueryTimeout;
-            if (timeout < 0) {
-                timeout = 0;
+        if (null == validationQuery) {
+            int timeoutSeconds = validationQueryTimeoutSeconds;
+            if (timeoutSeconds < 0) {
+                timeoutSeconds = 0;
             }
             try {
                 conn = pconn.getConnection();
-                valid = conn.isValid(timeout);
+                valid = conn.isValid(timeoutSeconds);
             } catch (final SQLException e) {
                 valid = false;
             } finally {
@@ -200,16 +193,16 @@ class KeyedCPDSConnectionFactory
             try {
                 conn = pconn.getConnection();
                 stmt = conn.createStatement();
-                rset = stmt.executeQuery(_validationQuery);
+                rset = stmt.executeQuery(validationQuery);
                 if (rset.next()) {
                     valid = true;
                 } else {
                     valid = false;
                 }
-                if (_rollbackAfterValidation) {
+                if (rollbackAfterValidation) {
                     conn.rollback();
                 }
-            } catch(final Exception e) {
+            } catch (final Exception e) {
                 valid = false;
             } finally {
                 Utils.closeQuietly(rset);
@@ -222,14 +215,12 @@ class KeyedCPDSConnectionFactory
     }
 
     @Override
-    public void passivateObject(final UserPassKey key,
-            final PooledObject<PooledConnectionAndInfo> p) throws Exception {
+    public void passivateObject(final UserPassKey key, final PooledObject<PooledConnectionAndInfo> p) throws Exception {
         validateLifetime(p);
     }
 
     @Override
-    public void activateObject(final UserPassKey key,
-            final PooledObject<PooledConnectionAndInfo> p) throws Exception {
+    public void activateObject(final UserPassKey key, final PooledObject<PooledConnectionAndInfo> p) throws Exception {
         validateLifetime(p);
     }
 
@@ -238,14 +229,13 @@ class KeyedCPDSConnectionFactory
     // ***********************************************************************
 
     /**
-     * This will be called if the Connection returned by the getConnection
-     * method came from a PooledConnection, and the user calls the close()
-     * method of this connection object. What we need to do here is to
-     * release this PooledConnection from our pool...
+     * This will be called if the Connection returned by the getConnection method came from a PooledConnection, and the
+     * user calls the close() method of this connection object. What we need to do here is to release this
+     * PooledConnection from our pool...
      */
     @Override
     public void connectionClosed(final ConnectionEvent event) {
-        final PooledConnection pc = (PooledConnection)event.getSource();
+        final PooledConnection pc = (PooledConnection) event.getSource();
         // if this event occurred because we were validating, or if this
         // connection has been marked for removal, ignore it
         // otherwise return the connection to the pool.
@@ -255,16 +245,14 @@ class KeyedCPDSConnectionFactory
                 throw new IllegalStateException(NO_KEY_MESSAGE);
             }
             try {
-                _pool.returnObject(pci.getUserPassKey(), pci);
+                pool.returnObject(pci.getUserPassKey(), pci);
             } catch (final Exception e) {
-                System.err.println("CLOSING DOWN CONNECTION AS IT COULD " +
-                "NOT BE RETURNED TO THE POOL");
+                System.err.println("CLOSING DOWN CONNECTION AS IT COULD " + "NOT BE RETURNED TO THE POOL");
                 pc.removeConnectionEventListener(this);
                 try {
-                    _pool.invalidateObject(pci.getUserPassKey(), pci);
+                    pool.invalidateObject(pci.getUserPassKey(), pci);
                 } catch (final Exception e3) {
-                    System.err.println("EXCEPTION WHILE DESTROYING OBJECT " +
-                            pci);
+                    System.err.println("EXCEPTION WHILE DESTROYING OBJECT " + pci);
                     e3.printStackTrace();
                 }
             }
@@ -272,16 +260,13 @@ class KeyedCPDSConnectionFactory
     }
 
     /**
-     * If a fatal error occurs, close the underlying physical connection so as
-     * not to be returned in the future
+     * If a fatal error occurs, close the underlying physical connection so as not to be returned in the future
      */
     @Override
     public void connectionErrorOccurred(final ConnectionEvent event) {
-        final PooledConnection pc = (PooledConnection)event.getSource();
+        final PooledConnection pc = (PooledConnection) event.getSource();
         if (null != event.getSQLException()) {
-            System.err
-                .println("CLOSING DOWN CONNECTION DUE TO INTERNAL ERROR (" +
-                         event.getSQLException() + ")");
+            System.err.println("CLOSING DOWN CONNECTION DUE TO INTERNAL ERROR (" + event.getSQLException() + ")");
         }
         pc.removeConnectionEventListener(this);
 
@@ -290,7 +275,7 @@ class KeyedCPDSConnectionFactory
             throw new IllegalStateException(NO_KEY_MESSAGE);
         }
         try {
-            _pool.invalidateObject(info.getUserPassKey(), info);
+            pool.invalidateObject(info.getUserPassKey(), info);
         } catch (final Exception e) {
             System.err.println("EXCEPTION WHILE DESTROYING OBJECT " + info);
             e.printStackTrace();
@@ -302,11 +287,10 @@ class KeyedCPDSConnectionFactory
     // ***********************************************************************
 
     /**
-     * Invalidates the PooledConnection in the pool.  The KeyedCPDSConnectionFactory
-     * closes the connection and pool counters are updated appropriately.
-     * Also clears any idle instances associated with the username that was used
-     * to create the PooledConnection.  Connections associated with this user
-     * are not affected and they will not be automatically closed on return to the pool.
+     * Invalidates the PooledConnection in the pool. The KeyedCPDSConnectionFactory closes the connection and pool
+     * counters are updated appropriately. Also clears any idle instances associated with the user name that was used to
+     * create the PooledConnection. Connections associated with this user are not affected and they will not be
+     * automatically closed on return to the pool.
      */
     @Override
     public void invalidate(final PooledConnection pc) throws SQLException {
@@ -316,53 +300,50 @@ class KeyedCPDSConnectionFactory
         }
         final UserPassKey key = info.getUserPassKey();
         try {
-            _pool.invalidateObject(key, info);  // Destroy and update pool counters
-            _pool.clear(key); // Remove any idle instances with this key
+            pool.invalidateObject(key, info); // Destroy and update pool counters
+            pool.clear(key); // Remove any idle instances with this key
         } catch (final Exception ex) {
             throw new SQLException("Error invalidating connection", ex);
         }
     }
 
     /**
-     * Does nothing.  This factory does not cache user credentials.
+     * Does nothing. This factory does not cache user credentials.
      */
     @Override
     public void setPassword(final String password) {
+        // Does nothing. This factory does not cache user credentials.
     }
 
     /**
-     * Sets the maximum lifetime in milliseconds of a connection after which the
-     * connection will always fail activation, passivation and validation.
+     * Sets the maximum lifetime in milliseconds of a connection after which the connection will always fail activation,
+     * passivation and validation.
      *
-     * @param maxConnLifetimeMillis A value of zero or less indicates an
-     *        infinite lifetime. The default value is -1.
+     * @param maxConnLifetimeMillis
+     *            A value of zero or less indicates an infinite lifetime. The default value is -1.
      */
     public void setMaxConnLifetimeMillis(final long maxConnLifetimeMillis) {
         this.maxConnLifetimeMillis = maxConnLifetimeMillis;
     }
 
     /**
-     * This implementation does not fully close the KeyedObjectPool, as
-     * this would affect all users.  Instead, it clears the pool associated
-     * with the given user.  This method is not currently used.
+     * This implementation does not fully close the KeyedObjectPool, as this would affect all users. Instead, it clears
+     * the pool associated with the given user. This method is not currently used.
      */
     @Override
-    public void closePool(final String username) throws SQLException {
+    public void closePool(final String userName) throws SQLException {
         try {
-            _pool.clear(new UserPassKey(username, null));
+            pool.clear(new UserPassKey(userName));
         } catch (final Exception ex) {
             throw new SQLException("Error closing connection pool", ex);
         }
     }
 
-    private void validateLifetime(final PooledObject<PooledConnectionAndInfo> p)
-            throws Exception {
+    private void validateLifetime(final PooledObject<PooledConnectionAndInfo> p) throws Exception {
         if (maxConnLifetimeMillis > 0) {
             final long lifetime = System.currentTimeMillis() - p.getCreateTime();
             if (lifetime > maxConnLifetimeMillis) {
-                throw new Exception(Utils.getMessage(
-                        "connectionFactory.lifetimeExceeded",
-                        Long.valueOf(lifetime),
+                throw new Exception(Utils.getMessage("connectionFactory.lifetimeExceeded", Long.valueOf(lifetime),
                         Long.valueOf(maxConnLifetimeMillis)));
             }
         }

==================================================
PerUserPoolDataSourceFactory.java
index 87ae16f315..fd5a7ef739 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/datasources/PerUserPoolDataSource.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/PerUserPoolDataSource.java
@@ -36,320 +36,308 @@ import org.apache.tomcat.dbcp.pool2.ObjectPool;
 import org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool;
 
 /**
- * <p>A pooling <code>DataSource</code> appropriate for deployment within
- * J2EE environment.  There are many configuration options, most of which are
- * defined in the parent class.  This datasource uses individual pools per
- * user, and some properties can be set specifically for a given user, if the
- * deployment environment can support initialization of mapped properties.
- * So for example, a pool of admin or write-access Connections can be
- * guaranteed a certain number of connections, separate from a maximum
- * set for users with read-only connections.</p>
+ * <p>
+ * A pooling <code>DataSource</code> appropriate for deployment within J2EE environment. There are many configuration
+ * options, most of which are defined in the parent class. This datasource uses individual pools per user, and some
+ * properties can be set specifically for a given user, if the deployment environment can support initialization of
+ * mapped properties. So for example, a pool of admin or write-access Connections can be guaranteed a certain number of
+ * connections, separate from a maximum set for users with read-only connections.
+ * </p>
  *
- * <p>User passwords can be changed without re-initializing the datasource.
- * When a <code>getConnection(username, password)</code> request is processed
- * with a password that is different from those used to create connections in
- * the pool associated with <code>username</code>, an attempt is made to create
- * a new connection using the supplied password and if this succeeds, the
- * existing pool is cleared and a new pool is created for connections using the
- * new password.</p>
+ * <p>
+ * User passwords can be changed without re-initializing the datasource. When a
+ * <code>getConnection(userName, password)</code> request is processed with a password that is different from those used
+ * to create connections in the pool associated with <code>userName</code>, an attempt is made to create a new
+ * connection using the supplied password and if this succeeds, the existing pool is cleared and a new pool is created
+ * for connections using the new password.
+ * </p>
  *
- * @author John D. McNally
  * @since 2.0
  */
 public class PerUserPoolDataSource extends InstanceKeyDataSource {
 
     private static final long serialVersionUID = 7872747993848065028L;
 
-    private static final Log log =
-            LogFactory.getLog(PerUserPoolDataSource.class);
+    private static final Log log = LogFactory.getLog(PerUserPoolDataSource.class);
 
     // Per user pool properties
-    private Map<String,Boolean> perUserBlockWhenExhausted = null;
-    private Map<String,String> perUserEvictionPolicyClassName = null;
-    private Map<String,Boolean> perUserLifo = null;
-    private Map<String,Integer> perUserMaxIdle = null;
-    private Map<String,Integer> perUserMaxTotal = null;
-    private Map<String,Long> perUserMaxWaitMillis = null;
-    private Map<String,Long> perUserMinEvictableIdleTimeMillis = null;
-    private Map<String,Integer> perUserMinIdle = null;
-    private Map<String,Integer> perUserNumTestsPerEvictionRun = null;
-    private Map<String,Long> perUserSoftMinEvictableIdleTimeMillis = null;
-    private Map<String,Boolean> perUserTestOnCreate = null;
-    private Map<String,Boolean> perUserTestOnBorrow = null;
-    private Map<String,Boolean> perUserTestOnReturn = null;
-    private Map<String,Boolean> perUserTestWhileIdle = null;
-    private Map<String,Long> perUserTimeBetweenEvictionRunsMillis = null;
+    private Map<String, Boolean> perUserBlockWhenExhausted;
+    private Map<String, String> perUserEvictionPolicyClassName;
+    private Map<String, Boolean> perUserLifo;
+    private Map<String, Integer> perUserMaxIdle;
+    private Map<String, Integer> perUserMaxTotal;
+    private Map<String, Long> perUserMaxWaitMillis;
+    private Map<String, Long> perUserMinEvictableIdleTimeMillis;
+    private Map<String, Integer> perUserMinIdle;
+    private Map<String, Integer> perUserNumTestsPerEvictionRun;
+    private Map<String, Long> perUserSoftMinEvictableIdleTimeMillis;
+    private Map<String, Boolean> perUserTestOnCreate;
+    private Map<String, Boolean> perUserTestOnBorrow;
+    private Map<String, Boolean> perUserTestOnReturn;
+    private Map<String, Boolean> perUserTestWhileIdle;
+    private Map<String, Long> perUserTimeBetweenEvictionRunsMillis;
 
     // Per user connection properties
-    private Map<String,Boolean> perUserDefaultAutoCommit = null;
-    private Map<String,Integer> perUserDefaultTransactionIsolation = null;
-    private Map<String,Boolean> perUserDefaultReadOnly = null;
+    private Map<String, Boolean> perUserDefaultAutoCommit;
+    private Map<String, Integer> perUserDefaultTransactionIsolation;
+    private Map<String, Boolean> perUserDefaultReadOnly;
 
     /**
-     * Map to keep track of Pools for a given user
+     * Map to keep track of Pools for a given user.
      */
-    private transient Map<PoolKey, PooledConnectionManager> managers =
-            new HashMap<>();
+    private transient Map<PoolKey, PooledConnectionManager> managers = new HashMap<>();
 
     /**
-     * Default no-arg constructor for Serialization
+     * Default no-arg constructor for Serialization.
      */
     public PerUserPoolDataSource() {
     }
 
     /**
-     * Close pool(s) being maintained by this datasource.
+     * Clears pool(s) maintained by this data source.
+     *
+     * @see org.apache.tomcat.dbcp.pool2.ObjectPool#clear()
+     * @since 2.3.0
      */
-    @Override
-    public void close() {
+    public void clear() {
         for (final PooledConnectionManager manager : managers.values()) {
             try {
-              ((CPDSConnectionFactory) manager).getPool().close();
+                getCPDSConnectionFactoryPool(manager).clear();
             } catch (final Exception closePoolException) {
-                    //ignore and try to close others.
+                // ignore and try to close others.
             }
         }
         InstanceKeyDataSourceFactory.removeInstance(getInstanceKey());
     }
 
-    // -------------------------------------------------------------------
-    // Properties
-
     /**
-     * Gets the user specific value for
-     * {@link GenericObjectPool#getBlockWhenExhausted()} for the
-     * specified user's pool or the default if no user specific value is defined.
-     * @param key The user
-     * @return <code>true</code> to block
+     * Closes pool(s) maintained by this data source.
+     *
+     * @see org.apache.tomcat.dbcp.pool2.ObjectPool#close()
      */
-    public boolean getPerUserBlockWhenExhausted(final String key) {
-        Boolean value = null;
-        if (perUserBlockWhenExhausted != null) {
-            value = perUserBlockWhenExhausted.get(key);
-        }
-        if (value == null) {
-            return getDefaultBlockWhenExhausted();
+    @Override
+    public void close() {
+        for (final PooledConnectionManager manager : managers.values()) {
+            try {
+                getCPDSConnectionFactoryPool(manager).close();
+            } catch (final Exception closePoolException) {
+                // ignore and try to close others.
+            }
         }
-        return value.booleanValue();
+        InstanceKeyDataSourceFactory.removeInstance(getInstanceKey());
     }
 
-    /**
-     * Sets a user specific value for
-     * {@link GenericObjectPool#getBlockWhenExhausted()} for the specified
-     * user's pool.
-     * @param username The user
-     * @param value The value
-     */
-    public void setPerUserBlockWhenExhausted(final String username,
-            final Boolean value) {
-        assertInitializationAllowed();
-        if (perUserBlockWhenExhausted == null) {
-            perUserBlockWhenExhausted = new HashMap<>();
-        }
-        perUserBlockWhenExhausted.put(username, value);
+    private HashMap<String, Boolean> createMap() {
+        // Should there be a default size different than what this ctor provides?
+        return new HashMap<>();
     }
 
-    void setPerUserBlockWhenExhausted(
-            final Map<String,Boolean> userDefaultBlockWhenExhausted) {
-        assertInitializationAllowed();
-        if (perUserBlockWhenExhausted == null) {
-            perUserBlockWhenExhausted = new HashMap<>();
-        } else {
-            perUserBlockWhenExhausted.clear();
-        }
-        perUserBlockWhenExhausted.putAll(userDefaultBlockWhenExhausted);
+    @Override
+    protected PooledConnectionManager getConnectionManager(final UserPassKey upKey) {
+        return managers.get(getPoolKey(upKey.getUsername()));
     }
 
+    private ObjectPool<PooledConnectionAndInfo> getCPDSConnectionFactoryPool(final PooledConnectionManager manager) {
+        return ((CPDSConnectionFactory) manager).getPool();
+    }
 
     /**
-     * Gets the user specific value for
-     * {@link GenericObjectPool#getEvictionPolicyClassName()} for the
-     * specified user's pool or the default if no user specific value is defined.
-     * @param key The user
-     * @return the policy class name
+     * Gets the number of active connections in the default pool.
+     *
+     * @return The number of active connections in the default pool.
      */
-    public String getPerUserEvictionPolicyClassName(final String key) {
-        String value = null;
-        if (perUserEvictionPolicyClassName != null) {
-            value = perUserEvictionPolicyClassName.get(key);
-        }
-        if (value == null) {
-            return getDefaultEvictionPolicyClassName();
-        }
-        return value;
+    public int getNumActive() {
+        return getNumActive(null);
     }
 
     /**
-     * Sets a user specific value for
-     * {@link GenericObjectPool#getEvictionPolicyClassName()} for the specified
-     * user's pool.
-     * @param username The user
-     * @param value The value
+     * Gets the number of active connections in the pool for a given user.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public void setPerUserEvictionPolicyClassName(final String username,
-            final String value) {
-        assertInitializationAllowed();
-        if (perUserEvictionPolicyClassName == null) {
-            perUserEvictionPolicyClassName = new HashMap<>();
-        }
-        perUserEvictionPolicyClassName.put(username, value);
+    @SuppressWarnings("resource")
+    public int getNumActive(final String userName) {
+        final ObjectPool<PooledConnectionAndInfo> pool = getPool(getPoolKey(userName));
+        return pool == null ? 0 : pool.getNumActive();
     }
 
-    void setPerUserEvictionPolicyClassName(
-            final Map<String,String> userDefaultEvictionPolicyClassName) {
-        assertInitializationAllowed();
-        if (perUserEvictionPolicyClassName == null) {
-            perUserEvictionPolicyClassName = new HashMap<>();
-        } else {
-            perUserEvictionPolicyClassName.clear();
-        }
-        perUserEvictionPolicyClassName.putAll(userDefaultEvictionPolicyClassName);
+    /**
+     * Gets the number of idle connections in the default pool.
+     *
+     * @return The number of idle connections in the default pool.
+     */
+    public int getNumIdle() {
+        return getNumIdle(null);
     }
 
+    /**
+     * Gets the number of idle connections in the pool for a given user.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
+     */
+    @SuppressWarnings("resource")
+    public int getNumIdle(final String userName) {
+        final ObjectPool<PooledConnectionAndInfo> pool = getPool(getPoolKey(userName));
+        return pool == null ? 0 : pool.getNumIdle();
+    }
 
     /**
-     * Gets the user specific value for {@link GenericObjectPool#getLifo()} for
-     * the specified user's pool or the default if no user specific value is
-     * defined.
-     * @param key The user
-     * @return <code>true</code> to use LIFO
+     * Gets the user specific value for {@link GenericObjectPool#getBlockWhenExhausted()} for the specified user's pool
+     * or the default if no user specific value is defined.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public boolean getPerUserLifo(final String key) {
+    public boolean getPerUserBlockWhenExhausted(final String userName) {
         Boolean value = null;
-        if (perUserLifo != null) {
-            value = perUserLifo.get(key);
+        if (perUserBlockWhenExhausted != null) {
+            value = perUserBlockWhenExhausted.get(userName);
         }
         if (value == null) {
-            return getDefaultLifo();
+            return getDefaultBlockWhenExhausted();
         }
         return value.booleanValue();
     }
 
     /**
-     * Sets a user specific value for
-     * {@link GenericObjectPool#getLifo()} for the specified
-     * user's pool.
-     * @param username The user
-     * @param value The value
+     * Gets the user specific default value for {@link Connection#setAutoCommit(boolean)} for the specified user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public void setPerUserLifo(final String username, final Boolean value) {
-        assertInitializationAllowed();
-        if (perUserLifo == null) {
-            perUserLifo = new HashMap<>();
+    public Boolean getPerUserDefaultAutoCommit(final String userName) {
+        Boolean value = null;
+        if (perUserDefaultAutoCommit != null) {
+            value = perUserDefaultAutoCommit.get(userName);
         }
-        perUserLifo.put(username, value);
+        return value;
     }
 
-    void setPerUserLifo(final Map<String,Boolean> userDefaultLifo) {
-        assertInitializationAllowed();
-        if (perUserLifo == null) {
-            perUserLifo = new HashMap<>();
-        } else {
-            perUserLifo.clear();
+    /**
+     * Gets the user specific default value for {@link Connection#setReadOnly(boolean)} for the specified user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
+     */
+    public Boolean getPerUserDefaultReadOnly(final String userName) {
+        Boolean value = null;
+        if (perUserDefaultReadOnly != null) {
+            value = perUserDefaultReadOnly.get(userName);
         }
-        perUserLifo.putAll(userDefaultLifo);
+        return value;
     }
 
-
     /**
-     * Gets the user specific value for
-     * {@link GenericObjectPool#getMaxIdle()} for the
-     * specified user's pool or the default if no user specific value is defined.
-     * @param key The user
-     * @return the maximum idle
+     * Gets the user specific default value for {@link Connection#setTransactionIsolation(int)} for the specified user's
+     * pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public int getPerUserMaxIdle(final String key) {
+    public Integer getPerUserDefaultTransactionIsolation(final String userName) {
         Integer value = null;
-        if (perUserMaxIdle != null) {
-            value = perUserMaxIdle.get(key);
-        }
-        if (value == null) {
-            return getDefaultMaxIdle();
+        if (perUserDefaultTransactionIsolation != null) {
+            value = perUserDefaultTransactionIsolation.get(userName);
         }
-        return value.intValue();
+        return value;
     }
 
     /**
-     * Sets a user specific value for
-     * {@link GenericObjectPool#getMaxIdle()} for the specified
-     * user's pool.
-     * @param username The user
-     * @param value The value
+     * Gets the user specific value for {@link GenericObjectPool#getEvictionPolicyClassName()} for the specified user's
+     * pool or the default if no user specific value is defined.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public void setPerUserMaxIdle(final String username, final Integer value) {
-        assertInitializationAllowed();
-        if (perUserMaxIdle == null) {
-            perUserMaxIdle = new HashMap<>();
+    public String getPerUserEvictionPolicyClassName(final String userName) {
+        String value = null;
+        if (perUserEvictionPolicyClassName != null) {
+            value = perUserEvictionPolicyClassName.get(userName);
+        }
+        if (value == null) {
+            return getDefaultEvictionPolicyClassName();
         }
-        perUserMaxIdle.put(username, value);
+        return value;
     }
 
-    void setPerUserMaxIdle(final Map<String,Integer> userDefaultMaxIdle) {
-        assertInitializationAllowed();
-        if (perUserMaxIdle == null) {
-            perUserMaxIdle = new HashMap<>();
-        } else {
-            perUserMaxIdle.clear();
+    /**
+     * Gets the user specific value for {@link GenericObjectPool#getLifo()} for the specified user's pool or the default
+     * if no user specific value is defined.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
+     */
+    public boolean getPerUserLifo(final String userName) {
+        Boolean value = null;
+        if (perUserLifo != null) {
+            value = perUserLifo.get(userName);
         }
-        perUserMaxIdle.putAll(userDefaultMaxIdle);
+        if (value == null) {
+            return getDefaultLifo();
+        }
+        return value.booleanValue();
     }
 
-
     /**
-     * Gets the user specific value for
-     * {@link GenericObjectPool#getMaxTotal()} for the
-     * specified user's pool or the default if no user specific value is defined.
-     * @param key The user
-     * @return the maximum total
+     * Gets the user specific value for {@link GenericObjectPool#getMaxIdle()} for the specified user's pool or the
+     * default if no user specific value is defined.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public int getPerUserMaxTotal(final String key) {
+    public int getPerUserMaxIdle(final String userName) {
         Integer value = null;
-        if (perUserMaxTotal != null) {
-            value = perUserMaxTotal.get(key);
+        if (perUserMaxIdle != null) {
+            value = perUserMaxIdle.get(userName);
         }
         if (value == null) {
-            return getDefaultMaxTotal();
+            return getDefaultMaxIdle();
         }
         return value.intValue();
     }
 
     /**
-     * Sets a user specific value for
-     * {@link GenericObjectPool#getMaxTotal()} for the specified
-     * user's pool.
-     * @param username The user
-     * @param value The value
+     * Gets the user specific value for {@link GenericObjectPool#getMaxTotal()} for the specified user's pool or the
+     * default if no user specific value is defined.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public void setPerUserMaxTotal(final String username, final Integer value) {
-        assertInitializationAllowed();
-        if (perUserMaxTotal == null) {
-            perUserMaxTotal = new HashMap<>();
+    public int getPerUserMaxTotal(final String userName) {
+        Integer value = null;
+        if (perUserMaxTotal != null) {
+            value = perUserMaxTotal.get(userName);
         }
-        perUserMaxTotal.put(username, value);
-    }
-
-    void setPerUserMaxTotal(final Map<String,Integer> userDefaultMaxTotal) {
-        assertInitializationAllowed();
-        if (perUserMaxTotal == null) {
-            perUserMaxTotal = new HashMap<>();
-        } else {
-            perUserMaxTotal.clear();
+        if (value == null) {
+            return getDefaultMaxTotal();
         }
-        perUserMaxTotal.putAll(userDefaultMaxTotal);
+        return value.intValue();
     }
 
-
     /**
-     * Gets the user specific value for
-     * {@link GenericObjectPool#getMaxWaitMillis()} for the
-     * specified user's pool or the default if no user specific value is defined.
-     * @param key The user
-     * @return the maximum wait time
+     * Gets the user specific value for {@link GenericObjectPool#getMaxWaitMillis()} for the specified user's pool or
+     * the default if no user specific value is defined.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public long getPerUserMaxWaitMillis(final String key) {
+    public long getPerUserMaxWaitMillis(final String userName) {
         Long value = null;
         if (perUserMaxWaitMillis != null) {
-            value = perUserMaxWaitMillis.get(key);
+            value = perUserMaxWaitMillis.get(userName);
         }
         if (value == null) {
             return getDefaultMaxWaitMillis();
@@ -358,43 +346,17 @@ public class PerUserPoolDataSource extends InstanceKeyDataSource {
     }
 
     /**
-     * Sets a user specific value for
-     * {@link GenericObjectPool#getMaxWaitMillis()} for the specified
-     * user's pool.
-     * @param username The user
-     * @param value The value
-     */
-    public void setPerUserMaxWaitMillis(final String username, final Long value) {
-        assertInitializationAllowed();
-        if (perUserMaxWaitMillis == null) {
-            perUserMaxWaitMillis = new HashMap<>();
-        }
-        perUserMaxWaitMillis.put(username, value);
-    }
-
-    void setPerUserMaxWaitMillis(
-            final Map<String,Long> userDefaultMaxWaitMillis) {
-        assertInitializationAllowed();
-        if (perUserMaxWaitMillis == null) {
-            perUserMaxWaitMillis = new HashMap<>();
-        } else {
-            perUserMaxWaitMillis.clear();
-        }
-        perUserMaxWaitMillis.putAll(userDefaultMaxWaitMillis);
-    }
-
-
-    /**
-     * Gets the user specific value for
-     * {@link GenericObjectPool#getMinEvictableIdleTimeMillis()} for the
-     * specified user's pool or the default if no user specific value is defined.
-     * @param key The user
-     * @return the minimum idle time for eviction
+     * Gets the user specific value for {@link GenericObjectPool#getMinEvictableIdleTimeMillis()} for the specified
+     * user's pool or the default if no user specific value is defined.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public long getPerUserMinEvictableIdleTimeMillis(final String key) {
+    public long getPerUserMinEvictableIdleTimeMillis(final String userName) {
         Long value = null;
         if (perUserMinEvictableIdleTimeMillis != null) {
-            value = perUserMinEvictableIdleTimeMillis.get(key);
+            value = perUserMinEvictableIdleTimeMillis.get(userName);
         }
         if (value == null) {
             return getDefaultMinEvictableIdleTimeMillis();
@@ -403,45 +365,17 @@ public class PerUserPoolDataSource extends InstanceKeyDataSource {
     }
 
     /**
-     * Sets a user specific value for
-     * {@link GenericObjectPool#getMinEvictableIdleTimeMillis()} for the
-     * specified user's pool.
-     * @param username The user
-     * @param value The value
-     */
-    public void setPerUserMinEvictableIdleTimeMillis(final String username,
-            final Long value) {
-        assertInitializationAllowed();
-        if (perUserMinEvictableIdleTimeMillis == null) {
-            perUserMinEvictableIdleTimeMillis = new HashMap<>();
-        }
-        perUserMinEvictableIdleTimeMillis.put(username, value);
-    }
-
-    void setPerUserMinEvictableIdleTimeMillis(
-            final Map<String,Long> userDefaultMinEvictableIdleTimeMillis) {
-        assertInitializationAllowed();
-        if (perUserMinEvictableIdleTimeMillis == null) {
-            perUserMinEvictableIdleTimeMillis = new HashMap<>();
-        } else {
-            perUserMinEvictableIdleTimeMillis.clear();
-        }
-        perUserMinEvictableIdleTimeMillis.putAll(
-                userDefaultMinEvictableIdleTimeMillis);
-    }
-
-
-    /**
-     * Gets the user specific value for
-     * {@link GenericObjectPool#getMinIdle()} for the
-     * specified user's pool or the default if no user specific value is defined.
-     * @param key The user
-     * @return the minimum idle count
+     * Gets the user specific value for {@link GenericObjectPool#getMinIdle()} for the specified user's pool or the
+     * default if no user specific value is defined.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public int getPerUserMinIdle(final String key) {
+    public int getPerUserMinIdle(final String userName) {
         Integer value = null;
         if (perUserMinIdle != null) {
-            value = perUserMinIdle.get(key);
+            value = perUserMinIdle.get(userName);
         }
         if (value == null) {
             return getDefaultMinIdle();
@@ -450,42 +384,17 @@ public class PerUserPoolDataSource extends InstanceKeyDataSource {
     }
 
     /**
-     * Sets a user specific value for
-     * {@link GenericObjectPool#getMinIdle()} for the specified
-     * user's pool.
-     * @param username The user
-     * @param value The value
-     */
-    public void setPerUserMinIdle(final String username, final Integer value) {
-        assertInitializationAllowed();
-        if (perUserMinIdle == null) {
-            perUserMinIdle = new HashMap<>();
-        }
-        perUserMinIdle.put(username, value);
-    }
-
-    void setPerUserMinIdle(final Map<String,Integer> userDefaultMinIdle) {
-        assertInitializationAllowed();
-        if (perUserMinIdle == null) {
-            perUserMinIdle = new HashMap<>();
-        } else {
-            perUserMinIdle.clear();
-        }
-        perUserMinIdle.putAll(userDefaultMinIdle);
-    }
-
-
-    /**
-     * Gets the user specific value for
-     * {@link GenericObjectPool#getNumTestsPerEvictionRun()} for the
-     * specified user's pool or the default if no user specific value is defined.
-     * @param key The user
-     * @return the tests count
+     * Gets the user specific value for {@link GenericObjectPool#getNumTestsPerEvictionRun()} for the specified user's
+     * pool or the default if no user specific value is defined.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public int getPerUserNumTestsPerEvictionRun(final String key) {
+    public int getPerUserNumTestsPerEvictionRun(final String userName) {
         Integer value = null;
         if (perUserNumTestsPerEvictionRun != null) {
-            value = perUserNumTestsPerEvictionRun.get(key);
+            value = perUserNumTestsPerEvictionRun.get(userName);
         }
         if (value == null) {
             return getDefaultNumTestsPerEvictionRun();
@@ -494,44 +403,17 @@ public class PerUserPoolDataSource extends InstanceKeyDataSource {
     }
 
     /**
-     * Sets a user specific value for
-     * {@link GenericObjectPool#getNumTestsPerEvictionRun()} for the specified
-     * user's pool.
-     * @param username The user
-     * @param value The value
-     */
-    public void setPerUserNumTestsPerEvictionRun(final String username,
-            final Integer value) {
-        assertInitializationAllowed();
-        if (perUserNumTestsPerEvictionRun == null) {
-            perUserNumTestsPerEvictionRun = new HashMap<>();
-        }
-        perUserNumTestsPerEvictionRun.put(username, value);
-    }
-
-    void setPerUserNumTestsPerEvictionRun(
-            final Map<String,Integer> userDefaultNumTestsPerEvictionRun) {
-        assertInitializationAllowed();
-        if (perUserNumTestsPerEvictionRun == null) {
-            perUserNumTestsPerEvictionRun = new HashMap<>();
-        } else {
-            perUserNumTestsPerEvictionRun.clear();
-        }
-        perUserNumTestsPerEvictionRun.putAll(userDefaultNumTestsPerEvictionRun);
-    }
-
-
-    /**
-     * Gets the user specific value for
-     * {@link GenericObjectPool#getSoftMinEvictableIdleTimeMillis()} for the
-     * specified user's pool or the default if no user specific value is defined.
-     * @param key The user
-     * @return the soft minimum idle time for eviction
+     * Gets the user specific value for {@link GenericObjectPool#getSoftMinEvictableIdleTimeMillis()} for the specified
+     * user's pool or the default if no user specific value is defined.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public long getPerUserSoftMinEvictableIdleTimeMillis(final String key) {
+    public long getPerUserSoftMinEvictableIdleTimeMillis(final String userName) {
         Long value = null;
         if (perUserSoftMinEvictableIdleTimeMillis != null) {
-            value = perUserSoftMinEvictableIdleTimeMillis.get(key);
+            value = perUserSoftMinEvictableIdleTimeMillis.get(userName);
         }
         if (value == null) {
             return getDefaultSoftMinEvictableIdleTimeMillis();
@@ -540,44 +422,36 @@ public class PerUserPoolDataSource extends InstanceKeyDataSource {
     }
 
     /**
-     * Sets a user specific value for
-     * {@link GenericObjectPool#getSoftMinEvictableIdleTimeMillis()} for the
-     * specified user's pool.
-     * @param username The user
-     * @param value The value
+     * Gets the user specific value for {@link GenericObjectPool#getTestOnBorrow()} for the specified user's pool or the
+     * default if no user specific value is defined.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public void setPerUserSoftMinEvictableIdleTimeMillis(final String username,
-            final Long value) {
-        assertInitializationAllowed();
-        if (perUserSoftMinEvictableIdleTimeMillis == null) {
-            perUserSoftMinEvictableIdleTimeMillis = new HashMap<>();
+    public boolean getPerUserTestOnBorrow(final String userName) {
+        Boolean value = null;
+        if (perUserTestOnBorrow != null) {
+            value = perUserTestOnBorrow.get(userName);
         }
-        perUserSoftMinEvictableIdleTimeMillis.put(username, value);
-    }
-
-    void setPerUserSoftMinEvictableIdleTimeMillis(
-            final Map<String,Long> userDefaultSoftMinEvictableIdleTimeMillis) {
-        assertInitializationAllowed();
-        if (perUserSoftMinEvictableIdleTimeMillis == null) {
-            perUserSoftMinEvictableIdleTimeMillis = new HashMap<>();
-        } else {
-            perUserSoftMinEvictableIdleTimeMillis.clear();
+        if (value == null) {
+            return getDefaultTestOnBorrow();
         }
-        perUserSoftMinEvictableIdleTimeMillis.putAll(userDefaultSoftMinEvictableIdleTimeMillis);
+        return value.booleanValue();
     }
 
-
     /**
-     * Gets the user specific value for
-     * {@link GenericObjectPool#getTestOnCreate()} for the
-     * specified user's pool or the default if no user specific value is defined.
-     * @param key The user
-     * @return <code>true</code> to test on create
+     * Gets the user specific value for {@link GenericObjectPool#getTestOnCreate()} for the specified user's pool or the
+     * default if no user specific value is defined.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public boolean getPerUserTestOnCreate(final String key) {
+    public boolean getPerUserTestOnCreate(final String userName) {
         Boolean value = null;
         if (perUserTestOnCreate != null) {
-            value = perUserTestOnCreate.get(key);
+            value = perUserTestOnCreate.get(userName);
         }
         if (value == null) {
             return getDefaultTestOnCreate();
@@ -586,459 +460,708 @@ public class PerUserPoolDataSource extends InstanceKeyDataSource {
     }
 
     /**
-     * Sets a user specific value for
-     * {@link GenericObjectPool#getTestOnCreate()} for the specified
-     * user's pool.
-     * @param username The user
-     * @param value The value
+     * Gets the user specific value for {@link GenericObjectPool#getTestOnReturn()} for the specified user's pool or the
+     * default if no user specific value is defined.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public void setPerUserTestOnCreate(final String username, final Boolean value) {
-        assertInitializationAllowed();
-        if (perUserTestOnCreate == null) {
-            perUserTestOnCreate = new HashMap<>();
+    public boolean getPerUserTestOnReturn(final String userName) {
+        Boolean value = null;
+        if (perUserTestOnReturn != null) {
+            value = perUserTestOnReturn.get(userName);
         }
-        perUserTestOnCreate.put(username, value);
-    }
-
-    void setPerUserTestOnCreate(final Map<String,Boolean> userDefaultTestOnCreate) {
-        assertInitializationAllowed();
-        if (perUserTestOnCreate == null) {
-            perUserTestOnCreate = new HashMap<>();
-        } else {
-            perUserTestOnCreate.clear();
+        if (value == null) {
+            return getDefaultTestOnReturn();
         }
-        perUserTestOnCreate.putAll(userDefaultTestOnCreate);
+        return value.booleanValue();
     }
 
-
     /**
-     * Gets the user specific value for
-     * {@link GenericObjectPool#getTestOnBorrow()} for the
-     * specified user's pool or the default if no user specific value is defined.
-     * @param key The user
-     * @return <code>true</code> to test on borrow
+     * Gets the user specific value for {@link GenericObjectPool#getTestWhileIdle()} for the specified user's pool or
+     * the default if no user specific value is defined.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public boolean getPerUserTestOnBorrow(final String key) {
+    public boolean getPerUserTestWhileIdle(final String userName) {
         Boolean value = null;
-        if (perUserTestOnBorrow != null) {
-            value = perUserTestOnBorrow.get(key);
+        if (perUserTestWhileIdle != null) {
+            value = perUserTestWhileIdle.get(userName);
         }
         if (value == null) {
-            return getDefaultTestOnBorrow();
+            return getDefaultTestWhileIdle();
         }
         return value.booleanValue();
     }
 
     /**
-     * Sets a user specific value for
-     * {@link GenericObjectPool#getTestOnBorrow()} for the specified
-     * user's pool.
-     * @param username The user
-     * @param value The value
+     * Gets the user specific value for {@link GenericObjectPool#getTimeBetweenEvictionRunsMillis()} for the specified
+     * user's pool or the default if no user specific value is defined.
+     *
+     * @param userName
+     *            The user name key.
+     * @return The user specific value.
      */
-    public void setPerUserTestOnBorrow(final String username, final Boolean value) {
-        assertInitializationAllowed();
-        if (perUserTestOnBorrow == null) {
-            perUserTestOnBorrow = new HashMap<>();
+    public long getPerUserTimeBetweenEvictionRunsMillis(final String userName) {
+        Long value = null;
+        if (perUserTimeBetweenEvictionRunsMillis != null) {
+            value = perUserTimeBetweenEvictionRunsMillis.get(userName);
+        }
+        if (value == null) {
+            return getDefaultTimeBetweenEvictionRunsMillis();
         }
-        perUserTestOnBorrow.put(username, value);
+        return value.longValue();
     }
 
-    void setPerUserTestOnBorrow(final Map<String,Boolean> userDefaultTestOnBorrow) {
-        assertInitializationAllowed();
-        if (perUserTestOnBorrow == null) {
-            perUserTestOnBorrow = new HashMap<>();
-        } else {
-            perUserTestOnBorrow.clear();
+    /**
+     * Returns the object pool associated with the given PoolKey.
+     *
+     * @param poolKey
+     *            PoolKey identifying the pool
+     * @return the GenericObjectPool pooling connections for the userName and datasource specified by the PoolKey
+     */
+    private ObjectPool<PooledConnectionAndInfo> getPool(final PoolKey poolKey) {
+        final CPDSConnectionFactory mgr = (CPDSConnectionFactory) managers.get(poolKey);
+        return mgr == null ? null : mgr.getPool();
+    }
+
+    @Override
+    protected PooledConnectionAndInfo getPooledConnectionAndInfo(final String userName, final String password)
+            throws SQLException {
+
+        final PoolKey key = getPoolKey(userName);
+        ObjectPool<PooledConnectionAndInfo> pool;
+        PooledConnectionManager manager;
+        synchronized (this) {
+            manager = managers.get(key);
+            if (manager == null) {
+                try {
+                    registerPool(userName, password);
+                    manager = managers.get(key);
+                } catch (final NamingException e) {
+                    throw new SQLException("RegisterPool failed", e);
+                }
+            }
+            pool = getCPDSConnectionFactoryPool(manager);
         }
-        perUserTestOnBorrow.putAll(userDefaultTestOnBorrow);
+
+        PooledConnectionAndInfo info = null;
+        try {
+            info = pool.borrowObject();
+        } catch (final NoSuchElementException ex) {
+            throw new SQLException("Could not retrieve connection info from pool", ex);
+        } catch (final Exception e) {
+            // See if failure is due to CPDSConnectionFactory authentication failure
+            try {
+                testCPDS(userName, password);
+            } catch (final Exception ex) {
+                throw new SQLException("Could not retrieve connection info from pool", ex);
+            }
+            // New password works, so kill the old pool, create a new one, and borrow
+            manager.closePool(userName);
+            synchronized (this) {
+                managers.remove(key);
+            }
+            try {
+                registerPool(userName, password);
+                pool = getPool(key);
+            } catch (final NamingException ne) {
+                throw new SQLException("RegisterPool failed", ne);
+            }
+            try {
+                info = pool.borrowObject();
+            } catch (final Exception ex) {
+                throw new SQLException("Could not retrieve connection info from pool", ex);
+            }
+        }
+        return info;
     }
 
+    /**
+     * Creates a pool key from the provided parameters.
+     *
+     * @param userName
+     *            User name
+     * @return The pool key
+     */
+    private PoolKey getPoolKey(final String userName) {
+        return new PoolKey(getDataSourceName(), userName);
+    }
 
     /**
-     * Gets the user specific value for
-     * {@link GenericObjectPool#getTestOnReturn()} for the
-     * specified user's pool or the default if no user specific value is defined.
-     * @param key The user
-     * @return <code>true</code> to test on return
+     * Returns a <code>PerUserPoolDataSource</code> {@link Reference}.
      */
-    public boolean getPerUserTestOnReturn(final String key) {
-        Boolean value = null;
-        if (perUserTestOnReturn != null) {
-            value = perUserTestOnReturn.get(key);
+    @Override
+    public Reference getReference() throws NamingException {
+        final Reference ref = new Reference(getClass().getName(), PerUserPoolDataSourceFactory.class.getName(), null);
+        ref.add(new StringRefAddr("instanceKey", getInstanceKey()));
+        return ref;
+    }
+
+    /**
+     * Supports Serialization interface.
+     *
+     * @param in
+     *            a <code>java.io.ObjectInputStream</code> value
+     * @throws IOException
+     *             if an error occurs
+     * @throws ClassNotFoundException
+     *             if an error occurs
+     */
+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {
+        try {
+            in.defaultReadObject();
+            final PerUserPoolDataSource oldDS = (PerUserPoolDataSource) new PerUserPoolDataSourceFactory()
+                    .getObjectInstance(getReference(), null, null, null);
+            this.managers = oldDS.managers;
+        } catch (final NamingException e) {
+            throw new IOException("NamingException: " + e);
         }
-        if (value == null) {
-            return getDefaultTestOnReturn();
+    }
+
+    private synchronized void registerPool(final String userName, final String password)
+            throws NamingException, SQLException {
+
+        final ConnectionPoolDataSource cpds = testCPDS(userName, password);
+
+        // Set up the factory we will use (passing the pool associates
+        // the factory with the pool, so we do not have to do so
+        // explicitly)
+        final CPDSConnectionFactory factory = new CPDSConnectionFactory(cpds, getValidationQuery(),
+                getValidationQueryTimeout(), isRollbackAfterValidation(), userName, password);
+        factory.setMaxConnLifetimeMillis(getMaxConnLifetimeMillis());
+
+        // Create an object pool to contain our PooledConnections
+        final GenericObjectPool<PooledConnectionAndInfo> pool = new GenericObjectPool<>(factory);
+        factory.setPool(pool);
+        pool.setBlockWhenExhausted(getPerUserBlockWhenExhausted(userName));
+        pool.setEvictionPolicyClassName(getPerUserEvictionPolicyClassName(userName));
+        pool.setLifo(getPerUserLifo(userName));
+        pool.setMaxIdle(getPerUserMaxIdle(userName));
+        pool.setMaxTotal(getPerUserMaxTotal(userName));
+        pool.setMaxWaitMillis(getPerUserMaxWaitMillis(userName));
+        pool.setMinEvictableIdleTimeMillis(getPerUserMinEvictableIdleTimeMillis(userName));
+        pool.setMinIdle(getPerUserMinIdle(userName));
+        pool.setNumTestsPerEvictionRun(getPerUserNumTestsPerEvictionRun(userName));
+        pool.setSoftMinEvictableIdleTimeMillis(getPerUserSoftMinEvictableIdleTimeMillis(userName));
+        pool.setTestOnCreate(getPerUserTestOnCreate(userName));
+        pool.setTestOnBorrow(getPerUserTestOnBorrow(userName));
+        pool.setTestOnReturn(getPerUserTestOnReturn(userName));
+        pool.setTestWhileIdle(getPerUserTestWhileIdle(userName));
+        pool.setTimeBetweenEvictionRunsMillis(getPerUserTimeBetweenEvictionRunsMillis(userName));
+
+        pool.setSwallowedExceptionListener(new SwallowedExceptionLogger(log));
+
+        final Object old = managers.put(getPoolKey(userName), factory);
+        if (old != null) {
+            throw new IllegalStateException("Pool already contains an entry for this user/password: " + userName);
         }
-        return value.booleanValue();
+    }
+
+    void setPerUserBlockWhenExhausted(final Map<String, Boolean> userDefaultBlockWhenExhausted) {
+        assertInitializationAllowed();
+        if (perUserBlockWhenExhausted == null) {
+            perUserBlockWhenExhausted = createMap();
+        } else {
+            perUserBlockWhenExhausted.clear();
+        }
+        perUserBlockWhenExhausted.putAll(userDefaultBlockWhenExhausted);
     }
 
     /**
-     * Sets a user specific value for
-     * {@link GenericObjectPool#getTestOnReturn()} for the specified
-     * user's pool.
-     * @param username The user
-     * @param value The value
+     * Sets a user specific value for {@link GenericObjectPool#getBlockWhenExhausted()} for the specified user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
      */
-    public void setPerUserTestOnReturn(final String username, final Boolean value) {
+    public void setPerUserBlockWhenExhausted(final String userName, final Boolean value) {
         assertInitializationAllowed();
-        if (perUserTestOnReturn == null) {
-            perUserTestOnReturn = new HashMap<>();
+        if (perUserBlockWhenExhausted == null) {
+            perUserBlockWhenExhausted = createMap();
         }
-        perUserTestOnReturn.put(username, value);
+        perUserBlockWhenExhausted.put(userName, value);
     }
 
-    void setPerUserTestOnReturn(
-            final Map<String,Boolean> userDefaultTestOnReturn) {
+    void setPerUserDefaultAutoCommit(final Map<String, Boolean> userDefaultAutoCommit) {
         assertInitializationAllowed();
-        if (perUserTestOnReturn == null) {
-            perUserTestOnReturn = new HashMap<>();
+        if (perUserDefaultAutoCommit == null) {
+            perUserDefaultAutoCommit = createMap();
         } else {
-            perUserTestOnReturn.clear();
+            perUserDefaultAutoCommit.clear();
         }
-        perUserTestOnReturn.putAll(userDefaultTestOnReturn);
+        perUserDefaultAutoCommit.putAll(userDefaultAutoCommit);
     }
 
-
     /**
-     * Gets the user specific value for
-     * {@link GenericObjectPool#getTestWhileIdle()} for the
-     * specified user's pool or the default if no user specific value is defined.
-     * @param key The user
-     * @return <code>true</code> to test while idle
+     * Sets a user specific default value for {@link Connection#setAutoCommit(boolean)} for the specified user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
      */
-    public boolean getPerUserTestWhileIdle(final String key) {
-        Boolean value = null;
-        if (perUserTestWhileIdle != null) {
-            value = perUserTestWhileIdle.get(key);
+    public void setPerUserDefaultAutoCommit(final String userName, final Boolean value) {
+        assertInitializationAllowed();
+        if (perUserDefaultAutoCommit == null) {
+            perUserDefaultAutoCommit = createMap();
         }
-        if (value == null) {
-            return getDefaultTestWhileIdle();
+        perUserDefaultAutoCommit.put(userName, value);
+    }
+
+    void setPerUserDefaultReadOnly(final Map<String, Boolean> userDefaultReadOnly) {
+        assertInitializationAllowed();
+        if (perUserDefaultReadOnly == null) {
+            perUserDefaultReadOnly = createMap();
+        } else {
+            perUserDefaultReadOnly.clear();
         }
-        return value.booleanValue();
+        perUserDefaultReadOnly.putAll(userDefaultReadOnly);
     }
 
     /**
-     * Sets a user specific value for
-     * {@link GenericObjectPool#getTestWhileIdle()} for the specified
-     * user's pool.
-     * @param username The user
-     * @param value The value
+     * Sets a user specific default value for {@link Connection#setReadOnly(boolean)} for the specified user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
      */
-    public void setPerUserTestWhileIdle(final String username, final Boolean value) {
+    public void setPerUserDefaultReadOnly(final String userName, final Boolean value) {
         assertInitializationAllowed();
-        if (perUserTestWhileIdle == null) {
-            perUserTestWhileIdle = new HashMap<>();
+        if (perUserDefaultReadOnly == null) {
+            perUserDefaultReadOnly = createMap();
         }
-        perUserTestWhileIdle.put(username, value);
+        perUserDefaultReadOnly.put(userName, value);
     }
 
-    void setPerUserTestWhileIdle(
-            final Map<String,Boolean> userDefaultTestWhileIdle) {
+    void setPerUserDefaultTransactionIsolation(final Map<String, Integer> userDefaultTransactionIsolation) {
         assertInitializationAllowed();
-        if (perUserTestWhileIdle == null) {
-            perUserTestWhileIdle = new HashMap<>();
+        if (perUserDefaultTransactionIsolation == null) {
+            perUserDefaultTransactionIsolation = new HashMap<>();
         } else {
-            perUserTestWhileIdle.clear();
+            perUserDefaultTransactionIsolation.clear();
         }
-        perUserTestWhileIdle.putAll(userDefaultTestWhileIdle);
+        perUserDefaultTransactionIsolation.putAll(userDefaultTransactionIsolation);
     }
 
-
     /**
-     * Gets the user specific value for
-     * {@link GenericObjectPool#getTimeBetweenEvictionRunsMillis()} for the
-     * specified user's pool or the default if no user specific value is defined.
-     * @param key The user
-     * @return time between eviction runs
+     * Sets a user specific default value for {@link Connection#setTransactionIsolation(int)} for the specified user's
+     * pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
      */
-    public long getPerUserTimeBetweenEvictionRunsMillis(final String key) {
-        Long value = null;
-        if (perUserTimeBetweenEvictionRunsMillis != null) {
-            value = perUserTimeBetweenEvictionRunsMillis.get(key);
+    public void setPerUserDefaultTransactionIsolation(final String userName, final Integer value) {
+        assertInitializationAllowed();
+        if (perUserDefaultTransactionIsolation == null) {
+            perUserDefaultTransactionIsolation = new HashMap<>();
         }
-        if (value == null) {
-            return getDefaultTimeBetweenEvictionRunsMillis();
+        perUserDefaultTransactionIsolation.put(userName, value);
+    }
+
+    void setPerUserEvictionPolicyClassName(final Map<String, String> userDefaultEvictionPolicyClassName) {
+        assertInitializationAllowed();
+        if (perUserEvictionPolicyClassName == null) {
+            perUserEvictionPolicyClassName = new HashMap<>();
+        } else {
+            perUserEvictionPolicyClassName.clear();
         }
-        return value.longValue();
+        perUserEvictionPolicyClassName.putAll(userDefaultEvictionPolicyClassName);
     }
 
     /**
-     * Sets a user specific value for
-     * {@link GenericObjectPool#getTimeBetweenEvictionRunsMillis ()} for the specified
-     * user's pool.
-     * @param username The user
-     * @param value The value
+     * Sets a user specific value for {@link GenericObjectPool#getEvictionPolicyClassName()} for the specified user's
+     * pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
      */
-    public void setPerUserTimeBetweenEvictionRunsMillis(final String username,
-            final Long value) {
+    public void setPerUserEvictionPolicyClassName(final String userName, final String value) {
         assertInitializationAllowed();
-        if (perUserTimeBetweenEvictionRunsMillis == null) {
-            perUserTimeBetweenEvictionRunsMillis = new HashMap<>();
+        if (perUserEvictionPolicyClassName == null) {
+            perUserEvictionPolicyClassName = new HashMap<>();
         }
-        perUserTimeBetweenEvictionRunsMillis.put(username, value);
+        perUserEvictionPolicyClassName.put(userName, value);
     }
 
-    void setPerUserTimeBetweenEvictionRunsMillis(
-            final Map<String,Long> userDefaultTimeBetweenEvictionRunsMillis ) {
+    void setPerUserLifo(final Map<String, Boolean> userDefaultLifo) {
         assertInitializationAllowed();
-        if (perUserTimeBetweenEvictionRunsMillis == null) {
-            perUserTimeBetweenEvictionRunsMillis = new HashMap<>();
+        if (perUserLifo == null) {
+            perUserLifo = createMap();
         } else {
-            perUserTimeBetweenEvictionRunsMillis.clear();
+            perUserLifo.clear();
         }
-        perUserTimeBetweenEvictionRunsMillis.putAll(
-                userDefaultTimeBetweenEvictionRunsMillis );
+        perUserLifo.putAll(userDefaultLifo);
     }
 
-
     /**
-     * Gets the user specific default value for
-     * {@link Connection#setAutoCommit(boolean)} for the specified user's pool.
-     * @param key The user
-     * @return <code>true</code> to commit automatically
+     * Sets a user specific value for {@link GenericObjectPool#getLifo()} for the specified user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
      */
-    public Boolean getPerUserDefaultAutoCommit(final String key) {
-        Boolean value = null;
-        if (perUserDefaultAutoCommit != null) {
-            value = perUserDefaultAutoCommit.get(key);
+    public void setPerUserLifo(final String userName, final Boolean value) {
+        assertInitializationAllowed();
+        if (perUserLifo == null) {
+            perUserLifo = createMap();
         }
-        return value;
+        perUserLifo.put(userName, value);
+    }
+
+    void setPerUserMaxIdle(final Map<String, Integer> userDefaultMaxIdle) {
+        assertInitializationAllowed();
+        if (perUserMaxIdle == null) {
+            perUserMaxIdle = new HashMap<>();
+        } else {
+            perUserMaxIdle.clear();
+        }
+        perUserMaxIdle.putAll(userDefaultMaxIdle);
     }
 
     /**
-     * Sets a user specific default value for
-     * {@link Connection#setAutoCommit(boolean)} for the specified user's pool.
-     * @param username The user
-     * @param value The value
+     * Sets a user specific value for {@link GenericObjectPool#getMaxIdle()} for the specified user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
      */
-    public void setPerUserDefaultAutoCommit(final String username, final Boolean value) {
+    public void setPerUserMaxIdle(final String userName, final Integer value) {
         assertInitializationAllowed();
-        if (perUserDefaultAutoCommit == null) {
-            perUserDefaultAutoCommit = new HashMap<>();
+        if (perUserMaxIdle == null) {
+            perUserMaxIdle = new HashMap<>();
         }
-        perUserDefaultAutoCommit.put(username, value);
+        perUserMaxIdle.put(userName, value);
     }
 
-    void setPerUserDefaultAutoCommit(final Map<String,Boolean> userDefaultAutoCommit) {
+    void setPerUserMaxTotal(final Map<String, Integer> userDefaultMaxTotal) {
         assertInitializationAllowed();
-        if (perUserDefaultAutoCommit == null) {
-            perUserDefaultAutoCommit = new HashMap<>();
+        if (perUserMaxTotal == null) {
+            perUserMaxTotal = new HashMap<>();
         } else {
-            perUserDefaultAutoCommit.clear();
+            perUserMaxTotal.clear();
         }
-        perUserDefaultAutoCommit.putAll(userDefaultAutoCommit);
+        perUserMaxTotal.putAll(userDefaultMaxTotal);
     }
 
-
     /**
-     * Gets the user specific default value for
-     * {@link Connection#setReadOnly(boolean)} for the specified user's pool.
-     * @param key The user
-     * @return <code>true</code> is read only by default
+     * Sets a user specific value for {@link GenericObjectPool#getMaxTotal()} for the specified user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
      */
-    public Boolean getPerUserDefaultReadOnly(final String key) {
-        Boolean value = null;
-        if (perUserDefaultReadOnly != null) {
-            value = perUserDefaultReadOnly.get(key);
+    public void setPerUserMaxTotal(final String userName, final Integer value) {
+        assertInitializationAllowed();
+        if (perUserMaxTotal == null) {
+            perUserMaxTotal = new HashMap<>();
         }
-        return value;
+        perUserMaxTotal.put(userName, value);
+    }
+
+    void setPerUserMaxWaitMillis(final Map<String, Long> userDefaultMaxWaitMillis) {
+        assertInitializationAllowed();
+        if (perUserMaxWaitMillis == null) {
+            perUserMaxWaitMillis = new HashMap<>();
+        } else {
+            perUserMaxWaitMillis.clear();
+        }
+        perUserMaxWaitMillis.putAll(userDefaultMaxWaitMillis);
     }
 
     /**
-     * Sets a user specific default value for
-     * {@link Connection#setReadOnly(boolean)} for the specified user's pool.
-     * @param username The user
-     * @param value The value
+     * Sets a user specific value for {@link GenericObjectPool#getMaxWaitMillis()} for the specified user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
      */
-    public void setPerUserDefaultReadOnly(final String username, final Boolean value) {
+    public void setPerUserMaxWaitMillis(final String userName, final Long value) {
         assertInitializationAllowed();
-        if (perUserDefaultReadOnly == null) {
-            perUserDefaultReadOnly = new HashMap<>();
+        if (perUserMaxWaitMillis == null) {
+            perUserMaxWaitMillis = new HashMap<>();
         }
-        perUserDefaultReadOnly.put(username, value);
+        perUserMaxWaitMillis.put(userName, value);
     }
 
-    void setPerUserDefaultReadOnly(final Map<String,Boolean> userDefaultReadOnly) {
+    void setPerUserMinEvictableIdleTimeMillis(final Map<String, Long> userDefaultMinEvictableIdleTimeMillis) {
         assertInitializationAllowed();
-        if (perUserDefaultReadOnly == null) {
-            perUserDefaultReadOnly = new HashMap<>();
+        if (perUserMinEvictableIdleTimeMillis == null) {
+            perUserMinEvictableIdleTimeMillis = new HashMap<>();
         } else {
-            perUserDefaultReadOnly.clear();
+            perUserMinEvictableIdleTimeMillis.clear();
         }
-        perUserDefaultReadOnly.putAll(userDefaultReadOnly);
+        perUserMinEvictableIdleTimeMillis.putAll(userDefaultMinEvictableIdleTimeMillis);
     }
 
-
     /**
-     * Gets the user specific default value for
-     * {@link Connection#setTransactionIsolation(int)} for the specified user's pool.
-     * @param key The user
-     * @return the default transaction isolation
+     * Sets a user specific value for {@link GenericObjectPool#getMinEvictableIdleTimeMillis()} for the specified user's
+     * pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
      */
-    public Integer getPerUserDefaultTransactionIsolation(final String key) {
-        Integer value = null;
-        if (perUserDefaultTransactionIsolation != null) {
-            value = perUserDefaultTransactionIsolation.get(key);
+    public void setPerUserMinEvictableIdleTimeMillis(final String userName, final Long value) {
+        assertInitializationAllowed();
+        if (perUserMinEvictableIdleTimeMillis == null) {
+            perUserMinEvictableIdleTimeMillis = new HashMap<>();
         }
-        return value;
+        perUserMinEvictableIdleTimeMillis.put(userName, value);
+    }
+
+    void setPerUserMinIdle(final Map<String, Integer> userDefaultMinIdle) {
+        assertInitializationAllowed();
+        if (perUserMinIdle == null) {
+            perUserMinIdle = new HashMap<>();
+        } else {
+            perUserMinIdle.clear();
+        }
+        perUserMinIdle.putAll(userDefaultMinIdle);
     }
 
     /**
-     * Sets a user specific default value for
-     * {@link Connection#setTransactionIsolation(int)} for the specified user's pool.
-     * @param username The user
-     * @param value The value
+     * Sets a user specific value for {@link GenericObjectPool#getMinIdle()} for the specified user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
      */
-    public void setPerUserDefaultTransactionIsolation(final String username,
-            final Integer value) {
+    public void setPerUserMinIdle(final String userName, final Integer value) {
         assertInitializationAllowed();
-        if (perUserDefaultTransactionIsolation == null) {
-            perUserDefaultTransactionIsolation = new HashMap<>();
+        if (perUserMinIdle == null) {
+            perUserMinIdle = new HashMap<>();
         }
-        perUserDefaultTransactionIsolation.put(username, value);
+        perUserMinIdle.put(userName, value);
     }
 
-    void setPerUserDefaultTransactionIsolation(
-            final Map<String,Integer> userDefaultTransactionIsolation) {
+    void setPerUserNumTestsPerEvictionRun(final Map<String, Integer> userDefaultNumTestsPerEvictionRun) {
         assertInitializationAllowed();
-        if (perUserDefaultTransactionIsolation == null) {
-            perUserDefaultTransactionIsolation = new HashMap<>();
+        if (perUserNumTestsPerEvictionRun == null) {
+            perUserNumTestsPerEvictionRun = new HashMap<>();
         } else {
-            perUserDefaultTransactionIsolation.clear();
+            perUserNumTestsPerEvictionRun.clear();
         }
-        perUserDefaultTransactionIsolation.putAll(userDefaultTransactionIsolation);
+        perUserNumTestsPerEvictionRun.putAll(userDefaultNumTestsPerEvictionRun);
     }
 
-
-    // ----------------------------------------------------------------------
-    // Instrumentation Methods
-
     /**
-     * @return the number of active connections in the default pool.
+     * Sets a user specific value for {@link GenericObjectPool#getNumTestsPerEvictionRun()} for the specified user's
+     * pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
      */
-    public int getNumActive() {
-        return getNumActive(null);
+    public void setPerUserNumTestsPerEvictionRun(final String userName, final Integer value) {
+        assertInitializationAllowed();
+        if (perUserNumTestsPerEvictionRun == null) {
+            perUserNumTestsPerEvictionRun = new HashMap<>();
+        }
+        perUserNumTestsPerEvictionRun.put(userName, value);
+    }
+
+    void setPerUserSoftMinEvictableIdleTimeMillis(final Map<String, Long> userDefaultSoftMinEvictableIdleTimeMillis) {
+        assertInitializationAllowed();
+        if (perUserSoftMinEvictableIdleTimeMillis == null) {
+            perUserSoftMinEvictableIdleTimeMillis = new HashMap<>();
+        } else {
+            perUserSoftMinEvictableIdleTimeMillis.clear();
+        }
+        perUserSoftMinEvictableIdleTimeMillis.putAll(userDefaultSoftMinEvictableIdleTimeMillis);
     }
 
     /**
-     * @param username The user
-     * @return the number of active connections in the pool for a given user.
+     * Sets a user specific value for {@link GenericObjectPool#getSoftMinEvictableIdleTimeMillis()} for the specified
+     * user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
      */
-    public int getNumActive(final String username) {
-        final ObjectPool<PooledConnectionAndInfo> pool =
-            getPool(getPoolKey(username));
-        return pool == null ? 0 : pool.getNumActive();
+    public void setPerUserSoftMinEvictableIdleTimeMillis(final String userName, final Long value) {
+        assertInitializationAllowed();
+        if (perUserSoftMinEvictableIdleTimeMillis == null) {
+            perUserSoftMinEvictableIdleTimeMillis = new HashMap<>();
+        }
+        perUserSoftMinEvictableIdleTimeMillis.put(userName, value);
+    }
+
+    void setPerUserTestOnBorrow(final Map<String, Boolean> userDefaultTestOnBorrow) {
+        assertInitializationAllowed();
+        if (perUserTestOnBorrow == null) {
+            perUserTestOnBorrow = createMap();
+        } else {
+            perUserTestOnBorrow.clear();
+        }
+        perUserTestOnBorrow.putAll(userDefaultTestOnBorrow);
     }
 
     /**
-     * @return the number of idle connections in the default pool.
+     * Sets a user specific value for {@link GenericObjectPool#getTestOnBorrow()} for the specified user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
      */
-    public int getNumIdle() {
-        return getNumIdle(null);
+    public void setPerUserTestOnBorrow(final String userName, final Boolean value) {
+        assertInitializationAllowed();
+        if (perUserTestOnBorrow == null) {
+            perUserTestOnBorrow = createMap();
+        }
+        perUserTestOnBorrow.put(userName, value);
+    }
+
+    void setPerUserTestOnCreate(final Map<String, Boolean> userDefaultTestOnCreate) {
+        assertInitializationAllowed();
+        if (perUserTestOnCreate == null) {
+            perUserTestOnCreate = createMap();
+        } else {
+            perUserTestOnCreate.clear();
+        }
+        perUserTestOnCreate.putAll(userDefaultTestOnCreate);
     }
 
     /**
-     * @param username The user
-     * @return the number of idle connections in the pool for a given user.
+     * Sets a user specific value for {@link GenericObjectPool#getTestOnCreate()} for the specified user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
      */
-    public int getNumIdle(final String username) {
-        final ObjectPool<PooledConnectionAndInfo> pool =
-            getPool(getPoolKey(username));
-        return pool == null ? 0 : pool.getNumIdle();
+    public void setPerUserTestOnCreate(final String userName, final Boolean value) {
+        assertInitializationAllowed();
+        if (perUserTestOnCreate == null) {
+            perUserTestOnCreate = createMap();
+        }
+        perUserTestOnCreate.put(userName, value);
     }
 
+    void setPerUserTestOnReturn(final Map<String, Boolean> userDefaultTestOnReturn) {
+        assertInitializationAllowed();
+        if (perUserTestOnReturn == null) {
+            perUserTestOnReturn = createMap();
+        } else {
+            perUserTestOnReturn.clear();
+        }
+        perUserTestOnReturn.putAll(userDefaultTestOnReturn);
+    }
 
-    // ----------------------------------------------------------------------
-    // Inherited abstract methods
-
-    @Override
-    protected PooledConnectionAndInfo
-        getPooledConnectionAndInfo(final String username, final String password)
-        throws SQLException {
+    /**
+     * Sets a user specific value for {@link GenericObjectPool#getTestOnReturn()} for the specified user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
+     */
+    public void setPerUserTestOnReturn(final String userName, final Boolean value) {
+        assertInitializationAllowed();
+        if (perUserTestOnReturn == null) {
+            perUserTestOnReturn = createMap();
+        }
+        perUserTestOnReturn.put(userName, value);
+    }
 
-        final PoolKey key = getPoolKey(username);
-        ObjectPool<PooledConnectionAndInfo> pool;
-        PooledConnectionManager manager;
-        synchronized(this) {
-            manager = managers.get(key);
-            if (manager == null) {
-                try {
-                    registerPool(username, password);
-                    manager = managers.get(key);
-                } catch (final NamingException e) {
-                    throw new SQLException("RegisterPool failed", e);
-                }
-            }
-            pool = ((CPDSConnectionFactory) manager).getPool();
+    void setPerUserTestWhileIdle(final Map<String, Boolean> userDefaultTestWhileIdle) {
+        assertInitializationAllowed();
+        if (perUserTestWhileIdle == null) {
+            perUserTestWhileIdle = createMap();
+        } else {
+            perUserTestWhileIdle.clear();
         }
+        perUserTestWhileIdle.putAll(userDefaultTestWhileIdle);
+    }
 
-        PooledConnectionAndInfo info = null;
-        try {
-            info = pool.borrowObject();
+    /**
+     * Sets a user specific value for {@link GenericObjectPool#getTestWhileIdle()} for the specified user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
+     */
+    public void setPerUserTestWhileIdle(final String userName, final Boolean value) {
+        assertInitializationAllowed();
+        if (perUserTestWhileIdle == null) {
+            perUserTestWhileIdle = createMap();
         }
-        catch (final NoSuchElementException ex) {
-            throw new SQLException(
-                    "Could not retrieve connection info from pool", ex);
+        perUserTestWhileIdle.put(userName, value);
+    }
+
+    void setPerUserTimeBetweenEvictionRunsMillis(final Map<String, Long> userDefaultTimeBetweenEvictionRunsMillis) {
+        assertInitializationAllowed();
+        if (perUserTimeBetweenEvictionRunsMillis == null) {
+            perUserTimeBetweenEvictionRunsMillis = new HashMap<>();
+        } else {
+            perUserTimeBetweenEvictionRunsMillis.clear();
         }
-        catch (final Exception e) {
-            // See if failure is due to CPDSConnectionFactory authentication failure
-            try {
-                testCPDS(username, password);
-            } catch (final Exception ex) {
-                throw new SQLException(
-                        "Could not retrieve connection info from pool", ex);
-            }
-            // New password works, so kill the old pool, create a new one, and borrow
-            manager.closePool(username);
-            synchronized (this) {
-                managers.remove(key);
-            }
-            try {
-                registerPool(username, password);
-                pool = getPool(key);
-            } catch (final NamingException ne) {
-                throw new SQLException("RegisterPool failed", ne);
-            }
-            try {
-                info = pool.borrowObject();
-            } catch (final Exception ex) {
-                throw new SQLException(
-                        "Could not retrieve connection info from pool", ex);
-            }
+        perUserTimeBetweenEvictionRunsMillis.putAll(userDefaultTimeBetweenEvictionRunsMillis);
+    }
+
+    /**
+     * Sets a user specific value for {@link GenericObjectPool#getTimeBetweenEvictionRunsMillis ()} for the specified
+     * user's pool.
+     *
+     * @param userName
+     *            The user name key.
+     * @param value
+     *            The user specific value.
+     */
+    public void setPerUserTimeBetweenEvictionRunsMillis(final String userName, final Long value) {
+        assertInitializationAllowed();
+        if (perUserTimeBetweenEvictionRunsMillis == null) {
+            perUserTimeBetweenEvictionRunsMillis = new HashMap<>();
         }
-        return info;
+        perUserTimeBetweenEvictionRunsMillis.put(userName, value);
     }
 
     @Override
-    protected void setupDefaults(final Connection con, final String username)
-        throws SQLException {
+    protected void setupDefaults(final Connection con, final String userName) throws SQLException {
         Boolean defaultAutoCommit = isDefaultAutoCommit();
-        if (username != null) {
-            final Boolean userMax = getPerUserDefaultAutoCommit(username);
+        if (userName != null) {
+            final Boolean userMax = getPerUserDefaultAutoCommit(userName);
             if (userMax != null) {
                 defaultAutoCommit = userMax;
             }
         }
 
         Boolean defaultReadOnly = isDefaultReadOnly();
-        if (username != null) {
-            final Boolean userMax = getPerUserDefaultReadOnly(username);
+        if (userName != null) {
+            final Boolean userMax = getPerUserDefaultReadOnly(userName);
             if (userMax != null) {
                 defaultReadOnly = userMax;
             }
         }
 
         int defaultTransactionIsolation = getDefaultTransactionIsolation();
-        if (username != null) {
-            final Integer userMax = getPerUserDefaultTransactionIsolation(username);
+        if (userName != null) {
+            final Integer userMax = getPerUserDefaultTransactionIsolation(userName);
             if (userMax != null) {
                 defaultTransactionIsolation = userMax.intValue();
             }
         }
 
-        if (defaultAutoCommit != null &&
-                con.getAutoCommit() != defaultAutoCommit.booleanValue()) {
+        if (defaultAutoCommit != null && con.getAutoCommit() != defaultAutoCommit.booleanValue()) {
             con.setAutoCommit(defaultAutoCommit.booleanValue());
         }
 
@@ -1046,117 +1169,8 @@ public class PerUserPoolDataSource extends InstanceKeyDataSource {
             con.setTransactionIsolation(defaultTransactionIsolation);
         }
 
-        if (defaultReadOnly != null &&
-                con.isReadOnly() != defaultReadOnly.booleanValue()) {
+        if (defaultReadOnly != null && con.isReadOnly() != defaultReadOnly.booleanValue()) {
             con.setReadOnly(defaultReadOnly.booleanValue());
         }
     }
-
-    @Override
-    protected PooledConnectionManager getConnectionManager(final UserPassKey upkey) {
-        return managers.get(getPoolKey(upkey.getUsername()));
-    }
-
-    /**
-     * @return a <code>PerUserPoolDataSource</code> {@link Reference}.
-     * @throws NamingException Should not happen
-     */
-    @Override
-    public Reference getReference() throws NamingException {
-        final Reference ref = new Reference(getClass().getName(),
-                PerUserPoolDataSourceFactory.class.getName(), null);
-        ref.add(new StringRefAddr("instanceKey", getInstanceKey()));
-        return ref;
-    }
-
-    /**
-     * Create a pool key from the provided parameters.
-     *
-     * @param username  User name
-     * @return the pool key
-     */
-    private PoolKey getPoolKey(final String username) {
-        return new PoolKey(getDataSourceName(), username);
-    }
-
-    private synchronized void registerPool(final String username, final String password)
-            throws NamingException, SQLException {
-
-        final ConnectionPoolDataSource cpds = testCPDS(username, password);
-
-        // Set up the factory we will use (passing the pool associates
-        // the factory with the pool, so we do not have to do so
-        // explicitly)
-        final CPDSConnectionFactory factory = new CPDSConnectionFactory(cpds,
-                getValidationQuery(), getValidationQueryTimeout(),
-                isRollbackAfterValidation(), username, password);
-        factory.setMaxConnLifetimeMillis(getMaxConnLifetimeMillis());
-
-        // Create an object pool to contain our PooledConnections
-        final GenericObjectPool<PooledConnectionAndInfo> pool =
-                new GenericObjectPool<>(factory);
-        factory.setPool(pool);
-        pool.setBlockWhenExhausted(getPerUserBlockWhenExhausted(username));
-        pool.setEvictionPolicyClassName(
-                getPerUserEvictionPolicyClassName(username));
-        pool.setLifo(getPerUserLifo(username));
-        pool.setMaxIdle(getPerUserMaxIdle(username));
-        pool.setMaxTotal(getPerUserMaxTotal(username));
-        pool.setMaxWaitMillis(getPerUserMaxWaitMillis(username));
-        pool.setMinEvictableIdleTimeMillis(
-                getPerUserMinEvictableIdleTimeMillis(username));
-        pool.setMinIdle(getPerUserMinIdle(username));
-        pool.setNumTestsPerEvictionRun(
-                getPerUserNumTestsPerEvictionRun(username));
-        pool.setSoftMinEvictableIdleTimeMillis(
-                getPerUserSoftMinEvictableIdleTimeMillis(username));
-        pool.setTestOnCreate(getPerUserTestOnCreate(username));
-        pool.setTestOnBorrow(getPerUserTestOnBorrow(username));
-        pool.setTestOnReturn(getPerUserTestOnReturn(username));
-        pool.setTestWhileIdle(getPerUserTestWhileIdle(username));
-        pool.setTimeBetweenEvictionRunsMillis(
-                getPerUserTimeBetweenEvictionRunsMillis(username));
-
-        pool.setSwallowedExceptionListener(new SwallowedExceptionLogger(log));
-
-        final Object old = managers.put(getPoolKey(username), factory);
-        if (old != null) {
-            throw new IllegalStateException("Pool already contains an entry for this user/password: " + username);
-        }
-    }
-
-    /**
-     * Supports Serialization interface.
-     *
-     * @param in a <code>java.io.ObjectInputStream</code> value
-     * @throws IOException if an error occurs
-     * @throws ClassNotFoundException if an error occurs
-     */
-    private void readObject(final ObjectInputStream in)
-        throws IOException, ClassNotFoundException {
-        try
-        {
-            in.defaultReadObject();
-            final PerUserPoolDataSource oldDS = (PerUserPoolDataSource)
-                new PerUserPoolDataSourceFactory()
-                    .getObjectInstance(getReference(), null, null, null);
-            this.managers = oldDS.managers;
-        }
-        catch (final NamingException e)
-        {
-            throw new IOException("NamingException: " + e);
-        }
-    }
-
-    /**
-     * Returns the object pool associated with the given PoolKey.
-     *
-     * @param key PoolKey identifying the pool
-     * @return the GenericObjectPool pooling connections for the username and datasource
-     * specified by the PoolKey
-     */
-    private ObjectPool<PooledConnectionAndInfo> getPool(final PoolKey key) {
-        final CPDSConnectionFactory mgr = (CPDSConnectionFactory) managers.get(key);
-        return mgr == null ? null : mgr.getPool();
-    }
 }

==================================================
PoolKey.java
index d45396fa9d..30791a92eb 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/datasources/PerUserPoolDataSourceFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/PerUserPoolDataSourceFactory.java
@@ -28,11 +28,8 @@ import javax.naming.Reference;
  *
  * @since 2.0
  */
-public class PerUserPoolDataSourceFactory
-    extends InstanceKeyDataSourceFactory
-{
-    private static final String PER_USER_POOL_CLASSNAME =
-        PerUserPoolDataSource.class.getName();
+public class PerUserPoolDataSourceFactory extends InstanceKeyDataSourceFactory {
+    private static final String PER_USER_POOL_CLASSNAME = PerUserPoolDataSource.class.getName();
 
     @Override
     protected boolean isCorrectClass(final String className) {
@@ -41,69 +38,58 @@ public class PerUserPoolDataSourceFactory
 
     @SuppressWarnings("unchecked") // Avoid warnings on deserialization
     @Override
-    protected InstanceKeyDataSource getNewInstance(final Reference ref)
-        throws IOException, ClassNotFoundException {
-        final PerUserPoolDataSource pupds =  new PerUserPoolDataSource();
+    protected InstanceKeyDataSource getNewInstance(final Reference ref) throws IOException, ClassNotFoundException {
+        final PerUserPoolDataSource pupds = new PerUserPoolDataSource();
         RefAddr ra = ref.get("defaultMaxTotal");
         if (ra != null && ra.getContent() != null) {
-            pupds.setDefaultMaxTotal(
-                Integer.parseInt(ra.getContent().toString()));
+            pupds.setDefaultMaxTotal(Integer.parseInt(ra.getContent().toString()));
         }
 
         ra = ref.get("defaultMaxIdle");
         if (ra != null && ra.getContent() != null) {
-            pupds.setDefaultMaxIdle(
-                Integer.parseInt(ra.getContent().toString()));
+            pupds.setDefaultMaxIdle(Integer.parseInt(ra.getContent().toString()));
         }
 
         ra = ref.get("defaultMaxWaitMillis");
         if (ra != null && ra.getContent() != null) {
-            pupds.setDefaultMaxWaitMillis(
-                Integer.parseInt(ra.getContent().toString()));
+            pupds.setDefaultMaxWaitMillis(Integer.parseInt(ra.getContent().toString()));
         }
 
         ra = ref.get("perUserDefaultAutoCommit");
-        if (ra != null  && ra.getContent() != null) {
+        if (ra != null && ra.getContent() != null) {
             final byte[] serialized = (byte[]) ra.getContent();
-            pupds.setPerUserDefaultAutoCommit(
-                    (Map<String,Boolean>) deserialize(serialized));
+            pupds.setPerUserDefaultAutoCommit((Map<String, Boolean>) deserialize(serialized));
         }
 
         ra = ref.get("perUserDefaultTransactionIsolation");
-        if (ra != null  && ra.getContent() != null) {
+        if (ra != null && ra.getContent() != null) {
             final byte[] serialized = (byte[]) ra.getContent();
-            pupds.setPerUserDefaultTransactionIsolation(
-                    (Map<String,Integer>) deserialize(serialized));
+            pupds.setPerUserDefaultTransactionIsolation((Map<String, Integer>) deserialize(serialized));
         }
 
         ra = ref.get("perUserMaxTotal");
-        if (ra != null  && ra.getContent() != null) {
+        if (ra != null && ra.getContent() != null) {
             final byte[] serialized = (byte[]) ra.getContent();
-            pupds.setPerUserMaxTotal(
-                    (Map<String,Integer>) deserialize(serialized));
+            pupds.setPerUserMaxTotal((Map<String, Integer>) deserialize(serialized));
         }
 
         ra = ref.get("perUserMaxIdle");
-        if (ra != null  && ra.getContent() != null) {
+        if (ra != null && ra.getContent() != null) {
             final byte[] serialized = (byte[]) ra.getContent();
-            pupds.setPerUserMaxIdle(
-                    (Map<String,Integer>) deserialize(serialized));
+            pupds.setPerUserMaxIdle((Map<String, Integer>) deserialize(serialized));
         }
 
         ra = ref.get("perUserMaxWaitMillis");
-        if (ra != null  && ra.getContent() != null) {
+        if (ra != null && ra.getContent() != null) {
             final byte[] serialized = (byte[]) ra.getContent();
-            pupds.setPerUserMaxWaitMillis(
-                    (Map<String,Long>) deserialize(serialized));
+            pupds.setPerUserMaxWaitMillis((Map<String, Long>) deserialize(serialized));
         }
 
         ra = ref.get("perUserDefaultReadOnly");
-        if (ra != null  && ra.getContent() != null) {
+        if (ra != null && ra.getContent() != null) {
             final byte[] serialized = (byte[]) ra.getContent();
-            pupds.setPerUserDefaultReadOnly(
-                    (Map<String,Boolean>) deserialize(serialized));
+            pupds.setPerUserDefaultReadOnly((Map<String, Boolean>) deserialize(serialized));
         }
         return pupds;
     }
 }
-

==================================================
PooledConnectionAndInfo.java
index 8dcf148386..f38e04f3c0 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/datasources/PoolKey.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/PoolKey.java
@@ -25,41 +25,57 @@ import java.io.Serializable;
 class PoolKey implements Serializable {
     private static final long serialVersionUID = 2252771047542484533L;
 
-    private final String datasourceName;
-    private final String username;
+    private final String dataSourceName;
+    private final String userName;
 
-    PoolKey(final String datasourceName, final String username) {
-        this.datasourceName = datasourceName;
-        this.username = username;
+    PoolKey(final String dataSourceName, final String userName) {
+        this.dataSourceName = dataSourceName;
+        this.userName = userName;
     }
 
     @Override
     public boolean equals(final Object obj) {
-        if (obj instanceof PoolKey) {
-            final PoolKey pk = (PoolKey)obj;
-            return (null == datasourceName ? null == pk.datasourceName : datasourceName.equals(pk.datasourceName)) &&
-                (null == username ? null == pk.username : username.equals(pk.username));
+        if (this == obj) {
+            return true;
         }
-        return false;
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        final PoolKey other = (PoolKey) obj;
+        if (dataSourceName == null) {
+            if (other.dataSourceName != null) {
+                return false;
+            }
+        } else if (!dataSourceName.equals(other.dataSourceName)) {
+            return false;
+        }
+        if (userName == null) {
+            if (other.userName != null) {
+                return false;
+            }
+        } else if (!userName.equals(other.userName)) {
+            return false;
+        }
+        return true;
     }
 
     @Override
     public int hashCode() {
-        int h = 0;
-        if (datasourceName != null) {
-            h += datasourceName.hashCode();
-        }
-        if (username != null) {
-            h = 29 * h + username.hashCode();
-        }
-        return h;
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((dataSourceName == null) ? 0 : dataSourceName.hashCode());
+        result = prime * result + ((userName == null) ? 0 : userName.hashCode());
+        return result;
     }
 
     @Override
     public String toString() {
         final StringBuffer sb = new StringBuffer(50);
         sb.append("PoolKey(");
-        sb.append(username).append(", ").append(datasourceName);
+        sb.append(userName).append(", ").append(dataSourceName);
         sb.append(')');
         return sb.toString();
     }

==================================================
PooledConnectionManager.java
index 6475986ff3..1fb1ccfcb7 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/datasources/PooledConnectionAndInfo.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/PooledConnectionAndInfo.java
@@ -19,23 +19,36 @@ package org.apache.tomcat.dbcp.dbcp2.datasources;
 
 import javax.sql.PooledConnection;
 
+import org.apache.tomcat.dbcp.dbcp2.Utils;
+
 /**
- * Immutable poolable object holding a PooledConnection along with the username and password
- * used to create the connection.
+ * Immutable poolable object holding a PooledConnection along with the user name and password used to create the
+ * connection.
  *
  * @since 2.0
  */
 final class PooledConnectionAndInfo {
     private final PooledConnection pooledConnection;
-    private final String password;
-    private final String username;
-    private final UserPassKey upkey;
+    private final char[] userPassword;
+    private final String userName;
+    private final UserPassKey upKey;
 
-    PooledConnectionAndInfo(final PooledConnection pc, final String username, final String password) {
+    /**
+     * @since 2.4.0
+     */
+    PooledConnectionAndInfo(final PooledConnection pc, final String userName, final char[] userPassword) {
         this.pooledConnection = pc;
-        this.username = username;
-        this.password = password;
-        upkey = new UserPassKey(username, password);
+        this.userName = userName;
+        this.userPassword = userPassword;
+        this.upKey = new UserPassKey(userName, userPassword);
+    }
+
+    /**
+     * @deprecated Since 2.4.0
+     */
+    @Deprecated
+    PooledConnectionAndInfo(final PooledConnection pc, final String userName, final String userPassword) {
+        this(pc, userName, Utils.toCharArray(userPassword));
     }
 
     PooledConnection getPooledConnection() {
@@ -43,22 +56,34 @@ final class PooledConnectionAndInfo {
     }
 
     UserPassKey getUserPassKey() {
-        return upkey;
+        return upKey;
     }
 
     /**
-     * Get the value of password.
+     * Gets the value of password.
+     *
      * @return value of password.
      */
     String getPassword() {
-        return password;
+        return Utils.toString(userPassword);
+    }
+
+    /**
+     * Gets the value of password.
+     *
+     * @return value of password.
+     * @since 2.4.0
+     */
+    char[] getPasswordCharArray() {
+        return userPassword;
     }
 
     /**
-     * Get the value of username.
-     * @return value of username.
+     * Gets the value of userName.
+     *
+     * @return value of userName.
      */
     String getUsername() {
-        return username;
+        return userName;
     }
 }

==================================================
SharedPoolDataSource.java
index b4da094edc..fc6bff88c5 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/datasources/PooledConnectionManager.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/PooledConnectionManager.java
@@ -27,29 +27,41 @@ import javax.sql.PooledConnection;
  * @since 2.0
  */
 interface PooledConnectionManager {
+
     /**
-     * Close the PooledConnection and remove it from the connection pool
-     * to which it belongs, adjusting pool counters.
+     * Closes the PooledConnection and remove it from the connection pool to which it belongs, adjusting pool counters.
      *
-     * @param pc PooledConnection to be invalidated
-     * @throws SQLException if an SQL error occurs closing the connection
+     * @param pc
+     *            PooledConnection to be invalidated
+     * @throws SQLException
+     *             if an SQL error occurs closing the connection
      */
     void invalidate(PooledConnection pc) throws SQLException;
 
+    // /**
+    // * Sets the database password used when creating connections.
+    // *
+    // * @param password password used when authenticating to the database
+    // * @since 3.0.0
+    // */
+    // void setPassword(char[] password);
+
     /**
      * Sets the database password used when creating connections.
      *
-     * @param password password used when authenticating to the database
+     * @param password
+     *            password used when authenticating to the database
      */
     void setPassword(String password);
 
-
     /**
      * Closes the connection pool associated with the given user.
      *
-     * @param username user name
-     * @throws SQLException if an error occurs closing idle connections in the pool
+     * @param userName
+     *            user name
+     * @throws SQLException
+     *             if an error occurs closing idle connections in the pool
      */
-    void closePool(String username) throws SQLException;
+    void closePool(String userName) throws SQLException;
 
 }

==================================================
SharedPoolDataSourceFactory.java
index 2b126e3b3c..a006f4ac64 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/datasources/SharedPoolDataSource.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/SharedPoolDataSource.java
@@ -32,20 +32,20 @@ import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool;
 import org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPoolConfig;
 
 /**
- * <p>A pooling <code>DataSource</code> appropriate for deployment within
- * J2EE environment.  There are many configuration options, most of which are
- * defined in the parent class. All users (based on username) share a single
- * maximum number of Connections in this datasource.</p>
+ * <p>
+ * A pooling <code>DataSource</code> appropriate for deployment within J2EE environment. There are many configuration
+ * options, most of which are defined in the parent class. All users (based on user name) share a single maximum number
+ * of Connections in this data source.
+ * </p>
  *
- * <p>User passwords can be changed without re-initializing the datasource.
- * When a <code>getConnection(username, password)</code> request is processed
- * with a password that is different from those used to create connections in the
- * pool associated with <code>username</code>, an attempt is made to create a
- * new connection using the supplied password and if this succeeds, idle connections
- * created using the old password are destroyed and new connections are created
- * using the new password.</p>
+ * <p>
+ * User passwords can be changed without re-initializing the data source. When a
+ * <code>getConnection(user name, password)</code> request is processed with a password that is different from those
+ * used to create connections in the pool associated with <code>user name</code>, an attempt is made to create a new
+ * connection using the supplied password and if this succeeds, idle connections created using the old password are
+ * destroyed and new connections are created using the new password.
+ * </p>
  *
- * @author John D. McNally
  * @since 2.0
  */
 public class SharedPoolDataSource extends InstanceKeyDataSource {
@@ -55,18 +55,18 @@ public class SharedPoolDataSource extends InstanceKeyDataSource {
     // Pool properties
     private int maxTotal = GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL;
 
-
-    private transient KeyedObjectPool<UserPassKey,PooledConnectionAndInfo> pool = null;
-    private transient KeyedCPDSConnectionFactory factory = null;
+    private transient KeyedObjectPool<UserPassKey, PooledConnectionAndInfo> pool;
+    private transient KeyedCPDSConnectionFactory factory;
 
     /**
-     * Default no-arg constructor for Serialization
+     * Default no-argument constructor for Serialization
      */
     public SharedPoolDataSource() {
+        // empty.
     }
 
     /**
-     * Close pool being maintained by this datasource.
+     * Closes pool being maintained by this data source.
      */
     @Override
     public void close() throws Exception {
@@ -76,11 +76,12 @@ public class SharedPoolDataSource extends InstanceKeyDataSource {
         InstanceKeyDataSourceFactory.removeInstance(getInstanceKey());
     }
 
-
     // -------------------------------------------------------------------
     // Properties
 
     /**
+     * Gets {@link GenericKeyedObjectPool#getMaxTotal()} for this pool.
+     *
      * @return {@link GenericKeyedObjectPool#getMaxTotal()} for this pool.
      */
     public int getMaxTotal() {
@@ -88,27 +89,32 @@ public class SharedPoolDataSource extends InstanceKeyDataSource {
     }
 
     /**
-     * Set {@link GenericKeyedObjectPool#getMaxTotal()} for this pool.
-     * @param maxTotal The max total value
+     * Sets {@link GenericKeyedObjectPool#getMaxTotal()} for this pool.
+     *
+     * @param maxTotal
+     *            {@link GenericKeyedObjectPool#getMaxTotal()} for this pool.
      */
     public void setMaxTotal(final int maxTotal) {
         assertInitializationAllowed();
         this.maxTotal = maxTotal;
     }
 
-
     // ----------------------------------------------------------------------
     // Instrumentation Methods
 
     /**
-     * @return the number of active connections in the pool.
+     * Gets the number of active connections in the pool.
+     *
+     * @return The number of active connections in the pool.
      */
     public int getNumActive() {
         return pool == null ? 0 : pool.getNumActive();
     }
 
     /**
-     * @return the number of idle connections in the pool.
+     * Gets the number of idle connections in the pool.
+     *
+     * @return The number of idle connections in the pool.
      */
     public int getNumIdle() {
         return pool == null ? 0 : pool.getNumIdle();
@@ -118,14 +124,13 @@ public class SharedPoolDataSource extends InstanceKeyDataSource {
     // Inherited abstract methods
 
     @Override
-    protected PooledConnectionAndInfo
-        getPooledConnectionAndInfo(final String username, final String password)
-        throws SQLException {
+    protected PooledConnectionAndInfo getPooledConnectionAndInfo(final String userName, final String userPassword)
+            throws SQLException {
 
-        synchronized(this) {
+        synchronized (this) {
             if (pool == null) {
                 try {
-                    registerPool(username, password);
+                    registerPool(userName, userPassword);
                 } catch (final NamingException e) {
                     throw new SQLException("RegisterPool failed", e);
                 }
@@ -134,47 +139,41 @@ public class SharedPoolDataSource extends InstanceKeyDataSource {
 
         PooledConnectionAndInfo info = null;
 
-        final UserPassKey key = new UserPassKey(username, password);
+        final UserPassKey key = new UserPassKey(userName, userPassword);
 
         try {
             info = pool.borrowObject(key);
-        }
-        catch (final Exception e) {
-            throw new SQLException(
-                    "Could not retrieve connection info from pool", e);
+        } catch (final Exception e) {
+            throw new SQLException("Could not retrieve connection info from pool", e);
         }
         return info;
     }
 
     @Override
-    protected PooledConnectionManager getConnectionManager(final UserPassKey upkey)  {
+    protected PooledConnectionManager getConnectionManager(final UserPassKey upkey) {
         return factory;
     }
 
     /**
-     * @return a <code>SharedPoolDataSource</code> {@link Reference}.
-     * @throws NamingException Should not occur
+     * Returns a <code>SharedPoolDataSource</code> {@link Reference}.
      */
     @Override
     public Reference getReference() throws NamingException {
-        final Reference ref = new Reference(getClass().getName(),
-            SharedPoolDataSourceFactory.class.getName(), null);
+        final Reference ref = new Reference(getClass().getName(), SharedPoolDataSourceFactory.class.getName(), null);
         ref.add(new StringRefAddr("instanceKey", getInstanceKey()));
         return ref;
     }
 
-    private void registerPool(final String username, final String password)
-            throws NamingException, SQLException {
+    private void registerPool(final String userName, final String password) throws NamingException, SQLException {
 
-        final ConnectionPoolDataSource cpds = testCPDS(username, password);
+        final ConnectionPoolDataSource cpds = testCPDS(userName, password);
 
         // Create an object pool to contain our PooledConnections
-        factory = new KeyedCPDSConnectionFactory(cpds, getValidationQuery(),
-                getValidationQueryTimeout(), isRollbackAfterValidation());
+        factory = new KeyedCPDSConnectionFactory(cpds, getValidationQuery(), getValidationQueryTimeout(),
+                isRollbackAfterValidation());
         factory.setMaxConnLifetimeMillis(getMaxConnLifetimeMillis());
 
-        final GenericKeyedObjectPoolConfig<PooledConnectionAndInfo> config =
-                new GenericKeyedObjectPoolConfig<>();
+        final GenericKeyedObjectPoolConfig config = new GenericKeyedObjectPoolConfig();
         config.setBlockWhenExhausted(getDefaultBlockWhenExhausted());
         config.setEvictionPolicyClassName(getDefaultEvictionPolicyClassName());
         config.setLifo(getDefaultLifo());
@@ -182,66 +181,58 @@ public class SharedPoolDataSource extends InstanceKeyDataSource {
         config.setMaxTotal(getMaxTotal());
         config.setMaxTotalPerKey(getDefaultMaxTotal());
         config.setMaxWaitMillis(getDefaultMaxWaitMillis());
-        config.setMinEvictableIdleTimeMillis(
-                getDefaultMinEvictableIdleTimeMillis());
+        config.setMinEvictableIdleTimeMillis(getDefaultMinEvictableIdleTimeMillis());
         config.setMinIdlePerKey(getDefaultMinIdle());
         config.setNumTestsPerEvictionRun(getDefaultNumTestsPerEvictionRun());
-        config.setSoftMinEvictableIdleTimeMillis(
-                getDefaultSoftMinEvictableIdleTimeMillis());
+        config.setSoftMinEvictableIdleTimeMillis(getDefaultSoftMinEvictableIdleTimeMillis());
         config.setTestOnCreate(getDefaultTestOnCreate());
         config.setTestOnBorrow(getDefaultTestOnBorrow());
         config.setTestOnReturn(getDefaultTestOnReturn());
         config.setTestWhileIdle(getDefaultTestWhileIdle());
-        config.setTimeBetweenEvictionRunsMillis(
-                getDefaultTimeBetweenEvictionRunsMillis());
+        config.setTimeBetweenEvictionRunsMillis(getDefaultTimeBetweenEvictionRunsMillis());
 
-        final KeyedObjectPool<UserPassKey,PooledConnectionAndInfo> tmpPool =
-                new GenericKeyedObjectPool<>(factory, config);
+        final KeyedObjectPool<UserPassKey, PooledConnectionAndInfo> tmpPool = new GenericKeyedObjectPool<>(factory,
+                config);
         factory.setPool(tmpPool);
         pool = tmpPool;
     }
 
     @Override
-    protected void setupDefaults(final Connection con, final String username) throws SQLException {
+    protected void setupDefaults(final Connection connection, final String userName) throws SQLException {
         final Boolean defaultAutoCommit = isDefaultAutoCommit();
-        if (defaultAutoCommit != null &&
-                con.getAutoCommit() != defaultAutoCommit.booleanValue()) {
-            con.setAutoCommit(defaultAutoCommit.booleanValue());
+        if (defaultAutoCommit != null && connection.getAutoCommit() != defaultAutoCommit.booleanValue()) {
+            connection.setAutoCommit(defaultAutoCommit.booleanValue());
         }
 
         final int defaultTransactionIsolation = getDefaultTransactionIsolation();
         if (defaultTransactionIsolation != UNKNOWN_TRANSACTIONISOLATION) {
-            con.setTransactionIsolation(defaultTransactionIsolation);
+            connection.setTransactionIsolation(defaultTransactionIsolation);
         }
 
         final Boolean defaultReadOnly = isDefaultReadOnly();
-        if (defaultReadOnly != null &&
-                con.isReadOnly() != defaultReadOnly.booleanValue()) {
-            con.setReadOnly(defaultReadOnly.booleanValue());
+        if (defaultReadOnly != null && connection.isReadOnly() != defaultReadOnly.booleanValue()) {
+            connection.setReadOnly(defaultReadOnly.booleanValue());
         }
     }
 
     /**
      * Supports Serialization interface.
      *
-     * @param in a <code>java.io.ObjectInputStream</code> value
-     * @throws IOException if an error occurs
-     * @throws ClassNotFoundException if an error occurs
+     * @param in
+     *            a <code>java.io.ObjectInputStream</code> value
+     * @throws IOException
+     *             if an error occurs
+     * @throws ClassNotFoundException
+     *             if an error occurs
      */
-    private void readObject(final ObjectInputStream in)
-        throws IOException, ClassNotFoundException {
-        try
-        {
+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {
+        try {
             in.defaultReadObject();
-            final SharedPoolDataSource oldDS = (SharedPoolDataSource)
-                new SharedPoolDataSourceFactory()
+            final SharedPoolDataSource oldDS = (SharedPoolDataSource) new SharedPoolDataSourceFactory()
                     .getObjectInstance(getReference(), null, null, null);
             this.pool = oldDS.pool;
-        }
-        catch (final NamingException e)
-        {
+        } catch (final NamingException e) {
             throw new IOException("NamingException: " + e);
         }
     }
 }
-

==================================================
UserPassKey.java
index 4ab921fb15..65bea41dd8 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/datasources/SharedPoolDataSourceFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/SharedPoolDataSourceFactory.java
@@ -22,13 +22,11 @@ import javax.naming.Reference;
 
 /**
  * A JNDI ObjectFactory which creates <code>SharedPoolDataSource</code>s
+ *
  * @since 2.0
  */
-public class SharedPoolDataSourceFactory
-    extends InstanceKeyDataSourceFactory
-{
-    private static final String SHARED_POOL_CLASSNAME =
-        SharedPoolDataSource.class.getName();
+public class SharedPoolDataSourceFactory extends InstanceKeyDataSourceFactory {
+    private static final String SHARED_POOL_CLASSNAME = SharedPoolDataSource.class.getName();
 
     @Override
     protected boolean isCorrectClass(final String className) {
@@ -40,10 +38,8 @@ public class SharedPoolDataSourceFactory
         final SharedPoolDataSource spds = new SharedPoolDataSource();
         final RefAddr ra = ref.get("maxTotal");
         if (ra != null && ra.getContent() != null) {
-            spds.setMaxTotal(
-                Integer.parseInt(ra.getContent().toString()));
+            spds.setMaxTotal(Integer.parseInt(ra.getContent().toString()));
         }
         return spds;
     }
 }
-

==================================================
BasicManagedDataSource.java
index 7313993985..4bcf4ab1a4 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/datasources/UserPassKey.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/datasources/UserPassKey.java
@@ -19,85 +19,115 @@ package org.apache.tomcat.dbcp.dbcp2.datasources;
 
 import java.io.Serializable;
 
+import org.apache.tomcat.dbcp.dbcp2.Utils;
+
 /**
- * <p>Holds a username, password pair.  Serves as a poolable object key for the KeyedObjectPool
- * backing a SharedPoolDataSource.  Two instances with the same username are considered equal.
- * This ensures that there will be only one keyed pool for each user in the pool.  The password
- * is used (along with the username) by the KeyedCPDSConnectionFactory when creating new connections.</p>
+ * <p>
+ * Holds a user name and password pair. Serves as a poolable object key for the KeyedObjectPool backing a
+ * SharedPoolDataSource. Two instances with the same user name are considered equal. This ensures that there will be
+ * only one keyed pool for each user in the pool. The password is used (along with the user name) by the
+ * KeyedCPDSConnectionFactory when creating new connections.
+ * </p>
  *
- * <p>{@link InstanceKeyDataSource#getConnection(String, String)} validates that the password used to create
- * a connection matches the password provided by the client.</p>
+ * <p>
+ * {@link InstanceKeyDataSource#getConnection(String, String)} validates that the password used to create a connection
+ * matches the password provided by the client.
+ * </p>
  *
  * @since 2.0
  */
 class UserPassKey implements Serializable {
     private static final long serialVersionUID = 5142970911626584817L;
-    private final String password;
-    private final String username;
-
-    UserPassKey(final String username, final String password) {
-        this.username = username;
-        this.password = password;
-    }
+    private final String userName;
+    private final char[] userPassword;
 
     /**
-     * Get the value of password.
-     * @return value of password.
+     * @since 2.4.0
      */
-    public String getPassword() {
-        return password;
+    UserPassKey(final String userName) {
+        this(userName, (char[]) null);
     }
 
     /**
-     * Get the value of username.
-     * @return value of username.
+     * @since 2.4.0
      */
-    public String getUsername() {
-        return username;
+    UserPassKey(final String userName, final char[] password) {
+        this.userName = userName;
+        this.userPassword = password;
+    }
+
+    UserPassKey(final String userName, final String userPassword) {
+        this(userName, Utils.toCharArray(userPassword));
     }
 
     /**
-     * @return <code>true</code> if the username fields for both
-     * objects are equal.  Two instances with the same username
-     * but different passwords are considered equal.
-     *
-     * @see java.lang.Object#equals(java.lang.Object)
+     * Only takes the user name into account.
      */
     @Override
     public boolean equals(final Object obj) {
+        if (this == obj) {
+            return true;
+        }
         if (obj == null) {
             return false;
         }
-
-        if (obj == this) {
-            return true;
+        if (getClass() != obj.getClass()) {
+            return false;
         }
-
-        if (!(obj instanceof UserPassKey)) {
+        final UserPassKey other = (UserPassKey) obj;
+        if (userName == null) {
+            if (other.userName != null) {
+                return false;
+            }
+        } else if (!userName.equals(other.userName)) {
             return false;
         }
+        return true;
+    }
 
-        final UserPassKey key = (UserPassKey) obj;
+    /**
+     * Gets the value of password.
+     *
+     * @return value of password.
+     */
+    public String getPassword() {
+        return Utils.toString(userPassword);
+    }
+
+    /**
+     * Gets the value of password.
+     *
+     * @return value of password.
+     */
+    public char[] getPasswordCharArray() {
+        return userPassword;
+    }
 
-        return this.username == null ?
-                key.username == null :
-                this.username.equals(key.username);
+    /**
+     * Gets the value of user name.
+     *
+     * @return value of user name.
+     */
+    public String getUsername() {
+        return userName;
     }
 
     /**
-     * Returns the hash of the username.
+     * Only takes the user name into account.
      */
     @Override
     public int hashCode() {
-        return this.username != null ?
-                this.username.hashCode() : 0;
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((userName == null) ? 0 : userName.hashCode());
+        return result;
     }
 
     @Override
     public String toString() {
         final StringBuffer sb = new StringBuffer(50);
         sb.append("UserPassKey(");
-        sb.append(username).append(", ").append(password).append(')');
+        sb.append(userName).append(", ").append(userPassword).append(')');
         return sb.toString();
     }
 }

==================================================
DataSourceXAConnectionFactory.java
index 949a7833be..7f814d24b3 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/BasicManagedDataSource.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/BasicManagedDataSource.java
@@ -30,22 +30,18 @@ import org.apache.tomcat.dbcp.dbcp2.PoolableConnectionFactory;
 import org.apache.tomcat.dbcp.dbcp2.PoolingDataSource;
 
 /**
- * <p>BasicManagedDataSource is an extension of BasicDataSource which
- * creates ManagedConnections.  This data source can create either
- * full two-phase-commit XA connections or one-phase-commit
- * local connections.  Both types of connections are committed or
- * rolled back as part of the global transaction (a.k.a. XA
- * transaction or JTA Transaction), but only XA connections can be
- * recovered in the case of a system crash.
+ * <p>
+ * BasicManagedDataSource is an extension of BasicDataSource which creates ManagedConnections. This data source can
+ * create either full two-phase-commit XA connections or one-phase-commit local connections. Both types of connections
+ * are committed or rolled back as part of the global transaction (a.k.a. XA transaction or JTA Transaction), but only
+ * XA connections can be recovered in the case of a system crash.
  * </p>
- * <p>BasicManagedDataSource adds the TransactionManager and XADataSource
- * properties.  The TransactionManager property is required and is
- * used to enlist connections in global transactions.  The XADataSource
- * is optional and if set is the class name of the XADataSource class
- * for a two-phase-commit JDBC driver.  If the XADataSource property
- * is set, the driverClassName is ignored and a DataSourceXAConnectionFactory
- * is created. Otherwise, a standard DriverConnectionFactory is created
- * and wrapped with a LocalXAConnectionFactory.
+ * <p>
+ * BasicManagedDataSource adds the TransactionManager and XADataSource properties. The TransactionManager property is
+ * required and is used to enlist connections in global transactions. The XADataSource is optional and if set is the
+ * class name of the XADataSource class for a two-phase-commit JDBC driver. If the XADataSource property is set, the
+ * driverClassName is ignored and a DataSourceXAConnectionFactory is created. Otherwise, a standard
+ * DriverConnectionFactory is created and wrapped with a LocalXAConnectionFactory.
  * </p>
  *
  * @see BasicDataSource
@@ -53,13 +49,17 @@ import org.apache.tomcat.dbcp.dbcp2.PoolingDataSource;
  * @since 2.0
  */
 public class BasicManagedDataSource extends BasicDataSource {
+
     /** Transaction Registry */
     private TransactionRegistry transactionRegistry;
+
     /** Transaction Manager */
     private transient TransactionManager transactionManager;
-    /** XA datasource class name */
+
+    /** XA data source class name */
     private String xaDataSource;
-    /** XA datasource instance */
+
+    /** XA data source instance */
     private XADataSource xaDataSourceInstance;
 
     /**
@@ -72,14 +72,17 @@ public class BasicManagedDataSource extends BasicDataSource {
     }
 
     /**
-     * <p>Sets the XADataSource instance used by the XAConnectionFactory.</p>
      * <p>
-     * Note: this method currently has no effect once the pool has been
-     * initialized.  The pool is initialized the first time one of the
-     * following methods is invoked: <code>getConnection, setLogwriter,
-     * setLoginTimeout, getLoginTimeout, getLogWriter.</code></p>
+     * Sets the XADataSource instance used by the XAConnectionFactory.
+     * </p>
+     * <p>
+     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
+     * time one of the following methods is invoked: <code>getConnection, setLogwriter,
+     * setLoginTimeout, getLoginTimeout, getLogWriter.</code>
+     * </p>
      *
-     * @param xaDataSourceInstance XADataSource instance
+     * @param xaDataSourceInstance
+     *            XADataSource instance
      */
     public synchronized void setXaDataSourceInstance(final XADataSource xaDataSourceInstance) {
         this.xaDataSourceInstance = xaDataSourceInstance;
@@ -88,6 +91,7 @@ public class BasicManagedDataSource extends BasicDataSource {
 
     /**
      * Gets the required transaction manager property.
+     *
      * @return the transaction manager used to enlist connections
      */
     public TransactionManager getTransactionManager() {
@@ -96,6 +100,7 @@ public class BasicManagedDataSource extends BasicDataSource {
 
     /**
      * Gets the transaction registry.
+     *
      * @return the transaction registry associating XAResources with managed connections
      */
     protected synchronized TransactionRegistry getTransactionRegistry() {
@@ -104,7 +109,9 @@ public class BasicManagedDataSource extends BasicDataSource {
 
     /**
      * Sets the required transaction manager property.
-     * @param transactionManager the transaction manager used to enlist connections
+     *
+     * @param transactionManager
+     *            the transaction manager used to enlist connections
      */
     public void setTransactionManager(final TransactionManager transactionManager) {
         this.transactionManager = transactionManager;
@@ -112,6 +119,7 @@ public class BasicManagedDataSource extends BasicDataSource {
 
     /**
      * Gets the optional XADataSource class name.
+     *
      * @return the optional XADataSource class name
      */
     public synchronized String getXADataSource() {
@@ -120,7 +128,9 @@ public class BasicManagedDataSource extends BasicDataSource {
 
     /**
      * Sets the optional XADataSource class name.
-     * @param xaDataSource the optional XADataSource class name
+     *
+     * @param xaDataSource
+     *            the optional XADataSource class name
      */
     public synchronized void setXADataSource(final String xaDataSource) {
         this.xaDataSource = xaDataSource;
@@ -132,10 +142,12 @@ public class BasicManagedDataSource extends BasicDataSource {
             throw new SQLException("Transaction manager must be set before a connection can be created");
         }
 
-        // If xa data source is not specified a DriverConnectionFactory is created and wrapped with a LocalXAConnectionFactory
+        // If xa data source is not specified a DriverConnectionFactory is created and wrapped with a
+        // LocalXAConnectionFactory
         if (xaDataSource == null) {
             final ConnectionFactory connectionFactory = super.createConnectionFactory();
-            final XAConnectionFactory xaConnectionFactory = new LocalXAConnectionFactory(getTransactionManager(), connectionFactory);
+            final XAConnectionFactory xaConnectionFactory = new LocalXAConnectionFactory(getTransactionManager(),
+                    connectionFactory);
             transactionRegistry = xaConnectionFactory.getTransactionRegistry();
             return xaConnectionFactory;
         }
@@ -159,15 +171,16 @@ public class BasicManagedDataSource extends BasicDataSource {
         }
 
         // finally, create the XAConnectionFactory using the XA data source
-        final XAConnectionFactory xaConnectionFactory = new DataSourceXAConnectionFactory(getTransactionManager(), xaDataSourceInstance, getUsername(), getPassword());
+        final XAConnectionFactory xaConnectionFactory = new DataSourceXAConnectionFactory(getTransactionManager(),
+                xaDataSourceInstance, getUsername(), getPassword());
         transactionRegistry = xaConnectionFactory.getTransactionRegistry();
         return xaConnectionFactory;
     }
 
     @Override
     protected DataSource createDataSourceInstance() throws SQLException {
-        final PoolingDataSource<PoolableConnection> pds =
-                new ManagedDataSource<>(getConnectionPool(), transactionRegistry);
+        final PoolingDataSource<PoolableConnection> pds = new ManagedDataSource<>(getConnectionPool(),
+                transactionRegistry);
         pds.setAccessToUnderlyingConnectionAllowed(isAccessToUnderlyingConnectionAllowed());
         return pds;
     }
@@ -175,16 +188,18 @@ public class BasicManagedDataSource extends BasicDataSource {
     /**
      * Creates the PoolableConnectionFactory and attaches it to the connection pool.
      *
-     * @param driverConnectionFactory JDBC connection factory created by {@link #createConnectionFactory()}
-     * @throws SQLException if an error occurs creating the PoolableConnectionFactory
+     * @param driverConnectionFactory
+     *            JDBC connection factory created by {@link #createConnectionFactory()}
+     * @throws SQLException
+     *             if an error occurs creating the PoolableConnectionFactory
      */
     @Override
-    protected PoolableConnectionFactory createPoolableConnectionFactory(
-            final ConnectionFactory driverConnectionFactory) throws SQLException {
+    protected PoolableConnectionFactory createPoolableConnectionFactory(final ConnectionFactory driverConnectionFactory)
+            throws SQLException {
         PoolableConnectionFactory connectionFactory = null;
         try {
-            connectionFactory = new PoolableManagedConnectionFactory(
-                    (XAConnectionFactory) driverConnectionFactory, getRegisteredJmxName());
+            connectionFactory = new PoolableManagedConnectionFactory((XAConnectionFactory) driverConnectionFactory,
+                    getRegisteredJmxName());
             connectionFactory.setValidationQuery(getValidationQuery());
             connectionFactory.setValidationQueryTimeout(getValidationQueryTimeout());
             connectionFactory.setConnectionInitSql(getConnectionInitSqls());
@@ -194,8 +209,7 @@ public class BasicManagedDataSource extends BasicDataSource {
             connectionFactory.setDefaultCatalog(getDefaultCatalog());
             connectionFactory.setCacheState(getCacheState());
             connectionFactory.setPoolStatements(isPoolPreparedStatements());
-            connectionFactory.setMaxOpenPreparedStatements(
-                    getMaxOpenPreparedStatements());
+            connectionFactory.setMaxOpenPreparedStatements(getMaxOpenPreparedStatements());
             connectionFactory.setMaxConnLifetimeMillis(getMaxConnLifetimeMillis());
             connectionFactory.setRollbackOnReturn(getRollbackOnReturn());
             connectionFactory.setEnableAutoCommitOnReturn(getEnableAutoCommitOnReturn());

==================================================
LocalXAConnectionFactory.java
index a7abac957f..f05b4e21c1 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/DataSourceXAConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/DataSourceXAConnectionFactory.java
@@ -19,6 +19,7 @@ package org.apache.tomcat.dbcp.dbcp2.managed;
 
 import java.sql.Connection;
 import java.sql.SQLException;
+import java.util.Objects;
 
 import javax.sql.ConnectionEvent;
 import javax.sql.ConnectionEventListener;
@@ -28,74 +29,111 @@ import javax.sql.XADataSource;
 import javax.transaction.TransactionManager;
 import javax.transaction.xa.XAResource;
 
+import org.apache.tomcat.dbcp.dbcp2.Utils;
+
 /**
  * An implementation of XAConnectionFactory which uses a real XADataSource to obtain connections and XAResources.
  *
- * @author Dain Sundstrom
  * @since 2.0
  */
 public class DataSourceXAConnectionFactory implements XAConnectionFactory {
     private final TransactionRegistry transactionRegistry;
     private final XADataSource xaDataSource;
-    private String username;
-    private String password;
+    private String userName;
+    private char[] userPassword;
 
     /**
-     * Creates an DataSourceXAConnectionFactory which uses the specified XADataSource to create database
-     * connections.  The connections are enlisted into transactions using the specified transaction manager.
+     * Creates an DataSourceXAConnectionFactory which uses the specified XADataSource to create database connections.
+     * The connections are enlisted into transactions using the specified transaction manager.
      *
-     * @param transactionManager the transaction manager in which connections will be enlisted
-     * @param xaDataSource the data source from which connections will be retrieved
+     * @param transactionManager
+     *            the transaction manager in which connections will be enlisted
+     * @param xaDataSource
+     *            the data source from which connections will be retrieved
      */
     public DataSourceXAConnectionFactory(final TransactionManager transactionManager, final XADataSource xaDataSource) {
-        this(transactionManager, xaDataSource, null, null);
+        this(transactionManager, xaDataSource, null, (char[]) null);
     }
 
     /**
-     * Creates an DataSourceXAConnectionFactory which uses the specified XADataSource to create database
-     * connections.  The connections are enlisted into transactions using the specified transaction manager.
+     * Creates an DataSourceXAConnectionFactory which uses the specified XADataSource to create database connections.
+     * The connections are enlisted into transactions using the specified transaction manager.
      *
-     * @param transactionManager the transaction manager in which connections will be enlisted
-     * @param xaDataSource the data source from which connections will be retrieved
-     * @param username the username used for authenticating new connections or null for unauthenticated
-     * @param password the password used for authenticating new connections
+     * @param transactionManager
+     *            the transaction manager in which connections will be enlisted
+     * @param xaDataSource
+     *            the data source from which connections will be retrieved
+     * @param userName
+     *            the user name used for authenticating new connections or null for unauthenticated
+     * @param userPassword
+     *            the password used for authenticating new connections
      */
-    public DataSourceXAConnectionFactory(final TransactionManager transactionManager, final XADataSource xaDataSource, final String username, final String password) {
-        if (transactionManager == null) {
-            throw new NullPointerException("transactionManager is null");
-        }
-        if (xaDataSource == null) {
-            throw new NullPointerException("xaDataSource is null");
-        }
-
+    public DataSourceXAConnectionFactory(final TransactionManager transactionManager, final XADataSource xaDataSource,
+            final String userName, final char[] userPassword) {
+        Objects.requireNonNull(transactionManager, "transactionManager is null");
+        Objects.requireNonNull(xaDataSource, "xaDataSource is null");
         this.transactionRegistry = new TransactionRegistry(transactionManager);
         this.xaDataSource = xaDataSource;
-        this.username = username;
-        this.password = password;
+        this.userName = userName;
+        this.userPassword = userPassword;
+    }
+
+    /**
+     * Creates an DataSourceXAConnectionFactory which uses the specified XADataSource to create database connections.
+     * The connections are enlisted into transactions using the specified transaction manager.
+     *
+     * @param transactionManager
+     *            the transaction manager in which connections will be enlisted
+     * @param xaDataSource
+     *            the data source from which connections will be retrieved
+     * @param userName
+     *            the user name used for authenticating new connections or null for unauthenticated
+     * @param userPassword
+     *            the password used for authenticating new connections
+     */
+    public DataSourceXAConnectionFactory(final TransactionManager transactionManager, final XADataSource xaDataSource,
+            final String userName, final String userPassword) {
+        this(transactionManager, xaDataSource, userName, Utils.toCharArray(userPassword));
     }
 
     /**
-     * Gets the username used to authenticate new connections.
+     * Gets the user name used to authenticate new connections.
+     *
      * @return the user name or null if unauthenticated connections are used
      */
     public String getUsername() {
-        return username;
+        return userName;
     }
 
     /**
-     * Sets the username used to authenticate new connections.
-     * @param username the username used for authenticating the connection or null for unauthenticated
+     * Sets the user name used to authenticate new connections.
+     *
+     * @param userName
+     *            the user name used for authenticating the connection or null for unauthenticated
      */
-    public void setUsername(final String username) {
-        this.username = username;
+    public void setUsername(final String userName) {
+        this.userName = userName;
     }
 
     /**
      * Sets the password used to authenticate new connections.
-     * @param password the password used for authenticating the connection or null for unauthenticated
+     *
+     * @param userPassword
+     *            the password used for authenticating the connection or null for unauthenticated.
+     * @since 2.4.0
      */
-    public void setPassword(final String password) {
-        this.password = password;
+    public void setPassword(final char[] userPassword) {
+        this.userPassword = userPassword;
+    }
+
+    /**
+     * Sets the password used to authenticate new connections.
+     *
+     * @param userPassword
+     *            the password used for authenticating the connection or null for unauthenticated
+     */
+    public void setPassword(final String userPassword) {
+        this.userPassword = Utils.toCharArray(userPassword);
     }
 
     @Override
@@ -107,10 +145,10 @@ public class DataSourceXAConnectionFactory implements XAConnectionFactory {
     public Connection createConnection() throws SQLException {
         // create a new XAConnection
         XAConnection xaConnection;
-        if (username == null) {
+        if (userName == null) {
             xaConnection = xaDataSource.getXAConnection();
         } else {
-            xaConnection = xaDataSource.getXAConnection(username, password);
+            xaConnection = xaDataSource.getXAConnection(userName, Utils.toString(userPassword));
         }
 
         // get the real connection and XAResource from the connection
@@ -143,7 +181,6 @@ public class DataSourceXAConnectionFactory implements XAConnectionFactory {
             }
         });
 
-
         return connection;
     }
 }

==================================================
ManagedConnection.java
index 779778618f..c909fab3c9 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/LocalXAConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/LocalXAConnectionFactory.java
@@ -19,6 +19,7 @@ package org.apache.tomcat.dbcp.dbcp2.managed;
 
 import java.sql.Connection;
 import java.sql.SQLException;
+import java.util.Objects;
 
 import javax.transaction.TransactionManager;
 import javax.transaction.xa.XAException;
@@ -28,11 +29,10 @@ import javax.transaction.xa.Xid;
 import org.apache.tomcat.dbcp.dbcp2.ConnectionFactory;
 
 /**
- * An implementation of XAConnectionFactory which manages non-XA connections in XA transactions.  A non-XA connection
+ * An implementation of XAConnectionFactory which manages non-XA connections in XA transactions. A non-XA connection
  * commits and rolls back as part of the XA transaction, but is not recoverable since the connection does not implement
  * the 2-phase protocol.
  *
- * @author Dain Sundstrom
  * @since 2.0
  */
 public class LocalXAConnectionFactory implements XAConnectionFactory {
@@ -40,20 +40,18 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
     private final ConnectionFactory connectionFactory;
 
     /**
-     * Creates an LocalXAConnectionFactory which uses the specified connection factory to create database
-     * connections.  The connections are enlisted into transactions using the specified transaction manager.
+     * Creates an LocalXAConnectionFactory which uses the specified connection factory to create database connections.
+     * The connections are enlisted into transactions using the specified transaction manager.
      *
-     * @param transactionManager the transaction manager in which connections will be enlisted
-     * @param connectionFactory  the connection factory from which connections will be retrieved
+     * @param transactionManager
+     *            the transaction manager in which connections will be enlisted
+     * @param connectionFactory
+     *            the connection factory from which connections will be retrieved
      */
-    public LocalXAConnectionFactory(final TransactionManager transactionManager, final ConnectionFactory connectionFactory) {
-        if (transactionManager == null) {
-            throw new NullPointerException("transactionManager is null");
-        }
-        if (connectionFactory == null) {
-            throw new NullPointerException("connectionFactory is null");
-        }
-
+    public LocalXAConnectionFactory(final TransactionManager transactionManager,
+            final ConnectionFactory connectionFactory) {
+        Objects.requireNonNull(transactionManager, "transactionManager is null");
+        Objects.requireNonNull(connectionFactory, "connectionFactory is null");
         this.transactionRegistry = new TransactionRegistry(transactionManager);
         this.connectionFactory = connectionFactory;
     }
@@ -78,16 +76,16 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
     }
 
     /**
-     * LocalXAResource is a fake XAResource for non-XA connections.  When a transaction is started
-     * the connection auto-commit is turned off.  When the connection is committed or rolled back,
-     * the commit or rollback method is called on the connection and then the original auto-commit
-     * value is restored.
+     * LocalXAResource is a fake XAResource for non-XA connections. When a transaction is started the connection
+     * auto-commit is turned off. When the connection is committed or rolled back, the commit or rollback method is
+     * called on the connection and then the original auto-commit value is restored.
      * <p>
-     * The LocalXAResource also respects the connection read-only setting.  If the connection is
-     * read-only the commit method will not be called, and the prepare method returns the XA_RDONLY.
+     * The LocalXAResource also respects the connection read-only setting. If the connection is read-only the commit
+     * method will not be called, and the prepare method returns the XA_RDONLY.
      * </p>
-     * It is assumed that the wrapper around a managed connection disables the setAutoCommit(),
-     * commit(), rollback() and setReadOnly() methods while a transaction is in progress.
+     * It is assumed that the wrapper around a managed connection disables the setAutoCommit(), commit(), rollback() and
+     * setReadOnly() methods while a transaction is in progress.
+     *
      * @since 2.0
      */
     protected static class LocalXAResource implements XAResource {
@@ -109,14 +107,17 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
         }
 
         /**
-         * Signals that a the connection has been enrolled in a transaction.  This method saves off the
-         * current auto commit flag, and then disables auto commit.  The original auto commit setting is
-         * restored when the transaction completes.
+         * Signals that a the connection has been enrolled in a transaction. This method saves off the current auto
+         * commit flag, and then disables auto commit. The original auto commit setting is restored when the transaction
+         * completes.
          *
-         * @param xid  the id of the transaction branch for this connection
-         * @param flag either XAResource.TMNOFLAGS or XAResource.TMRESUME
-         * @throws XAException if the connection is already enlisted in another transaction, or if auto-commit
-         *                     could not be disabled
+         * @param xid
+         *            the id of the transaction branch for this connection
+         * @param flag
+         *            either XAResource.TMNOFLAGS or XAResource.TMRESUME
+         * @throws XAException
+         *             if the connection is already enlisted in another transaction, or if auto-commit could not be
+         *             disabled
          */
         @Override
         public synchronized void start(final Xid xid, final int flag) throws XAException {
@@ -140,13 +141,15 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
                 try {
                     connection.setAutoCommit(false);
                 } catch (final SQLException e) {
-                    throw (XAException) new XAException("Count not turn off auto commit for a XA transaction").initCause(e);
+                    throw (XAException) new XAException("Count not turn off auto commit for a XA transaction")
+                            .initCause(e);
                 }
 
                 this.currentXid = xid;
             } else if (flag == XAResource.TMRESUME) {
                 if (!xid.equals(this.currentXid)) {
-                    throw new XAException("Attempting to resume in different transaction: expected " + this.currentXid + ", but was " + xid);
+                    throw new XAException("Attempting to resume in different transaction: expected " + this.currentXid
+                            + ", but was " + xid);
                 }
             } else {
                 throw new XAException("Unknown start flag " + flag);
@@ -156,31 +159,33 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
         /**
          * This method does nothing.
          *
-         * @param xid  the id of the transaction branch for this connection
-         * @param flag ignored
-         * @throws XAException if the connection is already enlisted in another transaction
+         * @param xid
+         *            the id of the transaction branch for this connection
+         * @param flag
+         *            ignored
+         * @throws XAException
+         *             if the connection is already enlisted in another transaction
          */
         @Override
         public synchronized void end(final Xid xid, final int flag) throws XAException {
-            if (xid == null) {
-                throw new NullPointerException("xid is null");
-            }
+            Objects.requireNonNull(xid, "xid is null");
             if (!this.currentXid.equals(xid)) {
                 throw new XAException("Invalid Xid: expected " + this.currentXid + ", but was " + xid);
             }
 
             // This notification tells us that the application server is done using this
-            // connection for the time being.  The connection is still associated with an
+            // connection for the time being. The connection is still associated with an
             // open transaction, so we must still wait for the commit or rollback method
         }
 
         /**
-         * This method does nothing since the LocalXAConnection does not support two-phase-commit.  This method
-         * will return XAResource.XA_RDONLY if the connection isReadOnly().  This assumes that the physical
-         * connection is wrapped with a proxy that prevents an application from changing the read-only flag
-         * while enrolled in a transaction.
+         * This method does nothing since the LocalXAConnection does not support two-phase-commit. This method will
+         * return XAResource.XA_RDONLY if the connection isReadOnly(). This assumes that the physical connection is
+         * wrapped with a proxy that prevents an application from changing the read-only flag while enrolled in a
+         * transaction.
          *
-         * @param xid the id of the transaction branch for this connection
+         * @param xid
+         *            the id of the transaction branch for this connection
          * @return XAResource.XA_RDONLY if the connection.isReadOnly(); XAResource.XA_OK otherwise
          */
         @Override
@@ -207,21 +212,21 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
         /**
          * Commits the transaction and restores the original auto commit setting.
          *
-         * @param xid  the id of the transaction branch for this connection
-         * @param flag ignored
-         * @throws XAException if connection.commit() throws a SQLException
+         * @param xid
+         *            the id of the transaction branch for this connection
+         * @param flag
+         *            ignored
+         * @throws XAException
+         *             if connection.commit() throws a SQLException
          */
         @Override
         public synchronized void commit(final Xid xid, final boolean flag) throws XAException {
-            if (xid == null) {
-                throw new NullPointerException("xid is null");
-            }
+            Objects.requireNonNull(xid, "xid is null");
             if (this.currentXid == null) {
                 throw new XAException("There is no current transaction");
             }
             if (!this.currentXid.equals(xid)) {
-                throw new XAException("Invalid Xid: expected " +
-                        this.currentXid + ", but was " + xid);
+                throw new XAException("Invalid Xid: expected " + this.currentXid + ", but was " + xid);
             }
 
             try {
@@ -240,6 +245,7 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
                 try {
                     connection.setAutoCommit(originalAutoCommit);
                 } catch (final SQLException e) {
+                    // ignore
                 }
                 this.currentXid = null;
             }
@@ -248,14 +254,14 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
         /**
          * Rolls back the transaction and restores the original auto commit setting.
          *
-         * @param xid the id of the transaction branch for this connection
-         * @throws XAException if connection.rollback() throws a SQLException
+         * @param xid
+         *            the id of the transaction branch for this connection
+         * @throws XAException
+         *             if connection.rollback() throws a SQLException
          */
         @Override
         public synchronized void rollback(final Xid xid) throws XAException {
-            if (xid == null) {
-                throw new NullPointerException("xid is null");
-            }
+            Objects.requireNonNull(xid, "xid is null");
             if (!this.currentXid.equals(xid)) {
                 throw new XAException("Invalid Xid: expected " + this.currentXid + ", but was " + xid);
             }
@@ -268,6 +274,7 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
                 try {
                     connection.setAutoCommit(originalAutoCommit);
                 } catch (final SQLException e) {
+                    // Ignore.
                 }
                 this.currentXid = null;
             }
@@ -276,7 +283,8 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
         /**
          * Returns true if the specified XAResource == this XAResource.
          *
-         * @param xaResource the XAResource to test
+         * @param xaResource
+         *            the XAResource to test
          * @return true if the specified XAResource == this XAResource; false otherwise
          */
         @Override
@@ -287,7 +295,8 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
         /**
          * Clears the currently associated transaction if it is the specified xid.
          *
-         * @param xid the id of the transaction to forget
+         * @param xid
+         *            the id of the transaction to forget
          */
         @Override
         public synchronized void forget(final Xid xid) {
@@ -297,9 +306,11 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
         }
 
         /**
-         * Always returns a zero length Xid array.  The LocalXAConnectionFactory can not support recovery, so no xids will ever be found.
+         * Always returns a zero length Xid array. The LocalXAConnectionFactory can not support recovery, so no xids
+         * will ever be found.
          *
-         * @param flag ignored since recovery is not supported
+         * @param flag
+         *            ignored since recovery is not supported
          * @return always a zero length Xid array.
          */
         @Override
@@ -320,7 +331,8 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
         /**
          * Always returns false since we have no way to set a transaction timeout on a JDBC connection.
          *
-         * @param transactionTimeout ignored since we have no way to set a transaction timeout on a JDBC connection
+         * @param transactionTimeout
+         *            ignored since we have no way to set a transaction timeout on a JDBC connection
          * @return always false
          */
         @Override

==================================================
ManagedDataSource.java
index 6a1e9a2f83..5391f225bb 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/ManagedConnection.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/ManagedConnection.java
@@ -19,43 +19,59 @@ package org.apache.tomcat.dbcp.dbcp2.managed;
 
 import java.sql.Connection;
 import java.sql.SQLException;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 
 import org.apache.tomcat.dbcp.dbcp2.DelegatingConnection;
 import org.apache.tomcat.dbcp.pool2.ObjectPool;
 
 /**
- * ManagedConnection is responsible for managing a database connection in a transactional environment
- * (typically called "Container Managed").  A managed connection operates like any other connection
- * when no global transaction (a.k.a. XA transaction or JTA Transaction) is in progress.  When a
- * global transaction is active a single physical connection to the database is used by all
- * ManagedConnections accessed in the scope of the transaction.  Connection sharing means that all
- * data access during a transaction has a consistent view of the database.  When the global transaction
- * is committed or rolled back the enlisted connections are committed or rolled back.  Typically upon
- * transaction completion, a connection returns to the auto commit setting in effect before being
- * enlisted in the transaction, but some vendors do not properly implement this.
+ * ManagedConnection is responsible for managing a database connection in a transactional environment (typically called
+ * "Container Managed"). A managed connection operates like any other connection when no global transaction (a.k.a. XA
+ * transaction or JTA Transaction) is in progress. When a global transaction is active a single physical connection to
+ * the database is used by all ManagedConnections accessed in the scope of the transaction. Connection sharing means
+ * that all data access during a transaction has a consistent view of the database. When the global transaction is
+ * committed or rolled back the enlisted connections are committed or rolled back. Typically upon transaction
+ * completion, a connection returns to the auto commit setting in effect before being enlisted in the transaction, but
+ * some vendors do not properly implement this.
+ * <p>
+ * When enlisted in a transaction the setAutoCommit(), commit(), rollback(), and setReadOnly() methods throw a
+ * SQLException. This is necessary to assure that the transaction completes as a single unit.
+ * </p>
  *
- * When enlisted in a transaction the setAutoCommit(), commit(), rollback(), and setReadOnly() methods
- * throw a SQLException.  This is necessary to assure that the transaction completes as a single unit.
+ * @param <C>
+ *            the Connection type
  *
- * @param <C> the Connection type
- *
- * @author Dain Sundstrom
  * @since 2.0
  */
 public class ManagedConnection<C extends Connection> extends DelegatingConnection<C> {
+
     private final ObjectPool<C> pool;
     private final TransactionRegistry transactionRegistry;
     private final boolean accessToUnderlyingConnectionAllowed;
     private TransactionContext transactionContext;
     private boolean isSharedConnection;
+    private final Lock lock;
 
-    public ManagedConnection(final ObjectPool<C> pool,
-            final TransactionRegistry transactionRegistry,
+    /**
+     * Constructs a new instance responsible for managing a database connection in a transactional environment.
+     *
+     * @param pool
+     *            The connection pool.
+     * @param transactionRegistry
+     *            The transaction registry.
+     * @param accessToUnderlyingConnectionAllowed
+     *            Whether or not to allow access to the underlying Connection.
+     * @throws SQLException
+     *             Thrown when there is problem managing transactions.
+     */
+    public ManagedConnection(final ObjectPool<C> pool, final TransactionRegistry transactionRegistry,
             final boolean accessToUnderlyingConnectionAllowed) throws SQLException {
         super(null);
         this.pool = pool;
         this.transactionRegistry = transactionRegistry;
         this.accessToUnderlyingConnectionAllowed = accessToUnderlyingConnectionAllowed;
+        this.lock = new ReentrantLock();
         updateTransactionStatus();
     }
 
@@ -67,7 +83,7 @@ public class ManagedConnection<C extends Connection> extends DelegatingConnectio
 
     private void updateTransactionStatus() throws SQLException {
         // if there is a is an active transaction context, assure the transaction context hasn't changed
-        if (transactionContext != null) {
+        if (transactionContext != null && !transactionContext.isTransactionComplete()) {
             if (transactionContext.isActive()) {
                 if (transactionContext != transactionRegistry.getActiveTransactionContext()) {
                     throw new SQLException("Connection can not be used while enlisted in another transaction");
@@ -76,7 +92,7 @@ public class ManagedConnection<C extends Connection> extends DelegatingConnectio
             }
             // transaction should have been cleared up by TransactionContextListener, but in
             // rare cases another lister could have registered which uses the connection before
-            // our listener is called.  In that rare case, trigger the transaction complete call now
+            // our listener is called. In that rare case, trigger the transaction complete call now
             transactionComplete();
         }
 
@@ -111,8 +127,7 @@ public class ManagedConnection<C extends Connection> extends DelegatingConnectio
             // always be of type C since it has been shared by another
             // connection from the same pool.
             @SuppressWarnings("unchecked")
-            final
-            C shared = (C) transactionContext.getSharedConnection();
+            final C shared = (C) transactionContext.getSharedConnection();
             setDelegate(shared);
 
             // remember that we are using a shared connection so it can be cleared after the
@@ -162,18 +177,25 @@ public class ManagedConnection<C extends Connection> extends DelegatingConnectio
             try {
                 // Don't actually close the connection if in a transaction. The
                 // connection will be closed by the transactionComplete method.
-                if (transactionContext == null) {
+                //
+                // DBCP-484 we need to make sure setClosedInternal(true) being
+                // invoked if transactionContext is not null as this value will
+                // be modified by the transactionComplete method which could run
+                // in the different thread with the transaction calling back.
+                lock.lock();
+                if (transactionContext == null || transactionContext.isTransactionComplete()) {
                     super.close();
                 }
             } finally {
                 setClosedInternal(true);
+                lock.unlock();
             }
         }
     }
 
     /**
-     * Delegates to {@link ManagedConnection#transactionComplete()}
-     * for transaction completion events.
+     * Delegates to {@link ManagedConnection#transactionComplete()} for transaction completion events.
+     *
      * @since 2.0
      */
     protected class CompletionListener implements TransactionContextListener {
@@ -186,7 +208,9 @@ public class ManagedConnection<C extends Connection> extends DelegatingConnectio
     }
 
     protected void transactionComplete() {
-        transactionContext = null;
+        lock.lock();
+        transactionContext.completeTransaction();
+        lock.unlock();
 
         // If we were using a shared connection, clear the reference now that
         // the transaction has completed
@@ -225,7 +249,6 @@ public class ManagedConnection<C extends Connection> extends DelegatingConnectio
         super.setAutoCommit(autoCommit);
     }
 
-
     @Override
     public void commit() throws SQLException {
         if (transactionContext != null) {
@@ -242,7 +265,6 @@ public class ManagedConnection<C extends Connection> extends DelegatingConnectio
         super.rollback();
     }
 
-
     @Override
     public void setReadOnly(final boolean readOnly) throws SQLException {
         if (transactionContext != null) {
@@ -257,6 +279,7 @@ public class ManagedConnection<C extends Connection> extends DelegatingConnectio
 
     /**
      * If false, getDelegate() and getInnermostDelegate() will return null.
+     *
      * @return if false, getDelegate() and getInnermostDelegate() will return null
      */
     public boolean isAccessToUnderlyingConnectionAllowed() {

==================================================
PoolableManagedConnection.java
index 638393fd8a..38c5085090 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/ManagedDataSource.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/ManagedDataSource.java
@@ -19,6 +19,7 @@ package org.apache.tomcat.dbcp.dbcp2.managed;
 
 import java.sql.Connection;
 import java.sql.SQLException;
+import java.util.Objects;
 
 import org.apache.tomcat.dbcp.dbcp2.PoolingDataSource;
 import org.apache.tomcat.dbcp.pool2.ObjectPool;
@@ -26,45 +27,43 @@ import org.apache.tomcat.dbcp.pool2.ObjectPool;
 /**
  * The ManagedDataSource is a PoolingDataSource that creates ManagedConnections.
  *
- * @author Dain Sundstrom
- * @param <C> The kind of {@link Connection} to manage.
+ * @param <C>
+ *            The kind of {@link Connection} to manage.
  * @since 2.0
  */
 public class ManagedDataSource<C extends Connection> extends PoolingDataSource<C> {
     private TransactionRegistry transactionRegistry;
 
     /**
-     * Creates a ManagedDataSource which obtains connections from the specified pool and
-     * manages them using the specified transaction registry.  The TransactionRegistry must
-     * be the transaction registry obtained from the XAConnectionFactory used to create
-     * the connection pool.  If not, an error will occur when attempting to use the connection
-     * in a global transaction because the XAResource object associated with the connection
-     * will be unavailable.
+     * Creates a ManagedDataSource which obtains connections from the specified pool and manages them using the
+     * specified transaction registry. The TransactionRegistry must be the transaction registry obtained from the
+     * XAConnectionFactory used to create the connection pool. If not, an error will occur when attempting to use the
+     * connection in a global transaction because the XAResource object associated with the connection will be
+     * unavailable.
      *
-     * @param pool the connection pool
-     * @param transactionRegistry the transaction registry obtained from the
-     * XAConnectionFactory used to create the connection pool object factory
+     * @param pool
+     *            the connection pool
+     * @param transactionRegistry
+     *            the transaction registry obtained from the XAConnectionFactory used to create the connection pool
+     *            object factory
      */
-    public ManagedDataSource(final ObjectPool<C> pool,
-            final TransactionRegistry transactionRegistry) {
+    public ManagedDataSource(final ObjectPool<C> pool, final TransactionRegistry transactionRegistry) {
         super(pool);
         this.transactionRegistry = transactionRegistry;
     }
 
     /**
-     * Sets the transaction registry from the XAConnectionFactory used to create the pool.
-     * The transaction registry can only be set once using either a connector or this setter
-     * method.
-     * @param transactionRegistry the transaction registry acquired from the XAConnectionFactory
-     * used to create the pool
+     * Sets the transaction registry from the XAConnectionFactory used to create the pool. The transaction registry can
+     * only be set once using either a connector or this setter method.
+     *
+     * @param transactionRegistry
+     *            the transaction registry acquired from the XAConnectionFactory used to create the pool
      */
     public void setTransactionRegistry(final TransactionRegistry transactionRegistry) {
-        if(this.transactionRegistry != null) {
+        if (this.transactionRegistry != null) {
             throw new IllegalStateException("TransactionRegistry already set");
         }
-        if(transactionRegistry == null) {
-            throw new NullPointerException("TransactionRegistry is null");
-        }
+        Objects.requireNonNull(transactionRegistry, "transactionRegistry is null");
 
         this.transactionRegistry = transactionRegistry;
     }
@@ -78,7 +77,6 @@ public class ManagedDataSource<C extends Connection> extends PoolingDataSource<C
             throw new IllegalStateException("TransactionRegistry has not been set");
         }
 
-        final Connection connection = new ManagedConnection<>(getPool(), transactionRegistry, isAccessToUnderlyingConnectionAllowed());
-        return connection;
+        return new ManagedConnection<>(getPool(), transactionRegistry, isAccessToUnderlyingConnectionAllowed());
     }
 }

==================================================
PoolableManagedConnectionFactory.java
index 4a01ea1a0a..1d70d1416f 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/PoolableManagedConnection.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/PoolableManagedConnection.java
@@ -33,39 +33,43 @@ import org.apache.tomcat.dbcp.pool2.ObjectPool;
 public class PoolableManagedConnection extends PoolableConnection {
     private final TransactionRegistry transactionRegistry;
 
-
     /**
      * Create a PoolableManagedConnection.
      *
-     * @param transactionRegistry transaction registry
-     * @param conn underlying connection
-     * @param pool connection pool
+     * @param transactionRegistry
+     *            transaction registry
+     * @param conn
+     *            underlying connection
+     * @param pool
+     *            connection pool
      */
-    public PoolableManagedConnection(final TransactionRegistry transactionRegistry,
-            final Connection conn, final ObjectPool<PoolableConnection> pool) {
+    public PoolableManagedConnection(final TransactionRegistry transactionRegistry, final Connection conn,
+            final ObjectPool<PoolableConnection> pool) {
         this(transactionRegistry, conn, pool, null, false);
     }
 
-
     /**
      * Create a PoolableManagedConnection.
      *
-     * @param transactionRegistry transaction registry
-     * @param conn underlying connection
-     * @param pool connection pool
-     * @param disconnectSqlCodes SQL_STATE codes considered fatal disconnection errors
-     * @param fastFailValidation true means fatal disconnection errors cause subsequent
-     *        validations to fail immediately (no attempt to run query or isValid)
+     * @param transactionRegistry
+     *            transaction registry
+     * @param conn
+     *            underlying connection
+     * @param pool
+     *            connection pool
+     * @param disconnectSqlCodes
+     *            SQL_STATE codes considered fatal disconnection errors
+     * @param fastFailValidation
+     *            true means fatal disconnection errors cause subsequent validations to fail immediately (no attempt to
+     *            run query or isValid)
      */
-    public PoolableManagedConnection(final TransactionRegistry transactionRegistry,
-            final Connection conn, final ObjectPool<PoolableConnection> pool,
-            final Collection<String> disconnectSqlCodes,
+    public PoolableManagedConnection(final TransactionRegistry transactionRegistry, final Connection conn,
+            final ObjectPool<PoolableConnection> pool, final Collection<String> disconnectSqlCodes,
             final boolean fastFailValidation) {
         super(conn, pool, null, disconnectSqlCodes, fastFailValidation);
         this.transactionRegistry = transactionRegistry;
     }
 
-
     /**
      * Actually close the underlying connection.
      */

==================================================
TransactionContext.java
index 34bb46672e..7a26a5fc98 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/PoolableManagedConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/PoolableManagedConnectionFactory.java
@@ -44,26 +44,26 @@ public class PoolableManagedConnectionFactory extends PoolableConnectionFactory
     private final TransactionRegistry transactionRegistry;
 
     /**
-     * Create a PoolableManagedConnectionFactory and attach it to a connection pool.
+     * Creates a PoolableManagedConnectionFactory and attach it to a connection pool.
      *
-     * @param connFactory XAConnectionFactory
-     * @param dataSourceJmxName JMX name of the datasource
+     * @param connFactory
+     *            XAConnectionFactory
+     * @param dataSourceJmxName
+     *            The data source name.
      */
-    public PoolableManagedConnectionFactory(final XAConnectionFactory connFactory,
-            final ObjectName dataSourceJmxName) {
+    public PoolableManagedConnectionFactory(final XAConnectionFactory connFactory, final ObjectName dataSourceJmxName) {
         super(connFactory, dataSourceJmxName);
         this.transactionRegistry = connFactory.getTransactionRegistry();
     }
 
     /**
-     * Uses the configured XAConnectionFactory to create a {@link PoolableManagedConnection}.
-     * Throws <code>IllegalStateException</code> if the connection factory returns null.
-     * Also initializes the connection using configured initialization sql (if provided)
-     * and sets up a prepared statement pool associated with the PoolableManagedConnection
-     * if statement pooling is enabled.
+     * Uses the configured XAConnectionFactory to create a {@link PoolableManagedConnection}. Throws
+     * <code>IllegalStateException</code> if the connection factory returns null. Also initializes the connection using
+     * configured initialization SQL (if provided) and sets up a prepared statement pool associated with the
+     * PoolableManagedConnection if statement pooling is enabled.
      */
     @Override
-    public synchronized PooledObject<PoolableConnection> makeObject() throws Exception {
+    synchronized public PooledObject<PoolableConnection> makeObject() throws Exception {
         Connection conn = getConnectionFactory().createConnection();
         if (conn == null) {
             throw new IllegalStateException("Connection factory returned null from createConnection");
@@ -71,7 +71,7 @@ public class PoolableManagedConnectionFactory extends PoolableConnectionFactory
         initializeConnection(conn);
         if (getPoolStatements()) {
             conn = new PoolingConnection(conn);
-            final GenericKeyedObjectPoolConfig<DelegatingPreparedStatement> config = new GenericKeyedObjectPoolConfig<>();
+            final GenericKeyedObjectPoolConfig config = new GenericKeyedObjectPoolConfig();
             config.setMaxTotalPerKey(-1);
             config.setBlockWhenExhausted(false);
             config.setMaxWaitMillis(0);
@@ -88,15 +88,14 @@ public class PoolableManagedConnectionFactory extends PoolableConnectionFactory
             } else {
                 config.setJmxEnabled(false);
             }
-            final KeyedObjectPool<PStmtKey,DelegatingPreparedStatement> stmtPool =
-                new GenericKeyedObjectPool<>((PoolingConnection)conn, config);
-            ((PoolingConnection)conn).setStatementPool(stmtPool);
+            final KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> stmtPool = new GenericKeyedObjectPool<>(
+                    (PoolingConnection) conn, config);
+            ((PoolingConnection) conn).setStatementPool(stmtPool);
             ((PoolingConnection) conn).setCacheState(getCacheState());
         }
-        final PoolableManagedConnection pmc =
-                new PoolableManagedConnection(transactionRegistry, conn, getPool(),
-                        getDisconnectionSqlCodes(), isFastFailValidation());
+        final PoolableManagedConnection pmc = new PoolableManagedConnection(transactionRegistry, conn, getPool(),
+                getDisconnectionSqlCodes(), isFastFailValidation());
         pmc.setCacheState(getCacheState());
-        return new DefaultPooledObject<>(pmc);
+        return new DefaultPooledObject<PoolableConnection>(pmc);
     }
 }

==================================================
TransactionContextListener.java
index f4c10595af..65a5c2ecba 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/TransactionContext.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/TransactionContext.java
@@ -20,6 +20,7 @@ package org.apache.tomcat.dbcp.dbcp2.managed;
 import java.lang.ref.WeakReference;
 import java.sql.Connection;
 import java.sql.SQLException;
+import java.util.Objects;
 
 import javax.transaction.RollbackException;
 import javax.transaction.Status;
@@ -29,43 +30,39 @@ import javax.transaction.Transaction;
 import javax.transaction.xa.XAResource;
 
 /**
- * TransactionContext represents the association between a single XAConnectionFactory and a Transaction.
- * This context contains a single shared connection which should be used by all ManagedConnections for
- * the XAConnectionFactory, the ability to listen for the transaction completion event, and a method
- * to check the status of the transaction.
+ * TransactionContext represents the association between a single XAConnectionFactory and a Transaction. This context
+ * contains a single shared connection which should be used by all ManagedConnections for the XAConnectionFactory, the
+ * ability to listen for the transaction completion event, and a method to check the status of the transaction.
  *
- * @author Dain Sundstrom
  * @since 2.0
  */
 public class TransactionContext {
     private final TransactionRegistry transactionRegistry;
     private final WeakReference<Transaction> transactionRef;
     private Connection sharedConnection;
+    private boolean transactionComplete;
 
     /**
-     * Creates a TransactionContext for the specified Transaction and TransactionRegistry.  The
-     * TransactionRegistry is used to obtain the XAResource for the shared connection when it is
-     * enlisted in the transaction.
+     * Creates a TransactionContext for the specified Transaction and TransactionRegistry. The TransactionRegistry is
+     * used to obtain the XAResource for the shared connection when it is enlisted in the transaction.
      *
-     * @param transactionRegistry the TransactionRegistry used to obtain the XAResource for the
-     * shared connection
-     * @param transaction the transaction
+     * @param transactionRegistry
+     *            the TransactionRegistry used to obtain the XAResource for the shared connection
+     * @param transaction
+     *            the transaction
      */
     public TransactionContext(final TransactionRegistry transactionRegistry, final Transaction transaction) {
-        if (transactionRegistry == null) {
-            throw new NullPointerException("transactionRegistry is null");
-        }
-        if (transaction == null) {
-            throw new NullPointerException("transaction is null");
-        }
+        Objects.requireNonNull(transactionRegistry, "transactionRegistry is null");
+        Objects.requireNonNull(transaction, "transaction is null");
         this.transactionRegistry = transactionRegistry;
         this.transactionRef = new WeakReference<>(transaction);
+        this.transactionComplete = false;
     }
 
     /**
-     * Gets the connection shared by all ManagedConnections in the transaction.  Specifically,
-     * connection using the same XAConnectionFactory from which the TransactionRegistry was
-     * obtained.
+     * Gets the connection shared by all ManagedConnections in the transaction. Specifically, connection using the same
+     * XAConnectionFactory from which the TransactionRegistry was obtained.
+     *
      * @return the shared connection for this transaction
      */
     public Connection getSharedConnection() {
@@ -73,13 +70,13 @@ public class TransactionContext {
     }
 
     /**
-     * Sets the shared connection for this transaction.  The shared connection is enlisted
-     * in the transaction.
+     * Sets the shared connection for this transaction. The shared connection is enlisted in the transaction.
      *
-     * @param sharedConnection the shared connection
-     * @throws SQLException if a shared connection is already set, if XAResource for the connection
-     * could not be found in the transaction registry, or if there was a problem enlisting the
-     * connection in the transaction
+     * @param sharedConnection
+     *            the shared connection
+     * @throws SQLException
+     *             if a shared connection is already set, if XAResource for the connection could not be found in the
+     *             transaction registry, or if there was a problem enlisting the connection in the transaction
      */
     public void setSharedConnection(final Connection sharedConnection) throws SQLException {
         if (this.sharedConnection != null) {
@@ -91,9 +88,12 @@ public class TransactionContext {
         final Transaction transaction = getTransaction();
         try {
             final XAResource xaResource = transactionRegistry.getXAResource(sharedConnection);
-            if ( !transaction.enlistResource(xaResource) ) {
+            if (!transaction.enlistResource(xaResource)) {
                 throw new SQLException("Unable to enlist connection in transaction: enlistResource returns 'false'.");
             }
+        } catch (final IllegalStateException e) {
+            // This can happen if the transaction is already timed out
+            throw new SQLException("Unable to enlist connection in the transaction", e);
         } catch (final RollbackException e) {
             // transaction was rolled back... proceed as if there never was a transaction
         } catch (final SystemException e) {
@@ -106,14 +106,17 @@ public class TransactionContext {
     /**
      * Adds a listener for transaction completion events.
      *
-     * @param listener the listener to add
-     * @throws SQLException if a problem occurs adding the listener to the transaction
+     * @param listener
+     *            the listener to add
+     * @throws SQLException
+     *             if a problem occurs adding the listener to the transaction
      */
     public void addTransactionContextListener(final TransactionContextListener listener) throws SQLException {
         try {
             getTransaction().registerSynchronization(new Synchronization() {
                 @Override
                 public void beforeCompletion() {
+                    // empty
                 }
 
                 @Override
@@ -131,8 +134,10 @@ public class TransactionContext {
 
     /**
      * True if the transaction is active or marked for rollback only.
+     *
      * @return true if the transaction is active or marked for rollback only; false otherwise
-     * @throws SQLException if a problem occurs obtaining the transaction status
+     * @throws SQLException
+     *             if a problem occurs obtaining the transaction status
      */
     public boolean isActive() throws SQLException {
         try {
@@ -154,4 +159,24 @@ public class TransactionContext {
         }
         return transaction;
     }
+
+    /**
+     * Sets the transaction complete flag to true.
+     *
+     * @since 2.4.0
+     */
+    public void completeTransaction() {
+        this.transactionComplete = true;
+    }
+
+    /**
+     * Gets the transaction complete flag to true.
+     *
+     * @return The transaction complete flag.
+     *
+     * @since 2.4.0
+     */
+    public boolean isTransactionComplete() {
+        return this.transactionComplete;
+    }
 }

==================================================
TransactionRegistry.java
index 6b25a4bf2d..567eb16b76 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/TransactionContextListener.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/TransactionContextListener.java
@@ -20,14 +20,16 @@ package org.apache.tomcat.dbcp.dbcp2.managed;
 /**
  * A listener for transaction completion events.
  *
- * @author Dain Sundstrom
  * @since 2.0
  */
 public interface TransactionContextListener {
     /**
      * Occurs after the transaction commits or rolls back.
-     * @param transactionContext the transaction context that completed
-     * @param commited true if the transaction committed; false otherwise
+     *
+     * @param transactionContext
+     *            the transaction context that completed
+     * @param commited
+     *            true if the transaction committed; false otherwise
      */
     void afterCompletion(TransactionContext transactionContext, boolean commited);
 }

==================================================
XAConnectionFactory.java
index 7b05065fa2..b3c0e17cab 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/TransactionRegistry.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/TransactionRegistry.java
@@ -20,9 +20,9 @@ package org.apache.tomcat.dbcp.dbcp2.managed;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.Map;
+import java.util.Objects;
 import java.util.WeakHashMap;
 
-import javax.transaction.Status;
 import javax.transaction.SystemException;
 import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
@@ -30,58 +30,56 @@ import javax.transaction.xa.XAResource;
 
 import org.apache.tomcat.dbcp.dbcp2.DelegatingConnection;
 
-
 /**
  * TransactionRegistry tracks Connections and XAResources in a transacted environment for a single XAConnectionFactory.
  * <p>
  * The TransactionRegistry hides the details of transaction processing from the existing DBCP pooling code, and gives
  * the ManagedConnection a way to enlist connections in a transaction, allowing for the maximal rescue of DBCP.
  * </p>
- * @author Dain Sundstrom
+ *
  * @since 2.0
  */
 public class TransactionRegistry {
     private final TransactionManager transactionManager;
-    private final Map<Transaction, TransactionContext> caches =
-            new WeakHashMap<>();
+    private final Map<Transaction, TransactionContext> caches = new WeakHashMap<>();
     private final Map<Connection, XAResource> xaResources = new WeakHashMap<>();
 
     /**
      * Creates a TransactionRegistry for the specified transaction manager.
-     * @param transactionManager the transaction manager used to enlist connections
+     *
+     * @param transactionManager
+     *            the transaction manager used to enlist connections.
      */
     public TransactionRegistry(final TransactionManager transactionManager) {
         this.transactionManager = transactionManager;
     }
 
     /**
-     * Registers the association between a Connection and a XAResource.  When a connection
-     * is enlisted in a transaction, it is actually the XAResource that is given to the transaction
-     * manager.
+     * Registers the association between a Connection and a XAResource. When a connection is enlisted in a transaction,
+     * it is actually the XAResource that is given to the transaction manager.
      *
-     * @param connection the JDBC connection
-     * @param xaResource the XAResource which managed the connection within a transaction
+     * @param connection
+     *            The JDBC connection.
+     * @param xaResource
+     *            The XAResource which managed the connection within a transaction.
      */
     public synchronized void registerConnection(final Connection connection, final XAResource xaResource) {
-        if (connection == null) {
-            throw new NullPointerException("connection is null");
-        }
-        if (xaResource == null) {
-            throw new NullPointerException("xaResource is null");
-        }
+        Objects.requireNonNull(connection, "connection is null");
+        Objects.requireNonNull(xaResource, "xaResource is null");
         xaResources.put(connection, xaResource);
     }
 
     /**
      * Gets the XAResource registered for the connection.
-     * @param connection the connection
-     * @return the XAResource registered for the connection; never null
-     * @throws SQLException if the connection does not have a registered XAResource
+     *
+     * @param connection
+     *            the connection
+     * @return The XAResource registered for the connection; never null.
+     * @throws SQLException
+     *             Thrown when the connection does not have a registered XAResource.
      */
     public synchronized XAResource getXAResource(final Connection connection) throws SQLException {
-        if (connection == null) {
-            throw new NullPointerException("connection is null");
-        }
+        Objects.requireNonNull(connection, "connection is null");
         final Connection key = getConnectionKey(connection);
         final XAResource xaResource = xaResources.get(key);
         if (xaResource == null) {
@@ -92,8 +90,10 @@ public class TransactionRegistry {
 
     /**
      * Gets the active TransactionContext or null if not Transaction is active.
-     * @return the active TransactionContext or null if no Transaction is active
-     * @throws SQLException if an error occurs while fetching the transaction
+     *
+     * @return The active TransactionContext or null if no Transaction is active.
+     * @throws SQLException
+     *             Thrown when an error occurs while fetching the transaction.
      */
     public TransactionContext getActiveTransactionContext() throws SQLException {
         Transaction transaction = null;
@@ -105,11 +105,8 @@ public class TransactionRegistry {
                 return null;
             }
 
-            // is it active
-            final int status = transaction.getStatus();
-            if (status != Status.STATUS_ACTIVE && status != Status.STATUS_MARKED_ROLLBACK) {
-                return null;
-            }
+            // This is the transaction on the thread so no need to check it's status - we should try to use it and
+            // fail later based on the subsequent status
         } catch (final SystemException e) {
             throw new SQLException("Unable to determine current transaction ", e);
         }
@@ -126,15 +123,16 @@ public class TransactionRegistry {
     }
 
     /**
-     * Unregisters a destroyed connection from {@link TransactionRegistry}
-     * @param connection The connection
+     * Unregisters a destroyed connection from {@link TransactionRegistry}.
+     *
+     * @param connection
+     *            A destroyed connection from {@link TransactionRegistry}.
      */
     public synchronized void unregisterConnection(final Connection connection) {
         final Connection key = getConnectionKey(connection);
         xaResources.remove(key);
     }
 
-
     private Connection getConnectionKey(final Connection connection) {
         Connection result;
         if (connection instanceof DelegatingConnection) {
@@ -145,4 +143,3 @@ public class TransactionRegistry {
         return result;
     }
 }
-

==================================================
package-info.java
index 958b0f3bb3..db0b9c079d 100644
--- a/java/org/apache/tomcat/dbcp/dbcp2/managed/XAConnectionFactory.java
+++ b/java/org/apache/tomcat/dbcp/dbcp2/managed/XAConnectionFactory.java
@@ -23,21 +23,17 @@ import java.sql.SQLException;
 import org.apache.tomcat.dbcp.dbcp2.ConnectionFactory;
 
 /**
- * XAConnectionFactory is an extension of ConnectionFactory used to create connections
- * in a transaction managed environment.  The XAConnectionFactory operates like a normal
- * ConnectionFactory except a TransactionRegistry is provided from which the XAResource
- * for a connection can be obtained.  This allows the existing DBCP pool code to work with
- * XAConnections and gives a the ManagedConnection a way to enlist a connection in the
- * the transaction.
+ * XAConnectionFactory is an extension of ConnectionFactory used to create connections in a transaction managed
+ * environment. The XAConnectionFactory operates like a normal ConnectionFactory except a TransactionRegistry is
+ * provided from which the XAResource for a connection can be obtained. This allows the existing DBCP pool code to work
+ * with XAConnections and gives a the ManagedConnection a way to enlist a connection in the the transaction.
  *
- * @author Dain Sundstrom
- * @author Rodney Waldhoff
  * @since 2.0
  */
 public interface XAConnectionFactory extends ConnectionFactory {
     /**
-     * Gets the TransactionRegistry for this connection factory which contains a the
-     * XAResource for every connection created by this factory.
+     * Gets the TransactionRegistry for this connection factory which contains a the XAResource for every connection
+     * created by this factory.
      *
      * @return the transaction registry for this connection factory
      */
@@ -46,13 +42,13 @@ public interface XAConnectionFactory extends ConnectionFactory {
     /**
      * Create a new {@link java.sql.Connection} in an implementation specific fashion.
      * <p>
-     * An implementation can assume that the caller of this will wrap the connection in
-     * a proxy that protects access to the setAutoCommit, commit and rollback when
-     * enrolled in a XA transaction.
+     * An implementation can assume that the caller of this will wrap the connection in a proxy that protects access to
+     * the setAutoCommit, commit and rollback when enrolled in a XA transaction.
      * </p>
      *
      * @return a new {@link java.sql.Connection}
-     * @throws java.sql.SQLException if a database error occurs creating the connection
+     * @throws java.sql.SQLException
+     *             if a database error occurs creating the connection
      */
     @Override
     Connection createConnection() throws SQLException;

==================================================
