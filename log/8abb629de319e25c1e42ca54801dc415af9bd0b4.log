8abb629de319e25c1e42ca54801dc415af9bd0b4
==================================================
Clean-up. No functional change.
==================================================
Mark Emlyn
==================================================
Thu Oct 20 19:52:47 2011 +0000
==================================================
Catalina.java
index 04c8543d75..0f09418baa 100644
--- a/TOMCAT-NEXT.txt
+++ b/TOMCAT-NEXT.txt
@@ -42,4 +42,8 @@ but possibly 7.1.x).
 
 8. Review the connector shutdown code for timing and threading issues
    particularly any that may result in a client socket being left open after a
-   connector.stop(). 
\ No newline at end of file
+   connector.stop(). 
+
+9. Remove all the static info attributes and associated getters.
+
+10. Remove the svn keywords from all the files. 
\ No newline at end of file

==================================================
AccessLogValve.java
index 4e7e814e62..0224e0c6c3 100644
--- a/java/org/apache/catalina/startup/Catalina.java
+++ b/java/org/apache/catalina/startup/Catalina.java
@@ -14,8 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.startup;
 
 
@@ -71,7 +69,6 @@ import org.xml.sax.SAXParseException;
  * @author Remy Maucherat
  * @version $Id$
  */
-
 public class Catalina {
 
 
@@ -277,8 +274,9 @@ public class Catalina {
     protected File configFile() {
 
         File file = new File(configFile);
-        if (!file.isAbsolute())
+        if (!file.isAbsolute()) {
             file = new File(System.getProperty(Globals.CATALINA_BASE_PROP), configFile);
+        }
         return (file);
 
     }
@@ -383,8 +381,9 @@ public class Catalina {
         digester.addRuleSet(new ClusterRuleSet("Server/Service/Engine/Cluster/"));
 
         long t2=System.currentTimeMillis();
-        if (log.isDebugEnabled())
+        if (log.isDebugEnabled()) {
             log.debug("Digester for server.xml created " + ( t2-t1 ));
+        }
         return (digester);
 
     }
@@ -457,8 +456,9 @@ public class Catalina {
                 Socket socket = new Socket(s.getAddress(), s.getPort());
                 OutputStream stream = socket.getOutputStream();
                 String shutdown = s.getShutdown();
-                for (int i = 0; i < shutdown.length(); i++)
+                for (int i = 0; i < shutdown.length(); i++) {
                     stream.write(shutdown.charAt(i));
+                }
                 stream.flush();
                 stream.close();
                 socket.close();
@@ -572,16 +572,18 @@ public class Catalina {
         try {
             getServer().init();
         } catch (LifecycleException e) {
-            if (Boolean.getBoolean("org.apache.catalina.startup.EXIT_ON_INIT_FAILURE"))
+            if (Boolean.getBoolean("org.apache.catalina.startup.EXIT_ON_INIT_FAILURE")) {
                 throw new java.lang.Error(e);
-            else
+            } else {
                 log.error("Catalina.start", e);
+            }
 
         }
 
         long t2 = System.nanoTime();
-        if(log.isInfoEnabled())
+        if(log.isInfoEnabled()) {
             log.info("Initialization processed in " + ((t2 - t1) / 1000000) + " ms");
+        }
 
     }
 
@@ -592,8 +594,9 @@ public class Catalina {
     public void load(String args[]) {
 
         try {
-            if (arguments(args))
+            if (arguments(args)) {
                 load();
+            }
         } catch (Exception e) {
             e.printStackTrace(System.out);
         }
@@ -624,8 +627,9 @@ public class Catalina {
         }
 
         long t2 = System.nanoTime();
-        if(log.isInfoEnabled())
+        if(log.isInfoEnabled()) {
             log.info("Server startup in " + ((t2 - t1) / 1000000) + " ms");
+        }
 
         try {
             // Register shutdown hook
@@ -807,8 +811,9 @@ public class Catalina {
                 value = value + ":" + oldValue;
             }
             System.setProperty(javax.naming.Context.URL_PKG_PREFIXES, value);
-            if( log.isDebugEnabled() )
+            if( log.isDebugEnabled() ) {
                 log.debug("Setting naming prefix=" + value);
+            }
             value = System.getProperty
                 (javax.naming.Context.INITIAL_CONTEXT_FACTORY);
             if (value == null) {
@@ -889,8 +894,9 @@ final class SetParentClassLoaderRule extends Rule {
     public void begin(String namespace, String name, Attributes attributes)
         throws Exception {
 
-        if (digester.getLogger().isDebugEnabled())
+        if (digester.getLogger().isDebugEnabled()) {
             digester.getLogger().debug("Setting parent class loader");
+        }
 
         Container top = (Container) digester.peek();
         top.setParentClassLoader(parentClassLoader);

==================================================
CometConnectionManagerValve.java
index daf3fed935..3cc31dc892 100644
--- a/java/org/apache/catalina/valves/AccessLogValve.java
+++ b/java/org/apache/catalina/valves/AccessLogValve.java
@@ -14,8 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.valves;
 
 
@@ -132,7 +130,7 @@ import org.apache.tomcat.util.buf.B2CConverter;
  * been made available to allow you to tell this instance to move
  * the existing log file to somewhere else and start writing a new log file.
  * </p>
- * 
+ *
  * <p>
  * Conditional logging is also supported. This can be done with the
  * <code>conditionUnless</code> and <code>conditionIf</code> properties.
@@ -143,7 +141,7 @@ import org.apache.tomcat.util.buf.B2CConverter;
  * The <code>condition</code> attribute is synonym for
  * <code>conditionUnless</code> and is provided for backwards compatibility.
  * </p>
- * 
+ *
  * <p>
  * For extended attributes coming from a getAttribute() call,
  * it is you responsibility to ensure there are no newline or
@@ -155,7 +153,7 @@ import org.apache.tomcat.util.buf.B2CConverter;
  * @author Remy Maucherat
  * @author Takayuki Kaneko
  * @author Peter Rossbach
- * 
+ *
  * @version $Id$
  */
 
@@ -244,7 +242,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
      */
     private static final TimeZone timezone;
 
-    
+
     /**
      * The time zone offset relative to GMT in text form when daylight saving
      * is not in operation.
@@ -257,7 +255,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
      * is in operation.
      */
     private static final String timeZoneDST;
-    
+
     /**
      * The size of our global date format cache
      */
@@ -268,7 +266,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
      */
     private static final int localCacheSize = 60;
 
-    
+
     /**
      * The current log file we are writing to. Helpful when checkExists
      * is true.
@@ -322,7 +320,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
             /* Helper object to be able to call SimpleDateFormat.format(). */
             private final Date currentDate = new Date();
 
-            private String cache[];
+            private final String cache[];
             private SimpleDateFormat formatter;
             private boolean isCLF = false;
 
@@ -428,10 +426,10 @@ public class AccessLogValve extends ValveBase implements AccessLog {
         /* Number of cached entries */
         private int cacheSize = 0;
 
-        private Locale cacheDefaultLocale;
-        private DateFormatCache parent;
-        private Cache cLFCache;
-        private HashMap<String, Cache> formatCache = new HashMap<String, Cache>();
+        private final Locale cacheDefaultLocale;
+        private final DateFormatCache parent;
+        private final Cache cLFCache;
+        private final HashMap<String, Cache> formatCache = new HashMap<String, Cache>();
 
         private DateFormatCache(int size, Locale loc, DateFormatCache parent) {
             cacheSize = size;
@@ -652,14 +650,15 @@ public class AccessLogValve extends ValveBase implements AccessLog {
      * @param pattern The new pattern
      */
     public void setPattern(String pattern) {
-        if (pattern == null)
+        if (pattern == null) {
             this.pattern = "";
-        else if (pattern.equals(Constants.AccessLog.COMMON_ALIAS))
+        } else if (pattern.equals(Constants.AccessLog.COMMON_ALIAS)) {
             this.pattern = Constants.AccessLog.COMMON_PATTERN;
-        else if (pattern.equals(Constants.AccessLog.COMBINED_ALIAS))
+        } else if (pattern.equals(Constants.AccessLog.COMBINED_ALIAS)) {
             this.pattern = Constants.AccessLog.COMBINED_PATTERN;
-        else
+        } else {
             this.pattern = pattern;
+        }
         logElements = createLogElements();
     }
 
@@ -684,8 +683,8 @@ public class AccessLogValve extends ValveBase implements AccessLog {
         this.checkExists = checkExists;
 
     }
-    
-    
+
+
     /**
      * Return the log file prefix.
      */
@@ -887,7 +886,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
 
     /**
      * Set the character set that is used to write the log file.
-     * 
+     *
      * @param encoding The name of the character set.
      */
     public void setEncoding(String encoding) {
@@ -911,7 +910,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
                 buffered) {
             writer.flush();
         }
-    }    
+    }
 
     /**
      * Log a message summarizing the specified request and response, according
@@ -926,10 +925,10 @@ public class AccessLogValve extends ValveBase implements AccessLog {
     @Override
     public void invoke(Request request, Response response) throws IOException,
             ServletException {
-        getNext().invoke(request, response);       
+        getNext().invoke(request, response);
     }
 
-    
+
     @Override
     public void log(Request request, Response response, long time) {
         if (!getState().isAvailable() || !getEnabled() || logElements == null
@@ -1024,11 +1023,11 @@ public class AccessLogValve extends ValveBase implements AccessLog {
                 synchronized(this) {
                     if ((systime - rotationLastChecked) > 1000) {
                         rotationLastChecked = systime;
-    
+
                         String tsDate;
                         // Check for a change of date
                         tsDate = fileDateFormatter.format(new Date(systime));
-    
+
                         // If the date has changed, switch log files
                         if (!dateStamp.equals(tsDate)) {
                             close();
@@ -1039,7 +1038,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
                 }
             }
         }
-        
+
         /* In case something external rotated the file instead */
         if (checkExists) {
             synchronized (this) {
@@ -1079,8 +1078,9 @@ public class AccessLogValve extends ValveBase implements AccessLog {
     protected synchronized void open() {
         // Create the directory if necessary
         File dir = new File(directory);
-        if (!dir.isAbsolute())
+        if (!dir.isAbsolute()) {
             dir = new File(System.getProperty(Globals.CATALINA_BASE_PROP), directory);
+        }
         if (!dir.mkdirs() && !dir.isDirectory()) {
             log.error(sm.getString("accessLogValve.openDirFail", dir));
         }
@@ -1124,14 +1124,14 @@ public class AccessLogValve extends ValveBase implements AccessLog {
             log.error(sm.getString("accessLogValve.openFail", pathname), e);
         }
     }
- 
+
     /**
      * This method returns a Date object that is accurate to within one second.
      * If a thread calls this method to get a Date and it's been less than 1
      * second since a new Date was created, this method simply gives out the
      * same Date again so that the system doesn't spend time creating Date
      * objects unnecessarily.
-     * 
+     *
      * @return Date
      */
     private static Date getDate(long systime) {
@@ -1148,8 +1148,8 @@ public class AccessLogValve extends ValveBase implements AccessLog {
             return timeZoneNoDST;
         }
     }
-    
-    
+
+
     private static String calculateTimeZoneOffset(long offset) {
         StringBuilder tz = new StringBuilder();
         if ((offset < 0)) {
@@ -1162,12 +1162,14 @@ public class AccessLogValve extends ValveBase implements AccessLog {
         long hourOffset = offset / (1000 * 60 * 60);
         long minuteOffset = (offset / (1000 * 60)) % 60;
 
-        if (hourOffset < 10)
+        if (hourOffset < 10) {
             tz.append("0");
+        }
         tz.append(hourOffset);
 
-        if (minuteOffset < 10)
+        if (minuteOffset < 10) {
             tz.append("0");
+        }
         tz.append(minuteOffset);
 
         return tz.toString();
@@ -1219,7 +1221,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
         fileDateFormatter.setTimeZone(timezone);
         dateStamp = fileDateFormatter.format(new Date(System.currentTimeMillis()));
         open();
-        
+
         setState(LifecycleState.STARTING);
     }
 
@@ -1233,11 +1235,11 @@ public class AccessLogValve extends ValveBase implements AccessLog {
      */
     @Override
     protected synchronized void stopInternal() throws LifecycleException {
-        
+
         setState(LifecycleState.STOPPING);
         close();
     }
-    
+
     /**
      * AccessLogElement writes the partial message into the buffer.
      */
@@ -1246,7 +1248,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
                 Response response, long time);
 
     }
-    
+
     /**
      * write thread name - %I
      */
@@ -1262,12 +1264,12 @@ public class AccessLogValve extends ValveBase implements AccessLog {
             }
         }
     }
-    
+
     /**
      * write local IP address - %A
      */
     protected static class LocalAddrElement implements AccessLogElement {
-        
+
         private static final String LOCAL_ADDR_VALUE;
 
         static {
@@ -1280,14 +1282,14 @@ public class AccessLogValve extends ValveBase implements AccessLog {
             }
             LOCAL_ADDR_VALUE = init;
         }
-        
+
         @Override
         public void addElement(StringBuilder buf, Date date, Request request,
                 Response response, long time) {
             buf.append(LOCAL_ADDR_VALUE);
         }
     }
-    
+
     /**
      * write remote IP address - %a
      */
@@ -1307,7 +1309,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
             }
         }
     }
-    
+
     /**
      * write remote host name - %h
      */
@@ -1331,7 +1333,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
             buf.append(value);
         }
     }
-    
+
     /**
      * write remote logical username from identd (always returns '-') - %l
      */
@@ -1342,7 +1344,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
             buf.append('-');
         }
     }
-    
+
     /**
      * write request protocol - %H
      */
@@ -1617,7 +1619,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
      * write bytes sent, excluding HTTP headers - %b, %B
      */
     protected static class ByteSentElement implements AccessLogElement {
-        private boolean conversion;
+        private final boolean conversion;
 
         /**
          * if conversion is true, write '-' instead of 0 - %b
@@ -1657,7 +1659,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
      * write time taken to process the request - %D, %T
      */
     protected static class ElapsedTimeElement implements AccessLogElement {
-        private boolean millis;
+        private final boolean millis;
 
         /**
          * if millis is true, write time in millis - %D
@@ -1684,7 +1686,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
             }
         }
     }
-    
+
     /**
      * write Query string (prepended with a '?' if it exists) - %q
      */
@@ -1693,8 +1695,9 @@ public class AccessLogValve extends ValveBase implements AccessLog {
         public void addElement(StringBuilder buf, Date date, Request request,
                 Response response, long time) {
             String query = null;
-            if (request != null)
+            if (request != null) {
                 query = request.getQueryString();
+            }
             if (query != null) {
                 buf.append('?');
                 buf.append(query);
@@ -1747,12 +1750,12 @@ public class AccessLogValve extends ValveBase implements AccessLog {
             buf.append(request.getServerName());
         }
     }
-    
+
     /**
      * write any string
      */
     protected static class StringElement implements AccessLogElement {
-        private String str;
+        private final String str;
 
         public StringElement(String str) {
             this.str = str;
@@ -1769,7 +1772,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
      * write incoming headers - %{xxx}i
      */
     protected static class HeaderElement implements AccessLogElement {
-        private String header;
+        private final String header;
 
         public HeaderElement(String header) {
             this.header = header;
@@ -1794,7 +1797,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
      * write a specific cookie - %{xxx}c
      */
     protected static class CookieElement implements AccessLogElement {
-        private String header;
+        private final String header;
 
         public CookieElement(String header) {
             this.header = header;
@@ -1821,12 +1824,12 @@ public class AccessLogValve extends ValveBase implements AccessLog {
      * write a specific response header - %{xxx}o
      */
     protected static class ResponseHeaderElement implements AccessLogElement {
-        private String header;
+        private final String header;
 
         public ResponseHeaderElement(String header) {
             this.header = header;
         }
-        
+
         @Override
         public void addElement(StringBuilder buf, Date date, Request request,
                 Response response, long time) {
@@ -1843,12 +1846,12 @@ public class AccessLogValve extends ValveBase implements AccessLog {
             buf.append('-');
         }
     }
-    
+
     /**
      * write an attribute in the ServletRequest - %{xxx}r
      */
     protected static class RequestAttributeElement implements AccessLogElement {
-        private String header;
+        private final String header;
 
         public RequestAttributeElement(String header) {
             this.header = header;
@@ -1879,7 +1882,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
      * write an attribute in the HttpSession - %{xxx}s
      */
     protected static class SessionAttributeElement implements AccessLogElement {
-        private String header;
+        private final String header;
 
         public SessionAttributeElement(String header) {
             this.header = header;
@@ -1891,8 +1894,9 @@ public class AccessLogValve extends ValveBase implements AccessLog {
             Object value = null;
             if (null != request) {
                 HttpSession sess = request.getSession(false);
-                if (null != sess)
+                if (null != sess) {
                     value = sess.getAttribute(header);
+                }
             } else {
                 value = "??";
             }
@@ -1972,7 +1976,7 @@ public class AccessLogValve extends ValveBase implements AccessLog {
         case 'r':
             return new RequestAttributeElement(header);
         case 's':
-            return new SessionAttributeElement(header);            
+            return new SessionAttributeElement(header);
         case 't':
             return new DateAndTimeElement(header);
         default:

==================================================
Constants.java
index 0036698ec3..97954109b1 100644
--- a/java/org/apache/catalina/valves/CometConnectionManagerValve.java
+++ b/java/org/apache/catalina/valves/CometConnectionManagerValve.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.valves;
 
 
@@ -55,7 +53,7 @@ import org.apache.catalina.connector.Response;
 
 public class CometConnectionManagerValve extends ValveBase
     implements HttpSessionListener, LifecycleListener {
-    
+
     //------------------------------------------------------ Constructor
     public CometConnectionManagerValve() {
         super(false);
@@ -77,7 +75,7 @@ public class CometConnectionManagerValve extends ValveBase
      */
     protected List<Request> cometRequests =
         Collections.synchronizedList(new ArrayList<Request>());
-    
+
 
     /**
      * Name of session attribute used to store list of comet connections.
@@ -121,11 +119,11 @@ public class CometConnectionManagerValve extends ValveBase
         }
     }
 
-    
+
     @Override
     public void lifecycleEvent(LifecycleEvent event) {
         if (Lifecycle.BEFORE_STOP_EVENT.equals(event.getType())) {
-            // The container is getting stopped, close all current connections 
+            // The container is getting stopped, close all current connections
             Iterator<Request> iterator = cometRequests.iterator();
             while (iterator.hasNext()) {
                 Request request = iterator.next();
@@ -180,15 +178,15 @@ public class CometConnectionManagerValve extends ValveBase
         throws IOException, ServletException {
         // Perform the request
         getNext().invoke(request, response);
-        
+
         if (request.isComet() && !response.isClosed()) {
-            // Start tracking this connection, since this is a 
+            // Start tracking this connection, since this is a
             // begin event, and Comet mode is on
             HttpSession session = request.getSession(true);
-            
+
             // Track the connection for webapp reload
             cometRequests.add(request);
-            
+
             // Track the connection for session expiration
             synchronized (session) {
                 Request[] requests = (Request[])
@@ -199,7 +197,7 @@ public class CometConnectionManagerValve extends ValveBase
                     session.setAttribute(cometRequestsAttribute,
                             requests);
                 } else {
-                    Request[] newRequests = 
+                    Request[] newRequests =
                         new Request[requests.length + 1];
                     for (int i = 0; i < requests.length; i++) {
                         newRequests[i] = requests[i];
@@ -209,10 +207,10 @@ public class CometConnectionManagerValve extends ValveBase
                 }
             }
         }
-        
+
     }
 
-    
+
     /**
      * Use events to update the connection state.
      *
@@ -225,22 +223,22 @@ public class CometConnectionManagerValve extends ValveBase
     @Override
     public void event(Request request, Response response, CometEvent event)
         throws IOException, ServletException {
-        
+
         // Perform the request
         boolean ok = false;
         try {
             getNext().event(request, response, event);
             ok = true;
         } finally {
-            if (!ok || response.isClosed() 
+            if (!ok || response.isClosed()
                     || (event.getEventType() == CometEvent.EventType.END)
                     || (event.getEventType() == CometEvent.EventType.ERROR
                             && !(event.getEventSubType() ==
                                 CometEvent.EventSubType.TIMEOUT))) {
-                
+
                 // Remove the connection from webapp reload tracking
                 cometRequests.remove(request);
-                
+
                 // Remove connection from session expiration tracking
                 // Note: can't get the session if it has been invalidated but
                 // OK since session listener will have done clean-up
@@ -262,7 +260,7 @@ public class CometConnectionManagerValve extends ValveBase
                             }
                             if (found) {
                                 if (reqs.length > 1) {
-                                    Request[] newConnectionInfos = 
+                                    Request[] newConnectionInfos =
                                         new Request[reqs.length - 1];
                                     int pos = 0;
                                     for (int i = 0; i < reqs.length; i++) {

==================================================
CrawlerSessionManagerValve.java
index 90ef58236c..b0d5909e2b 100644
--- a/java/org/apache/catalina/valves/Constants.java
+++ b/java/org/apache/catalina/valves/Constants.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.valves;
 
 

==================================================
ErrorReportValve.java
index bf4268cbc3..b3b9256d21 100644
--- a/java/org/apache/catalina/valves/CrawlerSessionManagerValve.java
+++ b/java/org/apache/catalina/valves/CrawlerSessionManagerValve.java
@@ -46,9 +46,9 @@ public class CrawlerSessionManagerValve extends ValveBase
     private static final Log log =
         LogFactory.getLog(CrawlerSessionManagerValve.class);
 
-    private Map<String,String> clientIpSessionId =
+    private final Map<String,String> clientIpSessionId =
         new ConcurrentHashMap<String, String>();
-    private Map<String,String> sessionIdClientIp =
+    private final Map<String,String> sessionIdClientIp =
         new ConcurrentHashMap<String, String>();
 
     private String crawlerUserAgents =
@@ -69,7 +69,7 @@ public class CrawlerSessionManagerValve extends ValveBase
      * Specify the regular expression (using {@link Pattern}) that will be used
      * to identify crawlers based in the User-Agent header provided. The default
      * is ".*GoogleBot.*|.*bingbot.*|.*Yahoo! Slurp.*"
-     *  
+     *
      * @param crawlerUserAgents The regular expression using {@link Pattern}
      */
     public void setCrawlerUserAgents(String crawlerUserAgents) {
@@ -83,7 +83,7 @@ public class CrawlerSessionManagerValve extends ValveBase
 
     /**
      * @see #setCrawlerUserAgents(String)
-     * @return  The current regular expression being used to match user agents. 
+     * @return  The current regular expression being used to match user agents.
      */
     public String getCrawlerUserAgents() {
         return crawlerUserAgents;
@@ -93,7 +93,7 @@ public class CrawlerSessionManagerValve extends ValveBase
     /**
      * Specify the session timeout (in seconds) for a crawler's session. This is
      * typically lower than that for a user session. The default is 60 seconds.
-     *  
+     *
      * @param sessionInactiveInterval   The new timeout for crawler sessions
      */
     public void setSessionInactiveInterval(int sessionInactiveInterval) {
@@ -117,7 +117,7 @@ public class CrawlerSessionManagerValve extends ValveBase
     @Override
     protected void initInternal() throws LifecycleException {
         super.initInternal();
-        
+
         uaPattern = Pattern.compile(crawlerUserAgents);
     }
 
@@ -145,24 +145,24 @@ public class CrawlerSessionManagerValve extends ValveBase
             if (uaHeaders.hasMoreElements()) {
                 uaHeader = uaHeaders.nextElement();
             }
-            
+
             // If more than one UA header - assume not a bot
             if (uaHeader != null && !uaHeaders.hasMoreElements()) {
 
                 if (log.isDebugEnabled()) {
                     log.debug(request.hashCode() + ": UserAgent=" + uaHeader);
                 }
-                
+
                 if (uaPattern.matcher(uaHeader).matches()) {
                     isBot = true;
-                    
+
                     if (log.isDebugEnabled()) {
                         log.debug(request.hashCode() +
                                 ": Bot found. UserAgent=" + uaHeader);
                     }
                 }
             }
-            
+
             // If this is a bot, is the session ID known?
             if (isBot) {
                 clientIp = request.getRemoteAddr();
@@ -178,7 +178,7 @@ public class CrawlerSessionManagerValve extends ValveBase
         }
 
         getNext().invoke(request, response);
-        
+
         if (isBot) {
             if (sessionId == null) {
                 // Has bot just created a session, if so make a note of it

==================================================
ExtendedAccessLogValve.java
index 98a29db864..7fcad1d602 100644
--- a/java/org/apache/catalina/valves/ErrorReportValve.java
+++ b/java/org/apache/catalina/valves/ErrorReportValve.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.valves;
 
 
@@ -98,7 +96,7 @@ public class ErrorReportValve extends ValveBase {
 
         // Perform the request
         getNext().invoke(request, response);
-        
+
         if (response.isCommitted()) {
             return;
         }
@@ -106,7 +104,7 @@ public class ErrorReportValve extends ValveBase {
         if (request.isAsyncStarted()) {
             return;
         }
-        
+
         Throwable throwable =
             (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);
 
@@ -157,12 +155,14 @@ public class ErrorReportValve extends ValveBase {
 
         // Do nothing on a 1xx, 2xx and 3xx status
         // Do nothing if anything has been written already
-        if ((statusCode < 400) || (response.getContentWritten() > 0))
+        if ((statusCode < 400) || (response.getContentWritten() > 0)) {
             return;
+        }
 
         String message = RequestUtil.filter(response.getMessage());
-        if (message == null)
+        if (message == null) {
             message = "";
+        }
 
         // Do nothing if there is no report for the specified status code
         String report = null;
@@ -171,8 +171,9 @@ public class ErrorReportValve extends ValveBase {
         } catch (Throwable t) {
             ExceptionUtils.handleThrowable(t);
         }
-        if (report == null)
+        if (report == null) {
             return;
+        }
 
         StringBuilder sb = new StringBuilder();
 
@@ -247,8 +248,9 @@ public class ErrorReportValve extends ValveBase {
                 response.setCharacterEncoding("utf-8");
             } catch (Throwable t) {
                 ExceptionUtils.handleThrowable(t);
-                if (container.getLogger().isDebugEnabled())
+                if (container.getLogger().isDebugEnabled()) {
                     container.getLogger().debug("status.setContentType", t);
+                }
             }
             Writer writer = response.getReporter();
             if (writer != null) {
@@ -261,12 +263,12 @@ public class ErrorReportValve extends ValveBase {
         } catch (IllegalStateException e) {
             // Ignore
         }
-        
+
     }
 
 
     /**
-     * Print out a partial servlet stack trace (truncating at the last 
+     * Print out a partial servlet stack trace (truncating at the last
      * occurrence of javax.servlet.).
      */
     protected String getPartialServletStackTrace(Throwable t) {

==================================================
JDBCAccessLogValve.java
index 5cfc290ab8..c7980fbe72 100644
--- a/java/org/apache/catalina/valves/ExtendedAccessLogValve.java
+++ b/java/org/apache/catalina/valves/ExtendedAccessLogValve.java
@@ -14,8 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.valves;
 
 
@@ -128,7 +126,7 @@ import org.apache.tomcat.util.ExceptionUtils;
  *
  * @author Tim Funk
  * @author Peter Rossbach
- * 
+ *
  * @version $Id$
  */
 
@@ -176,13 +174,15 @@ public class ExtendedAccessLogValve extends AccessLogValve {
     private String wrap(Object value) {
         String svalue;
         // Does the value contain a " ? If so must encode it
-        if (value == null || "-".equals(value))
+        if (value == null || "-".equals(value)) {
             return "-";
+        }
 
         try {
             svalue = value.toString();
-            if ("".equals(svalue))
+            if ("".equals(svalue)) {
                 return "-";
+            }
         } catch (Throwable e) {
             ExceptionUtils.handleThrowable(e);
             /* Log error */
@@ -229,7 +229,7 @@ public class ExtendedAccessLogValve extends AccessLogValve {
     protected static class DateElement implements AccessLogElement {
         // Milli-seconds in 24 hours
         private static final long INTERVAL = (1000 * 60 * 60 * 24);
-        
+
         private static final ThreadLocal<ElementTimestampStruct> currentDate =
                 new ThreadLocal<ElementTimestampStruct>() {
             @Override
@@ -237,7 +237,7 @@ public class ExtendedAccessLogValve extends AccessLogValve {
                 return new ElementTimestampStruct("yyyy-MM-dd");
             }
         };
-                
+
         @Override
         public void addElement(StringBuilder buf, Date date, Request request,
                 Response response, long time) {
@@ -250,14 +250,14 @@ public class ExtendedAccessLogValve extends AccessLogValve {
                 eds.currentTimestampString =
                     eds.currentTimestampFormat.format(eds.currentTimestamp);
             }
-            buf.append(eds.currentTimestampString);            
+            buf.append(eds.currentTimestampString);
         }
     }
-    
+
     protected static class TimeElement implements AccessLogElement {
-        // Milli-seconds in a second 
+        // Milli-seconds in a second
         private static final long INTERVAL = 1000;
-        
+
         private static final ThreadLocal<ElementTimestampStruct> currentTime =
                 new ThreadLocal<ElementTimestampStruct>() {
             @Override
@@ -265,7 +265,7 @@ public class ExtendedAccessLogValve extends AccessLogValve {
                 return new ElementTimestampStruct("HH:mm:ss");
             }
         };
-            
+
         @Override
         public void addElement(StringBuilder buf, Date date, Request request,
                 Response response, long time) {
@@ -278,13 +278,13 @@ public class ExtendedAccessLogValve extends AccessLogValve {
                 eds.currentTimestampString =
                     eds.currentTimestampFormat.format(eds.currentTimestamp);
             }
-            buf.append(eds.currentTimestampString);            
+            buf.append(eds.currentTimestampString);
         }
     }
-    
+
     protected class RequestHeaderElement implements AccessLogElement {
-        private String header;
-        
+        private final String header;
+
         public RequestHeaderElement(String header) {
             this.header = header;
         }
@@ -294,24 +294,24 @@ public class ExtendedAccessLogValve extends AccessLogValve {
             buf.append(wrap(request.getHeader(header)));
         }
     }
-    
+
     protected class ResponseHeaderElement implements AccessLogElement {
-        private String header;
-        
+        private final String header;
+
         public ResponseHeaderElement(String header) {
             this.header = header;
         }
-        
+
         @Override
         public void addElement(StringBuilder buf, Date date, Request request,
                 Response response, long time) {
             buf.append(wrap(response.getHeader(header)));
         }
     }
-    
+
     protected class ServletContextElement implements AccessLogElement {
-        private String attribute;
-        
+        private final String attribute;
+
         public ServletContextElement(String attribute) {
             this.attribute = attribute;
         }
@@ -322,10 +322,10 @@ public class ExtendedAccessLogValve extends AccessLogValve {
                     .getAttribute(attribute)));
         }
     }
-    
+
     protected class CookieElement implements AccessLogElement {
-        private String name;
-        
+        private final String name;
+
         public CookieElement(String name) {
             this.name = name;
         }
@@ -340,17 +340,17 @@ public class ExtendedAccessLogValve extends AccessLogValve {
             }
         }
     }
-    
+
     /**
      * write a specific response header - x-O(xxx)
      */
     protected class ResponseAllHeaderElement implements AccessLogElement {
-        private String header;
+        private final String header;
 
         public ResponseAllHeaderElement(String header) {
             this.header = header;
         }
-        
+
         @Override
         public void addElement(StringBuilder buf, Date date, Request request,
                 Response response, long time) {
@@ -372,24 +372,24 @@ public class ExtendedAccessLogValve extends AccessLogValve {
             buf.append("-");
         }
     }
-    
-    protected class RequestAttributeElement implements AccessLogElement { 
-        private String attribute;
-        
+
+    protected class RequestAttributeElement implements AccessLogElement {
+        private final String attribute;
+
         public RequestAttributeElement(String attribute) {
             this.attribute = attribute;
         }
-        
+
         @Override
         public void addElement(StringBuilder buf, Date date, Request request,
                 Response response, long time) {
             buf.append(wrap(request.getAttribute(attribute)));
-        }        
+        }
     }
-    
+
     protected class SessionAttributeElement implements AccessLogElement {
-        private String attribute;
-        
+        private final String attribute;
+
         public SessionAttributeElement(String attribute) {
             this.attribute = attribute;
         }
@@ -399,15 +399,16 @@ public class ExtendedAccessLogValve extends AccessLogValve {
             HttpSession session = null;
             if (request != null) {
                 session = request.getSession(false);
-                if (session != null)
+                if (session != null) {
                     buf.append(wrap(session.getAttribute(attribute)));
+                }
             }
         }
     }
-    
+
     protected class RequestParameterElement implements AccessLogElement {
-        private String parameter;
-        
+        private final String parameter;
+
         public RequestParameterElement(String parameter) {
             this.parameter = parameter;
         }
@@ -419,42 +420,43 @@ public class ExtendedAccessLogValve extends AccessLogValve {
                 return null;
             }
             return URLEncoder.encode(value);
-        }   
-        
+        }
+
         @Override
         public void addElement(StringBuilder buf, Date date, Request request,
                 Response response, long time) {
             buf.append(wrap(urlEncode(request.getParameter(parameter))));
         }
     }
-    
+
     protected static class PatternTokenizer {
         private StringReader sr = null;
         private StringBuilder buf = new StringBuilder();
         private boolean ended = false;
         private boolean subToken;
         private boolean parameter;
-        
+
         public PatternTokenizer(String str) {
             sr = new StringReader(str);
         }
-        
+
         public boolean hasSubToken() {
             return subToken;
         }
-        
+
         public boolean hasParameter() {
             return parameter;
         }
-        
+
         public String getToken() throws IOException {
-            if(ended)
+            if(ended) {
                 return null ;
-            
+            }
+
             String result = null;
             subToken = false;
             parameter = false;
-            
+
             int c = sr.read();
             while (c != -1) {
                 switch (c) {
@@ -489,7 +491,7 @@ public class ExtendedAccessLogValve extends AccessLogValve {
                 return null;
             }
         }
-        
+
         public String getParameter()throws IOException {
             String result;
             if (!parameter) {
@@ -508,10 +510,11 @@ public class ExtendedAccessLogValve extends AccessLogValve {
             }
             return null;
         }
-        
+
         public String getWhiteSpaces() throws IOException {
-            if(isEnded())
+            if(isEnded()) {
                 return "" ;
+            }
             StringBuilder whiteSpaces = new StringBuilder();
             if (buf.length() > 0) {
                 whiteSpaces.append(buf);
@@ -529,11 +532,11 @@ public class ExtendedAccessLogValve extends AccessLogValve {
             }
             return whiteSpaces.toString();
         }
-        
+
         public boolean isEnded() {
             return ended;
         }
-        
+
         public String getRemains() throws IOException {
             StringBuilder remains = new StringBuilder();
             for(int c = sr.read(); c != -1; c = sr.read()) {
@@ -541,9 +544,9 @@ public class ExtendedAccessLogValve extends AccessLogValve {
             }
             return remains.toString();
         }
-        
+
     }
-    
+
     @Override
     protected AccessLogElement[] createLogElements() {
         if (log.isDebugEnabled()) {
@@ -590,7 +593,7 @@ public class ExtendedAccessLogValve extends AccessLogValve {
             return null;
         }
     }
-    
+
     protected AccessLogElement getLogElement(String token, PatternTokenizer tokenizer) throws IOException {
         if ("date".equals(token)) {
             return new DateElement();
@@ -598,7 +601,7 @@ public class ExtendedAccessLogValve extends AccessLogValve {
             if (tokenizer.hasSubToken()) {
                 String nextToken = tokenizer.getToken();
                 if ("taken".equals(nextToken)) {
-                    return new ElapsedTimeElement(false);                
+                    return new ElapsedTimeElement(false);
                 }
             } else {
                 return new TimeElement();
@@ -647,7 +650,7 @@ public class ExtendedAccessLogValve extends AccessLogValve {
         log.error("unable to decode with rest of chars starting: " + token);
         return null;
     }
-    
+
     protected AccessLogElement getClientToServerElement(
             PatternTokenizer tokenizer) throws IOException {
         if (tokenizer.hasSubToken()) {
@@ -703,7 +706,7 @@ public class ExtendedAccessLogValve extends AccessLogValve {
                 + tokenizer.getRemains());
         return null;
     }
-    
+
     protected AccessLogElement getServerToClientElement(
             PatternTokenizer tokenizer) throws IOException {
         if (tokenizer.hasSubToken()) {
@@ -725,7 +728,7 @@ public class ExtendedAccessLogValve extends AccessLogValve {
                 + tokenizer.getRemains());
         return null;
     }
-    
+
     protected AccessLogElement getProxyElement(PatternTokenizer tokenizer)
         throws IOException {
         String token = null;
@@ -739,7 +742,7 @@ public class ExtendedAccessLogValve extends AccessLogValve {
         log.error("The next characters couldn't be decoded: " + token);
         return null;
     }
-    
+
     protected AccessLogElement getXParameterElement(PatternTokenizer tokenizer)
             throws IOException {
         if (!tokenizer.hasSubToken()) {
@@ -779,7 +782,7 @@ public class ExtendedAccessLogValve extends AccessLogValve {
                 + token);
         return null;
     }
-    
+
     protected AccessLogElement getServletRequestElement(String parameter) {
         if ("authType".equals(parameter)) {
             return new AccessLogElement() {
@@ -877,10 +880,10 @@ public class ExtendedAccessLogValve extends AccessLogValve {
     }
 
     private static class ElementTimestampStruct {
-        private Date currentTimestamp = new Date(0);
-        private SimpleDateFormat currentTimestampFormat;
+        private final Date currentTimestamp = new Date(0);
+        private final SimpleDateFormat currentTimestampFormat;
         private String currentTimestampString;
-        
+
         ElementTimestampStruct(String format) {
             currentTimestampFormat = new SimpleDateFormat(format, Locale.US);
             currentTimestampFormat.setTimeZone(TimeZone.getTimeZone("GMT"));

==================================================
PersistentValve.java
index 457e6c3ea2..de913a79a3 100644
--- a/java/org/apache/catalina/valves/JDBCAccessLogValve.java
+++ b/java/org/apache/catalina/valves/JDBCAccessLogValve.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.valves;
 
 
@@ -38,8 +36,8 @@ import org.apache.tomcat.util.ExceptionUtils;
 
 /**
  * <p>
- * This Tomcat extension logs server access directly to a database, and can 
- * be used instead of the regular file-based access log implemented in 
+ * This Tomcat extension logs server access directly to a database, and can
+ * be used instead of the regular file-based access log implemented in
  * AccessLogValve.
  * To use, copy into the server/classes directory of the Tomcat installation
  * and configure in server.xml as:
@@ -57,7 +55,7 @@ import org.apache.tomcat.util.ExceptionUtils;
  * the table name (<code>tableName</code>)
  * and the field names (corresponding to the get/set method names).
  * The same options as AccessLogValve are supported, such as
- * <code>resolveHosts</code> and <code>pattern</code> ("common" or "combined" 
+ * <code>resolveHosts</code> and <code>pattern</code> ("common" or "combined"
  * only).
  * </p>
  * <p>
@@ -65,7 +63,7 @@ import org.apache.tomcat.util.ExceptionUtils;
  * is created and used for all the log activity. When Tomcat is shutdown, the
  * database connection is closed.
  * This logger can be used at the level of the Engine context (being shared
- * by all the defined hosts) or the Host context (one instance of the logger 
+ * by all the defined hosts) or the Host context (one instance of the logger
  * per host, possibly using different databases).
  * </p>
  * <p>
@@ -92,13 +90,13 @@ import org.apache.tomcat.util.ExceptionUtils;
  * INDEX (userAgent)
  * );
  * </pre>
- * <p>Set JDBCAccessLogValve attribute useLongContentLength="true" as you have more then 4GB outputs. 
+ * <p>Set JDBCAccessLogValve attribute useLongContentLength="true" as you have more then 4GB outputs.
  * Please, use long SQL datatype at access.bytes attribute.
  * The datatype of bytes at oracle is <i>number</i> and other databases use <i>bytes BIGINT NOT NULL</i>.
  * </p>
- * 
+ *
  * <p>
- * If the table is created as above, its name and the field names don't need 
+ * If the table is created as above, its name and the field names don't need
  * to be defined.
  * </p>
  * <p>
@@ -108,7 +106,7 @@ import org.apache.tomcat.util.ExceptionUtils;
  * <p>
  * <i>TO DO: provide option for excluding logging of certain MIME types.</i>
  * </p>
- * 
+ *
  * @author Andre de Jesus
  * @author Peter Rossbach
  */
@@ -169,7 +167,7 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
     * @since 6.0.15
     */
     protected boolean useLongContentLength = false ;
-    
+
    /**
      * The connection username to use when trying to connect to the database.
      */
@@ -218,7 +216,7 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
     /**
      * The descriptive information about this implementation.
      */
-    protected static final String info = 
+    protected static final String info =
         "org.apache.catalina.valves.JDBCAccessLogValve/1.1";
 
 
@@ -259,7 +257,7 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
     /**
      * Sets the database driver name.
-     * 
+     *
      * @param driverName The complete name of the database driver class.
      */
     public void setDriverName(String driverName) {
@@ -285,7 +283,7 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
     /**
      * Sets the JDBC URL for the database where the log is stored.
-     * 
+     *
      * @param connectionURL The JDBC URL of the database.
      */
     public void setConnectionURL(String connectionURL) {
@@ -295,7 +293,7 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
     /**
      * Sets the name of the table where the logs are stored.
-     * 
+     *
      * @param tableName The name of the table.
      */
     public void setTableName(String tableName) {
@@ -305,7 +303,7 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
     /**
      * Sets the name of the field containing the remote host.
-     * 
+     *
      * @param remoteHostField The name of the remote host field.
      */
     public void setRemoteHostField(String remoteHostField) {
@@ -315,7 +313,7 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
     /**
      * Sets the name of the field containing the remote user name.
-     * 
+     *
      * @param userField The name of the remote user field.
      */
     public void setUserField(String userField) {
@@ -325,7 +323,7 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
     /**
      * Sets the name of the field containing the server-determined timestamp.
-     * 
+     *
      * @param timestampField The name of the server-determined timestamp field.
      */
     public void setTimestampField(String timestampField) {
@@ -334,9 +332,9 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
 
     /**
-     * Sets the name of the field containing the virtual host information 
+     * Sets the name of the field containing the virtual host information
      * (this is in fact the server name).
-     * 
+     *
      * @param virtualHostField The name of the virtual host field.
      */
     public void setVirtualHostField(String virtualHostField) {
@@ -346,7 +344,7 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
     /**
      * Sets the name of the field containing the HTTP request method.
-     * 
+     *
      * @param methodField The name of the HTTP request method field.
      */
     public void setMethodField(String methodField) {
@@ -356,8 +354,8 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
     /**
      * Sets the name of the field containing the URL part of the HTTP query.
-     * 
-     * @param queryField The name of the field containing the URL part of 
+     *
+     * @param queryField The name of the field containing the URL part of
      * the HTTP query.
      */
     public void setQueryField(String queryField) {
@@ -367,9 +365,9 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
   /**
    * Sets the name of the field containing the HTTP response status code.
-   * 
+   *
    * @param statusField The name of the HTTP response status code field.
-   */  
+   */
     public void setStatusField(String statusField) {
         this.statusField = statusField;
     }
@@ -377,7 +375,7 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
     /**
      * Sets the name of the field containing the number of bytes returned.
-     * 
+     *
      * @param bytesField The name of the returned bytes field.
      */
     public void setBytesField(String bytesField) {
@@ -387,7 +385,7 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
     /**
      * Sets the name of the field containing the referer.
-     * 
+     *
      * @param refererField The referer field name.
      */
     public void setRefererField(String refererField) {
@@ -397,7 +395,7 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
     /**
      * Sets the name of the field containing the user agent.
-     * 
+     *
      * @param userAgentField The name of the user agent field.
      */
     public void setUserAgentField(String userAgentField) {
@@ -406,11 +404,11 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
 
     /**
-     * Sets the logging pattern. The patterns supported correspond to the 
-     * file-based "common" and "combined". These are translated into the use 
+     * Sets the logging pattern. The patterns supported correspond to the
+     * file-based "common" and "combined". These are translated into the use
      * of tables containing either set of fields.
      * <P><I>TO DO: more flexible field choices.</I></P>
-     * 
+     *
      * @param pattern The name of the logging pattern.
      */
     public void setPattern(String pattern) {
@@ -420,8 +418,8 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
     /**
      * Determines whether IP host name resolution is done.
-     * 
-     * @param resolveHosts "true" or "false", if host IP resolution 
+     *
+     * @param resolveHosts "true" or "false", if host IP resolution
      * is desired or not.
      */
     public void setResolveHosts(String resolveHosts) {
@@ -434,7 +432,7 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
     public  boolean getUseLongContentLength() {
         return this.useLongContentLength ;
     }
-    
+
     /**
      * @param useLongContentLength the useLongContentLength to set
      */
@@ -447,12 +445,12 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
 
     /**
      * This method is invoked by Tomcat on each query.
-     * 
+     *
      * @param request The Request object.
      * @param response The Response object.
      *
      * @exception IOException Should not be thrown.
-     * @exception ServletException Database SQLException is wrapped 
+     * @exception ServletException Database SQLException is wrapped
      * in a ServletException.
      */
     @Override
@@ -469,7 +467,7 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
         }
 
         final String EMPTY = "" ;
-        
+
         String remoteHost;
         if(resolveHosts) {
             if (requestAttributesEnabled) {
@@ -496,10 +494,11 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
         }
         String user = request.getRemoteUser();
         String query=request.getRequestURI();
-        
+
         long bytes = response.getBytesWritten(true);
-        if(bytes < 0)
+        if(bytes < 0) {
             bytes = 0;
+        }
         int status = response.getStatus();
         String virtualHost = EMPTY;
         String method = EMPTY;
@@ -517,20 +516,21 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
           while (numberOfTries>0) {
             try {
                 open();
-    
+
                 ps.setString(1, remoteHost);
                 ps.setString(2, user);
                 ps.setTimestamp(3, new Timestamp(getCurrentTimeMillis()));
                 ps.setString(4, query);
                 ps.setInt(5, status);
-                
+
                 if(useLongContentLength) {
-                    ps.setLong(6, bytes);                
+                    ps.setLong(6, bytes);
                 } else {
-                    if (bytes > Integer.MAX_VALUE)
+                    if (bytes > Integer.MAX_VALUE) {
                         bytes = -1 ;
+                    }
                     ps.setInt(6, (int) bytes);
-                }               
+                }
                 if (logPattern.equals("combined")) {
                       ps.setString(7, virtualHost);
                       ps.setString(8, method);
@@ -544,8 +544,9 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
                   container.getLogger().error(sm.getString("jdbcAccessLogValve.exception"), e);
 
                 // Close the connection so that it gets reopened next time
-                if (conn != null)
+                if (conn != null) {
                     close();
+                }
               }
               numberOfTries--;
            }
@@ -563,8 +564,9 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
     protected void open() throws SQLException {
 
         // Do nothing if there is a database connection already open
-        if (conn != null)
+        if (conn != null) {
             return ;
+        }
 
         // Instantiate our database driver if necessary
         if (driver == null) {
@@ -580,26 +582,28 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
         // Open a new connection
         Properties props = new Properties();
         props.put("autoReconnect", "true");
-        if (connectionName != null)
+        if (connectionName != null) {
             props.put("user", connectionName);
-        if (connectionPassword != null)
+        }
+        if (connectionPassword != null) {
             props.put("password", connectionPassword);
+        }
         conn = driver.connect(connectionURL, props);
         conn.setAutoCommit(true);
         String logPattern = pattern;
         if (logPattern.equals("common")) {
                 ps = conn.prepareStatement
-                    ("INSERT INTO " + tableName + " (" 
+                    ("INSERT INTO " + tableName + " ("
                      + remoteHostField + ", " + userField + ", "
                      + timestampField +", " + queryField + ", "
-                     + statusField + ", " + bytesField 
+                     + statusField + ", " + bytesField
                      + ") VALUES(?, ?, ?, ?, ?, ?)");
         } else if (logPattern.equals("combined")) {
                 ps = conn.prepareStatement
-                    ("INSERT INTO " + tableName + " (" 
+                    ("INSERT INTO " + tableName + " ("
                      + remoteHostField + ", " + userField + ", "
-                     + timestampField + ", " + queryField + ", " 
-                     + statusField + ", " + bytesField + ", " 
+                     + timestampField + ", " + queryField + ", "
+                     + statusField + ", " + bytesField + ", "
                      + virtualHostField + ", " + methodField + ", "
                      + refererField + ", " + userAgentField
                      + ") VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
@@ -612,8 +616,9 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
     protected void close() {
 
         // Do nothing if the database connection is already closed
-        if (conn == null)
+        if (conn == null) {
             return;
+        }
 
         // Close our prepared statements (if any)
         try {
@@ -629,14 +634,14 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
         try {
             conn.close();
         } catch (SQLException e) {
-            container.getLogger().error(sm.getString("jdbcAccessLogValeve.close"), e); // Just log it here            
+            container.getLogger().error(sm.getString("jdbcAccessLogValeve.close"), e); // Just log it here
         } finally {
            this.conn = null;
         }
 
     }
-    
-    
+
+
     /**
      * Start this component and implement the requirements
      * of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
@@ -646,9 +651,9 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
      */
     @Override
     protected synchronized void startInternal() throws LifecycleException {
-        
+
         try {
-            open() ;        
+            open() ;
         } catch (SQLException e) {
             throw new LifecycleException(e);
         }
@@ -668,7 +673,7 @@ public final class JDBCAccessLogValve extends ValveBase implements AccessLog {
     protected synchronized void stopInternal() throws LifecycleException {
 
         setState(LifecycleState.STOPPING);
-        
+
         close() ;
     }
 

==================================================
RemoteAddrValve.java
index 5f0d0e2c51..fd1cab8304 100644
--- a/java/org/apache/catalina/valves/PersistentValve.java
+++ b/java/org/apache/catalina/valves/PersistentValve.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.valves;
 
 
@@ -124,8 +122,9 @@ public class PersistentValve extends ValveBase {
                     if (session != null) {
                         if (!session.isValid() ||
                             isSessionStale(session, System.currentTimeMillis())) {
-                            if (container.getLogger().isDebugEnabled())
+                            if (container.getLogger().isDebugEnabled()) {
                                 container.getLogger().debug("session swapped in is invalid or expired");
+                            }
                             session.expire();
                             store.remove(sessionId);
                         } else {
@@ -140,8 +139,9 @@ public class PersistentValve extends ValveBase {
                 }
             }
         }
-        if (container.getLogger().isDebugEnabled())
+        if (container.getLogger().isDebugEnabled()) {
             container.getLogger().debug("sessionId: " + sessionId);
+        }
 
         // Ask the next valve to process the request.
         getNext().invoke(request, response);
@@ -159,11 +159,13 @@ public class PersistentValve extends ValveBase {
                 hsess = null;
             }
             String newsessionId = null;
-            if (hsess!=null)
+            if (hsess!=null) {
                 newsessionId = hsess.getIdInternal();
-    
-            if (container.getLogger().isDebugEnabled())
+            }
+
+            if (container.getLogger().isDebugEnabled()) {
                 container.getLogger().debug("newsessionId: " + newsessionId);
+            }
             if (newsessionId!=null) {
                 /* store the session and remove it from the manager */
                 if (manager instanceof PersistentManager) {
@@ -177,7 +179,7 @@ public class PersistentValve extends ValveBase {
                         ((PersistentManager) manager).removeSuper(session);
                         session.recycle();
                     } else {
-                        if (container.getLogger().isDebugEnabled())
+                        if (container.getLogger().isDebugEnabled()) {
                             container.getLogger().debug("newsessionId store: " +
                                     store + " session: " + session +
                                     " valid: " +
@@ -185,12 +187,14 @@ public class PersistentValve extends ValveBase {
                                             session.isValid())) +
                                     " stale: " + isSessionStale(session,
                                             System.currentTimeMillis()));
-    
+                        }
+
                     }
                 } else {
-                    if (container.getLogger().isDebugEnabled())
+                    if (container.getLogger().isDebugEnabled()) {
                         container.getLogger().debug("newsessionId Manager: " +
                                 manager);
+                    }
                 }
             }
         }
@@ -203,19 +207,20 @@ public class PersistentValve extends ValveBase {
      * FIXME: Probably belongs in the Session class.
      */
     protected boolean isSessionStale(Session session, long timeNow) {
- 
+
         if (session != null) {
             int maxInactiveInterval = session.getMaxInactiveInterval();
             if (maxInactiveInterval >= 0) {
                 int timeIdle = // Truncate, do not round up
                     (int) ((timeNow - session.getThisAccessedTime()) / 1000L);
-                if (timeIdle >= maxInactiveInterval)
+                if (timeIdle >= maxInactiveInterval) {
                     return true;
+                }
             }
         }
- 
+
         return false;
- 
+
     }
 
 }

==================================================
RemoteHostValve.java
index 63058f43af..ae7b256a35 100644
--- a/java/org/apache/catalina/valves/RemoteAddrValve.java
+++ b/java/org/apache/catalina/valves/RemoteAddrValve.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.valves;
 
 

==================================================
RemoteIpValve.java
index 20c664ea11..19938ecbb1 100644
--- a/java/org/apache/catalina/valves/RemoteHostValve.java
+++ b/java/org/apache/catalina/valves/RemoteHostValve.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.valves;
 
 

==================================================
RequestFilterValve.java
index 0d2d18a695..58eeeb6589 100644
--- a/java/org/apache/catalina/valves/RemoteIpValve.java
+++ b/java/org/apache/catalina/valves/RemoteIpValve.java
@@ -5,16 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.catalina.valves;
 
 import java.io.IOException;
@@ -162,7 +161,7 @@ import org.apache.juli.logging.LogFactory;
  * RemoteIpValve configuration:
  * </p>
  * <code><pre>
- * &lt;Valve 
+ * &lt;Valve
  *   className="org.apache.catalina.valves.RemoteIpValve"
  *   internalProxies="192\.168\.0\.10|192\.168\.0\.11"
  *   remoteIpHeader="x-forwarded-for"
@@ -224,7 +223,7 @@ import org.apache.juli.logging.LogFactory;
  * RemoteIpValve configuration:
  * </p>
  * <code><pre>
- * &lt;Valve 
+ * &lt;Valve
  *   className="org.apache.catalina.valves.RemoteIpValve"
  *   internalProxies="192\.168\.0\.10|192\.168\.0\.11"
  *   remoteIpHeader="x-forwarded-for"
@@ -266,7 +265,7 @@ import org.apache.juli.logging.LogFactory;
  * RemoteIpValve configuration:
  * </p>
  * <code><pre>
- * &lt;Valve 
+ * &lt;Valve
  *   className="org.apache.catalina.valves.RemoteIpValve"
  *   internalProxies="192\.168\.0\.10|192\.168\.0\.11"
  *   remoteIpHeader="x-forwarded-for"
@@ -309,7 +308,7 @@ import org.apache.juli.logging.LogFactory;
  * RemoteIpValve configuration:
  * </p>
  * <code><pre>
- * &lt;Valve 
+ * &lt;Valve
  *   className="org.apache.catalina.valves.RemoteIpValve"
  *   internalProxies="192\.168\.0\.10|192\.168\.0\.11"
  *   remoteIpHeader="x-forwarded-for"
@@ -347,32 +346,32 @@ import org.apache.juli.logging.LogFactory;
  * </p>
  */
 public class RemoteIpValve extends ValveBase {
-    
+
     /**
      * {@link Pattern} for a comma delimited string that support whitespace characters
      */
     private static final Pattern commaSeparatedValuesPattern = Pattern.compile("\\s*,\\s*");
-    
+
     /**
      * The descriptive information related to this implementation.
      */
     private static final String info = "org.apache.catalina.valves.RemoteIpValve/1.0";
-    
+
     /**
      * Logger
      */
     private static final Log log = LogFactory.getLog(RemoteIpValve.class);
-    
+
     /**
      * Convert a given comma delimited String into an array of String
-     * 
+     *
      * @return array of String (non <code>null</code>)
      */
     protected static String[] commaDelimitedListToStringArray(String commaDelimitedStrings) {
         return (commaDelimitedStrings == null || commaDelimitedStrings.length() == 0) ? new String[0] : commaSeparatedValuesPattern
             .split(commaDelimitedStrings);
     }
-    
+
     /**
      * Convert an array of strings in a comma delimited string
      */
@@ -392,17 +391,17 @@ public class RemoteIpValve extends ValveBase {
         }
         return result.toString();
     }
-    
+
     /**
      * @see #setHttpServerPort(int)
      */
     private int httpServerPort = 80;
-    
+
     /**
      * @see #setHttpsServerPort(int)
      */
     private int httpsServerPort = 443;
-    
+
     private boolean changeLocalPort = false;
 
     /**
@@ -413,24 +412,24 @@ public class RemoteIpValve extends ValveBase {
             "192\\.168\\.\\d{1,3}\\.\\d{1,3}|" +
             "169\\.254\\.\\d{1,3}\\.\\d{1,3}|" +
             "127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}");
-    
+
     /**
      * @see #setProtocolHeader(String)
      */
     private String protocolHeader = null;
-    
+
     /**
      * @see #setProtocolHeaderHttpsValue(String)
      */
     private String protocolHeaderHttpsValue = "https";
-    
+
     private String portHeader = null;
 
     /**
      * @see #setProxiesHeader(String)
      */
     private String proxiesHeader = "X-Forwarded-By";
-    
+
     /**
      * @see #setRemoteIpHeader(String)
      */
@@ -445,7 +444,7 @@ public class RemoteIpValve extends ValveBase {
      * @see RemoteIpValve#setTrustedProxies(String)
      */
     private Pattern trustedProxies = null;
-    
+
 
     /**
      * Default constructor that ensures {@link ValveBase#ValveBase(boolean)} is
@@ -456,15 +455,15 @@ public class RemoteIpValve extends ValveBase {
         super(true);
     }
 
-    
+
     public int getHttpsServerPort() {
         return httpsServerPort;
     }
-    
+
     public int getHttpServerPort() {
         return httpServerPort;
     }
-    
+
     public boolean isChangeLocalPort() {
         return changeLocalPort;
     }
@@ -477,7 +476,7 @@ public class RemoteIpValve extends ValveBase {
      * Obtain the name of the HTTP header used to override the value returned
      * by {@link Request#getServerPort()} and (optionally depending on {link
      * {@link #isChangeLocalPort()} {@link Request#getLocalPort()}.
-     * 
+     *
      * @return  The HTTP header name
      */
     public String getPortHeader() {
@@ -488,7 +487,7 @@ public class RemoteIpValve extends ValveBase {
      * Set the name of the HTTP header used to override the value returned
      * by {@link Request#getServerPort()} and (optionally depending on {link
      * {@link #isChangeLocalPort()} {@link Request#getLocalPort()}.
-     * 
+     *
      * @param   portHeader  The HTTP header name
      */
     public void setPortHeader(String portHeader) {
@@ -502,7 +501,7 @@ public class RemoteIpValve extends ValveBase {
     public String getInfo() {
         return info;
     }
-    
+
     /**
      * @see #setInternalProxies(String)
      * @return Regular expression that defines the internal proxies
@@ -513,7 +512,7 @@ public class RemoteIpValve extends ValveBase {
         }
         return internalProxies.toString();
     }
-    
+
     /**
      * @see #setProtocolHeader(String)
      * @return the protocol header (e.g. "X-Forwarded-Proto")
@@ -521,7 +520,7 @@ public class RemoteIpValve extends ValveBase {
     public String getProtocolHeader() {
         return protocolHeader;
     }
-    
+
     /**
      * @see RemoteIpValve#setProtocolHeaderHttpsValue(String)
      * @return the value of the protocol header for incoming https request (e.g. "https")
@@ -529,7 +528,7 @@ public class RemoteIpValve extends ValveBase {
     public String getProtocolHeaderHttpsValue() {
         return protocolHeaderHttpsValue;
     }
-    
+
     /**
      * @see #setProxiesHeader(String)
      * @return the proxies header name (e.g. "X-Forwarded-By")
@@ -537,7 +536,7 @@ public class RemoteIpValve extends ValveBase {
     public String getProxiesHeader() {
         return proxiesHeader;
     }
-    
+
     /**
      * @see #setRemoteIpHeader(String)
      * @return the remote IP header name (e.g. "X-Forwarded-For")
@@ -565,7 +564,7 @@ public class RemoteIpValve extends ValveBase {
         }
         return trustedProxies.toString();
     }
-    
+
     /**
      * {@inheritDoc}
      */
@@ -576,14 +575,14 @@ public class RemoteIpValve extends ValveBase {
         final String originalScheme = request.getScheme();
         final boolean originalSecure = request.isSecure();
         final int originalServerPort = request.getServerPort();
-        
+
         if (internalProxies !=null &&
                 internalProxies.matcher(originalRemoteAddr).matches()) {
             String remoteIp = null;
             // In java 6, proxiesHeaderValue should be declared as a java.util.Deque
             LinkedList<String> proxiesHeaderValue = new LinkedList<String>();
             StringBuilder concatRemoteIpHeaderValue = new StringBuilder();
-            
+
             for (Enumeration<String> e = request.getHeaders(remoteIpHeader); e.hasMoreElements();) {
                 if (concatRemoteIpHeaderValue.length() > 0) {
                     concatRemoteIpHeaderValue.append(", ");
@@ -615,10 +614,10 @@ public class RemoteIpValve extends ValveBase {
                 newRemoteIpHeaderValue.addFirst(currentRemoteIp);
             }
             if (remoteIp != null) {
-                
+
                 request.setRemoteAddr(remoteIp);
                 request.setRemoteHost(remoteIp);
-                
+
                 // use request.coyoteRequest.mimeHeaders.setValue(str).setString(str) because request.addHeader(str, str) is no-op in Tomcat
                 // 6.0
                 if (proxiesHeaderValue.size() == 0) {
@@ -634,7 +633,7 @@ public class RemoteIpValve extends ValveBase {
                     request.getCoyoteRequest().getMimeHeaders().setValue(remoteIpHeader).setString(commaDelimitedRemoteIpHeaderValue);
                 }
             }
-            
+
             if (protocolHeader != null) {
                 String protocolHeaderValue = request.getHeader(protocolHeader);
                 if (protocolHeaderValue == null) {
@@ -644,17 +643,17 @@ public class RemoteIpValve extends ValveBase {
                     request.setSecure(true);
                     // use request.coyoteRequest.scheme instead of request.setScheme() because request.setScheme() is no-op in Tomcat 6.0
                     request.getCoyoteRequest().scheme().setString("https");
-                    
+
                     setPorts(request, httpsServerPort);
                 } else {
                     request.setSecure(false);
                     // use request.coyoteRequest.scheme instead of request.setScheme() because request.setScheme() is no-op in Tomcat 6.0
                     request.getCoyoteRequest().scheme().setString("http");
-                    
+
                     setPorts(request, httpServerPort);
                 }
             }
-            
+
             if (log.isDebugEnabled()) {
                 log.debug("Incoming request " + request.getRequestURI() + " with originalRemoteAddr '" + originalRemoteAddr
                           + "', originalRemoteHost='" + originalRemoteHost + "', originalSecure='" + originalSecure + "', originalScheme='"
@@ -682,12 +681,12 @@ public class RemoteIpValve extends ValveBase {
         } finally {
             request.setRemoteAddr(originalRemoteAddr);
             request.setRemoteHost(originalRemoteHost);
-            
+
             request.setSecure(originalSecure);
-            
+
             // use request.coyoteRequest.scheme instead of request.setScheme() because request.setScheme() is no-op in Tomcat 6.0
             request.getCoyoteRequest().scheme().setString(originalScheme);
-            
+
             request.setServerPort(originalServerPort);
         }
     }
@@ -713,7 +712,7 @@ public class RemoteIpValve extends ValveBase {
             request.setLocalPort(port);
         }
     }
-    
+
     /**
      * <p>
      * Server Port value if the {@link #protocolHeader} is not <code>null</code> and does not indicate HTTP
@@ -725,7 +724,7 @@ public class RemoteIpValve extends ValveBase {
     public void setHttpServerPort(int httpServerPort) {
         this.httpServerPort = httpServerPort;
     }
-    
+
     /**
      * <p>
      * Server Port value if the {@link #protocolHeader} indicates HTTPS
@@ -737,7 +736,7 @@ public class RemoteIpValve extends ValveBase {
     public void setHttpsServerPort(int httpsServerPort) {
         this.httpsServerPort = httpsServerPort;
     }
-    
+
     /**
      * <p>
      * Regular expression that defines the internal proxies.
@@ -753,7 +752,7 @@ public class RemoteIpValve extends ValveBase {
             this.internalProxies = Pattern.compile(internalProxies);
         }
     }
-    
+
     /**
      * <p>
      * Header that holds the incoming protocol, usally named <code>X-Forwarded-Proto</code>. If <code>null</code>, request.scheme and
@@ -766,7 +765,7 @@ public class RemoteIpValve extends ValveBase {
     public void setProtocolHeader(String protocolHeader) {
         this.protocolHeader = protocolHeader;
     }
-    
+
     /**
      * <p>
      * Case insensitive value of the protocol header to indicate that the incoming http request uses SSL.
@@ -778,7 +777,7 @@ public class RemoteIpValve extends ValveBase {
     public void setProtocolHeaderHttpsValue(String protocolHeaderHttpsValue) {
         this.protocolHeaderHttpsValue = protocolHeaderHttpsValue;
     }
-    
+
     /**
      * <p>
      * The proxiesHeader directive specifies a header into which mod_remoteip will collect a list of all of the intermediate client IP
@@ -798,7 +797,7 @@ public class RemoteIpValve extends ValveBase {
     public void setProxiesHeader(String proxiesHeader) {
         this.proxiesHeader = proxiesHeader;
     }
-    
+
     /**
      * <p>
      * Name of the http header from which the remote ip is extracted.
@@ -809,19 +808,19 @@ public class RemoteIpValve extends ValveBase {
      * <p>
      * Default value : <code>X-Forwarded-For</code>
      * </p>
-     * 
+     *
      * @param remoteIpHeader
      */
     public void setRemoteIpHeader(String remoteIpHeader) {
         this.remoteIpHeader = remoteIpHeader;
     }
-    
+
     /**
      * Should this valve set request attributes for IP address, Hostname,
      * protocol and port used for the request? This are typically used in
      * conjunction with the {@link AccessLog} which will otherwise log the
      * original values. Default is <code>true</code>.
-     * 
+     *
      * The attributes set are:
      * <ul>
      * <li>org.apache.catalina.RemoteAddr</li>
@@ -829,10 +828,10 @@ public class RemoteIpValve extends ValveBase {
      * <li>org.apache.catalina.Protocol</li>
      * <li>org.apache.catalina.ServerPost</li>
      * </ul>
-     * 
+     *
      * @param requestAttributesEnabled  <code>true</code> causes the attributes
      *                                  to be set, <code>false</code> disables
-     *                                  the setting of the attributes. 
+     *                                  the setting of the attributes.
      */
     public void setRequestAttributesEnabled(boolean requestAttributesEnabled) {
         this.requestAttributesEnabled = requestAttributesEnabled;

==================================================
SSLValve.java
index 085eabb82a..05c6440910 100644
--- a/java/org/apache/catalina/valves/RequestFilterValve.java
+++ b/java/org/apache/catalina/valves/RequestFilterValve.java
@@ -5,17 +5,15 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.valves;
 
 
@@ -59,9 +57,7 @@ import org.apache.catalina.connector.Response;
  * @author Craig R. McClanahan
  * @version $Id$
  */
-
-public abstract class RequestFilterValve
-    extends ValveBase {
+public abstract class RequestFilterValve extends ValveBase {
 
     //------------------------------------------------------ Constructor
     public RequestFilterValve() {

==================================================
SemaphoreValve.java
index 4ef7d315a2..09d76b49e1 100644
--- a/java/org/apache/catalina/valves/SSLValve.java
+++ b/java/org/apache/catalina/valves/SSLValve.java
@@ -14,7 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.catalina.valves;
 
 import java.io.ByteArrayInputStream;
@@ -39,10 +38,10 @@ import org.apache.juli.logging.LogFactory;
  * In httpd, mod_headers is used to add the SSL information as HTTP headers. In
  * Tomcat, this valve is used to read the information from the HTTP headers and
  * insert it into the request.<p>
- * 
+ *
  * <b>Note: Ensure that the headers are always set by httpd for all requests to
  * prevent a client spoofing SSL information by sending fake headers. </b><p>
- * 
+ *
  * In httpd.conf add the following:
  * <pre>
  * &lt;IfModule ssl_module&gt;
@@ -52,7 +51,7 @@ import org.apache.juli.logging.LogFactory;
  *   RequestHeader set SSL_CIPHER_USEKEYSIZE "%{SSL_CIPHER_USEKEYSIZE}s"
  * &lt;/IfModule&gt;
  * </pre>
- * 
+ *
  * In server.xml, configure this valve under the Engine element in server.xml:
  * <pre>
  * &lt;Engine ...&gt;
@@ -62,10 +61,10 @@ import org.apache.juli.logging.LogFactory;
  * </pre>
  */
 public class SSLValve extends ValveBase {
-    
+
     private static final Log log = LogFactory.getLog(SSLValve.class);
 
-    
+
     //------------------------------------------------------ Constructor
     public SSLValve() {
         super(true);
@@ -75,13 +74,15 @@ public class SSLValve extends ValveBase {
 
     public String mygetHeader(Request request, String header) {
         String strcert0 = request.getHeader(header);
-        if (strcert0 == null)
+        if (strcert0 == null) {
             return null;
+        }
         /* mod_header writes "(null)" when the ssl variable is no filled */
-        if ("(null)".equals(strcert0))
+        if ("(null)".equals(strcert0)) {
             return null;
+        }
         return strcert0;
-    } 
+    }
     @Override
     public void invoke(Request request, Response response)
         throws IOException, ServletException {
@@ -103,7 +104,7 @@ public class SSLValve extends ValveBase {
             try {
                 CertificateFactory cf;
                 if (providerName == null) {
-                    cf = CertificateFactory.getInstance("X.509");    
+                    cf = CertificateFactory.getInstance("X.509");
                 } else {
                     cf = CertificateFactory.getInstance("X.509", providerName);
                 }

==================================================
StuckThreadDetectionValve.java
index 3798e6397c..aed952e907 100644
--- a/java/org/apache/catalina/valves/SemaphoreValve.java
+++ b/java/org/apache/catalina/valves/SemaphoreValve.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -60,18 +60,18 @@ public class SemaphoreValve extends ValveBase {
      * Semaphore.
      */
     protected Semaphore semaphore = null;
-    
+
 
     // ------------------------------------------------------------- Properties
 
-    
+
     /**
      * Concurrency level of the semaphore.
      */
     protected int concurrency = 10;
     public int getConcurrency() { return concurrency; }
     public void setConcurrency(int concurrency) { this.concurrency = concurrency; }
-    
+
 
     /**
      * Fairness of the semaphore.
@@ -79,7 +79,7 @@ public class SemaphoreValve extends ValveBase {
     protected boolean fairness = false;
     public boolean getFairness() { return fairness; }
     public void setFairness(boolean fairness) { this.fairness = fairness; }
-    
+
 
     /**
      * Block until a permit is available.
@@ -87,7 +87,7 @@ public class SemaphoreValve extends ValveBase {
     protected boolean block = true;
     public boolean getBlock() { return block; }
     public void setBlock(boolean block) { this.block = block; }
-    
+
 
     /**
      * Block interruptibly until a permit is available.
@@ -95,7 +95,7 @@ public class SemaphoreValve extends ValveBase {
     protected boolean interruptible = false;
     public boolean getInterruptible() { return interruptible; }
     public void setInterruptible(boolean interruptible) { this.interruptible = interruptible; }
-    
+
 
     /**
      * Start this component and implement the requirements
@@ -106,7 +106,7 @@ public class SemaphoreValve extends ValveBase {
      */
     @Override
     protected synchronized void startInternal() throws LifecycleException {
-        
+
         semaphore = new Semaphore(concurrency, fairness);
 
         setState(LifecycleState.STARTING);
@@ -128,7 +128,7 @@ public class SemaphoreValve extends ValveBase {
         semaphore = null;
     }
 
-    
+
     // --------------------------------------------------------- Public Methods
 
 
@@ -165,7 +165,7 @@ public class SemaphoreValve extends ValveBase {
                             shouldRelease = false;
                             permitDenied(request, response);
                             return;
-                        }  
+                        }
                     } else {
                         semaphore.acquireUninterruptibly();
                     }
@@ -188,22 +188,22 @@ public class SemaphoreValve extends ValveBase {
 
     }
 
-    
+
     /**
      * Subclass friendly method to add conditions.
-     * @param request 
-     * @param response 
+     * @param request
+     * @param response
      */
     public boolean controlConcurrency(Request request, Response response) {
         return true;
     }
-    
+
 
     /**
      * Subclass friendly method to add error handling when a permit isn't
      * granted.
-     * @param request 
-     * @param response 
+     * @param request
+     * @param response
      * @throws IOException
      * @throws ServletException
      */
@@ -211,6 +211,6 @@ public class SemaphoreValve extends ValveBase {
         throws IOException, ServletException {
         // NO-OP by default
     }
-    
+
 
 }

==================================================
ValveBase.java
index b0c64ea35e..8d6af6a412 100644
--- a/java/org/apache/catalina/valves/StuckThreadDetectionValve.java
+++ b/java/org/apache/catalina/valves/StuckThreadDetectionValve.java
@@ -38,7 +38,7 @@ import org.apache.tomcat.util.res.StringManager;
  * This valve allows to detect requests that take a long time to process, which might
  * indicate that the thread that is processing it is stuck.
  * Based on code proposed by TomLu in Bugzilla entry #50306
- * 
+ *
  * @author slaurent
  *
  */
@@ -53,7 +53,7 @@ public class StuckThreadDetectionValve extends ValveBase {
      * Logger
      */
     private static final Log log = LogFactory.getLog(StuckThreadDetectionValve.class);
-    
+
     /**
      * The string manager for this package.
      */
@@ -64,30 +64,30 @@ public class StuckThreadDetectionValve extends ValveBase {
      * Keeps count of the number of stuck threads detected
      */
     private final AtomicInteger stuckCount = new AtomicInteger(0);
-    
+
     /**
      * In seconds. Default 600 (10 minutes).
      */
     private int threshold = 600;
-    
+
     /**
      * The only references we keep to actual running Thread objects are in
      * this Map (which is automatically cleaned in invoke()s finally clause).
      * That way, Threads can be GC'ed, eventhough the Valve still thinks they
      * are stuck (caused by a long monitor interval)
      */
-    private ConcurrentHashMap<Long, MonitoredThread> activeThreads =
+    private final ConcurrentHashMap<Long, MonitoredThread> activeThreads =
             new ConcurrentHashMap<Long, MonitoredThread>();
     /**
      *
      */
-    private Queue<CompletedStuckThread> completedStuckThreadsQueue =
+    private final Queue<CompletedStuckThread> completedStuckThreadsQueue =
             new ConcurrentLinkedQueue<CompletedStuckThread>();
 
     /**
      * Specify the threshold (in seconds) used when checking for stuck threads.
      * If &lt;=0, the detection is disabled. The default is 600 seconds.
-     * 
+     *
      * @param threshold
      *            The new threshold in seconds
      */
@@ -103,7 +103,7 @@ public class StuckThreadDetectionValve extends ValveBase {
         return threshold;
     }
 
-    
+
     /**
      * Required to enable async support.
      */
@@ -166,7 +166,7 @@ public class StuckThreadDetectionValve extends ValveBase {
     @Override
     public void invoke(Request request, Response response)
             throws IOException, ServletException {
-        
+
         if (threshold <= 0) {
             // short-circuit if not monitoring stuck threads
             getNext().invoke(request, response);
@@ -183,7 +183,7 @@ public class StuckThreadDetectionValve extends ValveBase {
             requestUrl.append("?");
             requestUrl.append(request.getQueryString());
         }
-        MonitoredThread monitoredThread = new MonitoredThread(Thread.currentThread(), 
+        MonitoredThread monitoredThread = new MonitoredThread(Thread.currentThread(),
             requestUrl.toString());
         activeThreads.put(key, monitoredThread);
 
@@ -216,7 +216,7 @@ public class StuckThreadDetectionValve extends ValveBase {
             }
         }
         // Check if any threads previously reported as stuck, have finished.
-        for (CompletedStuckThread completedStuckThread = completedStuckThreadsQueue.poll(); 
+        for (CompletedStuckThread completedStuckThread = completedStuckThreadsQueue.poll();
             completedStuckThread != null; completedStuckThread = completedStuckThreadsQueue.poll()) {
 
             int numStuckThreads = stuckCount.decrementAndGet();
@@ -224,7 +224,7 @@ public class StuckThreadDetectionValve extends ValveBase {
                     completedStuckThread.getTotalActiveTime(), numStuckThreads);
         }
     }
-    
+
     public long[] getStuckThreadIds() {
         List<Long> idList = new ArrayList<Long>();
         for (MonitoredThread monitoredThread : activeThreads.values()) {
@@ -282,7 +282,7 @@ public class StuckThreadDetectionValve extends ValveBase {
             int val = this.state.getAndSet(MonitoredThreadState.DONE.ordinal());
             return MonitoredThreadState.values()[val];
         }
-        
+
         boolean isMarkedAsStuck() {
             return this.state.get() == MonitoredThreadState.STUCK.ordinal();
         }
@@ -290,8 +290,8 @@ public class StuckThreadDetectionValve extends ValveBase {
 
     private static class CompletedStuckThread {
 
-        private String threadName;
-        private long totalActiveTime;
+        private final String threadName;
+        private final long totalActiveTime;
 
         public CompletedStuckThread(String threadName, long totalActiveTime) {
             this.threadName = threadName;

==================================================
