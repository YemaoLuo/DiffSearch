509b9090981d1c530f6af0117e1988124cb86fd6
==================================================
Re-order actions so order is consistent across implementations
==================================================
Mark Thomas
==================================================
Wed Feb 24 12:17:52 2016 +0000
==================================================
AjpProcessor.java
Re-order actions so order is consistent across implementations

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1732118 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http11Processor.java
index fcc0b6e5d9..3b36c4258e 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -390,20 +390,97 @@ public class AjpProcessor extends AbstractProcessor {
             }
             break;
         }
+        case AVAILABLE: {
+            if (available()) {
+                request.setAvailable(1);
+            } else {
+                request.setAvailable(0);
+            }
+            break;
+        }
+        case REQ_SET_BODY_REPLAY: {
+            // Set the given bytes as the content
+            ByteChunk bc = (ByteChunk) param;
+            int length = bc.getLength();
+            bodyBytes.setBytes(bc.getBytes(), bc.getStart(), length);
+            request.setContentLength(length);
+            first = false;
+            empty = false;
+            replay = true;
+            endOfStream = false;
+            break;
+        }
+        case RESET: {
+            // NO-OP
+            break;
+        }
+
+        // Error handling
         case IS_ERROR: {
             ((AtomicBoolean) param).set(getErrorState().isError());
             break;
         }
+        case CLOSE_NOW: {
+            // Prevent further writes to the response
+            swallowResponse = true;
+            setErrorState(ErrorState.CLOSE_NOW, null);
+            break;
+        }
         case DISABLE_SWALLOW_INPUT: {
             // TODO: Do not swallow request input but
             // make sure we are closing the connection
             setErrorState(ErrorState.CLOSE_CLEAN, null);
             break;
         }
-        case RESET: {
+        case END_REQUEST: {
+            // NO-OP for AJP
+            break;
+        }
+
+        // Request attribute support
+        case REQ_HOST_ADDR_ATTRIBUTE: {
+            // NO-OP
+            // Automatically populated during prepareRequest()
+            break;
+        }
+        case REQ_HOST_ATTRIBUTE: {
+            // Get remote host name using a DNS resolution
+            if (request.remoteHost().isNull()) {
+                try {
+                    request.remoteHost().setString(InetAddress.getByName
+                            (request.remoteAddr().toString()).getHostName());
+                } catch (IOException iex) {
+                    // Ignore
+                }
+            }
+            break;
+        }
+        case REQ_LOCALPORT_ATTRIBUTE: {
+            // NO-OP
+            // Automatically populated during prepareRequest()
+            break;
+        }
+        case REQ_LOCAL_ADDR_ATTRIBUTE: {
+            // Automatically populated during prepareRequest() when using
+            // modern AJP forwarder, otherwise copy from local name
+            if (request.localAddr().isNull()) {
+                request.localAddr().setString(request.localName().toString());
+            }
+            break;
+        }
+        case REQ_LOCAL_NAME_ATTRIBUTE: {
             // NO-OP
+            // Automatically populated during prepareRequest()
             break;
         }
+        case REQ_REMOTEPORT_ATTRIBUTE: {
+            // NO-OP
+            // Automatically populated during prepareRequest() when using
+            // modern AJP forwarder, otherwise not available
+            break;
+        }
+
+        // SSL request attribute support
         case REQ_SSL_ATTRIBUTE: {
             if (!certificates.isNull()) {
                 ByteChunk certData = certificates.getByteChunk();
@@ -451,59 +528,8 @@ public class AjpProcessor extends AbstractProcessor {
             // AJP as the reverse proxy controls that connection.
             break;
         }
-        case REQ_HOST_ATTRIBUTE: {
-            // Get remote host name using a DNS resolution
-            if (request.remoteHost().isNull()) {
-                try {
-                    request.remoteHost().setString(InetAddress.getByName
-                            (request.remoteAddr().toString()).getHostName());
-                } catch (IOException iex) {
-                    // Ignore
-                }
-            }
-            break;
-        }
-        case REQ_HOST_ADDR_ATTRIBUTE: {
-            // NO-OP
-            // Automatically populated during prepareRequest()
-            break;
-        }
-        case REQ_LOCAL_NAME_ATTRIBUTE: {
-            // NO-OP
-            // Automatically populated during prepareRequest()
-            break;
-        }
-        case REQ_LOCAL_ADDR_ATTRIBUTE: {
-            // Automatically populated during prepareRequest() when using
-            // modern AJP forwarder, otherwise copy from local name
-            if (request.localAddr().isNull()) {
-                request.localAddr().setString(request.localName().toString());
-            }
-            break;
-        }
-        case REQ_REMOTEPORT_ATTRIBUTE: {
-            // NO-OP
-            // Automatically populated during prepareRequest() when using
-            // modern AJP forwarder, otherwise not available
-            break;
-        }
-        case REQ_LOCALPORT_ATTRIBUTE: {
-            // NO-OP
-            // Automatically populated during prepareRequest()
-            break;
-        }
-        case REQ_SET_BODY_REPLAY: {
-            // Set the given bytes as the content
-            ByteChunk bc = (ByteChunk) param;
-            int length = bc.getLength();
-            bodyBytes.setBytes(bc.getBytes(), bc.getStart(), length);
-            request.setContentLength(length);
-            first = false;
-            empty = false;
-            replay = true;
-            endOfStream = false;
-            break;
-        }
+
+        // Servlet 3.0 asynchronous support
         case ASYNC_START: {
             asyncStateMachine.asyncStart((AsyncContextCallback) param);
             break;
@@ -525,29 +551,12 @@ public class AjpProcessor extends AbstractProcessor {
             asyncStateMachine.asyncDispatched();
             break;
         }
-        case ASYNC_SETTIMEOUT: {
-            if (param == null) {
-                return;
-            }
-            long timeout = ((Long) param).longValue();
-            setAsyncTimeout(timeout);
-            break;
-        }
-        case ASYNC_TIMEOUT: {
-            AtomicBoolean result = (AtomicBoolean) param;
-            result.set(asyncStateMachine.asyncTimeout());
-            break;
-        }
-        case ASYNC_RUN: {
-            asyncStateMachine.asyncRun((Runnable) param);
-            break;
-        }
         case ASYNC_ERROR: {
             asyncStateMachine.asyncError();
             break;
         }
-        case ASYNC_IS_STARTED: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncStarted());
+        case ASYNC_IS_ASYNC: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isAsync());
             break;
         }
         case ASYNC_IS_COMPLETING: {
@@ -558,29 +567,40 @@ public class AjpProcessor extends AbstractProcessor {
             ((AtomicBoolean) param).set(asyncStateMachine.isAsyncDispatching());
             break;
         }
-        case ASYNC_IS_ASYNC: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsync());
+        case ASYNC_IS_ERROR: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncError());
+            break;
+        }
+        case ASYNC_IS_STARTED: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncStarted());
             break;
         }
         case ASYNC_IS_TIMINGOUT: {
             ((AtomicBoolean) param).set(asyncStateMachine.isAsyncTimingOut());
             break;
         }
-        case ASYNC_IS_ERROR: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncError());
+        case ASYNC_RUN: {
+            asyncStateMachine.asyncRun((Runnable) param);
             break;
         }
-        case UPGRADE: {
-            // HTTP connections only. Unsupported for AJP.
-            throw new UnsupportedOperationException(
-                    sm.getString("ajpprocessor.httpupgrade.notsupported"));
-        }
-        case AVAILABLE: {
-            if (available()) {
-                request.setAvailable(1);
-            } else {
-                request.setAvailable(0);
+        case ASYNC_SETTIMEOUT: {
+            if (param == null) {
+                return;
             }
+            long timeout = ((Long) param).longValue();
+            setAsyncTimeout(timeout);
+            break;
+        }
+        case ASYNC_TIMEOUT: {
+            AtomicBoolean result = (AtomicBoolean) param;
+            result.set(asyncStateMachine.asyncTimeout());
+            break;
+        }
+
+        // Servlet 3.1 non-blocking I/O
+        case REQUEST_BODY_FULLY_READ: {
+            AtomicBoolean result = (AtomicBoolean) param;
+            result.set(endOfStream);
             break;
         }
         case NB_READ_INTEREST: {
@@ -595,11 +615,6 @@ public class AjpProcessor extends AbstractProcessor {
             isReady.set(result);
             break;
         }
-        case REQUEST_BODY_FULLY_READ: {
-            AtomicBoolean result = (AtomicBoolean) param;
-            result.set(endOfStream);
-            break;
-        }
         case DISPATCH_READ: {
             addDispatch(DispatchType.NON_BLOCKING_READ);
             break;
@@ -612,15 +627,12 @@ public class AjpProcessor extends AbstractProcessor {
             socketWrapper.executeNonBlockingDispatches(getIteratorAndClearDispatches());
             break;
         }
-        case CLOSE_NOW: {
-            // Prevent further writes to the response
-            swallowResponse = true;
-            setErrorState(ErrorState.CLOSE_NOW, null);
-            break;
-        }
-        case END_REQUEST: {
-            // NO-OP for AJP
-            break;
+
+        // Servlet 3.1 HTTP Upgrade
+        case UPGRADE: {
+            // HTTP connections only. Unsupported for AJP.
+            throw new UnsupportedOperationException(
+                    sm.getString("ajpprocessor.httpupgrade.notsupported"));
         }
 
         // Servlet 4.0 Push requests

==================================================
StreamProcessor.java
index b666e8b5bc..9a663361d9 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -683,20 +683,8 @@ public class Http11Processor extends AbstractProcessor {
             }
             break;
         }
-        case IS_ERROR: {
-            ((AtomicBoolean) param).set(getErrorState().isError());
-            break;
-        }
-        case DISABLE_SWALLOW_INPUT: {
-            // Do not swallow request input and make sure we are closing the
-            // connection
-            setErrorState(ErrorState.CLOSE_CLEAN, null);
-            inputBuffer.setSwallowInput(false);
-            break;
-        }
-        case RESET: {
-            // Note: This must be called before the response is committed
-            outputBuffer.reset();
+        case AVAILABLE: {
+            request.setAvailable(inputBuffer.available(Boolean.TRUE.equals(param)));
             break;
         }
         case REQ_SET_BODY_REPLAY: {
@@ -709,117 +697,36 @@ public class Http11Processor extends AbstractProcessor {
             internalBuffer.addActiveFilter(savedBody);
             break;
         }
-        case ASYNC_START: {
-            asyncStateMachine.asyncStart((AsyncContextCallback) param);
-            break;
-        }
-        case ASYNC_DISPATCHED: {
-            asyncStateMachine.asyncDispatched();
-            break;
-        }
-        case ASYNC_TIMEOUT: {
-            AtomicBoolean result = (AtomicBoolean) param;
-            result.set(asyncStateMachine.asyncTimeout());
-            break;
-        }
-        case ASYNC_RUN: {
-            asyncStateMachine.asyncRun((Runnable) param);
-            break;
-        }
-        case ASYNC_ERROR: {
-            asyncStateMachine.asyncError();
-            break;
-        }
-        case ASYNC_IS_STARTED: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncStarted());
-            break;
-        }
-        case ASYNC_IS_COMPLETING: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isCompleting());
-            break;
-        }
-        case ASYNC_IS_DISPATCHING: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncDispatching());
-            break;
-        }
-        case ASYNC_IS_ASYNC: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsync());
-            break;
-        }
-        case ASYNC_IS_TIMINGOUT: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncTimingOut());
-            break;
-        }
-        case ASYNC_IS_ERROR: {
-            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncError());
-            break;
-        }
-        case ASYNC_COMPLETE: {
-            clearDispatches();
-            if (asyncStateMachine.asyncComplete()) {
-                socketWrapper.processSocket(SocketEvent.OPEN_READ, true);
-            }
-            break;
-        }
-        case ASYNC_SETTIMEOUT: {
-            if (param == null) {
-                return;
-            }
-            long timeout = ((Long) param).longValue();
-            setAsyncTimeout(timeout);
+        case RESET: {
+            // Note: This must be called before the response is committed
+            outputBuffer.reset();
             break;
         }
-        case ASYNC_DISPATCH: {
-            if (asyncStateMachine.asyncDispatch()) {
-                socketWrapper.processSocket(SocketEvent.OPEN_READ, true);
-            }
+
+        // Error handling
+        case IS_ERROR: {
+            ((AtomicBoolean) param).set(getErrorState().isError());
             break;
         }
-        case UPGRADE: {
-            upgradeToken = (UpgradeToken) param;
-            // Stop further HTTP output
+        case CLOSE_NOW: {
+            // Block further output
             outputBuffer.finished = true;
+            setErrorState(ErrorState.CLOSE_NOW, null);
             break;
         }
-        case AVAILABLE: {
-            request.setAvailable(inputBuffer.available(Boolean.TRUE.equals(param)));
-            break;
-        }
-        case NB_WRITE_INTEREST: {
-            AtomicBoolean isReady = (AtomicBoolean)param;
-            isReady.set(outputBuffer.isReady());
-            break;
-        }
-        case NB_READ_INTEREST: {
-            socketWrapper.registerReadInterest();
-            break;
-        }
-        case REQUEST_BODY_FULLY_READ: {
-            AtomicBoolean result = (AtomicBoolean) param;
-            result.set(inputBuffer.isFinished());
-            break;
-        }
-        case DISPATCH_READ: {
-            addDispatch(DispatchType.NON_BLOCKING_READ);
-            break;
-        }
-        case DISPATCH_WRITE: {
-            addDispatch(DispatchType.NON_BLOCKING_WRITE);
-            break;
-        }
-        case DISPATCH_EXECUTE: {
-            SocketWrapperBase<?> wrapper = socketWrapper;
-            if (wrapper != null) {
-                wrapper.executeNonBlockingDispatches(getIteratorAndClearDispatches());
-            }
+        case DISABLE_SWALLOW_INPUT: {
+            // Do not swallow request input and make sure we are closing the
+            // connection
+            setErrorState(ErrorState.CLOSE_CLEAN, null);
+            inputBuffer.setSwallowInput(false);
             break;
         }
-        case CLOSE_NOW: {
-            // Block further output
-            outputBuffer.finished = true;
-            setErrorState(ErrorState.CLOSE_NOW, null);
+        case END_REQUEST: {
+            endRequest();
             break;
         }
+
+        // Request attribute support
         case REQ_HOST_ADDR_ATTRIBUTE: {
             if (socketWrapper == null) {
                 request.remoteAddr().recycle();
@@ -836,38 +743,40 @@ public class Http11Processor extends AbstractProcessor {
             }
             break;
         }
-        case REQ_REMOTEPORT_ATTRIBUTE: {
+        case REQ_LOCALPORT_ATTRIBUTE: {
             if (socketWrapper == null) {
-                request.setRemotePort(0);
+                request.setLocalPort(0);
             } else {
-                request.setRemotePort(socketWrapper.getRemotePort());
+                request.setLocalPort(socketWrapper.getLocalPort());
             }
             break;
         }
-        case REQ_LOCAL_NAME_ATTRIBUTE: {
+        case REQ_LOCAL_ADDR_ATTRIBUTE: {
             if (socketWrapper == null) {
-                request.localName().recycle();
+                request.localAddr().recycle();
             } else {
-                request.localName().setString(socketWrapper.getLocalName());
+                request.localAddr().setString(socketWrapper.getLocalAddr());
             }
             break;
         }
-        case REQ_LOCAL_ADDR_ATTRIBUTE: {
+        case REQ_LOCAL_NAME_ATTRIBUTE: {
             if (socketWrapper == null) {
-                request.localAddr().recycle();
+                request.localName().recycle();
             } else {
-                request.localAddr().setString(socketWrapper.getLocalAddr());
+                request.localName().setString(socketWrapper.getLocalName());
             }
             break;
         }
-        case REQ_LOCALPORT_ATTRIBUTE: {
+        case REQ_REMOTEPORT_ATTRIBUTE: {
             if (socketWrapper == null) {
-                request.setLocalPort(0);
+                request.setRemotePort(0);
             } else {
-                request.setLocalPort(socketWrapper.getLocalPort());
+                request.setRemotePort(socketWrapper.getRemotePort());
             }
             break;
         }
+
+        // SSL request attribute support
         case REQ_SSL_ATTRIBUTE: {
             try {
                 if (sslSupport != null) {
@@ -924,8 +833,111 @@ public class Http11Processor extends AbstractProcessor {
             }
             break;
         }
-        case END_REQUEST: {
-            endRequest();
+
+        // Servlet 3.0 asynchronous support
+        case ASYNC_START: {
+            asyncStateMachine.asyncStart((AsyncContextCallback) param);
+            break;
+        }
+        case ASYNC_COMPLETE: {
+            clearDispatches();
+            if (asyncStateMachine.asyncComplete()) {
+                socketWrapper.processSocket(SocketEvent.OPEN_READ, true);
+            }
+            break;
+        }
+        case ASYNC_DISPATCH: {
+            if (asyncStateMachine.asyncDispatch()) {
+                socketWrapper.processSocket(SocketEvent.OPEN_READ, true);
+            }
+            break;
+        }
+        case ASYNC_DISPATCHED: {
+            asyncStateMachine.asyncDispatched();
+            break;
+        }
+        case ASYNC_ERROR: {
+            asyncStateMachine.asyncError();
+            break;
+        }
+        case ASYNC_IS_ASYNC: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isAsync());
+            break;
+        }
+        case ASYNC_IS_COMPLETING: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isCompleting());
+            break;
+        }
+        case ASYNC_IS_DISPATCHING: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncDispatching());
+            break;
+        }
+        case ASYNC_IS_ERROR: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncError());
+            break;
+        }
+        case ASYNC_IS_STARTED: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncStarted());
+            break;
+        }
+        case ASYNC_IS_TIMINGOUT: {
+            ((AtomicBoolean) param).set(asyncStateMachine.isAsyncTimingOut());
+            break;
+        }
+        case ASYNC_RUN: {
+            asyncStateMachine.asyncRun((Runnable) param);
+            break;
+        }
+        case ASYNC_SETTIMEOUT: {
+            if (param == null) {
+                return;
+            }
+            long timeout = ((Long) param).longValue();
+            setAsyncTimeout(timeout);
+            break;
+        }
+        case ASYNC_TIMEOUT: {
+            AtomicBoolean result = (AtomicBoolean) param;
+            result.set(asyncStateMachine.asyncTimeout());
+            break;
+        }
+
+        // Servlet 3.1 non-blocking I/O
+        case REQUEST_BODY_FULLY_READ: {
+            AtomicBoolean result = (AtomicBoolean) param;
+            result.set(inputBuffer.isFinished());
+            break;
+        }
+        case NB_READ_INTEREST: {
+            socketWrapper.registerReadInterest();
+            break;
+        }
+        case NB_WRITE_INTEREST: {
+            AtomicBoolean isReady = (AtomicBoolean)param;
+            isReady.set(outputBuffer.isReady());
+            break;
+        }
+        case DISPATCH_READ: {
+            addDispatch(DispatchType.NON_BLOCKING_READ);
+            break;
+        }
+        case DISPATCH_WRITE: {
+            addDispatch(DispatchType.NON_BLOCKING_WRITE);
+            break;
+        }
+        case DISPATCH_EXECUTE: {
+            SocketWrapperBase<?> wrapper = socketWrapper;
+            if (wrapper != null) {
+                wrapper.executeNonBlockingDispatches(getIteratorAndClearDispatches());
+            }
+            break;
+        }
+
+        // Servlet 3.1 HTTP Upgrade
+        case UPGRADE: {
+            upgradeToken = (UpgradeToken) param;
+            // Stop further HTTP output
+            outputBuffer.finished = true;
             break;
         }
 

==================================================
