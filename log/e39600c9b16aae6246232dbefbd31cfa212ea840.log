e39600c9b16aae6246232dbefbd31cfa212ea840
==================================================
Part 1 of fix for
==================================================
Mark Thomas
==================================================
Fri Dec 5 17:32:34 2014 +0000
==================================================
ExpressionFactoryImpl.java
Part 1 of fix for
https://issues.apache.org/bugzilla/show_bug.cgi?id=57309
Addressed the direct calls to ELSupport.coerceToType()
Still need to address the type specific versions of that method.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1643365 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ELSupport.java
index 704fa102e8..e32ecedb0d 100644
--- a/java/org/apache/el/ExpressionFactoryImpl.java
+++ b/java/org/apache/el/ExpressionFactoryImpl.java
@@ -44,7 +44,7 @@ public class ExpressionFactoryImpl extends ExpressionFactory {
 
     @Override
     public Object coerceToType(Object obj, Class<?> type) {
-        return ELSupport.coerceToType(obj, type);
+        return ELSupport.coerceToType(null, obj, type);
     }
 
     @Override

==================================================
AstFunction.java
index 943cd5180d..cc4529aece 100644
--- a/java/org/apache/el/lang/ELSupport.java
+++ b/java/org/apache/el/lang/ELSupport.java
@@ -28,8 +28,8 @@ import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
 
+import javax.el.ELContext;
 import javax.el.ELException;
-
 import org.apache.el.util.MessageFactory;
 
 
@@ -430,9 +430,21 @@ public class ELSupport {
         }
     }
 
-    public static final Object coerceToType(final Object obj,
+    public static final Object coerceToType(final ELContext ctx, final Object obj,
             final Class<?> type) throws ELException {
 
+        if (ctx != null) {
+            boolean originalIsPropertyResolved = ctx.isPropertyResolved();
+            try {
+                Object result = ctx.getELResolver().convertToType(ctx, obj, type);
+                if (ctx.isPropertyResolved()) {
+                    return result;
+                }
+            } finally {
+                ctx.setPropertyResolved(originalIsPropertyResolved);
+            }
+        }
+
         if (type == null || Object.class.equals(type) ||
                 (obj != null && type.isAssignableFrom(obj.getClass()))) {
             return obj;
@@ -495,14 +507,14 @@ public class ELSupport {
 
         // Handle arrays
         if (type.isArray() && obj.getClass().isArray()) {
-            return coerceToArray(obj, type);
+            return coerceToArray(ctx, obj, type);
         }
 
         throw new ELException(MessageFactory.get("error.convert",
                 obj, obj.getClass(), type));
     }
 
-    private static Object coerceToArray(final Object obj,
+    private static Object coerceToArray(final ELContext ctx, final Object obj,
             final Class<?> type) {
         // Note: Nested arrays will result in nested calls to this method.
 
@@ -517,7 +529,7 @@ public class ELSupport {
         Object result = Array.newInstance(componentType, size);
         // Coerce each element in turn.
         for (int i = 0; i < size; i++) {
-            Array.set(result, i, coerceToType(Array.get(obj, i), componentType));
+            Array.set(result, i, coerceToType(ctx, Array.get(obj, i), componentType));
         }
 
         return result;

==================================================
AstValue.java
index 47ffc9a48d..9e0154c522 100644
--- a/java/org/apache/el/parser/AstFunction.java
+++ b/java/org/apache/el/parser/AstFunction.java
@@ -176,12 +176,12 @@ public final class AstFunction extends SimpleNode {
                             Class<?> target = paramTypes[i].getComponentType();
                             for (int j = i; j < inputParameterCount; j++) {
                                 varargs[j-i] = parameters.jjtGetChild(j).getValue(ctx);
-                                varargs[j-i] = coerceToType(varargs[j-i], target);
+                                varargs[j-i] = coerceToType(ctx, varargs[j-i], target);
                             }
                         }
                     } else {
                         params[i] = parameters.jjtGetChild(i).getValue(ctx);
-                        params[i] = coerceToType(params[i], paramTypes[i]);
+                        params[i] = coerceToType(ctx, params[i], paramTypes[i]);
                     }
                 }
             } catch (ELException ele) {

==================================================
ReflectionUtil.java
index a9040025ba..0f6e01c752 100644
--- a/java/org/apache/el/parser/AstValue.java
+++ b/java/org/apache/el/parser/AstValue.java
@@ -198,7 +198,7 @@ public final class AstValue extends SimpleNode {
         // coerce to the expected type
         Class<?> targetClass = resolver.getType(ctx, t.base, t.property);
         resolver.setValue(ctx, t.base, t.property,
-                ELSupport.coerceToType(value, targetClass));
+                ELSupport.coerceToType(ctx, value, targetClass));
         if (!ctx.isPropertyResolved()) {
             throw new PropertyNotFoundException(MessageFactory.get(
                     "error.resolver.unhandled", t.base, t.property));
@@ -212,7 +212,7 @@ public final class AstValue extends SimpleNode {
             throws ELException {
         Target t = getTarget(ctx);
         Method m = ReflectionUtil.getMethod(
-                t.base, t.property, paramTypes, null);
+                ctx, t.base, t.property, paramTypes, null);
         return new MethodInfo(m.getName(), m.getReturnType(), m
                 .getParameterTypes());
     }
@@ -235,10 +235,10 @@ public final class AstValue extends SimpleNode {
             values = paramValues;
             types = paramTypes;
         }
-        m = ReflectionUtil.getMethod(t.base, t.property, types, values);
+        m = ReflectionUtil.getMethod(ctx, t.base, t.property, types, values);
 
         // Handle varArgs and any co-ercion required
-        values = convertArgs(values, m);
+        values = convertArgs(ctx, values, m);
 
         Object result = null;
         try {
@@ -260,7 +260,7 @@ public final class AstValue extends SimpleNode {
         return result;
     }
 
-    private Object[] convertArgs(Object[] src, Method m) {
+    private Object[] convertArgs(EvaluationContext ctx, Object[] src, Method m) {
         Class<?>[] types = m.getParameterTypes();
         if (types.length == 0) {
             return new Object[0];
@@ -271,7 +271,7 @@ public final class AstValue extends SimpleNode {
         Object[] dest = new Object[paramCount];
 
         for (int i = 0; i < paramCount - 1; i++) {
-            dest[i] = ELSupport.coerceToType(src[i], types[i]);
+            dest[i] = ELSupport.coerceToType(ctx, src[i], types[i]);
         }
 
         if (m.isVarArgs()) {
@@ -279,13 +279,13 @@ public final class AstValue extends SimpleNode {
                     m.getParameterTypes()[paramCount - 1].getComponentType(),
                     src.length - (paramCount - 1));
             for (int i = 0; i < src.length - (paramCount - 1); i ++) {
-                varArgs[i] = ELSupport.coerceToType(src[paramCount - 1 + i],
+                varArgs[i] = ELSupport.coerceToType(ctx, src[paramCount - 1 + i],
                         types[paramCount - 1].getComponentType());
             }
             dest[paramCount - 1] = varArgs;
         } else {
             dest[paramCount - 1] = ELSupport.coerceToType(
-                    src[paramCount - 1], types[paramCount - 1]);
+                    ctx, src[paramCount - 1], types[paramCount - 1]);
         }
 
         return dest;

==================================================
TestELSupport.java
index 9763ea3431..7792b0b5f4 100644
--- a/java/org/apache/el/util/ReflectionUtil.java
+++ b/java/org/apache/el/util/ReflectionUtil.java
@@ -28,6 +28,7 @@ import javax.el.ELException;
 import javax.el.MethodNotFoundException;
 
 import org.apache.el.lang.ELSupport;
+import org.apache.el.lang.EvaluationContext;
 
 
 /**
@@ -111,6 +112,7 @@ public class ReflectionUtil {
 
     /**
      * Returns a method based on the criteria.
+     * @param ctx the context in which the expression is being evaluated
      * @param base the object that owns the method
      * @param property the name of the method
      * @param paramTypes the parameter types to use
@@ -124,7 +126,7 @@ public class ReflectionUtil {
      * the code in sync.
      */
     @SuppressWarnings("null")
-    public static Method getMethod(Object base, Object property,
+    public static Method getMethod(EvaluationContext ctx, Object base, Object property,
             Class<?>[] paramTypes, Object[] paramValues)
             throws MethodNotFoundException {
         if (base == null || property == null) {
@@ -186,7 +188,7 @@ public class ReflectionUtil {
                                 noMatch = true;
                                 break;
                             } else {
-                                if (isCoercibleFrom(paramValues[j], varType)) {
+                                if (isCoercibleFrom(ctx, paramValues[j], varType)) {
                                     coercibleMatch++;
                                 } else {
                                     noMatch = true;
@@ -205,7 +207,7 @@ public class ReflectionUtil {
                         noMatch = true;
                         break;
                     } else {
-                        if (isCoercibleFrom(paramValues[i], mParamTypes[i])) {
+                        if (isCoercibleFrom(ctx, paramValues[i], mParamTypes[i])) {
                             coercibleMatch++;
                         } else {
                             noMatch = true;
@@ -381,11 +383,11 @@ public class ReflectionUtil {
      * This class duplicates code in javax.el.Util. When making changes keep
      * the code in sync.
      */
-    private static boolean isCoercibleFrom(Object src, Class<?> target) {
+    private static boolean isCoercibleFrom(EvaluationContext ctx, Object src, Class<?> target) {
         // TODO: This isn't pretty but it works. Significant refactoring would
         //       be required to avoid the exception.
         try {
-            ELSupport.coerceToType(src, target);
+            ELSupport.coerceToType(ctx, src, target);
         } catch (ELException e) {
             return false;
         }

==================================================
TestReflectionUtil.java
index 93b687e4f4..a5ea627c6f 100644
--- a/test/org/apache/el/lang/TestELSupport.java
+++ b/test/org/apache/el/lang/TestELSupport.java
@@ -81,13 +81,13 @@ public class TestELSupport {
     @Test
     public void testCoerceIntegerToNumber() {
         Integer input = Integer.valueOf(4390241);
-        Object output = ELSupport.coerceToType(input, Number.class);
+        Object output = ELSupport.coerceToType(null, input, Number.class);
         assertEquals(input, output);
     }
 
     @Test
     public void testCoerceNullToNumber() {
-        Object output = ELSupport.coerceToType(null, Number.class);
+        Object output = ELSupport.coerceToType(null, null, Number.class);
         assertNull(output);
     }
 

==================================================
