0b139666157335c0415ae24789bae1082c673966
==================================================
Remove JASPIC authenticator and associated modules implemented during GSoC.
==================================================
Mark Thomas
==================================================
Fri Jan 1 17:27:07 2016 +0000
==================================================
AuthConfigFactoryImpl.java
Remove JASPIC authenticator and associated modules implemented during GSoC.
See http://tomcat.markmail.org/thread/ar2pdpb6vibu2dwd for reasoning.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1722510 13f79535-47bb-0310-9956-ffa450edef68



==================================================
JaspicAuthenticator.java
deleted file mode 100644
index 0cfa0ad58e..0000000000
--- a/java/org/apache/catalina/authenticator/jaspic/AuthConfigFactoryImpl.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import javax.security.auth.message.config.AuthConfigFactory;
-import javax.security.auth.message.config.AuthConfigProvider;
-import javax.security.auth.message.config.RegistrationListener;
-
-public class AuthConfigFactoryImpl extends AuthConfigFactory {
-
-    private Map<String, ConfigProviderInfo> configProviders = new HashMap<>();
-
-
-    @Override
-    public AuthConfigProvider getConfigProvider(String layer, String appContext,
-            RegistrationListener listener) {
-
-        String registrationKey = getRegistrationKey(layer, appContext);
-
-        ConfigProviderInfo provider = configProviders.get(registrationKey);
-        if (provider == null) {
-            provider = configProviders.get(getRegistrationKey(null, appContext));
-        }
-        if (provider == null) {
-            provider = configProviders.get(getRegistrationKey(layer, null));
-        }
-        if (provider == null) {
-            provider = configProviders.get(getRegistrationKey(null, null));
-        }
-        if (provider == null) {
-            return null;
-        }
-
-        if (listener != null) {
-            provider.addListener(listener);
-        }
-
-        return provider.getAuthConfigProvider();
-    }
-
-
-    @Override
-    @SuppressWarnings("rawtypes") // JASPIC API uses raw types
-    public String registerConfigProvider(String className, Map properties, String layer,
-            String appContext, String description) {
-        throw new IllegalStateException("Not implemented yet!");
-    }
-
-
-    @Override
-    public String registerConfigProvider(AuthConfigProvider provider, String layer,
-            String appContext, String description) {
-
-        String registrationId = getRegistrationKey(layer, appContext);
-        ConfigProviderInfo providerInfo =
-                new ConfigProviderInfo(provider, true, layer, appContext, description);
-        configProviders.put(registrationId, providerInfo);
-        return registrationId;
-    }
-
-
-    @Override
-    public boolean removeRegistration(String registrationID) {
-        return configProviders.remove(registrationID) != null;
-    }
-
-
-    @Override
-    public String[] detachListener(RegistrationListener listener, String layer, String appContext) {
-        return null;
-    }
-
-
-    @Override
-    public String[] getRegistrationIDs(AuthConfigProvider provider) {
-        return null;
-    }
-
-
-    @Override
-    public RegistrationContext getRegistrationContext(String registrationID) {
-        return configProviders.get(registrationID);
-    }
-
-
-    @Override
-    public void refresh() {
-
-    }
-
-
-    private String getRegistrationKey(String layer, String appContext) {
-        return layer + "/" + appContext;
-    }
-
-
-    private static class ConfigProviderInfo implements AuthConfigFactory.RegistrationContext {
-        private final AuthConfigProvider authConfigProvider;
-        private String appContext;
-        private String description;
-        private String messageLayer;
-        private final boolean persistent;
-        private final List<RegistrationListener> listeners = new ArrayList<>();
-
-        private ConfigProviderInfo(AuthConfigProvider authConfigProvider, boolean persistent,
-                String layer, String appContext, String description) {
-            this.authConfigProvider = authConfigProvider;
-            this.persistent = persistent;
-            this.messageLayer = layer;
-            this.appContext = appContext;
-            this.description = description;
-        }
-
-        private ConfigProviderInfo(AuthConfigProvider authConfigProvider,
-                List<RegistrationListener> listeners, boolean persistent) {
-            this.authConfigProvider = authConfigProvider;
-            this.persistent = persistent;
-        }
-
-        public AuthConfigProvider getAuthConfigProvider() {
-            return authConfigProvider;
-        }
-
-        public List<RegistrationListener> getListeners() {
-            return listeners;
-        }
-
-        public void addListener(RegistrationListener listener) {
-            listeners.add(listener);
-        }
-
-        @Override
-        public String getAppContext() {
-            return appContext;
-        }
-
-        @Override
-        public String getDescription() {
-            return description;
-        }
-
-        @Override
-        public String getMessageLayer() {
-            return messageLayer;
-        }
-
-        @Override
-        public boolean isPersistent() {
-            return persistent;
-        }
-    }
-}

==================================================
JaspicCallbackHandler.java
deleted file mode 100644
index d3eec5bc67..0000000000
--- a/java/org/apache/catalina/authenticator/jaspic/JaspicAuthenticator.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic;
-
-import java.io.IOException;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-import javax.security.auth.Subject;
-import javax.security.auth.message.AuthException;
-import javax.security.auth.message.AuthStatus;
-import javax.security.auth.message.config.AuthConfigFactory;
-import javax.security.auth.message.config.AuthConfigProvider;
-import javax.security.auth.message.config.ServerAuthConfig;
-import javax.security.auth.message.config.ServerAuthContext;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.authenticator.AuthenticatorBase;
-import org.apache.catalina.connector.Request;
-import org.apache.catalina.realm.GenericPrincipal;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.res.StringManager;
-
-/**
- * Security valve which implements JASPIC authentication.
- */
-public class JaspicAuthenticator extends AuthenticatorBase {
-
-    private static final Log log = LogFactory.getLog(JaspicAuthenticator.class);
-    protected static final StringManager sm = StringManager.getManager(JaspicAuthenticator.class);
-
-    private static final String AUTH_TYPE = "JASPIC";
-    public static final String MESSAGE_LAYER = "HttpServlet";
-
-    private String appContext;
-    private Subject serviceSubject;
-
-    private Map<String, String> authProperties = new HashMap<>();
-
-    private JaspicCallbackHandler callbackHandler;
-
-    @Override
-    protected synchronized void startInternal() throws LifecycleException {
-        super.startInternal();
-        serviceSubject = new Subject();
-        callbackHandler = getJaspicCallbackHandler();
-        appContext = context.getServletContext().getVirtualServerName() + " " + context.getServletContext().getContextPath();
-    }
-
-
-    @Override
-    public boolean authenticate(Request request, HttpServletResponse response) throws IOException {
-        if (checkForCachedAuthentication(request, response, true)) {
-            return true;
-        }
-
-        MessageInfoImpl messageInfo = new MessageInfoImpl(request, response, true);
-
-        AuthConfigFactory factory = AuthConfigFactory.getFactory();
-
-        AuthConfigProvider configProvider = factory.getConfigProvider(MESSAGE_LAYER, appContext,
-                null);
-        if (configProvider == null) {
-            handleUnauthorizedRequest(response, null);
-            return false;
-        }
-
-        AuthStatus authStatus;
-        Subject subject = new Subject();
-        try {
-            // TODO: A number of the method calls below are synchronised. For
-            //       something that may get called on every request that is a
-            //       potential bottleneck.
-            ServerAuthConfig authConfig = configProvider.getServerAuthConfig(MESSAGE_LAYER,
-                    appContext, callbackHandler);
-            String messageAuthContextId = authConfig.getAuthContextID(messageInfo);
-            ServerAuthContext authContext = authConfig.getAuthContext(messageAuthContextId,
-                    serviceSubject, authProperties);
-            authStatus = authContext.validateRequest(messageInfo, subject, serviceSubject);
-        } catch (AuthException e) {
-            handleUnauthorizedRequest(response, e);
-            return false;
-        }
-
-        if (authStatus == AuthStatus.SUCCESS) {
-            GenericPrincipal principal = getPrincipal(subject);
-            if (principal != null) {
-                register(request, response, principal, AUTH_TYPE, null, null);
-            }
-            return true;
-        }
-        return false;
-    }
-
-
-    private GenericPrincipal getPrincipal(Subject subject) {
-        if (subject == null) {
-            return null;
-        }
-
-        Set<GenericPrincipal> principals = subject.getPrivateCredentials(GenericPrincipal.class);
-        if (principals.isEmpty()) {
-            return null;
-        }
-
-        return principals.iterator().next();
-    }
-
-
-    private void handleUnauthorizedRequest(HttpServletResponse response, AuthException e)
-            throws IOException {
-        response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
-        if (log.isDebugEnabled()) {
-            log.debug(sm.getString("authenticator.jaspic.unauthorized"), e);
-        }
-    }
-
-
-    private JaspicCallbackHandler getJaspicCallbackHandler() {
-        return new JaspicCallbackHandler(container.getRealm());
-    }
-
-
-    @Override
-    protected String getAuthMethod() {
-        return context.getLoginConfig().getAuthMethod();
-    }
-
-
-    public void setProperty(String key, String value) {
-        this.authProperties.put(key, value);
-    }
-
-
-    public Map<String, String> getAuthProperties() {
-        return Collections.unmodifiableMap(authProperties);
-    }
-
-    public String getAppContext() {
-        return appContext;
-    }
-
-}

==================================================
MessageInfoImpl.java
deleted file mode 100644
index 1115d4e6d8..0000000000
--- a/java/org/apache/catalina/authenticator/jaspic/LocalStrings.properties
+++ /dev/null
@@ -1,20 +0,0 @@
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-authenticator.jaspic.unauthorized=Cannot authenticate with the provided credentials
-authenticator.jaspic.unknownCallback=Unknown JASPIC callback: [{0}]
-authenticator.jaspic.unknownAuthType=Unknown authentication type: [{0}]
-authenticator.jaspic.badRequestType=Request [{0}] is not a Catalina request
-authenticator.jaspic.badResponseType=Response [{0}] is not a Servlet response
\ No newline at end of file

==================================================
PrincipalGroupCallback.java
deleted file mode 100644
index 1c27a7976a..0000000000
--- a/java/org/apache/catalina/authenticator/jaspic/MessageInfoImpl.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import javax.security.auth.message.MessageInfo;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.catalina.connector.Request;
-import org.apache.tomcat.util.res.StringManager;
-
-public class MessageInfoImpl implements MessageInfo {
-    protected static final StringManager sm = StringManager.getManager(MessageInfoImpl.class);
-
-    public static final String IS_MANDATORY = "javax.security.auth.message.MessagePolicy.isMandatory";
-
-    private final Map<String, Object> map = new HashMap<>();
-    private Request request;
-    private HttpServletResponse response;
-
-    public MessageInfoImpl() {
-    }
-
-    public MessageInfoImpl(Request request, HttpServletResponse response, boolean authMandatory) {
-        this.request = request;
-        this.response = response;
-        map.put(IS_MANDATORY, Boolean.toString(authMandatory));
-    }
-
-    @Override
-    @SuppressWarnings("rawtypes")
-    // JASPIC uses raw types
-    public Map getMap() {
-        return map;
-    }
-
-    @Override
-    public Object getRequestMessage() {
-        return request;
-    }
-
-    @Override
-    public Object getResponseMessage() {
-        return response;
-    }
-
-    @Override
-    public void setRequestMessage(Object request) {
-        if (!(request instanceof Request)) {
-            throw new IllegalArgumentException(sm.getString("authenticator.jaspic.badRequestType",
-                    request.getClass().getName()));
-        }
-        this.request = (Request) request;
-    }
-
-    @Override
-    public void setResponseMessage(Object response) {
-        if (!(response instanceof HttpServletResponse)) {
-            throw new IllegalArgumentException(sm.getString("authenticator.jaspic.badResponseType",
-                    response.getClass().getName()));
-        }
-        this.response = (HttpServletResponse) response;
-    }
-}
\ No newline at end of file

==================================================
TomcatAuthConfig.java
deleted file mode 100644
index 50170401f6..0000000000
--- a/java/org/apache/catalina/authenticator/jaspic/PrincipalGroupCallback.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic;
-
-import java.security.Principal;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
-import javax.security.auth.Subject;
-import javax.security.auth.message.callback.CallerPrincipalCallback;
-import javax.security.auth.message.callback.GroupPrincipalCallback;
-
-import org.apache.catalina.realm.GenericPrincipal;
-
-/**
- * This class uses callbacks to construct JAAS Subject with
- * {@link GenericPrincipal}.
- */
-public class PrincipalGroupCallback {
-    private CallerPrincipalCallback callerPrincipalCallback;
-    private GroupPrincipalCallback groupPrincipalCallback;
-
-
-    public void setCallerPrincipalCallback(CallerPrincipalCallback callerPrincipalCallback) {
-        this.callerPrincipalCallback = callerPrincipalCallback;
-    }
-
-    public void setGroupPrincipalCallback(GroupPrincipalCallback groupPrincipalCallback) {
-        this.groupPrincipalCallback = groupPrincipalCallback;
-    }
-
-
-    /**
-     * Enrich JAAS subject with Tomcat's {@link GenericPrincipal}.
-     */
-    public void configureSubject() {
-        GenericPrincipal principal = getPrincipal();
-        if (principal == null) {
-            return;
-        }
-        Subject subject = getSubject();
-        if (subject != null) {
-            subject.getPrivateCredentials().add(principal);
-        }
-    }
-
-    private Subject getSubject() {
-        if (callerPrincipalCallback != null) {
-            return callerPrincipalCallback.getSubject();
-        }
-        if (groupPrincipalCallback != null) {
-            return groupPrincipalCallback.getSubject();
-        }
-        return null;
-    }
-
-    /**
-     * Get tomcat's principal, which contains user principal and roles.
-     *
-     * @return {@link GenericPrincipal}
-     */
-    public GenericPrincipal getPrincipal() {
-        if (callerPrincipalCallback == null) {
-            return null;
-        }
-        Principal userPrincipal = getUserPrincipal();
-        return new GenericPrincipal(getUserName(), null, getRoles(), userPrincipal);
-    }
-
-
-    private Principal getUserPrincipal() {
-        if (callerPrincipalCallback == null) {
-            return null;
-        }
-        return callerPrincipalCallback.getPrincipal();
-    }
-
-
-    private List<String> getRoles() {
-        if (groupPrincipalCallback == null) {
-            return Collections.emptyList();
-        }
-        return Arrays.asList(groupPrincipalCallback.getGroups());
-    }
-
-
-    private String getUserName() {
-        String name = null;
-        if (callerPrincipalCallback != null) {
-            name = callerPrincipalCallback.getName();
-        }
-        if (name != null) {
-            return name;
-        }
-        return getUserPrincipalName();
-    }
-
-
-    private String getUserPrincipalName() {
-        Principal principal = getUserPrincipal();
-        if (principal == null) {
-            return null;
-        }
-        return principal.getName();
-    }
-}

==================================================
TomcatAuthConfigProvider.java
deleted file mode 100644
index 0a61ade255..0000000000
--- a/java/org/apache/catalina/authenticator/jaspic/provider/TomcatAuthConfig.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic.provider;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import javax.security.auth.Subject;
-import javax.security.auth.callback.CallbackHandler;
-import javax.security.auth.message.AuthException;
-import javax.security.auth.message.MessageInfo;
-import javax.security.auth.message.config.ServerAuthConfig;
-import javax.security.auth.message.config.ServerAuthContext;
-
-import org.apache.catalina.Context;
-import org.apache.catalina.Realm;
-import org.apache.catalina.authenticator.jaspic.provider.modules.BasicAuthModule;
-import org.apache.catalina.authenticator.jaspic.provider.modules.DigestAuthModule;
-import org.apache.catalina.authenticator.jaspic.provider.modules.FormAuthModule;
-import org.apache.catalina.authenticator.jaspic.provider.modules.NonLoginAuthModule;
-import org.apache.catalina.authenticator.jaspic.provider.modules.SSLAuthModule;
-import org.apache.catalina.authenticator.jaspic.provider.modules.SpnegoAuthModule;
-import org.apache.catalina.authenticator.jaspic.provider.modules.TomcatAuthModule;
-import org.apache.tomcat.util.descriptor.web.LoginConfig;
-import org.apache.tomcat.util.res.StringManager;
-
-public class TomcatAuthConfig implements ServerAuthConfig {
-    protected static final StringManager sm = StringManager.getManager(TomcatAuthConfig.class);
-
-    private String messageLayer;
-    private String appContext;
-    private CallbackHandler handler;
-    private TomcatServerAuthContext tomcatServerAuthContext;
-
-    private Context context;
-    private LoginConfig loginConfig;
-    private Realm realm;
-    private Map<String, String> properties;
-
-    public TomcatAuthConfig(String layer, String appContext, CallbackHandler callbackHandler,
-            Context context, Map<String, String> properties) throws AuthException {
-        this.messageLayer = layer;
-        this.appContext = appContext;
-        this.handler = callbackHandler;
-        this.context = context;
-        this.properties = properties;
-        this.realm = context.getRealm();
-        this.loginConfig = context.getLoginConfig();
-        initializeAuthContext(properties);
-    }
-
-
-    @Override
-    public String getMessageLayer() {
-        return messageLayer;
-    }
-
-
-    @Override
-    public String getAppContext() {
-        return appContext;
-    }
-
-
-    @Override
-    public String getAuthContextID(MessageInfo messageInfo) {
-        return messageInfo.toString();
-    }
-
-
-    @Override
-    public synchronized void refresh() {
-        this.tomcatServerAuthContext = null;
-    }
-
-
-    @Override
-    public boolean isProtected() {
-        return false;
-    }
-
-
-    @Override
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    public synchronized ServerAuthContext getAuthContext(String authContextID,
-            Subject serviceSubject, Map properties) throws AuthException {
-        if (this.tomcatServerAuthContext == null) {
-            initializeAuthContext(properties);
-        }
-        return tomcatServerAuthContext;
-    }
-
-
-    private void initializeAuthContext(Map<String, String> properties) throws AuthException {
-        TomcatAuthModule module = getModule();
-        module.initialize(null, null, handler, getMergedProperties(properties));
-        this.tomcatServerAuthContext = new TomcatServerAuthContext(module);
-    }
-
-
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    private Map<String, String> getMergedProperties(Map properties) {
-        Map<String, String> mergedProperties = new HashMap<>(this.properties);
-        mergedProperties.put(TomcatAuthModule.REALM_NAME, getRealmName());
-        if (properties != null) {
-            mergedProperties.putAll(properties);
-        }
-        return mergedProperties;
-    }
-
-
-    private TomcatAuthModule getModule() throws AuthException {
-        String authMethod = getAuthMethod();
-        switch (authMethod) {
-        case "BASIC":
-            return new BasicAuthModule(context);
-        case "DIGEST":
-            return new DigestAuthModule(context);
-        case "FORM":
-            return new FormAuthModule(context);
-        case "NONE":
-            return new NonLoginAuthModule(context);
-        case "SPNEGO":
-            return new SpnegoAuthModule(context);
-        case "CLIENT-CERT":
-            return new SSLAuthModule(context);
-        default:
-            throw new AuthException(
-                    sm.getString("authenticator.jaspic.unknownAuthType", authMethod));
-        }
-    }
-
-
-    private String getRealmName() {
-        return loginConfig.getRealmName();
-    }
-
-
-    /**
-     * Temporary workaround to get authentication method
-     * @return
-     */
-    private String getAuthMethod() {
-        return loginConfig.getAuthMethod().replace("JASPIC-", "");
-    }
-}

==================================================
TomcatServerAuthContext.java
deleted file mode 100644
index 77a35eae01..0000000000
--- a/java/org/apache/catalina/authenticator/jaspic/provider/TomcatAuthConfigProvider.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic.provider;
-
-import java.util.Map;
-
-import javax.security.auth.callback.CallbackHandler;
-import javax.security.auth.message.AuthException;
-import javax.security.auth.message.config.AuthConfigFactory;
-import javax.security.auth.message.config.AuthConfigProvider;
-import javax.security.auth.message.config.ClientAuthConfig;
-import javax.security.auth.message.config.ServerAuthConfig;
-
-import org.apache.catalina.Context;
-
-/**
- * Tomcat's context based JASPIC authentication provider. It returns
- * authentication modules depending on context login-config setup.
- */
-public class TomcatAuthConfigProvider implements AuthConfigProvider {
-
-    private Map<String, String> providerProperties;
-    private ServerAuthConfig serverAuthConfig;
-    private Context context;
-
-
-    public TomcatAuthConfigProvider(Context context, Map<String, String> properties) {
-        this.context = context;
-        this.providerProperties = properties;
-    }
-
-
-    public TomcatAuthConfigProvider(Map<String, String> properties, AuthConfigFactory factory) {
-        this.providerProperties = properties;
-        if (factory != null) {
-            factory.registerConfigProvider(this, null, null, "Auto registration");
-        }
-    }
-
-
-    @Override
-    public ClientAuthConfig getClientAuthConfig(String layer, String appContext,
-            CallbackHandler handler) throws AuthException {
-        return null;
-    }
-
-
-    @Override
-    public synchronized ServerAuthConfig getServerAuthConfig(String layer, String appContext,
-            CallbackHandler handler) throws AuthException {
-        if (this.serverAuthConfig == null) {
-            this.serverAuthConfig = new TomcatAuthConfig(layer, appContext, handler, context, providerProperties);
-        }
-        return this.serverAuthConfig;
-    }
-
-
-    @Override
-    public void refresh() {
-        serverAuthConfig.refresh();
-    }
-}

==================================================
BasicAuthModule.java
deleted file mode 100644
index 8309e280b2..0000000000
--- a/java/org/apache/catalina/authenticator/jaspic/provider/TomcatServerAuthContext.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic.provider;
-
-import javax.security.auth.Subject;
-import javax.security.auth.message.AuthException;
-import javax.security.auth.message.AuthStatus;
-import javax.security.auth.message.MessageInfo;
-import javax.security.auth.message.config.ServerAuthContext;
-import javax.security.auth.message.module.ServerAuthModule;
-
-import org.apache.tomcat.util.res.StringManager;
-
-/**
- * This class contains references to different JASPIC modules.
- */
-public class TomcatServerAuthContext implements ServerAuthContext {
-
-    protected static final StringManager sm = StringManager
-            .getManager(TomcatServerAuthContext.class);
-
-    private ServerAuthModule module;
-
-
-    public TomcatServerAuthContext(ServerAuthModule module) {
-        this.module = module;
-    }
-
-
-    @Override
-    public AuthStatus validateRequest(MessageInfo messageInfo, Subject clientSubject,
-            Subject serviceSubject) throws AuthException {
-        return module.validateRequest(messageInfo, clientSubject, serviceSubject);
-    }
-
-
-    @Override
-    public AuthStatus secureResponse(MessageInfo messageInfo, Subject serviceSubject)
-            throws AuthException {
-        return module.secureResponse(messageInfo, serviceSubject);
-    }
-
-
-    @Override
-    public void cleanSubject(MessageInfo messageInfo, Subject subject) throws AuthException {
-        module.cleanSubject(messageInfo, subject);
-    }
-
-
-}

==================================================
DigestAuthModule.java
deleted file mode 100644
index e77629209d..0000000000
--- a/java/org/apache/catalina/authenticator/jaspic/provider/modules/BasicAuthModule.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic.provider.modules;
-
-import java.io.IOException;
-import java.text.MessageFormat;
-import java.util.Map;
-
-import javax.security.auth.Subject;
-import javax.security.auth.callback.Callback;
-import javax.security.auth.callback.CallbackHandler;
-import javax.security.auth.message.AuthException;
-import javax.security.auth.message.AuthStatus;
-import javax.security.auth.message.MessageInfo;
-import javax.security.auth.message.MessagePolicy;
-import javax.security.auth.message.callback.PasswordValidationCallback;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.catalina.Context;
-import org.apache.catalina.authenticator.BasicAuthenticator.BasicCredentials;
-import org.apache.catalina.connector.Request;
-import org.apache.tomcat.util.buf.ByteChunk;
-import org.apache.tomcat.util.buf.MessageBytes;
-
-/**
- * This class implements JASPIC based HTTP BASIC authentication.
- */
-public class BasicAuthModule extends TomcatAuthModule {
-
-    public BasicAuthModule(Context context) {
-        super(context);
-    }
-
-
-    @Override
-    public void initializeModule(MessagePolicy requestPolicy, MessagePolicy responsePolicy,
-            CallbackHandler handler, Map<String, String> options) throws AuthException {
-    }
-
-
-    @Override
-    public AuthStatus validateRequest(MessageInfo messageInfo, Subject clientSubject,
-            Subject serviceSubject) throws AuthException {
-        if (!isMandatory(messageInfo)) {
-            return AuthStatus.SUCCESS;
-        }
-
-        Request request = (Request) messageInfo.getRequestMessage();
-        HttpServletResponse response = (HttpServletResponse) messageInfo.getResponseMessage();
-        MessageBytes authorization = request.getCoyoteRequest().getMimeHeaders()
-                .getValue(AUTHORIZATION_HEADER);
-
-        String realmName = getRealmName();
-
-        if (authorization == null) {
-            return sendUnauthorizedError(response, realmName);
-        }
-
-        authorization.toBytes();
-        ByteChunk authorizationBC = authorization.getByteChunk();
-        BasicCredentials credentials = null;
-        try {
-            credentials = new BasicCredentials(authorizationBC);
-            String username = credentials.getUsername();
-            char[] password = credentials.getPassword().toCharArray();
-
-            PasswordValidationCallback passwordCallback = new PasswordValidationCallback(
-                    clientSubject, username, password);
-            handler.handle(new Callback[] { passwordCallback });
-
-            if (!passwordCallback.getResult()) {
-                return sendUnauthorizedError(response, realmName);
-            }
-            handlePrincipalCallbacks(clientSubject, getPrincipal(passwordCallback));
-            return AuthStatus.SUCCESS;
-        } catch (Exception e) {
-            throw new AuthException(e.getMessage());
-        }
-    }
-
-
-    private AuthStatus sendUnauthorizedError(HttpServletResponse response, String realmName)
-            throws AuthException {
-        String authHeader = MessageFormat.format("Basic realm=\"{0}\"", realmName);
-        response.setHeader(AUTH_HEADER_NAME, authHeader);
-        try {
-            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
-        } catch (IOException e) {
-            throw new AuthException(e.getMessage());
-        }
-        return AuthStatus.SEND_CONTINUE;
-    }
-
-
-}

==================================================
FormAuthModule.java
deleted file mode 100644
index cc9629a3cd..0000000000
--- a/java/org/apache/catalina/authenticator/jaspic/provider/modules/DigestAuthModule.java
+++ /dev/null
@@ -1,388 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic.provider.modules;
-
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.security.Principal;
-import java.text.MessageFormat;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import javax.security.auth.Subject;
-import javax.security.auth.callback.CallbackHandler;
-import javax.security.auth.callback.UnsupportedCallbackException;
-import javax.security.auth.message.AuthException;
-import javax.security.auth.message.AuthStatus;
-import javax.security.auth.message.MessageInfo;
-import javax.security.auth.message.MessagePolicy;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.catalina.Context;
-import org.apache.catalina.Realm;
-import org.apache.catalina.authenticator.DigestAuthenticator.DigestInfo;
-import org.apache.catalina.authenticator.DigestAuthenticator.NonceInfo;
-import org.apache.catalina.connector.Request;
-import org.apache.catalina.util.StandardSessionIdGenerator;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.security.ConcurrentMessageDigest;
-import org.apache.tomcat.util.security.MD5Encoder;
-
-public class DigestAuthModule extends TomcatAuthModule {
-    private static final Log log = LogFactory.getLog(DigestAuthModule.class);
-    /**
-     * Tomcat's DIGEST implementation only supports auth quality of protection.
-     */
-    protected static final String QOP = "auth";
-
-    private CallbackHandler handler;
-
-    private Realm realm;
-
-    /**
-     * List of server nonce values currently being tracked
-     */
-    protected Map<String, NonceInfo> nonces;
-
-    /**
-     * The last timestamp used to generate a nonce. Each nonce should get a
-     * unique timestamp.
-     */
-    protected long lastTimestamp = 0;
-    protected final Object lastTimestampLock = new Object();
-
-    /**
-     * Maximum number of server nonces to keep in the cache. If not specified,
-     * the default value of 1000 is used.
-     */
-    protected int nonceCacheSize = 1000;
-
-    /**
-     * The window size to use to track seen nonce count values for a given
-     * nonce. If not specified, the default of 100 is used.
-     */
-    protected int nonceCountWindowSize = 100;
-
-    /**
-     * Private key.
-     */
-    protected String key = null;
-
-    /**
-     * How long server nonces are valid for in milliseconds. Defaults to 5
-     * minutes.
-     */
-    protected long nonceValidity = 5 * 60 * 1000;
-
-    /**
-     * Opaque string.
-     */
-    protected String opaque;
-
-    /**
-     * Should the URI be validated as required by RFC2617? Can be disabled in
-     * reverse proxies where the proxy has modified the URI.
-     */
-    protected boolean validateUri = true;
-    private StandardSessionIdGenerator sessionIdGenerator;
-
-
-    // ------------------------------------------------------------- Properties
-
-    public DigestAuthModule(Context context) {
-        super(context);
-        this.realm = context.getRealm();
-    }
-
-
-    public int getNonceCountWindowSize() {
-        return nonceCountWindowSize;
-    }
-
-
-    public void setNonceCountWindowSize(int nonceCountWindowSize) {
-        this.nonceCountWindowSize = nonceCountWindowSize;
-    }
-
-
-    public int getNonceCacheSize() {
-        return nonceCacheSize;
-    }
-
-
-    public void setNonceCacheSize(int nonceCacheSize) {
-        this.nonceCacheSize = nonceCacheSize;
-    }
-
-
-    public String getKey() {
-        return key;
-    }
-
-
-    public void setKey(String key) {
-        this.key = key;
-    }
-
-
-    public long getNonceValidity() {
-        return nonceValidity;
-    }
-
-
-    public void setNonceValidity(long nonceValidity) {
-        this.nonceValidity = nonceValidity;
-    }
-
-
-    public String getOpaque() {
-        return opaque;
-    }
-
-
-    public void setOpaque(String opaque) {
-        this.opaque = opaque;
-    }
-
-
-    public boolean isValidateUri() {
-        return validateUri;
-    }
-
-
-    public void setValidateUri(boolean validateUri) {
-        this.validateUri = validateUri;
-    }
-
-
-    public void setRealm(Realm realm) {
-        this.realm = realm;
-    }
-
-
-    @Override
-    public synchronized void initializeModule(MessagePolicy requestPolicy, MessagePolicy responsePolicy,
-            CallbackHandler handler, Map<String, String> options) throws AuthException {
-        this.handler = handler;
-        this.sessionIdGenerator = new StandardSessionIdGenerator();
-
-        // Get properties from options
-        this.key = options.get("key");
-        String nonceCacheSizeValue = options.get("nonceCacheSize");
-        if (nonceCacheSizeValue != null) {
-            this.nonceCacheSize = Integer.parseInt(nonceCacheSizeValue);
-        }
-        String nonceCountWindowSizeValue = options.get("nonceCountWindowSize");
-        if (nonceCountWindowSizeValue != null) {
-            this.nonceCountWindowSize = Integer.parseInt(nonceCountWindowSizeValue);
-        }
-        String nonceValidityValue = options.get("nonceValidity");
-        if (nonceValidityValue != null) {
-            this.nonceValidity = Long.parseLong(nonceValidityValue);
-        }
-        this.opaque = options.get("opaque");
-        String validateUriValue = options.get("validateUri");
-        if (validateUriValue != null) {
-            this.validateUri = Boolean.parseBoolean(validateUriValue);
-        }
-
-        // Generate a random secret key
-        if (getKey() == null) {
-            setKey(sessionIdGenerator.generateSessionId());
-        }
-
-        // Generate the opaque string the same way
-        if (getOpaque() == null) {
-            setOpaque(sessionIdGenerator.generateSessionId());
-        }
-
-        nonces = new LinkedHashMap<String, NonceInfo>() {
-
-            private static final long serialVersionUID = 1L;
-            private static final long LOG_SUPPRESS_TIME = 5 * 60 * 1000;
-
-            private long lastLog = 0;
-
-            @Override
-            protected boolean removeEldestEntry(Map.Entry<String, NonceInfo> eldest) {
-                // This is called from a sync so keep it simple
-                long currentTime = System.currentTimeMillis();
-                if (size() > getNonceCacheSize()) {
-                    if (lastLog < currentTime
-                            && currentTime - eldest.getValue().getTimestamp() < getNonceValidity()) {
-                        // Replay attack is possible
-                        log.warn(sm.getString("digestAuthenticator.cacheRemove"));
-                        lastLog = currentTime + LOG_SUPPRESS_TIME;
-                    }
-                    return true;
-                }
-                return false;
-            }
-        };
-    }
-
-
-    @Override
-    public AuthStatus validateRequest(MessageInfo messageInfo, Subject clientSubject,
-            Subject serviceSubject) throws AuthException {
-
-        Principal principal = null;
-        Request request = (Request) messageInfo.getRequestMessage();
-        HttpServletResponse response = (HttpServletResponse) messageInfo.getResponseMessage();
-        String authorization = request.getHeader(AUTHORIZATION_HEADER);
-
-        DigestInfo digestInfo = new DigestInfo(getOpaque(), getNonceValidity(), getKey(), nonces,
-                isValidateUri());
-
-        if (authorization == null || !digestInfo.parse(request, authorization)) {
-            String nonce = generateNonce(request);
-            String authenticateHeader = getAuthenticateHeader(nonce, false);
-            return sendUnauthorizedError(response, authenticateHeader);
-        }
-
-        if (digestInfo.validate(request)) {
-            // FIXME: maybe use a custom callback handler instead
-            principal = digestInfo.authenticate(realm);
-        }
-
-        if (principal == null || digestInfo.isNonceStale()) {
-            String nonce = generateNonce(request);
-            boolean isNoncaneStale = principal != null && digestInfo.isNonceStale();
-            String authenticateHeader = getAuthenticateHeader(nonce, isNoncaneStale);
-            return sendUnauthorizedError(response, authenticateHeader);
-        }
-
-        try {
-            handlePrincipalCallbacks(clientSubject, principal);
-        } catch (IOException | UnsupportedCallbackException e) {
-            throw new AuthException(e.getMessage());
-        }
-        return AuthStatus.SUCCESS;
-    }
-
-
-    private AuthStatus sendUnauthorizedError(HttpServletResponse response, String authenticateHeader)
-            throws AuthException {
-        response.setHeader(AUTH_HEADER_NAME, authenticateHeader);
-        try {
-            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
-        } catch (IOException e) {
-            throw new AuthException(e.getMessage());
-        }
-        return AuthStatus.SEND_CONTINUE;
-    }
-
-
-    /**
-     * Removes the quotes on a string. RFC2617 states quotes are optional for
-     * all parameters except realm.
-     */
-    protected static String removeQuotes(String quotedString, boolean quotesRequired) {
-        // support both quoted and non-quoted
-        if (quotedString.length() > 0 && quotedString.charAt(0) != '"' && !quotesRequired) {
-            return quotedString;
-        } else if (quotedString.length() > 2) {
-            return quotedString.substring(1, quotedString.length() - 1);
-        } else {
-            return "";
-        }
-    }
-
-
-    /**
-     * Removes the quotes on a string.
-     */
-    protected static String removeQuotes(String quotedString) {
-        return removeQuotes(quotedString, false);
-    }
-
-
-    /**
-     * Generate a unique token. The token is generated according to the
-     * following pattern. NOnceToken = Base64 ( MD5 ( client-IP ":" time-stamp
-     * ":" private-key ) ).
-     *
-     * @param request HTTP Servlet request
-     */
-    protected String generateNonce(HttpServletRequest request) {
-
-        long currentTime = System.currentTimeMillis();
-
-        synchronized (lastTimestampLock) {
-            if (currentTime > lastTimestamp) {
-                lastTimestamp = currentTime;
-            } else {
-                currentTime = ++lastTimestamp;
-            }
-        }
-
-        String ipTimeKey = request.getRemoteAddr() + ":" + currentTime + ":" + getKey();
-
-        byte[] buffer = ConcurrentMessageDigest.digestMD5(ipTimeKey
-                .getBytes(StandardCharsets.ISO_8859_1));
-        String nonce = currentTime + ":" + MD5Encoder.encode(buffer);
-
-        NonceInfo info = new NonceInfo(currentTime, getNonceCountWindowSize());
-        synchronized (nonces) {
-            nonces.put(nonce, info);
-        }
-
-        return nonce;
-    }
-
-
-    /**
-     * Generates the WWW-Authenticate header.
-     * <p>
-     * The header MUST follow this template :
-     *
-     * <pre>
-     *      WWW-Authenticate    = "WWW-Authenticate" ":" "Digest"
-     *                            digest-challenge
-     *
-     *      digest-challenge    = 1#( realm | [ domain ] | nonce |
-     *                  [ digest-opaque ] |[ stale ] | [ algorithm ] )
-     *      realm               = "realm" "=" realm-value
-     *      realm-value         = quoted-string
-     *      domain              = "domain" "=" &lt;"&gt; 1#URI &lt;"&gt;
-     *      nonce               = "nonce" "=" nonce-value
-     *      nonce-value         = quoted-string
-     *      opaque              = "opaque" "=" quoted-string
-     *      stale               = "stale" "=" ( "true" | "false" )
-     *      algorithm           = "algorithm" "=" ( "MD5" | token )
-     * </pre>
-     *
-     * @param nonce nonce token
-     * @return
-     */
-    protected String getAuthenticateHeader(String nonce, boolean isNonceStale) {
-
-        String realmName = getRealmName();
-
-        String template = "Digest realm=\"{0}\", qop=\"{1}\", nonce=\"{2}\", opaque=\"{3}\"";
-        String authenticateHeader = MessageFormat.format(template, realmName, QOP, nonce,
-                getOpaque());
-        if (!isNonceStale) {
-            return authenticateHeader;
-        }
-        return authenticateHeader + ", stale=true";
-    }
-
-
-}

==================================================
NonLoginAuthModule.java
deleted file mode 100644
index 809a9d79b1..0000000000
--- a/java/org/apache/catalina/authenticator/jaspic/provider/modules/LocalStrings.properties
+++ /dev/null
@@ -1,37 +0,0 @@
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-authenticator.certificates=No client certificate chain in this request
-authenticator.formlogin=Invalid direct reference to form login page
-authenticator.loginFail=Login failed
-authenticator.manager=Exception initializing trust managers
-authenticator.noAuthHeader=No authorization header sent by client
-authenticator.notContext=Configuration error:  Must be attached to a Context
-authenticator.requestBodyTooBig=The request body was too large to be cached during the authentication process
-authenticator.sessionExpired=The time allowed for the login process has been exceeded. If you wish to continue you must either click back twice and re-click the link you requested or close and re-open your browser
-authenticator.unauthorized=Cannot authenticate with the provided credentials
-
-digestAuthenticator.cacheRemove=A valid entry has been removed from client nonce cache to make room for new entries. A replay attack is now possible. To prevent the possibility of replay attacks, reduce nonceValidity or increase cnonceCacheSize. Further warnings of this type will be suppressed for 5 minutes.
-
-formAuthenticator.forwardErrorFail=Unexpected error forwarding to error page
-formAuthenticator.forwardLogin=Forwarding request for [{0}] made with method [{1}] to login page [{2}] of context [{3}] using request method GET
-formAuthenticator.forwardLoginFail=Unexpected error forwarding to login page
-formAuthenticator.noErrorPage=No error page was defined for FORM authentication in context [{0}]
-formAuthenticator.noLoginPage=No login page was defined for FORM authentication in context [{0}]
-
-spnegoAuthenticator.authHeaderNoToken=The Negotiate authorization header sent by the client did not include a token
-spnegoAuthenticator.authHeaderNotNego=The authorization header sent by the client did not start with Negotiate
-spnegoAuthenticator.serviceLoginFail=Unable to login as the service principal
-spnegoAuthenticator.ticketValidateFail=Failed to validate client supplied ticket

==================================================
SSLAuthModule.java
deleted file mode 100644
index 1c390d9113..0000000000
--- a/java/org/apache/catalina/authenticator/jaspic/provider/modules/NonLoginAuthModule.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic.provider.modules;
-
-import java.util.Map;
-
-import javax.security.auth.Subject;
-import javax.security.auth.callback.CallbackHandler;
-import javax.security.auth.message.AuthException;
-import javax.security.auth.message.AuthStatus;
-import javax.security.auth.message.MessageInfo;
-import javax.security.auth.message.MessagePolicy;
-
-import org.apache.catalina.Context;
-
-public class NonLoginAuthModule extends TomcatAuthModule {
-
-    public NonLoginAuthModule(Context context) {
-        super(context);
-    }
-
-
-    @Override
-    public void initializeModule(MessagePolicy requestPolicy, MessagePolicy responsePolicy,
-            CallbackHandler handler, Map<String, String> options) throws AuthException {
-    }
-
-
-    @Override
-    public AuthStatus validateRequest(MessageInfo messageInfo, Subject clientSubject,
-            Subject serviceSubject) throws AuthException {
-        return AuthStatus.SUCCESS;
-    }
-
-}

==================================================
SpnegoAuthModule.java
deleted file mode 100644
index 2af7996a7a..0000000000
--- a/java/org/apache/catalina/authenticator/jaspic/provider/modules/SSLAuthModule.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic.provider.modules;
-
-import java.security.Principal;
-import java.security.cert.X509Certificate;
-import java.util.Map;
-
-import javax.security.auth.Subject;
-import javax.security.auth.callback.CallbackHandler;
-import javax.security.auth.message.AuthException;
-import javax.security.auth.message.AuthStatus;
-import javax.security.auth.message.MessageInfo;
-import javax.security.auth.message.MessagePolicy;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.catalina.Context;
-import org.apache.catalina.Globals;
-import org.apache.catalina.connector.Request;
-import org.apache.coyote.ActionCode;
-
-/**
- * This class implements JASPIC based HTTP BASIC authentication.
- */
-public class SSLAuthModule extends TomcatAuthModule {
-
-    public SSLAuthModule(Context context) {
-        super(context);
-    }
-
-
-    @Override
-    public void initializeModule(MessagePolicy requestPolicy, MessagePolicy responsePolicy,
-            CallbackHandler handler, Map<String, String> options) throws AuthException {
-    }
-
-
-    @Override
-    public AuthStatus validateRequest(MessageInfo messageInfo, Subject clientSubject,
-            Subject serviceSubject) throws AuthException {
-        if (!isMandatory(messageInfo)) {
-            return AuthStatus.SUCCESS;
-        }
-
-        Request request = (Request) messageInfo.getRequestMessage();
-        HttpServletResponse response = (HttpServletResponse) messageInfo.getResponseMessage();
-        try {
-            X509Certificate certs[] = getRequestCertificates(request);
-
-            if ((certs == null) || (certs.length < 1)) {
-                response.sendError(HttpServletResponse.SC_UNAUTHORIZED,
-                        sm.getString("authenticator.certificates"));
-                return AuthStatus.FAILURE;
-            }
-
-            // Authenticate the specified certificate chain
-            Principal principal = context.getRealm().authenticate(certs);
-            if (principal == null) {
-                response.sendError(HttpServletResponse.SC_UNAUTHORIZED,
-                        sm.getString("authenticator.unauthorized"));
-                return AuthStatus.FAILURE;
-            }
-            handlePrincipalCallbacks(clientSubject, principal);
-            return AuthStatus.SUCCESS;
-        } catch (Exception e) {
-            throw new AuthException(e.getMessage());
-        }
-
-    }
-
-
-    /**
-     * Look for the X509 certificate chain in the Request under the key
-     * <code>javax.servlet.request.X509Certificate</code>. If not found, trigger
-     * extracting the certificate chain from the Coyote request.
-     *
-     * @param request   Request to be processed
-     *
-     * @return          The X509 certificate chain if found, <code>null</code>
-     *                  otherwise.
-     */
-    protected X509Certificate[] getRequestCertificates(final Request request)
-            throws IllegalStateException {
-
-        X509Certificate certs[] =
-                (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR);
-
-        if ((certs == null) || (certs.length < 1)) {
-            try {
-                request.getCoyoteRequest().action(ActionCode.REQ_SSL_CERTIFICATE, null);
-                certs = (X509Certificate[]) request.getAttribute(Globals.CERTIFICATES_ATTR);
-            } catch (IllegalStateException ise) {
-                // Request body was too large for save buffer
-                // Return null which will trigger an auth failure
-            }
-        }
-
-        return certs;
-    }
-
-}

==================================================
TomcatAuthModule.java
deleted file mode 100644
index 5301a943a2..0000000000
--- a/java/org/apache/catalina/authenticator/jaspic/provider/modules/SpnegoAuthModule.java
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic.provider.modules;
-
-import java.io.File;
-import java.io.IOException;
-import java.security.Principal;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
-import java.util.Map;
-import java.util.regex.Pattern;
-
-import javax.security.auth.Subject;
-import javax.security.auth.callback.CallbackHandler;
-import javax.security.auth.callback.UnsupportedCallbackException;
-import javax.security.auth.login.LoginContext;
-import javax.security.auth.login.LoginException;
-import javax.security.auth.message.AuthException;
-import javax.security.auth.message.AuthStatus;
-import javax.security.auth.message.MessageInfo;
-import javax.security.auth.message.MessagePolicy;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.catalina.Context;
-import org.apache.catalina.authenticator.Constants;
-import org.apache.catalina.authenticator.SpnegoAuthenticator.AcceptAction;
-import org.apache.catalina.authenticator.SpnegoAuthenticator.AuthenticateAction;
-import org.apache.catalina.authenticator.SpnegoAuthenticator.SpnegoTokenFixer;
-import org.apache.catalina.connector.Request;
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.apache.tomcat.util.buf.ByteChunk;
-import org.apache.tomcat.util.buf.MessageBytes;
-import org.apache.tomcat.util.codec.binary.Base64;
-import org.apache.tomcat.util.compat.JreVendor;
-import org.ietf.jgss.GSSContext;
-import org.ietf.jgss.GSSCredential;
-import org.ietf.jgss.GSSException;
-import org.ietf.jgss.GSSManager;
-import org.ietf.jgss.Oid;
-
-/**
- * A SPNEGO authenticator that uses the SPNEGO/Kerberos support built in to Java
- * 6. Successful Kerberos authentication depends on the correct configuration of
- * multiple components. If the configuration is invalid, the error messages are
- * often cryptic although a Google search will usually point you in the right
- * direction.
- */
-public class SpnegoAuthModule extends TomcatAuthModule {
-    private static final Log log = LogFactory.getLog(SpnegoAuthModule.class);
-
-    private String loginConfigName = Constants.DEFAULT_LOGIN_MODULE_NAME;
-    private boolean storeDelegatedCredential = true;
-    private Pattern noKeepAliveUserAgents = null;
-    private boolean applyJava8u40Fix = true;
-
-    @Override
-    public void initializeModule(MessagePolicy requestPolicy, MessagePolicy responsePolicy,
-            CallbackHandler handler, Map<String, String> options) throws AuthException {
-        this.loginConfigName = options.getOrDefault("loginConfigName", Constants.DEFAULT_LOGIN_MODULE_NAME);
-        this.storeDelegatedCredential = Boolean.parseBoolean(options.getOrDefault("storeDelegatedCredential", Boolean.TRUE.toString()));
-        this.noKeepAliveUserAgents = compilePattern(options.get("noKeepAliveUserAgents"));
-        this.applyJava8u40Fix = Boolean.parseBoolean(options.getOrDefault("applyJava8u40Fix", Boolean.TRUE.toString()));
-
-        configureKerberosFileLocation();
-        configureJaasFileLocation();
-    }
-
-
-    private Pattern compilePattern(String noKeepAliveUserAgents) {
-        if (noKeepAliveUserAgents == null || noKeepAliveUserAgents.length() == 0) {
-            return null;
-        }
-        return Pattern.compile(noKeepAliveUserAgents);
-    }
-
-
-    private void configureKerberosFileLocation() {
-        String krb5Conf = System.getProperty(Constants.KRB5_CONF_PROPERTY);
-        if (krb5Conf == null) {
-            File configFile = new File(context.getCatalinaBase(), Constants.DEFAULT_KRB5_CONF);
-            System.setProperty(Constants.KRB5_CONF_PROPERTY, configFile.getAbsolutePath());
-        }
-    }
-
-
-    private void configureJaasFileLocation() {
-        String jaasConf = System.getProperty(Constants.JAAS_CONF_PROPERTY);
-        if (jaasConf == null) {
-            File configFile = new File(context.getCatalinaBase(), Constants.DEFAULT_JAAS_CONF);
-            System.setProperty(Constants.JAAS_CONF_PROPERTY, configFile.getAbsolutePath());
-        }
-    }
-
-
-    public SpnegoAuthModule(Context context) {
-        super(context);
-    }
-
-
-    @Override
-    public AuthStatus validateRequest(MessageInfo messageInfo, Subject clientSubject,
-            Subject serviceSubject) throws AuthException {
-        try {
-            return validate(messageInfo, clientSubject);
-        } catch (IOException e) {
-            throw new AuthException(e.getMessage());
-        }
-    }
-
-
-    private AuthStatus validate(MessageInfo messageInfo, Subject clientSubject) throws IOException {
-        Request request = (Request) messageInfo.getRequestMessage();
-        HttpServletResponse response = (HttpServletResponse) messageInfo.getResponseMessage();
-
-        MessageBytes authorization =
-                request.getCoyoteRequest().getMimeHeaders()
-                .getValue("authorization");
-
-            if (authorization == null) {
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("authenticator.noAuthHeader"));
-                }
-                response.setHeader("WWW-Authenticate", "Negotiate");
-                response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
-                return AuthStatus.SEND_FAILURE;
-            }
-
-            authorization.toBytes();
-            ByteChunk authorizationBC = authorization.getByteChunk();
-
-            if (!authorizationBC.startsWithIgnoreCase("negotiate ", 0)) {
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString(
-                            "spnegoAuthenticator.authHeaderNotNego"));
-                }
-                response.setHeader("WWW-Authenticate", "Negotiate");
-                response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
-                return AuthStatus.SEND_FAILURE;
-            }
-
-            authorizationBC.setOffset(authorizationBC.getOffset() + 10);
-
-            byte[] decoded = Base64.decodeBase64(authorizationBC.getBuffer(),
-                    authorizationBC.getOffset(),
-                    authorizationBC.getLength());
-
-            if (applyJava8u40Fix) {
-                SpnegoTokenFixer.fix(decoded);
-            }
-
-            if (decoded.length == 0) {
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString(
-                            "spnegoAuthenticator.authHeaderNoToken"));
-                }
-                response.setHeader("WWW-Authenticate", "Negotiate");
-                response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
-                return AuthStatus.SEND_FAILURE;
-            }
-
-            LoginContext lc = null;
-            GSSContext gssContext = null;
-            byte[] outToken = null;
-            Principal principal = null;
-            try {
-                try {
-                    lc = new LoginContext(loginConfigName);
-                    lc.login();
-                } catch (LoginException e) {
-                    log.error(sm.getString("spnegoAuthenticator.serviceLoginFail"),
-                            e);
-                    response.sendError(
-                            HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
-                    return AuthStatus.FAILURE;
-                }
-
-                Subject subject = lc.getSubject();
-
-                // Assume the GSSContext is stateless
-                // TODO: Confirm this assumption
-                final GSSManager manager = GSSManager.getInstance();
-                // IBM JDK only understands indefinite lifetime
-                final int credentialLifetime;
-                if (JreVendor.IS_IBM_JVM) {
-                    credentialLifetime = GSSCredential.INDEFINITE_LIFETIME;
-                } else {
-                    credentialLifetime = GSSCredential.DEFAULT_LIFETIME;
-                }
-                final PrivilegedExceptionAction<GSSCredential> action =
-                    new PrivilegedExceptionAction<GSSCredential>() {
-                        @Override
-                        public GSSCredential run() throws GSSException {
-                            return manager.createCredential(null,
-                                    credentialLifetime,
-                                    new Oid("1.3.6.1.5.5.2"),
-                                    GSSCredential.ACCEPT_ONLY);
-                        }
-                    };
-                gssContext = manager.createContext(Subject.doAs(subject, action));
-
-                outToken = Subject.doAs(lc.getSubject(), new AcceptAction(gssContext, decoded));
-
-                if (outToken == null) {
-                    if (log.isDebugEnabled()) {
-                        log.debug(sm.getString(
-                                "spnegoAuthenticator.ticketValidateFail"));
-                    }
-                    // Start again
-                    response.setHeader("WWW-Authenticate", "Negotiate");
-                    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
-                    return AuthStatus.SEND_FAILURE;
-                }
-
-                principal = Subject.doAs(subject, new AuthenticateAction(
-                        context.getRealm(), gssContext, storeDelegatedCredential));
-
-            } catch (GSSException e) {
-                if (log.isDebugEnabled()) {
-                    log.debug(sm.getString("spnegoAuthenticator.ticketValidateFail"), e);
-                }
-                response.setHeader("WWW-Authenticate", "Negotiate");
-                response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
-                return AuthStatus.FAILURE;
-            } catch (PrivilegedActionException e) {
-                Throwable cause = e.getCause();
-                if (cause instanceof GSSException) {
-                    if (log.isDebugEnabled()) {
-                        log.debug(sm.getString("spnegoAuthenticator.serviceLoginFail"), e);
-                    }
-                } else {
-                    log.error(sm.getString("spnegoAuthenticator.serviceLoginFail"), e);
-                }
-                response.setHeader("WWW-Authenticate", "Negotiate");
-                response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
-                return AuthStatus.FAILURE;
-            } finally {
-                if (gssContext != null) {
-                    try {
-                        gssContext.dispose();
-                    } catch (GSSException e) {
-                        // Ignore
-                    }
-                }
-                if (lc != null) {
-                    try {
-                        lc.logout();
-                    } catch (LoginException e) {
-                        // Ignore
-                    }
-                }
-            }
-
-            // Send response token on success and failure
-            response.setHeader("WWW-Authenticate", "Negotiate "
-                    + Base64.encodeBase64String(outToken));
-
-            if (principal != null) {
-                try {
-                    handlePrincipalCallbacks(clientSubject, principal);
-                } catch (IOException | UnsupportedCallbackException e) {
-                    // TODO Auto-generated catch block
-                    e.printStackTrace();
-                }
-
-                Pattern p = noKeepAliveUserAgents;
-                if (p != null) {
-                    MessageBytes ua =
-                            request.getCoyoteRequest().getMimeHeaders().getValue(
-                                    "user-agent");
-                    if (ua != null && p.matcher(ua.toString()).matches()) {
-                        response.setHeader("Connection", "close");
-                    }
-                }
-                return AuthStatus.SUCCESS;
-            }
-
-            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
-            return AuthStatus.FAILURE;
-    }
-
-
-    @Override
-    public AuthStatus secureResponse(MessageInfo messageInfo, Subject serviceSubject)
-            throws AuthException {
-        return null;
-    }
-
-
-    @Override
-    public void cleanSubject(MessageInfo messageInfo, Subject subject) throws AuthException {
-
-    }
-
-
-}

==================================================
ContextConfig.java
deleted file mode 100644
index 6c4c5685c4..0000000000
--- a/java/org/apache/catalina/authenticator/jaspic/provider/modules/TomcatAuthModule.java
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic.provider.modules;
-
-import java.io.IOException;
-import java.security.Principal;
-import java.util.Iterator;
-import java.util.Map;
-
-import javax.security.auth.Subject;
-import javax.security.auth.callback.Callback;
-import javax.security.auth.callback.CallbackHandler;
-import javax.security.auth.callback.UnsupportedCallbackException;
-import javax.security.auth.message.AuthException;
-import javax.security.auth.message.AuthStatus;
-import javax.security.auth.message.MessageInfo;
-import javax.security.auth.message.MessagePolicy;
-import javax.security.auth.message.callback.CallerPrincipalCallback;
-import javax.security.auth.message.callback.GroupPrincipalCallback;
-import javax.security.auth.message.callback.PasswordValidationCallback;
-import javax.security.auth.message.module.ServerAuthModule;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.catalina.Context;
-import org.apache.catalina.authenticator.jaspic.MessageInfoImpl;
-import org.apache.catalina.connector.Request;
-import org.apache.catalina.realm.GenericPrincipal;
-import org.apache.tomcat.util.res.StringManager;
-
-/**
- * Base class for JASPIC authentication modules.
- */
-public abstract class TomcatAuthModule implements ServerAuthModule {
-
-    public static final String REALM_NAME = "javax.servlet.http.realmName";
-    public static final String DEFAULT_REALM_NAME = "Authentication required";
-
-    protected static final String AUTH_HEADER_NAME = "WWW-Authenticate";
-    protected static final String AUTHORIZATION_HEADER = "authorization";
-
-    /**
-     * The string manager for this package.
-     */
-    protected static final StringManager sm = StringManager.getManager(TomcatAuthModule.class);
-
-    private Class<?>[] supportedMessageTypes = new Class[] { Request.class,
-            HttpServletResponse.class };
-
-    protected String realmName = DEFAULT_REALM_NAME;
-
-    protected CallbackHandler handler;
-
-    protected Context context;
-
-    protected boolean cache = true;
-    protected boolean changeSessionIdOnAuthentication = true;
-
-
-    public TomcatAuthModule(Context context) {
-        this.context = context;
-    }
-
-
-    protected boolean isMandatory(MessageInfo messageInfo) {
-        String mandatory = (String) messageInfo.getMap().get(MessageInfoImpl.IS_MANDATORY);
-        return Boolean.parseBoolean(mandatory);
-    }
-
-
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    @Override
-    public final void initialize(MessagePolicy requestPolicy, MessagePolicy responsePolicy,
-            CallbackHandler handler, Map options) throws AuthException {
-        this.handler = handler;
-        this.cache = (Boolean.parseBoolean((String) options.get("cache")));
-        this.changeSessionIdOnAuthentication = Boolean.parseBoolean((String) options.get("changeSessionIdOnAuthentication"));
-        String name = (String) options.get(REALM_NAME);
-        if (name != null) {
-            this.realmName = name;
-        }
-        initializeModule(requestPolicy, responsePolicy, handler, options);
-    }
-
-
-    public String getRealmName() {
-        return realmName;
-    }
-
-
-    /**
-     * Every subclass must extend this method in order to be initialized.
-     * Firstly, we initialize abstract module, then subclasses.
-     *
-     * @param requestPolicy
-     * @param responsePolicy
-     * @param handler
-     * @param options
-     * @throws AuthException
-     */
-    public abstract void initializeModule(MessagePolicy requestPolicy,
-            MessagePolicy responsePolicy, CallbackHandler handler, Map<String, String> options)
-            throws AuthException;
-
-
-    /**
-     * Convert Tomcat's principal to JAAS subject using JASPIC callbacks
-     *
-     * @param clientSubject
-     * @param principal
-     * @throws IOException
-     * @throws UnsupportedCallbackException
-     */
-    protected void handlePrincipalCallbacks(Subject clientSubject, Principal principal)
-            throws IOException, UnsupportedCallbackException {
-        CallerPrincipalCallback principalCallback = new CallerPrincipalCallback(clientSubject,
-                principal);
-        String[] roles = context.getRealm().getRoles(principal);
-        GroupPrincipalCallback groupCallback = new GroupPrincipalCallback(clientSubject, roles);
-        handler.handle(new Callback[] { principalCallback, groupCallback });
-    }
-
-    protected GenericPrincipal getPrincipal(PasswordValidationCallback passwordCallback) {
-        Iterator<Object> credentials = passwordCallback.getSubject().getPrivateCredentials()
-                .iterator();
-        return (GenericPrincipal) credentials.next();
-    }
-
-
-    @Override
-    public Class<?>[] getSupportedMessageTypes() {
-        return supportedMessageTypes;
-    }
-
-    @Override
-    public AuthStatus secureResponse(MessageInfo messageInfo, Subject serviceSubject)
-            throws AuthException {
-        return null;
-    }
-
-
-    @Override
-    public void cleanSubject(MessageInfo messageInfo, Subject subject) throws AuthException {
-    }
-
-}

==================================================
TestJaspicBasicAuthenticator.java
index 03d5004ec7..feb5c035b9 100644
--- a/java/org/apache/catalina/startup/ContextConfig.java
+++ b/java/org/apache/catalina/startup/ContextConfig.java
@@ -39,7 +39,6 @@ import java.util.Properties;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
-import javax.security.auth.message.config.AuthConfigFactory;
 import javax.servlet.MultipartConfigElement;
 import javax.servlet.ServletContainerInitializer;
 import javax.servlet.ServletContext;
@@ -62,8 +61,6 @@ import org.apache.catalina.Valve;
 import org.apache.catalina.WebResource;
 import org.apache.catalina.WebResourceRoot;
 import org.apache.catalina.Wrapper;
-import org.apache.catalina.authenticator.jaspic.JaspicAuthenticator;
-import org.apache.catalina.authenticator.jaspic.provider.TomcatAuthConfigProvider;
 import org.apache.catalina.core.StandardContext;
 import org.apache.catalina.core.StandardHost;
 import org.apache.catalina.util.ContextName;
@@ -388,15 +385,7 @@ public class ContextConfig implements LifecycleListener {
          */
         Valve authenticator = null;
         if (customAuthenticators != null) {
-            authenticator = (Valve)
-                customAuthenticators.get(loginConfig.getAuthMethod());
-        }
-
-        if (authenticator == null) {
-            String authMethod = loginConfig.getAuthMethod();
-            if (authMethod != null && authMethod.contains("JASPIC")) {
-                authenticator = new JaspicAuthenticator();
-            }
+            authenticator = (Valve) customAuthenticators.get(loginConfig.getAuthMethod());
         }
 
         if (authenticator == null) {
@@ -443,24 +432,6 @@ public class ContextConfig implements LifecycleListener {
     }
 
 
-    /**
-     * Configure and register default JASPIC modules
-     */
-    private void configureDefaultJaspicAuthModules() {
-        if (!(context.getAuthenticator() instanceof JaspicAuthenticator)) {
-            return;
-        }
-        // TODO currently we setup default provider if we have
-        // JaspicAuthenicator registred.
-        // we need to find a better way to decide, if we want embedded provider
-        // or not
-        JaspicAuthenticator authenticator = (JaspicAuthenticator) context.getAuthenticator();
-        AuthConfigFactory authConfigFactory = AuthConfigFactory.getFactory();
-        TomcatAuthConfigProvider provider = new TomcatAuthConfigProvider(context, authenticator.getAuthProperties());
-        authConfigFactory.registerConfigProvider(provider, JaspicAuthenticator.MESSAGE_LAYER,
-                authenticator.getAppContext(), "Apache Tomcat JASPIC");
-    }
-
     /**
      * Create (if necessary) and return a Digester configured to process the
      * context configuration descriptor for an application.
@@ -806,7 +777,6 @@ public class ContextConfig implements LifecycleListener {
         // Configure an authenticator if we need one
         if (ok) {
             authenticatorConfig();
-            configureDefaultJaspicAuthModules();
         }
 
         // Dump the contents of this pipeline if requested

==================================================
TestJaspicDigestAuthenticator.java
deleted file mode 100644
index 873956b138..0000000000
--- a/test/org/apache/catalina/authenticator/TestJaspicBasicAuthenticator.java
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.catalina.authenticator;
-
-import java.io.IOException;
-import java.text.MessageFormat;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import javax.security.auth.message.config.AuthConfigFactory;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-
-import org.junit.Test;
-
-import org.apache.catalina.Context;
-import org.apache.catalina.authenticator.jaspic.JaspicAuthenticator;
-import org.apache.catalina.authenticator.jaspic.provider.TomcatAuthConfigProvider;
-import org.apache.catalina.startup.TesterMapRealm;
-import org.apache.catalina.startup.TesterServlet;
-import org.apache.catalina.startup.Tomcat;
-import org.apache.catalina.startup.TomcatBaseTest;
-import org.apache.tomcat.util.buf.ByteChunk;
-import org.apache.tomcat.util.codec.binary.Base64;
-import org.apache.tomcat.util.descriptor.web.LoginConfig;
-import org.apache.tomcat.util.descriptor.web.SecurityCollection;
-import org.apache.tomcat.util.descriptor.web.SecurityConstraint;
-
-public class TestJaspicBasicAuthenticator extends TomcatBaseTest {
-
-    private static final String AUTH_METHOD = "JASPIC-BASIC";
-    private static final String USER = "user";
-    private static final String PASSWORD = "password";
-
-    private static final String ROLE = "role";
-    private static final String URI = "/protected";
-    private static final String REALM = "TestRealm";
-
-    private static final String WWW_AUTHENTICATE = "WWW-Authenticate";
-    private static final String CLIENT_AUTH_HEADER = "Authorization";
-
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-
-        Tomcat tomcat = getTomcatInstance();
-        Context ctxt = tomcat.addContext("", null);
-
-        // Add protected servlet
-        Tomcat.addServlet(ctxt, "TesterServlet", new TesterServlet());
-        ctxt.addServletMapping(URI, "TesterServlet");
-        SecurityCollection collection = new SecurityCollection();
-        collection.addPattern(URI);
-        SecurityConstraint sc = new SecurityConstraint();
-        sc.addAuthRole(ROLE);
-        sc.addCollection(collection);
-        ctxt.addConstraint(sc);
-
-        // Configure the Realm
-        TesterMapRealm realm = new TesterMapRealm();
-        realm.addUser(USER, PASSWORD);
-        realm.addUserRole(USER, ROLE);
-        ctxt.setRealm(realm);
-
-        // Configure the authenticator
-        LoginConfig lc = new LoginConfig();
-        lc.setAuthMethod(AUTH_METHOD);
-        lc.setRealmName(REALM);
-        ctxt.setLoginConfig(lc);
-
-        JaspicAuthenticator authenticator = new JaspicAuthenticator();
-        ctxt.getPipeline().addValve(authenticator);
-        AuthConfigFactory authConfigFactory = AuthConfigFactory.getFactory();
-        TomcatAuthConfigProvider provider = new TomcatAuthConfigProvider(ctxt, authenticator.getAuthProperties());
-        authConfigFactory.registerConfigProvider(provider, JaspicAuthenticator.MESSAGE_LAYER, null,
-                "Tomcat Jaspic");
-
-        tomcat.start();
-    }
-
-
-    @Test
-    public void shouldFailWithoutAuthenticationHeaders() throws Exception {
-        // given
-        Map<String, List<String>> requestHeaders = new HashMap<>();
-
-        // when
-        ResponseDescriptor response = getLocalhostUrl("/protected", requestHeaders);
-
-        // then
-        assertEquals(401, response.getResponseCode());
-    }
-
-
-    @Test
-    public void shouldReturnCorrectRealmName() throws Exception {
-        // given
-        Map<String, List<String>> requestHeaders = new HashMap<>();
-
-        // when
-        ResponseDescriptor response = getLocalhostUrl("/protected", requestHeaders);
-
-        // then
-        assertEquals(401, response.getResponseCode());
-        List<String> authenitcateHeaders = response.getHeaders().get(WWW_AUTHENTICATE);
-        assertNotNull(authenitcateHeaders);
-
-        String authenticationHeader = authenitcateHeaders.iterator().next();
-        assertNotNull(authenticationHeader);
-
-        //assertThat(authenticationHeader, CoreMatchers.containsString("Basic"));
-        //assertThat(authenticationHeader, CoreMatchers.containsString(REALM));
-    }
-
-
-    @Test
-    public void shouldSuccedOnCorrectAuthenticationHeaders() throws Exception {
-        // given
-        Map<String, List<String>> requestHeaders = new HashMap<>();
-
-        List<String> auth = new ArrayList<>();
-        auth.addAll(getBasicHeaders(USER, PASSWORD));
-        requestHeaders.put(CLIENT_AUTH_HEADER, auth);
-
-        // when
-        ResponseDescriptor response = getLocalhostUrl("/protected", requestHeaders);
-
-        // then
-        assertEquals(200, response.getResponseCode());
-    }
-
-
-    @Test
-    public void shouldFailWithIncorrectCredentials() throws Exception {
-        // given
-        Map<String, List<String>> reqHeaders = new HashMap<>();
-
-        List<String> auth = new ArrayList<>();
-        auth.addAll(getBasicHeaders(USER, "wrong password"));
-        reqHeaders.put(CLIENT_AUTH_HEADER, auth);
-
-        // when
-        ResponseDescriptor response = getLocalhostUrl("/protected", reqHeaders);
-
-        // then
-        assertEquals(401, response.getResponseCode());
-    }
-
-
-    private Collection<String> getBasicHeaders(String username, String password) {
-        List<String> basicHeaders = new ArrayList<>();
-        basicHeaders.add("Basic " + encodeCredentials(username, password));
-        return basicHeaders;
-    }
-
-
-    private String encodeCredentials(String username, String password) {
-        String credentials = MessageFormat.format("{0}:{1}", username, password);
-        return Base64.encodeBase64String(credentials.getBytes());
-    }
-
-
-    private ResponseDescriptor getLocalhostUrl(String url, Map<String, List<String>> requestHeaders)
-            throws IOException {
-        return getUrl("http://localhost:" + getPort() + url, requestHeaders);
-    }
-
-
-    private ResponseDescriptor getUrl(String url, Map<String, List<String>> requestHeaders)
-            throws IOException {
-        ByteChunk out = new ByteChunk();
-        Map<String, List<String>> responseHeaders = new HashMap<>();
-        int responseCode = getUrl(url, out, requestHeaders, responseHeaders);
-
-        ResponseDescriptor testResponse = new ResponseDescriptor();
-        testResponse.setBody(out.toString());
-        testResponse.setResponseCode(responseCode);
-        testResponse.setHeaders(responseHeaders);
-        return testResponse;
-    }
-
-}

==================================================
TestJaspicFormAuthenticator.java
deleted file mode 100644
index 6e82c8c58f..0000000000
--- a/test/org/apache/catalina/authenticator/TestJaspicDigestAuthenticator.java
+++ /dev/null
@@ -1,410 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.catalina.authenticator;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import javax.security.auth.message.config.AuthConfigFactory;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
-import org.junit.Assert;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import org.apache.catalina.Context;
-import org.apache.catalina.LifecycleException;
-import org.apache.catalina.authenticator.jaspic.JaspicAuthenticator;
-import org.apache.catalina.authenticator.jaspic.provider.TomcatAuthConfigProvider;
-import org.apache.catalina.connector.Request;
-import org.apache.catalina.startup.TesterMapRealm;
-import org.apache.catalina.startup.TesterServlet;
-import org.apache.catalina.startup.Tomcat;
-import org.apache.catalina.startup.TomcatBaseTest;
-import org.apache.tomcat.unittest.TesterContext;
-import org.apache.tomcat.util.buf.ByteChunk;
-import org.apache.tomcat.util.descriptor.web.LoginConfig;
-import org.apache.tomcat.util.descriptor.web.SecurityCollection;
-import org.apache.tomcat.util.descriptor.web.SecurityConstraint;
-import org.apache.tomcat.util.security.ConcurrentMessageDigest;
-import org.apache.tomcat.util.security.MD5Encoder;
-
-public class TestJaspicDigestAuthenticator extends TomcatBaseTest {
-
-    private static String USER = "user";
-    private static String PWD = "pwd";
-    private static String ROLE = "role";
-    private static String URI = "/protected";
-    private static String QUERY = "?foo=bar";
-    private static String CONTEXT_PATH = "/foo";
-    private static String CLIENT_AUTH_HEADER = "authorization";
-    private static String REALM = "TestRealm";
-    private static String CNONCE = "cnonce";
-    private static String NC1 = "00000001";
-    private static String NC2 = "00000002";
-    private static String QOP = "auth";
-
-
-    @Test
-    public void bug54521() throws LifecycleException {
-        DigestAuthenticator digestAuthenticator = new DigestAuthenticator();
-        digestAuthenticator.setContainer(new TesterContext());
-        digestAuthenticator.start();
-        Request request = new TesterRequest();
-        final int count = 1000;
-
-        Set<String> nonces = new HashSet<>();
-
-        for (int i = 0; i < count; i++) {
-            nonces.add(digestAuthenticator.generateNonce(request));
-        }
-
-        Assert.assertEquals(count,  nonces.size());
-    }
-
-
-    @Test
-    public void testAllValid() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, false, true, REALM, true, true,
-                NC1, NC2, CNONCE, QOP, true, true);
-    }
-
-    @Test
-    public void testValidNoQop() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, false, true, REALM, true, true,
-                null, null, null, null, true, true);
-    }
-
-    @Test
-    public void testValidQuery() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI + QUERY, false, true, REALM, true,
-                true, NC1, NC2, CNONCE, QOP, true, true);
-    }
-
-    @Test
-    public void testInvalidUriFail() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, true, true, REALM, true, true,
-                NC1, NC2, CNONCE, QOP, false, false);
-    }
-
-    @Test
-    @Ignore("URI validation is not implemented yet")
-    public void testInvalidUriPass() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, true, false, REALM, true, true,
-                NC1, NC2, CNONCE, QOP, true, true);
-    }
-
-    @Test
-    public void testInvalidRealm() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, false, true, "null", true, true,
-                NC1, NC2, CNONCE, QOP, false, false);
-    }
-
-    @Test
-    public void testInvalidNonce() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, false, true, REALM, false, true,
-                NC1, NC2, CNONCE, QOP, false, true);
-    }
-
-    @Test
-    public void testInvalidOpaque() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, false, true, REALM, true, false,
-                NC1, NC2, CNONCE, QOP, false, true);
-    }
-
-    @Test
-    public void testInvalidNc1() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, false, true, REALM, true, true,
-                "null", null, CNONCE, QOP, false, false);
-    }
-
-    @Test
-    public void testInvalidQop() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, false, true, REALM, true, true,
-                NC1, NC2, CNONCE, "null", false, false);
-    }
-
-    @Test
-    public void testInvalidQopCombo1() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, false, true, REALM, true, true,
-                NC1, NC2, CNONCE, null, false, false);
-    }
-
-    @Test
-    public void testInvalidQopCombo2() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, false, true, REALM, true, true,
-                NC1, NC2, null, QOP, false, false);
-    }
-
-    @Test
-    public void testInvalidQopCombo3() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, false, true, REALM, true, true,
-                NC1, NC2, null, null, false, false);
-    }
-
-    @Test
-    public void testInvalidQopCombo4() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, false, true, REALM, true, true,
-                null, null, CNONCE, QOP, false, false);
-    }
-
-    @Test
-    public void testInvalidQopCombo5() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, false, true, REALM, true, true,
-                null, null, CNONCE, null, false, false);
-    }
-
-    @Test
-    public void testInvalidQopCombo6() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, false, true, REALM, true, true,
-                null, null, null, QOP, false, false);
-    }
-
-    @Test
-    public void testReplay() throws Exception {
-        doTest(USER, PWD, CONTEXT_PATH + URI, false, true, REALM, true, true,
-                NC1, NC1, CNONCE, QOP, true, false);
-    }
-
-    public void doTest(String user, String pwd, String uri, boolean breakUri,
-            boolean validateUri, String realm, boolean useServerNonce,
-            boolean useServerOpaque, String nc1, String nc2, String cnonce,
-            String qop, boolean req2expect200, boolean req3expect200)
-            throws Exception {
-
-        if (!validateUri) {
-            DigestAuthenticator auth =
-                (DigestAuthenticator) getTomcatInstance().getHost().findChild(
-                        CONTEXT_PATH).getPipeline().getFirst();
-            auth.setValidateUri(false);
-        }
-        getTomcatInstance().start();
-
-        String digestUri;
-        if (breakUri) {
-            digestUri = "/broken" + uri;
-        } else {
-            digestUri = uri;
-        }
-        List<String> auth = new ArrayList<>();
-        auth.add(buildDigestResponse(user, pwd, digestUri, realm, "null",
-                "null", nc1, cnonce, qop));
-        Map<String,List<String>> reqHeaders = new HashMap<>();
-        reqHeaders.put(CLIENT_AUTH_HEADER, auth);
-
-        Map<String,List<String>> respHeaders = new HashMap<>();
-
-        // The first request will fail - but we need to extract the nonce
-        ByteChunk bc = new ByteChunk();
-        int rc = getUrl("http://localhost:" + getPort() + uri, bc, reqHeaders,
-                respHeaders);
-        assertEquals(401, rc);
-        assertTrue(bc.getLength() > 0);
-        bc.recycle();
-
-        // Second request should succeed (if we use the server nonce)
-        auth.clear();
-        if (useServerNonce) {
-            if (useServerOpaque) {
-                auth.add(buildDigestResponse(user, pwd, digestUri, realm,
-                        getNonce(respHeaders), getOpaque(respHeaders), nc1,
-                        cnonce, qop));
-            } else {
-                auth.add(buildDigestResponse(user, pwd, digestUri, realm,
-                        getNonce(respHeaders), "null", nc1, cnonce, qop));
-            }
-        } else {
-            auth.add(buildDigestResponse(user, pwd, digestUri, realm,
-                    "null", getOpaque(respHeaders), nc1, cnonce, QOP));
-        }
-        rc = getUrl("http://localhost:" + getPort() + uri, bc, reqHeaders,
-                null);
-
-        if (req2expect200) {
-            assertEquals(200, rc);
-            assertEquals("OK", bc.toString());
-        } else {
-            assertEquals(401, rc);
-            assertTrue(bc.getLength() > 0);
-        }
-
-        // Third request should succeed if we increment nc
-        auth.clear();
-        bc.recycle();
-        auth.add(buildDigestResponse(user, pwd, digestUri, realm,
-                getNonce(respHeaders), getOpaque(respHeaders), nc2, cnonce,
-                qop));
-        rc = getUrl("http://localhost:" + getPort() + uri, bc, reqHeaders,
-                null);
-
-        if (req3expect200) {
-            assertEquals(200, rc);
-            assertEquals("OK", bc.toString());
-        } else {
-            assertEquals(401, rc);
-            assertTrue(bc.getLength() > 0);
-        }
-    }
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-
-        // Configure a context with digest auth and a single protected resource
-        Tomcat tomcat = getTomcatInstance();
-
-        // No file system docBase required
-        Context ctxt = tomcat.addContext(CONTEXT_PATH, null);
-
-        // Add protected servlet
-        Tomcat.addServlet(ctxt, "TesterServlet", new TesterServlet());
-        ctxt.addServletMapping(URI, "TesterServlet");
-        SecurityCollection collection = new SecurityCollection();
-        collection.addPattern(URI);
-        SecurityConstraint sc = new SecurityConstraint();
-        sc.addAuthRole(ROLE);
-        sc.addCollection(collection);
-        ctxt.addConstraint(sc);
-
-        // Configure the Realm
-        TesterMapRealm realm = new TesterMapRealm();
-        realm.addUser(USER, PWD);
-        realm.addUserRole(USER, ROLE);
-        ctxt.setRealm(realm);
-
-        // Configure the authenticator
-        LoginConfig lc = new LoginConfig();
-        lc.setAuthMethod("DIGEST");
-        lc.setRealmName(REALM);
-        ctxt.setLoginConfig(lc);
-
-        JaspicAuthenticator authenticator = new JaspicAuthenticator();
-        ctxt.getPipeline().addValve(authenticator);
-        AuthConfigFactory authConfigFactory = AuthConfigFactory.getFactory();
-        TomcatAuthConfigProvider provider = new TomcatAuthConfigProvider(ctxt, authenticator.getAuthProperties());
-        authConfigFactory.registerConfigProvider(provider, JaspicAuthenticator.MESSAGE_LAYER,
-                null, "Tomcat Jaspic");
-    }
-
-
-    protected static String getNonce(Map<String,List<String>> respHeaders) {
-        List<String> authHeaders =
-            respHeaders.get(AuthenticatorBase.AUTH_HEADER_NAME);
-        // Assume there is only one
-        String authHeader = authHeaders.iterator().next();
-
-        int start = authHeader.indexOf("nonce=\"") + 7;
-        int end = authHeader.indexOf('\"', start);
-        return authHeader.substring(start, end);
-    }
-
-    protected static String getOpaque(Map<String,List<String>> respHeaders) {
-        List<String> authHeaders =
-            respHeaders.get(AuthenticatorBase.AUTH_HEADER_NAME);
-        // Assume there is only one
-        String authHeader = authHeaders.iterator().next();
-
-        int start = authHeader.indexOf("opaque=\"") + 8;
-        int end = authHeader.indexOf('\"', start);
-        return authHeader.substring(start, end);
-    }
-
-    /*
-     * Notes from RFC2617
-     * H(data) = MD5(data)
-     * KD(secret, data) = H(concat(secret, ":", data))
-     * A1 = unq(username-value) ":" unq(realm-value) ":" passwd
-     * A2 = Method ":" digest-uri-value
-     * request-digest  = <"> < KD ( H(A1),     unq(nonce-value)
-                                    ":" nc-value
-                                    ":" unq(cnonce-value)
-                                    ":" unq(qop-value)
-                                    ":" H(A2)
-                                   ) <">
-     */
-    private static String buildDigestResponse(String user, String pwd,
-            String uri, String realm, String nonce, String opaque, String nc,
-            String cnonce, String qop) {
-
-        String a1 = user + ":" + realm + ":" + pwd;
-        String a2 = "GET:" + uri;
-
-        String md5a1 = digest(a1);
-        String md5a2 = digest(a2);
-
-        String response;
-        if (qop == null) {
-            response = md5a1 + ":" + nonce + ":" + md5a2;
-        } else {
-            response = md5a1 + ":" + nonce + ":" + nc + ":" + cnonce + ":" +
-                    qop + ":" + md5a2;
-        }
-
-        String md5response = digest(response);
-
-        StringBuilder auth = new StringBuilder();
-        auth.append("Digest username=\"");
-        auth.append(user);
-        auth.append("\", realm=\"");
-        auth.append(realm);
-        auth.append("\", nonce=\"");
-        auth.append(nonce);
-        auth.append("\", uri=\"");
-        auth.append(uri);
-        auth.append("\", opaque=\"");
-        auth.append(opaque);
-        auth.append("\", response=\"");
-        auth.append(md5response);
-        auth.append("\"");
-        if (qop != null) {
-            auth.append(", qop=");
-            auth.append(qop);
-            auth.append("");
-        }
-        if (nc != null) {
-            auth.append(", nc=");
-            auth.append(nc);
-        }
-        if (cnonce != null) {
-            auth.append(", cnonce=\"");
-            auth.append(cnonce);
-            auth.append("\"");
-        }
-
-        return auth.toString();
-    }
-
-    private static String digest(String input) {
-        return MD5Encoder.encode(
-                ConcurrentMessageDigest.digestMD5(input.getBytes()));
-    }
-
-
-    private static class TesterRequest extends Request {
-
-        @Override
-        public String getRemoteAddr() {
-            return "127.0.0.1";
-        }
-    }
-}

==================================================
TestJaspicAuthenticator.java
deleted file mode 100644
index cc1ba2dd94..0000000000
--- a/test/org/apache/catalina/authenticator/TestJaspicFormAuthenticator.java
+++ /dev/null
@@ -1,771 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.catalina.authenticator;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.List;
-import java.util.StringTokenizer;
-
-import javax.security.auth.message.config.AuthConfigFactory;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-import org.junit.Ignore;
-import org.junit.Test;
-
-import org.apache.catalina.Context;
-import org.apache.catalina.authenticator.jaspic.JaspicAuthenticator;
-import org.apache.catalina.authenticator.jaspic.provider.TomcatAuthConfigProvider;
-import org.apache.catalina.startup.SimpleHttpClient;
-import org.apache.catalina.startup.TesterMapRealm;
-import org.apache.catalina.startup.TesterServlet;
-import org.apache.catalina.startup.Tomcat;
-import org.apache.catalina.startup.TomcatBaseTest;
-import org.apache.tomcat.util.descriptor.web.LoginConfig;
-import org.apache.tomcat.util.descriptor.web.SecurityCollection;
-import org.apache.tomcat.util.descriptor.web.SecurityConstraint;
-import org.apache.tomcat.websocket.server.WsContextListener;
-
-/*
- * Test FORM authentication for sessions that do and do not use cookies.
- *
- * 1. A client that can accept and respond to a Set-Cookie for JSESSIONID
- *    will be able to maintain its authenticated session, no matter whether
- *    the session ID is changed once, many times, or not at all.
- *
- * 2. A client that cannot accept cookies will only be able to maintain a
- *    persistent session IF the server sends the correct (current) jsessionid
- *    as a path parameter appended to ALL urls within its response. That is
- *    achievable with servlets, jsps, jstl (all of which which can ask for an
- *    encoded url to be inserted into the dynamic web page). It cannot work
- *    with static html.
- *    note: this test class uses the Tomcat sample jsps, which conform.
- *
- * 3. Therefore, any webapp that MIGHT need to authenticate a client that
- *    does not accept cookies MUST generate EVERY protected resource url
- *    dynamically (so that it will include the current session ID).
- *
- * 4. Any webapp that cannot satisfy case 3 MUST turn off
- *    changeSessionIdOnAuthentication for its Context and thus degrade the
- *    session fixation protection for ALL of its clients.
- *    note from MarkT: Not sure I agree with this. If the URLs aren't
- *      being encoded, then the session is going to break regardless of
- *      whether or not the session ID changes.
- *
- * Unlike a "proper browser", this unit test class does a quite lot of
- * screen-scraping and cheating of headers and urls (not very elegant,
- * but it makes no claims to generality).
- *
- */
-public class TestJaspicFormAuthenticator extends TomcatBaseTest {
-
-    // these should really be singletons to be type-safe,
-    // we are in a unit test and don't need to paranoid.
-    protected static final boolean USE_100_CONTINUE = true;
-    protected static final boolean NO_100_CONTINUE = !USE_100_CONTINUE;
-
-    protected static final boolean CLIENT_USE_COOKIES = true;
-    protected static final boolean CLIENT_NO_COOKIES = !CLIENT_USE_COOKIES;
-
-    protected static final boolean CLIENT_USE_HTTP_11 = true;
-    protected static final boolean CLIENT_USE_HTTP_10 = !CLIENT_USE_HTTP_11;
-
-    protected static final boolean SERVER_USE_COOKIES = true;
-    protected static final boolean SERVER_NO_COOKIES = !SERVER_USE_COOKIES;
-
-    protected static final boolean SERVER_CHANGE_SESSID = true;
-    protected static final boolean SERVER_FREEZE_SESSID = !SERVER_CHANGE_SESSID;
-
-    // minimum session timeout
-    private static final int TIMEOUT_MINS = 1;
-    private static final long TIMEOUT_DELAY_MSECS = (((TIMEOUT_MINS * 60) + 10) * 1000);
-
-    private FormAuthClient client;
-
-
-    // first, a set of tests where the server uses a cookie to carry
-    // the current session ID during and after authentication, and
-    // the client is prepared to return cookies with each request
-
-    @Test
-    public void testGetWithCookies() throws Exception {
-        doTest("GET", "GET", NO_100_CONTINUE, CLIENT_USE_COOKIES, SERVER_USE_COOKIES,
-                SERVER_CHANGE_SESSID);
-    }
-
-
-    @Test
-    public void testPostNoContinueWithCookies() throws Exception {
-        doTest("POST", "GET", NO_100_CONTINUE, CLIENT_USE_COOKIES, SERVER_USE_COOKIES,
-                SERVER_CHANGE_SESSID);
-    }
-
-
-    @Test
-    public void testPostWithContinueAndCookies() throws Exception {
-        doTest("POST", "GET", USE_100_CONTINUE, CLIENT_USE_COOKIES, SERVER_USE_COOKIES,
-                SERVER_CHANGE_SESSID);
-    }
-
-
-    // Bug 49779
-    @Test
-    public void testPostNoContinuePostRedirectWithCookies() throws Exception {
-        doTest("POST", "POST", NO_100_CONTINUE, CLIENT_USE_COOKIES, SERVER_USE_COOKIES,
-                SERVER_CHANGE_SESSID);
-    }
-
-
-    // Bug 49779
-    @Test
-    public void testPostWithContinuePostRedirectWithCookies() throws Exception {
-        doTest("POST", "POST", USE_100_CONTINUE, CLIENT_USE_COOKIES, SERVER_USE_COOKIES,
-                SERVER_CHANGE_SESSID);
-    }
-
-
-    // next, a set of tests where the server Context is configured to never
-    // use cookies and the session ID is only carried as a url path parameter
-
-    // Bug 53584
-    @Test
-    public void testGetNoServerCookies() throws Exception {
-        doTest("GET", "GET", NO_100_CONTINUE, CLIENT_NO_COOKIES, SERVER_NO_COOKIES,
-                SERVER_CHANGE_SESSID);
-    }
-
-
-    @Test
-    public void testPostNoContinueNoServerCookies() throws Exception {
-        doTest("POST", "GET", NO_100_CONTINUE, CLIENT_USE_COOKIES, SERVER_NO_COOKIES,
-                SERVER_CHANGE_SESSID);
-    }
-
-
-    @Test
-    public void testPostWithContinueNoServerCookies() throws Exception {
-        doTest("POST", "GET", USE_100_CONTINUE, CLIENT_USE_COOKIES, SERVER_NO_COOKIES,
-                SERVER_CHANGE_SESSID);
-    }
-
-
-    // variant of Bug 49779
-    @Test
-    public void testPostNoContinuePostRedirectNoServerCookies() throws Exception {
-        doTest("POST", "POST", NO_100_CONTINUE, CLIENT_USE_COOKIES, SERVER_NO_COOKIES,
-                SERVER_CHANGE_SESSID);
-    }
-
-
-    // variant of Bug 49779
-    @Test
-    public void testPostWithContinuePostRedirectNoServerCookies() throws Exception {
-        doTest("POST", "POST", USE_100_CONTINUE, CLIENT_USE_COOKIES, SERVER_NO_COOKIES,
-                SERVER_CHANGE_SESSID);
-    }
-
-
-    // next, a set of tests where the server Context uses cookies,
-    // but the client refuses to return them and tries to use
-    // the session ID if carried as a url path parameter
-
-    @Test
-    public void testGetNoClientCookies() throws Exception {
-        doTest("GET", "GET", NO_100_CONTINUE, CLIENT_NO_COOKIES, SERVER_USE_COOKIES,
-                SERVER_CHANGE_SESSID);
-    }
-
-
-    @Test
-    public void testPostNoContinueNoClientCookies() throws Exception {
-        doTest("POST", "GET", NO_100_CONTINUE, CLIENT_NO_COOKIES, SERVER_USE_COOKIES,
-                SERVER_CHANGE_SESSID);
-    }
-
-
-    @Test
-    public void testPostWithContinueNoClientCookies() throws Exception {
-        doTest("POST", "GET", USE_100_CONTINUE, CLIENT_NO_COOKIES, SERVER_USE_COOKIES,
-                SERVER_CHANGE_SESSID);
-    }
-
-
-    // variant of Bug 49779
-    @Test
-    public void testPostNoContinuePostRedirectNoClientCookies() throws Exception {
-        doTest("POST", "POST", NO_100_CONTINUE, CLIENT_NO_COOKIES, SERVER_USE_COOKIES,
-                SERVER_CHANGE_SESSID);
-    }
-
-
-    // variant of Bug 49779
-    @Test
-    public void testPostWithContinuePostRedirectNoClientCookies() throws Exception {
-        doTest("POST", "POST", USE_100_CONTINUE, CLIENT_NO_COOKIES, SERVER_USE_COOKIES,
-                SERVER_CHANGE_SESSID);
-    }
-
-
-    // finally, a set of tests to explore quirky situations
-    // but there is not need to replicate all the scenarios above.
-
-    @Test
-    public void testNoChangedSessidWithCookies() throws Exception {
-        doTest("GET", "GET", NO_100_CONTINUE, CLIENT_USE_COOKIES, SERVER_USE_COOKIES,
-                SERVER_FREEZE_SESSID);
-    }
-
-
-    @Test
-    public void testNoChangedSessidWithoutCookies() throws Exception {
-        doTest("GET", "GET", NO_100_CONTINUE, CLIENT_NO_COOKIES, SERVER_USE_COOKIES,
-                SERVER_FREEZE_SESSID);
-    }
-
-
-    // HTTP 1.0 test
-    @Test
-    public void testGetWithCookiesHttp10() throws Exception {
-        doTest("GET", "GET", NO_100_CONTINUE, CLIENT_USE_COOKIES, SERVER_USE_COOKIES,
-                SERVER_CHANGE_SESSID, CLIENT_USE_HTTP_10);
-    }
-
-
-    @Test
-    public void doTestSelectedMethods() throws Exception {
-
-        FormAuthClientSelectedMethods client = new FormAuthClientSelectedMethods(true, true, true,
-                true);
-
-        // First request for protected resource gets the login page
-        client.doResourceRequest("PUT", true, "/test?" + SelectedMethodsServlet.PARAM + "="
-                + SelectedMethodsServlet.VALUE, null);
-        assertTrue(client.getResponseLine(), client.isResponse200());
-        assertTrue(client.isResponseBodyOK());
-        String originalSessionId = client.getSessionId();
-        client.reset();
-
-        // Second request replies to the login challenge
-        client.doResourceRequest("POST", true, "/test/j_security_check",
-                FormAuthClientBase.LOGIN_REPLY);
-        assertTrue("login failed " + client.getResponseLine(), client.isResponse303());
-        assertTrue(client.isResponseBodyOK());
-        String redirectUri = client.getRedirectUri();
-        client.reset();
-
-        // Third request - the login was successful so
-        // follow the redirect to the protected resource
-        client.doResourceRequest("GET", true, redirectUri, null);
-        assertTrue(client.isResponse200());
-        assertTrue(client.isResponseBodyOK());
-        String newSessionId = client.getSessionId();
-
-        assertTrue(!originalSessionId.equals(newSessionId));
-        client.reset();
-    }
-
-
-    @Test
-    @Ignore
-    public void testTimeoutWithoutCookies() throws Exception {
-        String protectedUri = doTest("GET", "GET", NO_100_CONTINUE, CLIENT_NO_COOKIES,
-                SERVER_USE_COOKIES, SERVER_FREEZE_SESSID);
-
-        // wait long enough for my session to expire
-        Thread.sleep(TIMEOUT_DELAY_MSECS);
-
-        // then try to continue using the expired session to get the
-        // protected resource once more.
-        // should get login challenge or timeout status 408
-        doTestProtected("GET", protectedUri, NO_100_CONTINUE, FormAuthClient.LOGIN_REQUIRED, 1);
-    }
-
-
-    /*
-     * Choreograph the steps of the test dialogue with the server 1. while not
-     * authenticated, try to access a protected resource 2. respond to the login
-     * challenge with good credentials 3. after successful login, follow the
-     * redirect to the original page 4. repeatedly access the protected resource
-     * to demonstrate persistence of the authenticated session
-     * @param resourceMethod HTTP method for accessing the protected resource
-     * @param redirectMethod HTTP method for the login FORM reply
-     * @param useContinue whether the HTTP client should expect a 100 Continue
-     * @param clientShouldUseCookies whether the client should send cookies
-     * @param serverWillUseCookies whether the server should send cookies
-     */
-    private String doTest(String resourceMethod, String redirectMethod, boolean useContinue,
-            boolean clientShouldUseCookies, boolean serverWillUseCookies,
-            boolean serverWillChangeSessid) throws Exception {
-        return doTest(resourceMethod, redirectMethod, useContinue, clientShouldUseCookies,
-                serverWillUseCookies, serverWillChangeSessid, true);
-    }
-
-
-    private String doTest(String resourceMethod, String redirectMethod, boolean useContinue,
-            boolean clientShouldUseCookies, boolean serverWillUseCookies,
-            boolean serverWillChangeSessid, boolean clientShouldUseHttp11) throws Exception {
-
-        client = new FormAuthClient(clientShouldUseCookies, clientShouldUseHttp11,
-                serverWillUseCookies, serverWillChangeSessid);
-
-        // First request for protected resource gets the login page
-        client.setUseContinue(useContinue);
-        client.doResourceRequest(resourceMethod, false, null, null);
-        assertTrue(client.isResponse200());
-        assertTrue(client.isResponseBodyOK());
-        String loginUri = client.extractBodyUri(FormAuthClient.LOGIN_PARAM_TAG,
-                FormAuthClient.LOGIN_RESOURCE);
-        String originalSessionId = null;
-        if (serverWillUseCookies && clientShouldUseCookies) {
-            originalSessionId = client.getSessionId();
-        } else {
-            originalSessionId = client.extractPathSessionId(loginUri);
-        }
-        client.reset();
-
-        // Second request replies to the login challenge
-        client.setUseContinue(useContinue);
-        client.doLoginRequest(loginUri);
-        if (clientShouldUseHttp11) {
-            assertTrue("login failed " + client.getResponseLine(), client.isResponse303());
-        } else {
-            assertTrue("login failed " + client.getResponseLine(), client.isResponse302());
-        }
-        assertTrue(client.isResponseBodyOK());
-        String redirectUri = client.getRedirectUri();
-        client.reset();
-
-        // Third request - the login was successful so
-        // follow the redirect to the protected resource
-        client.doResourceRequest(redirectMethod, true, redirectUri, null);
-        if ("POST".equals(redirectMethod)) {
-            client.setUseContinue(useContinue);
-        }
-        assertTrue(client.isResponse200());
-        assertTrue(client.isResponseBodyOK());
-        String protectedUri = client.extractBodyUri(FormAuthClient.RESOURCE_PARAM_TAG,
-                FormAuthClient.PROTECTED_RESOURCE);
-        String newSessionId = null;
-        if (serverWillUseCookies && clientShouldUseCookies) {
-            newSessionId = client.getSessionId();
-        } else {
-            newSessionId = client.extractPathSessionId(protectedUri);
-        }
-        boolean sessionIdIsChanged = !(originalSessionId.equals(newSessionId));
-        // TODO implement this option
-        // assertTrue(sessionIdIsChanged == serverWillChangeSessid);
-        client.reset();
-
-        // Subsequent requests - keep accessing the protected resource
-        doTestProtected(resourceMethod, protectedUri, useContinue, FormAuthClient.LOGIN_SUCCESSFUL,
-                5);
-
-        return protectedUri;        // in case more requests will be issued
-    }
-
-
-    /*
-     * Repeatedly access the protected resource after the client has
-     * successfully logged-in to the webapp. The current session attributes will
-     * be used and cannot be changed. 3. after successful login, follow the
-     * redirect to the original page 4. repeatedly access the protected resource
-     * to demonstrate persistence of the authenticated session
-     * @param resourceMethod HTTP method for accessing the protected resource
-     * @param protectedUri to access (with or without sessionid)
-     * @param useContinue whether the HTTP client should expect a 100 Continue
-     * @param clientShouldUseCookies whether the client should send cookies
-     * @param serverWillUseCookies whether the server should send cookies
-     */
-    private void doTestProtected(String resourceMethod, String protectedUri, boolean useContinue,
-            int phase, int repeatCount) throws Exception {
-
-        // Subsequent requests - keep accessing the protected resource
-        for (int i = 0; i < repeatCount; i++) {
-            client.setUseContinue(useContinue);
-            client.doResourceRequest(resourceMethod, false, protectedUri, null);
-            assertTrue(client.isResponse200());
-            assertTrue(client.isResponseBodyOK(phase));
-            client.reset();
-        }
-    }
-
-    /*
-     * Encapsulate the logic needed to run a suitably-configured tomcat
-     * instance, send it an HTTP request and process the server response
-     */
-    private abstract class FormAuthClientBase extends SimpleHttpClient {
-
-        protected static final String LOGIN_PARAM_TAG = "action=";
-        protected static final String LOGIN_RESOURCE = "j_security_check";
-        protected static final String LOGIN_REPLY = "j_username=tomcat&j_password=tomcat";
-
-        protected static final String PROTECTED_RELATIVE_PATH = "/examples/jsp/security/protected/";
-        protected static final String PROTECTED_RESOURCE = "index.jsp";
-        private static final String PROTECTED_RESOURCE_URL = PROTECTED_RELATIVE_PATH
-                + PROTECTED_RESOURCE;
-        protected static final String RESOURCE_PARAM_TAG = "href=";
-        private static final char PARAM_DELIM = '?';
-
-        // primitive tracking of the test phases to verify the HTML body
-        protected static final int LOGIN_REQUIRED = 1;
-        protected static final int REDIRECTING = 2;
-        protected static final int LOGIN_SUCCESSFUL = 3;
-        private int requestCount = 0;
-
-        // todo: forgot this change and making it up again!
-        protected final String SESSION_PARAMETER_START = SESSION_PARAMETER_NAME + "=";
-
-        protected boolean clientShouldUseHttp11;
-
-
-        protected void doLoginRequest(String loginUri) throws Exception {
-
-            doResourceRequest("POST", true, PROTECTED_RELATIVE_PATH + loginUri, LOGIN_REPLY);
-        }
-
-
-        /*
-         * Prepare the resource request HTTP headers and issue the request.
-         * Three kinds of uri are supported: 1. fully qualified uri. 2. minimal
-         * uri without webapp path. 3. null - use the default protected resource
-         * Cookies are sent if available and supported by the test. Otherwise,
-         * the caller is expected to have provided a session id as a path
-         * parameter.
-         */
-        protected void doResourceRequest(String method, boolean isFullQualUri, String resourceUri,
-                String requestTail) throws Exception {
-
-            // build the HTTP request while assembling the uri
-            StringBuilder requestHead = new StringBuilder(128);
-            requestHead.append(method).append(" ");
-            if (isFullQualUri) {
-                requestHead.append(resourceUri);
-            } else {
-                if (resourceUri == null) {
-                    // the default relative url
-                    requestHead.append(PROTECTED_RESOURCE_URL);
-                } else {
-                    requestHead.append(PROTECTED_RELATIVE_PATH).append(resourceUri);
-                }
-                if ("GET".equals(method)) {
-                    requestHead.append("?role=bar");
-                }
-            }
-            if (clientShouldUseHttp11) {
-                requestHead.append(" HTTP/1.1").append(CRLF);
-            } else {
-                requestHead.append(" HTTP/1.0").append(CRLF);
-            }
-
-            // next, add the constant http headers
-            requestHead.append("Host: localhost").append(CRLF);
-            requestHead.append("Connection: close").append(CRLF);
-
-            // then any optional http headers
-            if (getUseContinue()) {
-                requestHead.append("Expect: 100-continue").append(CRLF);
-            }
-            if (getUseCookies()) {
-                String sessionId = getSessionId();
-                if (sessionId != null) {
-                    requestHead.append("Cookie: ").append(SESSION_COOKIE_NAME).append("=")
-                            .append(sessionId).append(CRLF);
-                }
-            }
-
-            // finally, for posts only, deal with the request content
-            if ("POST".equals(method)) {
-                if (requestTail == null) {
-                    requestTail = "role=bar";
-                }
-                requestHead.append("Content-Type: application/x-www-form-urlencoded").append(CRLF);
-                // calculate post data length
-                String len = Integer.toString(requestTail.length());
-                requestHead.append("Content-length: ").append(len).append(CRLF);
-            }
-
-            // always put an empty line after the headers
-            requestHead.append(CRLF);
-
-            String request[] = new String[2];
-            request[0] = requestHead.toString();
-            request[1] = requestTail;
-            doRequest(request);
-        }
-
-
-        private void doRequest(String request[]) throws Exception {
-            setRequest(request);
-            connect();
-            processRequest();
-            disconnect();
-            requestCount++;
-        }
-
-
-        /*
-         * verify the server response html body is the page we expect, based on
-         * the dialogue position within doTest.
-         */
-        @Override
-        public boolean isResponseBodyOK() {
-            return isResponseBodyOK(requestCount);
-        }
-
-
-        /*
-         * verify the server response html body is the page we expect, based on
-         * the dialogue position given by the caller.
-         */
-        public boolean isResponseBodyOK(int testPhase) {
-            switch (testPhase) {
-            case LOGIN_REQUIRED:
-                // First request should return in the login page
-                assertContains(getResponseBody(), "<title>Login Page for Examples</title>");
-                return true;
-            case REDIRECTING:
-                // Second request should result in redirect without a body
-                return true;
-            default:
-                // Subsequent requests should return in the protected page.
-                // Our role parameter should be appear in the page.
-                String body = getResponseBody();
-                assertContains(body, "<title>Protected Page for Examples</title>");
-                assertContains(body, "<input type=\"text\" name=\"role\" value=\"bar\"");
-                return true;
-            }
-        }
-
-
-        /*
-         * Scan the server response body and extract the given url, including
-         * any path elements.
-         */
-        protected String extractBodyUri(String paramTag, String resource) {
-            extractUriElements();
-            List<String> elements = getResponseBodyUriElements();
-            String fullPath = null;
-            for (String element : elements) {
-                int ix = element.indexOf(paramTag);
-                if (ix > -1) {
-                    ix += paramTag.length();
-                    char delim = element.charAt(ix);
-                    int iy = element.indexOf(resource, ix);
-                    if (iy > -1) {
-                        int lastCharIx = element.indexOf(delim, iy);
-                        fullPath = element.substring(iy, lastCharIx);
-                        // remove any trailing parameters
-                        int paramDelim = fullPath.indexOf(PARAM_DELIM);
-                        if (paramDelim > -1) {
-                            fullPath = fullPath.substring(0, paramDelim);
-                        }
-                        break;
-                    }
-                }
-            }
-            return fullPath;
-        }
-
-
-        /*
-         * extract the session id path element (if it exists in the given url)
-         */
-        protected String extractPathSessionId(String url) {
-            String sessionId = null;
-            int iStart = url.indexOf(SESSION_PARAMETER_START);
-            if (iStart > -1) {
-                iStart += SESSION_PARAMETER_START.length();
-                String remainder = url.substring(iStart);
-                StringTokenizer parser = new StringTokenizer(remainder,
-                        SESSION_PATH_PARAMETER_TAILS);
-                if (parser.hasMoreElements()) {
-                    sessionId = parser.nextToken();
-                } else {
-                    sessionId = url.substring(iStart);
-                }
-            }
-            return sessionId;
-        }
-
-
-        private void assertContains(String body, String expected) {
-            if (!body.contains(expected)) {
-                fail("Response number " + requestCount + ": body check failure.\n"
-                        + "Expected to contain substring: [" + expected + "]\nActual: [" + body
-                        + "]");
-            }
-        }
-    }
-
-    private class FormAuthClient extends FormAuthClientBase {
-        private FormAuthClient(boolean clientShouldUseCookies, boolean clientShouldUseHttp11,
-                boolean serverShouldUseCookies, boolean serverShouldChangeSessid) throws Exception {
-
-            this.clientShouldUseHttp11 = clientShouldUseHttp11;
-
-            Tomcat tomcat = getTomcatInstance();
-            File appDir = new File(getBuildDirectory(), "webapps/examples");
-            Context ctx = tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath());
-            setUseCookies(clientShouldUseCookies);
-            ctx.setCookies(serverShouldUseCookies);
-            ctx.addApplicationListener(WsContextListener.class.getName());
-
-            TesterMapRealm realm = new TesterMapRealm();
-            realm.addUser("tomcat", "tomcat");
-            realm.addUserRole("tomcat", "tomcat");
-            ctx.setRealm(realm);
-
-            JaspicAuthenticator jaspicAuthenticator = new JaspicAuthenticator();
-            ctx.getPipeline().addValve(jaspicAuthenticator);
-            AuthConfigFactory authConfigFactory = AuthConfigFactory.getFactory();
-            TomcatAuthConfigProvider provider = new TomcatAuthConfigProvider(ctx, jaspicAuthenticator.getAuthProperties());
-            authConfigFactory.registerConfigProvider(provider, JaspicAuthenticator.MESSAGE_LAYER,
-                    null, "Tomcat Jaspic");
-
-            tomcat.start();
-
-            // perhaps this does not work until tomcat has started?
-            ctx.setSessionTimeout(TIMEOUT_MINS);
-
-            // Port only known after Tomcat starts
-            setPort(getPort());
-        }
-    }
-
-    /**
-     * Encapsulate the logic needed to run a suitably-configured Tomcat
-     * instance, send it an HTTP request and process the server response when
-     * the protected resource is only protected for some HTTP methods. The use
-     * case of particular interest is when GET and POST are not protected since
-     * those are the methods used by the login form and the redirect and if
-     * those methods are not protected the authenticator may not process the
-     * associated requests.
-     */
-    private class FormAuthClientSelectedMethods extends FormAuthClientBase {
-
-        private FormAuthClientSelectedMethods(boolean clientShouldUseCookies,
-                boolean clientShouldUseHttp11, boolean serverShouldUseCookies,
-                boolean serverShouldChangeSessid) throws Exception {
-
-            this.clientShouldUseHttp11 = clientShouldUseHttp11;
-
-            Tomcat tomcat = getTomcatInstance();
-
-            Context ctx = tomcat.addContext("", System.getProperty("java.io.tmpdir"));
-            Tomcat.addServlet(ctx, "SelectedMethods", new SelectedMethodsServlet());
-            ctx.addServletMapping("/test", "SelectedMethods");
-            // Login servlet just needs to respond "OK". Client will handle
-            // creating a valid response. No need for a form.
-            Tomcat.addServlet(ctx, "Login", new TesterServlet());
-            ctx.addServletMapping("/login", "Login");
-
-            // Configure the security constraints
-            SecurityConstraint constraint = new SecurityConstraint();
-            SecurityCollection collection = new SecurityCollection();
-            collection.setName("Protect PUT");
-            collection.addMethod("PUT");
-            collection.addPattern("/test");
-            constraint.addCollection(collection);
-            constraint.addAuthRole("tomcat");
-            ctx.addConstraint(constraint);
-
-            // Configure authentication
-            LoginConfig lc = new LoginConfig();
-            lc.setAuthMethod("JASPIC-FORM");
-            lc.setLoginPage("/login");
-            ctx.setLoginConfig(lc);
-            ctx.getPipeline().addValve(new FormAuthenticator());
-
-            setUseCookies(clientShouldUseCookies);
-            ctx.setCookies(serverShouldUseCookies);
-
-            TesterMapRealm realm = new TesterMapRealm();
-            realm.addUser("tomcat", "tomcat");
-            realm.addUserRole("tomcat", "tomcat");
-            ctx.setRealm(realm);
-
-            JaspicAuthenticator authenticator = new JaspicAuthenticator();
-            ctx.getPipeline().addValve(authenticator);
-            AuthConfigFactory authConfigFactory = AuthConfigFactory.getFactory();
-            TomcatAuthConfigProvider provider = new TomcatAuthConfigProvider(ctx, authenticator.getAuthProperties());
-            authConfigFactory.registerConfigProvider(provider, JaspicAuthenticator.MESSAGE_LAYER,
-                    null, "Tomcat Jaspic");
-
-            tomcat.start();
-
-            // perhaps this does not work until tomcat has started?
-            ctx.setSessionTimeout(TIMEOUT_MINS);
-
-            // Port only known after Tomcat starts
-            setPort(getPort());
-        }
-
-
-        @Override
-        public boolean isResponseBodyOK() {
-            if (isResponse303()) {
-                return true;
-            }
-            assertTrue(getResponseBody(), getResponseBody().contains("OK"));
-            assertFalse(getResponseBody().contains("FAIL"));
-            return true;
-        }
-    }
-
-    private static final class SelectedMethodsServlet extends HttpServlet {
-
-        private static final long serialVersionUID = 1L;
-        public static final String PARAM = "TestParam";
-        public static final String VALUE = "TestValue";
-
-
-        @Override
-        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
-                throws ServletException, IOException {
-            resp.setContentType("text/plain;charset=UTF-8");
-
-            if (VALUE.equals(req.getParameter(PARAM)) && req.isUserInRole("tomcat")) {
-                resp.getWriter().print("OK");
-            } else {
-                resp.getWriter().print("FAIL");
-            }
-        }
-
-
-        @Override
-        protected void doPost(HttpServletRequest req, HttpServletResponse resp)
-                throws ServletException, IOException {
-            // Same as GET for this test case
-            doGet(req, resp);
-        }
-
-
-        @Override
-        protected void doPut(HttpServletRequest req, HttpServletResponse resp)
-                throws ServletException, IOException {
-            // Same as GET for this test case
-            doGet(req, resp);
-        }
-    }
-}

==================================================
TestJaspicCallbackHandler.java
deleted file mode 100644
index 3795a62012..0000000000
--- a/test/org/apache/catalina/authenticator/jaspic/TestJaspicAuthenticator.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic;
-
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.HashMap;
-import java.util.List;
-
-import javax.security.auth.message.config.AuthConfigFactory;
-import javax.servlet.http.HttpServletResponse;
-
-import static org.junit.Assert.assertEquals;
-
-import org.junit.Test;
-
-import org.apache.catalina.Context;
-import org.apache.catalina.authenticator.jaspic.sam.TesterAuthConfigProvider;
-import org.apache.catalina.startup.TesterServlet;
-import org.apache.catalina.startup.Tomcat;
-import org.apache.catalina.startup.TomcatBaseTest;
-import org.apache.tomcat.util.buf.ByteChunk;
-import org.apache.tomcat.util.descriptor.web.LoginConfig;
-import org.apache.tomcat.util.descriptor.web.SecurityCollection;
-import org.apache.tomcat.util.descriptor.web.SecurityConstraint;
-
-public class TestJaspicAuthenticator extends TomcatBaseTest {
-
-    private static String CONTEXT_PATH = "/foo";
-    private static final String URI_PROTECTED = "/protected";
-    private static final String ROLE = "group";
-    private Context context;
-
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-
-        Tomcat tomcat = getTomcatInstance();
-        this.context = tomcat.addContext(CONTEXT_PATH, null);
-
-        // Add protected servlet
-        Tomcat.addServlet(context, "TesterServlet", new TesterServlet());
-        context.addServletMapping(URI_PROTECTED, "TesterServlet");
-        SecurityCollection collection = new SecurityCollection();
-        collection.addPattern(URI_PROTECTED);
-
-        SecurityConstraint constraint = new SecurityConstraint();
-        constraint.addAuthRole(ROLE);
-        constraint.addCollection(collection);
-        context.addConstraint(constraint);
-
-        // Configure the authenticator
-        LoginConfig loginConfig = new LoginConfig();
-        loginConfig.setAuthMethod("JASPIC-BASIC");
-        context.setLoginConfig(loginConfig);
-        context.getPipeline().addValve(new JaspicAuthenticator());
-
-        AuthConfigFactory factory = AuthConfigFactory.getFactory();
-        factory.registerConfigProvider(new TesterAuthConfigProvider(), "HttpServlet", null,
-                "Description");
-        getTomcatInstance().start();
-    }
-
-
-    @Test
-    public void shouldAuthenticateUsingRegistredJaspicProvider() throws Exception {
-        // given
-        String url = getUrl() + URI_PROTECTED + "?doLogin=true";
-        ByteChunk byteChunk = new ByteChunk();
-
-        // when
-        int result = getUrl(url, byteChunk, new HashMap<String, List<String>>());
-
-        // then
-        assertEquals(HttpServletResponse.SC_OK, result);
-        assertEquals("OK", byteChunk.toString());
-    }
-
-
-    @Test
-    public void shouldFailAuthenticationUsingRegistredJaspicProvider() throws Exception {
-        // given
-        String url = getUrl() + URI_PROTECTED;
-        ByteChunk byteChunk = new ByteChunk();
-
-        // when
-        int result = getUrl(url, byteChunk, new HashMap<String, List<String>>());
-
-        // then
-        assertEquals(HttpServletResponse.SC_FORBIDDEN, result);
-    }
-
-
-    private String getUrl() throws MalformedURLException {
-        return new URL("http", "localhost", getPort(), CONTEXT_PATH).toString();
-    }
-}

==================================================
TestPrincipalGroupCallback.java
deleted file mode 100644
index cee8995814..0000000000
--- a/test/org/apache/catalina/authenticator/jaspic/TestJaspicCallbackHandler.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic;
-
-import java.util.Set;
-
-import javax.security.auth.Subject;
-import javax.security.auth.callback.Callback;
-import javax.security.auth.message.callback.CallerPrincipalCallback;
-import javax.security.auth.message.callback.GroupPrincipalCallback;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-import org.junit.Test;
-
-import org.apache.catalina.realm.GenericPrincipal;
-
-public class TestJaspicCallbackHandler {
-
-    private static final String USER = "user";
-
-    private JaspicCallbackHandler jaspicCallbackHandler = new JaspicCallbackHandler(null);
-
-
-    @Test
-    public void shouldConvertCallbackToTomcatPrincipal() throws Exception {
-        // given
-        Subject subject = new Subject();
-        CallerPrincipalCallback callerCallback = new CallerPrincipalCallback(subject, USER);
-        String[] groups = new String[] { "group" };
-
-        GroupPrincipalCallback groupCallback = new GroupPrincipalCallback(subject, groups);
-        Callback[] callbacks = new Callback[] { callerCallback, groupCallback };
-
-        // when
-        jaspicCallbackHandler.handle(callbacks);
-
-        // then
-        Set<GenericPrincipal> principals = callerCallback.getSubject().getPrivateCredentials(
-                GenericPrincipal.class);
-        GenericPrincipal principal = principals.iterator().next();
-        assertEquals(USER, principal.getName());
-        assertArrayEquals(groups, principal.getRoles());
-    }
-
-
-    @Test(expected = IllegalStateException.class)
-    public void shouldHandleUnknowCallback() throws Exception {
-        // given
-        Callback[] callbacks = new Callback[] { new Callback() {
-        } };
-
-        // when
-        jaspicCallbackHandler.handle(callbacks);
-
-        // then
-        fail("Should throw exception");
-    }
-}
\ No newline at end of file

==================================================
TesterAuthConfig.java
deleted file mode 100644
index 108bf7b4da..0000000000
--- a/test/org/apache/catalina/authenticator/jaspic/TestPrincipalGroupCallback.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic;
-
-import java.security.Principal;
-
-import javax.security.auth.Subject;
-import javax.security.auth.message.callback.CallerPrincipalCallback;
-import javax.security.auth.message.callback.GroupPrincipalCallback;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-
-import org.junit.Test;
-
-import org.apache.catalina.realm.GenericPrincipal;
-
-public class TestPrincipalGroupCallback {
-
-    private static final String USER_NAME = "user";
-
-
-    @Test
-    public void shouldAddUserPrincipal() throws Exception {
-        // given
-        PrincipalGroupCallback principalGroupCallback = new PrincipalGroupCallback();
-        UserPrincipal userPrincipal = new UserPrincipal(USER_NAME);
-        Subject subject = new Subject();
-        CallerPrincipalCallback callerCallback = new CallerPrincipalCallback(subject, userPrincipal);
-        principalGroupCallback.setCallerPrincipalCallback(callerCallback);
-        // when
-        GenericPrincipal principal = principalGroupCallback.getPrincipal();
-
-        // then
-        assertEquals(USER_NAME, principal.getName());
-        assertEquals(userPrincipal, principal.getUserPrincipal());
-    }
-
-
-    @Test
-    public void shouldCreatePrincipalWithUsername() throws Exception {
-        // given
-        PrincipalGroupCallback principalGroupCallback = new PrincipalGroupCallback();
-        Subject subject = new Subject();
-        CallerPrincipalCallback callerCallback = new CallerPrincipalCallback(subject, USER_NAME);
-        principalGroupCallback.setCallerPrincipalCallback(callerCallback);
-        // when
-        GenericPrincipal principal = principalGroupCallback.getPrincipal();
-
-        // then
-        assertEquals(USER_NAME, principal.getName());
-    }
-
-
-    @Test
-    public void shouldAddGroupsToPrincipal() throws Exception {
-        // given
-        PrincipalGroupCallback principalGroupCallback = new PrincipalGroupCallback();
-        Subject subject = new Subject();
-
-        CallerPrincipalCallback callerCallback = new CallerPrincipalCallback(subject, USER_NAME);
-        principalGroupCallback.setCallerPrincipalCallback(callerCallback);
-
-        String[] groups = new String[] { "group1" };
-        GroupPrincipalCallback groupCallback = new GroupPrincipalCallback(subject, groups);
-        principalGroupCallback.setGroupPrincipalCallback(groupCallback);
-
-        // when
-        GenericPrincipal principal = principalGroupCallback.getPrincipal();
-
-        // then
-        assertArrayEquals(principal.getRoles(), groups);
-    }
-
-
-    @Test
-    public void shouldReturnNullIfNoCallbackDefined() throws Exception {
-        // given
-        PrincipalGroupCallback principalGroupCallback = new PrincipalGroupCallback();
-
-        // when
-        GenericPrincipal principal = principalGroupCallback.getPrincipal();
-
-        // then
-        assertNull(principal);
-    }
-
-
-    private static class UserPrincipal implements Principal {
-        private String name;
-
-        public UserPrincipal(String name) {
-            this.name = name;
-        }
-
-        @Override
-        public String getName() {
-            return name;
-        }
-    }
-}
\ No newline at end of file

==================================================
TesterAuthConfigProvider.java
deleted file mode 100644
index 21cd18a855..0000000000
--- a/test/org/apache/catalina/authenticator/jaspic/sam/TesterAuthConfig.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic.sam;
-
-import java.util.Map;
-
-import javax.security.auth.Subject;
-import javax.security.auth.callback.CallbackHandler;
-import javax.security.auth.message.AuthException;
-import javax.security.auth.message.MessageInfo;
-import javax.security.auth.message.config.ServerAuthConfig;
-import javax.security.auth.message.config.ServerAuthContext;
-import javax.security.auth.message.module.ServerAuthModule;
-
-public class TesterAuthConfig implements ServerAuthConfig {
-
-    private CallbackHandler callbackHandler;
-    private ServerAuthModule authModule;
-
-
-    public TesterAuthConfig(CallbackHandler callbackHandler, ServerAuthModule authModule) {
-        this.callbackHandler = callbackHandler;
-        this.authModule = authModule;
-    }
-
-
-    @Override
-    public String getMessageLayer() {
-        return "HttpServlet";
-    }
-
-
-    @Override
-    public String getAppContext() {
-        return null;
-    }
-
-
-    @Override
-    public String getAuthContextID(MessageInfo messageInfo) {
-        return null;
-    }
-
-
-    @Override
-    public void refresh() {
-
-    }
-
-
-    @Override
-    public boolean isProtected() {
-        return false;
-    }
-
-
-    @Override
-    @SuppressWarnings("rawtypes")
-    public ServerAuthContext getAuthContext(String authContextID, Subject serviceSubject,
-            Map properties) throws AuthException {
-        return new TesterServerAuthContext(callbackHandler, authModule);
-    }
-}
\ No newline at end of file

==================================================
TesterAuthModule.java
deleted file mode 100644
index 92faeae8f0..0000000000
--- a/test/org/apache/catalina/authenticator/jaspic/sam/TesterAuthConfigProvider.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic.sam;
-
-import javax.security.auth.callback.CallbackHandler;
-import javax.security.auth.message.AuthException;
-import javax.security.auth.message.config.AuthConfigProvider;
-import javax.security.auth.message.config.ClientAuthConfig;
-import javax.security.auth.message.config.ServerAuthConfig;
-
-public class TesterAuthConfigProvider implements AuthConfigProvider {
-
-    @Override
-    public ClientAuthConfig getClientAuthConfig(String layer, String appContext,
-            CallbackHandler handler) throws AuthException {
-        return null;
-    }
-
-
-    @Override
-    public ServerAuthConfig getServerAuthConfig(String layer, String appContext,
-            CallbackHandler handler) throws AuthException {
-        return new TesterAuthConfig(handler, new TesterAuthModule());
-    }
-
-
-    @Override
-    public void refresh() {
-    }
-}
\ No newline at end of file

==================================================
TesterServerAuthContext.java
deleted file mode 100644
index f97234e5d7..0000000000
--- a/test/org/apache/catalina/authenticator/jaspic/sam/TesterAuthModule.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package org.apache.catalina.authenticator.jaspic.sam;
-
-import java.io.IOException;
-import java.security.Principal;
-import java.util.Map;
-
-import javax.security.auth.Subject;
-import javax.security.auth.callback.Callback;
-import javax.security.auth.callback.CallbackHandler;
-import javax.security.auth.callback.UnsupportedCallbackException;
-import javax.security.auth.message.AuthException;
-import javax.security.auth.message.AuthStatus;
-import javax.security.auth.message.MessageInfo;
-import javax.security.auth.message.MessagePolicy;
-import javax.security.auth.message.callback.CallerPrincipalCallback;
-import javax.security.auth.message.callback.GroupPrincipalCallback;
-import javax.security.auth.message.module.ServerAuthModule;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-public class TesterAuthModule implements ServerAuthModule {
-
-    private CallbackHandler handler;
-    private Class<?>[] supportedMessageTypes = new Class[] { HttpServletRequest.class,
-            HttpServletResponse.class };
-
-
-    @Override
-    @SuppressWarnings("rawtypes")
-    public void initialize(MessagePolicy requestPolicy, MessagePolicy responsePolicy,
-            CallbackHandler handler, Map options) throws AuthException {
-        this.handler = handler;
-    }
-
-
-    @Override
-    public AuthStatus validateRequest(MessageInfo messageInfo, Subject clientSubject,
-            Subject serviceSubject) throws AuthException {
-        HttpServletRequest request = (HttpServletRequest) messageInfo.getRequestMessage();
-
-        Callback[] callbacks = getAuthenticationCallbacks(clientSubject, request);
-
-        try {
-            handler.handle(callbacks);
-        } catch (IOException | UnsupportedCallbackException e) {
-            throw (AuthException) new AuthException().initCause(e);
-        }
-
-        return AuthStatus.SUCCESS;
-    }
-
-
-    private Callback[] getAuthenticationCallbacks(Subject clientSubject, HttpServletRequest request) {
-        Callback[] callbacks;
-
-        if (request.getParameter("doLogin") != null) {
-            callbacks = new Callback[] { new CallerPrincipalCallback(clientSubject, "user"),
-                    new GroupPrincipalCallback(clientSubject, new String[] { "group" }) };
-        } else {
-            callbacks = new Callback[] { new CallerPrincipalCallback(clientSubject,
-                    (Principal) null) };
-        }
-        return callbacks;
-    }
-
-
-    @Override
-    public AuthStatus secureResponse(MessageInfo messageInfo, Subject serviceSubject)
-            throws AuthException {
-        return AuthStatus.SEND_SUCCESS;
-    }
-
-
-    @Override
-    public void cleanSubject(MessageInfo messageInfo, Subject subject) throws AuthException {
-
-    }
-
-
-    @Override
-    public Class<?>[] getSupportedMessageTypes() {
-        return supportedMessageTypes;
-    }
-}

==================================================
