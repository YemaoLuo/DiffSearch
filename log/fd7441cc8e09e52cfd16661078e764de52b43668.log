fd7441cc8e09e52cfd16661078e764de52b43668
==================================================
Add handling for socket properties (using OpenSSL connectors and their direct buffers, something was missing), including its use of null objects to represent unset properties.
==================================================
Remy Maucherat
==================================================
Tue Feb 23 14:38:21 2016 +0000
==================================================
ConnectorStoreAppender.java
Add handling for socket properties (using OpenSSL connectors and their direct buffers, something was missing), including its use of null objects to represent unset properties.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1731865 13f79535-47bb-0310-9956-ffa450edef68



==================================================
IntrospectionUtils.java
index ef4dc7c6e1..abd1e78022 100644
--- a/java/org/apache/catalina/storeconfig/ConnectorStoreAppender.java
+++ b/java/org/apache/catalina/storeconfig/ConnectorStoreAppender.java
@@ -31,6 +31,7 @@ import java.util.List;
 import org.apache.catalina.connector.Connector;
 import org.apache.coyote.ProtocolHandler;
 import org.apache.tomcat.util.IntrospectionUtils;
+import org.apache.tomcat.util.net.SocketProperties;
 
 /**
  * Store the Connector attributes. Connector has really special design. A
@@ -78,7 +79,6 @@ public class ConnectorStoreAppender extends StoreAppender {
         while (propertyIterator.hasNext()) {
             String key = propertyIterator.next();
             Object value = IntrospectionUtils.getProperty(bean, key);
-
             if (desc.isTransientAttribute(key)) {
                 continue; // Skip the specified exceptions
             }
@@ -120,20 +120,20 @@ public class ConnectorStoreAppender extends StoreAppender {
         if (descriptors == null) {
             descriptors = new PropertyDescriptor[0];
         }
-        for (int i = 0; i < descriptors.length; i++) {
-            if (descriptors[i] instanceof IndexedPropertyDescriptor) {
+        for (PropertyDescriptor descriptor : descriptors) {
+            if (descriptor instanceof IndexedPropertyDescriptor) {
                 continue; // Indexed properties are not persisted
             }
-            if (!isPersistable(descriptors[i].getPropertyType())
-                    || (descriptors[i].getReadMethod() == null)
-                    || (descriptors[i].getWriteMethod() == null)) {
+            if (!isPersistable(descriptor.getPropertyType())
+                    || (descriptor.getReadMethod() == null)
+                    || (descriptor.getWriteMethod() == null)) {
                 continue; // Must be a read-write primitive or String
             }
-            if ("protocol".equals(descriptors[i].getName())
-                    || "protocolHandlerClassName".equals(descriptors[i]
+            if ("protocol".equals(descriptor.getName())
+                    || "protocolHandlerClassName".equals(descriptor
                             .getName()))
                 continue;
-            propertyKeys.add(descriptors[i].getName());
+            propertyKeys.add(descriptor.getName());
         }
         // Add the properties of the protocol handler
         descriptors = Introspector.getBeanInfo(
@@ -141,16 +141,16 @@ public class ConnectorStoreAppender extends StoreAppender {
         if (descriptors == null) {
             descriptors = new PropertyDescriptor[0];
         }
-        for (int i = 0; i < descriptors.length; i++) {
-            if (descriptors[i] instanceof IndexedPropertyDescriptor) {
+        for (PropertyDescriptor descriptor : descriptors) {
+            if (descriptor instanceof IndexedPropertyDescriptor) {
                 continue; // Indexed properties are not persisted
             }
-            if (!isPersistable(descriptors[i].getPropertyType())
-                    || (descriptors[i].getReadMethod() == null)
-                    || (descriptors[i].getWriteMethod() == null)) {
+            if (!isPersistable(descriptor.getPropertyType())
+                    || (descriptor.getReadMethod() == null)
+                    || (descriptor.getWriteMethod() == null)) {
                 continue; // Must be a read-write primitive or String
             }
-            String key = descriptors[i].getName();
+            String key = descriptor.getName();
             if (replacements.get(key) != null) {
                 key = replacements.get(key);
             }
@@ -158,6 +158,32 @@ public class ConnectorStoreAppender extends StoreAppender {
                 propertyKeys.add(key);
             }
         }
+        // Add the properties for the socket
+        final String socketName = "socket.";
+        descriptors = Introspector.getBeanInfo(
+                SocketProperties.class).getPropertyDescriptors();
+        if (descriptors == null) {
+            descriptors = new PropertyDescriptor[0];
+        }
+        for (PropertyDescriptor descriptor : descriptors) {
+            if (descriptor instanceof IndexedPropertyDescriptor) {
+                continue; // Indexed properties are not persisted
+            }
+            if (!isPersistable(descriptor.getPropertyType())
+                    || (descriptor.getReadMethod() == null)
+                    || (descriptor.getWriteMethod() == null)) {
+                continue; // Must be a read-write primitive or String
+            }
+            String key = descriptor.getName();
+            if (replacements.get(key) != null) {
+                key = replacements.get(key);
+            }
+            if (!propertyKeys.contains(key)) {
+                // Add socket.[original name] if this is not a property
+                // that could be set elsewhere
+                propertyKeys.add(socketName + descriptor.getName());
+            }
+        }
         return propertyKeys;
     }
 

==================================================
AbstractEndpoint.java
index d8cc6fa024..aa964460c2 100644
--- a/java/org/apache/tomcat/util/IntrospectionUtils.java
+++ b/java/org/apache/tomcat/util/IntrospectionUtils.java
@@ -220,6 +220,10 @@ public final class IntrospectionUtils {
             log.warn("IntrospectionUtils: IllegalAccessException for " +
                     o.getClass() + " " + name + ")", iae);
         } catch (InvocationTargetException ie) {
+            if (ie.getCause() instanceof NullPointerException) {
+                // Assume the underlying object uses a storage to represent an unset property
+                return null;
+            }
             ExceptionUtils.handleThrowable(ie.getCause());
             log.warn("IntrospectionUtils: InvocationTargetException for " +
                     o.getClass() + " " + name + ")", ie);

==================================================
