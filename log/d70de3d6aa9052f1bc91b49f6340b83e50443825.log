d70de3d6aa9052f1bc91b49f6340b83e50443825
==================================================
Whitespace removal from remaining /java/org/apache/jasper
==================================================
Mark Emlyn
==================================================
Sat Oct 22 21:18:03 2011 +0000
==================================================
Constants.java
Whitespace removal from remaining /java/org/apache/jasper

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1187803 13f79535-47bb-0310-9956-ffa450edef68



==================================================
EmbeddedServletOptions.java
index 60ff5e3c75..442858e7e1 100644
--- a/java/org/apache/jasper/Constants.java
+++ b/java/org/apache/jasper/Constants.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -31,19 +31,19 @@ import java.util.List;
  * @author Mark Roth
  */
 public class Constants {
-    
+
     /**
-     * The base class of the generated servlets. 
+     * The base class of the generated servlets.
      */
-    public static final String JSP_SERVLET_BASE = 
+    public static final String JSP_SERVLET_BASE =
         System.getProperty("org.apache.jasper.Constants.JSP_SERVLET_BASE", "org.apache.jasper.runtime.HttpJspBase");
 
     /**
-     * _jspService is the name of the method that is called by 
+     * _jspService is the name of the method that is called by
      * HttpJspBase.service(). This is where most of the code generated
      * from JSPs go.
      */
-    public static final String SERVICE_METHOD_NAME = 
+    public static final String SERVICE_METHOD_NAME =
         System.getProperty("org.apache.jasper.Constants.SERVICE_METHOD_NAME", "_jspService");
 
     /**
@@ -53,22 +53,22 @@ public class Constants {
 
     /**
      * These classes/packages are automatically imported by the
-     * generated code. 
+     * generated code.
      */
-    private static final String[] PRIVATE_STANDARD_IMPORTS = { 
-        "javax.servlet.*", 
-        "javax.servlet.http.*", 
+    private static final String[] PRIVATE_STANDARD_IMPORTS = {
+        "javax.servlet.*",
+        "javax.servlet.http.*",
         "javax.servlet.jsp.*"
     };
     public static final List<String> STANDARD_IMPORTS =
         Collections.unmodifiableList(Arrays.asList(PRIVATE_STANDARD_IMPORTS));
 
     /**
-     * ServletContext attribute for classpath. This is tomcat specific. 
-     * Other servlet engines may choose to support this attribute if they 
-     * want to have this JSP engine running on them. 
+     * ServletContext attribute for classpath. This is tomcat specific.
+     * Other servlet engines may choose to support this attribute if they
+     * want to have this JSP engine running on them.
      */
-    public static final String SERVLET_CLASSPATH = 
+    public static final String SERVLET_CLASSPATH =
         System.getProperty("org.apache.jasper.Constants.SERVLET_CLASSPATH", "org.apache.catalina.jsp_classpath");
 
     /**
@@ -77,7 +77,7 @@ public class Constants {
      * value returned by <code>request.getServletPath()</code> to select
      * the JSP page to be executed.
      */
-    public static final String JSP_FILE = 
+    public static final String JSP_FILE =
         System.getProperty("org.apache.jasper.Constants.JSP_FILE", "org.apache.catalina.jsp_file");
 
 
@@ -103,56 +103,56 @@ public class Constants {
 
     /**
      * The query parameter that causes the JSP engine to just
-     * pregenerated the servlet but not invoke it. 
+     * pregenerated the servlet but not invoke it.
      */
-    public static final String PRECOMPILE = 
+    public static final String PRECOMPILE =
         System.getProperty("org.apache.jasper.Constants.PRECOMPILE", "jsp_precompile");
 
     /**
      * The default package name for compiled jsp pages.
      */
-    public static final String JSP_PACKAGE_NAME = 
+    public static final String JSP_PACKAGE_NAME =
         System.getProperty("org.apache.jasper.Constants.JSP_PACKAGE_NAME", "org.apache.jsp");
 
     /**
      * The default package name for tag handlers generated from tag files
      */
-    public static final String TAG_FILE_PACKAGE_NAME = 
+    public static final String TAG_FILE_PACKAGE_NAME =
         System.getProperty("org.apache.jasper.Constants.TAG_FILE_PACKAGE_NAME", "org.apache.jsp.tag");
 
     // Must be kept in sync with org/apache/catalina/Globals.java
-    public static final String ALT_DD_ATTR = 
+    public static final String ALT_DD_ATTR =
         System.getProperty("org.apache.jasper.Constants.ALT_DD_ATTR", "org.apache.catalina.deploy.alt_dd");
 
     /**
-     * Public Id and the Resource path (of the cached copy) 
-     * of the DTDs for tag library descriptors. 
+     * Public Id and the Resource path (of the cached copy)
+     * of the DTDs for tag library descriptors.
      */
-    public static final String TAGLIB_DTD_PUBLIC_ID_11 = 
+    public static final String TAGLIB_DTD_PUBLIC_ID_11 =
         "-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.1//EN";
-    public static final String TAGLIB_DTD_RESOURCE_PATH_11 = 
+    public static final String TAGLIB_DTD_RESOURCE_PATH_11 =
         "/javax/servlet/jsp/resources/web-jsptaglibrary_1_1.dtd";
-    public static final String TAGLIB_DTD_PUBLIC_ID_12 = 
+    public static final String TAGLIB_DTD_PUBLIC_ID_12 =
         "-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN";
-    public static final String TAGLIB_DTD_RESOURCE_PATH_12 = 
+    public static final String TAGLIB_DTD_RESOURCE_PATH_12 =
         "/javax/servlet/jsp/resources/web-jsptaglibrary_1_2.dtd";
 
     /**
-     * Public Id and the Resource path (of the cached copy) 
+     * Public Id and the Resource path (of the cached copy)
      * of the DTDs for web application deployment descriptors
      */
-    public static final String WEBAPP_DTD_PUBLIC_ID_22 = 
+    public static final String WEBAPP_DTD_PUBLIC_ID_22 =
         "-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN";
-    public static final String WEBAPP_DTD_RESOURCE_PATH_22 = 
+    public static final String WEBAPP_DTD_RESOURCE_PATH_22 =
         "/javax/servlet/resources/web-app_2_2.dtd";
-    public static final String WEBAPP_DTD_PUBLIC_ID_23 = 
+    public static final String WEBAPP_DTD_PUBLIC_ID_23 =
         "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN";
-    public static final String WEBAPP_DTD_RESOURCE_PATH_23 = 
+    public static final String WEBAPP_DTD_RESOURCE_PATH_23 =
         "/javax/servlet/resources/web-app_2_3.dtd";
 
     /**
      * List of the Public IDs that we cache, and their
-     * associated location. This is used by 
+     * associated location. This is used by
      * an EntityResolver to return the location of the
      * cached copy of a DTD.
      */
@@ -175,14 +175,14 @@ public class Constants {
     public static final List<String> CACHED_DTD_RESOURCE_PATHS =
         Collections.unmodifiableList(
                 Arrays.asList(PRIVATE_CACHED_DTD_RESOURCE_PATHS));
-    
+
     /**
      * Default URLs to download the plugin for Netscape and IE.
      */
-    public static final String NS_PLUGIN_URL = 
+    public static final String NS_PLUGIN_URL =
         "http://java.sun.com/products/plugin/";
 
-    public static final String IE_PLUGIN_URL = 
+    public static final String IE_PLUGIN_URL =
         "http://java.sun.com/products/plugin/1.2.2/jinstall-1_2_2-win.cab#Version=1,2,2,0";
 
     /**
@@ -194,7 +194,7 @@ public class Constants {
     /**
      * Has security been turned on?
      */
-    public static final boolean IS_SECURITY_ENABLED = 
+    public static final boolean IS_SECURITY_ENABLED =
         (System.getSecurityManager() != null);
 
     public static final boolean USE_INSTANCE_MANAGER_FOR_TAGS =

==================================================
JasperException.java
index 6c5ddbd082..2457e7efac 100644
--- a/java/org/apache/jasper/EmbeddedServletOptions.java
+++ b/java/org/apache/jasper/EmbeddedServletOptions.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -35,159 +35,159 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 
 /**
- * A class to hold all init parameters specific to the JSP engine. 
+ * A class to hold all init parameters specific to the JSP engine.
  *
  * @author Anil K. Vijendran
  * @author Hans Bergsten
  * @author Pierre Delisle
  */
 public final class EmbeddedServletOptions implements Options {
-    
+
     // Logger
     private final Log log = LogFactory.getLog(EmbeddedServletOptions.class);
-    
+
     private Properties settings = new Properties();
-    
+
     /**
      * Is Jasper being used in development mode?
      */
     private boolean development = true;
-    
+
     /**
      * Should Ant fork its java compiles of JSP pages.
      */
     public boolean fork = true;
-    
+
     /**
      * Do you want to keep the generated Java files around?
      */
     private boolean keepGenerated = true;
-    
+
     /**
      * Should white spaces between directives or actions be trimmed?
      */
     private boolean trimSpaces = false;
-    
+
     /**
      * Determines whether tag handler pooling is enabled.
      */
     private boolean isPoolingEnabled = true;
-    
+
     /**
      * Do you want support for "mapped" files? This will generate
      * servlet that has a print statement per line of the JSP file.
      * This seems like a really nice feature to have for debugging.
      */
     private boolean mappedFile = true;
-    
+
     /**
      * Do we want to include debugging information in the class file?
      */
     private boolean classDebugInfo = true;
-    
+
     /**
      * Background compile thread check interval in seconds.
      */
     private int checkInterval = 0;
-    
+
     /**
      * Is the generation of SMAP info for JSR45 debugging suppressed?
      */
     private boolean isSmapSuppressed = false;
-    
+
     /**
      * Should SMAP info for JSR45 debugging be dumped to a file?
      */
     private boolean isSmapDumped = false;
-    
+
     /**
      * Are Text strings to be generated as char arrays?
      */
     private boolean genStringAsCharArray = false;
-    
+
     private boolean errorOnUseBeanInvalidClassAttribute = true;
-    
+
     /**
      * I want to see my generated servlets. Which directory are they
      * in?
      */
     private File scratchDir;
-    
+
     /**
      * Need to have this as is for versions 4 and 5 of IE. Can be set from
      * the initParams so if it changes in the future all that is needed is
      * to have a jsp initParam of type ieClassId="<value>"
      */
     private String ieClassId = "clsid:8AD9C840-044E-11D1-B3E9-00805F499D93";
-    
+
     /**
      * What classpath should I use while compiling generated servlets?
      */
     private String classpath = null;
-    
+
     /**
      * Compiler to use.
      */
     private String compiler = null;
-    
+
     /**
      * Compiler target VM.
      */
     private String compilerTargetVM = "1.6";
-    
+
     /**
      * The compiler source VM.
      */
     private String compilerSourceVM = "1.6";
-    
+
     /**
      * The compiler class name.
      */
     private String compilerClassName = null;
-    
+
     /**
      * Cache for the TLD locations
      */
     private TldLocationsCache tldLocationsCache = null;
-    
+
     /**
      * Jsp config information
      */
     private JspConfig jspConfig = null;
-    
+
     /**
      * TagPluginManager
      */
     private TagPluginManager tagPluginManager = null;
-    
+
     /**
      * Java platform encoding to generate the JSP
      * page servlet.
      */
     private String javaEncoding = "UTF8";
-    
+
     /**
      * Modification test interval.
      */
     private int modificationTestInterval = 4;
-    
+
     /**
      * Is re-compilation attempted immediately after a failure?
      */
     private boolean recompileOnFail = false;
-    
+
     /**
      * Is generation of X-Powered-By response header enabled/disabled?
      */
     private boolean xpoweredBy;
-    
+
     /**
      * Should we include a source fragment in exception messages, which could be displayed
      * to the developer ?
      */
     private boolean displaySourceFragment = true;
 
-    
+
     /**
      * The maximum number of loaded jsps per web-application. If there are more
      * jsps loaded, they will be unloaded.
@@ -203,13 +203,13 @@ public final class EmbeddedServletOptions implements Options {
     public String getProperty(String name ) {
         return settings.getProperty( name );
     }
-    
+
     public void setProperty(String name, String value ) {
-        if (name != null && value != null){ 
+        if (name != null && value != null){
             settings.setProperty( name, value );
         }
     }
-    
+
     /**
      * Are we keeping generated code around?
      */
@@ -217,7 +217,7 @@ public final class EmbeddedServletOptions implements Options {
     public boolean getKeepGenerated() {
         return keepGenerated;
     }
-    
+
     /**
      * Should white spaces between directives or actions be trimmed?
      */
@@ -225,12 +225,12 @@ public final class EmbeddedServletOptions implements Options {
     public boolean getTrimSpaces() {
         return trimSpaces;
     }
-    
+
     @Override
     public boolean isPoolingEnabled() {
         return isPoolingEnabled;
     }
-    
+
     /**
      * Are we supporting HTML mapped servlets?
      */
@@ -238,7 +238,7 @@ public final class EmbeddedServletOptions implements Options {
     public boolean getMappedFile() {
         return mappedFile;
     }
-    
+
     /**
      * Should class files be compiled with debug information?
      */
@@ -246,7 +246,7 @@ public final class EmbeddedServletOptions implements Options {
     public boolean getClassDebugInfo() {
         return classDebugInfo;
     }
-    
+
     /**
      * Background JSP compile thread check interval
      */
@@ -254,7 +254,7 @@ public final class EmbeddedServletOptions implements Options {
     public int getCheckInterval() {
         return checkInterval;
     }
-    
+
     /**
      * Modification test interval.
      */
@@ -262,7 +262,7 @@ public final class EmbeddedServletOptions implements Options {
     public int getModificationTestInterval() {
         return modificationTestInterval;
     }
-    
+
     /**
      * Re-compile on failure.
      */
@@ -270,7 +270,7 @@ public final class EmbeddedServletOptions implements Options {
     public boolean getRecompileOnFail() {
         return recompileOnFail;
     }
-    
+
     /**
      * Is Jasper being used in development mode?
      */
@@ -278,7 +278,7 @@ public final class EmbeddedServletOptions implements Options {
     public boolean getDevelopment() {
         return development;
     }
-    
+
     /**
      * Is the generation of SMAP info for JSR45 debugging suppressed?
      */
@@ -286,7 +286,7 @@ public final class EmbeddedServletOptions implements Options {
     public boolean isSmapSuppressed() {
         return isSmapSuppressed;
     }
-    
+
     /**
      * Should SMAP info for JSR45 debugging be dumped to a file?
      */
@@ -294,7 +294,7 @@ public final class EmbeddedServletOptions implements Options {
     public boolean isSmapDumped() {
         return isSmapDumped;
     }
-    
+
     /**
      * Are Text strings to be generated as char arrays?
      */
@@ -302,15 +302,15 @@ public final class EmbeddedServletOptions implements Options {
     public boolean genStringAsCharArray() {
         return this.genStringAsCharArray;
     }
-    
+
     /**
-     * Class ID for use in the plugin tag when the browser is IE. 
+     * Class ID for use in the plugin tag when the browser is IE.
      */
     @Override
     public String getIeClassId() {
         return ieClassId;
     }
-    
+
     /**
      * What is my scratch dir?
      */
@@ -318,7 +318,7 @@ public final class EmbeddedServletOptions implements Options {
     public File getScratchDir() {
         return scratchDir;
     }
-    
+
     /**
      * What classpath should I use while compiling the servlets
      * generated from JSP files?
@@ -327,7 +327,7 @@ public final class EmbeddedServletOptions implements Options {
     public String getClassPath() {
         return classpath;
     }
-    
+
     /**
      * Is generation of X-Powered-By response header enabled/disabled?
      */
@@ -335,7 +335,7 @@ public final class EmbeddedServletOptions implements Options {
     public boolean isXpoweredBy() {
         return xpoweredBy;
     }
-    
+
     /**
      * Compiler to use.
      */
@@ -343,7 +343,7 @@ public final class EmbeddedServletOptions implements Options {
     public String getCompiler() {
         return compiler;
     }
-    
+
     /**
      * @see Options#getCompilerTargetVM
      */
@@ -351,7 +351,7 @@ public final class EmbeddedServletOptions implements Options {
     public String getCompilerTargetVM() {
         return compilerTargetVM;
     }
-    
+
     /**
      * @see Options#getCompilerSourceVM
      */
@@ -359,7 +359,7 @@ public final class EmbeddedServletOptions implements Options {
     public String getCompilerSourceVM() {
         return compilerSourceVM;
     }
-    
+
     /**
      * Java compiler class to use.
      */
@@ -372,45 +372,45 @@ public final class EmbeddedServletOptions implements Options {
     public boolean getErrorOnUseBeanInvalidClassAttribute() {
         return errorOnUseBeanInvalidClassAttribute;
     }
-    
+
     public void setErrorOnUseBeanInvalidClassAttribute(boolean b) {
         errorOnUseBeanInvalidClassAttribute = b;
     }
-    
+
     @Override
     public TldLocationsCache getTldLocationsCache() {
         return tldLocationsCache;
     }
-    
+
     public void setTldLocationsCache( TldLocationsCache tldC ) {
         tldLocationsCache = tldC;
     }
-    
+
     @Override
     public String getJavaEncoding() {
         return javaEncoding;
     }
-    
+
     @Override
     public boolean getFork() {
         return fork;
     }
-    
+
     @Override
     public JspConfig getJspConfig() {
         return jspConfig;
     }
-    
+
     @Override
     public TagPluginManager getTagPluginManager() {
         return tagPluginManager;
     }
-    
+
     @Override
     public boolean isCaching() {
         return false;
     }
-    
+
     @Override
     public Map<String, TagLibraryInfo> getCache() {
         return null;
@@ -445,22 +445,22 @@ public final class EmbeddedServletOptions implements Options {
 
     /**
      * Create an EmbeddedServletOptions object using data available from
-     * ServletConfig and ServletContext. 
+     * ServletConfig and ServletContext.
      */
     public EmbeddedServletOptions(ServletConfig config,
             ServletContext context) {
-        
+
         Enumeration<String> enumeration=config.getInitParameterNames();
         while( enumeration.hasMoreElements() ) {
             String k=enumeration.nextElement();
             String v=config.getInitParameter( k );
             setProperty( k, v);
         }
-        
+
         // quick hack
         String validating=config.getInitParameter( "validating");
         if( "false".equals( validating )) ParserUtils.validating=false;
-        
+
         String keepgen = config.getInitParameter("keepgenerated");
         if (keepgen != null) {
             if (keepgen.equalsIgnoreCase("true")) {
@@ -473,9 +473,9 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
-        
-        String trimsp = config.getInitParameter("trimSpaces"); 
+
+
+        String trimsp = config.getInitParameter("trimSpaces");
         if (trimsp != null) {
             if (trimsp.equalsIgnoreCase("true")) {
                 trimSpaces = true;
@@ -487,10 +487,10 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
+
         this.isPoolingEnabled = true;
         String poolingEnabledParam
-        = config.getInitParameter("enablePooling"); 
+        = config.getInitParameter("enablePooling");
         if (poolingEnabledParam != null
                 && !poolingEnabledParam.equalsIgnoreCase("true")) {
             if (poolingEnabledParam.equalsIgnoreCase("false")) {
@@ -501,8 +501,8 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
-        String mapFile = config.getInitParameter("mappedfile"); 
+
+        String mapFile = config.getInitParameter("mappedfile");
         if (mapFile != null) {
             if (mapFile.equalsIgnoreCase("true")) {
                 this.mappedFile = true;
@@ -514,7 +514,7 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
+
         String debugInfo = config.getInitParameter("classdebuginfo");
         if (debugInfo != null) {
             if (debugInfo.equalsIgnoreCase("true")) {
@@ -527,7 +527,7 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
+
         String checkInterval = config.getInitParameter("checkInterval");
         if (checkInterval != null) {
             try {
@@ -538,7 +538,7 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
+
         String modificationTestInterval = config.getInitParameter("modificationTestInterval");
         if (modificationTestInterval != null) {
             try {
@@ -549,8 +549,8 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
-        String recompileOnFail = config.getInitParameter("recompileOnFail"); 
+
+        String recompileOnFail = config.getInitParameter("recompileOnFail");
         if (recompileOnFail != null) {
             if (recompileOnFail.equalsIgnoreCase("true")) {
                 this.recompileOnFail = true;
@@ -574,7 +574,7 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
+
         String suppressSmap = config.getInitParameter("suppressSmap");
         if (suppressSmap != null) {
             if (suppressSmap.equalsIgnoreCase("true")) {
@@ -587,7 +587,7 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
+
         String dumpSmap = config.getInitParameter("dumpSmap");
         if (dumpSmap != null) {
             if (dumpSmap.equalsIgnoreCase("true")) {
@@ -600,7 +600,7 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
+
         String genCharArray = config.getInitParameter("genStringAsCharArray");
         if (genCharArray != null) {
             if (genCharArray.equalsIgnoreCase("true")) {
@@ -613,7 +613,7 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
+
         String errBeanClass =
             config.getInitParameter("errorOnUseBeanInvalidClassAttribute");
         if (errBeanClass != null) {
@@ -627,19 +627,19 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
+
         String ieClassId = config.getInitParameter("ieClassId");
         if (ieClassId != null)
             this.ieClassId = ieClassId;
-        
+
         String classpath = config.getInitParameter("classpath");
         if (classpath != null)
             this.classpath = classpath;
-        
+
         /*
          * scratchdir
          */
-        String dir = config.getInitParameter("scratchdir"); 
+        String dir = config.getInitParameter("scratchdir");
         if (dir != null) {
             scratchDir = new File(dir);
         } else {
@@ -652,39 +652,39 @@ public final class EmbeddedServletOptions implements Options {
                 if (dir != null)
                     scratchDir = new File(dir);
             }
-        }      
+        }
         if (this.scratchDir == null) {
             log.fatal(Localizer.getMessage("jsp.error.no.scratch.dir"));
             return;
         }
-        
+
         if (!(scratchDir.exists() && scratchDir.canRead() &&
                 scratchDir.canWrite() && scratchDir.isDirectory()))
             log.fatal(Localizer.getMessage("jsp.error.bad.scratch.dir",
                     scratchDir.getAbsolutePath()));
-        
+
         this.compiler = config.getInitParameter("compiler");
-        
+
         String compilerTargetVM = config.getInitParameter("compilerTargetVM");
         if(compilerTargetVM != null) {
             this.compilerTargetVM = compilerTargetVM;
         }
-        
+
         String compilerSourceVM = config.getInitParameter("compilerSourceVM");
         if(compilerSourceVM != null) {
             this.compilerSourceVM = compilerSourceVM;
         }
-        
+
         String javaEncoding = config.getInitParameter("javaEncoding");
         if (javaEncoding != null) {
             this.javaEncoding = javaEncoding;
         }
-        
+
         String compilerClassName = config.getInitParameter("compilerClassName");
         if (compilerClassName != null) {
             this.compilerClassName = compilerClassName;
         }
-        
+
         String fork = config.getInitParameter("fork");
         if (fork != null) {
             if (fork.equalsIgnoreCase("true")) {
@@ -697,8 +697,8 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
-        String xpoweredBy = config.getInitParameter("xpoweredBy"); 
+
+        String xpoweredBy = config.getInitParameter("xpoweredBy");
         if (xpoweredBy != null) {
             if (xpoweredBy.equalsIgnoreCase("true")) {
                 this.xpoweredBy = true;
@@ -710,8 +710,8 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
-        String displaySourceFragment = config.getInitParameter("displaySourceFragment"); 
+
+        String displaySourceFragment = config.getInitParameter("displaySourceFragment");
         if (displaySourceFragment != null) {
             if (displaySourceFragment.equalsIgnoreCase("true")) {
                 this.displaySourceFragment = true;
@@ -723,7 +723,7 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
+
         String maxLoadedJsps = config.getInitParameter("maxLoadedJsps");
         if (maxLoadedJsps != null) {
             try {
@@ -734,7 +734,7 @@ public final class EmbeddedServletOptions implements Options {
                 }
             }
         }
-        
+
         String jspIdleTimeout = config.getInitParameter("jspIdleTimeout");
         if (jspIdleTimeout != null) {
             try {
@@ -749,13 +749,13 @@ public final class EmbeddedServletOptions implements Options {
         // Setup the global Tag Libraries location cache for this
         // web-application.
         tldLocationsCache = TldLocationsCache.getInstance(context);
-        
+
         // Setup the jsp config info for this web app.
         jspConfig = new JspConfig(context);
-        
+
         // Create a Tag plugin instance
         tagPluginManager = new TagPluginManager(context);
     }
-    
+
 }
 

==================================================
JspC.java
index 582c6667e7..6fdefceff2 100644
--- a/java/org/apache/jasper/JasperException.java
+++ b/java/org/apache/jasper/JasperException.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,12 +19,12 @@ package org.apache.jasper;
 
 /**
  * Base class for all exceptions generated by the JSP engine. Makes it
- * convenient to catch just this at the top-level. 
+ * convenient to catch just this at the top-level.
  *
  * @author Anil K. Vijendran
  */
 public class JasperException extends javax.servlet.ServletException {
-    
+
     private static final long serialVersionUID = 1L;
 
     public JasperException(String reason) {

==================================================
Options.java
index fda8b3263d..f2c7a820fb 100644
--- a/java/org/apache/jasper/JspC.java
+++ b/java/org/apache/jasper/JspC.java
@@ -132,7 +132,7 @@ public class JspC implements Options {
     protected static final int DEFAULT_DIE_LEVEL = 1;
     protected static final int NO_DIE_LEVEL = 0;
     protected static final Set<String> insertBefore = new HashSet<String>();
-    
+
     static {
         insertBefore.add("</web-app>");
         insertBefore.add("<servlet-mapping>");
@@ -269,7 +269,7 @@ public class JspC implements Options {
 
     /**
      * Apply command-line arguments.
-     * 
+     *
      * @param arg
      *            The arguments
      */
@@ -329,7 +329,7 @@ public class JspC implements Options {
                     caching = false;
                 } else {
                     caching = true;
-                }            
+                }
             } else if (tok.equals(SWITCH_CLASSPATH)) {
                 setClassPath(nextArg());
             } else if (tok.startsWith(SWITCH_DIE)) {
@@ -505,7 +505,7 @@ public class JspC implements Options {
 
     /**
      * Sets the option to enable caching.
-     * 
+     *
      * @see Options#isCaching()
      */
     public void setCaching(boolean caching) {
@@ -547,8 +547,8 @@ public class JspC implements Options {
     public boolean getRecompileOnFail() {
         return false;
     }
-    
-    
+
+
     /**
      * In JspC this always returns <code>false</code>.
      * {@inheritDoc}
@@ -583,14 +583,14 @@ public class JspC implements Options {
 
     /**
      * Sets smapDumped flag.
-     * 
+     *
      * @see Options#isSmapDumped()
      */
     public void setSmapDumped(boolean smapDumped) {
         this.smapDumped = smapDumped;
     }
 
-    
+
     /**
      * Determines whether text strings are to be generated as char arrays,
      * which improves performance in some cases.
@@ -613,7 +613,7 @@ public class JspC implements Options {
     /**
      * Sets the class-id value to be sent to Internet Explorer when using
      * &lt;jsp:plugin&gt; tags.
-     * 
+     *
      * @param ieClassId
      *            Class-id value
      */
@@ -647,7 +647,7 @@ public class JspC implements Options {
 
     /**
      * Sets the option to determine what compiler to use.
-     * 
+     *
      * @see Options#getCompiler()
      */
     public void setCompiler(String c) {
@@ -672,7 +672,7 @@ public class JspC implements Options {
 
     /**
      * Sets the compiler target VM.
-     * 
+     *
      * @see Options#getCompilerTargetVM()
      */
     public void setCompilerTargetVM(String vm) {
@@ -689,7 +689,7 @@ public class JspC implements Options {
 
      /**
       * Sets the compiler source VM.
-      * 
+      *
       * @see Options#getCompilerSourceVM()
       */
     public void setCompilerSourceVM(String vm) {
@@ -906,11 +906,11 @@ public class JspC implements Options {
 
     /**
      * Sets the encoding to be used to read and write web.xml files.
-     * 
+     *
      * <p>
      * If not specified, defaults to the platform default encoding.
      * </p>
-     * 
+     *
      * @param encoding
      *            Encoding, e.g. "UTF-8".
      */
@@ -921,7 +921,7 @@ public class JspC implements Options {
     /**
      * Sets the option to merge generated web.xml fragment into the
      * WEB-INF/web.xml file of the web application that we were processing.
-     * 
+     *
      * @param b
      *            <code>true</code> to merge the fragment into the existing
      *            web.xml file of the processed web application
@@ -966,7 +966,7 @@ public class JspC implements Options {
     /**
      * Adds servlet declaration and mapping for the JSP page servlet to the
      * generated web.xml fragment.
-     * 
+     *
      * @param file
      *            Context-relative path to the JSP file, e.g.
      *            <code>/index.jsp</code>
@@ -1097,21 +1097,21 @@ public class JspC implements Options {
         if(!webXml2.delete() && log.isDebugEnabled())
             log.debug(Localizer.getMessage("jspc.delete.fail",
                     webXml2.toString()));
-        
+
         if (!(new File(webxmlFile)).delete() && log.isDebugEnabled())
             log.debug(Localizer.getMessage("jspc.delete.fail", webxmlFile));
 
     }
-    
+
     /*
      * Assumes valid xml
      */
     private String getElement(Reader reader) throws IOException {
         StringBuilder result = new StringBuilder();
         result.append('<');
-        
+
         boolean done = false;
-        
+
         while (!done) {
             int current = reader.read();
             while (current != '>') {
@@ -1122,7 +1122,7 @@ public class JspC implements Options {
                 current = reader.read();
             }
             result.append((char) current);
-            
+
             int len = result.length();
             if (len > 4 && result.substring(0, 4).equals("<!--")) {
                 // This is a comment - make sure we are at the end
@@ -1133,8 +1133,8 @@ public class JspC implements Options {
                 done = true;
             }
         }
-        
-        
+
+
         return result.toString();
     }
 

==================================================
AntCompiler.java
index 55c0a00048..fb8c1eba9a 100644
--- a/java/org/apache/jasper/Options.java
+++ b/java/org/apache/jasper/Options.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -27,7 +27,7 @@ import org.apache.jasper.compiler.TagPluginManager;
 import org.apache.jasper.compiler.TldLocationsCache;
 
 /**
- * A class to hold all init parameters specific to the JSP engine. 
+ * A class to hold all init parameters specific to the JSP engine.
  *
  * @author Anil K. Vijendran
  * @author Hans Bergsten
@@ -116,7 +116,7 @@ public interface Options {
 
     /**
      * Compiler to use.
-     * 
+     *
      * <p>
      * If <code>null</code> (the default), the java compiler from Eclipse JDT
      * project, bundled with Tomcat, will be used. Otherwise, the
@@ -134,19 +134,19 @@ public interface Options {
     /**
      * The compiler source VM, e.g. 1.3, 1.4, 1.5 or 1.6.
      */
-    public String getCompilerSourceVM();   
+    public String getCompilerSourceVM();
 
     /**
      * Jasper Java compiler class to use.
      */
-    public String getCompilerClassName();   
+    public String getCompilerClassName();
 
     /**
      * The cache for the location of the TLD's
      * for the various tag libraries 'exposed'
      * by the web application.
-     * A tag library is 'exposed' either explicitly in 
-     * web.xml or implicitly via the uri tag in the TLD 
+     * A tag library is 'exposed' either explicitly in
+     * web.xml or implicitly via the uri tag in the TLD
      * of a taglib deployed in a jar file (WEB-INF/lib).
      *
      * @return the instance of the TldLocationsCache
@@ -162,7 +162,7 @@ public interface Options {
 
     /**
      * The boolean flag to tell Ant whether to fork JSP page compilations.
-     * 
+     *
      * <p>
      * Is used only when Jasper uses an external java compiler (wrapped through
      * a <code>javac</code> Apache Ant task).
@@ -170,7 +170,7 @@ public interface Options {
     public boolean getFork();
 
     /**
-     * Obtain JSP configuration information specified in web.xml.  
+     * Obtain JSP configuration information specified in web.xml.
      */
     public JspConfig getJspConfig();
 
@@ -186,48 +186,48 @@ public interface Options {
 
     /**
      * Indicates whether text strings are to be generated as char arrays.
-     * 
+     *
      * @return <code>true</code> if text strings are to be generated as char
      *         arrays, <code>false</code> otherwise
      */
     public boolean genStringAsCharArray();
-    
+
     /**
      * Modification test interval.
      */
     public int getModificationTestInterval();
-    
+
 
     /**
      * Re-compile on failure.
      */
     public boolean getRecompileOnFail();
-    
+
     /**
      * Is caching enabled (used for precompilation).
      */
     public boolean isCaching();
-    
+
     /**
      * The web-application wide cache for the TagLibraryInfo tag library
      * descriptors, used if {@link #isCaching()} returns <code>true</code>.
-     * 
+     *
      * <p>
      * Using this cache avoids the cost of repeating the parsing of a tag
      * library descriptor XML file (performed by TagLibraryInfoImpl.parseTLD).
      * </p>
-     * 
+     *
      * @return the Map(String uri, TagLibraryInfo tld) instance.
      */
     public Map<String, TagLibraryInfo> getCache();
-    
+
     /**
      * The maximum number of loaded jsps per web-application. If there are more
      * jsps loaded, they will be unloaded. If unset or less than 0, no jsps
      * are unloaded.
      */
     public int getMaxLoadedJsps();
-    
+
     /**
      * The idle time in seconds after which a JSP is unloaded.
      * If unset or less or equal than 0, no jsps are unloaded.

==================================================
AttributeParser.java
index c3d70712e5..15323b8aa6 100644
--- a/java/org/apache/jasper/compiler/AntCompiler.java
+++ b/java/org/apache/jasper/compiler/AntCompiler.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -48,7 +48,7 @@ import org.apache.tools.ant.types.PatternSet;
 public class AntCompiler extends Compiler {
 
     private final Log log = LogFactory.getLog(AntCompiler.class); // must not be static
-    
+
     protected static final Object javacLock = new Object();
 
     static {
@@ -64,10 +64,10 @@ public class AntCompiler extends Compiler {
 
     // Lazy eval - if we don't need to compile we probably don't need the project
     protected Project getProject() {
-        
+
         if (project != null)
             return project;
-        
+
         // Initializing project
         project = new Project();
         logger = new JasperAntLogger();
@@ -78,7 +78,7 @@ public class AntCompiler extends Compiler {
         if (System.getProperty(Constants.CATALINA_HOME_PROP) != null) {
             project.setBasedir(System.getProperty(Constants.CATALINA_HOME_PROP));
         }
-        
+
         if( options.getCompiler() != null ) {
             if( log.isDebugEnabled() )
                 log.debug("Compiler " + options.getCompiler() );
@@ -87,40 +87,40 @@ public class AntCompiler extends Compiler {
         project.init();
         return project;
     }
-    
+
     public static class JasperAntLogger extends DefaultLogger {
-        
+
         protected StringBuilder reportBuf = new StringBuilder();
-        
+
         @Override
         protected void printMessage(final String message,
                 final PrintStream stream,
                 final int priority) {
         }
-        
+
         @Override
         protected void log(String message) {
             reportBuf.append(message);
             reportBuf.append(Constants.NEWLINE);
         }
-        
+
         protected String getReport() {
             String report = reportBuf.toString();
             reportBuf.setLength(0);
             return report;
         }
     }
-    
+
     // --------------------------------------------------------- Public Methods
 
 
-    /** 
+    /**
      * Compile the servlet from .java file to .class file
      */
     @Override
     protected void generateClass(String[] smap)
         throws FileNotFoundException, JasperException, Exception {
-        
+
         long t1 = 0;
         if (log.isDebugEnabled()) {
             t1 = System.currentTimeMillis();
@@ -128,23 +128,23 @@ public class AntCompiler extends Compiler {
 
         String javaEncoding = ctxt.getOptions().getJavaEncoding();
         String javaFileName = ctxt.getServletJavaFileName();
-        String classpath = ctxt.getClassPath(); 
-        
+        String classpath = ctxt.getClassPath();
+
         String sep = System.getProperty("path.separator");
-        
+
         StringBuilder errorReport = new StringBuilder();
-        
+
         StringBuilder info=new StringBuilder();
         info.append("Compile: javaFileName=" + javaFileName + "\n" );
         info.append("    classpath=" + classpath + "\n" );
-        
+
         // Start capturing the System.err output for this thread
         SystemLogHandler.setThread();
-        
+
         // Initializing javac task
         getProject();
         Javac javac = (Javac) project.createTask("javac");
-        
+
         // Initializing classpath
         Path path = new Path(project);
         path.setPath(System.getProperty("java.class.path"));
@@ -156,17 +156,17 @@ public class AntCompiler extends Compiler {
             path.setLocation(repository);
             info.append("    cp=" + repository + "\n");
         }
-        
+
         if( log.isDebugEnabled() )
             log.debug( "Using classpath: " + System.getProperty("java.class.path") + sep
                     + classpath);
-        
+
         // Initializing sourcepath
         Path srcPath = new Path(project);
         srcPath.setLocation(options.getScratchDir());
-        
+
         info.append("    work dir=" + options.getScratchDir() + "\n");
-        
+
         // Initialize and set java extensions
         String exts = System.getProperty("java.ext.dirs");
         if (exts != null) {
@@ -181,7 +181,7 @@ public class AntCompiler extends Compiler {
         if(ctxt.getOptions().getFork()) {
             String endorsed = System.getProperty("java.endorsed.dirs");
             if(endorsed != null) {
-                Javac.ImplementationSpecificArgument endorsedArg = 
+                Javac.ImplementationSpecificArgument endorsedArg =
                     javac.createCompilerArg();
                 endorsedArg.setLine("-J-Djava.endorsed.dirs=" +
                         quotePathList(endorsed));
@@ -191,7 +191,7 @@ public class AntCompiler extends Compiler {
                 info.append("    no endorsed dirs specified\n");
             }
         }
-        
+
         // Configure the compiler object
         javac.setEncoding(javaEncoding);
         javac.setClasspath(path);
@@ -201,7 +201,7 @@ public class AntCompiler extends Compiler {
         javac.setOptimize(! ctxt.getOptions().getClassDebugInfo() );
         javac.setFork(ctxt.getOptions().getFork());
         info.append("    srcDir=" + srcPath + "\n" );
-        
+
         // Set the Java compiler to use
         if (options.getCompiler() != null) {
             javac.setCompiler(options.getCompiler());
@@ -217,15 +217,15 @@ public class AntCompiler extends Compiler {
             javac.setSource(options.getCompilerSourceVM());
             info.append("   compilerSourceVM=" + options.getCompilerSourceVM() + "\n");
         }
-        
+
         // Build includes path
         PatternSet.NameEntry includes = javac.createInclude();
-        
+
         includes.setName(ctxt.getJavaPath());
         info.append("    include="+ ctxt.getJavaPath() + "\n" );
-        
+
         BuildException be = null;
-        
+
         try {
             if (ctxt.getOptions().getFork()) {
                 javac.execute();
@@ -239,7 +239,7 @@ public class AntCompiler extends Compiler {
             log.error(Localizer.getMessage("jsp.error.javac"), e);
             log.error(Localizer.getMessage("jsp.error.javac.env") + info.toString());
         }
-        
+
         errorReport.append(logger.getReport());
 
         // Stop capturing the System.err output for this thread
@@ -253,7 +253,7 @@ public class AntCompiler extends Compiler {
             File javaFile = new File(javaFileName);
             javaFile.delete();
         }
-        
+
         if (be != null) {
             String errorReportString = errorReport.toString();
             log.error(Localizer.getMessage("jsp.error.compilation", javaFileName, errorReportString));
@@ -265,20 +265,20 @@ public class AntCompiler extends Compiler {
                 errDispatcher.javacError(errorReportString, be);
             }
         }
-        
+
         if( log.isDebugEnabled() ) {
             long t2 = System.currentTimeMillis();
             log.debug("Compiled " + ctxt.getServletJavaFileName() + " "
                       + (t2-t1) + "ms");
         }
-        
+
         logger = null;
         project = null;
-        
+
         if (ctxt.isPrototypeMode()) {
             return;
         }
-        
+
         // JSR45 Support
         if (! options.isSmapSuppressed()) {
             SmapUtil.installSmap(smap);

==================================================
BeanRepository.java
index 1d6d0e1f27..2c014302a5 100644
--- a/java/org/apache/jasper/compiler/AttributeParser.java
+++ b/java/org/apache/jasper/compiler/AttributeParser.java
@@ -28,7 +28,7 @@ package org.apache.jasper.compiler;
  */
 public class AttributeParser {
 
-    /* System property that controls if the strict quoting rules are applied. */ 
+    /* System property that controls if the strict quoting rules are applied. */
     private static final boolean STRICT_QUOTE_ESCAPING = Boolean.valueOf(
             System.getProperty(
                     "org.apache.jasper.compiler.Parser.STRICT_QUOTE_ESCAPING",
@@ -37,7 +37,7 @@ public class AttributeParser {
     /**
      * Parses the provided input String as a JSP attribute and returns an
      * unquoted value.
-     * 
+     *
      * @param input         The input.
      * @param quote         The quote character for the attribute or 0 for
      *                      scripting expressions.
@@ -59,7 +59,7 @@ public class AttributeParser {
     /**
      * Provided solely for unit test purposes and allows per call overriding of
      * the STRICT_QUOTE_ESCAPING system property.
-     * 
+     *
      * @param input         The input.
      * @param quote         The quote character for the attribute or 0 for
      *                      scripting expressions.
@@ -81,32 +81,32 @@ public class AttributeParser {
 
     /* The quoted input string. */
     private final String input;
-    
+
     /* The quote used for the attribute - null for scripting expressions. */
     private final char quote;
-    
+
     /* Is expression language being ignored - affects unquoting. \$ and \# are
      * treated as literals rather than quoted values. */
     private final boolean isELIgnored;
-    
+
     /* Are deferred expression treated as literals */
     private final boolean isDeferredSyntaxAllowedAsLiteral;
-    
+
     /* Overrides the STRICT_QUOTE_ESCAPING. Used for Unit tests only. */
     private final boolean strict;
-    
+
     /* The type ($ or #) of expression. Literals have a type of null. */
     private char type;
-    
+
     /* The length of the quoted input string. */
     private final int size;
-    
+
     /* Tracks the current position of the parser in the input String. */
     private int i = 0;
-    
+
     /* Indicates if the last character returned by nextChar() was escaped. */
     private boolean lastChEscaped = false;
-    
+
     /* The unquoted result. */
     private StringBuilder result;
 
@@ -258,7 +258,7 @@ public class AttributeParser {
     private char nextChar() {
         lastChEscaped = false;
         char ch = input.charAt(i);
-        
+
         if (ch == '&') {
             if (i + 5 < size && input.charAt(i + 1) == 'a' &&
                     input.charAt(i + 2) == 'p' && input.charAt(i + 3) == 'o' &&

==================================================
Compiler.java
index c702c211d4..e3cc96d77a 100644
--- a/java/org/apache/jasper/compiler/BeanRepository.java
+++ b/java/org/apache/jasper/compiler/BeanRepository.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,7 +22,7 @@ import java.util.HashMap;
 import org.apache.jasper.JasperException;
 
 /**
- * Repository of {page, request, session, application}-scoped beans 
+ * Repository of {page, request, session, application}-scoped beans
  *
  * @author Mandar Raje
  * @author Remy Maucherat
@@ -35,7 +35,7 @@ public class BeanRepository {
 
     /**
      * Constructor.
-     */    
+     */
     public BeanRepository(ClassLoader loader, ErrorDispatcher err) {
         this.loader = loader;
         this.errDispatcher = err;
@@ -45,14 +45,14 @@ public class BeanRepository {
     public void addBean(Node.UseBean n, String s, String type, String scope)
         throws JasperException {
 
-        if (!(scope == null || scope.equals("page") || scope.equals("request") 
+        if (!(scope == null || scope.equals("page") || scope.equals("request")
                 || scope.equals("session") || scope.equals("application"))) {
             errDispatcher.jspError(n, "jsp.error.usebean.badScope");
         }
 
         beanTypes.put(s, type);
     }
-            
+
     public Class<?> getBeanType(String bean)
         throws JasperException {
         Class<?> clazz = null;
@@ -63,7 +63,7 @@ public class BeanRepository {
         }
         return clazz;
     }
-      
+
     public boolean checkVariable(String bean) {
         return beanTypes.containsKey(bean);
     }

==================================================
DefaultErrorHandler.java
index 3772862f85..21712687df 100644
--- a/java/org/apache/jasper/compiler/Compiler.java
+++ b/java/org/apache/jasper/compiler/Compiler.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -39,7 +39,7 @@ import org.apache.juli.logging.LogFactory;
 
 /**
  * Main JSP compiler class. This class uses Ant for compiling.
- * 
+ *
  * @author Anil K. Vijendran
  * @author Mandar Raje
  * @author Pierre Delisle
@@ -48,7 +48,7 @@ import org.apache.juli.logging.LogFactory;
  * @author Mark Roth
  */
 public abstract class Compiler {
-    
+
     private final Log log = LogFactory.getLog(Compiler.class); // must not be static
 
     // ----------------------------------------------------- Instance Variables
@@ -90,7 +90,7 @@ public abstract class Compiler {
 
     /**
      * Compile the jsp file into equivalent servlet in .java file
-     * 
+     *
      * @return a smap for the current JSP page, if one is generated, null
      *         otherwise
      */
@@ -184,16 +184,16 @@ public abstract class Compiler {
              * solutions. We now use two passes to parse the translation unit.
              * The first just parses the directives and the second parses the
              * whole translation unit once we know how isELIgnored has been set.
-             * TODO There are some possible optimisations of this process.  
-             */ 
+             * TODO There are some possible optimisations of this process.
+             */
             // Parse the file
             ParserController parserCtl = new ParserController(ctxt, this);
-            
+
             // Pass 1 - the directives
             Node.Nodes directives =
                 parserCtl.parseDirectives(ctxt.getJspFile());
             Validator.validateDirectives(this, directives);
-            
+
             // Pass 2 - the whole translation unit
             pageNodes = parserCtl.parse(ctxt.getJspFile());
 
@@ -343,7 +343,7 @@ public abstract class Compiler {
     /**
      * Compile the jsp file from the current engine context. As an side- effect,
      * tag files that are referenced by this page are also compiled.
-     * 
+     *
      * @param compileClass
      *            If true, generate both .java and .class file If false,
      *            generate only .java file
@@ -356,7 +356,7 @@ public abstract class Compiler {
     /**
      * Compile the jsp file from the current engine context. As an side- effect,
      * tag files that are referenced by this page are also compiled.
-     * 
+     *
      * @param compileClass
      *            If true, generate both .java and .class file If false,
      *            generate only .java file
@@ -430,7 +430,7 @@ public abstract class Compiler {
      * JSP page with that of the corresponding .class or .java file. If the page
      * has dependencies, the check is also extended to its dependents, and so
      * on. This method can by overridden by a subclasses of Compiler.
-     * 
+     *
      * @param checkClass
      *            If true, check against .class file, if false, check against
      *            .java file.

==================================================
Dumper.java
index 2b54e51ae8..fbdc35ba52 100644
--- a/java/org/apache/jasper/compiler/DefaultErrorHandler.java
+++ b/java/org/apache/jasper/compiler/DefaultErrorHandler.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -26,7 +26,7 @@ import org.apache.jasper.JasperException;
  * @author Jan Luehe
  */
 class DefaultErrorHandler implements ErrorHandler {
-    
+
     /*
      * Processes the given JSP parse error.
      *
@@ -44,7 +44,7 @@ class DefaultErrorHandler implements ErrorHandler {
                         Integer.toString(line), Integer.toString(column)) +
                 ") " + errMsg, ex);
     }
-    
+
     /*
      * Processes the given JSP parse error.
      *
@@ -55,7 +55,7 @@ class DefaultErrorHandler implements ErrorHandler {
     public void jspError(String errMsg, Exception ex) throws JasperException {
         throw new JasperException(errMsg, ex);
     }
-    
+
     /*
      * Processes the given javac compilation errors.
      *
@@ -64,18 +64,18 @@ class DefaultErrorHandler implements ErrorHandler {
      */
     @Override
     public void javacError(JavacErrorDetail[] details) throws JasperException {
-        
+
         if (details == null) {
             return;
         }
-        
+
         Object[] args = null;
         StringBuilder buf = new StringBuilder();
-        
+
         for (int i=0; i < details.length; i++) {
             if (details[i].getJspBeginLineNumber() >= 0) {
                 args = new Object[] {
-                        Integer.valueOf(details[i].getJspBeginLineNumber()), 
+                        Integer.valueOf(details[i].getJspBeginLineNumber()),
                         details[i].getJspFileName() };
                 buf.append(Constants.NEWLINE);
                 buf.append(Constants.NEWLINE);
@@ -102,7 +102,7 @@ class DefaultErrorHandler implements ErrorHandler {
         throw new JasperException(
                 Localizer.getMessage("jsp.error.unable.compile") + ": " + buf);
     }
-    
+
     /**
      * Processes the given javac error report and exception.
      *
@@ -112,9 +112,9 @@ class DefaultErrorHandler implements ErrorHandler {
     @Override
     public void javacError(String errorReport, Exception exception)
     throws JasperException {
-        
+
         throw new JasperException(
                 Localizer.getMessage("jsp.error.unable.compile"), exception);
     }
-    
+
 }

==================================================
ELFunctionMapper.java
index 980356645c..46ac5e8757 100644
--- a/java/org/apache/jasper/compiler/Dumper.java
+++ b/java/org/apache/jasper/compiler/Dumper.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -133,28 +133,28 @@ class Dumper {
             dumpBody(n);
             printString("</jsp:useBean>");
         }
-        
+
         @Override
         public void visit(Node.PlugIn n) throws JasperException {
             printAttributes("<jsp:plugin", n.getAttributes(), ">");
             dumpBody(n);
             printString("</jsp:plugin>");
         }
-        
+
         @Override
         public void visit(Node.ParamsAction n) throws JasperException {
             printAttributes("<jsp:params", n.getAttributes(), ">");
             dumpBody(n);
             printString("</jsp:params>");
         }
-        
+
         @Override
         public void visit(Node.ParamAction n) throws JasperException {
             printAttributes("<jsp:param", n.getAttributes(), ">");
             dumpBody(n);
             printString("</jsp:param>");
         }
-        
+
         @Override
         public void visit(Node.NamedAttribute n) throws JasperException {
             printAttributes("<jsp:attribute", n.getAttributes(), ">");
@@ -168,7 +168,7 @@ class Dumper {
             dumpBody(n);
             printString("</jsp:body>");
         }
-        
+
         @Override
         public void visit(Node.ELExpression n) throws JasperException {
             printString( "${" + n.getText() + "}" );
@@ -203,7 +203,7 @@ class Dumper {
 
     public static void dump(Node n) {
         try {
-            n.accept(new DumpVisitor());        
+            n.accept(new DumpVisitor());
         } catch (JasperException e) {
             e.printStackTrace();
         }

==================================================
ELNode.java
index a3aba09029..409e0429e1 100644
--- a/java/org/apache/jasper/compiler/ELFunctionMapper.java
+++ b/java/org/apache/jasper/compiler/ELFunctionMapper.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -46,7 +46,7 @@ public class ELFunctionMapper {
      *
      * @param page The current compilation unit.
      */
-    public static void map(Node.Nodes page) 
+    public static void map(Node.Nodes page)
                 throws JasperException {
 
         ELFunctionMapper map = new ELFunctionMapper();
@@ -69,7 +69,7 @@ public class ELFunctionMapper {
      * for functions, and if found functions mappers are created.
      */
     class ELFunctionVisitor extends Node.Visitor {
-        
+
         /**
          * Use a global name map to facilitate reuse of function maps.
          * The key used is prefix:function:uri.
@@ -148,7 +148,7 @@ public class ELFunctionMapper {
             doMap(n.getEL());
         }
 
-        private void doMap(Node.JspAttribute attr) 
+        private void doMap(Node.JspAttribute attr)
                 throws JasperException {
             if (attr != null) {
                 doMap(attr.getEL());
@@ -158,7 +158,7 @@ public class ELFunctionMapper {
         /**
          * Creates function mappers, if needed, from ELNodes
          */
-        private void doMap(ELNode.Nodes el) 
+        private void doMap(ELNode.Nodes el)
                 throws JasperException {
 
             // Only care about functions in ELNode's
@@ -195,7 +195,7 @@ public class ELFunctionMapper {
                 el.setMapName(decName);
                 return;
             }
-        
+
             // Generate declaration for the map statically
             decName = getMapName();
             ss.append("private static org.apache.jasper.runtime.ProtectedFunctionMapper " + decName + ";\n");
@@ -296,13 +296,13 @@ public class ELFunctionMapper {
         /**
          * Convert a binary class name into a canonical one that can be used
          * when generating Java source code.
-         * 
+         *
          * @param className Binary class name
          * @return          Canonical equivalent
          */
         private String getCanonicalName(String className) throws JasperException {
             Class<?> clazz;
-            
+
             ClassLoader tccl;
             if (Constants.IS_SECURITY_ENABLED) {
                 PrivilegedAction<ClassLoader> pa = new PrivilegedGetTccl();
@@ -319,7 +319,7 @@ public class ELFunctionMapper {
             return clazz.getCanonicalName();
         }
     }
-    
+
     private static class PrivilegedGetTccl
             implements PrivilegedAction<ClassLoader> {
 

==================================================
ELParser.java
index 0bd5971486..0cfe4129a7 100644
--- a/java/org/apache/jasper/compiler/ELNode.java
+++ b/java/org/apache/jasper/compiler/ELNode.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -238,7 +238,7 @@ abstract class ELNode {
         public String getMapName() {
             return mapName;
         }
-    
+
     }
 
     /*

==================================================
ErrorDispatcher.java
index 4a64b5603e..7e5f5d9ba9 100644
--- a/java/org/apache/jasper/compiler/ELParser.java
+++ b/java/org/apache/jasper/compiler/ELParser.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,12 +19,12 @@ package org.apache.jasper.compiler;
 
 /**
  * This class implements a parser for EL expressions.
- * 
+ *
  * It takes strings of the form xxx${..}yyy${..}zzz etc, and turn it into a
  * ELNode.Nodes.
- * 
+ *
  * Currently, it only handles text outside ${..} and functions in ${ ..}.
- * 
+ *
  * @author Kin-man Chung
  */
 
@@ -40,7 +40,7 @@ public class ELParser {
     private int index; // Current index of the expression
 
     private String expression; // The EL expression
-    
+
     private char type;
 
     private boolean escapeBS; // is '\' an escape char in text outside EL?
@@ -60,7 +60,7 @@ public class ELParser {
 
     /**
      * Parse an EL expression
-     * 
+     *
      * @param expression
      *            The input expression string of the form Char* ('${' Char*
      *            '}')* Char*
@@ -88,9 +88,9 @@ public class ELParser {
     /**
      * Parse an EL expression string '${...}'. Currently only separates the EL
      * into functions and everything else.
-     * 
+     *
      * @return An ELNode.Nodes representing the EL expression
-     * 
+     *
      * TODO: Can this be refactored to use the standard EL implementation?
      */
     private ELNode.Nodes parseEL() {
@@ -181,7 +181,7 @@ public class ELParser {
     /**
      * Skip until an EL expression ('${' || '#{') is reached, allowing escape
      * sequences '\\' and '\$' and '\#'.
-     * 
+     *
      * @return The text string up to the EL expression
      */
     private String skipUntilEL() {

==================================================
ErrorHandler.java
index f360487a7e..cdce48cd10 100644
--- a/java/org/apache/jasper/compiler/ErrorDispatcher.java
+++ b/java/org/apache/jasper/compiler/ErrorDispatcher.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -33,9 +33,9 @@ import org.xml.sax.SAXException;
  *
  * This class is also responsible for localizing any error codes before they
  * are passed on to the configured error handler.
- * 
+ *
  * In the case of a Java compilation error, the compiler error message is
- * parsed into an array of JavacErrorDetail instances, which is passed on to 
+ * parsed into an array of JavacErrorDetail instances, which is passed on to
  * the configured error handler.
  *
  * @author Jan Luehe
@@ -435,9 +435,9 @@ public class ErrorDispatcher {
         StringBuilder errMsgBuf = null;
         int lineNum = -1;
         JavacErrorDetail javacError = null;
-        
+
         BufferedReader reader = new BufferedReader(new StringReader(errMsg));
-        
+
         /*
          * Parse compilation errors. Each compilation error consists of a file
          * path and error line number, followed by a number of lines describing
@@ -445,52 +445,52 @@ public class ErrorDispatcher {
          */
         String line = null;
         while ((line = reader.readLine()) != null) {
-            
+
             /*
              * Error line number is delimited by set of colons.
              * Ignore colon following drive letter on Windows (fromIndex = 2).
              * XXX Handle deprecation warnings that don't have line info
              */
-            int beginColon = line.indexOf(':', 2); 
+            int beginColon = line.indexOf(':', 2);
             int endColon = line.indexOf(':', beginColon + 1);
             if ((beginColon >= 0) && (endColon >= 0)) {
                 if (javacError != null) {
                     // add previous error to error vector
                     errors.add(javacError);
                 }
-                
+
                 String lineNumStr = line.substring(beginColon + 1, endColon);
                 try {
                     lineNum = Integer.parseInt(lineNumStr);
                 } catch (NumberFormatException e) {
                     lineNum = -1;
                 }
-                
+
                 errMsgBuf = new StringBuilder();
-                
+
                 javacError = createJavacError(fname, page, errMsgBuf, lineNum);
             }
-            
+
             // Ignore messages preceding first error
             if (errMsgBuf != null) {
                 errMsgBuf.append(line);
                 errMsgBuf.append(Constants.NEWLINE);
             }
         }
-        
+
         // Add last error to error vector
         if (javacError != null) {
             errors.add(javacError);
-        } 
-        
+        }
+
         reader.close();
-        
+
         JavacErrorDetail[] errDetails = null;
         if (errors.size() > 0) {
             errDetails = new JavacErrorDetail[errors.size()];
             errors.toArray(errDetails);
         }
-        
+
         return errDetails;
     }
 
@@ -508,8 +508,8 @@ public class ErrorDispatcher {
     throws JasperException {
         return createJavacError(fname, page, errMsgBuf, lineNum, null);
     }
-    
-    
+
+
     /**
      * @param fname
      * @param page
@@ -551,7 +551,7 @@ public class ErrorDispatcher {
         } else {
             /*
              * javac error line number cannot be mapped to JSP page
-             * line number. For example, this is the case if a 
+             * line number. For example, this is the case if a
              * scriptlet is missing a closing brace, which causes
              * havoc with the try-catch-finally block that the code
              * generator places around all generated code: As a result

==================================================
Generator.java
index 36ad3aaf53..8b2f028173 100644
--- a/java/org/apache/jasper/compiler/ErrorHandler.java
+++ b/java/org/apache/jasper/compiler/ErrorHandler.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -21,7 +21,7 @@ import org.apache.jasper.JasperException;
 
 /**
  * Interface for handling JSP parse and javac compilation errors.
- * 
+ *
  * An implementation of this interface may be registered with the
  * ErrorDispatcher by setting the XXX initialization parameter in the JSP
  * page compiler and execution servlet in Catalina's web.xml file to the

==================================================
ImplicitTagLibraryInfo.java
index 1e4c191d13..d0e9efc6c1 100644
--- a/java/org/apache/jasper/compiler/Generator.java
+++ b/java/org/apache/jasper/compiler/Generator.java
@@ -89,7 +89,7 @@ class Generator {
     /* System property that controls if the requirement to have the object
      * used in jsp:getProperty action to be previously "introduced"
      * to the JSP processor (see JSP.5.3) is enforced.
-     */ 
+     */
     private static final boolean STRICT_GET_PROPERTY = Boolean.valueOf(
             System.getProperty(
                     "org.apache.jasper.compiler.Generator.STRICT_GET_PROPERTY",
@@ -104,7 +104,7 @@ class Generator {
     private ErrorDispatcher err;
 
     private BeanRepository beanInfo;
-    
+
     private Set<String> varInfoNames;
 
     private JspCompilationContext ctxt;
@@ -122,7 +122,7 @@ class Generator {
     private Vector<String> tagHandlerPoolNames;
 
     private GenBuffer charArrayBuffer;
-    
+
     private DateFormat timestampFormat;
 
     /**
@@ -297,7 +297,7 @@ class Generator {
 
                 if (!n.implementsSimpleTag()) {
                     String name = createTagHandlerPoolName(n.getPrefix(), n
-                            .getLocalName(), n.getAttributes(), 
+                            .getLocalName(), n.getAttributes(),
                             n.getNamedAttributeNodes(), n.hasEmptyBody());
                     n.setTagHandlerPoolName(name);
                     if (!names.contains(name)) {
@@ -1100,7 +1100,7 @@ class Generator {
                 msg.append(name);
                 msg.append(
                         "'. Name was not previously introduced as per JSP.5.3");
-                
+
                 throw new JasperException(msg.toString());
             }
 
@@ -1742,8 +1742,8 @@ class Generator {
                     }
                 }
             }
-            
-            
+
+
             if (n.implementsSimpleTag()) {
                 generateCustomDoTag(n, handlerInfo, tagHandlerVar);
             } else {
@@ -1794,7 +1794,7 @@ class Generator {
                 // restore previous writer
                 out = outSave;
             }
-            
+
         }
 
         private static final String DOUBLE_QUOTE = "\\\"";
@@ -2011,11 +2011,11 @@ class Generator {
                         caOut.print(quote(output));
                         caOut.println(".toCharArray();");
                     }
-    
+
                     n.setBeginJavaLine(out.getJavaLine());
                     out.printil("out.write(" + charArrayName + ");");
                     n.setEndJavaLine(out.getJavaLine());
-                    
+
                     textIndex = textIndex + len;
                 }
                 return;

==================================================
JDTCompiler.java
index 7c18ab7e2d..38494755dd 100644
--- a/java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java
+++ b/java/org/apache/jasper/compiler/ImplicitTagLibraryInfo.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -37,7 +37,7 @@ import org.apache.jasper.xmlparser.TreeNode;
 
 /**
  * Class responsible for generating an implicit tag library containing tag
- * handlers corresponding to the tag files in "/WEB-INF/tags/" or a 
+ * handlers corresponding to the tag files in "/WEB-INF/tags/" or a
  * subdirectory of it.
  *
  * @author Jan Luehe
@@ -108,7 +108,7 @@ class ImplicitTagLibraryInfo extends TagLibraryInfo {
                      * of the "imaginary" <tag-file> element
                      */
                     String suffix = path.endsWith(TAG_FILE_SUFFIX) ?
-                            TAG_FILE_SUFFIX : TAGX_FILE_SUFFIX; 
+                            TAG_FILE_SUFFIX : TAGX_FILE_SUFFIX;
                     String tagName = path.substring(path.lastIndexOf("/") + 1);
                     tagName = tagName.substring(0,
                             tagName.lastIndexOf(suffix));
@@ -118,12 +118,12 @@ class ImplicitTagLibraryInfo extends TagLibraryInfo {
                     try {
                         in = ctxt.getResourceAsStream(path);
                         if (in != null) {
-                            
+
                             // Add implicit TLD to dependency list
                             if (pi != null) {
                                 pi.addDependant(path, ctxt.getLastModified(path));
                             }
-                            
+
                             ParserUtils pu = new ParserUtils();
                             TreeNode tld = pu.parseXMLDocument(uri, in);
 
@@ -171,8 +171,8 @@ class ImplicitTagLibraryInfo extends TagLibraryInfo {
                     }
                 }
             }
-        }        
-        
+        }
+
     }
 
     /**

==================================================
JarResource.java
index 3435bc2be6..b18432eff7 100644
--- a/java/org/apache/jasper/compiler/JDTCompiler.java
+++ b/java/org/apache/jasper/compiler/JDTCompiler.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -54,7 +54,7 @@ import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
 
 /**
  * JDT class compiler. This compiler will load source dependencies from the
- * context classloader, reducing dramatically disk access during 
+ * context classloader, reducing dramatically disk access during
  * the compilation process.
  *
  * @author Cocoon2
@@ -63,8 +63,8 @@ import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
 public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
 
     private final Log log = LogFactory.getLog(JDTCompiler.class); // must not be static
-   
-    /** 
+
+    /**
      * Compile the servlet from .java file to .class file
      */
     @Override
@@ -75,19 +75,19 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
         if (log.isDebugEnabled()) {
             t1 = System.currentTimeMillis();
         }
-        
+
         final String sourceFile = ctxt.getServletJavaFileName();
         final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
         String packageName = ctxt.getServletPackageName();
-        final String targetClassName = 
-            ((packageName.length() != 0) ? (packageName + ".") : "") 
+        final String targetClassName =
+            ((packageName.length() != 0) ? (packageName + ".") : "")
                     + ctxt.getServletClassName();
         final ClassLoader classLoader = ctxt.getJspLoader();
         String[] fileNames = new String[] {sourceFile};
         String[] classNames = new String[] {targetClassName};
         final ArrayList<JavacErrorDetail> problemList =
             new ArrayList<JavacErrorDetail>();
-        
+
         class CompilationUnit implements ICompilationUnit {
 
             String className;
@@ -102,7 +102,7 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
             public char[] getFileName() {
                 return sourceFile.toCharArray();
             }
-            
+
             @Override
             public char[] getContents() {
                 char[] result = null;
@@ -110,13 +110,13 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
                 Reader reader = null;
                 try {
                     is = new FileInputStream(sourceFile);
-                     
+
                     reader = new BufferedReader(new InputStreamReader(is,
                             ctxt.getOptions().getJavaEncoding()));
                     char[] chars = new char[8192];
                     StringBuilder buf = new StringBuilder();
                     int count;
-                    while ((count = reader.read(chars, 0, 
+                    while ((count = reader.read(chars, 0,
                                                 chars.length)) > 0) {
                         buf.append(chars, 0, count);
                     }
@@ -138,7 +138,7 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
                 }
                 return result;
             }
-            
+
             @Override
             public char[] getMainTypeName() {
                 int dot = className.lastIndexOf('.');
@@ -147,10 +147,10 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
                 }
                 return className.toCharArray();
             }
-            
+
             @Override
             public char[][] getPackageName() {
-                StringTokenizer izer = 
+                StringTokenizer izer =
                     new StringTokenizer(className, ".");
                 char[][] result = new char[izer.countTokens()-1][];
                 for (int i = 0; i < result.length; i++) {
@@ -164,7 +164,7 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
         final INameEnvironment env = new INameEnvironment() {
 
                 @Override
-                public NameEnvironmentAnswer 
+                public NameEnvironmentAnswer
                     findType(char[][] compoundTypeName) {
                     String result = "";
                     String sep = "";
@@ -177,8 +177,8 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
                 }
 
                 @Override
-                public NameEnvironmentAnswer 
-                    findType(char[] typeName, 
+                public NameEnvironmentAnswer
+                    findType(char[] typeName,
                              char[][] packageName) {
                         String result = "";
                         String sep = "";
@@ -191,24 +191,24 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
                         result += new String(typeName);
                         return findType(result);
                 }
-                
+
                 private NameEnvironmentAnswer findType(String className) {
 
                     InputStream is = null;
                     try {
                         if (className.equals(targetClassName)) {
-                            ICompilationUnit compilationUnit = 
+                            ICompilationUnit compilationUnit =
                                 new CompilationUnit(sourceFile, className);
-                            return 
+                            return
                                 new NameEnvironmentAnswer(compilationUnit, null);
                         }
-                        String resourceName = 
+                        String resourceName =
                             className.replace('.', '/') + ".class";
                         is = classLoader.getResourceAsStream(resourceName);
                         if (is != null) {
                             byte[] classBytes;
                             byte[] buf = new byte[8192];
-                            ByteArrayOutputStream baos = 
+                            ByteArrayOutputStream baos =
                                 new ByteArrayOutputStream(buf.length);
                             int count;
                             while ((count = is.read(buf, 0, buf.length)) > 0) {
@@ -217,10 +217,10 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
                             baos.flush();
                             classBytes = baos.toByteArray();
                             char[] fileName = className.toCharArray();
-                            ClassFileReader classFileReader = 
-                                new ClassFileReader(classBytes, fileName, 
+                            ClassFileReader classFileReader =
+                                new ClassFileReader(classBytes, fileName,
                                                     true);
-                            return 
+                            return
                                 new NameEnvironmentAnswer(classFileReader, null);
                         }
                     } catch (IOException exc) {
@@ -244,13 +244,13 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
                         return false;
                     }
                     String resourceName = result.replace('.', '/') + ".class";
-                    InputStream is = 
+                    InputStream is =
                         classLoader.getResourceAsStream(resourceName);
                     return is == null;
                 }
 
                 @Override
-                public boolean isPackage(char[][] parentPackageName, 
+                public boolean isPackage(char[][] parentPackageName,
                                          char[] packageName) {
                     String result = "";
                     String sep = "";
@@ -279,7 +279,7 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
 
             };
 
-        final IErrorHandlingPolicy policy = 
+        final IErrorHandlingPolicy policy =
             DefaultErrorHandlingPolicies.proceedWithAllProblems();
 
         final Map<String,String> settings = new HashMap<String,String>();
@@ -307,7 +307,7 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
             } else if(opt.equals("1.2")) {
                 settings.put(CompilerOptions.OPTION_Source,
                              CompilerOptions.VERSION_1_2);
-            } else if(opt.equals("1.3")) { 
+            } else if(opt.equals("1.3")) {
                 settings.put(CompilerOptions.OPTION_Source,
                              CompilerOptions.VERSION_1_3);
             } else if(opt.equals("1.4")) {
@@ -332,7 +332,7 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
             settings.put(CompilerOptions.OPTION_Source,
                     CompilerOptions.VERSION_1_5);
         }
-        
+
         // Target JVM
         if(ctxt.getOptions().getCompilerTargetVM() != null) {
             String opt = ctxt.getOptions().getCompilerTargetVM();
@@ -342,7 +342,7 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
             } else if(opt.equals("1.2")) {
                 settings.put(CompilerOptions.OPTION_TargetPlatform,
                              CompilerOptions.VERSION_1_2);
-            } else if(opt.equals("1.3")) { 
+            } else if(opt.equals("1.3")) {
                 settings.put(CompilerOptions.OPTION_TargetPlatform,
                              CompilerOptions.VERSION_1_3);
             } else if(opt.equals("1.4")) {
@@ -376,9 +376,9 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
                     CompilerOptions.VERSION_1_5);
         }
 
-        final IProblemFactory problemFactory = 
+        final IProblemFactory problemFactory =
             new DefaultProblemFactory(Locale.getDefault());
-        
+
         final ICompilerRequestor requestor = new ICompilerRequestor() {
                 @Override
                 public void acceptResult(CompilationResult result) {
@@ -388,11 +388,11 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
                             for (int i = 0; i < problems.length; i++) {
                                 IProblem problem = problems[i];
                                 if (problem.isError()) {
-                                    String name = 
+                                    String name =
                                         new String(problems[i].getOriginatingFileName());
                                     try {
                                         problemList.add(ErrorDispatcher.createJavacError
-                                                (name, pageNodes, new StringBuilder(problem.getMessage()), 
+                                                (name, pageNodes, new StringBuilder(problem.getMessage()),
                                                         problem.getSourceLineNumber(), ctxt));
                                     } catch (JasperException e) {
                                         log.error("Error visiting node", e);
@@ -404,22 +404,22 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
                             ClassFile[] classFiles = result.getClassFiles();
                             for (int i = 0; i < classFiles.length; i++) {
                                 ClassFile classFile = classFiles[i];
-                                char[][] compoundName = 
+                                char[][] compoundName =
                                     classFile.getCompoundName();
                                 String className = "";
                                 String sep = "";
-                                for (int j = 0; 
+                                for (int j = 0;
                                      j < compoundName.length; j++) {
                                     className += sep;
                                     className += new String(compoundName[j]);
                                     sep = ".";
                                 }
                                 byte[] bytes = classFile.getBytes();
-                                String outFile = outputDir + "/" + 
+                                String outFile = outputDir + "/" +
                                     className.replace('.', '/') + ".class";
-                                FileOutputStream fout = 
+                                FileOutputStream fout =
                                     new FileOutputStream(outFile);
-                                BufferedOutputStream bos = 
+                                BufferedOutputStream bos =
                                     new BufferedOutputStream(fout);
                                 bos.write(bytes);
                                 bos.close();
@@ -431,7 +431,7 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
                 }
             };
 
-        ICompilationUnit[] compilationUnits = 
+        ICompilationUnit[] compilationUnits =
             new ICompilationUnit[classNames.length];
         for (int i = 0; i < compilationUnits.length; i++) {
             String className = classNames[i];
@@ -450,13 +450,13 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
             File javaFile = new File(ctxt.getServletJavaFileName());
             javaFile.delete();
         }
-    
+
         if (!problemList.isEmpty()) {
-            JavacErrorDetail[] jeds = 
+            JavacErrorDetail[] jeds =
                 problemList.toArray(new JavacErrorDetail[0]);
             errDispatcher.javacError(jeds);
         }
-        
+
         if( log.isDebugEnabled() ) {
             long t2=System.currentTimeMillis();
             log.debug("Compiled " + ctxt.getServletJavaFileName() + " "
@@ -471,8 +471,8 @@ public class JDTCompiler extends org.apache.jasper.compiler.Compiler {
         if (! options.isSmapSuppressed()) {
             SmapUtil.installSmap(smap);
         }
-        
+
     }
-    
-    
+
+
 }

==================================================
JarScannerFactory.java
index 23e262b7c1..ea738554e0 100644
--- a/java/org/apache/jasper/compiler/JarResource.java
+++ b/java/org/apache/jasper/compiler/JarResource.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,21 +22,21 @@ import java.net.URL;
 import java.util.jar.JarFile;
 
 public interface JarResource {
-       
-    /**     
+
+    /**
      * @return The JarFile for this resource. A new instance of JarFile
      *         should be returned on each call.
      * @throws IOException
      */
     JarFile getJarFile() throws IOException;
-       
-    /**     
-     * @return The URL of this resource. May or may not point 
-     *         to the actual Jar file.    
+
+    /**
+     * @return The URL of this resource. May or may not point
+     *         to the actual Jar file.
      */
     String getUrl();
-    
-    /**     
+
+    /**
      * @param name
      * @return The URL for the entry within this resource.
      */

==================================================
JarURLResource.java
index b8e824c290..29a58a2a40 100644
--- a/java/org/apache/jasper/compiler/JarScannerFactory.java
+++ b/java/org/apache/jasper/compiler/JarScannerFactory.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -36,7 +36,7 @@ public class JarScannerFactory {
      * ServletContext}. It is obtained via a context parameter.
      */
     public static JarScanner getJarScanner(ServletContext ctxt) {
-        JarScanner jarScanner = 
+        JarScanner jarScanner =
             (JarScanner) ctxt.getAttribute(JarScanner.class.getName());
         if (jarScanner == null) {
             ctxt.log(Localizer.getMessage("jsp.warning.noJarScanner"));

==================================================
JasperTagInfo.java
index 4ea16cf10f..3e073fbc41 100644
--- a/java/org/apache/jasper/compiler/JarURLResource.java
+++ b/java/org/apache/jasper/compiler/JarURLResource.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -24,17 +24,17 @@ import java.net.URL;
 import java.util.jar.JarFile;
 
 public class JarURLResource implements JarResource {
-    
+
     private String jarUrl;
-    
+
     public JarURLResource(URL jarURL) {
         this(jarURL.toExternalForm());
     }
-    
+
     public JarURLResource(String jarUrl) {
         this.jarUrl = jarUrl;
     }
-    
+
     @Override
     public JarFile getJarFile() throws IOException {
         URL jarFileUrl = new URL("jar:" + jarUrl + "!/");
@@ -43,12 +43,12 @@ public class JarURLResource implements JarResource {
         conn.connect();
         return conn.getJarFile();
     }
-       
+
     @Override
     public String getUrl() {
         return jarUrl;
     }
-    
+
     @Override
     public URL getEntry(String name) {
         try {

==================================================
JavacErrorDetail.java
index d8b91cc706..66eda03a6e 100644
--- a/java/org/apache/jasper/compiler/JasperTagInfo.java
+++ b/java/org/apache/jasper/compiler/JasperTagInfo.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -49,7 +49,7 @@ class JasperTagInfo extends TagInfo {
         super(tagName, tagClassName, bodyContent, infoString, taglib,
                 tagExtraInfo, attributeInfo, displayName, smallIcon, largeIcon,
                 tvi);
-        
+
         this.dynamicAttrsMapName = mapName;
     }
 

==================================================
JspConfig.java
index 6c6b96d2f4..071dc4345c 100644
--- a/java/org/apache/jasper/compiler/JavacErrorDetail.java
+++ b/java/org/apache/jasper/compiler/JavacErrorDetail.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -46,7 +46,7 @@ public class JavacErrorDetail {
     /**
      * Constructor.
      *
-     * @param javaFileName The name of the Java file in which the 
+     * @param javaFileName The name of the Java file in which the
      * compilation error occurred
      * @param javaLineNum The compilation error line number
      * @param errMsg The compilation error message
@@ -64,7 +64,7 @@ public class JavacErrorDetail {
     /**
      * Constructor.
      *
-     * @param javaFileName The name of the Java file in which the 
+     * @param javaFileName The name of the Java file in which the
      * compilation error occurred
      * @param javaLineNum The compilation error line number
      * @param jspFileName The name of the JSP file from which the Java source
@@ -80,37 +80,37 @@ public class JavacErrorDetail {
             int jspBeginLineNum,
             StringBuilder errMsg,
             JspCompilationContext ctxt) {
-        
+
         this(javaFileName, javaLineNum, errMsg);
         this.jspFileName = jspFileName;
         this.jspBeginLineNum = jspBeginLineNum;
-        
+
         if (jspBeginLineNum > 0 && ctxt != null) {
             InputStream is = null;
             FileInputStream  fis = null;
-            
+
             try {
                 // Read both files in, so we can inspect them
                 is = ctxt.getResourceAsStream(jspFileName);
                 String[] jspLines = readFile(is);
-    
+
                 fis = new FileInputStream(ctxt.getServletJavaFileName());
                 String[] javaLines = readFile(fis);
-    
+
                 if (jspLines.length < jspBeginLineNum) {
                     // Avoid ArrayIndexOutOfBoundsException
                     // Probably bug 48498 but could be some other cause
                     jspExtract = Localizer.getMessage("jsp.error.bug48498");
                     return;
                 }
-                
+
                 // If the line contains the opening of a multi-line scriptlet
                 // block, then the JSP line number we got back is probably
                 // faulty.  Scan forward to match the java line...
                 if (jspLines[jspBeginLineNum-1].lastIndexOf("<%") >
                     jspLines[jspBeginLineNum-1].lastIndexOf("%>")) {
                     String javaLine = javaLines[javaLineNum-1].trim();
-    
+
                     for (int i=jspBeginLineNum-1; i<jspLines.length; i++) {
                         if (jspLines[i].indexOf(javaLine) != -1) {
                             // Update jsp line number
@@ -119,13 +119,13 @@ public class JavacErrorDetail {
                         }
                     }
                 }
-    
+
                 // copy out a fragment of JSP to display to the user
                 StringBuilder fragment = new StringBuilder(1024);
                 int startIndex = Math.max(0, this.jspBeginLineNum-1-3);
                 int endIndex = Math.min(
                         jspLines.length-1, this.jspBeginLineNum-1+3);
-    
+
                 for (int i=startIndex;i<=endIndex; ++i) {
                     fragment.append(i+1);
                     fragment.append(": ");
@@ -133,7 +133,7 @@ public class JavacErrorDetail {
                     fragment.append(Constants.NEWLINE);
                 }
                 jspExtract = fragment.toString();
-    
+
             } catch (IOException ioe) {
                 // Can't read files - ignore
             } finally {
@@ -167,7 +167,7 @@ public class JavacErrorDetail {
 
     /**
      * Gets the compilation error line number.
-     * 
+     *
      * @return Compilation error line number
      */
     public int getJavaLineNumber() {
@@ -203,7 +203,7 @@ public class JavacErrorDetail {
     public String getErrorMessage() {
         return this.errMsg.toString();
     }
-    
+
     /**
      * Gets the extract of the JSP that corresponds to this message.
      *
@@ -212,7 +212,7 @@ public class JavacErrorDetail {
     public String getJspExtract() {
         return this.jspExtract;
     }
-    
+
     /**
      * Reads a text file from an input stream into a String[]. Used to read in
      * the JSP and generated Java file when generating error messages.

==================================================
JspDocumentParser.java
index 5add4d125c..e3be4ddeb1 100644
--- a/java/org/apache/jasper/compiler/JspConfig.java
+++ b/java/org/apache/jasper/compiler/JspConfig.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -76,7 +76,7 @@ public class JspConfig {
 
         try {
             webXml = new WebXml(ctxt);
-            
+
             TreeNode webApp = null;
             if (webXml.getInputSource() != null) {
                 ParserUtils pu = new ParserUtils();
@@ -233,7 +233,7 @@ public class JspConfig {
                             defaultIsELIgnored,
                             defaultIsScriptingInvalid,
                             null, null, null,
-                            defaultDeferedSyntaxAllowedAsLiteral, 
+                            defaultDeferedSyntaxAllowedAsLiteral,
                             defaultTrimDirectiveWhitespaces,
                             defaultDefaultContentType,
                             defaultBuffer,
@@ -439,7 +439,7 @@ public class JspConfig {
         }
 
         return new JspProperty(isXml, isELIgnored, isScriptingInvalid,
-                pageEncoding, includePreludes, includeCodas, 
+                pageEncoding, includePreludes, includeCodas,
                 isDeferedSyntaxAllowedAsLiteral, isTrimDirectiveWhitespaces,
                 defaultContentType, buffer, errorOnUndelcaredNamespace);
     }
@@ -532,7 +532,7 @@ public class JspConfig {
         public JspProperty(String isXml, String elIgnored,
                 String scriptingInvalid, String pageEncoding,
                 Vector<String> includePrelude, Vector<String> includeCoda,
-                String deferedSyntaxAllowedAsLiteral, 
+                String deferedSyntaxAllowedAsLiteral,
                 String trimDirectiveWhitespaces,
                 String defaultContentType,
                 String buffer,
@@ -574,23 +574,23 @@ public class JspConfig {
         public Vector<String> getIncludeCoda() {
             return includeCoda;
         }
-        
+
         public String isDeferedSyntaxAllowedAsLiteral() {
             return deferedSyntaxAllowedAsLiteral;
         }
-        
+
         public String isTrimDirectiveWhitespaces() {
             return trimDirectiveWhitespaces;
         }
-        
+
         public String getDefaultContentType() {
             return defaultContentType;
         }
-        
+
         public String getBuffer() {
             return buffer;
         }
-        
+
         public String isErrorOnUndeclaredNamespace() {
             return errorOnUndeclaredNamespace;
         }

==================================================
JspReader.java
index ef6ba2eea8..d33ffcc469 100644
--- a/java/org/apache/jasper/compiler/JspDocumentParser.java
+++ b/java/org/apache/jasper/compiler/JspDocumentParser.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -71,7 +71,7 @@ class JspDocumentParser
      * Outermost (in the nesting hierarchy) node whose body is declared to be
      * scriptless. If a node's body is declared to be scriptless, all its
      * nested nodes must be scriptless, too.
-     */ 
+     */
     private Node scriptlessBodyNode;
 
     private Locator locator;
@@ -242,7 +242,7 @@ class JspDocumentParser
      * Receives notification of the start of an element.
      *
      * This method assigns the given tag attributes to one of 3 buckets:
-     * 
+     *
      * - "xmlns" attributes that represent (standard or custom) tag libraries.
      * - "xmlns" attributes that do not represent tag libraries.
      * - all remaining attributes.
@@ -273,7 +273,7 @@ class JspDocumentParser
         }
 
         String currentPrefix = getPrefix(current.getQName());
-        
+
         // jsp:text must not have any subelements
         if (JSP_URI.equals(uri) && TEXT_ACTION.equals(current.getLocalName())
                 && "jsp".equals(currentPrefix)) {
@@ -288,7 +288,7 @@ class JspDocumentParser
         if (attrs != null) {
             /*
              * Notice that due to a bug in the underlying SAX parser, the
-             * attributes must be enumerated in descending order. 
+             * attributes must be enumerated in descending order.
              */
             boolean isTaglib = false;
             for (int i = attrs.getLength() - 1; i >= 0; i--) {
@@ -437,7 +437,7 @@ class JspDocumentParser
      * invoke this method with chunks of it.  This is a problem when we try
      * to determine if the text contains only whitespaces, or when we are
      * looking for an EL expression string.  Therefore it is necessary to
-     * buffer and concatenate the chunks and process the concatenated text 
+     * buffer and concatenate the chunks and process the concatenated text
      * later (at beginTag and endTag)
      *
      * @param buf The characters
@@ -669,7 +669,7 @@ class JspDocumentParser
                         if (!(child instanceof Node.NamedAttribute)) {
                             throw new SAXParseException(Localizer.getMessage(
                                     "jasper.error.emptybodycontent.nonempty",
-                                    current.qName), locator); 
+                                    current.qName), locator);
                         }
                     }
                 }
@@ -784,7 +784,7 @@ class JspDocumentParser
     }
 
     /*
-     * Receives notification of the start of a Namespace mapping. 
+     * Receives notification of the start of a Namespace mapping.
      */
     @Override
     public void startPrefixMapping(String prefix, String uri)
@@ -794,7 +794,7 @@ class JspDocumentParser
         if (directivesOnly && !(JSP_URI.equals(uri))) {
             return;
         }
-        
+
         try {
             taglibInfo = getTaglibInfo(prefix, uri);
         } catch (JasperException je) {
@@ -815,7 +815,7 @@ class JspDocumentParser
     }
 
     /*
-     * Receives notification of the end of a Namespace mapping. 
+     * Receives notification of the end of a Namespace mapping.
      */
     @Override
     public void endPrefixMapping(String prefix) throws SAXException {
@@ -1433,7 +1433,7 @@ class JspDocumentParser
         //factory.setFeature(
         //    "http://xml.org/sax/features/validation",
         //    validating);
-        
+
         // Configure the parser
         SAXParser saxParser = factory.newSAXParser();
         XMLReader xmlReader = saxParser.getXMLReader();

==================================================
JspRuntimeContext.java
index 09ae7405cf..67f63cbe1f 100644
--- a/java/org/apache/jasper/compiler/JspReader.java
+++ b/java/org/apache/jasper/compiler/JspReader.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -141,13 +141,13 @@ class JspReader {
     }
 
     /**
-     * @return JSP compilation context with which this JspReader is 
+     * @return JSP compilation context with which this JspReader is
      * associated
      */
     JspCompilationContext getJspCompilationContext() {
         return context;
     }
-    
+
     /**
      * Returns the file at the given position in the list.
      *
@@ -157,16 +157,16 @@ class JspReader {
     String getFile(final int fileid) {
         return sourceFiles.get(fileid);
     }
-       
+
     /**
      * Checks if the current file has more input.
      *
      * @return True if more reading is possible
      * @throws JasperException if an error occurs
-     */ 
+     */
     boolean hasMoreInput() throws JasperException {
         if (current.cursor >= current.stream.length) {
-            if (singleFile) return false; 
+            if (singleFile) return false;
             while (popFile()) {
                 if (current.cursor < current.stream.length) return true;
             }
@@ -174,15 +174,15 @@ class JspReader {
         }
         return true;
     }
-    
+
     int nextChar() throws JasperException {
         if (!hasMoreInput())
             return -1;
-        
+
         int ch = current.stream[current.cursor];
 
         current.cursor++;
-        
+
         if (ch == '\n') {
             current.line++;
             current.col = 0;
@@ -353,10 +353,10 @@ class JspReader {
         int limlen = limit.length();
         int ch;
         int prev = 'x';        // Doesn't matter
-        
+
     skip:
         for (ret = mark(), ch = nextChar() ; ch != -1 ;
-                 ret = mark(), prev = ch, ch = nextChar()) {            
+                 ret = mark(), prev = ch, ch = nextChar()) {
             if (ch == '\\' && prev == '\\') {
                 ch = 0;                // Double \ is not an escape char anymore
             }
@@ -372,7 +372,7 @@ class JspReader {
         }
         return null;
     }
-    
+
     /**
      * Skip until the given end tag is matched in the stream.
      * When returned, the context is positioned past the end of the tag.
@@ -407,22 +407,22 @@ class JspReader {
         StringBuilder StringBuilder = new StringBuilder();
         skipSpaces();
         StringBuilder.setLength(0);
-        
+
         if (!hasMoreInput()) {
             return "";
         }
 
         int ch = peekChar();
-        
+
         if (quoted) {
             if (ch == '"' || ch == '\'') {
 
                 char endQuote = ch == '"' ? '"' : '\'';
-                // Consume the open quote: 
+                // Consume the open quote:
                 ch = nextChar();
                 for (ch = nextChar(); ch != -1 && ch != endQuote;
                          ch = nextChar()) {
-                    if (ch == '\\') 
+                    if (ch == '\\')
                         ch = nextChar();
                     StringBuilder.append((char) ch);
                 }
@@ -472,7 +472,7 @@ class JspReader {
                     || ch == '/') {
                 return true;
             }
-            // Look for an end-of-comment or end-of-tag:                
+            // Look for an end-of-comment or end-of-tag:
             if (ch == '-') {
                 Mark mark = mark();
                 if (((ch = nextChar()) == '>')
@@ -508,7 +508,7 @@ class JspReader {
 
         return sourceFiles.size() - 1;
     }
-    
+
 
     /**
      * Unregister the source file.
@@ -532,7 +532,7 @@ class JspReader {
      * Push a file (and its associated Stream) on the file stack.  THe
      * current position in the current file is remembered.
      */
-    private void pushFile(String file, String encoding, 
+    private void pushFile(String file, String encoding,
                            InputStreamReader reader) throws JasperException {
 
         // Register the file
@@ -564,7 +564,7 @@ class JspReader {
                 caw.write(buf, 0, i);
             caw.close();
             if (current == null) {
-                current = new Mark(this, caw.toCharArray(), fileid, 
+                current = new Mark(this, caw.toCharArray(), fileid,
                                    getFile(fileid), master, encoding);
             } else {
                 current.pushStream(caw.toCharArray(), fileid, getFile(fileid),

==================================================
Localizer.java
index b2bc335963..325e072f37 100644
--- a/java/org/apache/jasper/compiler/JspRuntimeContext.java
+++ b/java/org/apache/jasper/compiler/JspRuntimeContext.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -154,12 +154,12 @@ public final class JspRuntimeContext {
 
         // If this web application context is running from a
         // directory, start the background compilation thread
-        String appBase = context.getRealPath("/");         
+        String appBase = context.getRealPath("/");
         if (!options.getDevelopment()
                 && appBase != null
                 && options.getCheckInterval() > 0) {
             lastCompileCheck = System.currentTimeMillis();
-        }                                            
+        }
 
         if (options.getMaxLoadedJsps() > 0) {
             jspQueue = new FastRemovalDequeue<JspServletWrapper>(options.getMaxLoadedJsps());
@@ -182,7 +182,7 @@ public final class JspRuntimeContext {
     private final Options options;
     private final ClassLoader parentClassLoader;
     private final PermissionCollection permissionCollection;
-    private final CodeSource codeSource;                    
+    private final CodeSource codeSource;
     private final String classpath;
     private volatile long lastCompileCheck = -1L;
     private volatile long lastJspQueueUpdate = System.currentTimeMillis();
@@ -195,7 +195,7 @@ public final class JspRuntimeContext {
     private Map<String, JspServletWrapper> jsps = new ConcurrentHashMap<String, JspServletWrapper>();
 
     /**
-     * Keeps JSP pages ordered by last access. 
+     * Keeps JSP pages ordered by last access.
      */
     private FastRemovalDequeue<JspServletWrapper> jspQueue = null;
 
@@ -254,7 +254,7 @@ public final class JspRuntimeContext {
         }
         return entry;
     }
-    
+
     /**
      * Push unloadHandle for JspServletWrapper to front of the queue.
      *
@@ -268,7 +268,7 @@ public final class JspRuntimeContext {
         }
         jspQueue.moveFirst(unloadHandle);
     }
-    
+
     /**
      * Returns the number of JSPs for which JspServletWrappers exist, i.e.,
      * the number of JSPs that have been loaded into the webapp.
@@ -310,7 +310,7 @@ public final class JspRuntimeContext {
 
     /**
      * Process a "destroy" event for this web application context.
-     */                                                        
+     */
     public void destroy() {
         Iterator<JspServletWrapper> servlets = jsps.values().iterator();
         while (servlets.hasNext()) {
@@ -390,7 +390,7 @@ public final class JspRuntimeContext {
         } else {
             return;
         }
-        
+
         Object [] wrappers = jsps.values().toArray();
         for (int i = 0; i < wrappers.length; i++ ) {
             JspServletWrapper jsw = (JspServletWrapper)wrappers[i];
@@ -440,13 +440,13 @@ public final class JspRuntimeContext {
 
         if (parentClassLoader instanceof URLClassLoader) {
             URL [] urls = ((URLClassLoader)parentClassLoader).getURLs();
-    
+
             for(int i = 0; i < urls.length; i++) {
                 // Tomcat 4 can use URL's other than file URL's,
                 // a protocol other than file: will generate a
                 // bad file system path, so only add file:
                 // protocol URL's to the classpath.
-                
+
                 if( urls[i].getProtocol().equals("file") ) {
                     cpath.append(urls[i].getFile()+sep);
                 }
@@ -490,7 +490,7 @@ public final class JspRuntimeContext {
         CodeSource source = null;
         PermissionCollection permissions = null;
         if( policy != null ) {
-            try {          
+            try {
                 // Get the permissions for the web app context
                 String docBase = context.getRealPath("/");
                 if( docBase == null ) {

==================================================
Mark.java
index f1075dddaf..eb428e7a02 100644
--- a/java/org/apache/jasper/compiler/Localizer.java
+++ b/java/org/apache/jasper/compiler/Localizer.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -32,7 +32,7 @@ import org.apache.jasper.util.ExceptionUtils;
 public class Localizer {
 
     private static ResourceBundle bundle = null;
-    
+
     static {
         try {
         bundle = ResourceBundle.getBundle(
@@ -51,7 +51,7 @@ public class Localizer {
      * localized error messages, it is used as the error message.
      *
      * @param errCode Error code to localize
-     * 
+     *
      * @return Localized error message
      */
     public static String getMessage(String errCode) {
@@ -63,7 +63,7 @@ public class Localizer {
         return errMsg;
     }
 
-    /* 
+    /*
      * Returns the localized error message corresponding to the given error
      * code.
      *
@@ -79,7 +79,7 @@ public class Localizer {
         return getMessage(errCode, new Object[] {arg});
     }
 
-    /* 
+    /*
      * Returns the localized error message corresponding to the given error
      * code.
      *
@@ -95,8 +95,8 @@ public class Localizer {
     public static String getMessage(String errCode, String arg1, String arg2) {
         return getMessage(errCode, new Object[] {arg1, arg2});
     }
-    
-    /* 
+
+    /*
      * Returns the localized error message corresponding to the given error
      * code.
      *
@@ -115,7 +115,7 @@ public class Localizer {
         return getMessage(errCode, new Object[] {arg1, arg2, arg3});
     }
 
-    /* 
+    /*
      * Returns the localized error message corresponding to the given error
      * code.
      *
@@ -157,7 +157,7 @@ public class Localizer {
             }
         } catch (MissingResourceException e) {
         }
-        
+
         return errMsg;
     }
 }

==================================================
Node.java
index 5cf66537b6..65534b0b8c 100644
--- a/java/org/apache/jasper/compiler/Mark.java
+++ b/java/org/apache/jasper/compiler/Mark.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -23,7 +23,7 @@ import java.util.Stack;
 import org.apache.jasper.JspCompilationContext;
 
 /**
- * Mark represents a point in the JSP input. 
+ * Mark represents a point in the JSP input.
  *
  * @author Anil K. Vijendran
  */
@@ -111,7 +111,7 @@ final class Mark {
 
     /**
      * Constructor
-     */    
+     */
     Mark(JspCompilationContext ctxt, String filename, int line, int col) {
 
         this.reader = null;
@@ -138,11 +138,11 @@ final class Mark {
      * @param inEncoding encoding of new file
      */
     public void pushStream(char[] inStream, int inFileId, String name,
-                           String inBaseDir, String inEncoding) 
+                           String inBaseDir, String inEncoding)
     {
         // store current state in stack
         includeStack.push(new IncludeState(cursor, line, col, fileId,
-                                           fileName, baseDir, 
+                                           fileName, baseDir,
                                            encoding, stream) );
 
         // set new variables
@@ -225,10 +225,10 @@ final class Mark {
     public boolean equals(Object other) {
         if (other instanceof Mark) {
             Mark m = (Mark) other;
-            return this.reader == m.reader && this.fileId == m.fileId 
-                && this.cursor == m.cursor && this.line == m.line 
+            return this.reader == m.reader && this.fileId == m.fileId
+                && this.cursor == m.cursor && this.line == m.line
                 && this.col == m.col;
-        } 
+        }
         return false;
     }
 
@@ -245,7 +245,7 @@ final class Mark {
         String baseDir;
         char[] stream = null;
 
-        IncludeState(int inCursor, int inLine, int inCol, int inFileId, 
+        IncludeState(int inCursor, int inLine, int inCol, int inFileId,
                      String name, String inBaseDir, String inEncoding,
                      char[] inStream) {
             cursor = inCursor;

==================================================
PageDataImpl.java
index 52859bba49..83925372f5 100644
--- a/java/org/apache/jasper/compiler/Node.java
+++ b/java/org/apache/jasper/compiler/Node.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -46,7 +46,7 @@ import org.xml.sax.Attributes;
 /**
  * An internal data representation of a JSP page or a JSP document (XML). Also
  * included here is a visitor class for traversing nodes.
- * 
+ *
  * @author Kin-man Chung
  * @author Jan Luehe
  * @author Shawn Bayern
@@ -104,7 +104,7 @@ abstract class Node implements TagConstants {
 
     /**
      * Constructor.
-     * 
+     *
      * @param start
      *            The location of the jsp page
      * @param parent
@@ -118,7 +118,7 @@ abstract class Node implements TagConstants {
 
     /**
      * Constructor for Nodes parsed from standard syntax.
-     * 
+     *
      * @param qName
      *            The action's qualified name
      * @param localName
@@ -142,7 +142,7 @@ abstract class Node implements TagConstants {
 
     /**
      * Constructor for Nodes parsed from XML syntax.
-     * 
+     *
      * @param qName
      *            The action's qualified name
      * @param localName
@@ -174,7 +174,7 @@ abstract class Node implements TagConstants {
 
     /*
      * Constructor.
-     * 
+     *
      * @param qName The action's qualified name @param localName The action's
      * local name @param text The text associated with this node @param start
      * The location of the jsp page @param parent The enclosing node
@@ -199,10 +199,10 @@ abstract class Node implements TagConstants {
 
     /*
      * Gets this Node's attributes.
-     * 
+     *
      * In the case of a Node parsed from standard syntax, this method returns
      * all the Node's attributes.
-     * 
+     *
      * In the case of a Node parsed from XML syntax, this method returns only
      * those attributes whose name does not start with xmlns.
      */
@@ -289,7 +289,7 @@ abstract class Node implements TagConstants {
     /**
      * Searches all subnodes of this node for jsp:attribute standard actions,
      * and returns that set of nodes as a Node.Nodes object.
-     * 
+     *
      * @return Possibly empty Node.Nodes object containing any jsp:attribute
      *         subnodes of this Node
      */
@@ -380,7 +380,7 @@ abstract class Node implements TagConstants {
     /**
      * Selects and invokes a method in the visitor class based on the node type.
      * This is abstract and should be overrode by the extending classes.
-     * 
+     *
      * @param v
      *            The visitor class
      */
@@ -426,7 +426,7 @@ abstract class Node implements TagConstants {
         /*
          * Flag indicating if the default page encoding is being used (only
          * applicable with standard syntax).
-         * 
+         *
          * True if the page does not provide a page directive with a
          * 'contentType' attribute (or the 'contentType' attribute doesn't have
          * a CHARSET value), the page does not provide a page directive with a
@@ -534,7 +534,7 @@ abstract class Node implements TagConstants {
         public Root getParentRoot() {
             return parentRoot;
         }
-        
+
         /**
          * Generates a new temporary variable name.
          */
@@ -544,7 +544,7 @@ abstract class Node implements TagConstants {
             } else {
                 return parentRoot.nextTemporaryVariableName();
             }
-            
+
         }
     }
 
@@ -594,7 +594,7 @@ abstract class Node implements TagConstants {
          * Parses the comma-separated list of class or package names in the
          * given attribute value and adds each component to this PageDirective's
          * vector of imported classes and packages.
-         * 
+         *
          * @param value
          *            A comma-separated string of imports.
          */
@@ -683,7 +683,7 @@ abstract class Node implements TagConstants {
          * Parses the comma-separated list of class or package names in the
          * given attribute value and adds each component to this PageDirective's
          * vector of imported classes and packages.
-         * 
+         *
          * @param value
          *            A comma-separated string of imports.
          */
@@ -834,7 +834,7 @@ abstract class Node implements TagConstants {
          * was stored as a String in the "text" field, whereas when this node
          * was created from a JSP document, its text was stored as one or more
          * TemplateText nodes in its body. This method handles either case.
-         * 
+         *
          * @return The text string
          */
         @Override
@@ -1755,13 +1755,13 @@ abstract class Node implements TagConstants {
         /*
          * Computes this custom tag's custom nesting level, which corresponds to
          * the number of times this custom tag is nested inside itself.
-         * 
+         *
          * Example:
-         * 
+         *
          * <g:h> <a:b> -- nesting level 0 <c:d> <e:f> <a:b> -- nesting level 1
          * <a:b> -- nesting level 2 </a:b> </a:b> <a:b> -- nesting level 1
          * </a:b> </e:f> </c:d> </a:b> </g:h>
-         * 
+         *
          * @return Custom tag's nesting level
          */
         private int makeCustomNestingLevel() {
@@ -1780,7 +1780,7 @@ abstract class Node implements TagConstants {
         /**
          * Returns true if this custom action has an empty body, and false
          * otherwise.
-         * 
+         *
          * A custom action is considered to have an empty body if the following
          * holds true: - getBody() returns null, or - all immediate children are
          * jsp:attribute actions, or - the action's jsp:body is empty.
@@ -1932,7 +1932,7 @@ abstract class Node implements TagConstants {
         public void setOmit(JspAttribute omit) {
             this.omit = omit;
         }
-        
+
         public JspAttribute getOmit() {
             return omit;
         }
@@ -2072,7 +2072,7 @@ abstract class Node implements TagConstants {
 
         /**
          * Add a source to Java line mapping
-         * 
+         *
          * @param srcLine
          *            The position of the source line, relative to the line at
          *            the start of this node. The corresponding java line is
@@ -2096,7 +2096,7 @@ abstract class Node implements TagConstants {
 
     /**
      * Represents attributes that can be request time expressions.
-     * 
+     *
      * Can either be a plain attribute, an attribute that represents a request
      * time expression value, or a named attribute (specified using the
      * jsp:attribute standard action).
@@ -2143,7 +2143,7 @@ abstract class Node implements TagConstants {
 
         /**
          * Allow node to validate itself
-         * 
+         *
          * @param ef
          * @param ctx
          * @throws ELException
@@ -2200,7 +2200,7 @@ abstract class Node implements TagConstants {
         }
 
         /**
-         * 
+         *
          * @return return true if there's TagAttributeInfo meaning we need to
          *         assign a ValueExpression
          */
@@ -2209,7 +2209,7 @@ abstract class Node implements TagConstants {
         }
 
         /**
-         * 
+         *
          * @return return true if there's TagAttributeInfo meaning we need to
          *         assign a MethodExpression
          */
@@ -2233,7 +2233,7 @@ abstract class Node implements TagConstants {
             }
             return "java.lang.Object";
         }
-        
+
         public String[] getParameterTypeNames() {
             if (this.tai != null) {
                 if (this.isDeferredMethodInput()) {
@@ -2257,7 +2257,7 @@ abstract class Node implements TagConstants {
 
         /**
          * Only makes sense if namedAttribute is false.
-         * 
+         *
          * @return the value for the attribute, or the expression string
          *         (stripped of "<%=", "%>", "%=", or "%" but containing "${"
          *         and "}" for EL expressions)
@@ -2268,7 +2268,7 @@ abstract class Node implements TagConstants {
 
         /**
          * Only makes sense if namedAttribute is true.
-         * 
+         *
          * @return the nodes that evaluate to the body of this attribute.
          */
         public NamedAttribute getNamedAttributeNode() {
@@ -2344,7 +2344,7 @@ abstract class Node implements TagConstants {
 
         /**
          * Appends a node to the list
-         * 
+         *
          * @param n
          *            The node to add
          */
@@ -2355,7 +2355,7 @@ abstract class Node implements TagConstants {
 
         /**
          * Removes the given node from the list.
-         * 
+         *
          * @param n
          *            The node to be removed
          */
@@ -2365,7 +2365,7 @@ abstract class Node implements TagConstants {
 
         /**
          * Visit the nodes in the list with the supplied visitor
-         * 
+         *
          * @param v
          *            The visitor used
          */

==================================================
PageInfo.java
index 665d74393d..9eab9f5111 100644
--- a/java/org/apache/jasper/compiler/PageDataImpl.java
+++ b/java/org/apache/jasper/compiler/PageDataImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -142,7 +142,7 @@ class PageDataImpl extends PageData implements TagConstants {
                      * 'jsp' prefix has been hijacked, that is, bound to a
                      * namespace other than the JSP namespace. This means that
                      * when adding an 'id' attribute to each element, we can't
-                     * use the 'jsp' prefix. Therefore, create a new prefix 
+                     * use the 'jsp' prefix. Therefore, create a new prefix
                      * (one that is unique across the translation unit) for use
                      * by the 'id' attribute, and bind it to the JSP namespace
                      */
@@ -342,7 +342,7 @@ class PageDataImpl extends PageData implements TagConstants {
     public void visit(Node.IncludeAction n) throws JasperException {
             appendTag(n);
         }
-    
+
         @Override
     public void visit(Node.ForwardAction n) throws JasperException {
             appendTag(n);
@@ -377,7 +377,7 @@ class PageDataImpl extends PageData implements TagConstants {
     public void visit(Node.UseBean n) throws JasperException {
             appendTag(n);
         }
-        
+
         @Override
     public void visit(Node.PlugIn n) throws JasperException {
             appendTag(n);
@@ -387,7 +387,7 @@ class PageDataImpl extends PageData implements TagConstants {
         public void visit(Node.NamedAttribute n) throws JasperException {
             appendTag(n);
         }
-        
+
         @Override
         public void visit(Node.JspBody n) throws JasperException {
             appendTag(n);
@@ -436,7 +436,7 @@ class PageDataImpl extends PageData implements TagConstants {
     public void visit(Node.VariableDirective n) throws JasperException {
             appendTag(n);
         }
-        
+
         @Override
     public void visit(Node.TemplateText n) throws JasperException {
             /*
@@ -585,7 +585,7 @@ class PageDataImpl extends PageData implements TagConstants {
             buf.append("  ").append("pageEncoding").append("=\"UTF-8\"\n");
             buf.append("  ").append("contentType").append("=\"");
             buf.append(compiler.getPageInfo().getContentType()).append("\"\n");
-            buf.append("/>\n");            
+            buf.append("/>\n");
         }
 
         /*
@@ -629,7 +629,7 @@ class PageDataImpl extends PageData implements TagConstants {
             buf.append("  ").append(jspIdPrefix).append(":id").append("=\"");
             buf.append(jspId++).append("\"\n");
             buf.append("  ").append("pageEncoding").append("=\"UTF-8\"\n");
-            buf.append("/>\n");            
+            buf.append("/>\n");
         }
 
         private void appendText(String text, boolean createJspTextElement) {
@@ -649,7 +649,7 @@ class PageDataImpl extends PageData implements TagConstants {
                 appendCDATA(text);
             }
         }
-        
+
         /*
          * Appends the given text as a CDATA section to the XML view, unless
          * the text has already been marked as CDATA.

==================================================
Parser.java
index 72508e5d97..8516e6aef7 100644
--- a/java/org/apache/jasper/compiler/PageInfo.java
+++ b/java/org/apache/jasper/compiler/PageInfo.java
@@ -69,10 +69,10 @@ class PageInfo {
 
     private boolean scriptless = false;
     private boolean scriptingInvalid = false;
-    
+
     private String isELIgnoredValue;
     private boolean isELIgnored = false;
-    
+
     // JSP 2.1
     private String deferredSyntaxAllowedAsLiteralValue;
     private boolean deferredSyntaxAllowedAsLiteral = false;
@@ -80,7 +80,7 @@ class PageInfo {
         ExpressionFactory.newInstance();
     private String trimDirectiveWhitespacesValue;
     private boolean trimDirectiveWhitespaces = false;
-    
+
     private String omitXmlDecl = null;
     private String doctypeName = null;
     private String doctypePublic = null;
@@ -632,7 +632,7 @@ class PageInfo {
 
         isELIgnoredValue = value;
     }
-    
+
     /*
      * deferredSyntaxAllowedAsLiteral
      */
@@ -653,7 +653,7 @@ class PageInfo {
 
         deferredSyntaxAllowedAsLiteralValue = value;
     }
-    
+
     /*
      * trimDirectiveWhitespaces
      */
@@ -694,7 +694,7 @@ class PageInfo {
     public Mark getNonCustomTagPrefix(String prefix) {
         return nonCustomTagPrefixMap.get(prefix);
     }
-    
+
     public String getDeferredSyntaxAllowedAsLiteral() {
         return deferredSyntaxAllowedAsLiteralValue;
     }
@@ -726,13 +726,13 @@ class PageInfo {
     public Set<String> getVarInfoNames() {
         return varInfoNames;
     }
-    
+
     public boolean isErrorOnUndeclaredNamespace() {
         return errorOnUndeclaredNamepsace;
     }
-    
+
     public void setErrorOnUndeclaredNamespace(
             boolean errorOnUndeclaredNamespace) {
-        this.errorOnUndeclaredNamepsace = errorOnUndeclaredNamespace; 
+        this.errorOnUndeclaredNamepsace = errorOnUndeclaredNamespace;
     }
 }

==================================================
ParserController.java
index d7be14c018..ddaa6d90ef 100644
--- a/java/org/apache/jasper/compiler/Parser.java
+++ b/java/org/apache/jasper/compiler/Parser.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -36,7 +36,7 @@ import org.xml.sax.helpers.AttributesImpl;
  * This class implements a parser for a JSP page (non-xml view). JSP page
  * grammar is included here for reference. The token '#' that appears in the
  * production indicates the current input token location in the production.
- * 
+ *
  * @author Kin-man Chung
  * @author Shawn Bayern
  * @author Mark Roth
@@ -77,7 +77,7 @@ class Parser implements TagConstants {
 
     /* System property that controls if the strict white space rules are
      * applied.
-     */ 
+     */
     private static final boolean STRICT_WHITESPACE = Boolean.valueOf(
             System.getProperty(
                     "org.apache.jasper.compiler.Parser.STRICT_WHITESPACE",
@@ -101,7 +101,7 @@ class Parser implements TagConstants {
 
     /**
      * The main entry for Parser
-     * 
+     *
      * @param pc
      *            The ParseController, use for getting other objects in compiler
      *            and for parsing included pages
@@ -267,12 +267,12 @@ class Parser implements TagConstants {
         String ret = null;
         try {
             char quote = watch.charAt(watch.length() - 1);
-            
+
             // If watch is longer than 1 character this is a scripting
             // expression and EL is always ignored
             boolean isElIgnored =
                 pageInfo.isELIgnored() || watch.length() > 1;
-            
+
             ret = AttributeParser.getUnquoted(reader.getText(start, stop),
                     quote, isElIgnored,
                     pageInfo.isDeferredSyntaxAllowedAsLiteral());
@@ -446,7 +446,7 @@ class Parser implements TagConstants {
      * Parses a directive with the following syntax: Directive ::= S? ( 'page'
      * PageDirective | 'include' IncludeDirective | 'taglib' TagLibDirective) S?
      * '%>'
-     * 
+     *
      * TagDirective ::= S? ('tag' PageDirective | 'include' IncludeDirective |
      * 'taglib' TagLibDirective) | 'attribute AttributeDirective | 'variable
      * VariableDirective S? '%>'
@@ -506,11 +506,11 @@ class Parser implements TagConstants {
 
     /*
      * Parses a directive with the following syntax:
-     * 
+     *
      * XMLJSPDirectiveBody ::= S? ( ( 'page' PageDirectiveAttrList S? ( '/>' | (
      * '>' S? ETag ) ) | ( 'include' IncludeDirectiveAttrList S? ( '/>' | ( '>'
      * S? ETag ) ) | <TRANSLATION_ERROR>
-     * 
+     *
      * XMLTagDefDirectiveBody ::= ( ( 'tag' TagDirectiveAttrList S? ( '/>' | (
      * '>' S? ETag ) ) | ( 'include' IncludeDirectiveAttrList S? ( '/>' | ( '>'
      * S? ETag ) ) | ( 'attribute' AttributeDirectiveAttrList S? ( '/>' | ( '>'
@@ -836,13 +836,13 @@ class Parser implements TagConstants {
 
     /*
      * For Include: StdActionContent ::= Attributes ParamBody
-     * 
+     *
      * ParamBody ::= EmptyBody | ( '>' S? ( '<jsp:attribute' NamedAttributes )? '<jsp:body'
      * (JspBodyParam | <TRANSLATION_ERROR> ) S? ETag ) | ( '>' S? Param* ETag )
-     * 
+     *
      * EmptyBody ::= '/>' | ( '>' ETag ) | ( '>' S? '<jsp:attribute'
      * NamedAttributes ETag )
-     * 
+     *
      * JspBodyParam ::= S? '>' Param* '</jsp:body>'
      */
     private void parseInclude(Node parent) throws JasperException {
@@ -963,23 +963,23 @@ class Parser implements TagConstants {
      * since the syntax is identical (the only thing that differs substantially
      * is how to process the body, and thus we accept the body type as a
      * parameter).
-     * 
+     *
      * OptionalBody ::= EmptyBody | ActionBody
-     * 
+     *
      * ScriptlessOptionalBody ::= EmptyBody | ScriptlessActionBody
-     * 
+     *
      * TagDependentOptionalBody ::= EmptyBody | TagDependentActionBody
-     * 
+     *
      * EmptyBody ::= '/>' | ( '>' ETag ) | ( '>' S? '<jsp:attribute'
      * NamedAttributes ETag )
-     * 
+     *
      * ActionBody ::= JspAttributeAndBody | ( '>' Body ETag )
-     * 
+     *
      * ScriptlessActionBody ::= JspAttributeAndBody | ( '>' ScriptlessBody ETag )
-     * 
+     *
      * TagDependentActionBody ::= JspAttributeAndBody | ( '>' TagDependentBody
      * ETag )
-     * 
+     *
      */
     private void parseOptionalBody(Node parent, String tag, String bodyType)
             throws JasperException {
@@ -1006,7 +1006,7 @@ class Parser implements TagConstants {
     /**
      * Attempts to parse 'JspAttributeAndBody' production. Returns true if it
      * matched, or false if not. Assumes EmptyBody is okay as well.
-     * 
+     *
      * JspAttributeAndBody ::= ( '>' # S? ( '<jsp:attribute' NamedAttributes )? '<jsp:body' (
      * JspBodyBody | <TRANSLATION_ERROR> ) S? ETag )
      */
@@ -1066,14 +1066,14 @@ class Parser implements TagConstants {
 
     /*
      * For Plugin: StdActionContent ::= Attributes PluginBody
-     * 
+     *
      * PluginBody ::= EmptyBody | ( '>' S? ( '<jsp:attribute' NamedAttributes )? '<jsp:body' (
      * JspBodyPluginTags | <TRANSLATION_ERROR> ) S? ETag ) | ( '>' S? PluginTags
      * ETag )
-     * 
+     *
      * EmptyBody ::= '/>' | ( '>' ETag ) | ( '>' S? '<jsp:attribute'
      * NamedAttributes ETag )
-     * 
+     *
      */
     private void parsePlugin(Node parent) throws JasperException {
         Attributes attrs = parseAttributes();
@@ -1157,24 +1157,24 @@ class Parser implements TagConstants {
 
     /*
      * # '<' CustomAction CustomActionBody
-     * 
+     *
      * CustomAction ::= TagPrefix ':' CustomActionName
-     * 
+     *
      * TagPrefix ::= Name
-     * 
+     *
      * CustomActionName ::= Name
-     * 
+     *
      * CustomActionBody ::= ( Attributes CustomActionEnd ) | <TRANSLATION_ERROR>
-     * 
+     *
      * Attributes ::= ( S Attribute )* S?
-     * 
+     *
      * CustomActionEnd ::= CustomActionTagDependent | CustomActionJSPContent |
      * CustomActionScriptlessContent
-     * 
+     *
      * CustomActionTagDependent ::= TagDependentOptionalBody
-     * 
+     *
      * CustomActionJSPContent ::= OptionalBody
-     * 
+     *
      * CustomActionScriptlessContent ::= ScriptlessOptionalBody
      */
     private boolean parseCustomTag(Node parent) throws JasperException {

==================================================
ScriptingVariabler.java
index 986ada9459..d040428ee9 100644
--- a/java/org/apache/jasper/compiler/ParserController.java
+++ b/java/org/apache/jasper/compiler/ParserController.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -73,7 +73,7 @@ class ParserController implements TagConstants {
      * Constructor
      */
     public ParserController(JspCompilationContext ctxt, Compiler compiler) {
-        this.ctxt = ctxt; 
+        this.ctxt = ctxt;
         this.compiler = compiler;
         this.err = compiler.getErrorDispatcher();
     }
@@ -94,7 +94,7 @@ class ParserController implements TagConstants {
     public Node.Nodes parse(String inFileName)
     throws FileNotFoundException, JasperException, IOException {
         // If we're parsing a packaged tag file or a resource included by it
-        // (using an include directive), ctxt.getTagFileJar() returns the 
+        // (using an include directive), ctxt.getTagFileJar() returns the
         // JAR file from which to read the tag file or included resource,
         // respectively.
         isTagFile = ctxt.isTagFile();
@@ -111,7 +111,7 @@ class ParserController implements TagConstants {
     public Node.Nodes parseDirectives(String inFileName)
     throws FileNotFoundException, JasperException, IOException {
         // If we're parsing a packaged tag file or a resource included by it
-        // (using an include directive), ctxt.getTagFileJar() returns the 
+        // (using an include directive), ctxt.getTagFileJar() returns the
         // JAR file from which to read the tag file or included resource,
         // respectively.
         isTagFile = ctxt.isTagFile();
@@ -139,7 +139,7 @@ class ParserController implements TagConstants {
     /**
      * Extracts tag file directive information from the given tag file.
      *
-     * This is invoked by the compiler 
+     * This is invoked by the compiler
      *
      * @param inFileName    The name of the tag file to be parsed.
      * @param jarResource The location of the tag file.
@@ -199,7 +199,7 @@ class ParserController implements TagConstants {
                 compiler.getPageInfo().addDependant(
                         jarResource.getEntry(entry).toString(),
                         Long.valueOf(jarFile.getEntry(entry).getTime()));
-                        
+
             }
         }
 
@@ -273,7 +273,7 @@ class ParserController implements TagConstants {
      *
      * @param absFileName The URI to match
      *
-     * @return The value of the <page-encoding> attribute of the 
+     * @return The value of the <page-encoding> attribute of the
      * jsp-property-group with matching URL pattern
      */
     private String getJspConfigPageEncoding(String absFileName)
@@ -354,7 +354,7 @@ class ParserController implements TagConstants {
                  * We need to be careful, because the page may be encoded in
                  * ISO-8859-1 (or something entirely different), and may
                  * contain byte sequences that will cause a UTF-8 converter to
-                 * throw exceptions. 
+                 * throw exceptions.
                  *
                  * It is safe to use a source encoding of ISO-8859-1 in this
                  * case, as there are no invalid byte sequences in ISO-8859-1,
@@ -376,11 +376,11 @@ class ParserController implements TagConstants {
 
         /*
          * At this point, 'isExternal' or 'isXml' is FALSE.
-         * Search for jsp:root action, in order to determine if we're dealing 
-         * with XML or standard syntax (unless we already know what we're 
+         * Search for jsp:root action, in order to determine if we're dealing
+         * with XML or standard syntax (unless we already know what we're
          * dealing with, i.e., when 'isExternal' is TRUE and 'isXml' is FALSE).
          * No check for XML prolog, since nothing prevents a page from
-         * outputting XML and still using JSP syntax (in this case, the 
+         * outputting XML and still using JSP syntax (in this case, the
          * XML prolog is treated as template text).
          */
         JspReader jspReader = null;
@@ -425,7 +425,7 @@ class ParserController implements TagConstants {
                 }
             }
         }
-        
+
     }
 
     /*
@@ -538,9 +538,9 @@ class ParserController implements TagConstants {
     private String resolveFileName(String inFileName) {
         String fileName = inFileName.replace('\\', '/');
         boolean isAbsolute = fileName.startsWith("/");
-        fileName = isAbsolute ? fileName 
+        fileName = isAbsolute ? fileName
                 : baseDirStack.peek() + fileName;
-        String baseDir = 
+        String baseDir =
             fileName.substring(0, fileName.lastIndexOf("/") + 1);
         baseDirStack.push(baseDir);
         return fileName;
@@ -601,7 +601,7 @@ class ParserController implements TagConstants {
                     && Character.isWhitespace(root.charAt(index))) {
                 index++;
             }
-            if (index < root.length() 
+            if (index < root.length()
                 && (root.charAt(index) == '"' || root.charAt(index) == '\'')) {
                 index++;
                 if (root.regionMatches(index, JSP_URI, 0, JSP_URI.length())) {

==================================================
ServletWriter.java
index 3249496bd4..0bb8f2c1b2 100644
--- a/java/org/apache/jasper/compiler/ScriptingVariabler.java
+++ b/java/org/apache/jasper/compiler/ScriptingVariabler.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -60,7 +60,7 @@ class ScriptingVariabler {
 
     /*
      * For every custom tag, determines the scripting variables it needs to
-     * declare. 
+     * declare.
      */
     static class ScriptingVariableVisitor extends Node.Visitor {
 
@@ -111,7 +111,7 @@ class ScriptingVariabler {
                         continue;
                     }
                     String varName = varInfos[i].getVarName();
-                    
+
                     Integer currentRange = scriptVars.get(varName);
                     if (currentRange == null ||
                             ownRange.compareTo(currentRange) > 0) {

==================================================
SmapGenerator.java
index 3a213860e6..5f3b11da01 100644
--- a/java/org/apache/jasper/compiler/ServletWriter.java
+++ b/java/org/apache/jasper/compiler/ServletWriter.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -19,7 +19,7 @@ package org.apache.jasper.compiler;
 import java.io.PrintWriter;
 
 /**
- * This is what is used to generate servlets. 
+ * This is what is used to generate servlets.
  *
  * @author Anil K. Vijendran
  * @author Kin-man Chung
@@ -34,7 +34,7 @@ public class ServletWriter {
 
     // The sink writer:
     PrintWriter writer;
-    
+
     // servlet line numbers start from 1
     private int javaLine = 1;
 
@@ -47,7 +47,7 @@ public class ServletWriter {
         writer.close();
     }
 
-    
+
     // -------------------- Access informations --------------------
 
     public int getJavaLine() {

==================================================
SmapStratum.java
index 97d4f3912b..13297ed44d 100644
--- a/java/org/apache/jasper/compiler/SmapGenerator.java
+++ b/java/org/apache/jasper/compiler/SmapGenerator.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -24,7 +24,7 @@ import java.util.List;
  * Represents a source map (SMAP), which serves to associate lines
  * of the input JSP file(s) to lines in the generated servlet in the
  * final .class file, according to the JSR-045 spec.
- * 
+ *
  * @author Shawn Bayern
  */
 public class SmapGenerator {

==================================================
SmapUtil.java
index a737c02e3e..183d07dd26 100644
--- a/java/org/apache/jasper/compiler/SmapStratum.java
+++ b/java/org/apache/jasper/compiler/SmapStratum.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -177,7 +177,7 @@ public class SmapStratum {
             System.out.print(li.toString());
         }
 */
-        //Incorporate each LineInfo into the previous LineInfo's 
+        //Incorporate each LineInfo into the previous LineInfo's
         //outputLineIncrement, if possible
         int i = 0;
         while (i < lineData.size() - 1) {
@@ -235,7 +235,7 @@ public class SmapStratum {
      *        carefully, and only when they uniquely identify a file.
      * @param inputLineCount the number of lines in the input to map
      *        (SMAP <tt>LineFileCount</tt>)
-     * @param outputStartLine starting line in the output file 
+     * @param outputStartLine starting line in the output file
      *        (SMAP <tt>OutputStartLine</tt>)
      * @param outputLineIncrement number of output lines to map to each
      *        input line (SMAP <tt>OutputLineIncrement</tt>).  <i>Given the
@@ -255,7 +255,7 @@ public class SmapStratum {
             throw new IllegalArgumentException(
                 "inputFileName: " + inputFileName);
 
-        //Jasper incorrectly SMAPs certain Nodes, giving them an 
+        //Jasper incorrectly SMAPs certain Nodes, giving them an
         //outputStartLine of 0.  This can cause a fatal error in
         //optimizeLineSection, making it impossible for Jasper to
         //compile the JSP.  Until we can fix the underlying

==================================================
TagConstants.java
index 9ab2a81213..a4e93aa104 100644
--- a/java/org/apache/jasper/compiler/SmapUtil.java
+++ b/java/org/apache/jasper/compiler/SmapUtil.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -36,7 +36,7 @@ import org.apache.jasper.JspCompilationContext;
 /**
  * Contains static utilities for generating SMAP data based on the
  * current version of Jasper.
- * 
+ *
  * @author Jayson Falkner
  * @author Shawn Bayern
  * @author Robert Field (inner SDEInstaller class)
@@ -76,7 +76,7 @@ public class SmapUtil {
 
         // set up our SMAP generator
         SmapGenerator g = new SmapGenerator();
-        
+
         /** Disable reading of input SMAP because:
             1. There is a bug here: getRealPath() is null if .jsp is in a jar
                Bugzilla 14660.
@@ -596,7 +596,7 @@ public class SmapUtil {
             int iInputStartLine = mark.getLineNumber();
             int iOutputStartLine = n.getBeginJavaLine();
             int iOutputLineIncrement = breakAtLF? 1: 0;
-            smap.addLineData(iInputStartLine, fileName, 1, iOutputStartLine, 
+            smap.addLineData(iInputStartLine, fileName, 1, iOutputStartLine,
                              iOutputLineIncrement);
 
             // Output additional mappings in the text
@@ -698,5 +698,5 @@ public class SmapUtil {
             return map;
         }
     }
-    
+
 }

==================================================
TagFileProcessor.java
index 373eb0e9de..432312d738 100644
--- a/java/org/apache/jasper/compiler/TagConstants.java
+++ b/java/org/apache/jasper/compiler/TagConstants.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
TagLibraryInfoImpl.java
index e575977880..4c36426a53 100644
--- a/java/org/apache/jasper/compiler/TagFileProcessor.java
+++ b/java/org/apache/jasper/compiler/TagFileProcessor.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -42,7 +42,7 @@ import org.apache.jasper.servlet.JspServletWrapper;
 /**
  * 1. Processes and extracts the directive info in a tag file. 2. Compiles and
  * loads tag files used in a JSP file.
- * 
+ *
  * @author Kin-man Chung
  */
 
@@ -240,7 +240,7 @@ class TagFileProcessor {
             if (deferredMethod && deferredValue) {
                 err.jspError(n, "jsp.error.deferredmethodandvalue");
             }
-            
+
             String attrName = n.getAttributeValue("name");
             boolean required = JspUtil.booleanValue(n
                     .getAttributeValue("required"));
@@ -267,7 +267,7 @@ class TagFileProcessor {
             } else {
                 if (type == null)
                     type = "java.lang.String";
-                
+
                 if (deferredValue) {
                     type = ValueExpression.class.getName();
                 } else if (deferredMethod) {
@@ -280,7 +280,7 @@ class TagFileProcessor {
                             || deferredValueSpecified || deferredValue)) {
                 err.jspError("jsp.error.invalid.version", path);
             }
-            
+
             TagAttributeInfo tagAttributeInfo = new TagAttributeInfo(attrName,
                     required, type, rtexprvalue, fragment, null, deferredValue,
                     deferredMethod, deferredValueType, deferredMethodSignature);
@@ -407,14 +407,14 @@ class TagFileProcessor {
         /**
          * Reports a translation error if names specified in attributes of
          * directives are not unique in this translation unit.
-         * 
+         *
          * The value of the following attributes must be unique. 1. 'name'
          * attribute of an attribute directive 2. 'name-given' attribute of a
          * variable directive 3. 'alias' attribute of variable directive 4.
          * 'dynamic-attributes' of a tag directive except that
          * 'dynamic-attributes' can (and must) have the same value when it
          * appears in multiple tag directives.
-         * 
+         *
          * Also, 'name-from' attribute of a variable directive cannot have the
          * same value as that from another variable directive.
          */
@@ -475,7 +475,7 @@ class TagFileProcessor {
      * in it. The method is used to obtain the info on the tag file, when the
      * handler that it represents is referenced. The tag file is not compiled
      * here.
-     * 
+     *
      * @param pc
      *            the current ParserController used in this compilation
      * @param name
@@ -483,7 +483,7 @@ class TagFileProcessor {
      * @param path
      *            the path for the tagfile
      * @param jarResource
-     *            the Jar resource containing the tag file 
+     *            the Jar resource containing the tag file
      * @param tagLibInfo
      *            the TagLibraryInfo object associated with this TagInfo
      * @return a TagInfo object assembled from the directives in the tag file.
@@ -520,7 +520,7 @@ class TagFileProcessor {
 
         JarResource tagJarResouce = null;
         if (tagFilePath.startsWith("/META-INF/")) {
-            tagJarResouce = 
+            tagJarResouce =
                 compiler.getCompilationContext().getTldLocation(
                         tagInfo.getTagLibrary().getURI()).getJarResource();
         }
@@ -676,7 +676,7 @@ class TagFileProcessor {
     /**
      * Removed the java and class files for the tag prototype generated from the
      * current compilation.
-     * 
+     *
      * @param classFileName
      *            If non-null, remove only the class file with with this name.
      */

==================================================
TagPluginManager.java
index df8f3276f7..5fb633c961 100644
--- a/java/org/apache/jasper/compiler/TagLibraryInfoImpl.java
+++ b/java/org/apache/jasper/compiler/TagLibraryInfoImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -53,7 +53,7 @@ import org.apache.juli.logging.LogFactory;
 
 /**
  * Implementation of the TagLibraryInfo class from the JSP spec.
- * 
+ *
  * @author Anil K. Vijendran
  * @author Mandar Raje
  * @author Pierre Delisle
@@ -66,7 +66,7 @@ class TagLibraryInfoImpl extends TagLibraryInfo implements TagConstants {
     private final Log log = LogFactory.getLog(TagLibraryInfoImpl.class);
 
     private JspCompilationContext ctxt;
-    
+
     private PageInfo pi;
 
     private ErrorDispatcher err;
@@ -200,7 +200,7 @@ class TagLibraryInfoImpl extends TagLibraryInfo implements TagConstants {
         Collection<TagLibraryInfo> coll = pi.getTaglibs();
         return coll.toArray(new TagLibraryInfo[0]);
     }
-    
+
     /*
      * @param ctxt The JSP compilation context @param uri The TLD's uri @param
      * in The TLD's input stream @param jarFileUrl The JAR file containing the
@@ -297,7 +297,7 @@ class TagLibraryInfoImpl extends TagLibraryInfo implements TagConstants {
 
     /*
      * @param uri The uri of the TLD @param ctxt The compilation context
-     * 
+     *
      * @return String array whose first element denotes the path to the TLD. If
      * the path to the TLD points to a jar file, then the second element denotes
      * the name of the TLD entry in the jar file, which is hardcoded to
@@ -432,11 +432,11 @@ class TagLibraryInfoImpl extends TagLibraryInfo implements TagConstants {
     /*
      * Parses the tag file directives of the given TagFile and turns them into a
      * TagInfo.
-     * 
+     *
      * @param elem The <tag-file> element in the TLD @param uri The location of
      * the TLD, in case the tag file is specified relative to it @param jarFile
      * The JAR file, in case the tag file is packaged in a JAR
-     * 
+     *
      * @return TagInfo corresponding to tag file directives
      */
     private TagFileInfo createTagFileInfo(TreeNode elem, JarResource jarResource)
@@ -457,8 +457,8 @@ class TagLibraryInfoImpl extends TagLibraryInfo implements TagConstants {
                 // Ignore <example> element: Bugzilla 33538
             } else if ("tag-extension".equals(tname)) {
                 // Ignore <tag-extension> element: Bugzilla 33538
-            } else if ("icon".equals(tname) 
-                    || "display-name".equals(tname) 
+            } else if ("icon".equals(tname)
+                    || "display-name".equals(tname)
                     || "description".equals(tname)) {
                 // Ignore these elements: Bugzilla 38015
             } else {
@@ -576,7 +576,7 @@ class TagLibraryInfoImpl extends TagLibraryInfo implements TagConstants {
             // translation time) the type is fixed at java.lang.String.
             type = "java.lang.String";
         }
-        
+
         return new TagAttributeInfo(name, required, type, rtexprvalue,
                 isFragment, null, deferredValue, deferredMethod, expectedType,
                 methodSignature);
@@ -728,7 +728,7 @@ class TagLibraryInfoImpl extends TagLibraryInfo implements TagConstants {
 
     /**
      * The instance (if any) for the TagLibraryValidator class.
-     * 
+     *
      * @return The TagLibraryValidator instance, if any.
      */
     public TagLibraryValidator getTagLibraryValidator() {
@@ -739,7 +739,7 @@ class TagLibraryInfoImpl extends TagLibraryInfo implements TagConstants {
      * Translation-time validation of the XML document associated with the JSP
      * page. This is a convenience method on the associated TagLibraryValidator
      * class.
-     * 
+     *
      * @param thePage
      *            The JSP page object
      * @return A string indicating whether the page is valid or not.

==================================================
TextOptimizer.java
index 63d324d401..2685ee552d 100644
--- a/java/org/apache/jasper/compiler/TagPluginManager.java
+++ b/java/org/apache/jasper/compiler/TagPluginManager.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -68,7 +68,7 @@ public class TagPluginManager {
         });
 
     }
- 
+
     private void init(ErrorDispatcher err) throws JasperException {
         if (initialized)
             return;
@@ -121,7 +121,7 @@ public class TagPluginManager {
     }
 
     /**
-     * Invoke tag plugin for the given custom tag, if a plugin exists for 
+     * Invoke tag plugin for the given custom tag, if a plugin exists for
      * the custom tag's tag handler.
      *
      * The given custom tag node will be manipulated by the plugin.
@@ -237,7 +237,7 @@ public class TagPluginManager {
 
         @Override
         public void generateBody() {
-            // Since we'll generate the body anyway, this is really a nop, 
+            // Since we'll generate the body anyway, this is really a nop,
             // except for the fact that it lets us put the Java sources the
             // plugins produce in the correct order (w.r.t the body).
             curNodes = node.getAtETag();

==================================================
TldLocation.java
index 3d74150175..5ce9623bec 100644
--- a/java/org/apache/jasper/compiler/TextOptimizer.java
+++ b/java/org/apache/jasper/compiler/TextOptimizer.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -81,7 +81,7 @@ public class TextOptimizer {
 
         @Override
         public void visit(Node.TemplateText n) throws JasperException {
-            if ((options.getTrimSpaces() || pageInfo.isTrimDirectiveWhitespaces()) 
+            if ((options.getTrimSpaces() || pageInfo.isTrimDirectiveWhitespaces())
                     && n.isAllSpace()) {
                 n.setText(EMPTY_TEXT);
                 return;
@@ -99,7 +99,7 @@ public class TextOptimizer {
 
         /**
          * This method breaks concatenation mode.  As a side effect it copies
-         * the concatenated string to the first text node 
+         * the concatenated string to the first text node
          */
         private void collectText() {
 

==================================================
TldLocationsCache.java
index 5e3f8154d9..521ca830d9 100644
--- a/java/org/apache/jasper/compiler/TldLocation.java
+++ b/java/org/apache/jasper/compiler/TldLocation.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,18 +18,18 @@
 package org.apache.jasper.compiler;
 
 public class TldLocation {
-    
+
     private String entryName;
     private JarResource jar;
-    
+
     public TldLocation(String entryName) {
         this(entryName, (JarResource)null);
     }
-    
+
     public TldLocation(String entryName, String resourceUrl) {
         this(entryName, getJarResource(resourceUrl));
     }
-    
+
     public TldLocation(String entryName, JarResource jarResource) {
         if (entryName == null) {
             throw new IllegalArgumentException("Tld name is required");
@@ -37,21 +37,21 @@ public class TldLocation {
         this.entryName = entryName;
         this.jar = jarResource;
     }
-        
+
     private static JarResource getJarResource(String resourceUrl) {
         return (resourceUrl != null) ? new JarURLResource(resourceUrl) : null;
     }
-    
+
     /**
      * @return The name of the tag library.
      */
     public String getName() {
         return entryName;
     }
-    
+
     /**
-     * 
-     * @return The jar resource the tag library is contained in. 
+     *
+     * @return The jar resource the tag library is contained in.
      *         Might return null if the tag library is not contained in jar resource.
      */
     public JarResource getJarResource() {

==================================================
Validator.java
index b54c0374ca..085a6eb265 100644
--- a/java/org/apache/jasper/compiler/TldLocationsCache.java
+++ b/java/org/apache/jasper/compiler/TldLocationsCache.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -45,7 +45,7 @@ import org.apache.tomcat.util.scan.JarFactory;
 /**
  * A container for all tag libraries that are defined "globally"
  * for the web application.
- * 
+ *
  * Tag Libraries can be defined globally in one of two ways:
  *   1. Via <taglib> elements in web.xml:
  *      the uri and location of the tag-library are specified in
@@ -112,9 +112,9 @@ public class TldLocationsCache {
     private volatile boolean initialized;
     private ServletContext ctxt;
 
-    /** Constructor. 
+    /** Constructor.
      *
-     * @param ctxt the servlet context of the web application in which Jasper 
+     * @param ctxt the servlet context of the web application in which Jasper
      * is running
      */
     public TldLocationsCache(ServletContext ctxt) {
@@ -126,8 +126,8 @@ public class TldLocationsCache {
     /**
      * Sets the list of JARs that are known not to contain any TLDs.
      *
-     * @param jarNames List of comma-separated names of JAR files that are 
-     * known not to contain any TLDs 
+     * @param jarNames List of comma-separated names of JAR files that are
+     * known not to contain any TLDs
      */
     public static void setNoTldJars(String jarNames) {
         if (jarNames == null) {
@@ -170,7 +170,7 @@ public class TldLocationsCache {
      * in the web application. A tag library is 'exposed' either explicitly in
      * web.xml or implicitly via the uri tag in the TLD of a taglib deployed
      * in a jar file (WEB-INF/lib).
-     * 
+     *
      * @param uri The taglib uri
      *
      * @return An array of two Strings: The first element denotes the real
@@ -186,7 +186,7 @@ public class TldLocationsCache {
         return mappings.get(uri);
     }
 
-    /** 
+    /**
      * Returns the type of a URI:
      *     ABS_URI
      *     ROOT_REL_URI
@@ -207,7 +207,7 @@ public class TldLocationsCache {
      *
      * This supports a Tomcat-specific extension to the TLD search
      * order defined in the JSP spec. It allows tag libraries packaged as JAR
-     * files to be shared by web applications by simply dropping them in a 
+     * files to be shared by web applications by simply dropping them in a
      * location that all web applications have access to (e.g.,
      * <CATALINA_HOME>/lib). It also supports some of the weird and
      * wonderful arrangements present when Tomcat gets embedded.
@@ -218,7 +218,7 @@ public class TldLocationsCache {
         try {
             tldScanWebXml();
             tldScanResourcePaths(WEB_INF);
-            
+
             JarScanner jarScanner = JarScannerFactory.getJarScanner(ctxt);
             if (jarScanner != null) {
                 jarScanner.scan(ctxt,
@@ -251,11 +251,11 @@ public class TldLocationsCache {
 
     /*
      * Populates taglib map described in web.xml.
-     * 
+     *
      * This is not kept in sync with o.a.c.startup.TldConfig as the Jasper only
      * needs the URI to TLD mappings from scan web.xml whereas TldConfig needs
      * to scan the actual TLD files.
-     */    
+     */
     private void tldScanWebXml() throws Exception {
 
         WebXml webXml = null;
@@ -317,7 +317,7 @@ public class TldLocationsCache {
      * Initially, rootPath equals /WEB-INF/. The /WEB-INF/classes and
      * /WEB-INF/lib sub-directories are excluded from the search, as per the
      * JSP 2.0 spec.
-     * 
+     *
      * Keep code in sync with o.a.c.startup.TldConfig
      */
     private void tldScanResourcePaths(String startPath)
@@ -397,7 +397,7 @@ public class TldLocationsCache {
      * map for any TLD that has a <uri> element.
      *
      * @param jarConn The JarURLConnection to the JAR file to scan
-     * 
+     *
      * Keep in sync with o.a.c.startup.TldConfig
      */
     private void tldScanJar(JarURLConnection jarConn) throws IOException {
@@ -405,13 +405,13 @@ public class TldLocationsCache {
         Jar jar = null;
         InputStream is;
         boolean foundTld = false;
-        
+
         URL resourceURL = jarConn.getJarFileURL();
         String resourcePath = resourceURL.toString();
-        
+
         try {
             jar = JarFactory.newInstance(jarConn.getURL());
-            
+
             jar.nextEntry();
             String entryName = jar.getEntryName();
             while (entryName != null) {
@@ -457,7 +457,7 @@ public class TldLocationsCache {
     /*
      * Scan the TLD contents in the specified input stream and add any new URIs
      * to the map.
-     * 
+     *
      * @param resourcePath  Path of the resource
      * @param entryName     If the resource is a JAR file, the name of the entry
      *                      in the JAR file

==================================================
WebXml.java
index ce6ee9f3b9..e5c289f6da 100644
--- a/java/org/apache/jasper/compiler/Validator.java
+++ b/java/org/apache/jasper/compiler/Validator.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -45,7 +45,7 @@ import org.xml.sax.Attributes;
  * mandatory presence, entry value validity, and consistency. As a side effect,
  * some page global value (such as those from page directives) are stored, for
  * later use.
- * 
+ *
  * @author Kin-man Chung
  * @author Jan Luehe
  * @author Shawn Bayern
@@ -320,10 +320,10 @@ class Validator {
         /*
          * Compares page encodings specified in various places, and throws
          * exception in case of page encoding mismatch.
-         * 
+         *
          * @param pageDirEnc The value of the pageEncoding attribute of the page
          * directive @param pageDir The page directive node
-         * 
+         *
          * @throws JasperException in case of page encoding mismatch
          */
         private String comparePageEncodings(String thePageDirEnc,
@@ -371,17 +371,17 @@ class Validator {
                     return pageEnc;
                 }
             }
-            
+
             return pageDirEnc;
         }
-        
+
         /*
          * Compares page encodings specified in various places, and throws
          * exception in case of page encoding mismatch.
-         * 
+         *
          * @param thePageDirEnc The value of the pageEncoding attribute of the page
          * directive @param pageDir The page directive node
-         * 
+         *
          * @throws JasperException in case of page encoding mismatch
          */
         private void compareTagEncodings(String thePageDirEnc,
@@ -780,7 +780,7 @@ class Validator {
             if (value == null) {
                 return false;
             }
-            
+
             int i = 0;
             int len = value.length();
             boolean prevCharIsEscape = false;
@@ -1043,19 +1043,19 @@ class Validator {
         /*
          * Make sure the given custom action does not have any invalid
          * attributes.
-         * 
+         *
          * A custom action and its declared attributes always belong to the same
          * namespace, which is identified by the prefix name of the custom tag
          * invocation. For example, in this invocation:
-         * 
+         *
          * <my:test a="1" b="2" c="3"/>, the action
-         * 
+         *
          * "test" and its attributes "a", "b", and "c" all belong to the
          * namespace identified by the prefix "my". The above invocation would
          * be equivalent to:
-         * 
+         *
          * <my:test my:a="1" my:b="2" my:c="3"/>
-         * 
+         *
          * An action attribute may have a prefix different from that of the
          * action invocation only if the underlying tag handler supports dynamic
          * attributes, in which case the attribute with the different prefix is
@@ -1074,7 +1074,7 @@ class Validator {
 
             for (int i = 0; attrs != null && i < attrs.getLength(); i++) {
                 boolean found = false;
-                
+
                 boolean runtimeExpression = ((n.getRoot().isXmlSyntax() && attrs.getValue(i).startsWith("%="))
                         || (!n.getRoot().isXmlSyntax() && attrs.getValue(i).startsWith("<%=")));
                 boolean elExpression = false;
@@ -1122,7 +1122,7 @@ class Validator {
                         TagAttributeInfo tldAttr = tldAttrs[j];
                         if (tldAttr.canBeRequestTime()
                                 || tldAttr.isDeferredMethod() || tldAttr.isDeferredValue()) { // JSP 2.1
-                            
+
                             if (!expression) {
 
                                 String expectedType = null;
@@ -1202,12 +1202,12 @@ class Validator {
                                     err.jspError(n, "jsp.error.attribute.custom.non_rt_with_expr",
                                             tldAttr.getName());
                                 }
-                                
+
                                 if (elExpression) {
                                     // El expression
                                     validateFunctions(el, n);
                                     jspAttrs[i] = new Node.JspAttribute(tldAttr,
-                                            attrs.getQName(i), attrs.getURI(i), 
+                                            attrs.getQName(i), attrs.getURI(i),
                                             attrs.getLocalName(i),
                                             attrs.getValue(i), false, el, false);
                                     ELContextImpl ctx = new ELContextImpl();
@@ -1216,7 +1216,7 @@ class Validator {
                                         jspAttrs[i].validateEL(this.pageInfo.getExpressionFactory(), ctx);
                                     } catch (ELException e) {
                                         this.err.jspError(n.getStart(),
-                                                "jsp.error.invalid.expression", 
+                                                "jsp.error.invalid.expression",
                                                 attrs.getValue(i), e.toString());
                                     }
                                 } else {
@@ -1227,7 +1227,7 @@ class Validator {
                                             .getValue(i), n, false);
                                 }
                             }
-                            
+
                         } else {
                             // Attribute does not accept any expressions.
                             // Make sure its value does not contain any.
@@ -1269,7 +1269,7 @@ class Validator {
          * attributes
          */
         private void checkNamedAttributes(Node.CustomTag n,
-                Node.JspAttribute[] jspAttrs, int start, 
+                Node.JspAttribute[] jspAttrs, int start,
                 Hashtable<String, Object> tagDataAttrs)
                 throws JasperException {
 
@@ -1421,7 +1421,7 @@ class Validator {
          * expression.
          */
         private boolean isExpression(Node n, String value, boolean checkDeferred) {
-            
+
             boolean runtimeExpression = ((n.getRoot().isXmlSyntax() && value.startsWith("%="))
                     || (!n.getRoot().isXmlSyntax() && value.startsWith("<%=")));
             boolean elExpression = false;
@@ -1434,7 +1434,7 @@ class Validator {
                     if (node instanceof ELNode.Root) {
                         if (((ELNode.Root) node).getType() == '$') {
                             elExpression = true;
-                        } else if (checkDeferred && !pageInfo.isDeferredSyntaxAllowedAsLiteral() 
+                        } else if (checkDeferred && !pageInfo.isDeferredSyntaxAllowedAsLiteral()
                                 && ((ELNode.Root) node).getType() == '#') {
                             elExpression = true;
                         }
@@ -1599,7 +1599,7 @@ class Validator {
 
         /**
          * Get the parameters types from the function signature.
-         * 
+         *
          * @return An array of parameter class names
          */
         private String[] getParameters(ELNode.Function func)

==================================================
TagPlugin.java
index 1414e6331d..9b3e803522 100644
--- a/java/org/apache/jasper/compiler/WebXml.java
+++ b/java/org/apache/jasper/compiler/WebXml.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -37,15 +37,15 @@ import org.xml.sax.InputSource;
  * provided and in Servlet 3.0 / JSP 2.2 environments an application's web.xml
  * may be the result of merging a number of web-fragment.xml files and/or
  * annotations with the main web.xml
- * 
- * Clients *must* ensure that they call {@link #close()} to clean up resources. 
+ *
+ * Clients *must* ensure that they call {@link #close()} to clean up resources.
  */
 public class WebXml {
     private static final String FILE_PROTOCOL = "file:";
     private static final String WEB_XML = "/WEB-INF/web.xml";
 
     private final Log log = LogFactory.getLog(WebXml.class);
-            
+
     private InputStream stream;
     private InputSource source;
     private String systemId;
@@ -58,7 +58,7 @@ public class WebXml {
             source = new InputSource(new StringReader(webXml));
             systemId = org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML;
         }
-        
+
         // If not available as context attribute, look for an alternative
         // location
         if (source == null) {
@@ -79,7 +79,7 @@ public class WebXml {
                 }
             }
         }
-        
+
         // Finally, try the default /WEB-INF/web.xml
         if (source == null) {
             URL uri = ctxt.getResource(WEB_XML);
@@ -99,7 +99,7 @@ public class WebXml {
             source.setSystemId(systemId);
         }
     }
-    
+
     public String getSystemId() {
         return systemId;
     }

==================================================
TagPluginContext.java
index 49cbc7c0f5..03c2dc13d9 100644
--- a/java/org/apache/jasper/compiler/tagplugin/TagPlugin.java
+++ b/java/org/apache/jasper/compiler/tagplugin/TagPlugin.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
ELContextImpl.java
index f9d1db508e..cf7a8f0501 100644
--- a/java/org/apache/jasper/compiler/tagplugin/TagPluginContext.java
+++ b/java/org/apache/jasper/compiler/tagplugin/TagPluginContext.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
ELContextWrapper.java
index 4739c6a273..2518a99175 100644
--- a/java/org/apache/jasper/el/ELContextImpl.java
+++ b/java/org/apache/jasper/el/ELContextImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -28,7 +28,7 @@ import javax.el.VariableMapper;
 
 /**
  * Implementation of ELContext
- * 
+ *
  * @author Jacob Hookom
  */
 public final class ELContextImpl extends ELContext {

==================================================
ELResolverImpl.java
index bf8fca374d..0aa1f36014 100644
--- a/java/org/apache/jasper/el/ELContextWrapper.java
+++ b/java/org/apache/jasper/el/ELContextWrapper.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -25,14 +25,14 @@ import javax.el.VariableMapper;
 
 /**
  * Simple ELContextWrapper for runtime evaluation of EL w/ dynamic FunctionMappers
- * 
+ *
  * @author jhook
  */
 public final class ELContextWrapper extends ELContext {
 
     private final ELContext target;
     private final FunctionMapper fnMapper;
-    
+
     public ELContextWrapper(ELContext target, FunctionMapper fnMapper) {
         this.target = target;
         this.fnMapper = fnMapper;

==================================================
ExpressionEvaluatorImpl.java
index 318e806ca3..a7a84cbe82 100644
--- a/java/org/apache/jasper/el/ELResolverImpl.java
+++ b/java/org/apache/jasper/el/ELResolverImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
ExpressionImpl.java
index b27dc7ee7b..0b80deea09 100644
--- a/java/org/apache/jasper/el/ExpressionEvaluatorImpl.java
+++ b/java/org/apache/jasper/el/ExpressionEvaluatorImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -29,7 +29,7 @@ import javax.servlet.jsp.el.VariableResolver;
 public final class ExpressionEvaluatorImpl extends ExpressionEvaluator {
 
     private final ExpressionFactory factory;
-    
+
     public ExpressionEvaluatorImpl(ExpressionFactory factory) {
         this.factory = factory;
     }

==================================================
FunctionMapperImpl.java
index 69f2d5eb3f..67e8d6ae52 100644
--- a/java/org/apache/jasper/el/ExpressionImpl.java
+++ b/java/org/apache/jasper/el/ExpressionImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -26,7 +26,7 @@ import javax.servlet.jsp.el.VariableResolver;
 public final class ExpressionImpl extends Expression {
 
     private final ValueExpression ve;
-    
+
     public ExpressionImpl(ValueExpression ve) {
         this.ve = ve;
     }

==================================================
JspELException.java
index d273c44cce..93c9cd3067 100644
--- a/java/org/apache/jasper/el/FunctionMapperImpl.java
+++ b/java/org/apache/jasper/el/FunctionMapperImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,7 +22,7 @@ import javax.servlet.jsp.el.FunctionMapper;
 
 @Deprecated
 public final class FunctionMapperImpl extends javax.el.FunctionMapper {
-    
+
     private final FunctionMapper fnMapper;
 
     public FunctionMapperImpl(FunctionMapper fnMapper) {

==================================================
JspMethodExpression.java
index 3651a6521e..a7651ffe93 100644
--- a/java/org/apache/jasper/el/JspELException.java
+++ b/java/org/apache/jasper/el/JspELException.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
JspMethodNotFoundException.java
index 51d4c55197..4a7a414ef1 100644
--- a/java/org/apache/jasper/el/JspMethodExpression.java
+++ b/java/org/apache/jasper/el/JspMethodExpression.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
JspPropertyNotFoundException.java
index 249576d354..886d82c0af 100644
--- a/java/org/apache/jasper/el/JspMethodNotFoundException.java
+++ b/java/org/apache/jasper/el/JspMethodNotFoundException.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
JspPropertyNotWritableException.java
index e09b763f88..3482d990a1 100644
--- a/java/org/apache/jasper/el/JspPropertyNotFoundException.java
+++ b/java/org/apache/jasper/el/JspPropertyNotFoundException.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
JspValueExpression.java
index 95107775e7..0e2c1699ab 100644
--- a/java/org/apache/jasper/el/JspPropertyNotWritableException.java
+++ b/java/org/apache/jasper/el/JspPropertyNotWritableException.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
VariableResolverImpl.java
index cc5a41007c..97e4371845 100644
--- a/java/org/apache/jasper/el/JspValueExpression.java
+++ b/java/org/apache/jasper/el/JspValueExpression.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -29,7 +29,7 @@ import javax.el.ValueExpression;
 
 /**
  * Wrapper for providing context to ValueExpressions
- * 
+ *
  * @author Jacob Hookom
  */
 public final class JspValueExpression extends ValueExpression implements

==================================================
BodyContentImpl.java
index e14eb4d635..1b2a9d2684 100644
--- a/java/org/apache/jasper/resources/LocalStrings_fr.properties
+++ b/java/org/apache/jasper/resources/LocalStrings_fr.properties
@@ -40,12 +40,12 @@ jsp.error.not.impl.include=Erreur interne: include non impl\u00e9ment\u00e9
 jsp.error.unavailable=La JSP a \u00e9t\u00e9 marqu\u00e9e comme non disponible
 jsp.error.usebean.missing.attribute=useBean: l''identificateur d''attribut (id attribute) est manquant ou mal orthographi\u00e9
 jsp.error.usebean.missing.type=useBean ({0}): La classe ou le type d''attribut doit \u00eatre\
-sp\u00e9cifi\u00e9: 
+sp\u00e9cifi\u00e9:
 jsp.error.usebean.duplicate=useBean: Nom de bean dupliqu\u00e9: {0}
 jsp.error.usebean.prohibited.as.session=Impossible d''utiliser comme bean de session {0} car c''est interdit\
-par la directive jsp d\u00e9finie pr\u00e9c\u00e9demment: 
-jsp.error.usebean.not.both=useBean: Impossible de sp\u00e9cifier \u00e0 la fois la classe et l''attribut beanName: 
-jsp.error.usebean.bad.type.cast=useBean ({0}): Le type ({1}) n''est pas assignable depuis la classe ({2}) 
+par la directive jsp d\u00e9finie pr\u00e9c\u00e9demment:
+jsp.error.usebean.not.both=useBean: Impossible de sp\u00e9cifier \u00e0 la fois la classe et l''attribut beanName:
+jsp.error.usebean.bad.type.cast=useBean ({0}): Le type ({1}) n''est pas assignable depuis la classe ({2})
 jsp.error.classname=Impossible de d\u00e9terminer le nom de classe d''apr\u00e8s le fichier .class
 jsp.warning.bad.type=Attention: mauvais type dans le fichier .class
 jsp.error.data.file.write=Erreur lors de l''\u00e9criture du fichier de donn\u00e9es
@@ -57,8 +57,8 @@ jsp.error.page.invalid.autoflush=Directive de Page: valeur incorrecte pour autoF
 jsp.error.page.invalid.isthreadsafe=Directive de Page: valeur incorrecte pour isThreadSafe
 jsp.error.page.invalid.info=Directive de Page: valeur incorrecte pour info
 jsp.error.page.invalid.iserrorpage=Directive de Page: valeur incorrecte pour isErrorPage
-jsp.error.page.defafteruse.language=Directive de Page: on ne peut d\u00e9finir language apr\u00e8s un scriptlet 
-jsp.error.page.nomapping.language=Directive de Page: Pas de correspondance pour language: 
+jsp.error.page.defafteruse.language=Directive de Page: on ne peut d\u00e9finir language apr\u00e8s un scriptlet
+jsp.error.page.nomapping.language=Directive de Page: Pas de correspondance pour language:
 jsp.error.page.bad_b_and_a_combo=Directive de Page: combinaison ill\u00e9gale de buffer=\"none\" && autoFlush=\"false\"
 jsp.error.not.impl.taglib=Internal error: Tag extensions non impl\u00e9ment\u00e9s
 jsp.error.include.missing.file=l''argument fichier (file) pour l''inclusion (include) est absent
@@ -89,7 +89,7 @@ jsp.error.file.cannot.read=Impossible de lire le fichier: {0}
 jsp.error.file.already.registered=Inclusion r\u00e9cursive du fichier {0}
 jsp.error.file.not.registered=Le fichier {0} n''appara\u00eet pas dans l''inclusion (include)
 jsp.error.quotes.unterminated=guillemets non termin\u00e9s
-jsp.error.attr.quoted=La valeur de l''attribute doit \u00eatre entre guillemets 
+jsp.error.attr.quoted=La valeur de l''attribute doit \u00eatre entre guillemets
 jsp.error.attr.novalue=L''attribute {0} n''a pas de valeur
 jsp.error.tag.attr.unterminated=Liste de tag d''attribut non termin\u00e9e
 jsp.error.param.noname=Pas de nom dans le tag PARAM

==================================================
HttpJspBase.java
index ef2d9ff864..f34a0de6c4 100644
--- a/java/org/apache/jasper/runtime/BodyContentImpl.java
+++ b/java/org/apache/jasper/runtime/BodyContentImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -30,27 +30,27 @@ import org.apache.jasper.Constants;
 /**
  * Write text to a character-output stream, buffering characters so as
  * to provide for the efficient writing of single characters, arrays,
- * and strings. 
+ * and strings.
  *
- * Provide support for discarding for the output that has been buffered. 
+ * Provide support for discarding for the output that has been buffered.
  *
  * @author Rajiv Mordani
  * @author Jan Luehe
  */
 public class BodyContentImpl extends BodyContent {
-    
-    private static final String LINE_SEPARATOR = 
+
+    private static final String LINE_SEPARATOR =
         System.getProperty("line.separator");
-    private static final boolean LIMIT_BUFFER = 
+    private static final boolean LIMIT_BUFFER =
         Boolean.valueOf(System.getProperty("org.apache.jasper.runtime.BodyContentImpl.LIMIT_BUFFER", "false")).booleanValue();
-    
+
     private char[] cb;
     private int nextChar;
     private boolean closed;
-    
+
     // Enclosed writer to which any output is written
     private Writer writer;
-    
+
     /**
      * Constructor.
      */
@@ -61,7 +61,7 @@ public class BodyContentImpl extends BodyContent {
         nextChar = 0;
         closed = false;
     }
-    
+
     /**
      * Write a single character.
      */
@@ -77,7 +77,7 @@ public class BodyContentImpl extends BodyContent {
             cb[nextChar++] = (char) c;
         }
     }
-    
+
     /**
      * Write a portion of an array of characters.
      *
@@ -99,22 +99,22 @@ public class BodyContentImpl extends BodyContent {
             writer.write(cbuf, off, len);
         } else {
             ensureOpen();
-            
+
             if ((off < 0) || (off > cbuf.length) || (len < 0) ||
                     ((off + len) > cbuf.length) || ((off + len) < 0)) {
                 throw new IndexOutOfBoundsException();
             } else if (len == 0) {
                 return;
-            } 
-            
+            }
+
             if (len >= bufferSize - nextChar)
                 reAllocBuff (len);
-            
+
             System.arraycopy(cbuf, off, cb, nextChar, len);
             nextChar+=len;
         }
     }
-    
+
     /**
      * Write an array of characters.  This method cannot be inherited from the
      * Writer class because it must suppress I/O exceptions.
@@ -127,7 +127,7 @@ public class BodyContentImpl extends BodyContent {
             write(buf, 0, buf.length);
         }
     }
-    
+
     /**
      * Write a portion of a String.
      *
@@ -143,12 +143,12 @@ public class BodyContentImpl extends BodyContent {
             ensureOpen();
             if (len >= bufferSize - nextChar)
                 reAllocBuff(len);
-            
+
             s.getChars(off, off + len, cb, nextChar);
             nextChar += len;
         }
     }
-    
+
     /**
      * Write a string.  This method cannot be inherited from the Writer class
      * because it must suppress I/O exceptions.
@@ -161,7 +161,7 @@ public class BodyContentImpl extends BodyContent {
             write(s, 0, s.length());
         }
     }
-    
+
     /**
      * Write a line separator.  The line separator string is defined by the
      * system property <tt>line.separator</tt>, and is not necessarily a single
@@ -177,7 +177,7 @@ public class BodyContentImpl extends BodyContent {
             write(LINE_SEPARATOR);
         }
     }
-    
+
     /**
      * Print a boolean value.  The string produced by <code>{@link
      * java.lang.String#valueOf(boolean)}</code> is translated into bytes
@@ -196,7 +196,7 @@ public class BodyContentImpl extends BodyContent {
             write(b ? "true" : "false");
         }
     }
-    
+
     /**
      * Print a character.  The character is translated into one or more bytes
      * according to the platform's default character encoding, and these bytes
@@ -214,7 +214,7 @@ public class BodyContentImpl extends BodyContent {
             write(String.valueOf(c));
         }
     }
-    
+
     /**
      * Print an integer.  The string produced by <code>{@link
      * java.lang.String#valueOf(int)}</code> is translated into bytes according
@@ -233,7 +233,7 @@ public class BodyContentImpl extends BodyContent {
             write(String.valueOf(i));
         }
     }
-    
+
     /**
      * Print a long integer.  The string produced by <code>{@link
      * java.lang.String#valueOf(long)}</code> is translated into bytes
@@ -252,7 +252,7 @@ public class BodyContentImpl extends BodyContent {
             write(String.valueOf(l));
         }
     }
-    
+
     /**
      * Print a floating-point number.  The string produced by <code>{@link
      * java.lang.String#valueOf(float)}</code> is translated into bytes
@@ -271,7 +271,7 @@ public class BodyContentImpl extends BodyContent {
             write(String.valueOf(f));
         }
     }
-    
+
     /**
      * Print a double-precision floating-point number.  The string produced by
      * <code>{@link java.lang.String#valueOf(double)}</code> is translated into
@@ -290,7 +290,7 @@ public class BodyContentImpl extends BodyContent {
             write(String.valueOf(d));
         }
     }
-    
+
     /**
      * Print an array of characters.  The characters are converted into bytes
      * according to the platform's default character encoding, and these bytes
@@ -310,7 +310,7 @@ public class BodyContentImpl extends BodyContent {
             write(s);
         }
     }
-    
+
     /**
      * Print a string.  If the argument is <code>null</code> then the string
      * <code>"null"</code> is printed.  Otherwise, the string's characters are
@@ -330,7 +330,7 @@ public class BodyContentImpl extends BodyContent {
             write(s);
         }
     }
-    
+
     /**
      * Print an object.  The string produced by the <code>{@link
      * java.lang.String#valueOf(Object)}</code> method is translated into bytes
@@ -349,7 +349,7 @@ public class BodyContentImpl extends BodyContent {
             write(String.valueOf(obj));
         }
     }
-    
+
     /**
      * Terminate the current line by writing the line separator string.  The
      * line separator string is defined by the system property
@@ -362,7 +362,7 @@ public class BodyContentImpl extends BodyContent {
     public void println() throws IOException {
         newLine();
     }
-    
+
     /**
      * Print a boolean value and then terminate the line.  This method behaves
      * as though it invokes <code>{@link #print(boolean)}</code> and then
@@ -375,7 +375,7 @@ public class BodyContentImpl extends BodyContent {
         print(x);
         println();
     }
-    
+
     /**
      * Print a character and then terminate the line.  This method behaves as
      * though it invokes <code>{@link #print(char)}</code> and then
@@ -388,7 +388,7 @@ public class BodyContentImpl extends BodyContent {
         print(x);
         println();
     }
-    
+
     /**
      * Print an integer and then terminate the line.  This method behaves as
      * though it invokes <code>{@link #print(int)}</code> and then
@@ -401,7 +401,7 @@ public class BodyContentImpl extends BodyContent {
         print(x);
         println();
     }
-    
+
     /**
      * Print a long integer and then terminate the line.  This method behaves
      * as though it invokes <code>{@link #print(long)}</code> and then
@@ -414,7 +414,7 @@ public class BodyContentImpl extends BodyContent {
         print(x);
         println();
     }
-    
+
     /**
      * Print a floating-point number and then terminate the line.  This method
      * behaves as though it invokes <code>{@link #print(float)}</code> and then
@@ -427,7 +427,7 @@ public class BodyContentImpl extends BodyContent {
         print(x);
         println();
     }
-    
+
     /**
      * Print a double-precision floating-point number and then terminate the
      * line.  This method behaves as though it invokes <code>{@link
@@ -440,7 +440,7 @@ public class BodyContentImpl extends BodyContent {
         print(x);
         println();
     }
-    
+
     /**
      * Print an array of characters and then terminate the line.  This method
      * behaves as though it invokes <code>{@link #print(char[])}</code> and
@@ -453,7 +453,7 @@ public class BodyContentImpl extends BodyContent {
         print(x);
         println();
     }
-    
+
     /**
      * Print a String and then terminate the line.  This method behaves as
      * though it invokes <code>{@link #print(String)}</code> and then
@@ -466,7 +466,7 @@ public class BodyContentImpl extends BodyContent {
         print(x);
         println();
     }
-    
+
     /**
      * Print an Object and then terminate the line.  This method behaves as
      * though it invokes <code>{@link #print(Object)}</code> and then
@@ -479,11 +479,11 @@ public class BodyContentImpl extends BodyContent {
         print(x);
         println();
     }
-    
+
     /**
      * Clear the contents of the buffer. If the buffer has been already
      * been flushed then the clear operation shall throw an IOException
-     * to signal the fact that some data has already been irrevocably 
+     * to signal the fact that some data has already been irrevocably
      * written to the client response stream.
      *
      * @throws IOException If an I/O error occurs
@@ -500,7 +500,7 @@ public class BodyContentImpl extends BodyContent {
             }
         }
     }
-    
+
     /**
      * Clears the current contents of the buffer. Unlike clear(), this
      * method will not throw an IOException if the buffer has already been
@@ -515,7 +515,7 @@ public class BodyContentImpl extends BodyContent {
             this.clear();
         }
     }
-    
+
     /**
      * Close the stream, flushing it first.  Once a stream has been closed,
      * further write() or flush() invocations will cause an IOException to be
@@ -531,7 +531,7 @@ public class BodyContentImpl extends BodyContent {
             closed = true;
         }
     }
-    
+
     /**
      * This method returns the size of the buffer used by the JspWriter.
      *
@@ -539,13 +539,13 @@ public class BodyContentImpl extends BodyContent {
      */
     @Override
     public int getBufferSize() {
-        // According to the spec, the JspWriter returned by 
+        // According to the spec, the JspWriter returned by
         // JspContext.pushBody(java.io.Writer writer) must behave as
         // though it were unbuffered. This means that its getBufferSize()
         // must always return 0.
         return (writer == null) ? bufferSize : 0;
     }
-    
+
     /**
      * @return the number of bytes unused in the buffer
      */
@@ -553,7 +553,7 @@ public class BodyContentImpl extends BodyContent {
     public int getRemaining() {
         return (writer == null) ? bufferSize-nextChar : 0;
     }
-    
+
     /**
      * Return the value of this BodyJspWriter as a Reader.
      * Note: this is after evaluation!!  There are no scriptlets,
@@ -565,7 +565,7 @@ public class BodyContentImpl extends BodyContent {
     public Reader getReader() {
         return (writer == null) ? new CharArrayReader (cb, 0, nextChar) : null;
     }
-    
+
     /**
      * Return the value of the BodyJspWriter as a String.
      * Note: this is after evaluation!!  There are no scriptlets,
@@ -577,7 +577,7 @@ public class BodyContentImpl extends BodyContent {
     public String getString() {
         return (writer == null) ? new String(cb, 0, nextChar) : null;
     }
-    
+
     /**
      * Write the contents of this BodyJspWriter into a Writer.
      * Subclasses are likely to do interesting things with the
@@ -594,7 +594,7 @@ public class BodyContentImpl extends BodyContent {
             // it doesn't allow to flush.
         }
     }
-    
+
     /**
      * Sets the writer to which all output is written.
      */
@@ -629,26 +629,26 @@ public class BodyContentImpl extends BodyContent {
     private void ensureOpen() throws IOException {
         if (closed) throw new IOException("Stream closed");
     }
-    
+
     /**
      * Reallocates buffer since the spec requires it to be unbounded.
      */
     private void reAllocBuff(int len) {
-        
+
         if (bufferSize + len <= cb.length) {
             bufferSize = cb.length;
             return;
         }
-        
+
         if (len < cb.length) {
             len = cb.length;
         }
-        
+
         char[] tmp = new char[cb.length + len];
         System.arraycopy(cb, 0, tmp, 0, cb.length);
         cb = tmp;
         bufferSize = cb.length;
     }
-    
-    
+
+
 }

==================================================
InstanceManagerFactory.java
index f455833a81..544af4e449 100644
--- a/java/org/apache/jasper/runtime/HttpJspBase.java
+++ b/java/org/apache/jasper/runtime/HttpJspBase.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -34,21 +34,21 @@ import org.apache.jasper.compiler.Localizer;
  * @author Anil K. Vijendran
  */
 public abstract class HttpJspBase extends HttpServlet implements HttpJspPage {
-    
+
     private static final long serialVersionUID = 1L;
 
     protected HttpJspBase() {
     }
 
     @Override
-    public final void init(ServletConfig config) 
-        throws ServletException 
+    public final void init(ServletConfig config)
+        throws ServletException
     {
         super.init(config);
         jspInit();
         _jspInit();
     }
-    
+
     @Override
     public String getServletInfo() {
         return Localizer.getMessage("jsp.engine.info");
@@ -64,12 +64,12 @@ public abstract class HttpJspBase extends HttpServlet implements HttpJspPage {
      * Entry point into service.
      */
     @Override
-    public final void service(HttpServletRequest request, HttpServletResponse response) 
-        throws ServletException, IOException 
+    public final void service(HttpServletRequest request, HttpServletResponse response)
+        throws ServletException, IOException
     {
         _jspService(request, response);
     }
-    
+
     @Override
     public void jspInit() {
     }
@@ -85,7 +85,7 @@ public abstract class HttpJspBase extends HttpServlet implements HttpJspPage {
     }
 
     @Override
-    public abstract void _jspService(HttpServletRequest request, 
-                                     HttpServletResponse response) 
+    public abstract void _jspService(HttpServletRequest request,
+                                     HttpServletResponse response)
         throws ServletException, IOException;
 }

==================================================
JspApplicationContextImpl.java
index 373971749c..c4b0e88413 100644
--- a/java/org/apache/jasper/runtime/InstanceManagerFactory.java
+++ b/java/org/apache/jasper/runtime/InstanceManagerFactory.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -29,7 +29,7 @@ public class InstanceManagerFactory {
     }
 
     public static InstanceManager getInstanceManager(ServletConfig config) {
-        InstanceManager instanceManager = 
+        InstanceManager instanceManager =
                 (InstanceManager) config.getServletContext().getAttribute(InstanceManager.class.getName());
         if (instanceManager == null) {
             throw new IllegalStateException("No org.apache.tomcat.InstanceManager set in ServletContext");

==================================================
JspContextWrapper.java
index 8f48ff02ae..11fc557e4c 100644
--- a/java/org/apache/jasper/runtime/JspApplicationContextImpl.java
+++ b/java/org/apache/jasper/runtime/JspApplicationContextImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -43,7 +43,7 @@ import org.apache.jasper.el.ELContextImpl;
 
 /**
  * Implementation of JspApplicationContext
- * 
+ *
  * @author Jacob Hookom
  */
 public class JspApplicationContextImpl implements JspApplicationContext {
@@ -128,7 +128,7 @@ public class JspApplicationContextImpl implements JspApplicationContext {
             r.add(new MapELResolver());
             r.add(new ResourceBundleELResolver());
             r.add(new ListELResolver());
-            r.add(new ArrayELResolver());    
+            r.add(new ArrayELResolver());
             r.add(new BeanELResolver());
             r.add(new ScopedAttributeELResolver());
             this.resolver = r;

==================================================
JspFactoryImpl.java
index d7f0927012..934f277efd 100644
--- a/java/org/apache/jasper/runtime/JspContextWrapper.java
+++ b/java/org/apache/jasper/runtime/JspContextWrapper.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -47,12 +47,12 @@ import org.apache.jasper.util.Enumerator;
 
 /**
  * Implementation of a JSP Context Wrapper.
- * 
+ *
  * The JSP Context Wrapper is a JspContext created and maintained by a tag
  * handler implementation. It wraps the Invoking JSP Context, that is, the
  * JspContext instance passed to the tag handler by the invoking page via
  * setJspContext().
- * 
+ *
  * @author Kin-man Chung
  * @author Jan Luehe
  * @author Jacob Hookom
@@ -380,7 +380,7 @@ public class JspContextWrapper extends PageContext implements VariableResolver {
     /**
      * Copies the variables of the given scope from the virtual page scope of
      * this JSP context wrapper to the page scope of the invoking JSP context.
-     * 
+     *
      * @param scope
      *            variable scope (one of NESTED, AT_BEGIN, or AT_END)
      */
@@ -457,7 +457,7 @@ public class JspContextWrapper extends PageContext implements VariableResolver {
     /**
      * Checks to see if the given variable name is used as an alias, and if so,
      * returns the variable name for which it is used as an alias.
-     * 
+     *
      * @param varName
      *            The variable name to check
      * @return The variable name for which varName is used as an alias, or
@@ -480,9 +480,9 @@ public class JspContextWrapper extends PageContext implements VariableResolver {
     @Override
     public ELContext getELContext() {
         // instead decorate!!!
-        
+
         return this.invokingJspCtxt.getELContext();
-        
+
         /*
         if (this.elContext != null) {
             JspFactory jspFact = JspFactory.getDefaultFactory();

==================================================
JspFragmentHelper.java
index 74a143161f..5232a36e2b 100644
--- a/java/org/apache/jasper/runtime/JspFactoryImpl.java
+++ b/java/org/apache/jasper/runtime/JspFactoryImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -44,9 +44,9 @@ public class JspFactoryImpl extends JspFactory {
     private final Log log = LogFactory.getLog(JspFactoryImpl.class);
 
     private static final String SPEC_VERSION = "2.1";
-    private static final boolean USE_POOL = 
+    private static final boolean USE_POOL =
         Boolean.valueOf(System.getProperty("org.apache.jasper.runtime.JspFactoryImpl.USE_POOL", "true")).booleanValue();
-    private static final int POOL_SIZE = 
+    private static final int POOL_SIZE =
         Integer.valueOf(System.getProperty("org.apache.jasper.runtime.JspFactoryImpl.POOL_SIZE", "8")).intValue();
 
     private ThreadLocal<PageContextPool> localPool = new ThreadLocal<PageContextPool>();
@@ -109,7 +109,7 @@ public class JspFactoryImpl extends JspFactory {
             } else {
                 pc = new PageContextImpl();
             }
-            pc.initialize(servlet, request, response, errorPageURL, 
+            pc.initialize(servlet, request, response, errorPageURL,
                     needsSession, bufferSize, autoflush);
             return pc;
         } catch (Throwable ex) {

==================================================
JspRuntimeLibrary.java
index f0054bb361..1f6d32a589 100644
--- a/java/org/apache/jasper/runtime/JspFragmentHelper.java
+++ b/java/org/apache/jasper/runtime/JspFragmentHelper.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -33,17 +33,17 @@ import javax.servlet.jsp.tagext.JspTag;
  *
  * @author Mark Roth
  */
-public abstract class JspFragmentHelper 
-    extends JspFragment 
+public abstract class JspFragmentHelper
+    extends JspFragment
 {
-    
+
     protected int discriminator;
     protected JspContext jspContext;
     protected PageContext _jspx_page_context;
     protected JspTag parentTag;
 
-    public JspFragmentHelper( int discriminator, JspContext jspContext, 
-        JspTag parentTag ) 
+    public JspFragmentHelper( int discriminator, JspContext jspContext,
+        JspTag parentTag )
     {
         this.discriminator = discriminator;
         this.jspContext = jspContext;
@@ -53,14 +53,14 @@ public abstract class JspFragmentHelper
         }
         this.parentTag = parentTag;
     }
-    
+
     @Override
     public JspContext getJspContext() {
         return this.jspContext;
     }
-    
+
     public JspTag getParentTag() {
         return this.parentTag;
     }
-    
+
 }

==================================================
JspSourceDependent.java
index d739fdf67e..b09dbe4612 100644
--- a/java/org/apache/jasper/runtime/JspRuntimeLibrary.java
+++ b/java/org/apache/jasper/runtime/JspRuntimeLibrary.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -43,7 +43,7 @@ import org.apache.jasper.compiler.Localizer;
 
 /**
  * Bunch of util methods that are used by code generated for useBean,
- * getProperty and setProperty.  
+ * getProperty and setProperty.
  *
  * The __begin, __end stuff is there so that the JSP engine can
  * actually parse this file and inline them if people don't want
@@ -54,7 +54,7 @@ import org.apache.jasper.compiler.Localizer;
  * @author Shawn Bayern
  */
 public class JspRuntimeLibrary {
-    
+
     protected static class PrivilegedIntrospectHelper
         implements PrivilegedExceptionAction<Void> {
 
@@ -76,7 +76,7 @@ public class JspRuntimeLibrary {
             this.param = param;
             this.ignoreMethodNF = ignoreMethodNF;
         }
-         
+
         @Override
         public Void run() throws JasperException {
             internalIntrospecthelper(
@@ -103,7 +103,7 @@ public class JspRuntimeLibrary {
                 /*
                  * The only place that sets JSP_EXCEPTION is
                  * PageContextImpl.handlePageException(). It really should set
-                 * SERVLET_EXCEPTION, but that would interfere with the 
+                 * SERVLET_EXCEPTION, but that would interfere with the
                  * ErrorReportValve. Therefore, if JSP_EXCEPTION is set, we
                  * need to set SERVLET_EXCEPTION.
                  */
@@ -189,7 +189,7 @@ public class JspRuntimeLibrary {
         } else if (target == Character.class) {
             if (isNullOrEmpty)
                 return Character.valueOf((char) 0);
-            else 
+            else
                 return Character.valueOf(s.charAt(0));
         } else if (target == Double.class) {
             if (isNullOrEmpty)
@@ -223,8 +223,8 @@ public class JspRuntimeLibrary {
 
    // __begin convertMethod
     public static Object convert(String propertyName, String s, Class<?> t,
-            Class<?> propertyEditorClass) 
-       throws JasperException 
+            Class<?> propertyEditorClass)
+       throws JasperException
     {
         try {
             if (s == null) {
@@ -284,7 +284,7 @@ public class JspRuntimeLibrary {
         }
     }
     // __end introspectMethod
-    
+
     // __begin introspecthelperMethod
     public static void introspecthelper(Object bean, String prop,
                                         String value, ServletRequest request,
@@ -309,7 +309,7 @@ public class JspRuntimeLibrary {
 
     private static void internalIntrospecthelper(Object bean, String prop,
                                         String value, ServletRequest request,
-                                        String param, boolean ignoreMethodNF) 
+                                        String param, boolean ignoreMethodNF)
                                         throws JasperException
     {
         Method method = null;
@@ -344,7 +344,7 @@ public class JspRuntimeLibrary {
                         method.invoke(bean, new Object[] { values });
                     } else {
                         createTypedArray (prop, bean, method, values, t,
-                                          propertyEditorClass); 
+                                          propertyEditorClass);
                     }
                 } else {
                     if(value == null || (param != null && value.equals(""))) return;
@@ -372,7 +372,7 @@ public class JspRuntimeLibrary {
         }
     }
     // __end introspecthelperMethod
-    
+
     //-------------------------------------------------------------------
     // functions to convert builtin Java data types to string.
     //-------------------------------------------------------------------
@@ -519,7 +519,7 @@ public class JspRuntimeLibrary {
             } else {
                 Object[] tmpval = new Integer[values.length];
                 for (int i=0; i<values.length; i++) {
-                    tmpval[i] =  
+                    tmpval[i] =
                         getValueFromPropertyEditorManager(
                                             t, propertyName, values[i]);
                 }
@@ -539,10 +539,10 @@ public class JspRuntimeLibrary {
     public static String escapeQueryString(String unescString) {
     if ( unescString == null )
         return null;
-   
+
     String escString    = "";
     String shellSpChars = "&;`'\"|*?~<>^()[]{}$\\\n";
-   
+
     for(int index=0; index<unescString.length(); index++) {
         char nextChar = unescString.charAt(index);
 
@@ -581,7 +581,7 @@ public class JspRuntimeLibrary {
     {
         try {
             Method method = getWriteMethod(bean.getClass(), prop);
-            method.invoke(bean, new Object[] { 
+            method.invoke(bean, new Object[] {
                 pageContext.getExpressionEvaluator().evaluate(
                     expression,
                     method.getParameterTypes()[0],
@@ -625,7 +625,7 @@ public class JspRuntimeLibrary {
             throw new JasperException(ex);
         }
     }
-    
+
     public static void handleSetProperty(Object bean, String prop,
                                          int value)
         throws JasperException
@@ -635,9 +635,9 @@ public class JspRuntimeLibrary {
             method.invoke(bean, new Object[] { Integer.valueOf(value) });
         } catch (Exception ex) {
             throw new JasperException(ex);
-        }        
+        }
     }
-    
+
     public static void handleSetProperty(Object bean, String prop,
                                          short value)
         throws JasperException
@@ -647,9 +647,9 @@ public class JspRuntimeLibrary {
             method.invoke(bean, new Object[] { Short.valueOf(value) });
         } catch (Exception ex) {
             throw new JasperException(ex);
-        }        
+        }
     }
-    
+
     public static void handleSetProperty(Object bean, String prop,
                                          long value)
         throws JasperException
@@ -659,9 +659,9 @@ public class JspRuntimeLibrary {
             method.invoke(bean, new Object[] { Long.valueOf(value) });
         } catch (Exception ex) {
             throw new JasperException(ex);
-        }        
-    } 
-    
+        }
+    }
+
     public static void handleSetProperty(Object bean, String prop,
                                          double value)
         throws JasperException
@@ -671,9 +671,9 @@ public class JspRuntimeLibrary {
             method.invoke(bean, new Object[] { Double.valueOf(value) });
         } catch (Exception ex) {
             throw new JasperException(ex);
-        }        
+        }
     }
-    
+
     public static void handleSetProperty(Object bean, String prop,
                                          float value)
         throws JasperException
@@ -683,9 +683,9 @@ public class JspRuntimeLibrary {
             method.invoke(bean, new Object[] { Float.valueOf(value) });
         } catch (Exception ex) {
             throw new JasperException(ex);
-        }        
+        }
     }
-    
+
     public static void handleSetProperty(Object bean, String prop,
                                          char value)
         throws JasperException
@@ -695,7 +695,7 @@ public class JspRuntimeLibrary {
             method.invoke(bean, new Object[] { Character.valueOf(value) });
         } catch (Exception ex) {
             throw new JasperException(ex);
-        }        
+        }
     }
 
     public static void handleSetProperty(Object bean, String prop,
@@ -707,9 +707,9 @@ public class JspRuntimeLibrary {
             method.invoke(bean, new Object[] { Byte.valueOf(value) });
         } catch (Exception ex) {
             throw new JasperException(ex);
-        }        
+        }
     }
-    
+
     public static void handleSetProperty(Object bean, String prop,
                                          boolean value)
         throws JasperException
@@ -719,12 +719,12 @@ public class JspRuntimeLibrary {
             method.invoke(bean, new Object[] { Boolean.valueOf(value) });
         } catch (Exception ex) {
             throw new JasperException(ex);
-        }        
+        }
     }
-    
+
     public static Method getWriteMethod(Class<?> beanClass, String prop)
     throws JasperException {
-        Method method = null;        
+        Method method = null;
         Class<?> type = null;
         try {
             java.beans.BeanInfo info
@@ -739,7 +739,7 @@ public class JspRuntimeLibrary {
                         break;
                     }
                 }
-            } else {        
+            } else {
                 // just in case introspection silently fails.
                 throw new JasperException(
                     Localizer.getMessage("jsp.error.beans.nobeaninfo",
@@ -768,7 +768,7 @@ public class JspRuntimeLibrary {
     public static Method getReadMethod(Class<?> beanClass, String prop)
             throws JasperException {
 
-        Method method = null;        
+        Method method = null;
         Class<?> type = null;
         try {
             java.beans.BeanInfo info
@@ -783,7 +783,7 @@ public class JspRuntimeLibrary {
                         break;
                     }
                 }
-            } else {        
+            } else {
                 // just in case introspection silently fails.
                 throw new JasperException(
                     Localizer.getMessage("jsp.error.beans.nobeaninfo",
@@ -812,8 +812,8 @@ public class JspRuntimeLibrary {
 
     public static Object getValueFromBeanInfoPropertyEditor(
                            Class<?> attrClass, String attrName, String attrValue,
-                           Class<?> propertyEditorClass) 
-        throws JasperException 
+                           Class<?> propertyEditorClass)
+        throws JasperException
     {
         try {
             PropertyEditor pe =
@@ -829,11 +829,11 @@ public class JspRuntimeLibrary {
     }
 
     public static Object getValueFromPropertyEditorManager(
-                     Class<?> attrClass, String attrName, String attrValue) 
-        throws JasperException 
+                     Class<?> attrClass, String attrName, String attrValue)
+        throws JasperException
     {
         try {
-            PropertyEditor propEditor = 
+            PropertyEditor propEditor =
                 PropertyEditorManager.findEditor(attrClass);
             if (propEditor != null) {
                 propEditor.setAsText(attrValue);
@@ -877,13 +877,13 @@ public class JspRuntimeLibrary {
             String pathInfo = (String)
                 request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);
             if (pathInfo == null) {
-                if (uri.lastIndexOf('/') >= 0) 
+                if (uri.lastIndexOf('/') >= 0)
                     uri = uri.substring(0, uri.lastIndexOf('/'));
             }
         }
         else {
             uri = hrequest.getServletPath();
-            if (uri.lastIndexOf('/') >= 0) 
+            if (uri.lastIndexOf('/') >= 0)
                 uri = uri.substring(0, uri.lastIndexOf('/'));
         }
         return uri + '/' + relativePath;
@@ -935,7 +935,7 @@ public class JspRuntimeLibrary {
      * in J2SDK1.4, and should be removed if the only platform supported
      * is 1.4 or higher.
      * @param s The String to be URL encoded.
-     * @param enc The character encoding 
+     * @param enc The character encoding
      * @return The URL encoded String
      */
     public static String URLEncode(String s, String enc) {
@@ -945,7 +945,7 @@ public class JspRuntimeLibrary {
         }
 
         if (enc == null) {
-            enc = "ISO-8859-1";        // The default request encoding 
+            enc = "ISO-8859-1";        // The default request encoding
         }
 
         StringBuilder out = new StringBuilder(s.length());
@@ -957,7 +957,7 @@ public class JspRuntimeLibrary {
             // Use the default encoding?
             writer = new OutputStreamWriter(buf);
         }
-        
+
         for (int i = 0; i < s.length(); i++) {
             int c = s.charAt(i);
             if (c == ' ') {

==================================================
JspWriterImpl.java
index 3f0766d89e..0775e41cd9 100644
--- a/java/org/apache/jasper/runtime/JspSourceDependent.java
+++ b/java/org/apache/jasper/runtime/JspSourceDependent.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
PageContextImpl.java
index 92a07a9114..c02236e03c 100644
--- a/java/org/apache/jasper/runtime/JspWriterImpl.java
+++ b/java/org/apache/jasper/runtime/JspWriterImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -32,29 +32,29 @@ import org.apache.jasper.security.SecurityUtil;
 /**
  * Write text to a character-output stream, buffering characters so as
  * to provide for the efficient writing of single characters, arrays,
- * and strings. 
+ * and strings.
+ *
+ * Provide support for discarding for the output that has been
+ * buffered.
  *
- * Provide support for discarding for the output that has been 
- * buffered. 
- * 
  * This needs revisiting when the buffering problems in the JSP spec
- * are fixed -akv 
+ * are fixed -akv
  *
  * @author Anil K. Vijendran
  */
 public class JspWriterImpl extends JspWriter {
-    
+
     private Writer out;
-    private ServletResponse response;    
+    private ServletResponse response;
     private char cb[];
     private int nextChar;
     private boolean flushed = false;
     private boolean closed = false;
-    
+
     public JspWriterImpl() {
         super( Constants.DEFAULT_BUFFER_SIZE, true );
     }
-    
+
     /**
      * Create a buffered character-output stream that uses a default-sized
      * output buffer.
@@ -64,7 +64,7 @@ public class JspWriterImpl extends JspWriter {
     public JspWriterImpl(ServletResponse response) {
         this(response, Constants.DEFAULT_BUFFER_SIZE, true);
     }
-    
+
     /**
      * Create a new buffered character-output stream that uses an output
      * buffer of the given size.
@@ -74,7 +74,7 @@ public class JspWriterImpl extends JspWriter {
      *
      * @exception  IllegalArgumentException  If sz is <= 0
      */
-    public JspWriterImpl(ServletResponse response, int sz, 
+    public JspWriterImpl(ServletResponse response, int sz,
             boolean autoFlush) {
         super(sz, autoFlush);
         if (sz < 0)
@@ -83,7 +83,7 @@ public class JspWriterImpl extends JspWriter {
         cb = sz == 0 ? null : new char[sz];
         nextChar = 0;
     }
-    
+
     void init( ServletResponse response, int sz, boolean autoFlush ) {
         this.response= response;
         if( sz > 0 && ( cb == null || sz > cb.length ) )
@@ -92,7 +92,7 @@ public class JspWriterImpl extends JspWriter {
         this.autoFlush=autoFlush;
         this.bufferSize=sz;
     }
-    
+
     /** Package-level access
      */
     void recycle() {
@@ -102,7 +102,7 @@ public class JspWriterImpl extends JspWriter {
         nextChar = 0;
         response = null;
     }
-    
+
     /**
      * Flush the output buffer to the underlying character stream, without
      * flushing the stream itself.  This method is non-private only so that it
@@ -119,26 +119,26 @@ public class JspWriterImpl extends JspWriter {
         out.write(cb, 0, nextChar);
         nextChar = 0;
     }
-    
+
     private void initOut() throws IOException {
         if (out == null) {
             out = response.getWriter();
         }
     }
-    
+
     private String getLocalizeMessage(final String message){
         if (SecurityUtil.isPackageProtectionEnabled()){
             return AccessController.doPrivileged(new PrivilegedAction<String>(){
                 @Override
                 public String run(){
-                    return Localizer.getMessage(message); 
+                    return Localizer.getMessage(message);
                 }
             });
         } else {
             return Localizer.getMessage(message);
         }
     }
-    
+
     /**
      * Discard the output buffer.
      */
@@ -154,7 +154,7 @@ public class JspWriterImpl extends JspWriter {
         ensureOpen();
         nextChar = 0;
     }
-    
+
     @Override
     public void clearBuffer() throws IOException {
         if (bufferSize == 0)
@@ -163,11 +163,11 @@ public class JspWriterImpl extends JspWriter {
         ensureOpen();
         nextChar = 0;
     }
-    
+
     private final void bufferOverflow() throws IOException {
         throw new IOException(getLocalizeMessage("jsp.error.overflow"));
     }
-    
+
     /**
      * Flush the stream.
      *
@@ -179,7 +179,7 @@ public class JspWriterImpl extends JspWriter {
             out.flush();
         }
     }
-    
+
     /**
      * Close the stream.
      *
@@ -195,7 +195,7 @@ public class JspWriterImpl extends JspWriter {
         out = null;
         closed = true;
     }
-    
+
     /**
      * @return the number of bytes unused in the buffer
      */
@@ -203,14 +203,14 @@ public class JspWriterImpl extends JspWriter {
     public int getRemaining() {
         return bufferSize - nextChar;
     }
-    
+
     /** check to make sure that the stream has not been closed */
     private void ensureOpen() throws IOException {
         if (response == null || closed)
             throw new IOException("Stream closed");
     }
-    
-    
+
+
     /**
      * Write a single character.
      */
@@ -230,7 +230,7 @@ public class JspWriterImpl extends JspWriter {
             cb[nextChar++] = (char) c;
         }
     }
-    
+
     /**
      * Our own little min method, to avoid loading java.lang.Math if we've run
      * out of file descriptors and we're trying to print a stack trace.
@@ -239,7 +239,7 @@ public class JspWriterImpl extends JspWriter {
         if (a < b) return a;
         return b;
     }
-    
+
     /**
      * Write a portion of an array of characters.
      *
@@ -255,24 +255,24 @@ public class JspWriterImpl extends JspWriter {
      * @param  len   Number of characters to write
      */
     @Override
-    public void write(char cbuf[], int off, int len) 
-    throws IOException 
+    public void write(char cbuf[], int off, int len)
+    throws IOException
     {
         ensureOpen();
-        
+
         if (bufferSize == 0) {
             initOut();
             out.write(cbuf, off, len);
             return;
         }
-        
+
         if ((off < 0) || (off > cbuf.length) || (len < 0) ||
                 ((off + len) > cbuf.length) || ((off + len) < 0)) {
             throw new IndexOutOfBoundsException();
         } else if (len == 0) {
             return;
-        } 
-        
+        }
+
         if (len >= bufferSize) {
             /* If the request length exceeds the size of the output buffer,
              flush the buffer and then write the data directly.  In this
@@ -285,22 +285,22 @@ public class JspWriterImpl extends JspWriter {
             out.write(cbuf, off, len);
             return;
         }
-        
+
         int b = off, t = off + len;
         while (b < t) {
             int d = min(bufferSize - nextChar, t - b);
             System.arraycopy(cbuf, b, cb, nextChar, d);
             b += d;
             nextChar += d;
-            if (nextChar >= bufferSize) 
+            if (nextChar >= bufferSize)
                 if (autoFlush)
                     flushBuffer();
                 else
                     bufferOverflow();
         }
-        
+
     }
-    
+
     /**
      * Write an array of characters.  This method cannot be inherited from the
      * Writer class because it must suppress I/O exceptions.
@@ -309,7 +309,7 @@ public class JspWriterImpl extends JspWriter {
     public void write(char buf[]) throws IOException {
         write(buf, 0, buf.length);
     }
-    
+
     /**
      * Write a portion of a String.
      *
@@ -331,14 +331,14 @@ public class JspWriterImpl extends JspWriter {
             s.getChars(b, b + d, cb, nextChar);
             b += d;
             nextChar += d;
-            if (nextChar >= bufferSize) 
+            if (nextChar >= bufferSize)
                 if (autoFlush)
                     flushBuffer();
                 else
                     bufferOverflow();
         }
     }
-    
+
     /**
      * Write a string.  This method cannot be inherited from the Writer class
      * because it must suppress I/O exceptions.
@@ -353,10 +353,10 @@ public class JspWriterImpl extends JspWriter {
             write(s, 0, s.length());
         }
     }
-    
-    
+
+
     static String lineSeparator = System.getProperty("line.separator");
-    
+
     /**
      * Write a line separator.  The line separator string is defined by the
      * system property <tt>line.separator</tt>, and is not necessarily a single
@@ -364,15 +364,15 @@ public class JspWriterImpl extends JspWriter {
      *
      * @exception  IOException  If an I/O error occurs
      */
-    
+
     @Override
     public void newLine() throws IOException {
         write(lineSeparator);
     }
-    
-    
+
+
     /* Methods that do not terminate lines */
-    
+
     /**
      * Print a boolean value.  The string produced by <code>{@link
      * java.lang.String#valueOf(boolean)}</code> is translated into bytes
@@ -386,7 +386,7 @@ public class JspWriterImpl extends JspWriter {
     public void print(boolean b) throws IOException {
         write(b ? "true" : "false");
     }
-    
+
     /**
      * Print a character.  The character is translated into one or more bytes
      * according to the platform's default character encoding, and these bytes
@@ -399,7 +399,7 @@ public class JspWriterImpl extends JspWriter {
     public void print(char c) throws IOException {
         write(String.valueOf(c));
     }
-    
+
     /**
      * Print an integer.  The string produced by <code>{@link
      * java.lang.String#valueOf(int)}</code> is translated into bytes according
@@ -413,7 +413,7 @@ public class JspWriterImpl extends JspWriter {
     public void print(int i) throws IOException {
         write(String.valueOf(i));
     }
-    
+
     /**
      * Print a long integer.  The string produced by <code>{@link
      * java.lang.String#valueOf(long)}</code> is translated into bytes
@@ -427,7 +427,7 @@ public class JspWriterImpl extends JspWriter {
     public void print(long l) throws IOException {
         write(String.valueOf(l));
     }
-    
+
     /**
      * Print a floating-point number.  The string produced by <code>{@link
      * java.lang.String#valueOf(float)}</code> is translated into bytes
@@ -441,7 +441,7 @@ public class JspWriterImpl extends JspWriter {
     public void print(float f) throws IOException {
         write(String.valueOf(f));
     }
-    
+
     /**
      * Print a double-precision floating-point number.  The string produced by
      * <code>{@link java.lang.String#valueOf(double)}</code> is translated into
@@ -455,7 +455,7 @@ public class JspWriterImpl extends JspWriter {
     public void print(double d) throws IOException {
         write(String.valueOf(d));
     }
-    
+
     /**
      * Print an array of characters.  The characters are converted into bytes
      * according to the platform's default character encoding, and these bytes
@@ -470,7 +470,7 @@ public class JspWriterImpl extends JspWriter {
     public void print(char s[]) throws IOException {
         write(s);
     }
-    
+
     /**
      * Print a string.  If the argument is <code>null</code> then the string
      * <code>"null"</code> is printed.  Otherwise, the string's characters are
@@ -487,7 +487,7 @@ public class JspWriterImpl extends JspWriter {
         }
         write(s);
     }
-    
+
     /**
      * Print an object.  The string produced by the <code>{@link
      * java.lang.String#valueOf(Object)}</code> method is translated into bytes
@@ -501,9 +501,9 @@ public class JspWriterImpl extends JspWriter {
     public void print(Object obj) throws IOException {
         write(String.valueOf(obj));
     }
-    
+
     /* Methods that do terminate lines */
-    
+
     /**
      * Terminate the current line by writing the line separator string.  The
      * line separator string is defined by the system property
@@ -512,13 +512,13 @@ public class JspWriterImpl extends JspWriter {
      *
      * Need to change this from PrintWriter because the default
      * println() writes  to the sink directly instead of through the
-     * write method...  
+     * write method...
      */
     @Override
     public void println() throws IOException {
         newLine();
     }
-    
+
     /**
      * Print a boolean value and then terminate the line.  This method behaves
      * as though it invokes <code>{@link #print(boolean)}</code> and then
@@ -529,7 +529,7 @@ public class JspWriterImpl extends JspWriter {
         print(x);
         println();
     }
-    
+
     /**
      * Print a character and then terminate the line.  This method behaves as
      * though it invokes <code>{@link #print(char)}</code> and then <code>{@link
@@ -540,7 +540,7 @@ public class JspWriterImpl extends JspWriter {
         print(x);
         println();
     }
-    
+
     /**
      * Print an integer and then terminate the line.  This method behaves as
      * though it invokes <code>{@link #print(int)}</code> and then <code>{@link
@@ -551,7 +551,7 @@ public class JspWriterImpl extends JspWriter {
         print(x);
         println();
     }
-    
+
     /**
      * Print a long integer and then terminate the line.  This method behaves
      * as though it invokes <code>{@link #print(long)}</code> and then
@@ -562,7 +562,7 @@ public class JspWriterImpl extends JspWriter {
         print(x);
         println();
     }
-    
+
     /**
      * Print a floating-point number and then terminate the line.  This method
      * behaves as though it invokes <code>{@link #print(float)}</code> and then
@@ -573,7 +573,7 @@ public class JspWriterImpl extends JspWriter {
         print(x);
         println();
     }
-    
+
     /**
      * Print a double-precision floating-point number and then terminate the
      * line.  This method behaves as though it invokes <code>{@link
@@ -584,7 +584,7 @@ public class JspWriterImpl extends JspWriter {
         print(x);
         println();
     }
-    
+
     /**
      * Print an array of characters and then terminate the line.  This method
      * behaves as though it invokes <code>{@link #print(char[])}</code> and then
@@ -595,7 +595,7 @@ public class JspWriterImpl extends JspWriter {
         print(x);
         println();
     }
-    
+
     /**
      * Print a String and then terminate the line.  This method behaves as
      * though it invokes <code>{@link #print(String)}</code> and then
@@ -606,7 +606,7 @@ public class JspWriterImpl extends JspWriter {
         print(x);
         println();
     }
-    
+
     /**
      * Print an Object and then terminate the line.  This method behaves as
      * though it invokes <code>{@link #print(Object)}</code> and then
@@ -617,5 +617,5 @@ public class JspWriterImpl extends JspWriter {
         print(x);
         println();
     }
-    
+
 }

==================================================
PerThreadTagHandlerPool.java
index 64d385dec2..0d35e169ac 100644
--- a/java/org/apache/jasper/runtime/PageContextImpl.java
+++ b/java/org/apache/jasper/runtime/PageContextImpl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -59,7 +59,7 @@ import org.apache.jasper.util.Enumerator;
 /**
  * Implementation of the PageContext class from the JSP spec. Also doubles as a
  * VariableResolver for the EL.
- * 
+ *
  * @author Anil K. Vijendran
  * @author Larry Cable
  * @author Hans Bergsten
@@ -70,7 +70,7 @@ import org.apache.jasper.util.Enumerator;
  */
 public class PageContextImpl extends PageContext {
 
-    private static final JspFactory jspf = JspFactory.getDefaultFactory(); 
+    private static final JspFactory jspf = JspFactory.getDefaultFactory();
 
     private BodyContentImpl[] outs;
 
@@ -96,12 +96,12 @@ public class PageContextImpl extends PageContext {
     private transient ServletResponse response;
 
     private transient HttpSession session;
-    
+
     private transient ELContextImpl elContext;
 
     private boolean isIncluded;
-    
-    
+
+
     // initial output stream
     private transient JspWriter out;
 
@@ -137,7 +137,7 @@ public class PageContextImpl extends PageContext {
         this.errorPageURL = errorPageURL;
         this.request = request;
         this.response = response;
-        
+
         // initialize application context
         this.applicationContext = JspApplicationContextImpl.getInstance(context);
 
@@ -611,7 +611,7 @@ public class PageContextImpl extends PageContext {
      * Returns the exception associated with this page context, if any. <p/>
      * Added wrapping for Throwables to avoid ClassCastException: see Bugzilla
      * 31171 for details.
-     * 
+     *
      * @return The Exception associated with this page context, if any.
      */
     @Override
@@ -940,7 +940,7 @@ public class PageContextImpl extends PageContext {
      * go away once the EL interpreter moves out of JSTL and into its own
      * project. For now, this is necessary because the standard machinery is too
      * slow.
-     * 
+     *
      * @param expression
      *            The expression to be evaluated
      * @param expectedType

==================================================
ProtectedFunctionMapper.java
index 3723e6226e..b8dbe2304d 100644
--- a/java/org/apache/jasper/runtime/PerThreadTagHandlerPool.java
+++ b/java/org/apache/jasper/runtime/PerThreadTagHandlerPool.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -31,7 +31,7 @@ import org.apache.jasper.Constants;
  *
  * @author Jan Luehe
  * @author Costin Manolache
- * 
+ *
  * @deprecated Use of ThreadLocals is likely to trigger memory leaks. Use
  *             TagHandlerPool. Will be removed in Tomcat 8.0.x.
  */
@@ -126,7 +126,7 @@ public class PerThreadTagHandlerPool extends TagHandlerPool {
      * Calls the release() method of all tag handlers in this tag handler pool.
      */
     @Override
-    public void release() {        
+    public void release() {
         Enumeration<PerThreadData> enumeration = perThreadDataVector.elements();
         while (enumeration.hasMoreElements()) {
             PerThreadData ptd = enumeration.nextElement();

==================================================
ServletResponseWrapperInclude.java
index dca4bd9e9e..6143d61cf2 100644
--- a/java/org/apache/jasper/runtime/ProtectedFunctionMapper.java
+++ b/java/org/apache/jasper/runtime/ProtectedFunctionMapper.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -31,7 +31,7 @@ import org.apache.jasper.security.SecurityUtil;
 /**
  * Maps EL functions to their Java method counterparts. Keeps the actual Method
  * objects protected so that JSP pages can't indirectly do reflection.
- * 
+ *
  * @author Mark Roth
  * @author Kin-man Chung
  */
@@ -59,7 +59,7 @@ public final class ProtectedFunctionMapper extends javax.el.FunctionMapper
      * retrieve an instance of the ProtectedFunctionMapper. This is necessary
      * since generated code does not have access to create instances of classes
      * in this package.
-     * 
+     *
      * @return A new protected function mapper.
      */
     public static ProtectedFunctionMapper getInstance() {
@@ -82,7 +82,7 @@ public final class ProtectedFunctionMapper extends javax.el.FunctionMapper
     /**
      * Stores a mapping from the given EL function prefix and name to the given
      * Java method.
-     * 
+     *
      * @param fnQName
      *            The EL function qualified name (including prefix)
      * @param c
@@ -128,7 +128,7 @@ public final class ProtectedFunctionMapper extends javax.el.FunctionMapper
      * Creates an instance for this class, and stores the Method for the given
      * EL function prefix and name. This method is used for the case when there
      * is only one function in the EL expression.
-     * 
+     *
      * @param fnQName
      *            The EL function qualified name (including prefix)
      * @param c
@@ -183,7 +183,7 @@ public final class ProtectedFunctionMapper extends javax.el.FunctionMapper
     /**
      * Resolves the specified local name and prefix into a Java.lang.Method.
      * Returns null if the prefix and local name are not found.
-     * 
+     *
      * @param prefix
      *            the prefix of the function
      * @param localName

==================================================
TagHandlerPool.java
index 0fa695dcc3..4128780b5d 100644
--- a/java/org/apache/jasper/runtime/ServletResponseWrapperInclude.java
+++ b/java/org/apache/jasper/runtime/ServletResponseWrapperInclude.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -45,7 +45,7 @@ public class ServletResponseWrapperInclude extends HttpServletResponseWrapper {
 
     private JspWriter jspWriter;
 
-    public ServletResponseWrapperInclude(ServletResponse response, 
+    public ServletResponseWrapperInclude(ServletResponse response,
                                          JspWriter jspWriter) {
         super((HttpServletResponse)response);
         this.printWriter = new PrintWriter(jspWriter);

==================================================
SecurityClassLoad.java
index e06655d0c4..bc0c0f1d8b 100644
--- a/java/org/apache/jasper/runtime/TagHandlerPool.java
+++ b/java/org/apache/jasper/runtime/TagHandlerPool.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -28,7 +28,7 @@ import org.apache.tomcat.InstanceManager;
 
 /**
  * Pool of tag handlers that can be reused.
- * 
+ *
  * @author Jan Luehe
  */
 public class TagHandlerPool {
@@ -93,7 +93,7 @@ public class TagHandlerPool {
     /**
      * Gets the next available tag handler from this tag handler pool,
      * instantiating one if this tag handler pool is empty.
-     * 
+     *
      * @param handlerClass
      *            Tag handler class
      * @return Reused or newly instantiated tag handler
@@ -129,7 +129,7 @@ public class TagHandlerPool {
      * Adds the given tag handler to this tag handler pool, unless this tag
      * handler pool has already reached its capacity, in which case the tag
      * handler's release() method is called.
-     * 
+     *
      * @param handler
      *            Tag handler to add to this tag handler pool
      */

==================================================
SecurityUtil.java
index 5f5e56f62f..00de553387 100644
--- a/java/org/apache/jasper/security/SecurityClassLoad.java
+++ b/java/org/apache/jasper/security/SecurityClassLoad.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -48,7 +48,7 @@ public final class SecurityClassLoad {
                 "runtime.JspRuntimeLibrary");
             loader.loadClass( basePackage +
                 "runtime.JspRuntimeLibrary$PrivilegedIntrospectHelper");
-            
+
             loader.loadClass( basePackage +
                 "runtime.ServletResponseWrapperInclude");
             loader.loadClass( basePackage +
@@ -61,47 +61,47 @@ public final class SecurityClassLoad {
             loader.loadClass( basePackage +
                 "runtime.ProtectedFunctionMapper$1");
             loader.loadClass( basePackage +
-                "runtime.ProtectedFunctionMapper$2"); 
+                "runtime.ProtectedFunctionMapper$2");
             loader.loadClass( basePackage +
                 "runtime.ProtectedFunctionMapper$3");
             loader.loadClass( basePackage +
-                "runtime.ProtectedFunctionMapper$4"); 
+                "runtime.ProtectedFunctionMapper$4");
 
             loader.loadClass( basePackage +
-                "runtime.PageContextImpl");      
+                "runtime.PageContextImpl");
             loader.loadClass( basePackage +
-                "runtime.PageContextImpl$1");      
+                "runtime.PageContextImpl$1");
             loader.loadClass( basePackage +
-                "runtime.PageContextImpl$2");      
+                "runtime.PageContextImpl$2");
             loader.loadClass( basePackage +
-                "runtime.PageContextImpl$3");      
+                "runtime.PageContextImpl$3");
             loader.loadClass( basePackage +
-                "runtime.PageContextImpl$4");      
+                "runtime.PageContextImpl$4");
             loader.loadClass( basePackage +
-                "runtime.PageContextImpl$5");      
+                "runtime.PageContextImpl$5");
             loader.loadClass( basePackage +
-                "runtime.PageContextImpl$6");      
+                "runtime.PageContextImpl$6");
             loader.loadClass( basePackage +
-                "runtime.PageContextImpl$7");      
+                "runtime.PageContextImpl$7");
             loader.loadClass( basePackage +
-                "runtime.PageContextImpl$8");      
+                "runtime.PageContextImpl$8");
             loader.loadClass( basePackage +
-                "runtime.PageContextImpl$9");      
+                "runtime.PageContextImpl$9");
             loader.loadClass( basePackage +
-                "runtime.PageContextImpl$10");      
+                "runtime.PageContextImpl$10");
             loader.loadClass( basePackage +
-                "runtime.PageContextImpl$11");      
+                "runtime.PageContextImpl$11");
             loader.loadClass( basePackage +
-                "runtime.PageContextImpl$12");      
+                "runtime.PageContextImpl$12");
             loader.loadClass( basePackage +
-                "runtime.PageContextImpl$13");      
+                "runtime.PageContextImpl$13");
 
             loader.loadClass( basePackage +
-                "runtime.JspContextWrapper");   
+                "runtime.JspContextWrapper");
 
             // Trigger loading of class and reading of property
             SecurityUtil.isPackageProtectionEnabled();
-            
+
             loader.loadClass( basePackage +
                 "servlet.JspServletWrapper");
 

==================================================
JasperLoader.java
index fc3a4a6ab1..880bf1a9f8 100644
--- a/java/org/apache/jasper/security/SecurityUtil.java
+++ b/java/org/apache/jasper/security/SecurityUtil.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -25,10 +25,10 @@ import org.apache.jasper.Constants;
  */
 
 public final class SecurityUtil{
-    
-    private static boolean packageDefinitionEnabled =  
+
+    private static boolean packageDefinitionEnabled =
          System.getProperty("package.definition") == null ? false : true;
-    
+
     /**
      * Return the <code>SecurityManager</code> only if Security is enabled AND
      * package protection mechanism is enabled.
@@ -39,7 +39,7 @@ public final class SecurityUtil{
         }
         return false;
     }
-    
+
 
     /**
      * Filter the specified message string for characters that are sensitive

==================================================
JspCServletContext.java
index 731d3c4f7d..48cd6a2b35 100644
--- a/java/org/apache/jasper/servlet/JasperLoader.java
+++ b/java/org/apache/jasper/servlet/JasperLoader.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -27,7 +27,7 @@ import java.security.PermissionCollection;
 import org.apache.jasper.Constants;
 
 /**
- * Class loader for loading servlet class files (corresponding to JSP files) 
+ * Class loader for loading servlet class files (corresponding to JSP files)
  * and tag handler class files (corresponding to tag files).
  *
  * @author Anil K. Vijendran
@@ -73,40 +73,40 @@ public class JasperLoader extends URLClassLoader {
      *     <code>Class</code> object is returned.</li>
      * <li>If the <code>delegate</code> property is set to <code>true</code>,
      *     call the <code>loadClass()</code> method of the parent class
-     *     loader, if any.</li>            
+     *     loader, if any.</li>
      * <li>Call <code>findClass()</code> to find this class in our locally
-     *     defined repositories.</li>      
+     *     defined repositories.</li>
      * <li>Call the <code>loadClass()</code> method of our parent
-     *     class loader, if any.</li>      
+     *     class loader, if any.</li>
      * </ul>
      * If the class was found using the above steps, and the
      * <code>resolve</code> flag is <code>true</code>, this method will then
      * call <code>resolveClass(Class)</code> on the resulting Class object.
-     *                                     
+     *
      * @param name Name of the class to be loaded
      * @param resolve If <code>true</code> then resolve the class
-     *                                     
+     *
      * @exception ClassNotFoundException if the class was not found
-     */                                    
+     */
     @Override
     public synchronized Class<?> loadClass(final String name, boolean resolve)
         throws ClassNotFoundException {
 
-        Class<?> clazz = null;                
-                                           
+        Class<?> clazz = null;
+
         // (0) Check our previously loaded class cache
-        clazz = findLoadedClass(name);     
-        if (clazz != null) {               
-            if (resolve)                   
-                resolveClass(clazz);       
-            return (clazz);        
-        }                          
-                          
+        clazz = findLoadedClass(name);
+        if (clazz != null) {
+            if (resolve)
+                resolveClass(clazz);
+            return (clazz);
+        }
+
         // (.5) Permission to access this class when using a SecurityManager
-        if (securityManager != null) {     
+        if (securityManager != null) {
             int dot = name.lastIndexOf('.');
-            if (dot >= 0) {                
-                try {        
+            if (dot >= 0) {
+                try {
                     // Do not call the security manager since by default, we grant that package.
                     if (!"org.apache.jasper.runtime".equalsIgnoreCase(name.substring(0,dot))){
                         securityManager.checkPackageAccess(name.substring(0,dot));
@@ -116,14 +116,14 @@ public class JasperLoader extends URLClassLoader {
                         "Restricted Class: " + name;
                     se.printStackTrace();
                     throw new ClassNotFoundException(error);
-                }                          
-            }                              
+                }
+            }
         }
 
         if( !name.startsWith(Constants.JSP_PACKAGE_NAME + '.') ) {
             // Class is not in org.apache.jsp, therefore, have our
             // parent load it
-            clazz = parent.loadClass(name);            
+            clazz = parent.loadClass(name);
             if( resolve )
                 resolveClass(clazz);
             return clazz;
@@ -132,10 +132,10 @@ public class JasperLoader extends URLClassLoader {
         return findClass(name);
     }
 
-    
+
     /**
      * Delegate to parent
-     * 
+     *
      * @see java.lang.ClassLoader#getResourceAsStream(java.lang.String)
      */
     @Override
@@ -153,8 +153,8 @@ public class JasperLoader extends URLClassLoader {
         }
         return is;
     }
-    
-    
+
+
     /**
      * Get the Permissions for a CodeSource.
      *

==================================================
JspServlet.java
index ec97119b99..772a496b0c 100644
--- a/java/org/apache/jasper/servlet/JspCServletContext.java
+++ b/java/org/apache/jasper/servlet/JspCServletContext.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -242,8 +242,8 @@ public class JspCServletContext implements ServletContext {
         }
 
     }
-            
-            
+
+
     /**
      * Return a request dispatcher for the specified context-relative path.
      *

==================================================
JspServletWrapper.java
index e6b451e5a4..369e70a981 100644
--- a/java/org/apache/jasper/servlet/JspServlet.java
+++ b/java/org/apache/jasper/servlet/JspServlet.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -81,14 +81,14 @@ public class JspServlet extends HttpServlet implements PeriodicEventListener {
      */
     @Override
     public void init(ServletConfig config) throws ServletException {
-        
+
         super.init(config);
         this.config = config;
         this.context = config.getServletContext();
-        
+
         // Initialize the JSP Runtime Context
         // Check for a custom Options implementation
-        String engineOptionsName = 
+        String engineOptionsName =
             config.getInitParameter("engineOptionsClass");
         if (engineOptionsName != null) {
             // Instantiate the indicated Options implementation
@@ -273,10 +273,10 @@ public class JspServlet extends HttpServlet implements PeriodicEventListener {
         }
 
     }
-    
+
 
     @Override
-    public void service (HttpServletRequest request, 
+    public void service (HttpServletRequest request,
                              HttpServletResponse response)
                 throws ServletException, IOException {
         //jspFile may be configured as an init-param for this servlet instance
@@ -307,7 +307,7 @@ public class JspServlet extends HttpServlet implements PeriodicEventListener {
                 }
             } else {
                 /*
-                 * Requested JSP has not been the target of a 
+                 * Requested JSP has not been the target of a
                  * RequestDispatcher.include(). Reconstruct its path from the
                  * request's getServletPath() and getPathInfo()
                  */
@@ -319,7 +319,7 @@ public class JspServlet extends HttpServlet implements PeriodicEventListener {
             }
         }
 
-        if (log.isDebugEnabled()) {    
+        if (log.isDebugEnabled()) {
             log.debug("JspEngine --> " + jspUri);
             log.debug("\t     ServletPath: " + request.getServletPath());
             log.debug("\t        PathInfo: " + request.getPathInfo());

==================================================
Util.java
index f89e82f45c..679a7cc396 100644
--- a/java/org/apache/jasper/servlet/JspServletWrapper.java
+++ b/java/org/apache/jasper/servlet/JspServletWrapper.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -75,7 +75,7 @@ public class JspServletWrapper {
         new HashMap<String,Long>();
 
     static {
-        // If this is missing, 
+        // If this is missing,
         ALWAYS_OUTDATED_DEPENDENCIES.put("/WEB-INF/web.xml", Long.valueOf(-1));
     }
 
@@ -155,7 +155,7 @@ public class JspServletWrapper {
 
     public Servlet getServlet() throws ServletException {
         // DCL on 'reload' requires that 'reload' be volatile
-        // (this also forces a read memory barrier, ensuring the 
+        // (this also forces a read memory barrier, ensuring the
         // new servlet object is read consistently)
         if (reload) {
             synchronized (this) {
@@ -164,7 +164,7 @@ public class JspServletWrapper {
                 if (reload) {
                     // This is to maintain the original protocol.
                     destroy();
-                    
+
                     final Servlet servlet;
 
                     try {
@@ -177,7 +177,7 @@ public class JspServletWrapper {
                     } catch (Exception e) {
                         throw new JasperException(e);
                     }
-                    
+
                     servlet.init(config);
 
                     if (!firstTime) {
@@ -188,7 +188,7 @@ public class JspServletWrapper {
                     reload = false;
                     // Volatile 'reload' forces in order write of 'theServlet' and new servlet object
                 }
-            }    
+            }
         }
         return theServlet;
     }
@@ -321,11 +321,11 @@ public class JspServletWrapper {
         return unloadHandle;
     }
 
-    public void service(HttpServletRequest request, 
+    public void service(HttpServletRequest request,
                         HttpServletResponse response,
                         boolean precompile)
             throws ServletException, IOException, FileNotFoundException {
-        
+
         Servlet servlet;
 
         try {
@@ -400,7 +400,7 @@ public class JspServletWrapper {
         }
 
         try {
-            
+
             /*
              * (3) Handle limitation of number of loaded Jsps
              */
@@ -449,7 +449,7 @@ public class JspServletWrapper {
             available = System.currentTimeMillis() +
                 (unavailableSeconds * 1000L);
             response.sendError
-                (HttpServletResponse.SC_SERVICE_UNAVAILABLE, 
+                (HttpServletResponse.SC_SERVICE_UNAVAILABLE,
                  ex.getMessage());
         } catch (ServletException ex) {
             if(options.getDevelopment()) {
@@ -539,7 +539,7 @@ public class JspServletWrapper {
                 }
             }
 
-            
+
             if (jspFrame == null ||
                     this.ctxt.getCompiler().getPageNodes() == null) {
                 // If we couldn't find a frame in the stack trace corresponding
@@ -568,9 +568,9 @@ public class JspServletWrapper {
                         ("jsp.exception", detail.getJspFileName(),
                                 "" + jspLineNumber) + Constants.NEWLINE +
                                 Constants.NEWLINE + detail.getJspExtract() +
-                                Constants.NEWLINE + Constants.NEWLINE + 
+                                Constants.NEWLINE + Constants.NEWLINE +
                                 "Stacktrace:", ex);
-                
+
             }
 
             return new JasperException(Localizer.getMessage

==================================================
Catch.java
index ca90ed1dbd..d55b58b14c 100644
--- a/java/org/apache/jasper/tagplugins/jstl/Util.java
+++ b/java/org/apache/jasper/tagplugins/jstl/Util.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -41,17 +41,17 @@ import org.apache.jasper.Constants;
  */
 
 public class Util {
-    
-    public static final String VALID_SCHEME_CHAR = 
+
+    public static final String VALID_SCHEME_CHAR =
         "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+.-";
-    
-    public static final String DEFAULT_ENCODING = 
+
+    public static final String DEFAULT_ENCODING =
         "ISO-8859-1";
-    
+
     public static final int HIGHEST_SPECIAL = '>';
-    
+
     private static char[][] specialCharactersRepresentation = new char[HIGHEST_SPECIAL + 1][];
-    
+
     static {
         specialCharactersRepresentation['&'] = "&amp;".toCharArray();
         specialCharactersRepresentation['<'] = "&lt;".toCharArray();
@@ -59,7 +59,7 @@ public class Util {
         specialCharactersRepresentation['"'] = "&#034;".toCharArray();
         specialCharactersRepresentation['\''] = "&#039;".toCharArray();
     }
-    
+
     /**
      * Converts the given string description of a scope to the corresponding
      * PageContext constant.
@@ -70,12 +70,12 @@ public class Util {
      * @param scope String description of scope
      *
      * @return PageContext constant corresponding to given scope description
-     * 
-     * taken from org.apache.taglibs.standard.tag.common.core.Util  
+     *
+     * taken from org.apache.taglibs.standard.tag.common.core.Util
      */
     public static int getScope(String scope){
         int ret = PageContext.PAGE_SCOPE;
-        
+
         if("request".equalsIgnoreCase(scope)){
             ret = PageContext.REQUEST_SCOPE;
         }else if("session".equalsIgnoreCase(scope)){
@@ -83,10 +83,10 @@ public class Util {
         }else if("application".equalsIgnoreCase(scope)){
             ret = PageContext.APPLICATION_SCOPE;
         }
-        
+
         return ret;
     }
-    
+
     /**
      * Returns <tt>true</tt> if our current URL is absolute,
      * <tt>false</tt> otherwise.
@@ -96,21 +96,21 @@ public class Util {
         if(url == null){
             return false;
         }
-        
+
         int colonPos = url.indexOf(":");
         if(colonPos == -1){
             return false;
         }
-        
+
         for(int i=0;i<colonPos;i++){
             if(VALID_SCHEME_CHAR.indexOf(url.charAt(i)) == -1){
                 return false;
             }
         }
-        
+
         return true;
     }
-    
+
     /**
      * Get the value associated with a content-type attribute.
      * Syntax defined in RFC 2045, section 5.1.
@@ -126,7 +126,7 @@ public class Util {
         if (index == -1) return null;
         index += 1; // positioned after the '='
         input = input.substring(index).trim();
-        
+
         if (input.charAt(0) == '"') {
             // attribute value is a quoted string
             begin = 1;
@@ -140,13 +140,13 @@ public class Util {
         }
         return input.substring(begin, end).trim();
     }
-    
+
     /**
      * Strips a servlet session ID from <tt>url</tt>.  The session ID
      * is encoded as a URL "path parameter" beginning with "jsessionid=".
      * We thus remove anything we find between ";jsessionid=" (inclusive)
      * and either EOS or a subsequent ';' (exclusive).
-     * 
+     *
      * taken from org.apache.taglibs.standard.tag.common.core.ImportSupport
      */
     public static String stripSession(String url) {
@@ -162,8 +162,8 @@ public class Util {
         }
         return u.toString();
     }
-    
-    
+
+
     /**
      * Performs the following substring replacements
      * (to facilitate output to XML/HTML pages):
@@ -175,7 +175,7 @@ public class Util {
      *    ' -> &#039;
      *
      * See also OutSupport.writeEscapedXml().
-     * 
+     *
      * taken from org.apache.taglibs.standard.tag.common.core.Util
      */
     @SuppressWarnings("null") // escapedBuffer cannot be null
@@ -184,7 +184,7 @@ public class Util {
         int length = buffer.length();
         char[] arrayBuffer = buffer.toCharArray();
         StringBuilder escapedBuffer = null;
-        
+
         for (int i = 0; i < length; i++) {
             char c = arrayBuffer[i];
             if (c <= HIGHEST_SPECIAL) {
@@ -214,7 +214,7 @@ public class Util {
         }
         return escapedBuffer.toString();
     }
-    
+
     /** Utility methods
      * taken from org.apache.taglibs.standard.tag.common.core.UrlSupport
      */
@@ -224,7 +224,7 @@ public class Util {
         // don't touch absolute URLs
         if (isAbsoluteUrl(url))
             return url;
-        
+
         // normalize relative URLs against a context root
         HttpServletRequest request =
             (HttpServletRequest) pageContext.getRequest();
@@ -248,12 +248,12 @@ public class Util {
             }
         }
     }
-    
-    /** Wraps responses to allow us to retrieve results as Strings. 
-     * mainly taken from org.apache.taglibs.standard.tag.common.core.importSupport 
+
+    /** Wraps responses to allow us to retrieve results as Strings.
+     * mainly taken from org.apache.taglibs.standard.tag.common.core.importSupport
      */
     public static class ImportResponseWrapper extends HttpServletResponseWrapper{
-        
+
         private StringWriter sw = new StringWriter();
         private ByteArrayOutputStream bos = new ByteArrayOutputStream();
         private ServletOutputStream sos = new ServletOutputStream() {
@@ -266,12 +266,12 @@ public class Util {
         private boolean isStreamUsed;
         private int status = 200;
         private String charEncoding;
-        
+
         public ImportResponseWrapper(HttpServletResponse arg0) {
             super(arg0);
             // TODO Auto-generated constructor stub
         }
-        
+
         @Override
         public PrintWriter getWriter() {
             if (isStreamUsed)
@@ -280,7 +280,7 @@ public class Util {
             isWriterUsed = true;
             return new PrintWriter(sw);
         }
-        
+
         @Override
         public ServletOutputStream getOutputStream() {
             if (isWriterUsed)
@@ -289,37 +289,37 @@ public class Util {
             isStreamUsed = true;
             return sos;
         }
-        
+
         /** Has no effect. */
         @Override
         public void setContentType(String x) {
             // ignore
         }
-        
+
         /** Has no effect. */
         @Override
         public void setLocale(Locale x) {
             // ignore
         }
-        
+
         @Override
         public void setStatus(int status) {
             this.status = status;
         }
-        
+
         @Override
         public int getStatus() {
             return status;
         }
-        
+
         public String getCharEncoding(){
             return this.charEncoding;
         }
-        
+
         public void setCharEncoding(String ce){
             this.charEncoding = ce;
         }
-        
+
         public String getString() throws UnsupportedEncodingException {
             if (isWriterUsed)
                 return sw.toString();
@@ -332,5 +332,5 @@ public class Util {
                 return ""; // target didn't write anything
         }
     }
-    
+
 }

==================================================
Choose.java
index 7e006523ef..f757580eb2 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Catch.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Catch.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,43 +22,43 @@ import org.apache.jasper.compiler.tagplugin.TagPlugin;
 import org.apache.jasper.compiler.tagplugin.TagPluginContext;
 
 public class Catch implements TagPlugin {
-    
+
     @Override
     public void doTag(TagPluginContext ctxt) {
-        
+
         //flag for the existence of the var attribute
         boolean hasVar = ctxt.isAttributeSpecified("var");
-        
+
         //temp name for exception and caught
         String exceptionName = ctxt.getTemporaryVariableName();
         String caughtName = ctxt.getTemporaryVariableName();
-        
+
         //main part to generate code
         ctxt.generateJavaSource("boolean " + caughtName + " = false;");
         ctxt.generateJavaSource("try{");
         ctxt.generateBody();
         ctxt.generateJavaSource("}");
-        
+
         //do catch
         ctxt.generateJavaSource("catch(Throwable " + exceptionName + "){");
-        
-        //if the var specified, the exception object should 
-        //be set to the attribute "var" defines in page scope 
+
+        //if the var specified, the exception object should
+        //be set to the attribute "var" defines in page scope
         if(hasVar){
             String strVar = ctxt.getConstantAttribute("var");
-            ctxt.generateJavaSource("    pageContext.setAttribute(\"" + strVar + "\", " 
+            ctxt.generateJavaSource("    pageContext.setAttribute(\"" + strVar + "\", "
                     + exceptionName + ", PageContext.PAGE_SCOPE);");
         }
-        
-        //whenever there's exception caught, 
+
+        //whenever there's exception caught,
         //the flag caught should be set true;
         ctxt.generateJavaSource("    " + caughtName + " = true;");
         ctxt.generateJavaSource("}");
-        
+
         //do finally
         ctxt.generateJavaSource("finally{");
-        
-        //if var specified, the attribute it defines 
+
+        //if var specified, the attribute it defines
         //in page scope should be removed
         if(hasVar){
             String strVar = ctxt.getConstantAttribute("var");
@@ -66,8 +66,8 @@ public class Catch implements TagPlugin {
             ctxt.generateJavaSource("        pageContext.removeAttribute(\"" + strVar + "\", PageContext.PAGE_SCOPE);");
             ctxt.generateJavaSource("    }");
         }
-        
+
         ctxt.generateJavaSource("}");
     }
-    
+
 }

==================================================
ForEach.java
index 97eca05e49..c0043b6af8 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Choose.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Choose.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,13 +22,13 @@ import org.apache.jasper.compiler.tagplugin.TagPlugin;
 import org.apache.jasper.compiler.tagplugin.TagPluginContext;
 
 public final class Choose implements TagPlugin {
-    
+
     @Override
     public void doTag(TagPluginContext ctxt) {
-        
+
         // Not much to do here, much of the work will be done in the
         // containing tags, <c:when> and <c:otherwise>.
-        
+
         ctxt.generateBody();
         // See comments in When.java for the reason "}" is generated here.
         ctxt.generateJavaSource("}");

==================================================
ForTokens.java
index 2b8c00f399..c585959701 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/ForEach.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/ForEach.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,31 +22,31 @@ import org.apache.jasper.compiler.tagplugin.TagPlugin;
 import org.apache.jasper.compiler.tagplugin.TagPluginContext;
 
 public final class ForEach implements TagPlugin {
-    
+
     private boolean hasVar, hasBegin, hasEnd, hasStep;
-    
+
     @Override
     public void doTag(TagPluginContext ctxt) {
-        
+
         String index = null;
-        
+
         boolean hasVarStatus = ctxt.isAttributeSpecified("varStatus");
         if (hasVarStatus) {
             ctxt.dontUseTagPlugin();
             return;
         }
-        
+
         hasVar = ctxt.isAttributeSpecified("var");
         hasBegin = ctxt.isAttributeSpecified("begin");
         hasEnd = ctxt.isAttributeSpecified("end");
         hasStep = ctxt.isAttributeSpecified("step");
-        
+
         boolean hasItems = ctxt.isAttributeSpecified("items");
         if (hasItems) {
             doCollection(ctxt);
             return;
         }
-        
+
         // We must have a begin and end attributes
         index = ctxt.getTemporaryVariableName();
         ctxt.generateJavaSource("for (int " + index + " = ");
@@ -61,7 +61,7 @@ public final class ForEach implements TagPlugin {
         else {
             ctxt.generateJavaSource("; " + index + "++) {");
         }
-        
+
         // If var is specified and the body contains an EL, then sycn
         // the var attribute
         if (hasVar /* && ctxt.hasEL() */) {
@@ -72,21 +72,21 @@ public final class ForEach implements TagPlugin {
         ctxt.generateBody();
         ctxt.generateJavaSource("}");
     }
-    
+
     /**
      * Generate codes for Collections
      * The pseudo code is:
      */
     private void doCollection(TagPluginContext ctxt) {
-        
+
         ctxt.generateImport("java.util.*");
         generateIterators(ctxt);
-        
+
         String itemsV = ctxt.getTemporaryVariableName();
         ctxt.generateJavaSource("Object " + itemsV + "= ");
         ctxt.generateAttribute("items");
         ctxt.generateJavaSource(";");
-        
+
         String indexV=null, beginV=null, endV=null, stepV=null;
         if (hasBegin) {
             beginV = ctxt.getTemporaryVariableName();
@@ -108,7 +108,7 @@ public final class ForEach implements TagPlugin {
             ctxt.generateAttribute("step");
             ctxt.generateJavaSource(";");
         }
-        
+
         String iterV = ctxt.getTemporaryVariableName();
         ctxt.generateJavaSource("Iterator " + iterV + " = null;");
         // Object[]
@@ -138,23 +138,23 @@ public final class ForEach implements TagPlugin {
         // double[]
         ctxt.generateJavaSource("else if (" + itemsV + " instanceof double[])");
         ctxt.generateJavaSource(iterV + "=toIterator((double[])" + itemsV + ");");
-        
+
         // Collection
         ctxt.generateJavaSource("else if (" + itemsV + " instanceof Collection)");
         ctxt.generateJavaSource(iterV + "=((Collection)" + itemsV + ").iterator();");
-        
+
         // Iterator
         ctxt.generateJavaSource("else if (" + itemsV + " instanceof Iterator)");
         ctxt.generateJavaSource(iterV + "=(Iterator)" + itemsV + ";");
-        
+
         // Enumeration
         ctxt.generateJavaSource("else if (" + itemsV + " instanceof Enumeration)");
         ctxt.generateJavaSource(iterV + "=toIterator((Enumeration)" + itemsV + ");");
-        
+
         // Map
         ctxt.generateJavaSource("else if (" + itemsV + " instanceof Map)");
         ctxt.generateJavaSource(iterV + "=((Map)" + itemsV + ").entrySet().iterator();");
-        
+
         if (hasBegin) {
             String tV = ctxt.getTemporaryVariableName();
             ctxt.generateJavaSource("for (int " + tV + "=" + beginV + ";" +
@@ -162,16 +162,16 @@ public final class ForEach implements TagPlugin {
                     tV + "--)");
             ctxt.generateJavaSource(iterV + ".next();");
         }
-        
+
         ctxt.generateJavaSource("while (" + iterV + ".hasNext()){");
         if (hasVar) {
             ctxt.generateJavaSource("_jspx_page_context.setAttribute(");
             ctxt.generateAttribute("var");
             ctxt.generateJavaSource(", " + iterV + ".next());");
         }
-        
+
         ctxt.generateBody();
-        
+
         if (hasStep) {
             String tV = ctxt.getTemporaryVariableName();
             ctxt.generateJavaSource("for (int " + tV + "=" + stepV + "-1;" +
@@ -197,14 +197,14 @@ public final class ForEach implements TagPlugin {
         }
         ctxt.generateJavaSource("}"); // while
     }
-    
+
     /**
      * Generate iterators for data types supported in items
      */
     private void generateIterators(TagPluginContext ctxt) {
-        
+
         // Object[]
-        ctxt.generateDeclaration("ObjectArrayIterator", 
+        ctxt.generateDeclaration("ObjectArrayIterator",
                 "private Iterator toIterator(final Object[] a){\n" +
                 "  return (new Iterator() {\n" +
                 "    int index=0;\n" +
@@ -216,9 +216,9 @@ public final class ForEach implements TagPlugin {
                 "  });\n" +
                 "}"
         );
-        
+
         // boolean[]
-        ctxt.generateDeclaration("booleanArrayIterator", 
+        ctxt.generateDeclaration("booleanArrayIterator",
                 "private Iterator toIterator(final boolean[] a){\n" +
                 "  return (new Iterator() {\n" +
                 "    int index=0;\n" +
@@ -230,9 +230,9 @@ public final class ForEach implements TagPlugin {
                 "  });\n" +
                 "}"
         );
-        
+
         // byte[]
-        ctxt.generateDeclaration("byteArrayIterator", 
+        ctxt.generateDeclaration("byteArrayIterator",
                 "private Iterator toIterator(final byte[] a){\n" +
                 "  return (new Iterator() {\n" +
                 "    int index=0;\n" +
@@ -244,9 +244,9 @@ public final class ForEach implements TagPlugin {
                 "  });\n" +
                 "}"
         );
-        
+
         // char[]
-        ctxt.generateDeclaration("charArrayIterator", 
+        ctxt.generateDeclaration("charArrayIterator",
                 "private Iterator toIterator(final char[] a){\n" +
                 "  return (new Iterator() {\n" +
                 "    int index=0;\n" +
@@ -258,9 +258,9 @@ public final class ForEach implements TagPlugin {
                 "  });\n" +
                 "}"
         );
-        
+
         // short[]
-        ctxt.generateDeclaration("shortArrayIterator", 
+        ctxt.generateDeclaration("shortArrayIterator",
                 "private Iterator toIterator(final short[] a){\n" +
                 "  return (new Iterator() {\n" +
                 "    int index=0;\n" +
@@ -272,9 +272,9 @@ public final class ForEach implements TagPlugin {
                 "  });\n" +
                 "}"
         );
-        
+
         // int[]
-        ctxt.generateDeclaration("intArrayIterator", 
+        ctxt.generateDeclaration("intArrayIterator",
                 "private Iterator toIterator(final int[] a){\n" +
                 "  return (new Iterator() {\n" +
                 "    int index=0;\n" +
@@ -286,9 +286,9 @@ public final class ForEach implements TagPlugin {
                 "  });\n" +
                 "}"
         );
-        
+
         // long[]
-        ctxt.generateDeclaration("longArrayIterator", 
+        ctxt.generateDeclaration("longArrayIterator",
                 "private Iterator toIterator(final long[] a){\n" +
                 "  return (new Iterator() {\n" +
                 "    int index=0;\n" +
@@ -300,7 +300,7 @@ public final class ForEach implements TagPlugin {
                 "  });\n" +
                 "}"
         );
-        
+
         // float[]
         ctxt.generateDeclaration("floatArrayIterator",
                 "private Iterator toIterator(final float[] a){\n" +
@@ -314,7 +314,7 @@ public final class ForEach implements TagPlugin {
                 "  });\n" +
                 "}"
         );
-        
+
         // double[]
         ctxt.generateDeclaration("doubleArrayIterator",
                 "private Iterator toIterator(final double[] a){\n" +
@@ -328,7 +328,7 @@ public final class ForEach implements TagPlugin {
                 "  });\n" +
                 "}"
         );
-        
+
         // Enumeration
         ctxt.generateDeclaration("enumIterator",
                 "private Iterator toIterator(final Enumeration e){\n" +
@@ -341,6 +341,6 @@ public final class ForEach implements TagPlugin {
                 "  });\n" +
                 "}"
         );
-        
+
     }
 }

==================================================
If.java
index 99d31da2d6..6d32c56578 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/ForTokens.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/ForTokens.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,23 +22,23 @@ import org.apache.jasper.compiler.tagplugin.TagPlugin;
 import org.apache.jasper.compiler.tagplugin.TagPluginContext;
 
 public class ForTokens implements TagPlugin {
-    
+
     @Override
     public void doTag(TagPluginContext ctxt) {
         boolean hasVar, hasVarStatus, hasBegin, hasEnd, hasStep;
-        
+
         //init the flags
         hasVar = ctxt.isAttributeSpecified("var");
         hasVarStatus = ctxt.isAttributeSpecified("varStatus");
         hasBegin = ctxt.isAttributeSpecified("begin");
         hasEnd = ctxt.isAttributeSpecified("end");
         hasStep = ctxt.isAttributeSpecified("step");
-        
+
         if(hasVarStatus){
             ctxt.dontUseTagPlugin();
             return;
         }
-        
+
         //define all the temp variables' names
         String itemsName = ctxt.getTemporaryVariableName();
         String delimsName = ctxt.getTemporaryVariableName();
@@ -49,21 +49,21 @@ public class ForTokens implements TagPlugin {
         String index = ctxt.getTemporaryVariableName();
         String temp  = ctxt.getTemporaryVariableName();
         String tokensCountName = ctxt.getTemporaryVariableName();
-        
-        //get the value of the "items" attribute 
+
+        //get the value of the "items" attribute
         ctxt.generateJavaSource("String " + itemsName + " = (String)");
         ctxt.generateAttribute("items");
         ctxt.generateJavaSource(";");
-        
+
         //get the value of the "delim" attribute
         ctxt.generateJavaSource("String " + delimsName + " = (String)");
         ctxt.generateAttribute("delims");
         ctxt.generateJavaSource(";");
-        
+
         //new a StringTokenizer Object according to the "items" and the "delim"
         ctxt.generateJavaSource("java.util.StringTokenizer " + stName + " = " +
                 "new java.util.StringTokenizer(" + itemsName + ", " + delimsName + ");");
-        
+
         //if "begin" specified, move the token to the "begin" place
         //and record the begin index. default begin place is 0.
         ctxt.generateJavaSource("int " + tokensCountName + " = " + stName + ".countTokens();");
@@ -75,10 +75,10 @@ public class ForTokens implements TagPlugin {
         }else{
             ctxt.generateJavaSource("int " + beginName + " = 0;");
         }
-        
+
         //when "end" is specified, if the "end" is more than the last index,
         //record the end place as the last index, otherwise, record it as "end";
-        //default end place is the last index 
+        //default end place is the last index
         if(hasEnd){
             ctxt.generateJavaSource("int " + endName + " = 0;"  );
             ctxt.generateJavaSource("if((" + tokensCountName + " - 1) < ");
@@ -92,7 +92,7 @@ public class ForTokens implements TagPlugin {
         }else{
             ctxt.generateJavaSource("int " + endName + " = " + tokensCountName + " - 1;");
         }
-        
+
         //get the step value from "step" if specified.
         //default step value is 1.
         if(hasStep){
@@ -102,7 +102,7 @@ public class ForTokens implements TagPlugin {
         }else{
             ctxt.generateJavaSource("int " + stepName + " = 1;");
         }
-        
+
         //the loop
         ctxt.generateJavaSource("for(int " + index + " = " + beginName + "; " + index + " <= " + endName + "; " + index + "++){");
         ctxt.generateJavaSource("    String " + temp + " = " + stName + ".nextToken();");
@@ -116,5 +116,5 @@ public class ForTokens implements TagPlugin {
         ctxt.generateJavaSource("    }");
         ctxt.generateJavaSource("}");
     }
-    
+
 }

==================================================
Import.java
index 662c740c25..62d64e3ea4 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/If.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/If.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,7 +22,7 @@ import org.apache.jasper.compiler.tagplugin.TagPlugin;
 import org.apache.jasper.compiler.tagplugin.TagPluginContext;
 
 public final class If implements TagPlugin {
-    
+
     @Override
     public void doTag(TagPluginContext ctxt) {
         String condV = ctxt.getTemporaryVariableName();

==================================================
Otherwise.java
index 20900191bc..49389eb857 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Import.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Import.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -23,25 +23,25 @@ import org.apache.jasper.compiler.tagplugin.TagPluginContext;
 import org.apache.jasper.tagplugins.jstl.Util;
 
 public class Import implements TagPlugin {
-    
+
     @Override
     public void doTag(TagPluginContext ctxt) {
         boolean hasContext, hasVar, hasScope, hasVarReader, hasCharEncoding;
-        
+
         //flags
         hasContext  = ctxt.isAttributeSpecified("context");
         hasVar = ctxt.isAttributeSpecified("var");
         hasScope = ctxt.isAttributeSpecified("scope");
         hasVarReader = ctxt.isAttributeSpecified("varReader");
         hasCharEncoding = ctxt.isAttributeSpecified("charEncoding");
-        
+
         //variables' names
-        String urlName = ctxt.getTemporaryVariableName();           
-        String contextName = ctxt.getTemporaryVariableName();       
+        String urlName = ctxt.getTemporaryVariableName();
+        String contextName = ctxt.getTemporaryVariableName();
         String iauName = ctxt.getTemporaryVariableName();           // is absolute url
         String urlObjName = ctxt.getTemporaryVariableName();        //URL object
         String ucName = ctxt.getTemporaryVariableName();            //URLConnection
-        String inputStreamName = ctxt.getTemporaryVariableName();   
+        String inputStreamName = ctxt.getTemporaryVariableName();
         String tempReaderName = ctxt.getTemporaryVariableName();
         String tempReaderName2 = ctxt.getTemporaryVariableName();
         String charSetName = ctxt.getTemporaryVariableName();
@@ -55,115 +55,115 @@ public class Import implements TagPlugin {
         String brName = ctxt.getTemporaryVariableName();            //BufferedReader name
         String sbName = ctxt.getTemporaryVariableName();            //StringBuilder name
         String tempStringName = ctxt.getTemporaryVariableName();
-        
+
         //is absolute url
         ctxt.generateJavaSource("boolean " + iauName + ";");
-        
+
         //get the url value
         ctxt.generateJavaSource("String " + urlName + " = ");
         ctxt.generateAttribute("url");
         ctxt.generateJavaSource(";");
-        
+
         //validate the url
         ctxt.generateJavaSource("if(" + urlName + " == null || " + urlName + ".equals(\"\")){");
         ctxt.generateJavaSource("    throw new JspTagException(\"The \\\"url\\\" attribute " +
         "illegally evaluated to \\\"null\\\" or \\\"\\\" in &lt;import&gt;\");");
         ctxt.generateJavaSource("}");
-        
+
         //initialize the is_absolute_url
         ctxt.generateJavaSource(iauName + " = " +
                 "org.apache.jasper.tagplugins.jstl.Util.isAbsoluteUrl(" + urlName + ");");
-        
+
         //validate the context
         if(hasContext){
-            
+
             ctxt.generateJavaSource("String " + contextName + " = ");
             ctxt.generateAttribute("context");
             ctxt.generateJavaSource(";");
-            
+
             ctxt.generateJavaSource("if((!" + contextName + ".startsWith(\"/\")) " +
                     "|| (!" + urlName + ".startsWith(\"/\"))){");
             ctxt.generateJavaSource("    throw new JspTagException" +
                     "(\"In URL tags, when the \\\"context\\\" attribute is specified, " +
             "values of both \\\"context\\\" and \\\"url\\\" must start with \\\"/\\\".\");");
             ctxt.generateJavaSource("}");
-            
+
         }
-        
+
         //define charset
         ctxt.generateJavaSource("String " + charSetName + " = null;");
-        
+
         //if the charEncoding attribute is specified
         if(hasCharEncoding){
-            
+
             //initialize the charEncoding
             ctxt.generateJavaSource("String " + charEncodingName + " = ");
             ctxt.generateAttribute("charEncoding");
             ctxt.generateJavaSource(";");
-            
+
             //assign appropriate value to the charset
             ctxt.generateJavaSource("if(null != " + charEncodingName + " " +
                     "&& !" + charEncodingName + ".equals(\"\")){");
-            ctxt.generateJavaSource("    " + charSetName + " = " 
+            ctxt.generateJavaSource("    " + charSetName + " = "
                     + charEncodingName + ";");
             ctxt.generateJavaSource("}");
         }
-        
+
         //reshape the url string
         ctxt.generateJavaSource("if(!"+iauName+"){");
         ctxt.generateJavaSource("    if(!" + urlName + ".startsWith(\"/\")){");
         ctxt.generateJavaSource("        String " + servletPathName + " = " +
         "((HttpServletRequest)pageContext.getRequest()).getServletPath();");
-        ctxt.generateJavaSource("        " + urlName + " = " 
+        ctxt.generateJavaSource("        " + urlName + " = "
                 + servletPathName + ".substring(0," + servletPathName + ".lastIndexOf('/')) + '/' + " + urlName + ";");
         ctxt.generateJavaSource("    }");
         ctxt.generateJavaSource("}");
-        
+
         //if the varReader attribute specified
         if(hasVarReader){
-            
+
             //get the String value of varReader
             ctxt.generateJavaSource("String " + varReaderName + " = ");
             ctxt.generateAttribute("varReader");
             ctxt.generateJavaSource(";");
-            
+
             //if the url is absolute url
             ctxt.generateJavaSource("if(" + iauName + "){");
-            
+
             //get the content of the target
             ctxt.generateJavaSource("    java.net.URL " + urlObjName + " = new java.net.URL(" + urlName + ");");
-            ctxt.generateJavaSource("    java.net.URLConnection " + ucName + " = " 
+            ctxt.generateJavaSource("    java.net.URLConnection " + ucName + " = "
                     + urlObjName + ".openConnection();");
-            ctxt.generateJavaSource("    java.io.InputStream " + inputStreamName + " = " 
+            ctxt.generateJavaSource("    java.io.InputStream " + inputStreamName + " = "
                     + ucName + ".getInputStream();");
-            
+
             ctxt.generateJavaSource("    if(" + charSetName + " == null){");
-            ctxt.generateJavaSource("        String " + contentTypeName + " = " 
+            ctxt.generateJavaSource("        String " + contentTypeName + " = "
                     + ucName + ".getContentType();");
             ctxt.generateJavaSource("        if(null != " + contentTypeName + "){");
             ctxt.generateJavaSource("            " + charSetName + " = " +
                     "org.apache.jasper.tagplugins.jstl.Util.getContentTypeAttribute(" + contentTypeName + ", \"charset\");");
-            ctxt.generateJavaSource("            if(" + charSetName + " == null) " 
+            ctxt.generateJavaSource("            if(" + charSetName + " == null) "
                     + charSetName + " = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;");
             ctxt.generateJavaSource("        }else{");
             ctxt.generateJavaSource("            " + charSetName + " = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;");
             ctxt.generateJavaSource("        }");
             ctxt.generateJavaSource("    }");
-            
+
             if(!hasCharEncoding){
                 ctxt.generateJavaSource("    String " + contentTypeName + " = " + ucName + ".getContentType();");
             }
-            
+
             //define the Reader
             ctxt.generateJavaSource("    java.io.Reader " + tempReaderName + " = null;");
-            
+
             //initialize the Reader object
             ctxt.generateJavaSource("    try{");
             ctxt.generateJavaSource("        " + tempReaderName + " = new java.io.InputStreamReader(" + inputStreamName + ", " + charSetName + ");");
             ctxt.generateJavaSource("    }catch(Exception ex){");
             ctxt.generateJavaSource("        " + tempReaderName + " = new java.io.InputStreamReader(" + inputStreamName + ", org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING);");
             ctxt.generateJavaSource("    }");
-            
+
             //validate the response
             ctxt.generateJavaSource("    if(" + ucName + " instanceof java.net.HttpURLConnection){");
             ctxt.generateJavaSource("        int status = ((java.net.HttpURLConnection) " + ucName + ").getResponseCode();");
@@ -171,19 +171,19 @@ public class Import implements TagPlugin {
             ctxt.generateJavaSource("            throw new JspTagException(status + \" \" + " + urlName + ");");
             ctxt.generateJavaSource("        }");
             ctxt.generateJavaSource("    }");
-            
+
             //set attribute in the page context scope
             ctxt.generateJavaSource("    pageContext.setAttribute(" + varReaderName + ", " + tempReaderName + ");");
-            
+
             //if the url is relative
             ctxt.generateJavaSource("}else{");
-            
+
             //if the url is relative, http request is needed
             ctxt.generateJavaSource("    if (!(pageContext.getRequest() instanceof HttpServletRequest  " +
             "&& pageContext.getResponse() instanceof HttpServletResponse)){");
             ctxt.generateJavaSource("        throw new JspTagException(\"Relative &lt;import&gt; from non-HTTP request not allowed\");");
             ctxt.generateJavaSource("    }");
-            
+
             //get the servlet context of the context defined in the context attribute
             ctxt.generateJavaSource("    ServletContext " + servletContextName + " = null;");
             if(hasContext){
@@ -195,7 +195,7 @@ public class Import implements TagPlugin {
             }else{
                 ctxt.generateJavaSource("    " + servletContextName + " = pageContext.getServletContext();");
             }
-            
+
             //
             ctxt.generateJavaSource("    if(" + servletContextName + " == null){");
             if(hasContext){
@@ -204,11 +204,11 @@ public class Import implements TagPlugin {
                 ctxt.generateJavaSource("        throw new JspTagException(\"Unable to get RequestDispatcher for  URL: \\\" \" +" + urlName + "+ \" \\\". Verify values and/or enable cross context access.\");");
             }
             ctxt.generateJavaSource("    }");
-            
+
             //get the request dispatcher
             ctxt.generateJavaSource("    RequestDispatcher " + requestDispatcherName + " = " + servletContextName + ".getRequestDispatcher(org.apache.jasper.tagplugins.jstl.Util.stripSession("+urlName+"));");
             ctxt.generateJavaSource("    if(" + requestDispatcherName + " == null) throw new JspTagException(org.apache.jasper.tagplugins.jstl.Util.stripSession("+urlName+"));");
-            
+
             //initialize a ImportResponseWrapper to include the resource
             ctxt.generateJavaSource("    org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper " + irwName + " = new org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper((HttpServletResponse) pageContext.getResponse());");
             ctxt.generateJavaSource("    if(" + charSetName + " == null){");
@@ -228,30 +228,30 @@ public class Import implements TagPlugin {
             ctxt.generateJavaSource("        else");
             ctxt.generateJavaSource("            throw new JspException(rc);");
             ctxt.generateJavaSource("    }");
-            
+
             //validate the response status
             ctxt.generateJavaSource("    if(" + irwName + ".getStatus() < 200 || " + irwName + ".getStatus() > 299){");
             ctxt.generateJavaSource("        throw new JspTagException(" + irwName + ".getStatus()+\" \" + org.apache.jasper.tagplugins.jstl.Util.stripSession(" + urlName + "));");
             ctxt.generateJavaSource("    }");
-            
+
             //push in the page context
             ctxt.generateJavaSource("    java.io.Reader " + tempReaderName + " = new java.io.StringReader(" + irwName + ".getString());");
             ctxt.generateJavaSource("    pageContext.setAttribute(" + varReaderName + ", " + tempReaderName + ");");
-            
+
             ctxt.generateJavaSource("}");
-            
+
             //execute the body action
             ctxt.generateBody();
-            
+
             //close the reader
             ctxt.generateJavaSource("java.io.Reader " + tempReaderName2 + " = (java.io.Reader)pageContext.getAttribute(" + varReaderName + ");");
             ctxt.generateJavaSource("if(" + tempReaderName2 + " != null) " + tempReaderName2 + ".close();");
             ctxt.generateJavaSource("pageContext.removeAttribute(" + varReaderName + ",1);");
         }
-        
-        //if the varReader is not specified 
+
+        //if the varReader is not specified
         else{
-            
+
             ctxt.generateJavaSource("pageContext.setAttribute(\"url_without_param\"," + urlName + ");");
             ctxt.generateBody();
             ctxt.generateJavaSource(urlName + " = (String)pageContext.getAttribute(\"url_without_param\");");
@@ -261,37 +261,37 @@ public class Import implements TagPlugin {
                 strScope = ctxt.getConstantAttribute("scope");
             }
             int iScope = Util.getScope(strScope);
-            
+
             ctxt.generateJavaSource("String " + tempStringName + " = null;");
-            
+
             ctxt.generateJavaSource("if(" + iauName + "){");
-            
+
             //get the content of the target
             ctxt.generateJavaSource("    java.net.URL " + urlObjName + " = new java.net.URL(" + urlName + ");");
             ctxt.generateJavaSource("    java.net.URLConnection " + ucName + " = " + urlObjName + ".openConnection();");
             ctxt.generateJavaSource("    java.io.InputStream " + inputStreamName + " = " + ucName + ".getInputStream();");
             ctxt.generateJavaSource("    java.io.Reader " + tempReaderName + " = null;");
-            
+
             ctxt.generateJavaSource("    if(" + charSetName + " == null){");
-            ctxt.generateJavaSource("        String " + contentTypeName + " = " 
+            ctxt.generateJavaSource("        String " + contentTypeName + " = "
                     + ucName + ".getContentType();");
             ctxt.generateJavaSource("        if(null != " + contentTypeName + "){");
             ctxt.generateJavaSource("            " + charSetName + " = " +
                     "org.apache.jasper.tagplugins.jstl.Util.getContentTypeAttribute(" + contentTypeName + ", \"charset\");");
-            ctxt.generateJavaSource("            if(" + charSetName + " == null) " 
+            ctxt.generateJavaSource("            if(" + charSetName + " == null) "
                     + charSetName + " = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;");
             ctxt.generateJavaSource("        }else{");
             ctxt.generateJavaSource("            " + charSetName + " = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;");
             ctxt.generateJavaSource("        }");
             ctxt.generateJavaSource("    }");
-            
+
             ctxt.generateJavaSource("    try{");
             ctxt.generateJavaSource("        " + tempReaderName + " = new java.io.InputStreamReader(" + inputStreamName + "," + charSetName + ");");
             ctxt.generateJavaSource("    }catch(Exception ex){");
             //ctxt.generateJavaSource("        throw new JspTagException(ex.toString());");
             ctxt.generateJavaSource("        " + tempReaderName + " = new java.io.InputStreamReader(" + inputStreamName + ",org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING);");
             ctxt.generateJavaSource("    }");
-            
+
             //validate the response
             ctxt.generateJavaSource("    if(" + ucName + " instanceof java.net.HttpURLConnection){");
             ctxt.generateJavaSource("        int status = ((java.net.HttpURLConnection) " + ucName + ").getResponseCode();");
@@ -299,22 +299,22 @@ public class Import implements TagPlugin {
             ctxt.generateJavaSource("            throw new JspTagException(status + \" \" + " + urlName + ");");
             ctxt.generateJavaSource("        }");
             ctxt.generateJavaSource("    }");
-            
+
             ctxt.generateJavaSource("    java.io.BufferedReader " + brName + " =  new java.io.BufferedReader(" + tempReaderName + ");");
             ctxt.generateJavaSource("    StringBuilder " + sbName + " = new StringBuilder();");
             String index = ctxt.getTemporaryVariableName();
             ctxt.generateJavaSource("    int " + index + ";");
             ctxt.generateJavaSource("    while(("+index+" = "+brName+".read()) != -1) "+sbName+".append((char)"+index+");");
             ctxt.generateJavaSource("    " + tempStringName + " = " +sbName + ".toString();");
-            
+
             ctxt.generateJavaSource("}else{");
-            
+
             //if the url is relative, http request is needed.
             ctxt.generateJavaSource("    if (!(pageContext.getRequest() instanceof HttpServletRequest  " +
             "&& pageContext.getResponse() instanceof HttpServletResponse)){");
             ctxt.generateJavaSource("        throw new JspTagException(\"Relative &lt;import&gt; from non-HTTP request not allowed\");");
             ctxt.generateJavaSource("    }");
-            
+
             //get the servlet context of the context defined in the context attribute
             ctxt.generateJavaSource("    ServletContext " + servletContextName + " = null;");
             if(hasContext){
@@ -326,7 +326,7 @@ public class Import implements TagPlugin {
             }else{
                 ctxt.generateJavaSource("    " + servletContextName + " = pageContext.getServletContext();");
             }
-            
+
             //
             ctxt.generateJavaSource("    if(" + servletContextName + " == null){");
             if(hasContext){
@@ -335,11 +335,11 @@ public class Import implements TagPlugin {
                 ctxt.generateJavaSource("        throw new JspTagException(\"Unable to get RequestDispatcher for URL: \\\" \" +" + urlName + "+ \" \\\". Verify values and/or enable cross context access.\");");
             }
             ctxt.generateJavaSource("    }");
-            
+
             //get the request dispatcher
             ctxt.generateJavaSource("    RequestDispatcher " + requestDispatcherName + " = " + servletContextName + ".getRequestDispatcher(org.apache.jasper.tagplugins.jstl.Util.stripSession("+urlName+"));");
             ctxt.generateJavaSource("    if(" + requestDispatcherName + " == null) throw new JspTagException(org.apache.jasper.tagplugins.jstl.Util.stripSession("+urlName+"));");
-            
+
             //initialize a ImportResponseWrapper to include the resource
             ctxt.generateJavaSource("    org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper " + irwName + " = new org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper((HttpServletResponse) pageContext.getResponse());");
             ctxt.generateJavaSource("    if(" + charSetName + " == null){");
@@ -359,16 +359,16 @@ public class Import implements TagPlugin {
             ctxt.generateJavaSource("        else");
             ctxt.generateJavaSource("            throw new JspException(rc);");
             ctxt.generateJavaSource("    }");
-            
+
             //validate the response status
             ctxt.generateJavaSource("    if(" + irwName + ".getStatus() < 200 || " + irwName + ".getStatus() > 299){");
             ctxt.generateJavaSource("        throw new JspTagException(" + irwName + ".getStatus()+\" \" + org.apache.jasper.tagplugins.jstl.Util.stripSession(" + urlName + "));");
             ctxt.generateJavaSource("    }");
-            
+
             ctxt.generateJavaSource("    " + tempStringName + " = " + irwName + ".getString();");
-            
+
             ctxt.generateJavaSource("}");
-            
+
             if(hasVar){
                 String strVar = ctxt.getConstantAttribute("var");
                 ctxt.generateJavaSource("pageContext.setAttribute(\""+strVar+"\"," + tempStringName + "," + iScope + ");");

==================================================
Out.java
index 11afe2cbe9..4608c33ac8 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Otherwise.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Otherwise.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,10 +22,10 @@ import org.apache.jasper.compiler.tagplugin.TagPlugin;
 import org.apache.jasper.compiler.tagplugin.TagPluginContext;
 
 public final class Otherwise implements TagPlugin {
-    
+
     @Override
     public void doTag(TagPluginContext ctxt) {
-        
+
         // See When.java for the reason whey "}" is need at the beginng and
         // not at the end.
         ctxt.generateJavaSource("} else {");

==================================================
Param.java
index 58d3a9e404..92a9eea089 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Out.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Out.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -23,22 +23,22 @@ import org.apache.jasper.compiler.tagplugin.TagPluginContext;
 
 
 public final class Out implements TagPlugin {
-    
+
     @Override
     public void doTag(TagPluginContext ctxt) {
-        
-        //these two data member are to indicate 
+
+        //these two data member are to indicate
         //whether the corresponding attribute is specified
         boolean hasDefault=false, hasEscapeXml=false;
         hasDefault = ctxt.isAttributeSpecified("default");
         hasEscapeXml = ctxt.isAttributeSpecified("escapeXml");
-        
-        //strValName, strEscapeXmlName & strDefName are two variables' name 
+
+        //strValName, strEscapeXmlName & strDefName are two variables' name
         //standing for value, escapeXml and default attribute
         String strValName = ctxt.getTemporaryVariableName();
         String strDefName = ctxt.getTemporaryVariableName();
         String strEscapeXmlName = ctxt.getTemporaryVariableName();
-        
+
         //according to the tag file, the value attribute is mandatory.
         ctxt.generateJavaSource("String " + strValName + " = null;");
         ctxt.generateJavaSource("if(");
@@ -48,7 +48,7 @@ public final class Out implements TagPlugin {
         ctxt.generateAttribute("value");
         ctxt.generateJavaSource(").toString();");
         ctxt.generateJavaSource("}");
-        
+
         //initiate the strDefName with null.
         //if the default has been specified, then assign the value to it;
         ctxt.generateJavaSource("String " + strDefName + " = null;\n");
@@ -61,7 +61,7 @@ public final class Out implements TagPlugin {
             ctxt.generateJavaSource(").toString();");
             ctxt.generateJavaSource("}");
         }
-        
+
         //initiate the strEscapeXmlName with true;
         //if the escapeXml is specified, assign the value to it;
         ctxt.generateJavaSource("boolean " + strEscapeXmlName + " = true;");
@@ -70,8 +70,8 @@ public final class Out implements TagPlugin {
             ctxt.generateAttribute("default");
             ctxt.generateJavaSource(").toString());");
         }
-        
-        //main part. 
+
+        //main part.
         ctxt.generateJavaSource("if(null != " + strValName +"){");
         ctxt.generateJavaSource("    if(" + strEscapeXmlName + "){");
         ctxt.generateJavaSource("        " + strValName + " = org.apache.jasper.tagplugins.jstl.Util.escapeXml(" + strValName + ");");
@@ -86,6 +86,6 @@ public final class Out implements TagPlugin {
         ctxt.generateJavaSource("    }else{");
         ctxt.generateBody();
         ctxt.generateJavaSource("    }");
-        ctxt.generateJavaSource("}");   
+        ctxt.generateJavaSource("}");
     }
 }

==================================================
Redirect.java
index 43a7e12cc0..e94e023ac0 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Param.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Param.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,19 +22,19 @@ import org.apache.jasper.compiler.tagplugin.TagPlugin;
 import org.apache.jasper.compiler.tagplugin.TagPluginContext;
 
 public class Param implements TagPlugin {
-    
+
     @Override
     public void doTag(TagPluginContext ctxt) {
-        
+
         //don't support the body content
-        
+
         //define names of all the temp variables
         String nameName = ctxt.getTemporaryVariableName();
         String valueName = ctxt.getTemporaryVariableName();
         String urlName = ctxt.getTemporaryVariableName();
         String encName = ctxt.getTemporaryVariableName();
         String index = ctxt.getTemporaryVariableName();
-        
+
         //if the param tag has no parents, throw a exception
         TagPluginContext parent = ctxt.getParentContext();
         if(parent == null){
@@ -42,16 +42,16 @@ public class Param implements TagPlugin {
             "(\"&lt;param&gt; outside &lt;import&gt; or &lt;urlEncode&gt;\");");
             return;
         }
-        
+
         //get the url string before adding this param
         ctxt.generateJavaSource("String " + urlName + " = " +
         "(String)pageContext.getAttribute(\"url_without_param\");");
-        
+
         //get the value of "name"
         ctxt.generateJavaSource("String " + nameName + " = ");
         ctxt.generateAttribute("name");
         ctxt.generateJavaSource(";");
-        
+
         //if the "name" is null then do nothing.
         //else add such string "name=value" to the url.
         //and the url should be encoded

==================================================
Remove.java
index 0390dc1677..d37050300f 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Redirect.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Redirect.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,20 +22,20 @@ import org.apache.jasper.compiler.tagplugin.TagPlugin;
 import org.apache.jasper.compiler.tagplugin.TagPluginContext;
 
 public class Redirect implements TagPlugin {
-    
+
     @Override
     public void doTag(TagPluginContext ctxt) {
-        
+
         //flag for the existence of the "context"
         boolean hasContext = ctxt.isAttributeSpecified("context");
-        
+
         //names of the temp variables
         String urlName = ctxt.getTemporaryVariableName();
         String contextName = ctxt.getTemporaryVariableName();
         String baseUrlName = ctxt.getTemporaryVariableName();
         String resultName = ctxt.getTemporaryVariableName();
         String responseName = ctxt.getTemporaryVariableName();
-        
+
         //get context
         ctxt.generateJavaSource("String " + contextName + " = null;");
         if(hasContext){
@@ -43,36 +43,36 @@ public class Redirect implements TagPlugin {
             ctxt.generateAttribute("context");
             ctxt.generateJavaSource(";");
         }
-        
+
         //get the url
         ctxt.generateJavaSource("String " + urlName + " = ");
         ctxt.generateAttribute("url");
         ctxt.generateJavaSource(";");
-        
+
         //get the raw url according to "url" and "context"
         ctxt.generateJavaSource("String " + baseUrlName + " = " +
                 "org.apache.jasper.tagplugins.jstl.Util.resolveUrl(" + urlName + ", " + contextName + ", pageContext);");
         ctxt.generateJavaSource("pageContext.setAttribute" +
                 "(\"url_without_param\", " + baseUrlName + ");");
-        
+
         //add params
         ctxt.generateBody();
-        
+
         ctxt.generateJavaSource("String " + resultName + " = " +
         "(String)pageContext.getAttribute(\"url_without_param\");");
         ctxt.generateJavaSource("pageContext.removeAttribute" +
         "(\"url_without_param\");");
-        
+
         //get the response object
         ctxt.generateJavaSource("HttpServletResponse " + responseName + " = " +
         "((HttpServletResponse) pageContext.getResponse());");
-        
+
         //if the url is relative, encode it
         ctxt.generateJavaSource("if(!org.apache.jasper.tagplugins.jstl.Util.isAbsoluteUrl(" + resultName + ")){");
         ctxt.generateJavaSource("    " + resultName + " = "
                 + responseName + ".encodeRedirectURL(" + resultName + ");");
         ctxt.generateJavaSource("}");
-        
+
         //do redirect
         ctxt.generateJavaSource("try{");
         ctxt.generateJavaSource("    " + responseName + ".sendRedirect(" + resultName + ");");
@@ -80,5 +80,5 @@ public class Redirect implements TagPlugin {
         ctxt.generateJavaSource("    throw new JspTagException(ex.toString(), ex);");
         ctxt.generateJavaSource("}");
     }
-    
+
 }

==================================================
Set.java
index f7e8404834..330e8a7c26 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Remove.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Remove.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -23,16 +23,16 @@ import org.apache.jasper.compiler.tagplugin.TagPluginContext;
 import org.apache.jasper.tagplugins.jstl.Util;
 
 public class Remove implements TagPlugin {
-    
+
     @Override
     public void doTag(TagPluginContext ctxt) {
-        
+
         //scope flag
         boolean hasScope = ctxt.isAttributeSpecified("scope");
-        
+
         //the value of the "var"
         String strVar = ctxt.getConstantAttribute("var");
-        
+
         //remove attribute from certain scope.
         //default scope is "page".
         if(hasScope){
@@ -42,5 +42,5 @@ public class Remove implements TagPlugin {
             ctxt.generateJavaSource("pageContext.removeAttribute(\"" + strVar + "\");");
         }
     }
-    
+
 }

==================================================
Url.java
index 04341d4ad2..ea4e07449d 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Set.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Set.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -23,30 +23,30 @@ import org.apache.jasper.compiler.tagplugin.TagPluginContext;
 import org.apache.jasper.tagplugins.jstl.Util;
 
 public class Set implements TagPlugin {
-    
+
     @Override
     public void doTag(TagPluginContext ctxt) {
-        
+
         //the flags to indicate whether the attributes have been specified
-        boolean hasValue = false, hasVar = false, hasScope = false, 
+        boolean hasValue = false, hasVar = false, hasScope = false,
         hasTarget = false;
-        
+
         //the scope name
         String strScope;
         //the id of the scope
         int iScope;
-        
+
         //initialize the flags
         hasValue = ctxt.isAttributeSpecified("value");
         hasVar = ctxt.isAttributeSpecified("var");
         hasScope = ctxt.isAttributeSpecified("scope");
         hasTarget = ctxt.isAttributeSpecified("target");
-        
+
         //the temp variables name
         String resultName = ctxt.getTemporaryVariableName();
         String targetName = ctxt.getTemporaryVariableName();
         String propertyName = ctxt.getTemporaryVariableName();
-        
+
         //initialize the "result" which will be assigned to the var or target.property
         ctxt.generateJavaSource("Object " + resultName + " = null;");
         if(hasValue){
@@ -57,17 +57,17 @@ public class Set implements TagPlugin {
             ctxt.dontUseTagPlugin();
             return;
         }
-        
+
         //initialize the strScope
         if(hasScope){
             strScope = ctxt.getConstantAttribute("scope");
         }else{
             strScope = "page";
         }
-        
+
         //get the iScope according to the strScope
         iScope = Util.getScope(strScope);
-        
+
         //if the attribute var has been specified then assign the result to the var;
         if(hasVar){
             String strVar = ctxt.getConstantAttribute("var");
@@ -80,16 +80,16 @@ public class Set implements TagPlugin {
                 ctxt.generateJavaSource("    pageContext.removeAttribute(\"" + strVar + "\");");
             }
             ctxt.generateJavaSource("}");
-            
+
             //else assign the result to the target.property
         }else if(hasTarget){
-            
+
             //generate the temp variable name
             String pdName = ctxt.getTemporaryVariableName();
             String successFlagName = ctxt.getTemporaryVariableName();
             String index = ctxt.getTemporaryVariableName();
             String methodName = ctxt.getTemporaryVariableName();
-            
+
             //initialize the property
             ctxt.generateJavaSource("String " + propertyName + " = null;");
             ctxt.generateJavaSource("if(");
@@ -99,15 +99,15 @@ public class Set implements TagPlugin {
             ctxt.generateAttribute("property");
             ctxt.generateJavaSource(").toString();");
             ctxt.generateJavaSource("}");
-            
+
             //initialize the target
             ctxt.generateJavaSource("Object " + targetName + " = ");
             ctxt.generateAttribute("target");
             ctxt.generateJavaSource(";");
-            
+
             //the target is ok
             ctxt.generateJavaSource("if(" + targetName + " != null){");
-            
+
             //if the target is a map, then put the result into the map with the key property
             ctxt.generateJavaSource("    if(" + targetName + " instanceof java.util.Map){");
             ctxt.generateJavaSource("        if(null != " + resultName + "){");
@@ -115,27 +115,27 @@ public class Set implements TagPlugin {
             ctxt.generateJavaSource("        }else{");
             ctxt.generateJavaSource("            ((java.util.Map) " + targetName + ").remove(" + propertyName + ");");
             ctxt.generateJavaSource("        }");
-            
+
             //else assign the result to the target.property
             ctxt.generateJavaSource("    }else{");
             ctxt.generateJavaSource("        try{");
-            
+
             //get all the property of the target
             ctxt.generateJavaSource("            java.beans.PropertyDescriptor " + pdName + "[] = java.beans.Introspector.getBeanInfo(" + targetName + ".getClass()).getPropertyDescriptors();");
-            
+
             //the success flag is to imply whether the assign is successful
             ctxt.generateJavaSource("            boolean " + successFlagName + " = false;");
-            
+
             //find the right property
             ctxt.generateJavaSource("            for(int " + index + "=0;" + index + "<" + pdName + ".length;" + index + "++){");
             ctxt.generateJavaSource("                if(" + pdName + "[" + index + "].getName().equals(" + propertyName + ")){");
-            
+
             //get the "set" method;
             ctxt.generateJavaSource("                    java.lang.reflect.Method " + methodName + " = " + pdName + "[" + index + "].getWriteMethod();");
             ctxt.generateJavaSource("                    if(null == " + methodName + "){");
             ctxt.generateJavaSource("                        throw new JspException(\"No setter method in &lt;set&gt; for property \"+" + propertyName + ");");
             ctxt.generateJavaSource("                    }");
-            
+
             //invoke the method through the reflection
             ctxt.generateJavaSource("                    if(" + resultName + " != null){");
             ctxt.generateJavaSource("                        " + methodName + ".invoke(" + targetName + ", new Object[]{(" + methodName + ".getParameterTypes()[0]).cast(" + resultName + ")});");
@@ -149,7 +149,7 @@ public class Set implements TagPlugin {
             ctxt.generateJavaSource("                throw new JspException(\"Invalid property in &lt;set&gt;:\"+" + propertyName + ");");
             ctxt.generateJavaSource("            }");
             ctxt.generateJavaSource("        }");
-            
+
             //catch the el exception and throw it as a JspException
             ctxt.generateJavaSource("        catch (IllegalAccessException ex) {");
             ctxt.generateJavaSource("            throw new JspException(ex);");
@@ -164,5 +164,5 @@ public class Set implements TagPlugin {
             ctxt.generateJavaSource("}");
         }
     }
-    
+
 }

==================================================
When.java
index f7b79faf05..f275aac396 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/Url.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/Url.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -23,37 +23,37 @@ import org.apache.jasper.compiler.tagplugin.TagPluginContext;
 import org.apache.jasper.tagplugins.jstl.Util;
 
 public class Url implements TagPlugin {
-    
+
     @Override
     public void doTag(TagPluginContext ctxt) {
-        
+
         //flags
         boolean hasVar, hasContext, hasScope;
-        
+
         //init flags
         hasVar = ctxt.isAttributeSpecified("var");
         hasContext = ctxt.isAttributeSpecified("context");
         hasScope = ctxt.isAttributeSpecified("scope");
-        
+
         //define name of the temp variables
         String valueName = ctxt.getTemporaryVariableName();
         String contextName = ctxt.getTemporaryVariableName();
         String baseUrlName = ctxt.getTemporaryVariableName();
         String resultName = ctxt.getTemporaryVariableName();
         String responseName = ctxt.getTemporaryVariableName();
-        
+
         //get the scope
         String strScope = "page";
         if(hasScope){
             strScope = ctxt.getConstantAttribute("scope");
         }
         int iScope = Util.getScope(strScope);
-        
+
         //get the value
         ctxt.generateJavaSource("String " + valueName + " = ");
         ctxt.generateAttribute("value");
         ctxt.generateJavaSource(";");
-        
+
         //get the context
         ctxt.generateJavaSource("String " + contextName + " = null;");
         if(hasContext){
@@ -61,20 +61,20 @@ public class Url implements TagPlugin {
             ctxt.generateAttribute("context");
             ctxt.generateJavaSource(";");
         }
-        
+
         //get the raw url
         ctxt.generateJavaSource("String " + baseUrlName + " = " +
                 "org.apache.jasper.tagplugins.jstl.Util.resolveUrl(" + valueName + ", " + contextName + ", pageContext);");
         ctxt.generateJavaSource("pageContext.setAttribute" +
                 "(\"url_without_param\", " + baseUrlName + ");");
-        
+
         //add params
         ctxt.generateBody();
-        
+
         ctxt.generateJavaSource("String " + resultName + " = " +
         "(String)pageContext.getAttribute(\"url_without_param\");");
         ctxt.generateJavaSource("pageContext.removeAttribute(\"url_without_param\");");
-        
+
         //if the url is relative, encode it
         ctxt.generateJavaSource("if(!org.apache.jasper.tagplugins.jstl.Util.isAbsoluteUrl(" + resultName + ")){");
         ctxt.generateJavaSource("    HttpServletResponse " + responseName + " = " +
@@ -82,13 +82,13 @@ public class Url implements TagPlugin {
         ctxt.generateJavaSource("    " + resultName + " = "
                 + responseName + ".encodeURL(" + resultName + ");");
         ctxt.generateJavaSource("}");
-        
+
         //if "var" is specified, the url string store in the attribute var defines
         if(hasVar){
             String strVar = ctxt.getConstantAttribute("var");
             ctxt.generateJavaSource("pageContext.setAttribute" +
                     "(\"" + strVar + "\", " + resultName + ", " + iScope + ");");
-            
+
             //if var is not specified, just print out the url string
         }else{
             ctxt.generateJavaSource("try{");
@@ -98,5 +98,5 @@ public class Url implements TagPlugin {
             ctxt.generateJavaSource("}");
         }
     }
-    
+
 }

==================================================
Enumerator.java
index e44e1ae066..2661f6e4ab 100644
--- a/java/org/apache/jasper/tagplugins/jstl/core/When.java
+++ b/java/org/apache/jasper/tagplugins/jstl/core/When.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,7 +22,7 @@ import org.apache.jasper.compiler.tagplugin.TagPlugin;
 import org.apache.jasper.compiler.tagplugin.TagPluginContext;
 
 public final class When implements TagPlugin {
-    
+
     @Override
     public void doTag(TagPluginContext ctxt) {
         // Get the parent context to determine if this is the first <c:when>
@@ -31,7 +31,7 @@ public final class When implements TagPlugin {
             ctxt.dontUseTagPlugin();
             return;
         }
-        
+
         if ("true".equals(parentContext.getPluginAttribute("hasBeenHere"))) {
             ctxt.generateJavaSource("} else if(");
             // See comment below for the reason we generate the extra "}" here.
@@ -43,7 +43,7 @@ public final class When implements TagPlugin {
         ctxt.generateAttribute("test");
         ctxt.generateJavaSource("){");
         ctxt.generateBody();
-        
+
         // We don't generate the closing "}" for the "if" here because there
         // may be whitespaces in between <c:when>'s.  Instead we delay
         // generating it until the next <c:when> or <c:otherwise> or

==================================================
ExceptionUtils.java
index 3b0dc4e4ba..ba773d7f38 100644
--- a/java/org/apache/jasper/util/Enumerator.java
+++ b/java/org/apache/jasper/util/Enumerator.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -73,7 +73,7 @@ public final class Enumerator<T> implements Enumeration<T> {
             while (iterator.hasNext()) {
                 list.add(iterator.next());
             }
-            this.iterator = list.iterator();   
+            this.iterator = list.iterator();
         }
 
     }

==================================================
UniqueAttributesImpl.java
index be5eeb80ac..d7c6b37231 100644
--- a/java/org/apache/jasper/util/ExceptionUtils.java
+++ b/java/org/apache/jasper/util/ExceptionUtils.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -20,9 +20,9 @@ package org.apache.jasper.util;
  * Utilities for handling Throwables and Exceptions.
  */
 public class ExceptionUtils {
-    
+
     /**
-     * Checks whether the supplied Throwable is one that needs to be 
+     * Checks whether the supplied Throwable is one that needs to be
      * rethrown and swallows all others.
      * @param t the Throwable to check
      */

==================================================
ASCIIReader.java
index 67da6d1a5d..0f6510bd02 100644
--- a/java/org/apache/jasper/util/UniqueAttributesImpl.java
+++ b/java/org/apache/jasper/util/UniqueAttributesImpl.java
@@ -31,7 +31,7 @@ public class UniqueAttributesImpl extends AttributesImpl {
 
     private static final String IMPORT = "import";
     private static final String PAGE_ENCODING = "pageEncoding";
-    
+
     private final boolean pageDirective;
     private final Set<String> qNames = new HashSet<String>();
 

==================================================
EncodingMap.java
index b8c8c5681b..cbd00d5732 100644
--- a/java/org/apache/jasper/xmlparser/ASCIIReader.java
+++ b/java/org/apache/jasper/xmlparser/ASCIIReader.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -47,8 +47,8 @@ public class ASCIIReader extends Reader {
     // Constructors
     //
 
-    /** 
-     * Constructs an ASCII reader from the specified input stream 
+    /**
+     * Constructs an ASCII reader from the specified input stream
      * and buffer size.
      *
      * @param inputStream The input stream.

==================================================
ParserUtils.java
index cb17b541e4..38f904abb1 100644
--- a/java/org/apache/jasper/xmlparser/EncodingMap.java
+++ b/java/org/apache/jasper/xmlparser/EncodingMap.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -28,7 +28,7 @@ package org.apache.jasper.xmlparser;
 import java.util.Hashtable;
 
 /**
- * EncodingMap is a convenience class which handles conversions between 
+ * EncodingMap is a convenience class which handles conversions between
  * IANA encoding names and Java encoding names, and vice versa. The
  * encoding names used in XML instance documents <strong>must</strong>
  * be the IANA encoding names specified or one of the aliases for those names
@@ -470,7 +470,7 @@ import java.util.Hashtable;
  *      </TD>
  *  </TR>
  * </TABLE>
- * 
+ *
  * @author TAMURA Kent, IBM
  * @author Andy Clark, IBM
  *
@@ -556,7 +556,7 @@ public class EncodingMap {
         fIANA2JavaMap.put("CP500",    "CP500");
         fIANA2JavaMap.put("CSIBM500",    "CP500");
         fIANA2JavaMap.put("EBCDIC-CP-CH",    "CP500");
-        fIANA2JavaMap.put("EBCDIC-CP-BE",    "CP500"); 
+        fIANA2JavaMap.put("EBCDIC-CP-BE",    "CP500");
         fIANA2JavaMap.put("IBM775",    "CP775");
         fIANA2JavaMap.put("CP775",    "CP775");
         fIANA2JavaMap.put("CSPC775BALTIC",    "CP775");
@@ -717,7 +717,7 @@ public class EncodingMap {
         fIANA2JavaMap.put("WINDOWS-1258",   "Cp1258");
         fIANA2JavaMap.put("TIS-620",   "TIS620");
 
-        fIANA2JavaMap.put("ISO-8859-1",      "ISO8859_1"); 
+        fIANA2JavaMap.put("ISO-8859-1",      "ISO8859_1");
         fIANA2JavaMap.put("ISO-IR-100",      "ISO8859_1");
         fIANA2JavaMap.put("ISO_8859-1",      "ISO8859_1");
         fIANA2JavaMap.put("LATIN1",      "ISO8859_1");
@@ -726,34 +726,34 @@ public class EncodingMap {
         fIANA2JavaMap.put("IBM819",      "ISO8859_1");
         fIANA2JavaMap.put("CP819",      "ISO8859_1");
 
-        fIANA2JavaMap.put("ISO-8859-2",      "ISO8859_2"); 
+        fIANA2JavaMap.put("ISO-8859-2",      "ISO8859_2");
         fIANA2JavaMap.put("ISO-IR-101",      "ISO8859_2");
         fIANA2JavaMap.put("ISO_8859-2",      "ISO8859_2");
         fIANA2JavaMap.put("LATIN2",      "ISO8859_2");
         fIANA2JavaMap.put("CSISOLATIN2",      "ISO8859_2");
         fIANA2JavaMap.put("L2",      "ISO8859_2");
 
-        fIANA2JavaMap.put("ISO-8859-3",      "ISO8859_3"); 
+        fIANA2JavaMap.put("ISO-8859-3",      "ISO8859_3");
         fIANA2JavaMap.put("ISO-IR-109",      "ISO8859_3");
         fIANA2JavaMap.put("ISO_8859-3",      "ISO8859_3");
         fIANA2JavaMap.put("LATIN3",      "ISO8859_3");
         fIANA2JavaMap.put("CSISOLATIN3",      "ISO8859_3");
         fIANA2JavaMap.put("L3",      "ISO8859_3");
 
-        fIANA2JavaMap.put("ISO-8859-4",      "ISO8859_4"); 
+        fIANA2JavaMap.put("ISO-8859-4",      "ISO8859_4");
         fIANA2JavaMap.put("ISO-IR-110",      "ISO8859_4");
         fIANA2JavaMap.put("ISO_8859-4",      "ISO8859_4");
         fIANA2JavaMap.put("LATIN4",      "ISO8859_4");
         fIANA2JavaMap.put("CSISOLATIN4",      "ISO8859_4");
         fIANA2JavaMap.put("L4",      "ISO8859_4");
 
-        fIANA2JavaMap.put("ISO-8859-5",      "ISO8859_5"); 
+        fIANA2JavaMap.put("ISO-8859-5",      "ISO8859_5");
         fIANA2JavaMap.put("ISO-IR-144",      "ISO8859_5");
         fIANA2JavaMap.put("ISO_8859-5",      "ISO8859_5");
         fIANA2JavaMap.put("CYRILLIC",      "ISO8859_5");
         fIANA2JavaMap.put("CSISOLATINCYRILLIC",      "ISO8859_5");
 
-        fIANA2JavaMap.put("ISO-8859-6",      "ISO8859_6"); 
+        fIANA2JavaMap.put("ISO-8859-6",      "ISO8859_6");
         fIANA2JavaMap.put("ISO-IR-127",      "ISO8859_6");
         fIANA2JavaMap.put("ISO_8859-6",      "ISO8859_6");
         fIANA2JavaMap.put("ECMA-114",      "ISO8859_6");
@@ -761,7 +761,7 @@ public class EncodingMap {
         fIANA2JavaMap.put("ARABIC",      "ISO8859_6");
         fIANA2JavaMap.put("CSISOLATINARABIC",      "ISO8859_6");
 
-        fIANA2JavaMap.put("ISO-8859-7",      "ISO8859_7"); 
+        fIANA2JavaMap.put("ISO-8859-7",      "ISO8859_7");
         fIANA2JavaMap.put("ISO-IR-126",      "ISO8859_7");
         fIANA2JavaMap.put("ISO_8859-7",      "ISO8859_7");
         fIANA2JavaMap.put("ELOT_928",      "ISO8859_7");
@@ -770,29 +770,29 @@ public class EncodingMap {
         fIANA2JavaMap.put("CSISOLATINGREEK",      "ISO8859_7");
         fIANA2JavaMap.put("GREEK8",      "ISO8859_7");
 
-        fIANA2JavaMap.put("ISO-8859-8",      "ISO8859_8"); 
-        fIANA2JavaMap.put("ISO-8859-8-I",      "ISO8859_8"); // added since this encoding only differs w.r.t. presentation 
+        fIANA2JavaMap.put("ISO-8859-8",      "ISO8859_8");
+        fIANA2JavaMap.put("ISO-8859-8-I",      "ISO8859_8"); // added since this encoding only differs w.r.t. presentation
         fIANA2JavaMap.put("ISO-IR-138",      "ISO8859_8");
         fIANA2JavaMap.put("ISO_8859-8",      "ISO8859_8");
         fIANA2JavaMap.put("HEBREW",      "ISO8859_8");
         fIANA2JavaMap.put("CSISOLATINHEBREW",      "ISO8859_8");
 
-        fIANA2JavaMap.put("ISO-8859-9",      "ISO8859_9"); 
+        fIANA2JavaMap.put("ISO-8859-9",      "ISO8859_9");
         fIANA2JavaMap.put("ISO-IR-148",      "ISO8859_9");
         fIANA2JavaMap.put("ISO_8859-9",      "ISO8859_9");
         fIANA2JavaMap.put("LATIN5",      "ISO8859_9");
         fIANA2JavaMap.put("CSISOLATIN5",      "ISO8859_9");
         fIANA2JavaMap.put("L5",      "ISO8859_9");
 
-        fIANA2JavaMap.put("ISO-8859-13",      "ISO8859_13"); 
-        
-        fIANA2JavaMap.put("ISO-8859-15",      "ISO8859_15_FDIS"); 
+        fIANA2JavaMap.put("ISO-8859-13",      "ISO8859_13");
+
+        fIANA2JavaMap.put("ISO-8859-15",      "ISO8859_15_FDIS");
         fIANA2JavaMap.put("ISO_8859-15",      "ISO8859_15_FDIS");
-        fIANA2JavaMap.put("LATIN-9",          "ISO8859_15_FDIS"); 
+        fIANA2JavaMap.put("LATIN-9",          "ISO8859_15_FDIS");
 
         fIANA2JavaMap.put("KOI8-R",          "KOI8_R");
         fIANA2JavaMap.put("CSKOI8R",          "KOI8_R");
-        fIANA2JavaMap.put("US-ASCII",        "ASCII"); 
+        fIANA2JavaMap.put("US-ASCII",        "ASCII");
         fIANA2JavaMap.put("ISO-IR-6",        "ASCII");
         fIANA2JavaMap.put("ANSI_X3.4-1968",        "ASCII");
         fIANA2JavaMap.put("ANSI_X3.4-1986",        "ASCII");
@@ -808,8 +808,8 @@ public class EncodingMap {
         fIANA2JavaMap.put("UTF-16BE",           "UnicodeBig");
         fIANA2JavaMap.put("UTF-16LE",           "UnicodeLittle");
 
-        // support for 1047, as proposed to be added to the 
-        // IANA registry in 
+        // support for 1047, as proposed to be added to the
+        // IANA registry in
         // http://lists.w3.org/Archives/Public/ietf-charset/2002JulSep/0049.html
         fIANA2JavaMap.put("IBM-1047",    "Cp1047");
         fIANA2JavaMap.put("IBM1047",    "Cp1047");
@@ -866,7 +866,7 @@ public class EncodingMap {
         // REVISIT:
         //   j:CNS11643 -> EUC-TW?
         //   ISO-2022-CN? ISO-2022-CN-EXT?
-                                                
+
         // add Java to IANA encoding mappings
         //fJava2IANAMap.put("8859_1",    "US-ASCII"); // ?
         fJava2IANAMap.put("ISO8859_1",    "ISO-8859-1");
@@ -963,18 +963,18 @@ public class EncodingMap {
 
     /**
      * Adds an IANA to Java encoding name mapping.
-     * 
+     *
      * @param ianaEncoding The IANA encoding name.
      * @param javaEncoding The Java encoding name.
      */
-    public static void putIANA2JavaMapping(String ianaEncoding, 
+    public static void putIANA2JavaMapping(String ianaEncoding,
                                            String javaEncoding) {
         fIANA2JavaMap.put(ianaEncoding, javaEncoding);
     }
 
     /**
      * Returns the Java encoding name for the specified IANA encoding name.
-     * 
+     *
      * @param ianaEncoding The IANA encoding name.
      */
     public static String getIANA2JavaMapping(String ianaEncoding) {
@@ -983,7 +983,7 @@ public class EncodingMap {
 
     /**
      * Removes an IANA to Java encoding name mapping.
-     * 
+     *
      * @param ianaEncoding The IANA encoding name.
      */
     public static String removeIANA2JavaMapping(String ianaEncoding) {
@@ -992,18 +992,18 @@ public class EncodingMap {
 
     /**
      * Adds a Java to IANA encoding name mapping.
-     * 
+     *
      * @param javaEncoding The Java encoding name.
      * @param ianaEncoding The IANA encoding name.
      */
-    public static void putJava2IANAMapping(String javaEncoding, 
+    public static void putJava2IANAMapping(String javaEncoding,
                                            String ianaEncoding) {
         fJava2IANAMap.put(javaEncoding, ianaEncoding);
     }
 
     /**
      * Returns the IANA encoding name for the specified Java encoding name.
-     * 
+     *
      * @param javaEncoding The Java encoding name.
      */
     public static String getJava2IANAMapping(String javaEncoding) {
@@ -1012,7 +1012,7 @@ public class EncodingMap {
 
     /**
      * Removes a Java to IANA encoding name mapping.
-     * 
+     *
      * @param javaEncoding The Java encoding name.
      */
     public static String removeJava2IANAMapping(String javaEncoding) {

==================================================
SymbolTable.java
index 1c6dec7317..19550ece2c 100644
--- a/java/org/apache/jasper/xmlparser/ParserUtils.java
+++ b/java/org/apache/jasper/xmlparser/ParserUtils.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -180,7 +180,7 @@ public class ParserUtils {
                 }
             }
         }
-        
+
         // Return the completed TreeNode graph
         return (treeNode);
     }

==================================================
TreeNode.java
index ad77e29857..9c39b96a9b 100644
--- a/java/org/apache/jasper/xmlparser/SymbolTable.java
+++ b/java/org/apache/jasper/xmlparser/SymbolTable.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

==================================================
UCSReader.java
index dc23f67de3..35f6145e5c 100644
--- a/java/org/apache/jasper/xmlparser/TreeNode.java
+++ b/java/org/apache/jasper/xmlparser/TreeNode.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -151,7 +151,7 @@ public class TreeNode {
     public Iterator<String> findAttributes() {
 
         if (attributes == null) {
-            List<String> empty = Collections.emptyList(); 
+            List<String> empty = Collections.emptyList();
             return empty.iterator();
         } else
             return attributes.keySet().iterator();
@@ -187,7 +187,7 @@ public class TreeNode {
     public Iterator<TreeNode> findChildren() {
 
         if (children == null) {
-            List<TreeNode> empty = Collections.emptyList(); 
+            List<TreeNode> empty = Collections.emptyList();
             return empty.iterator();
         } else
             return children.iterator();
@@ -205,9 +205,9 @@ public class TreeNode {
     public Iterator<TreeNode> findChildren(String name) {
 
         if (children == null) {
-            List<TreeNode> empty = Collections.emptyList(); 
+            List<TreeNode> empty = Collections.emptyList();
             return empty.iterator();
-        } 
+        }
 
         ArrayList<TreeNode> results = new ArrayList<TreeNode>();
         Iterator<TreeNode> items = children.iterator();

==================================================
UTF8Reader.java
index bba4d12b82..dd40efee02 100644
--- a/java/org/apache/jasper/xmlparser/UCSReader.java
+++ b/java/org/apache/jasper/xmlparser/UCSReader.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -21,7 +21,7 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.io.Reader;
 
-/** 
+/**
  * Reader for UCS-2 and UCS-4 encodings.
  * (i.e., encodings from ISO-10646-UCS-(2|4)).
  *
@@ -33,14 +33,14 @@ public class UCSReader extends Reader {
 
     private final org.apache.juli.logging.Log log=
         org.apache.juli.logging.LogFactory.getLog( UCSReader.class );
-    
+
     //
     // Constants
     //
 
     /** Default byte buffer size (8192, larger than that of ASCIIReader
      * since it's reasonable to surmise that the average UCS-4-encoded
-     * file should be 4 times as large as the average ASCII-encoded file). 
+     * file should be 4 times as large as the average ASCII-encoded file).
      */
     public static final int DEFAULT_BUFFER_SIZE = 8192;
 
@@ -66,8 +66,8 @@ public class UCSReader extends Reader {
     // Constructors
     //
 
-    /** 
-     * Constructs an ASCII reader from the specified input stream 
+    /**
+     * Constructs an ASCII reader from the specified input stream
      * using the default buffer size.  The Endian-ness and whether this is
      * UCS-2 or UCS-4 needs also to be known in advance.
      *
@@ -78,8 +78,8 @@ public class UCSReader extends Reader {
         this(inputStream, DEFAULT_BUFFER_SIZE, encoding);
     } // <init>(InputStream, short)
 
-    /** 
-     * Constructs an ASCII reader from the specified input stream 
+    /**
+     * Constructs an ASCII reader from the specified input stream
      * and buffer size.  The Endian-ness and whether this is
      * UCS-2 or UCS-4 needs also to be known in advance.
      *
@@ -111,7 +111,7 @@ public class UCSReader extends Reader {
      * @exception  IOException  If an I/O error occurs
      */
     @Override
-    public int read() throws IOException { 
+    public int read() throws IOException {
         int b0 = fInputStream.read() & 0xff;
         if (b0 == 0xff)
             return -1;
@@ -172,7 +172,7 @@ public class UCSReader extends Reader {
                         fBuffer[count+j] = 0;
                     break;
                 } else {
-                    fBuffer[count+i] = (byte)charRead; 
+                    fBuffer[count+i] = (byte)charRead;
                 }
             }
             count += numToRead;

==================================================
XMLChar.java
index 5dff6975fe..9c4b8846a2 100644
--- a/java/org/apache/jasper/xmlparser/UTF8Reader.java
+++ b/java/org/apache/jasper/xmlparser/UTF8Reader.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -34,7 +34,7 @@ public class UTF8Reader
 
     private final org.apache.juli.logging.Log log=
         org.apache.juli.logging.LogFactory.getLog( UTF8Reader.class );
-    
+
     // debugging
 
     /** Debug read. */
@@ -60,8 +60,8 @@ public class UTF8Reader
     // Constructors
     //
 
-    /** 
-     * Constructs a UTF-8 reader from the specified input stream, 
+    /**
+     * Constructs a UTF-8 reader from the specified input stream,
      * buffer size and MessageFormatter.
      *
      * @param inputStream The input stream.
@@ -100,7 +100,7 @@ public class UTF8Reader
             int index = 0;
 
             // get first byte
-            int b0 = index == fOffset 
+            int b0 = index == fOffset
                    ? fInputStream.read() : fBuffer[index++] & 0x00FF;
             if (b0 == -1) {
                 return -1;
@@ -115,7 +115,7 @@ public class UTF8Reader
             // UTF-8:   [110y yyyy] [10xx xxxx]
             // Unicode: [0000 0yyy] [yyxx xxxx]
             else if ((b0 & 0xE0) == 0xC0) {
-                int b1 = index == fOffset 
+                int b1 = index == fOffset
                        ? fInputStream.read() : fBuffer[index++] & 0x00FF;
                 if (b1 == -1) {
                     expectedByte(2, 2);
@@ -137,7 +137,7 @@ public class UTF8Reader
                 if ((b1 & 0xC0) != 0x80) {
                     invalidByte(2, 3);
                 }
-                int b2 = index == fOffset 
+                int b2 = index == fOffset
                        ? fInputStream.read() : fBuffer[index++] & 0x00FF;
                 if (b2 == -1) {
                     expectedByte(3, 3);
@@ -154,7 +154,7 @@ public class UTF8Reader
             //          [1101 11yy] [yyxx xxxx] (low surrogate)
             //          * uuuuu = wwww + 1
             else if ((b0 & 0xF8) == 0xF0) {
-                int b1 = index == fOffset 
+                int b1 = index == fOffset
                        ? fInputStream.read() : fBuffer[index++] & 0x00FF;
                 if (b1 == -1) {
                     expectedByte(2, 4);
@@ -162,7 +162,7 @@ public class UTF8Reader
                 if ((b1 & 0xC0) != 0x80) {
                     invalidByte(2, 3);
                 }
-                int b2 = index == fOffset 
+                int b2 = index == fOffset
                        ? fInputStream.read() : fBuffer[index++] & 0x00FF;
                 if (b2 == -1) {
                     expectedByte(3, 4);
@@ -170,7 +170,7 @@ public class UTF8Reader
                 if ((b2 & 0xC0) != 0x80) {
                     invalidByte(3, 3);
                 }
-                int b3 = index == fOffset 
+                int b3 = index == fOffset
                        ? fInputStream.read() : fBuffer[index++] & 0x00FF;
                 if (b3 == -1) {
                     expectedByte(4, 4);
@@ -183,8 +183,8 @@ public class UTF8Reader
                     invalidSurrogate(uuuuu);
                 }
                 int wwww = uuuuu - 1;
-                int hs = 0xD800 | 
-                         ((wwww << 6) & 0x03C0) | ((b1 << 2) & 0x003C) | 
+                int hs = 0xD800 |
+                         ((wwww << 6) & 0x03C0) | ((b1 << 2) & 0x003C) |
                          ((b2 >> 4) & 0x0003);
                 int ls = 0xDC00 | ((b2 << 6) & 0x03C0) | (b3 & 0x003F);
                 c = hs;
@@ -256,7 +256,7 @@ public class UTF8Reader
         // skip read; last character was in error
         // NOTE: Having an offset value other than zero means that there was
         //       an error in the last character read. In this case, we have
-        //       skipped the read so we don't consume any bytes past the 
+        //       skipped the read so we don't consume any bytes past the
         //       error. By signaling the error on the next block read we
         //       allow the method to return the most valid characters that
         //       it can on the previous block read. -Ac
@@ -281,8 +281,8 @@ public class UTF8Reader
             // Unicode: [0000 0yyy] [yyxx xxxx]
             if ((b0 & 0xE0) == 0xC0) {
                 int b1 = -1;
-                if (++in < total) { 
-                    b1 = fBuffer[in] & 0x00FF; 
+                if (++in < total) {
+                    b1 = fBuffer[in] & 0x00FF;
                 }
                 else {
                     b1 = fInputStream.read();
@@ -315,8 +315,8 @@ public class UTF8Reader
             // Unicode: [zzzz yyyy] [yyxx xxxx]
             if ((b0 & 0xF0) == 0xE0) {
                 int b1 = -1;
-                if (++in < total) { 
-                    b1 = fBuffer[in] & 0x00FF; 
+                if (++in < total) {
+                    b1 = fBuffer[in] & 0x00FF;
                 }
                 else {
                     b1 = fInputStream.read();
@@ -340,8 +340,8 @@ public class UTF8Reader
                     invalidByte(2, 3);
                 }
                 int b2 = -1;
-                if (++in < total) { 
-                    b2 = fBuffer[in] & 0x00FF; 
+                if (++in < total) {
+                    b2 = fBuffer[in] & 0x00FF;
                 }
                 else {
                     b2 = fInputStream.read();
@@ -379,8 +379,8 @@ public class UTF8Reader
             //          * uuuuu = wwww + 1
             if ((b0 & 0xF8) == 0xF0) {
                 int b1 = -1;
-                if (++in < total) { 
-                    b1 = fBuffer[in] & 0x00FF; 
+                if (++in < total) {
+                    b1 = fBuffer[in] & 0x00FF;
                 }
                 else {
                     b1 = fInputStream.read();
@@ -404,8 +404,8 @@ public class UTF8Reader
                     invalidByte(2, 4);
                 }
                 int b2 = -1;
-                if (++in < total) { 
-                    b2 = fBuffer[in] & 0x00FF; 
+                if (++in < total) {
+                    b2 = fBuffer[in] & 0x00FF;
                 }
                 else {
                     b2 = fInputStream.read();
@@ -431,8 +431,8 @@ public class UTF8Reader
                     invalidByte(3, 4);
                 }
                 int b3 = -1;
-                if (++in < total) { 
-                    b3 = fBuffer[in] & 0x00FF; 
+                if (++in < total) {
+                    b3 = fBuffer[in] & 0x00FF;
                 }
                 else {
                     b3 = fInputStream.read();
@@ -617,7 +617,7 @@ public class UTF8Reader
     }
 
     /** Throws an exception for invalid byte. */
-    private void invalidByte(int position, int count) 
+    private void invalidByte(int position, int count)
         throws UTFDataFormatException {
 
         throw new UTFDataFormatException(
@@ -628,7 +628,7 @@ public class UTF8Reader
 
     /** Throws an exception for invalid surrogate bits. */
     private void invalidSurrogate(int uuuuu) throws UTFDataFormatException {
-        
+
         throw new UTFDataFormatException(
                 Localizer.getMessage("jsp.error.xml.invalidHighSurrogate",
                                      Integer.toHexString(uuuuu)));

==================================================
XMLEncodingDetector.java
index 4e84e332bc..6002c265f7 100644
--- a/java/org/apache/jasper/xmlparser/XMLChar.java
+++ b/java/org/apache/jasper/xmlparser/XMLChar.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -74,10 +74,10 @@ public class XMLChar {
 
     /** Pubid character mask. */
     public static final int MASK_PUBID = 0x10;
-    
-    /** 
+
+    /**
      * Content character mask. Special characters are those that can
-     * be considered the start of markup, such as '&lt;' and '&amp;'. 
+     * be considered the start of markup, such as '&lt;' and '&amp;'.
      * The various newline characters are considered special as well.
      * All other valid XML characters can be considered content.
      * <p>
@@ -96,10 +96,10 @@ public class XMLChar {
     //
 
     static {
-        
+
         // Initializing the Character Flag Array
         // Code generated by: XMLCharGenerator.
-        
+
         CHARS[9] = 35;
         CHARS[10] = 19;
         CHARS[13] = 19;
@@ -916,7 +916,7 @@ public class XMLChar {
         }
         return true;
     } // isValidName(String):boolean
-    
+
 
     /*
      * from the namespace rec
@@ -952,7 +952,7 @@ public class XMLChar {
      * in the XML 1.0 Recommendation
      *
      * @param nmtoken string to check
-     * @return true if nmtoken is a valid Nmtoken 
+     * @return true if nmtoken is a valid Nmtoken
      */
     public static boolean isValidNmtoken(String nmtoken) {
         if (nmtoken.length() == 0)

==================================================
XMLString.java
index 05292517ee..eb8f2cfc0c 100644
--- a/java/org/apache/jasper/xmlparser/XMLEncodingDetector.java
+++ b/java/org/apache/jasper/xmlparser/XMLEncodingDetector.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -40,7 +40,7 @@ import org.apache.jasper.compiler.JspUtil;
 import org.apache.jasper.compiler.Localizer;
 
 public class XMLEncodingDetector {
-    
+
     private InputStream stream;
     private String encoding;
     private boolean isEncodingSetInProlog;
@@ -48,7 +48,7 @@ public class XMLEncodingDetector {
     private int skip;
     private Boolean isBigEndian;
     private Reader reader;
-    
+
     // org.apache.xerces.impl.XMLEntityManager fields
     public static final int DEFAULT_BUFFER_SIZE = 2048;
     public static final int DEFAULT_XMLDECL_BUFFER_SIZE = 64;
@@ -56,7 +56,7 @@ public class XMLEncodingDetector {
     private SymbolTable fSymbolTable;
     private XMLEncodingDetector fCurrentEntity;
     private int fBufferSize = DEFAULT_BUFFER_SIZE;
-    
+
     // org.apache.xerces.impl.XMLEntityManager.ScannedEntity fields
     private int lineNumber = 1;
     private int columnNumber = 1;
@@ -65,15 +65,15 @@ public class XMLEncodingDetector {
     private int position;
     private int count;
     private boolean mayReadChunks = false;
-    
+
     // org.apache.xerces.impl.XMLScanner fields
-    private XMLString fString = new XMLString();    
+    private XMLString fString = new XMLString();
     private XMLStringBuffer fStringBuffer = new XMLStringBuffer();
     private XMLStringBuffer fStringBuffer2 = new XMLStringBuffer();
     private static final String fVersionSymbol = "version";
     private static final String fEncodingSymbol = "encoding";
     private static final String fStandaloneSymbol = "standalone";
-    
+
     // org.apache.xerces.impl.XMLDocumentFragmentScannerImpl fields
     private int fMarkupDepth = 0;
     private String[] fStrings = new String[3];
@@ -97,7 +97,7 @@ public class XMLEncodingDetector {
      *
      * @return Two-element array, where the first element (of type
      * java.lang.String) contains the name of the (auto)detected encoding, and
-     * the second element (of type java.lang.Boolean) specifies whether the 
+     * the second element (of type java.lang.Boolean) specifies whether the
      * encoding was specified using the 'encoding' attribute of an XML prolog
      * (TRUE) or autodetected (FALSE).
      */
@@ -128,11 +128,11 @@ public class XMLEncodingDetector {
                               Boolean.valueOf(this.isBomPresent),
                               Integer.valueOf(this.skip) };
     }
-    
+
     // stub method
     void endEntity() {
     }
-    
+
     // Adapted from:
     // org.apache.xerces.impl.XMLEntityManager.startEntity()
     private void createInitialReader() throws IOException, JasperException {
@@ -152,7 +152,7 @@ public class XMLEncodingDetector {
                 Object [] encodingDesc = getEncodingName(b4, count);
                 encoding = (String)(encodingDesc[0]);
                 isBigEndian = (Boolean)(encodingDesc[1]);
-        
+
                 if (encodingDesc.length > 3) {
                     isBomPresent = ((Boolean)(encodingDesc[2])).booleanValue();
                     skip = ((Integer)(encodingDesc[3])).intValue();
@@ -388,12 +388,12 @@ public class XMLEncodingDetector {
      * @throws EOFException Thrown on end of file.
      */
     public int peekChar() throws IOException {
-        
+
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
             load(0, true);
         }
-        
+
         // peek at character
         int c = fCurrentEntity.ch[fCurrentEntity.position];
 
@@ -404,9 +404,9 @@ public class XMLEncodingDetector {
         else {
             return c;
         }
-        
+
     } // peekChar():int
-    
+
     // Adapted from:
     // org.apache.xerces.impl.XMLEntityManager.EntityScanner.scanChar
     /**
@@ -446,7 +446,7 @@ public class XMLEncodingDetector {
         // return character that was scanned
         fCurrentEntity.columnNumber++;
         return c;
-        
+
     }
 
     // Adapted from:
@@ -468,12 +468,12 @@ public class XMLEncodingDetector {
      * @see XMLChar#isNameStart
      */
     public String scanName() throws IOException {
-        
+
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
             load(0, true);
         }
-        
+
         // scan name
         int offset = fCurrentEntity.position;
         if (XMLChar.isNameStart(fCurrentEntity.ch[offset])) {
@@ -517,7 +517,7 @@ public class XMLEncodingDetector {
             symbol = fSymbolTable.addSymbol(fCurrentEntity.ch, offset, length);
         }
         return symbol;
-        
+
     }
 
     // Adapted from:
@@ -694,9 +694,9 @@ public class XMLEncodingDetector {
         char charAt0 = delimiter.charAt(0);
         boolean external = fCurrentEntity.isExternal();
         do {
-    
+
             // load more characters, if needed
-    
+
             if (fCurrentEntity.position == fCurrentEntity.count) {
                 load(0, true);
             }
@@ -705,19 +705,19 @@ public class XMLEncodingDetector {
                                  fCurrentEntity.ch, 0, fCurrentEntity.count - fCurrentEntity.position);
                 load(fCurrentEntity.count - fCurrentEntity.position, false);
                 fCurrentEntity.position = 0;
-            } 
+            }
             if (fCurrentEntity.position >= fCurrentEntity.count - delimLen) {
                 // something must be wrong with the input: e.g., file ends an
                 // unterminated comment
                 int length = fCurrentEntity.count - fCurrentEntity.position;
                 buffer.append (fCurrentEntity.ch, fCurrentEntity.position,
-                               length); 
+                               length);
                 fCurrentEntity.columnNumber += fCurrentEntity.count;
                 fCurrentEntity.position = fCurrentEntity.count;
                 load(0,true);
                 return false;
             }
-    
+
             // normalize newlines
             int offset = fCurrentEntity.position;
             int c = fCurrentEntity.ch[offset];
@@ -772,7 +772,7 @@ public class XMLEncodingDetector {
                     return true;
                 }
             }
-    
+
             // iterate over buffer looking for delimiter
         OUTER: while (fCurrentEntity.position < fCurrentEntity.count) {
             c = fCurrentEntity.ch[fCurrentEntity.position++];
@@ -803,7 +803,7 @@ public class XMLEncodingDetector {
                 fCurrentEntity.position--;
                 int length = fCurrentEntity.position - offset;
                 fCurrentEntity.columnNumber += length - newlines;
-                buffer.append(fCurrentEntity.ch, offset, length); 
+                buffer.append(fCurrentEntity.ch, offset, length);
                 return true;
             }
         }
@@ -813,7 +813,7 @@ public class XMLEncodingDetector {
                 length -= delimLen;
             }
             buffer.append (fCurrentEntity.ch, offset, length);
-    
+
             // return true if string was skipped
         } while (!done);
         return !done;
@@ -1243,7 +1243,7 @@ public class XMLEncodingDetector {
             }
         }
     }
-    
+
     // Adapted from:
     // org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanXMLDeclOrTextDecl
     /**
@@ -1264,7 +1264,7 @@ public class XMLEncodingDetector {
      *                         be scanned instead of an XML
      *                         declaration.
      */
-    private void scanXMLDeclOrTextDecl(boolean scanningTextDecl) 
+    private void scanXMLDeclOrTextDecl(boolean scanningTextDecl)
         throws IOException, JasperException {
 
         // scan decl
@@ -1308,7 +1308,7 @@ public class XMLEncodingDetector {
      * at the time of calling is lost.
      */
     private void scanXMLDeclOrTextDecl(boolean scanningTextDecl,
-                                       String[] pseudoAttributeValues) 
+                                       String[] pseudoAttributeValues)
                 throws IOException, JasperException {
 
         // pseudo-attribute values
@@ -1419,7 +1419,7 @@ public class XMLEncodingDetector {
         if (scanningTextDecl && state != STATE_DONE) {
             err.jspError("jsp.error.xml.morePseudoAttributes");
         }
-        
+
         // If there is no data in the xml or text decl then we fail to report
         // error for version or encoding info above.
         if (scanningTextDecl) {
@@ -1440,7 +1440,7 @@ public class XMLEncodingDetector {
             err.jspError("jsp.error.xml.xmlDeclUnterminated");
 
         }
-        
+
         // fill in return array
         pseudoAttributeValues[0] = version;
         pseudoAttributeValues[1] = encoding;
@@ -1453,10 +1453,10 @@ public class XMLEncodingDetector {
      * Scans a pseudo attribute.
      *
      * @param scanningTextDecl True if scanning this pseudo-attribute for a
-     *                         TextDecl; false if scanning XMLDecl. This 
+     *                         TextDecl; false if scanning XMLDecl. This
      *                         flag is needed to report the correct type of
      *                         error.
-     * @param value            The string to fill in with the attribute 
+     * @param value            The string to fill in with the attribute
      *                         value.
      *
      * @return The name of the attribute
@@ -1464,8 +1464,8 @@ public class XMLEncodingDetector {
      * <strong>Note:</strong> This method uses fStringBuffer2, anything in it
      * at the time of calling is lost.
      */
-    public String scanPseudoAttribute(boolean scanningTextDecl, 
-                                      XMLString value) 
+    public String scanPseudoAttribute(boolean scanningTextDecl,
+                                      XMLString value)
                 throws IOException, JasperException {
 
         String name = scanName();
@@ -1524,12 +1524,12 @@ public class XMLEncodingDetector {
         return name;
 
     }
-    
+
     // Adapted from:
     // org.apache.xerces.impl.XMLScanner.scanPIData
     /**
      * Scans a processing data. This is needed to handle the situation
-     * where a document starts with a processing instruction whose 
+     * where a document starts with a processing instruction whose
      * target name <em>starts with</em> "xml". (e.g. xmlfoo)
      *
      * <strong>Note:</strong> This method uses fStringBuffer, anything in it
@@ -1538,7 +1538,7 @@ public class XMLEncodingDetector {
      * @param target The PI target
      * @param data The string to fill in with the data
      */
-    private void scanPIData(String target, XMLString data) 
+    private void scanPIData(String target, XMLString data)
         throws IOException, JasperException {
 
         // check target
@@ -1613,7 +1613,7 @@ public class XMLEncodingDetector {
         // supplemental character must be a valid XML character
         if (!XMLChar.isValid(c)) {
             err.jspError("jsp.error.xml.invalidCharInContent",
-                         Integer.toString(c, 16)); 
+                         Integer.toString(c, 16));
             return false;
         }
 

==================================================
XMLStringBuffer.java
index 7f995f8ab8..36bf839c90 100644
--- a/java/org/apache/jasper/xmlparser/XMLString.java
+++ b/java/org/apache/jasper/xmlparser/XMLString.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -38,7 +38,7 @@ package org.apache.jasper.xmlparser;
  * <p>
  * <strong>Note:</strong> Methods that are passed an XMLString structure
  * are required to copy the information out of the buffer if it is to be
- * saved for use beyond the scope of the method. The contents of the 
+ * saved for use beyond the scope of the method. The contents of the
  * structure are volatile and the contents of the character buffer cannot
  * be assured once the method that is passed this structure returns.
  * Therefore, methods passed this structure should not save any reference
@@ -79,7 +79,7 @@ public class XMLString {
     /**
      * Initializes the contents of the XMLString structure with the
      * specified values.
-     * 
+     *
      * @param ch     The character array.
      * @param offset The offset into the character array.
      * @param length The length of characters from the offset.
@@ -96,7 +96,7 @@ public class XMLString {
      * <p>
      * <strong>Note:</strong> This does not copy the character array;
      * only the reference to the array is copied.
-     * 
+     *
      * @param s
      */
     public void setValues(XMLString s) {
@@ -114,7 +114,7 @@ public class XMLString {
     /**
      * Returns true if the contents of this XMLString structure and
      * the specified string are equal.
-     * 
+     *
      * @param s The string to compare.
      */
     public boolean equals(String s) {
@@ -125,7 +125,7 @@ public class XMLString {
             return false;
         }
 
-        // is this faster than call s.toCharArray first and compare the 
+        // is this faster than call s.toCharArray first and compare the
         // two arrays directly, which will possibly involve creating a
         // new char array object.
         for (int i=0; i<length; i++) {

==================================================
