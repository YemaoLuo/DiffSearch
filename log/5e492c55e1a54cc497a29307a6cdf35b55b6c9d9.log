5e492c55e1a54cc497a29307a6cdf35b55b6c9d9
==================================================
Introduce SocketProcessorBase and start to pull common SocketProcessor functionality into it.
==================================================
Mark Thomas
==================================================
Tue May 31 20:35:15 2016 +0000
==================================================
AprEndpoint.java
Introduce SocketProcessorBase and start to pull common SocketProcessor functionality into it.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1746341 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Nio2Endpoint.java
index f61a9b23e6..86519b8d1c 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -2244,33 +2244,25 @@ public class AprEndpoint extends AbstractEndpoint<Long> implements SNICallBack {
      * This class is the equivalent of the Worker, but will simply use in an
      * external Executor thread pool.
      */
-    protected class SocketProcessor implements Runnable {
-
-        private final SocketWrapperBase<Long> socket;
-        private final SocketEvent status;
+    protected class SocketProcessor extends  SocketProcessorBase<Long> {
 
         public SocketProcessor(SocketWrapperBase<Long> socket,
-                SocketEvent status) {
-            this.socket = socket;
-            if (status == null) {
-                // Should never happen
-                throw new NullPointerException();
-            }
-            this.status = status;
+                SocketEvent event) {
+            super(socket, event);
         }
 
         @Override
         public void run() {
-            synchronized (socket) {
+            synchronized (socketWrapper) {
                 // Process the request from this socket
-                if (socket.getSocket() == null) {
+                if (socketWrapper.getSocket() == null) {
                     // Closed in another thread
                     return;
                 }
-                SocketState state = getHandler().process(socket, status);
+                SocketState state = getHandler().process(socketWrapper, event);
                 if (state == Handler.SocketState.CLOSED) {
                     // Close socket and pool
-                    closeSocket(socket.getSocket().longValue());
+                    closeSocket(socketWrapper.getSocket().longValue());
                 }
             }
         }

==================================================
NioEndpoint.java
index a6783e7f18..42a3c3c9c0 100644
--- a/java/org/apache/tomcat/util/net/Nio2Endpoint.java
+++ b/java/org/apache/tomcat/util/net/Nio2Endpoint.java
@@ -1624,44 +1624,36 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
      * This class is the equivalent of the Worker, but will simply use in an
      * external Executor thread pool.
      */
-    protected class SocketProcessor implements Runnable {
+    protected class SocketProcessor extends SocketProcessorBase<Nio2Channel> {
 
-        private SocketWrapperBase<Nio2Channel> socket = null;
-        private SocketEvent status = null;
-
-        public SocketProcessor(SocketWrapperBase<Nio2Channel> socket, SocketEvent status) {
-            reset(socket,status);
-        }
-
-        public void reset(SocketWrapperBase<Nio2Channel> socket, SocketEvent status) {
-            this.socket = socket;
-            this.status = status;
+        public SocketProcessor(SocketWrapperBase<Nio2Channel> socketWrapper, SocketEvent event) {
+            super(socketWrapper, event);
         }
 
         @Override
         public void run() {
-            synchronized (socket) {
-                if (SocketEvent.OPEN_WRITE != status) {
+            synchronized (socketWrapper) {
+                if (SocketEvent.OPEN_WRITE != event) {
                     // Anything other than OPEN_WRITE is a genuine read or an
                     // error condition so for all of those release the semaphore
-                    ((Nio2SocketWrapper) socket).releaseReadPending();
+                    ((Nio2SocketWrapper) socketWrapper).releaseReadPending();
                 }
                 boolean launch = false;
                 try {
                     int handshake = -1;
 
                     try {
-                        if (socket.getSocket() != null) {
+                        if (socketWrapper.getSocket() != null) {
                             // For STOP there is no point trying to handshake as the
                             // Poller has been stopped.
-                            if (!socket.getSocket().isHandshakeComplete() && status == SocketEvent.ERROR) {
+                            if (!socketWrapper.getSocket().isHandshakeComplete() && event == SocketEvent.ERROR) {
                                 handshake = -1;
-                            } else if (socket.getSocket().isHandshakeComplete() ||
-                                    status == SocketEvent.STOP ||
-                                    status == SocketEvent.ERROR) {
+                            } else if (socketWrapper.getSocket().isHandshakeComplete() ||
+                                    event == SocketEvent.STOP ||
+                                    event == SocketEvent.ERROR) {
                                 handshake = 0;
                             } else {
-                                handshake = socket.getSocket().handshake();
+                                handshake = socketWrapper.getSocket().handshake();
                                 // The handshake process reads/writes from/to the
                                 // socket. status may therefore be OPEN_WRITE once
                                 // the handshake completes. However, the handshake
@@ -1669,7 +1661,7 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                                 // must always be OPEN_READ after it completes. It
                                 // is OK to always set this as it is only used if
                                 // the handshake completes.
-                                status = SocketEvent.OPEN_READ;
+                                event = SocketEvent.OPEN_READ;
                             }
                         }
                     } catch (IOException x) {
@@ -1681,27 +1673,27 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                     if (handshake == 0) {
                         SocketState state = SocketState.OPEN;
                         // Process the request from this socket
-                        if (status == null) {
-                            state = getHandler().process(socket, SocketEvent.OPEN_READ);
+                        if (event == null) {
+                            state = getHandler().process(socketWrapper, SocketEvent.OPEN_READ);
                         } else {
-                            state = getHandler().process(socket, status);
+                            state = getHandler().process(socketWrapper, event);
                         }
                         if (state == SocketState.CLOSED) {
                             // Close socket and pool
-                            closeSocket(socket);
+                            closeSocket(socketWrapper);
                             if (running && !paused) {
-                                if (!nioChannels.push(socket.getSocket())) {
-                                    socket.getSocket().free();
+                                if (!nioChannels.push(socketWrapper.getSocket())) {
+                                    socketWrapper.getSocket().free();
                                 }
                             }
                         } else if (state == SocketState.UPGRADING) {
                             launch = true;
                         }
                     } else if (handshake == -1 ) {
-                        closeSocket(socket);
+                        closeSocket(socketWrapper);
                         if (running && !paused) {
-                            if (!nioChannels.push(socket.getSocket())) {
-                                socket.getSocket().free();
+                            if (!nioChannels.push(socketWrapper.getSocket())) {
+                                socketWrapper.getSocket().free();
                             }
                         }
                     }
@@ -1709,13 +1701,13 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                     ExceptionUtils.handleThrowable(vme);
                 } catch (Throwable t) {
                     log.error(sm.getString("endpoint.processing.fail"), t);
-                    if (socket != null) {
-                        closeSocket(socket);
+                    if (socketWrapper != null) {
+                        closeSocket(socketWrapper);
                     }
                 } finally {
                     if (launch) {
                         try {
-                            getExecutor().execute(new SocketProcessor(socket, SocketEvent.OPEN_READ));
+                            getExecutor().execute(new SocketProcessor(socketWrapper, SocketEvent.OPEN_READ));
                         } catch (NullPointerException npe) {
                             if (running) {
                                 log.error(sm.getString("endpoint.launch.fail"),
@@ -1723,8 +1715,8 @@ public class Nio2Endpoint extends AbstractJsseEndpoint<Nio2Channel> {
                             }
                         }
                     }
-                    socket = null;
-                    status = null;
+                    socketWrapper = null;
+                    event = null;
                     //return to cache
                     if (running && !paused) {
                         processorCache.push(this);

==================================================
SocketProcessorBase.java
index af2e6dfa2f..600235120f 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -1423,23 +1423,15 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel> {
      * This class is the equivalent of the Worker, but will simply use in an
      * external Executor thread pool.
      */
-    protected class SocketProcessor implements Runnable {
+    protected class SocketProcessor extends SocketProcessorBase<NioChannel> {
 
-        private NioSocketWrapper ka = null;
-        private SocketEvent status = null;
-
-        public SocketProcessor(NioSocketWrapper ka, SocketEvent status) {
-            reset(ka, status);
-        }
-
-        public void reset(NioSocketWrapper ka, SocketEvent status) {
-            this.ka = ka;
-            this.status = status;
+        public SocketProcessor(SocketWrapperBase<NioChannel> ka, SocketEvent event) {
+            super(ka, event);
         }
 
         @Override
         public void run() {
-            NioChannel socket = ka.getSocket();
+            NioChannel socket = socketWrapper.getSocket();
             if (socket == null) {
                 return;
             }
@@ -1455,7 +1447,7 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel> {
                             // For STOP there is no point trying to handshake as the
                             // Poller has been stopped.
                             if (socket.isHandshakeComplete() ||
-                                    status == SocketEvent.STOP) {
+                                    event == SocketEvent.STOP) {
                                 handshake = 0;
                             } else {
                                 handshake = socket.handshake(
@@ -1467,7 +1459,7 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel> {
                                 // must always be OPEN_READ after it completes. It
                                 // is OK to always set this as it is only used if
                                 // the handshake completes.
-                                status = SocketEvent.OPEN_READ;
+                                event = SocketEvent.OPEN_READ;
                             }
                         }
                     } catch (IOException x) {
@@ -1479,18 +1471,20 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel> {
                     if (handshake == 0) {
                         SocketState state = SocketState.OPEN;
                         // Process the request from this socket
-                        if (status == null) {
-                            state = getHandler().process(ka, SocketEvent.OPEN_READ);
+                        if (event == null) {
+                            state = getHandler().process(socketWrapper, SocketEvent.OPEN_READ);
                         } else {
-                            state = getHandler().process(ka, status);
+                            state = getHandler().process(socketWrapper, event);
                         }
                         if (state == SocketState.CLOSED) {
                             close(socket, key);
                         }
                     } else if (handshake == -1 ) {
                         close(socket, key);
-                    } else {
-                        ka.getPoller().add(socket,handshake);
+                    } else if (handshake == SelectionKey.OP_READ){
+                        socketWrapper.registerReadInterest();
+                    } else if (handshake == SelectionKey.OP_WRITE){
+                        socketWrapper.registerWriteInterest();
                     }
                 } catch (CancelledKeyException cx) {
                     socket.getPoller().cancelledKey(key);
@@ -1500,8 +1494,8 @@ public class NioEndpoint extends AbstractJsseEndpoint<NioChannel> {
                     log.error("", t);
                     socket.getPoller().cancelledKey(key);
                 } finally {
-                    ka = null;
-                    status = null;
+                    socketWrapper = null;
+                    event = null;
                     //return to cache
                     if (running && !paused) {
                         processorCache.push(this);

==================================================
