dccc2644ce701e88b152563473a350ec33a29a81
==================================================
Further fix for BZ 66508
==================================================
Mark Thomas
==================================================
Fri Mar 24 17:21:04 2023 +0000
==================================================
SocketWrapperBase.java
Further fix for BZ 66508

https://bz.apache.org/bugzilla/show_bug.cgi?id=66508

Avoid deadlock for close messages when
WsRemoteEndpointImplServer.endMessage() for a previous message is
processed on a container thread



==================================================
WsRemoteEndpointImplBase.java
index ae6ee0e019..1216bd7a3a 100644
--- a/java/org/apache/tomcat/util/net/SocketWrapperBase.java
+++ b/java/org/apache/tomcat/util/net/SocketWrapperBase.java
@@ -31,7 +31,6 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
-import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
 import jakarta.servlet.ServletConnection;
@@ -61,7 +60,7 @@ public abstract class SocketWrapperBase<E> {
 
     private E socket;
     private final AbstractEndpoint<E,?> endpoint;
-    private final Lock lock = new ReentrantLock();
+    private final ReentrantLock lock = new ReentrantLock();
 
     protected final AtomicBoolean closed = new AtomicBoolean(false);
 
@@ -158,7 +157,7 @@ public abstract class SocketWrapperBase<E> {
         return endpoint;
     }
 
-    public Lock getLock() {
+    public ReentrantLock getLock() {
         return lock;
     }
 

==================================================
WsRemoteEndpointImplClient.java
index eec3381a85..5dc9298b6e 100644
--- a/java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java
+++ b/java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java
@@ -33,6 +33,7 @@ import java.util.concurrent.Future;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.ReentrantLock;
 
 import javax.naming.NamingException;
 
@@ -66,7 +67,7 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
     private final IntermediateMessageHandler intermediateMessageHandler = new IntermediateMessageHandler(this);
 
     private Transformation transformation = null;
-    private final Semaphore messagePartInProgress = new Semaphore(1);
+    protected final Semaphore messagePartInProgress = new Semaphore(1);
     private final Queue<MessagePart> messagePartQueue = new ArrayDeque<>();
     private final Object messagePartLock = new Object();
 
@@ -288,9 +289,8 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
             return;
         }
 
-        long timeout = timeoutExpiry - System.currentTimeMillis();
         try {
-            if (!messagePartInProgress.tryAcquire(timeout, TimeUnit.MILLISECONDS)) {
+            if (!acquireMessagePartInProgressSemaphore(opCode, timeoutExpiry)) {
                 String msg = sm.getString("wsRemoteEndpoint.acquireTimeout");
                 wsSession.doClose(new CloseReason(CloseCodes.GOING_AWAY, msg),
                         new CloseReason(CloseCodes.CLOSED_ABNORMALLY, msg), true);
@@ -334,6 +334,23 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
     }
 
 
+    /**
+     * Acquire the semaphore that allows a message part to be written.
+     *
+     * @param opCode        The OPCODE for the message to be written
+     * @param timeoutExpiry The time when the attempt to acquire the semaphore should expire
+     *
+     * @return {@code true} if the semaphore is obtained, otherwise {@code false}.
+     *
+     * @throws InterruptedException If the wait for the semaphore is interrupted
+     */
+    protected boolean acquireMessagePartInProgressSemaphore(byte opCode, long timeoutExpiry)
+            throws InterruptedException {
+        long timeout = timeoutExpiry - System.currentTimeMillis();
+        return messagePartInProgress.tryAcquire(timeout, TimeUnit.MILLISECONDS);
+    }
+
+
     void startMessage(byte opCode, ByteBuffer payload, boolean last, SendHandler handler) {
 
         wsSession.updateLastActiveWrite();
@@ -735,6 +752,9 @@ public abstract class WsRemoteEndpointImplBase implements RemoteEndpoint {
 
     protected abstract void doClose();
 
+    protected abstract ReentrantLock getLock();
+
+
     private static void writeHeader(ByteBuffer headerBuffer, boolean fin, int rsv, byte opCode, boolean masked,
             ByteBuffer payload, byte[] mask, boolean first) {
 

==================================================
WsSession.java
index d22ac2d3fd..5f0cc67fc3 100644
--- a/java/org/apache/tomcat/websocket/WsRemoteEndpointImplClient.java
+++ b/java/org/apache/tomcat/websocket/WsRemoteEndpointImplClient.java
@@ -21,6 +21,7 @@ import java.nio.ByteBuffer;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
+import java.util.concurrent.locks.ReentrantLock;
 
 import jakarta.websocket.SendHandler;
 import jakarta.websocket.SendResult;
@@ -28,6 +29,7 @@ import jakarta.websocket.SendResult;
 public class WsRemoteEndpointImplClient extends WsRemoteEndpointImplBase {
 
     private final AsyncChannelWrapper channel;
+    private final ReentrantLock lock = new ReentrantLock();
 
     public WsRemoteEndpointImplClient(AsyncChannelWrapper channel) {
         this.channel = channel;
@@ -67,8 +69,15 @@ public class WsRemoteEndpointImplClient extends WsRemoteEndpointImplBase {
         handler.onResult(SENDRESULT_OK);
     }
 
+
     @Override
     protected void doClose() {
         channel.close();
     }
+
+
+    @Override
+    protected ReentrantLock getLock() {
+        return lock;
+    }
 }

==================================================
WsHttpUpgradeHandler.java
index 1851e80001..5f947afde7 100644
--- a/java/org/apache/tomcat/websocket/WsSession.java
+++ b/java/org/apache/tomcat/websocket/WsSession.java
@@ -107,7 +107,6 @@ public class WsSession implements Session {
     private volatile MessageHandler binaryMessageHandler = null;
     private volatile MessageHandler.Whole<PongMessage> pongMessageHandler = null;
     private volatile State state = State.OPEN;
-    private final Object stateLock = new Object();
     private final Map<String, Object> userProperties = new ConcurrentHashMap<>();
     private volatile int maxBinaryMessageBufferSize = Constants.DEFAULT_BUFFER_SIZE;
     private volatile int maxTextMessageBufferSize = Constants.DEFAULT_BUFFER_SIZE;
@@ -564,7 +563,8 @@ public class WsSession implements Session {
             return;
         }
 
-        synchronized (stateLock) {
+        wsRemoteEndpoint.getLock().lock();
+        try {
             if (state != State.OPEN) {
                 return;
             }
@@ -594,6 +594,8 @@ public class WsSession implements Session {
                 }
                 fireEndpointOnClose(closeReasonLocal);
             }
+        } finally {
+            wsRemoteEndpoint.getLock().unlock();
         }
 
         IOException ioe = new IOException(sm.getString("wsSession.messageFailed"));
@@ -612,7 +614,8 @@ public class WsSession implements Session {
      */
     public void onClose(CloseReason closeReason) {
 
-        synchronized (stateLock) {
+        wsRemoteEndpoint.getLock().lock();
+        try {
             if (state != State.CLOSED) {
                 try {
                     wsRemoteEndpoint.setBatchingAllowed(false);
@@ -630,9 +633,12 @@ public class WsSession implements Session {
                 // Close the socket
                 wsRemoteEndpoint.close();
             }
+        } finally {
+            wsRemoteEndpoint.getLock().unlock();
         }
     }
 
+
     private void fireEndpointOnClose(CloseReason closeReason) {
 
         // Fire the onClose event

==================================================
WsRemoteEndpointImplServer.java
index b180e52a74..7f37101e71 100644
--- a/java/org/apache/tomcat/websocket/server/WsHttpUpgradeHandler.java
+++ b/java/org/apache/tomcat/websocket/server/WsHttpUpgradeHandler.java
@@ -117,7 +117,8 @@ public class WsHttpUpgradeHandler implements InternalHttpUpgradeHandler {
         ClassLoader cl = t.getContextClassLoader();
         t.setContextClassLoader(applicationClassLoader);
         try {
-            wsRemoteEndpointServer = new WsRemoteEndpointImplServer(socketWrapper, upgradeInfo, webSocketContainer);
+            wsRemoteEndpointServer = new WsRemoteEndpointImplServer(socketWrapper, upgradeInfo, webSocketContainer,
+                    connection);
             wsSession = new WsSession(wsRemoteEndpointServer, webSocketContainer, handshakeRequest.getRequestURI(),
                     handshakeRequest.getParameterMap(), handshakeRequest.getQueryString(),
                     handshakeRequest.getUserPrincipal(), httpSessionId, negotiatedExtensions, subProtocol,

==================================================
