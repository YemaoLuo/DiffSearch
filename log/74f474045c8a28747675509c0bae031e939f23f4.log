74f474045c8a28747675509c0bae031e939f23f4
==================================================
Let the RemoteCIDRValve inherit from RequestFilterValve
==================================================
Rainer Jung
==================================================
Fri Dec 4 13:59:43 2020 +0100
==================================================
NetMask.java
index 7c2fe5b3d6..9dcb2ff01d 100644
--- a/java/org/apache/catalina/util/LocalStrings.properties
+++ b/java/org/apache/catalina/util/LocalStrings.properties
@@ -42,6 +42,7 @@ netmask.cidrNegative=The CIDR [{0}] is negative
 netmask.cidrNotNumeric=The CIDR [{0}] is not numeric
 netmask.cidrTooBig=The CIDR [{0}] is greater than the address length [{1}]
 netmask.invalidAddress=The address [{0}] is not valid
+netmask.invalidPort=The port part in the pattern [{0}] is not valid
 
 parameterMap.locked=No modifications are allowed to a locked ParameterMap
 

==================================================
RemoteCIDRValve.java
index 25f8332629..111dd4d64e 100644
--- a/java/org/apache/catalina/valves/LocalStrings.properties
+++ b/java/org/apache/catalina/valves/LocalStrings.properties
@@ -130,7 +130,9 @@ jdbcAccessLogValve.close=Failed to close database
 jdbcAccessLogValve.exception=Exception performing insert access entry
 
 remoteCidrValve.invalid=Invalid configuration provided for [{0}]. See previous messages for details.
+remoteCidrValve.noPort=Request does not contain a valid server port. Request denied.
 remoteCidrValve.noRemoteIp=Client does not have an IP address. Request denied.
+remoteCidrValve.unexpectedPort=Request contains server port, although connector configuration attribute addConnectorPort is false. Request denied.
 
 remoteIpValve.invalidHostHeader=Invalid value [{0}] found for Host in HTTP header [{1}]
 remoteIpValve.invalidHostWithPort=Host value [{0}] in HTTP header [{1}] included a port number which will be ignored
@@ -147,4 +149,4 @@ stuckThreadDetectionValve.notifyStuckThreadCompleted=Thread [{0}] (id=[{3}]) was
 stuckThreadDetectionValve.notifyStuckThreadDetected=Thread [{0}] (id=[{6}]) has been active for [{1}] milliseconds (since [{2}]) to serve the same request for [{4}] and may be stuck (configured threshold for this StuckThreadDetectionValve is [{5}] seconds). There is/are [{3}] thread(s) in total that are monitored by this Valve and may be stuck.
 stuckThreadDetectionValve.notifyStuckThreadInterrupted=Thread [{0}] (id=[{5}]) has been interrupted because it was active for [{1}] milliseconds (since [{2}]) to serve the same request for [{3}] and was probably stuck (configured interruption threshold for this StuckThreadDetectionValve is [{4}] seconds).
 
-persistentValve.filter.failure=Unable to compile filter=[{0}]
\ No newline at end of file
+persistentValve.filter.failure=Unable to compile filter=[{0}]

==================================================
TestNetMask.java
index 41d1178b1c..1fd880e0f8 100644
--- a/java/org/apache/catalina/valves/mbeans-descriptors.xml
+++ b/java/org/apache/catalina/valves/mbeans-descriptors.xml
@@ -457,6 +457,69 @@
     </operation>
   </mbean>
 
+  <mbean name="RemoteCIDRValve"
+         description="Concrete implementation of RequestFilterValve that filters based on the string representation of the remote client's network address in CIDR format"
+         domain="Catalina"
+         group="Valve"
+         type="org.apache.catalina.valves.RemoteCIDRValve">
+
+    <attribute name="addConnectorPort"
+               description="Append the server connector port to the client network CIDR separated by a semicolon"
+               type="boolean"/>
+
+    <attribute name="allow"
+               description="The allow expression"
+               type="java.lang.String"/>
+
+    <attribute name="allowValid"
+               description="Becomes false if assigned value of allow expression is not syntactically correct"
+               is="true"
+               type="boolean"
+               writeable="false"/>
+
+    <attribute name="asyncSupported"
+               description="Does this valve support async reporting."
+               is="true"
+               type="boolean"/>
+
+    <attribute name="className"
+               description="Fully qualified class name of the managed object"
+               type="java.lang.String"
+               writeable="false"/>
+
+    <attribute name="deny"
+               description="The deny expression"
+               type="java.lang.String"/>
+
+    <attribute name="denyStatus"
+               description="HTTP response status code that is used when rejecting denied request"
+               type="int"/>
+
+    <attribute name="denyValid"
+               description="Becomes false if assigned value of deny expression is not syntactically correct"
+               is="true"
+               type="boolean"
+               writeable="false"/>
+
+    <attribute name="invalidAuthenticationWhenDeny"
+               description="Send an invalid authentication header instead of deny"
+               type="boolean"/>
+
+    <attribute name="stateName"
+               description="The name of the LifecycleState that this component is currently in"
+               type="java.lang.String"
+               writeable="false"/>
+
+    <operation name="isAllowed"
+               description="Tests whether a client with this host name is allowed access by the current valve configuration"
+               impact="INFO"
+               returnType="boolean">
+      <parameter name="hostName"
+          description="host name to be tested"
+                 type="java.lang.String"/>
+    </operation>
+  </mbean>
+
   <mbean name="RemoteIpValve"
          description="Valve that sets client information (eg IP address) based on data from a trusted proxy"
          domain="Catalina"

==================================================
TestRequestFilterValve.java
index 2260a24781..b67ae545a6 100644
--- a/test/org/apache/catalina/util/TestNetMask.java
+++ b/test/org/apache/catalina/util/TestNetMask.java
@@ -61,6 +61,9 @@ public final class TestNetMask {
         result.add(new Object[] { "ae31::27:ef2:1/-1", null, Boolean.FALSE, null });
         result.add(new Object[] { "ae31::27:ef2:1/129", null, Boolean.FALSE, null });
 
+        // Invalid port regex suffix after ";"
+        result.add(new Object[] { "1.2.3.4;[", null, Boolean.FALSE, null });
+
         // IPv4
         result.add(new Object[] { "1.2.3.4", "1.2.3.4", Boolean.TRUE, Boolean.TRUE });
 
@@ -98,6 +101,16 @@ public final class TestNetMask {
         // Mixed
         result.add(new Object[] { "10.0.0.0/22", "::1", Boolean.TRUE, Boolean.FALSE });
 
+        // port
+        result.add(new Object[] { "1.2.3.4;8080", "1.2.3.4", Boolean.TRUE, Boolean.FALSE });
+        result.add(new Object[] { "1.2.3.4", "1.2.3.4;8080", Boolean.TRUE, Boolean.FALSE });
+        result.add(new Object[] { "1.2.3.4;", "1.2.3.4;8080", Boolean.TRUE, Boolean.FALSE });
+        result.add(new Object[] { "1.2.3.4;8080", "1.2.3.4;8080", Boolean.TRUE, Boolean.TRUE });
+        result.add(new Object[] { "1.2.3.4;8080", "1.2.3.4;8009", Boolean.TRUE, Boolean.FALSE });
+        result.add(new Object[] { "1.2.3.4;.*", "1.2.3.4;8080", Boolean.TRUE, Boolean.TRUE });
+        result.add(new Object[] { "1.2.3.4;8\\d+", "1.2.3.4;8080", Boolean.TRUE, Boolean.TRUE });
+        result.add(new Object[] { "1.2.3.4;8\\d+", "1.2.3.4;9090", Boolean.TRUE, Boolean.FALSE });
+
         return result;
     }
 
@@ -109,7 +122,7 @@ public final class TestNetMask {
         try {
             netMask = new NetMask(mask);
         } catch (Exception e) {
-            exception =e;
+            exception = e;
         }
 
         if (valid.booleanValue()) {
@@ -122,15 +135,32 @@ public final class TestNetMask {
             return;
         }
 
+        final int portIdx = input.indexOf(";");
+        final boolean usePort = portIdx >= 0 || mask.indexOf(";") >= 0;
+        final int port;
+        final String nonPortPart;
+
+        if (portIdx == -1) {
+            port = -1;
+            nonPortPart = input;
+        } else {
+            port = Integer.parseInt(input.substring(portIdx + 1));
+            nonPortPart = input.substring(0, portIdx);
+        }
+
         InetAddress inetAddress = null;
         try {
-            inetAddress = InetAddress.getByName(input);
+            inetAddress = InetAddress.getByName(nonPortPart);
         } catch (UnknownHostException e) {
             e.printStackTrace();
             Assert.fail();
         }
 
-        Assert.assertEquals(matches, Boolean.valueOf(netMask.matches(inetAddress)));
+        if (usePort) {
+            Assert.assertEquals(matches, Boolean.valueOf(netMask.matches(inetAddress, port)));
+        } else {
+            Assert.assertEquals(matches, Boolean.valueOf(netMask.matches(inetAddress)));
+        }
 
         Assert.assertEquals(mask, netMask.toString());
     }

==================================================
