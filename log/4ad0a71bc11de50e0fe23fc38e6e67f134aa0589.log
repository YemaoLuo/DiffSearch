4ad0a71bc11de50e0fe23fc38e6e67f134aa0589
==================================================
BZ 64190 Add 'proper' ms support to OneLineFormatter.
==================================================
Mark Thomas
==================================================
Tue Mar 3 14:36:08 2020 +0000
==================================================
OneLineFormatter.java
BZ 64190 Add 'proper' ms support to OneLineFormatter.

S SS or SSS can now be used (once) anywhere in the format String.
Format strings without S SS or SSS are now ~30% faster
The current default (effectively "dd-MMM-yyyy HH:mm:ss.SSS") is within
less than 1% of the old implementation.
Using S SS or SSS anywhere but the very end doubles the time taken to
generate the timestamp.


==================================================
TestOneLineFormatterMillisPerformance.java
index 75845cf9ce..fad37b0603 100644
--- a/java/org/apache/juli/OneLineFormatter.java
+++ b/java/org/apache/juli/OneLineFormatter.java
@@ -51,7 +51,7 @@ public class OneLineFormatter extends Formatter {
     };
 
     /* Timestamp format */
-    private static final String DEFAULT_TIME_FORMAT = "dd-MMM-yyyy HH:mm:ss";
+    private static final String DEFAULT_TIME_FORMAT = "dd-MMM-yyyy HH:mm:ss.SSS";
 
     /**
      * The size of our global date format cache
@@ -68,6 +68,8 @@ public class OneLineFormatter extends Formatter {
      */
     private ThreadLocal<DateFormatCache> localDateCache;
 
+    private volatile MillisHandling millisHandling = MillisHandling.APPEND;
+
 
     public OneLineFormatter() {
         String timeFormat = LogManager.getLogManager().getProperty(
@@ -86,12 +88,31 @@ public class OneLineFormatter extends Formatter {
      *                   {@link java.text.SimpleDateFormat} syntax
      */
     public void setTimeFormat(final String timeFormat) {
+        final String cachedTimeFormat;
+
+        if (timeFormat.endsWith(".SSS")) {
+            cachedTimeFormat = timeFormat.substring(0,  timeFormat.length() - 4);
+            millisHandling = MillisHandling.APPEND;
+        } else if (timeFormat.contains("SSS")) {
+            millisHandling = MillisHandling.REPLACE_SSS;
+            cachedTimeFormat = timeFormat;
+        } else if (timeFormat.contains("SS")) {
+            millisHandling = MillisHandling.REPLACE_SS;
+            cachedTimeFormat = timeFormat;
+        } else if (timeFormat.contains("S")) {
+            millisHandling = MillisHandling.REPLACE_S;
+            cachedTimeFormat = timeFormat;
+        } else {
+            millisHandling = MillisHandling.NONE;
+            cachedTimeFormat = timeFormat;
+        }
+
         final DateFormatCache globalDateCache =
-                new DateFormatCache(globalCacheSize, timeFormat, null);
+                new DateFormatCache(globalCacheSize, cachedTimeFormat, null);
         localDateCache = new ThreadLocal<DateFormatCache>() {
             @Override
             protected DateFormatCache initialValue() {
-                return new DateFormatCache(localCacheSize, timeFormat, globalDateCache);
+                return new DateFormatCache(localCacheSize, cachedTimeFormat, globalDateCache);
             }
         };
     }
@@ -156,18 +177,45 @@ public class OneLineFormatter extends Formatter {
     }
 
     protected void addTimestamp(StringBuilder buf, long timestamp) {
-        buf.append(localDateCache.get().getFormat(timestamp));
-        long frac = timestamp % 1000;
-        buf.append('.');
-        if (frac < 100) {
-            if (frac < 10) {
+        String cachedTimeStamp = localDateCache.get().getFormat(timestamp);
+        if (millisHandling == MillisHandling.NONE) {
+            buf.append(cachedTimeStamp);
+        } else if (millisHandling == MillisHandling.APPEND) {
+            buf.append(cachedTimeStamp);
+            long frac = timestamp % 1000;
+            buf.append('.');
+            if (frac < 100) {
+                if (frac < 10) {
+                    buf.append('0');
+                    buf.append('0');
+                } else {
+                    buf.append('0');
+                }
+            }
+            buf.append(frac);
+        } else {
+            // Some version of replace
+            long frac = timestamp % 1000;
+            // Formatted string may vary in length so the insert point may vary
+            int insertStart = cachedTimeStamp.indexOf('#');
+            buf.append(cachedTimeStamp.subSequence(0, insertStart));
+            if (frac < 100 && millisHandling == MillisHandling.REPLACE_SSS) {
                 buf.append('0');
+                if (frac < 10) {
+                    buf.append('0');
+                }
+            } else if (frac < 10 && millisHandling == MillisHandling.REPLACE_SS) {
                 buf.append('0');
+            }
+            buf.append(frac);
+            if (millisHandling == MillisHandling.REPLACE_SSS) {
+                buf.append(cachedTimeStamp.substring(insertStart + 3));
+            } else if (millisHandling == MillisHandling.REPLACE_SS) {
+                buf.append(cachedTimeStamp.substring(insertStart + 2));
             } else {
-                buf.append('0');
+                buf.append(cachedTimeStamp.substring(insertStart + 1));
             }
         }
-        buf.append(frac);
     }
 
 
@@ -250,4 +298,13 @@ public class OneLineFormatter extends Formatter {
             super.println(x);
         }
     }
+
+
+    private static enum MillisHandling {
+        NONE,
+        APPEND,
+        REPLACE_S,
+        REPLACE_SS,
+        REPLACE_SSS,
+    }
 }

==================================================
