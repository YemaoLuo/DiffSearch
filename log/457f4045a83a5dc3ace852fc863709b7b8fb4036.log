457f4045a83a5dc3ace852fc863709b7b8fb4036
==================================================
UCDetector: Remove unused classes
==================================================
Mark Emlyn
==================================================
Tue Feb 19 20:00:33 2013 +0000
==================================================
GenericParser.java
UCDetector: Remove unused classes

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1447888 13f79535-47bb-0310-9956-ffa450edef68



==================================================
NodeCreateRule.java
deleted file mode 100644
index 7fe2126fb2..0000000000
--- a/java/org/apache/tomcat/util/digester/GenericParser.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.tomcat.util.digester;
-
-import java.util.Properties;
-
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-
-import org.apache.juli.logging.Log;
-import org.apache.juli.logging.LogFactory;
-import org.xml.sax.SAXException;
-import org.xml.sax.SAXNotRecognizedException;
-
-/**
- * Create a <code>SAXParser</code> configured to support XML Schema and DTD.
- *
- * @since 1.6
- */
-
-public class GenericParser{
-
-    /**
-     * The Log to which all SAX event related logging calls will be made.
-     */
-    private static final Log log =
-        LogFactory.getLog("org.apache.tomcat.util.digester.Digester.sax");
-
-    /**
-     * The JAXP 1.2 property required to set up the schema location.
-     */
-    private static final String JAXP_SCHEMA_SOURCE =
-        "http://java.sun.com/xml/jaxp/properties/schemaSource";
-
-    /**
-     * The JAXP 1.2 property to set up the schemaLanguage used.
-     */
-    protected static String JAXP_SCHEMA_LANGUAGE =
-        "http://java.sun.com/xml/jaxp/properties/schemaLanguage";
-
-    /**
-     * Create a <code>SAXParser</code> configured to support XML Schema and DTD
-     * @param properties parser specific properties/features
-     * @return an XML Schema/DTD enabled <code>SAXParser</code>
-     */
-    public static SAXParser newSAXParser(Properties properties)
-            throws ParserConfigurationException,
-                   SAXException,
-                   SAXNotRecognizedException{
-
-        SAXParserFactory factory =
-                        (SAXParserFactory)properties.get("SAXParserFactory");
-        SAXParser parser = factory.newSAXParser();
-        String schemaLocation = (String)properties.get("schemaLocation");
-        String schemaLanguage = (String)properties.get("schemaLanguage");
-
-        try{
-            if (schemaLocation != null) {
-                parser.setProperty(JAXP_SCHEMA_LANGUAGE, schemaLanguage);
-                parser.setProperty(JAXP_SCHEMA_SOURCE, schemaLocation);
-            }
-        } catch (SAXNotRecognizedException e){
-            log.info(parser.getClass().getName() + ": "
-                                        + e.getMessage() + " not supported.");
-        }
-        return parser;
-    }
-
-}
\ No newline at end of file

==================================================
ParserFeatureSetterFactory.java
deleted file mode 100644
index 56f3b321ea..0000000000
--- a/java/org/apache/tomcat/util/digester/NodeCreateRule.java
+++ /dev/null
@@ -1,440 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.tomcat.util.digester;
-
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-
-import org.w3c.dom.Attr;
-import org.w3c.dom.DOMException;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
-import org.w3c.dom.Node;
-import org.xml.sax.Attributes;
-import org.xml.sax.ContentHandler;
-import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
-import org.xml.sax.helpers.DefaultHandler;
-
-
-/**
- * A rule implementation that creates a DOM
- * {@link org.w3c.dom.Node Node} containing the XML at the element that matched
- * the rule. Two concrete types of nodes can be created by this rule:
- * <ul>
- *   <li>the default is to create an {@link org.w3c.dom.Element Element} node.
- *   The created element will correspond to the element that matched the rule,
- *   containing all XML content underneath that element.</li>
- *   <li>alternatively, this rule can create nodes of type
- *   {@link org.w3c.dom.DocumentFragment DocumentFragment}, which will contain
- *   only the XML content under the element the rule was triggered on.</li>
- * </ul>
- * The created node will be normalized, meaning it will not contain text nodes
- * that only contain white space characters.
- *
-
- *
- * <p>The created <code>Node</code> will be pushed on Digester's object stack
- * when done. To use it in the context of another DOM
- * {@link org.w3c.dom.Document Document}, it must be imported first, using the
- * Document method
- * {@link org.w3c.dom.Document#importNode(org.w3c.dom.Node, boolean) importNode()}.
- * </p>
- *
- * <p><strong>Important Note:</strong> This is implemented by replacing the SAX
- * {@link org.xml.sax.ContentHandler ContentHandler} in the parser used by
- * Digester, and resetting it when the matched element is closed. As a side
- * effect, rules that would match XML nodes under the element that matches
- * a <code>NodeCreateRule</code> will never be triggered by Digester, which
- * usually is the behavior one would expect.</p>
- *
- * <p><strong>Note</strong> that the current implementation does not set the namespace prefixes
- * in the exported nodes. The (usually more important) namespace URIs are set,
- * of course.</p>
- *
- * @since Digester 1.4
- */
-
-public class NodeCreateRule extends Rule {
-
-
-    // ---------------------------------------------------------- Inner Classes
-
-
-    /**
-     * The SAX content handler that does all the actual work of assembling the
-     * DOM node tree from the SAX events.
-     */
-    private class NodeBuilder
-        extends DefaultHandler {
-
-
-        // ------------------------------------------------------- Constructors
-
-
-        /**
-         * Constructor.
-         *
-         * <p>Stores the content handler currently used by Digester so it can
-         * be reset when done, and initializes the DOM objects needed to
-         * build the node.</p>
-         *
-         * @param doc the document to use to create nodes
-         * @param root the root node
-         * @throws ParserConfigurationException if the DocumentBuilderFactory
-         *   could not be instantiated
-         * @throws SAXException if the XMLReader could not be instantiated by
-         *   Digester (should not happen)
-         */
-        public NodeBuilder(Document doc, Node root)
-            throws ParserConfigurationException, SAXException {
-
-            this.doc = doc;
-            this.root = root;
-            this.top = root;
-
-            oldContentHandler = digester.getXMLReader().getContentHandler();
-
-        }
-
-
-        // ------------------------------------------------- Instance Variables
-
-
-        /**
-         * The content handler used by Digester before it was set to this
-         * content handler.
-         */
-        protected ContentHandler oldContentHandler = null;
-
-
-        /**
-         * Depth of the current node, relative to the element where the content
-         * handler was put into action.
-         */
-        protected int depth = 0;
-
-
-        /**
-         * A DOM Document used to create the various Node instances.
-         */
-        protected Document doc = null;
-
-
-        /**
-         * The DOM node that will be pushed on Digester's stack.
-         */
-        protected Node root = null;
-
-
-        /**
-         * The current top DOM mode.
-         */
-        protected Node top = null;
-
-
-        // --------------------------------------------- ContentHandler Methods
-
-
-        /**
-         * Appends a {@link org.w3c.dom.Text Text} node to the current node.
-         *
-         * @param ch the characters from the XML document
-         * @param start the start position in the array
-         * @param length the number of characters to read from the array
-         * @throws SAXException if the DOM implementation throws an exception
-         */
-        @Override
-        public void characters(char[] ch, int start, int length)
-            throws SAXException {
-
-            try {
-                String str = new String(ch, start, length);
-                if (str.trim().length() > 0) {
-                    top.appendChild(doc.createTextNode(str));
-                }
-            } catch (DOMException e) {
-                throw new SAXException(e.getMessage(), e);
-            }
-
-        }
-
-
-        /**
-         * Checks whether control needs to be returned to Digester.
-         *
-         * @param namespaceURI the namespace URI
-         * @param localName the local name
-         * @param qName the qualified (prefixed) name
-         * @throws SAXException if the DOM implementation throws an exception
-         */
-        @Override
-        public void endElement(String namespaceURI, String localName,
-                               String qName)
-            throws SAXException {
-
-            try {
-                if (depth == 0) {
-                    getDigester().getXMLReader().setContentHandler(
-                        oldContentHandler);
-                    getDigester().push(root);
-                    getDigester().endElement(namespaceURI, localName, qName);
-                }
-
-                top = top.getParentNode();
-                depth--;
-            } catch (DOMException e) {
-                throw new SAXException(e.getMessage(), e);
-            }
-
-        }
-
-
-        /**
-         * Adds a new
-         * {@link org.w3c.dom.ProcessingInstruction ProcessingInstruction} to
-         * the current node.
-         *
-         * @param target the processing instruction target
-         * @param data the processing instruction data, or null if none was
-         *   supplied
-         * @throws SAXException if the DOM implementation throws an exception
-         */
-        @Override
-        public void processingInstruction(String target, String data)
-            throws SAXException {
-
-            try {
-                top.appendChild(doc.createProcessingInstruction(target, data));
-            } catch (DOMException e) {
-                throw new SAXException(e.getMessage(), e);
-            }
-
-        }
-
-
-        /**
-         * Adds a new child {@link org.w3c.dom.Element Element} to the current
-         * node.
-         *
-         * @param namespaceURI the namespace URI
-         * @param localName the local name
-         * @param qName the qualified (prefixed) name
-         * @param atts the list of attributes
-         * @throws SAXException if the DOM implementation throws an exception
-         */
-        @Override
-        public void startElement(String namespaceURI, String localName,
-                                 String qName, Attributes atts)
-            throws SAXException {
-
-            try {
-                Node previousTop = top;
-                if ((localName == null) || (localName.length() == 0)) {
-                    top = doc.createElement(qName);
-                } else {
-                    top = doc.createElementNS(namespaceURI, localName);
-                }
-                for (int i = 0; i < atts.getLength(); i++) {
-                    Attr attr = null;
-                    if ((atts.getLocalName(i) == null) ||
-                        (atts.getLocalName(i).length() == 0)) {
-                        attr = doc.createAttribute(atts.getQName(i));
-                        attr.setNodeValue(atts.getValue(i));
-                        ((Element)top).setAttributeNode(attr);
-                    } else {
-                        attr = doc.createAttributeNS(atts.getURI(i),
-                                                     atts.getLocalName(i));
-                        attr.setNodeValue(atts.getValue(i));
-                        ((Element)top).setAttributeNodeNS(attr);
-                    }
-                }
-                previousTop.appendChild(top);
-                depth++;
-            } catch (DOMException e) {
-                throw new SAXException(e.getMessage(), e);
-            }
-
-        }
-
-    }
-
-
-    // ----------------------------------------------------------- Constructors
-
-
-    /**
-     * Default constructor. Creates an instance of this rule that will create a
-     * DOM {@link org.w3c.dom.Element Element}.
-     */
-    public NodeCreateRule() throws ParserConfigurationException {
-
-        this(Node.ELEMENT_NODE);
-
-    }
-
-
-    /**
-     * Constructor. Creates an instance of this rule that will create a DOM
-     * {@link org.w3c.dom.Element Element}, but lets you specify the JAXP
-     * <code>DocumentBuilder</code> that should be used when constructing the
-     * node tree.
-     *
-     * @param documentBuilder the JAXP <code>DocumentBuilder</code> to use
-     */
-    public NodeCreateRule(DocumentBuilder documentBuilder) {
-
-        this(Node.ELEMENT_NODE, documentBuilder);
-
-    }
-
-
-    /**
-     * Constructor. Creates an instance of this rule that will create either a
-     * DOM {@link org.w3c.dom.Element Element} or a DOM
-     * {@link org.w3c.dom.DocumentFragment DocumentFragment}, depending on the
-     * value of the <code>nodeType</code> parameter.
-     *
-     * @param nodeType the type of node to create, which can be either
-     *   {@link org.w3c.dom.Node#ELEMENT_NODE Node.ELEMENT_NODE} or
-     *   {@link org.w3c.dom.Node#DOCUMENT_FRAGMENT_NODE Node.DOCUMENT_FRAGMENT_NODE}
-     * @throws IllegalArgumentException if the node type is not supported
-     */
-    public NodeCreateRule(int nodeType) throws ParserConfigurationException {
-
-        this(nodeType,
-             DocumentBuilderFactory.newInstance().newDocumentBuilder());
-
-    }
-
-
-    /**
-     * Constructor. Creates an instance of this rule that will create either a
-     * DOM {@link org.w3c.dom.Element Element} or a DOM
-     * {@link org.w3c.dom.DocumentFragment DocumentFragment}, depending on the
-     * value of the <code>nodeType</code> parameter. This constructor lets you
-     * specify the JAXP <code>DocumentBuilder</code> that should be used when
-     * constructing the node tree.
-     *
-     * @param nodeType the type of node to create, which can be either
-     *   {@link org.w3c.dom.Node#ELEMENT_NODE Node.ELEMENT_NODE} or
-     *   {@link org.w3c.dom.Node#DOCUMENT_FRAGMENT_NODE Node.DOCUMENT_FRAGMENT_NODE}
-     * @param documentBuilder the JAXP <code>DocumentBuilder</code> to use
-     * @throws IllegalArgumentException if the node type is not supported
-     */
-    public NodeCreateRule(int nodeType, DocumentBuilder documentBuilder) {
-
-        if (!((nodeType == Node.DOCUMENT_FRAGMENT_NODE) ||
-              (nodeType == Node.ELEMENT_NODE))) {
-            throw new IllegalArgumentException(
-                "Can only create nodes of type DocumentFragment and Element");
-        }
-        this.nodeType = nodeType;
-        this.documentBuilder = documentBuilder;
-
-    }
-
-
-    // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * The JAXP <code>DocumentBuilder</code> to use.
-     */
-    private DocumentBuilder documentBuilder = null;
-
-
-    /**
-     * The type of the node that should be created. Must be one of the
-     * constants defined in {@link org.w3c.dom.Node Node}, but currently only
-     * {@link org.w3c.dom.Node#ELEMENT_NODE Node.ELEMENT_NODE} and
-     * {@link org.w3c.dom.Node#DOCUMENT_FRAGMENT_NODE Node.DOCUMENT_FRAGMENT_NODE}
-     * are allowed values.
-     */
-    private int nodeType = Node.ELEMENT_NODE;
-
-
-    // ----------------------------------------------------------- Rule Methods
-
-
-    /**
-     * Implemented to replace the content handler currently in use by a
-     * NodeBuilder.
-     *
-     * @param namespaceURI the namespace URI of the matching element, or an
-     *   empty string if the parser is not namespace aware or the element has
-     *   no namespace
-     * @param name the local name if the parser is namespace aware, or just
-     *   the element name otherwise
-     * @param attributes The attribute list of this element
-     * @throws Exception indicates a JAXP configuration problem
-     */
-    @Override
-    public void begin(String namespaceURI, String name, Attributes attributes)
-        throws Exception {
-
-        XMLReader xmlReader = getDigester().getXMLReader();
-        Document doc = documentBuilder.newDocument();
-        NodeBuilder builder = null;
-        if (nodeType == Node.ELEMENT_NODE) {
-            Element element = null;
-            if (getDigester().getNamespaceAware()) {
-                element =
-                    doc.createElementNS(namespaceURI, name);
-                for (int i = 0; i < attributes.getLength(); i++) {
-                    element.setAttributeNS(attributes.getURI(i),
-                                           attributes.getLocalName(i),
-                                           attributes.getValue(i));
-                }
-            } else {
-                element = doc.createElement(name);
-                for (int i = 0; i < attributes.getLength(); i++) {
-                    element.setAttribute(attributes.getQName(i),
-                                         attributes.getValue(i));
-                }
-            }
-            builder = new NodeBuilder(doc, element);
-        } else {
-            builder = new NodeBuilder(doc, doc.createDocumentFragment());
-        }
-        xmlReader.setContentHandler(builder);
-
-    }
-
-
-    /**
-     * Pop the Node off the top of the stack.
-     *
-     * @param namespace the namespace URI of the matching element, or an
-     *   empty string if the parser is not namespace aware or the element has
-     *   no namespace
-     * @param name the local name if the parser is namespace aware, or just
-     *   the element name otherwise
-     */
-    @Override
-    public void end(String namespace, String name) throws Exception {
-
-        digester.pop();
-
-    }
-
-
-}

==================================================
WithDefaultsRulesWrapper.java
deleted file mode 100644
index d8d99334ce..0000000000
--- a/java/org/apache/tomcat/util/digester/ParserFeatureSetterFactory.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.tomcat.util.digester;
-
-import java.util.Properties;
-
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-
-import org.xml.sax.SAXException;
-import org.xml.sax.SAXNotRecognizedException;
-import org.xml.sax.SAXNotSupportedException;
-
-/**
- * Creates a <code>SAXParser</code> based on the underlying parser.
- * Allows logical properties depending on logical parser versions
- * to be set.
- *
- * @since 1.6
- */
-public class ParserFeatureSetterFactory{
-
-    /**
-     * <code>true</code> is Xerces is used.
-     */
-    private static boolean isXercesUsed;
-
-    static {
-        try{
-            // Use reflection to avoid a build dependency with Xerces.
-            Class.forName("org.apache.xerces.impl.Version");
-            isXercesUsed = true;
-        } catch (Exception ex){
-            isXercesUsed = false;
-        }
-    }
-
-    /**
-     * Create a new <code>SAXParser</code>
-     * @param properties (logical) properties to be set on parser
-     * @return a <code>SAXParser</code> configured based on the underlying
-     * parser implementation.
-     */
-    public static SAXParser newSAXParser(Properties properties)
-            throws ParserConfigurationException,
-                   SAXException,
-                   SAXNotRecognizedException,
-                   SAXNotSupportedException {
-
-        if (isXercesUsed){
-            return XercesParser.newSAXParser(properties);
-        } else {
-            return GenericParser.newSAXParser(properties);
-        }
-    }
-
-}
\ No newline at end of file

==================================================
XercesParser.java
deleted file mode 100644
index 2ae9016a6d..0000000000
--- a/java/org/apache/tomcat/util/digester/WithDefaultsRulesWrapper.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.tomcat.util.digester;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * <p><code>Rules</code> <em>Decorator</em> that returns default rules
- * when no matches are returned by the wrapped implementation.</p>
- *
- * <p>This allows default <code>Rule</code> instances to be added to any
- * existing <code>Rules</code> implementation. These default <code>Rule</code>
- * instances will be returned for any match for which the wrapped
- * implementation does not return any matches.</p>
- * <p> For example,
- * <pre>
- *   Rule alpha;
- *   ...
- *   WithDefaultsRulesWrapper rules = new WithDefaultsRulesWrapper(new BaseRules());
- *   rules.addDefault(alpha);
- *   ...
- *   digester.setRules(rules);
- *   ...
- * </pre>
- * when a pattern does not match any other rule, then rule alpha will be called.
- * </p>
- * <p><code>WithDefaultsRulesWrapper</code> follows the <em>Decorator</em> pattern.</p>
- *
- * @since 1.6
- */
-
-public class WithDefaultsRulesWrapper implements Rules {
-
-    // --------------------------------------------------------- Fields
-
-    /** The Rules implementation that this class wraps. */
-    private Rules wrappedRules;
-    /** Rules to be fired when the wrapped implementations returns none. */
-    private List<Rule> defaultRules = new ArrayList<>();
-    /** All rules (preserves order in which they were originally added) */
-    private List<Rule> allRules = new ArrayList<>();
-
-    // --------------------------------------------------------- Constructor
-
-    /**
-     * Base constructor.
-     *
-     * @param wrappedRules the wrapped <code>Rules</code> implementation, not null
-     * @throws IllegalArgumentException when <code>wrappedRules</code> is null
-     */
-    public WithDefaultsRulesWrapper(Rules wrappedRules) {
-        if (wrappedRules == null) {
-            throw new IllegalArgumentException("Wrapped rules must not be null");
-        }
-        this.wrappedRules = wrappedRules;
-    }
-
-    // --------------------------------------------------------- Properties
-
-    /** Gets digester using these Rules */
-    @Override
-    public Digester getDigester() {
-        return wrappedRules.getDigester();
-    }
-
-    /** Sets digester using these Rules */
-    @Override
-    public void setDigester(Digester digester) {
-        wrappedRules.setDigester(digester);
-        Iterator<Rule> it = defaultRules.iterator();
-        while (it.hasNext()) {
-            Rule rule = it.next();
-            rule.setDigester(digester);
-        }
-    }
-
-    /** Gets namespace to apply to Rule's added */
-    @Override
-    public String getNamespaceURI() {
-        return wrappedRules.getNamespaceURI();
-    }
-
-    /** Sets namespace to apply to Rule's added subsequently */
-    @Override
-    public void setNamespaceURI(String namespaceURI) {
-        wrappedRules.setNamespaceURI(namespaceURI);
-    }
-
-    /** Gets Rule's which will be fired when the wrapped implementation returns no matches */
-    public List<Rule> getDefaults() {
-        return defaultRules;
-    }
-
-    // --------------------------------------------------------- Public Methods
-
-    /**
-     * Return list of rules matching given pattern.
-     * If wrapped implementation returns any matches return those.
-     * Otherwise, return default matches.
-     */
-    @Override
-    public List<Rule> match(String namespaceURI, String pattern) {
-        List<Rule> matches = wrappedRules.match(namespaceURI, pattern);
-        if (matches ==  null || matches.isEmpty()) {
-            // a little bit of defensive programming
-            return new ArrayList<>(defaultRules);
-        }
-        // otherwise
-        return matches;
-    }
-
-    /** Adds a rule to be fired when wrapped implementation returns no matches */
-    public void addDefault(Rule rule) {
-        // set up rule
-        if (wrappedRules.getDigester() != null) {
-            rule.setDigester(wrappedRules.getDigester());
-        }
-
-        if (wrappedRules.getNamespaceURI() != null) {
-            rule.setNamespaceURI(wrappedRules.getNamespaceURI());
-        }
-
-        defaultRules.add(rule);
-        allRules.add(rule);
-    }
-
-    /** Gets all rules */
-    @Override
-    public List<Rule> rules() {
-        return allRules;
-    }
-
-    /** Clears all Rule's */
-    @Override
-    public void clear() {
-        wrappedRules.clear();
-        allRules.clear();
-        defaultRules.clear();
-    }
-
-    /**
-     * Adds a Rule to be fired on given pattern.
-     * Pattern matching is delegated to wrapped implementation.
-     */
-    @Override
-    public void add(String pattern, Rule rule) {
-        wrappedRules.add(pattern, rule);
-        allRules.add(rule);
-    }
-}

==================================================
