7518e971e45542a3c3717a25a93861d586f2f2dd
==================================================
Refactor connection preface handling into a separate class.
==================================================
Mark Thomas
==================================================
Tue May 12 20:16:58 2015 +0000
==================================================
AbstractHttp11Protocol.java
Refactor connection preface handling into a separate class.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1679047 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ConnectionPrefaceParser.java
index c43b29dc77..c37947dc32 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Protocol.java
@@ -37,6 +37,7 @@ import org.apache.coyote.UpgradeProtocol;
 import org.apache.coyote.http11.upgrade.InternalHttpUpgradeHandler;
 import org.apache.coyote.http11.upgrade.UpgradeProcessorExternal;
 import org.apache.coyote.http11.upgrade.UpgradeProcessorInternal;
+import org.apache.coyote.http2.Http2Protocol;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.SSLHostConfig;
 import org.apache.tomcat.util.net.SocketWrapperBase;
@@ -52,7 +53,7 @@ public abstract class AbstractHttp11Protocol<S> extends AbstractProtocol<S> {
         //       This is disabled by default otherwise it will break the
         //       APR/native connector with clients that support h2 with ALPN
         //       (because the Http2Protocol is only stubbed out)
-        //addUpgradeProtocol(new Http2Protocol());
+        addUpgradeProtocol(new Http2Protocol());
     }
 
 

==================================================
Http2UpgradeHandler.java
new file mode 100644
index 0000000000..795e1ef80f
--- /dev/null
+++ b/java/org/apache/coyote/http2/ConnectionPrefaceParser.java
@@ -0,0 +1,77 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.coyote.http2;
+
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+
+import org.apache.juli.logging.Log;
+import org.apache.juli.logging.LogFactory;
+import org.apache.tomcat.util.net.SocketWrapperBase;
+import org.apache.tomcat.util.res.StringManager;
+
+/**
+ * Parser for the initial part of the client connection preface received by the
+ * server.
+ */
+public class ConnectionPrefaceParser {
+
+    private static final Log log = LogFactory.getLog(ConnectionPrefaceParser.class);
+    private static final StringManager sm = StringManager.getManager(ConnectionPrefaceParser.class);
+
+    private static final byte[] EXPECTED =
+            "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".getBytes(StandardCharsets.ISO_8859_1);
+
+    private volatile byte[] data = new byte[EXPECTED.length];
+    private volatile int pos = 0;
+    private volatile boolean error = false;
+
+
+    public boolean parse(SocketWrapperBase<?> socketWrapper) {
+        int read = 0;
+        try {
+            read = socketWrapper.read(false, data, pos, EXPECTED.length - pos);
+        } catch (IOException ioe) {
+            log.error(sm.getString("connectionPrefaceParser.ioError"), ioe);
+            error = true;
+            return false;
+        }
+
+        if (read == -1) {
+            log.error(sm.getString("connectionPrefaceParser.eos", Integer.toString(pos)));
+            error = true;
+            return false;
+        }
+
+        for (int i = pos; i < (pos + read); i++) {
+            if (data[i] != EXPECTED[i]) {
+                log.error(sm.getString("connectionPrefaceParser.mismatch",
+                        new String(data, StandardCharsets.ISO_8859_1)));
+                error = true;
+                return false;
+            }
+        }
+
+        pos += read;
+        return pos == EXPECTED.length;
+    }
+
+
+    public boolean isError() {
+        return error;
+    }
+}

==================================================
