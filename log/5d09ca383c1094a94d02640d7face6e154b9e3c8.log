5d09ca383c1094a94d02640d7face6e154b9e3c8
==================================================
Some more plumbing to support multiple certificates per virtual host
==================================================
Mark Thomas
==================================================
Fri Jun 19 19:11:11 2015 +0000
==================================================
AbstractJsseEndpoint.java
Some more plumbing to support multiple certificates per virtual host

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1686483 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AprEndpoint.java
index 1d5640838e..b1501e0257 100644
--- a/java/org/apache/tomcat/util/net/AbstractJsseEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AbstractJsseEndpoint.java
@@ -74,17 +74,19 @@ public abstract class AbstractJsseEndpoint<S> extends AbstractEndpoint<S> {
             sslImplementation = SSLImplementation.getInstance(getSslImplementationName());
 
             for (SSLHostConfig sslHostConfig : sslHostConfigs.values()) {
-                SSLUtil sslUtil = sslImplementation.getSSLUtil(sslHostConfig);
-
-                SSLContext sslContext = sslUtil.createSSLContext();
-                sslContext.init(sslUtil.getKeyManagers(), sslUtil.getTrustManagers(), null);
-
-                SSLSessionContext sessionContext = sslContext.getServerSessionContext();
-                if (sessionContext != null) {
-                    sslUtil.configureSessionContext(sessionContext);
+                for (SSLHostConfigCertificate certificate : sslHostConfig.getCertificates(true)) {
+                    SSLUtil sslUtil = sslImplementation.getSSLUtil(sslHostConfig, certificate);
+
+                    SSLContext sslContext = sslUtil.createSSLContext();
+                    sslContext.init(sslUtil.getKeyManagers(), sslUtil.getTrustManagers(), null);
+
+                    SSLSessionContext sessionContext = sslContext.getServerSessionContext();
+                    if (sessionContext != null) {
+                        sslUtil.configureSessionContext(sessionContext);
+                    }
+                    SSLContextWrapper sslContextWrapper = new SSLContextWrapper(sslContext, sslUtil);
+                    sslHostConfig.setSslContext(sslContextWrapper);
                 }
-                SSLContextWrapper sslContextWrapper = new SSLContextWrapper(sslContext, sslUtil);
-                sslHostConfig.setSslContext(sslContextWrapper);
             }
         }
     }

==================================================
SSLHostConfig.java
index efd815ffcd..33902ac0c0 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -368,179 +368,181 @@ public class AprEndpoint extends AbstractEndpoint<Long> implements SNICallBack {
         if (isSSLEnabled()) {
             for (SSLHostConfig sslHostConfig : sslHostConfigs.values()) {
 
-                if (SSLHostConfig.adjustRelativePath(sslHostConfig.getCertificateFile()) == null) {
-                    // This is required
-                    throw new Exception(sm.getString("endpoint.apr.noSslCertFile"));
-                }
+                for (SSLHostConfigCertificate certificate : sslHostConfig.getCertificates(true)) {
+                    if (SSLHostConfig.adjustRelativePath(sslHostConfig.getCertificateFile()) == null) {
+                        // This is required
+                        throw new Exception(sm.getString("endpoint.apr.noSslCertFile"));
+                    }
 
-                // SSL protocol
-                int value = SSL.SSL_PROTOCOL_NONE;
-                if (sslHostConfig.getProtocols().size() == 0) {
-                    // Native fallback used if protocols=""
-                    value = SSL.SSL_PROTOCOL_ALL;
-                } else {
-                    for (String protocol : sslHostConfig.getProtocols()) {
-                        if (Constants.SSL_PROTO_SSLv2Hello.equalsIgnoreCase(protocol)) {
-                            // NO-OP. OpenSSL always supports SSLv2Hello
-                        } else if (Constants.SSL_PROTO_SSLv2.equalsIgnoreCase(protocol)) {
-                            value |= SSL.SSL_PROTOCOL_SSLV2;
-                        } else if (Constants.SSL_PROTO_SSLv3.equalsIgnoreCase(protocol)) {
-                            value |= SSL.SSL_PROTOCOL_SSLV3;
-                        } else if (Constants.SSL_PROTO_TLSv1.equalsIgnoreCase(protocol)) {
-                            value |= SSL.SSL_PROTOCOL_TLSV1;
-                        } else if (Constants.SSL_PROTO_TLSv1_1.equalsIgnoreCase(protocol)) {
-                            value |= SSL.SSL_PROTOCOL_TLSV1_1;
-                        } else if (Constants.SSL_PROTO_TLSv1_2.equalsIgnoreCase(protocol)) {
-                            value |= SSL.SSL_PROTOCOL_TLSV1_2;
-                        } else {
-                            // Protocol not recognized, fail to start as it is safer than
-                            // continuing with the default which might enable more than the
-                            // is required
-                            throw new Exception(sm.getString(
-                                    "endpoint.apr.invalidSslProtocol", protocol));
+                    // SSL protocol
+                    int value = SSL.SSL_PROTOCOL_NONE;
+                    if (sslHostConfig.getProtocols().size() == 0) {
+                        // Native fallback used if protocols=""
+                        value = SSL.SSL_PROTOCOL_ALL;
+                    } else {
+                        for (String protocol : sslHostConfig.getProtocols()) {
+                            if (Constants.SSL_PROTO_SSLv2Hello.equalsIgnoreCase(protocol)) {
+                                // NO-OP. OpenSSL always supports SSLv2Hello
+                            } else if (Constants.SSL_PROTO_SSLv2.equalsIgnoreCase(protocol)) {
+                                value |= SSL.SSL_PROTOCOL_SSLV2;
+                            } else if (Constants.SSL_PROTO_SSLv3.equalsIgnoreCase(protocol)) {
+                                value |= SSL.SSL_PROTOCOL_SSLV3;
+                            } else if (Constants.SSL_PROTO_TLSv1.equalsIgnoreCase(protocol)) {
+                                value |= SSL.SSL_PROTOCOL_TLSV1;
+                            } else if (Constants.SSL_PROTO_TLSv1_1.equalsIgnoreCase(protocol)) {
+                                value |= SSL.SSL_PROTOCOL_TLSV1_1;
+                            } else if (Constants.SSL_PROTO_TLSv1_2.equalsIgnoreCase(protocol)) {
+                                value |= SSL.SSL_PROTOCOL_TLSV1_2;
+                            } else {
+                                // Protocol not recognized, fail to start as it is safer than
+                                // continuing with the default which might enable more than the
+                                // is required
+                                throw new Exception(sm.getString(
+                                        "endpoint.apr.invalidSslProtocol", protocol));
+                            }
                         }
                     }
-                }
 
-                // Create SSL Context
-                long ctx = 0;
-                try {
-                    ctx = SSLContext.make(rootPool, value, SSL.SSL_MODE_SERVER);
-                } catch (Exception e) {
-                    // If the sslEngine is disabled on the AprLifecycleListener
-                    // there will be an Exception here but there is no way to check
-                    // the AprLifecycleListener settings from here
-                    throw new Exception(
-                            sm.getString("endpoint.apr.failSslContextMake"), e);
-                }
+                    // Create SSL Context
+                    long ctx = 0;
+                    try {
+                        ctx = SSLContext.make(rootPool, value, SSL.SSL_MODE_SERVER);
+                    } catch (Exception e) {
+                        // If the sslEngine is disabled on the AprLifecycleListener
+                        // there will be an Exception here but there is no way to check
+                        // the AprLifecycleListener settings from here
+                        throw new Exception(
+                                sm.getString("endpoint.apr.failSslContextMake"), e);
+                    }
 
-                boolean legacyRenegSupported = false;
-                try {
-                    legacyRenegSupported = SSL.hasOp(SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
-                    if (legacyRenegSupported)
-                        if (sslHostConfig.getInsecureRenegotiation()) {
-                            SSLContext.setOptions(ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
-                        } else {
-                            SSLContext.clearOptions(ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
-                        }
-                } catch (UnsatisfiedLinkError e) {
-                    // Ignore
-                }
-                if (!legacyRenegSupported) {
-                    // OpenSSL does not support unsafe legacy renegotiation.
-                    log.warn(sm.getString("endpoint.warn.noInsecureReneg",
-                                          SSL.versionString()));
-                }
+                    boolean legacyRenegSupported = false;
+                    try {
+                        legacyRenegSupported = SSL.hasOp(SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
+                        if (legacyRenegSupported)
+                            if (sslHostConfig.getInsecureRenegotiation()) {
+                                SSLContext.setOptions(ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
+                            } else {
+                                SSLContext.clearOptions(ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
+                            }
+                    } catch (UnsatisfiedLinkError e) {
+                        // Ignore
+                    }
+                    if (!legacyRenegSupported) {
+                        // OpenSSL does not support unsafe legacy renegotiation.
+                        log.warn(sm.getString("endpoint.warn.noInsecureReneg",
+                                              SSL.versionString()));
+                    }
 
-                // Use server's preference order for ciphers (rather than
-                // client's)
-                boolean orderCiphersSupported = false;
-                try {
-                    orderCiphersSupported = SSL.hasOp(SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
-                    if (orderCiphersSupported) {
-                        if (sslHostConfig.getHonorCipherOrder()) {
-                            SSLContext.setOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
-                        } else {
-                            SSLContext.clearOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
+                    // Use server's preference order for ciphers (rather than
+                    // client's)
+                    boolean orderCiphersSupported = false;
+                    try {
+                        orderCiphersSupported = SSL.hasOp(SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
+                        if (orderCiphersSupported) {
+                            if (sslHostConfig.getHonorCipherOrder()) {
+                                SSLContext.setOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
+                            } else {
+                                SSLContext.clearOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
+                            }
                         }
+                    } catch (UnsatisfiedLinkError e) {
+                        // Ignore
+                    }
+                    if (!orderCiphersSupported) {
+                        // OpenSSL does not support ciphers ordering.
+                        log.warn(sm.getString("endpoint.warn.noHonorCipherOrder",
+                                              SSL.versionString()));
                     }
-                } catch (UnsatisfiedLinkError e) {
-                    // Ignore
-                }
-                if (!orderCiphersSupported) {
-                    // OpenSSL does not support ciphers ordering.
-                    log.warn(sm.getString("endpoint.warn.noHonorCipherOrder",
-                                          SSL.versionString()));
-                }
 
-                // Disable compression if requested
-                boolean disableCompressionSupported = false;
-                try {
-                    disableCompressionSupported = SSL.hasOp(SSL.SSL_OP_NO_COMPRESSION);
-                    if (disableCompressionSupported) {
-                        if (sslHostConfig.getDisableCompression()) {
-                            SSLContext.setOptions(ctx, SSL.SSL_OP_NO_COMPRESSION);
-                        } else {
-                            SSLContext.clearOptions(ctx, SSL.SSL_OP_NO_COMPRESSION);
+                    // Disable compression if requested
+                    boolean disableCompressionSupported = false;
+                    try {
+                        disableCompressionSupported = SSL.hasOp(SSL.SSL_OP_NO_COMPRESSION);
+                        if (disableCompressionSupported) {
+                            if (sslHostConfig.getDisableCompression()) {
+                                SSLContext.setOptions(ctx, SSL.SSL_OP_NO_COMPRESSION);
+                            } else {
+                                SSLContext.clearOptions(ctx, SSL.SSL_OP_NO_COMPRESSION);
+                            }
                         }
+                    } catch (UnsatisfiedLinkError e) {
+                        // Ignore
+                    }
+                    if (!disableCompressionSupported) {
+                        // OpenSSL does not support ciphers ordering.
+                        log.warn(sm.getString("endpoint.warn.noDisableCompression",
+                                              SSL.versionString()));
                     }
-                } catch (UnsatisfiedLinkError e) {
-                    // Ignore
-                }
-                if (!disableCompressionSupported) {
-                    // OpenSSL does not support ciphers ordering.
-                    log.warn(sm.getString("endpoint.warn.noDisableCompression",
-                                          SSL.versionString()));
-                }
 
-                // Disable TLS Session Tickets (RFC4507) to protect perfect forward secrecy
-                boolean disableSessionTicketsSupported = false;
-                try {
-                    disableSessionTicketsSupported = SSL.hasOp(SSL.SSL_OP_NO_TICKET);
-                    if (disableSessionTicketsSupported) {
-                        if (sslHostConfig.getDisableSessionTickets()) {
-                            SSLContext.setOptions(ctx, SSL.SSL_OP_NO_TICKET);
-                        } else {
-                            SSLContext.clearOptions(ctx, SSL.SSL_OP_NO_TICKET);
+                    // Disable TLS Session Tickets (RFC4507) to protect perfect forward secrecy
+                    boolean disableSessionTicketsSupported = false;
+                    try {
+                        disableSessionTicketsSupported = SSL.hasOp(SSL.SSL_OP_NO_TICKET);
+                        if (disableSessionTicketsSupported) {
+                            if (sslHostConfig.getDisableSessionTickets()) {
+                                SSLContext.setOptions(ctx, SSL.SSL_OP_NO_TICKET);
+                            } else {
+                                SSLContext.clearOptions(ctx, SSL.SSL_OP_NO_TICKET);
+                            }
                         }
+                    } catch (UnsatisfiedLinkError e) {
+                        // Ignore
+                    }
+                    if (!disableSessionTicketsSupported) {
+                        // OpenSSL is too old to support TLS Session Tickets.
+                        log.warn(sm.getString("endpoint.warn.noDisableSessionTickets",
+                                              SSL.versionString()));
                     }
-                } catch (UnsatisfiedLinkError e) {
-                    // Ignore
-                }
-                if (!disableSessionTicketsSupported) {
-                    // OpenSSL is too old to support TLS Session Tickets.
-                    log.warn(sm.getString("endpoint.warn.noDisableSessionTickets",
-                                          SSL.versionString()));
-                }
 
-                // List the ciphers that the client is permitted to negotiate
-                SSLContext.setCipherSuite(ctx, sslHostConfig.getCiphers());
-                // Load Server key and certificate
-                SSLContext.setCertificate(ctx,
-                        SSLHostConfig.adjustRelativePath(sslHostConfig.getCertificateFile()),
-                        SSLHostConfig.adjustRelativePath(sslHostConfig.getCertificateKeyFile()),
-                        sslHostConfig.getCertificateKeyPassword(), SSL.SSL_AIDX_RSA);
-                // Support Client Certificates
-                SSLContext.setCACertificate(ctx,
-                        SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificateFile()),
-                        SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificatePath()));
-                // Set revocation
-                SSLContext.setCARevocation(ctx,
-                        SSLHostConfig.adjustRelativePath(
-                                sslHostConfig.getCertificateRevocationListFile()),
-                        SSLHostConfig.adjustRelativePath(
-                                sslHostConfig.getCertificateRevocationListPath()));
-                // Client certificate verification
-                switch (sslHostConfig.getCertificateVerification()) {
-                case NONE:
-                    value = SSL.SSL_CVERIFY_NONE;
-                    break;
-                case OPTIONAL:
-                    value = SSL.SSL_CVERIFY_OPTIONAL;
-                    break;
-                case OPTIONAL_NO_CA:
-                    value = SSL.SSL_CVERIFY_OPTIONAL_NO_CA;
-                    break;
-                case REQUIRED:
-                    value = SSL.SSL_CVERIFY_REQUIRE;
-                    break;
-                }
-                SSLContext.setVerify(ctx, value, sslHostConfig.getCertificateVerificationDepth());
-                // For now, sendfile is not supported with SSL
-                if (getUseSendfile()) {
-                    setUseSendfileInternal(false);
-                    if (useSendFileSet) {
-                        log.warn(sm.getString("endpoint.apr.noSendfileWithSSL"));
+                    // List the ciphers that the client is permitted to negotiate
+                    SSLContext.setCipherSuite(ctx, sslHostConfig.getCiphers());
+                    // Load Server key and certificate
+                    SSLContext.setCertificate(ctx,
+                            SSLHostConfig.adjustRelativePath(sslHostConfig.getCertificateFile()),
+                            SSLHostConfig.adjustRelativePath(sslHostConfig.getCertificateKeyFile()),
+                            certificate.getCertificateKeyPassword(), SSL.SSL_AIDX_RSA);
+                    // Support Client Certificates
+                    SSLContext.setCACertificate(ctx,
+                            SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificateFile()),
+                            SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificatePath()));
+                    // Set revocation
+                    SSLContext.setCARevocation(ctx,
+                            SSLHostConfig.adjustRelativePath(
+                                    sslHostConfig.getCertificateRevocationListFile()),
+                            SSLHostConfig.adjustRelativePath(
+                                    sslHostConfig.getCertificateRevocationListPath()));
+                    // Client certificate verification
+                    switch (sslHostConfig.getCertificateVerification()) {
+                    case NONE:
+                        value = SSL.SSL_CVERIFY_NONE;
+                        break;
+                    case OPTIONAL:
+                        value = SSL.SSL_CVERIFY_OPTIONAL;
+                        break;
+                    case OPTIONAL_NO_CA:
+                        value = SSL.SSL_CVERIFY_OPTIONAL_NO_CA;
+                        break;
+                    case REQUIRED:
+                        value = SSL.SSL_CVERIFY_REQUIRE;
+                        break;
+                    }
+                    SSLContext.setVerify(ctx, value, sslHostConfig.getCertificateVerificationDepth());
+                    // For now, sendfile is not supported with SSL
+                    if (getUseSendfile()) {
+                        setUseSendfileInternal(false);
+                        if (useSendFileSet) {
+                            log.warn(sm.getString("endpoint.apr.noSendfileWithSSL"));
+                        }
                     }
-                }
 
-                if (negotiableProtocols.size() > 0) {
-                    byte[] protocols = buildAlpnConfig(negotiableProtocols);
-                    if (SSLContext.setALPN(ctx, protocols, protocols.length) != 0) {
-                        log.warn(sm.getString("endpoint.alpn.fail", negotiableProtocols));
+                    if (negotiableProtocols.size() > 0) {
+                        byte[] protocols = buildAlpnConfig(negotiableProtocols);
+                        if (SSLContext.setALPN(ctx, protocols, protocols.length) != 0) {
+                            log.warn(sm.getString("endpoint.alpn.fail", negotiableProtocols));
+                        }
                     }
+                    sslHostConfig.setSslContext(Long.valueOf(ctx));
                 }
-                sslHostConfig.setSslContext(Long.valueOf(ctx));
             }
             SSLHostConfig defaultSSLHostConfig = sslHostConfigs.get(getDefaultSSLHostConfigName());
             Long defaultSSLContext = (Long) defaultSSLHostConfig.getSslContext();

==================================================
SSLHostConfigCertificate.java
index 23faab2426..3933be83c5 100644
--- a/java/org/apache/tomcat/util/net/SSLHostConfig.java
+++ b/java/org/apache/tomcat/util/net/SSLHostConfig.java
@@ -63,8 +63,11 @@ public class SSLHostConfig {
 
     // Configuration properties
 
+    // Nested
+    private SSLHostConfigCertificate defaultCertificate = null;
+    private Set<SSLHostConfigCertificate> certificates = new HashSet<>(4);
+
     // Common
-    private String certificateKeyPassword = null;
     private String certificateRevocationListFile;
     private CertificateVerification certificateVerification = CertificateVerification.NONE;
     private int certificateVerificationDepth = 10;
@@ -146,15 +149,56 @@ public class SSLHostConfig {
     }
 
 
-    // ----------------------------------------- Common configuration properties
+    // ------------------------------------------- Nested configuration elements
 
-    public void setCertificateKeyPassword(String certificateKeyPassword) {
-        this.certificateKeyPassword = certificateKeyPassword;
+    private void registerDefaultCertificate() {
+        if (defaultCertificate == null) {
+            defaultCertificate =
+                    new SSLHostConfigCertificate(SSLHostConfigCertificate.Type.UNDEFINED);
+            certificates.add(defaultCertificate);
+        }
+    }
+
+
+    public void addCertificate(SSLHostConfigCertificate certificate) {
+        // Need to make sure that if there is more than one certificate, none of
+        // them have a type of undefined.
+        if (certificates.size() == 0) {
+            certificates.add(certificate);
+            return;
+        }
+
+        if (certificates.size() == 1 &&
+                certificates.iterator().next().getType() == SSLHostConfigCertificate.Type.UNDEFINED ||
+                        certificate.getType() == SSLHostConfigCertificate.Type.UNDEFINED) {
+            // Invalid config
+        }
+
+        certificates.add(certificate);
     }
 
 
-    public String getCertificateKeyPassword() {
-        return certificateKeyPassword;
+    public Set<SSLHostConfigCertificate> getCertificates() {
+        return getCertificates(false);
+    }
+
+
+    public Set<SSLHostConfigCertificate> getCertificates(boolean createDefaultIfEmpty) {
+        if (certificates.size() == 0 && createDefaultIfEmpty) {
+            registerDefaultCertificate();
+        }
+        return certificates;
+    }
+
+
+    // ----------------------------------------- Common configuration properties
+
+    // TODO: All of these SSL setters can be removed once it is no longer
+    // necessary to support the old configuration attributes (Tomcat 10?).
+
+    public void setCertificateKeyPassword(String certificateKeyPassword) {
+        registerDefaultCertificate();
+        defaultCertificate.setCertificateKeyPassword(certificateKeyPassword);
     }
 
 

==================================================
SSLImplementation.java
new file mode 100644
index 0000000000..c0edca3486
--- /dev/null
+++ b/java/org/apache/tomcat/util/net/SSLHostConfigCertificate.java
@@ -0,0 +1,56 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.util.net;
+
+
+public class SSLHostConfigCertificate {
+
+    public static final Type DEFAULT_TYPE = Type.UNDEFINED;
+
+    // Common
+    private final Type type;
+    private String certificateKeyPassword = null;
+
+
+    public SSLHostConfigCertificate(Type type) {
+        this.type = type;
+    }
+
+
+    public Type getType() {
+        return type;
+    }
+
+
+    public String getCertificateKeyPassword() {
+        return certificateKeyPassword;
+    }
+
+
+    public void setCertificateKeyPassword(String certificateKeyPassword) {
+        this.certificateKeyPassword = certificateKeyPassword;
+    }
+
+
+    public static enum Type {
+        UNDEFINED,
+        RSA,
+        DSA,
+        EC,
+        DH
+    }
+}

==================================================
JSSEImplementation.java
index 8a5057cf0a..c24535981a 100644
--- a/java/org/apache/tomcat/util/net/SSLImplementation.java
+++ b/java/org/apache/tomcat/util/net/SSLImplementation.java
@@ -71,5 +71,6 @@ public abstract class SSLImplementation {
 
     public abstract SSLSupport getSSLSupport(SSLSession session);
 
-    public abstract SSLUtil getSSLUtil(SSLHostConfig sslHostConfig);
+    public abstract SSLUtil getSSLUtil(SSLHostConfig sslHostConfig,
+            SSLHostConfigCertificate certificate);
 }

==================================================
JSSESocketFactory.java
index 73b1db7388..0d6d152c3f 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSEImplementation.java
@@ -19,6 +19,7 @@ package org.apache.tomcat.util.net.jsse;
 import javax.net.ssl.SSLSession;
 
 import org.apache.tomcat.util.net.SSLHostConfig;
+import org.apache.tomcat.util.net.SSLHostConfigCertificate;
 import org.apache.tomcat.util.net.SSLImplementation;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.SSLUtil;
@@ -50,7 +51,7 @@ public class JSSEImplementation extends SSLImplementation {
     }
 
     @Override
-    public SSLUtil getSSLUtil(SSLHostConfig sslHostConfig) {
-        return new JSSESocketFactory(sslHostConfig);
+    public SSLUtil getSSLUtil(SSLHostConfig sslHostConfig, SSLHostConfigCertificate certificate) {
+        return new JSSESocketFactory(sslHostConfig, certificate);
     }
 }

==================================================
OpenSSLContext.java
index bedd667b5e..0281667547 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSESocketFactory.java
@@ -56,6 +56,7 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.net.SSLContext;
 import org.apache.tomcat.util.net.SSLHostConfig;
+import org.apache.tomcat.util.net.SSLHostConfigCertificate;
 import org.apache.tomcat.util.net.SSLUtil;
 import org.apache.tomcat.util.net.jsse.openssl.OpenSSLCipherConfigurationParser;
 import org.apache.tomcat.util.res.StringManager;
@@ -78,12 +79,14 @@ public class JSSESocketFactory implements SSLUtil {
     private static final StringManager sm = StringManager.getManager(JSSESocketFactory.class);
 
     private final SSLHostConfig sslHostConfig;
+    private final SSLHostConfigCertificate certificate;
 
     private final String[] defaultServerProtocols;
 
 
-    public JSSESocketFactory (SSLHostConfig sslHostConfig) {
+    public JSSESocketFactory (SSLHostConfig sslHostConfig, SSLHostConfigCertificate certificate) {
         this.sslHostConfig = sslHostConfig;
+        this.certificate = certificate;
 
         SSLContext context;
         try {
@@ -266,7 +269,7 @@ public class JSSESocketFactory implements SSLUtil {
         String keystorePass = sslHostConfig.getCertificateKeystorePassword();
         String keyAlias = sslHostConfig.getCertificateKeyAlias();
         String algorithm = sslHostConfig.getKeyManagerAlgorithm();
-        String keyPass = sslHostConfig.getCertificateKeyPassword();
+        String keyPass = certificate.getCertificateKeyPassword();
         // This has to be here as it can't be moved to SSLHostConfig since the
         // defaults vary between JSSE and OpenSSL.
         if (keyPass == null) {

==================================================
OpenSSLImplementation.java
index 602e620d37..afb911a45b 100644
--- a/java/org/apache/tomcat/util/net/openssl/OpenSSLContext.java
+++ b/java/org/apache/tomcat/util/net/openssl/OpenSSLContext.java
@@ -55,6 +55,7 @@ import org.apache.tomcat.jni.SSLContext;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.Constants;
 import org.apache.tomcat.util.net.SSLHostConfig;
+import org.apache.tomcat.util.net.SSLHostConfigCertificate;
 import org.apache.tomcat.util.net.jsse.openssl.OpenSSLCipherConfigurationParser;
 import org.apache.tomcat.util.res.StringManager;
 
@@ -69,6 +70,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
     private static final String defaultProtocol = "TLS";
 
     private final SSLHostConfig sslHostConfig;
+    private final SSLHostConfigCertificate certificate;
     private OpenSSLServerSessionContext sessionContext;
 
     private List<String> ciphers = new ArrayList<>();
@@ -105,8 +107,10 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
         }
     }
 
-    public OpenSSLContext(SSLHostConfig sslHostConfig) throws SSLException {
+    public OpenSSLContext(SSLHostConfig sslHostConfig, SSLHostConfigCertificate certificate)
+            throws SSLException {
         this.sslHostConfig = sslHostConfig;
+        this.certificate = certificate;
         aprPool = Pool.create(0);
         boolean success = false;
         try {
@@ -305,7 +309,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
             SSLContext.setCertificate(ctx,
                     SSLHostConfig.adjustRelativePath(sslHostConfig.getCertificateFile()),
                     SSLHostConfig.adjustRelativePath(sslHostConfig.getCertificateKeyFile()),
-                    sslHostConfig.getCertificateKeyPassword(), SSL.SSL_AIDX_RSA);
+                    certificate.getCertificateKeyPassword(), SSL.SSL_AIDX_RSA);
             // Support Client Certificates
             SSLContext.setCACertificate(ctx,
                     SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificateFile()),

==================================================
OpenSSLUtil.java
index a9a099fd03..d1472019b1 100644
--- a/java/org/apache/tomcat/util/net/openssl/OpenSSLImplementation.java
+++ b/java/org/apache/tomcat/util/net/openssl/OpenSSLImplementation.java
@@ -19,6 +19,7 @@ package org.apache.tomcat.util.net.openssl;
 import javax.net.ssl.SSLSession;
 
 import org.apache.tomcat.util.net.SSLHostConfig;
+import org.apache.tomcat.util.net.SSLHostConfigCertificate;
 import org.apache.tomcat.util.net.SSLImplementation;
 import org.apache.tomcat.util.net.SSLSupport;
 import org.apache.tomcat.util.net.SSLUtil;
@@ -39,8 +40,8 @@ public class OpenSSLImplementation extends SSLImplementation {
     }
 
     @Override
-    public SSLUtil getSSLUtil(SSLHostConfig sslHostConfig) {
-        return new OpenSSLUtil(sslHostConfig);
+    public SSLUtil getSSLUtil(SSLHostConfig sslHostConfig, SSLHostConfigCertificate certificate) {
+        return new OpenSSLUtil(sslHostConfig, certificate);
     }
 
 }

==================================================
TesterBug50640SslImpl.java
index b1aaa1accb..c95eb47b76 100644
--- a/java/org/apache/tomcat/util/net/openssl/OpenSSLUtil.java
+++ b/java/org/apache/tomcat/util/net/openssl/OpenSSLUtil.java
@@ -24,22 +24,25 @@ import javax.net.ssl.TrustManager;
 
 import org.apache.tomcat.util.net.SSLContext;
 import org.apache.tomcat.util.net.SSLHostConfig;
+import org.apache.tomcat.util.net.SSLHostConfigCertificate;
 import org.apache.tomcat.util.net.SSLUtil;
 
 public class OpenSSLUtil implements SSLUtil {
 
     private final SSLHostConfig sslHostConfig;
+    private final SSLHostConfigCertificate certificate;
 
     private String[] enabledProtocols = null;
     private String[] enabledCiphers = null;
 
-    public OpenSSLUtil(SSLHostConfig sslHostConfig) {
+    public OpenSSLUtil(SSLHostConfig sslHostConfig, SSLHostConfigCertificate certificate) {
         this.sslHostConfig = sslHostConfig;
+        this.certificate = certificate;
     }
 
     @Override
     public SSLContext createSSLContext() throws Exception {
-        return new OpenSSLContext(sslHostConfig);
+        return new OpenSSLContext(sslHostConfig, certificate);
     }
 
     @Override

==================================================
