9de5b036c094f0378d06bdec7ae96db75ae3a06a
==================================================
Session manager performance
==================================================
Mark Emlyn
==================================================
Wed Nov 17 12:59:06 2010 +0000
==================================================
BackupManager.java
Session manager performance
Focused on Windows.
Use a queue of Random's to generate session ID to remove sync bottleneck on random.nextBytes(bytes)
Timings suggest some bottlenecks still present in default Windows code path

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1036019 13f79535-47bb-0310-9956-ffa450edef68



==================================================
DeltaManager.java
index 5d844cbcdc..179f2ff526 100644
--- a/java/org/apache/catalina/ha/session/BackupManager.java
+++ b/java/org/apache/catalina/ha/session/BackupManager.java
@@ -203,7 +203,7 @@ public class BackupManager extends ClusterManagerBase
         }
 
         cluster.removeManager(this);
-        this.random = null;
+        this.randoms.clear();
     }
 
     @Override

==================================================
ManagerBase.java
index 4a2b23e233..5e98862a7a 100644
--- a/java/org/apache/catalina/session/LocalStrings_ja.properties
+++ b/java/org/apache/catalina/session/LocalStrings_ja.properties
@@ -27,12 +27,10 @@ JDBCStore.checkConnectionDBClosed=\u30c7\u30fc\u30bf\u30d9\u30fc\u30b9\u63a5\u7d
 JDBCStore.checkConnectionDBReOpenFail=\u30c7\u30fc\u30bf\u30d9\u30fc\u30b9\u306e\u518d\u30aa\u30fc\u30d7\u30f3\u304c\u5931\u6557\u3057\u307e\u3057\u305f\u3002\u30c7\u30fc\u30bf\u30d9\u30fc\u30b9\u304c\u30c0\u30a6\u30f3\u3057\u3066\u3044\u308b\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002
 JDBCStore.checkConnectionSQLException=SQL\u4f8b\u5916\u304c\u767a\u751f\u3057\u307e\u3057\u305f {0}
 JDBCStore.checkConnectionClassNotFoundException=JDBC\u30c9\u30e9\u30a4\u30d0\u30af\u30e9\u30b9\u304c\u898b\u3064\u304b\u308a\u307e\u305b\u3093 {0}
-managerBase.complete=\u4e71\u6570\u767a\u751f\u5668\u306e\u30b7\u30fc\u30c9\u306e\u751f\u6210\u304c\u5b8c\u4e86\u3057\u307e\u3057\u305f
 managerBase.createSession.ise=createSession: \u30a2\u30af\u30c6\u30a3\u30d6\u30bb\u30c3\u30b7\u30e7\u30f3\u304c\u591a\u3059\u304e\u307e\u3059
 managerBase.getting=\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0 {0} \u306e\u30e1\u30c3\u30bb\u30fc\u30b8\u30c0\u30a4\u30b8\u30a7\u30b9\u30c8\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u3092\u53d6\u5f97\u3057\u307e\u3059
 managerBase.gotten=\u30e1\u30c3\u30bb\u30fc\u30b8\u30c0\u30a4\u30b8\u30a7\u30b9\u30c8\u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u306e\u53d6\u5f97\u3092\u5b8c\u4e86\u3057\u307e\u3057\u305f
 managerBase.random=\u30af\u30e9\u30b9 {0} \u306e\u4e71\u6570\u767a\u751f\u5668\u306e\u521d\u671f\u5316\u306e\u4f8b\u5916\u3067\u3059
-managerBase.seeding=\u4e71\u6570\u767a\u751f\u5668\u30af\u30e9\u30b9 {0} \u306e\u30b7\u30fc\u30c9\u3092\u751f\u6210\u3057\u3066\u3044\u307e\u3059
 managerBase.sessionTimeout=\u7121\u52b9\u306a\u30bb\u30c3\u30b7\u30e7\u30f3\u30bf\u30a4\u30e0\u30a2\u30a6\u30c8\u8a2d\u5b9a\u3067\u3059 {0}
 serverSession.value.iae=null\u5024\u3067\u3059
 standardManager.expireException=processsExpire: \u30bb\u30c3\u30b7\u30e7\u30f3\u306e\u7d42\u4e86\u51e6\u7406\u4e2d\u306e\u4f8b\u5916\u3067\u3059

==================================================
PersistentManagerBase.java
index f85d618ee2..a36b8fb771 100644
--- a/java/org/apache/catalina/session/ManagerBase.java
+++ b/java/org/apache/catalina/session/ManagerBase.java
@@ -22,6 +22,8 @@ package org.apache.catalina.session;
 import java.beans.PropertyChangeEvent;
 import java.beans.PropertyChangeListener;
 import java.beans.PropertyChangeSupport;
+import java.io.ByteArrayInputStream;
+import java.io.DataInputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -31,6 +33,7 @@ import java.security.AccessController;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.security.PrivilegedAction;
+import java.security.SecureRandom;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.HashMap;
@@ -99,8 +102,11 @@ public abstract class ManagerBase extends LifecycleMBeanBase
 
 
     /**
-     * Return the MessageDigest implementation to be used when
-     * creating session identifiers.
+     * Queue of MessageDigest objects to be used when creating session
+     * identifiers. If the queue is empty when a MessageDigest is required, a
+     * new MessageDigest object is created. This is designed this way since
+     * MessageDigest objects are not thread-safe and sync'ing on a single object
+     * is slow(er).
      */
     protected Queue<MessageDigest> digests =
         new ConcurrentLinkedQueue<MessageDigest>();
@@ -147,14 +153,23 @@ public abstract class ManagerBase extends LifecycleMBeanBase
 
 
     /**
-     * A random number generator to use when generating session identifiers.
+     * Queue of random number generator objects to be used when creating session
+     * identifiers. If the queue is empty when a random number generator is
+     * required, a new random number generator object is created. This is
+     * designed this way since random number generator use a sync to make them
+     * thread-safe and the sync makes using a a single object slow(er).
      */
-    protected volatile Random random = null;
+    protected Queue<Random> randoms = new ConcurrentLinkedQueue<Random>();
 
+    /**
+     * Random number generator used to see @{link {@link #randoms}.
+     */
+    protected SecureRandom randomSeed = null;
 
     /**
      * The Java class name of the random number generator class to be used
-     * when generating session identifiers.
+     * when generating session identifiers. The random number generator(s) will
+     * always be seeded from a SecureRandom instance.
      */
     protected String randomClass = "java.security.SecureRandom";
 
@@ -597,45 +612,78 @@ public abstract class ManagerBase extends LifecycleMBeanBase
     }
     
     /**
-     * Return the random number generator instance we should use for
-     * generating session identifiers.  If there is no such generator
-     * currently defined, construct and seed a new one.
+     * Create a new random number generator instance we should use for
+     * generating session identifiers.
      */
-    public Random getRandom() {
-        if (this.random == null) {
-            synchronized (this) {
-                if (this.random == null) {
-                    // Calculate the new random number generator seed
-                    long seed = System.currentTimeMillis();
-                    long t1 = seed;
-                    char entropy[] = getEntropy().toCharArray();
-                    for (int i = 0; i < entropy.length; i++) {
-                        long update = ((byte) entropy[i]) << ((i % 8) * 8);
-                        seed ^= update;
-                    }
-                    try {
-                        // Construct and seed a new random number generator
-                        Class<?> clazz = Class.forName(randomClass);
-                        this.random = (Random) clazz.newInstance();
-                        this.random.setSeed(seed);
-                    } catch (Exception e) {
-                        // Fall back to the simple case
-                        log.error(sm.getString("managerBase.random",
-                                randomClass), e);
-                        this.random = new java.util.Random();
-                        this.random.setSeed(seed);
-                    }
-                    if(log.isDebugEnabled()) {
-                        long t2=System.currentTimeMillis();
-                        if( (t2-t1) > 100 )
-                            log.debug(sm.getString("managerBase.seeding",
-                                    randomClass) + " " + (t2-t1));
-                    }
-                }
+    protected Random createRandom() {
+        if (randomSeed == null) {
+            createRandomSeed();
+        }
+        
+        Random result = null;
+        
+        long t1 = System.currentTimeMillis();
+        try {
+            // Construct and seed a new random number generator
+            Class<?> clazz = Class.forName(randomClass);
+            result = (Random) clazz.newInstance();
+        } catch (Exception e) {
+            // Fall back to the simple case
+            log.error(sm.getString("managerBase.random",
+                    randomClass), e);
+            result = new java.util.Random();
+        }
+        byte[] seedBytes = randomSeed.generateSeed(64);
+        ByteArrayInputStream bais = new ByteArrayInputStream(seedBytes);
+        DataInputStream dis = new DataInputStream(bais);
+        for (int i = 0; i < 8; i++) {
+            try {
+                result.setSeed(dis.readLong());
+            } catch (IOException e) {
+                // Should never happen
+                log.error(sm.getString("managerBase.seedFailed",
+                        result.getClass().getName()), e);
             }
         }
         
-        return this.random;
+        if(log.isDebugEnabled()) {
+            long t2=System.currentTimeMillis();
+            if( (t2-t1) > 100 )
+                log.debug(sm.getString("managerBase.createRandom",
+                        Long.valueOf(t2-t1)));
+        }
+        return result;
+    }
+
+
+    /**
+     * Create the random number generator that will be used to seed the random
+     * number generators that will create session IDs. 
+     */
+    protected synchronized void createRandomSeed() {
+        if (randomSeed != null) {
+            return;
+        }
+
+        long seed = System.currentTimeMillis();
+        long t1 = seed;
+        char entropy[] = getEntropy().toCharArray();
+        for (int i = 0; i < entropy.length; i++) {
+            long update = ((byte) entropy[i]) << ((i % 8) * 8);
+            seed ^= update;
+        }
+
+        // Construct and seed a new random number generator
+        SecureRandom result = new SecureRandom();
+        result.setSeed(seed);
+
+        if(log.isDebugEnabled()) {
+            long t2=System.currentTimeMillis();
+            if( (t2-t1) > 100 )
+                log.debug(sm.getString("managerBase.createRandomSeed",
+                        Long.valueOf(t2-t1)));
+        }
+        randomSeed = result;
     }
 
 
@@ -983,7 +1031,12 @@ public abstract class ManagerBase extends LifecycleMBeanBase
             devRandomSourceIsValid = false;
             closeRandomFile();
         }
-        getRandom().nextBytes(bytes);
+        Random random = randoms.poll();
+        if (random == null) {
+            random = createRandom();
+        }
+        random.nextBytes(bytes);
+        randoms.add(random);
     }
 
 

==================================================
StandardManager.java
index b288bc204b..d15b081e5e 100644
--- a/java/org/apache/catalina/session/PersistentManagerBase.java
+++ b/java/org/apache/catalina/session/PersistentManagerBase.java
@@ -870,7 +870,7 @@ public abstract class PersistentManagerBase extends ManagerBase {
             ((Lifecycle)getStore()).stop();
 
         // Require a new random number generator if we are restarted
-        this.random = null;
+        this.randoms.clear();
     }
 
 

==================================================
Benchmarks.java
index 204863983b..356526b1ee 100644
--- a/java/org/apache/catalina/session/StandardManager.java
+++ b/java/org/apache/catalina/session/StandardManager.java
@@ -518,7 +518,7 @@ public class StandardManager extends ManagerBase {
         }
 
         // Require a new random number generator if we are restarted
-        this.random = null;
+        this.randoms.clear();
     }
 
 

==================================================
