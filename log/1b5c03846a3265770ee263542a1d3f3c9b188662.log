1b5c03846a3265770ee263542a1d3f3c9b188662
==================================================
Refactor acceptor pause and shutdown to remove need for 'random' waits in
==================================================
Mark Emlyn
==================================================
Thu Nov 17 16:40:02 2011 +0000
==================================================
AbstractEndpoint.java
Refactor acceptor pause and shutdown to remove need for 'random' waits in
the shutdown code.
Removes the need for the fastShutdown attribute

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1203253 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AprEndpoint.java
index a90a29faf4..308202d2af 100644
--- a/java/org/apache/tomcat/util/net/AbstractEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AbstractEndpoint.java
@@ -30,6 +30,7 @@ import javax.net.ssl.KeyManagerFactory;
 
 import org.apache.juli.logging.Log;
 import org.apache.tomcat.util.IntrospectionUtils;
+import org.apache.tomcat.util.net.AbstractEndpoint.Acceptor.AcceptorState;
 import org.apache.tomcat.util.res.StringManager;
 import org.apache.tomcat.util.threads.LimitLatch;
 import org.apache.tomcat.util.threads.ResizableExecutor;
@@ -74,6 +75,25 @@ public abstract class AbstractEndpoint {
         UNBOUND, BOUND_ON_INIT, BOUND_ON_START
     }
 
+    public abstract static class Acceptor implements Runnable {
+        public enum AcceptorState {
+            NEW, RUNNING, PAUSED, ENDED
+        }
+
+        protected volatile AcceptorState state = AcceptorState.NEW;
+        public final AcceptorState getState() {
+            return state;
+        }
+
+        private String threadName;
+        protected final void setThreadName(final String threadName) {
+            this.threadName = threadName;
+        }
+        protected final String getThreadName() {
+            return threadName;
+        }
+    }
+
     private static final int INITIAL_ERROR_DELAY = 50;
     private static final int MAX_ERROR_DELAY = 1600;
 
@@ -109,25 +129,33 @@ public abstract class AbstractEndpoint {
         return socketProperties;
     }
 
+    /**
+     * Threads used to accept new connections and pass them to worker threads.
+     */
+    protected Acceptor[] acceptors;
+
 
     // ----------------------------------------------------------------- Properties
 
     /**
-     * A flag that can be used to speed up Tomcat shutdown by testing
-     * environments where we control external connections to Tomcat. Set it to
-     * {@code true} if it is known that there are no active or pending
-     * connections and all requests have already been processed. The default
-     * value is {@code false}.
+     * Acceptor thread count.
      */
-    private boolean fastShutdown = false;
-
-    public void setFastShutdown(boolean fastShutdown) {
-        this.fastShutdown = fastShutdown;
+    protected int acceptorThreadCount = 0;
+    public void setAcceptorThreadCount(int acceptorThreadCount) {
+        this.acceptorThreadCount = acceptorThreadCount;
     }
+    public int getAcceptorThreadCount() { return acceptorThreadCount; }
+
 
-    public boolean isFastShutdown() {
-        return fastShutdown;
+    /**
+     * Priority of the acceptor threads.
+     */
+    protected int acceptorThreadPriority = Thread.NORM_PRIORITY;
+    public void setAcceptorThreadPriority(int acceptorThreadPriority) {
+        this.acceptorThreadPriority = acceptorThreadPriority;
     }
+    public int getAcceptorThreadPriority() { return acceptorThreadPriority; }
+
 
     private int maxConnections = 10000;
     public void setMaxConnections(int maxCon) {
@@ -480,6 +508,16 @@ public abstract class AbstractEndpoint {
             if (getLog().isDebugEnabled()) {
                 getLog().debug("Socket unlock completed for:"+saddr);
             }
+
+            // Wait for upto 1000ms acceptor threads to unlock
+            long waitLeft = 1000;
+            for (Acceptor acceptor : acceptors) {
+                while (waitLeft > 0 &&
+                        acceptor.getState() == AcceptorState.RUNNING) {
+                    Thread.sleep(50);
+                    waitLeft -= 50;
+                }
+            }
         } catch(Exception e) {
             if (getLog().isDebugEnabled()) {
                 getLog().debug(sm.getString("endpoint.debug.unlock", "" + getPort()), e);
@@ -525,24 +563,33 @@ public abstract class AbstractEndpoint {
         startInternal();
     }
 
+    protected final void startAcceptorThreads() {
+        int count = getAcceptorThreadCount();
+        acceptors = new Acceptor[count];
+
+        for (int i = 0; i < count; i++) {
+            acceptors[i] = createAcceptor();
+            Thread t = new Thread(acceptors[i], getName() + "-Acceptor-" + i);
+            t.setPriority(getAcceptorThreadPriority());
+            t.setDaemon(getDaemon());
+            t.start();
+        }
+    }
+
+
+    /**
+     * Hook to allow Endpoints to provide a specific Acceptor implementation.
+     */
+    protected abstract Acceptor createAcceptor();
+
+
     /**
      * Pause the endpoint, which will stop it accepting new connections.
      */
     public void pause() {
         if (running && !paused) {
             paused = true;
-            if (isFastShutdown()) {
-                // unlockAccept will also be called by stopInternal(),
-                // so when shutting down it can be skipped here.
-                return;
-            }
             unlockAccept();
-            // Heuristic: Sleep for a while to ensure pause of the endpoint
-            try {
-                Thread.sleep(1000);
-            } catch (InterruptedException e) {
-                // Ignore
-            }
         }
     }
 

==================================================
JIoEndpoint.java
index bcf500463f..a675173922 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -40,6 +40,7 @@ import org.apache.tomcat.jni.SSLSocket;
 import org.apache.tomcat.jni.Socket;
 import org.apache.tomcat.jni.Status;
 import org.apache.tomcat.util.ExceptionUtils;
+import org.apache.tomcat.util.net.AbstractEndpoint.Acceptor.AcceptorState;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 
 
@@ -91,9 +92,6 @@ public class AprEndpoint extends AbstractEndpoint {
     protected long sslContext = 0;
 
 
-    private Acceptor acceptors[] = null;
-
-
     protected ConcurrentLinkedQueue<SocketWrapper<Long>> waitingRequests =
         new ConcurrentLinkedQueue<SocketWrapper<Long>>();
 
@@ -164,14 +162,6 @@ public class AprEndpoint extends AbstractEndpoint {
     public boolean getUsePolling() { return true; } // Always supported
 
 
-    /**
-     * Acceptor thread count.
-     */
-    protected int acceptorThreadCount = 0;
-    public void setAcceptorThreadCount(int acceptorThreadCount) { this.acceptorThreadCount = acceptorThreadCount; }
-    public int getAcceptorThreadCount() { return acceptorThreadCount; }
-
-
     /**
      * Sendfile thread count.
      */
@@ -619,15 +609,7 @@ public class AprEndpoint extends AbstractEndpoint {
                 }
             }
 
-            // Start acceptor threads
-            acceptors = new Acceptor[acceptorThreadCount];
-            for (int i = 0; i < acceptorThreadCount; i++) {
-                acceptors[i] = new Acceptor();
-                acceptors[i].setName(getName() + "-Acceptor-" + i);
-                acceptors[i].setPriority(threadPriority);
-                acceptors[i].setDaemon(getDaemon());
-                acceptors[i].start();
-            }
+            startAcceptorThreads();
 
             // Start async timeout thread
             Thread timeoutThread = new Thread(new AsyncTimeout(),
@@ -651,25 +633,28 @@ public class AprEndpoint extends AbstractEndpoint {
         if (running) {
             running = false;
             unlockAccept();
-            for (int i = 0; i < acceptors.length; i++) {
-                long s = System.currentTimeMillis() + 10000;
-                while (acceptors[i].isAlive() && serverSock != 0) {
+            for (AbstractEndpoint.Acceptor acceptor : acceptors) {
+                long waitLeft = 10000;
+                while (waitLeft > 0 &&
+                        acceptor.getState() != AcceptorState.ENDED &&
+                        serverSock != 0) {
                     try {
-                        acceptors[i].interrupt();
-                        acceptors[i].join(1000);
+                        Thread.sleep(50);
                     } catch (InterruptedException e) {
-                        // Ignore
-                    }
-                    if (System.currentTimeMillis() >= s) {
-                        log.warn(sm.getString("endpoint.warn.unlockAcceptorFailed",
-                                 acceptors[i].getName()));
-                        // If the Acceptor is still running force
-                        // the hard socket close.
-                        if (serverSock != 0) {
-                            Socket.shutdown(serverSock, Socket.APR_SHUTDOWN_READ);
-                            serverSock = 0;
-                        }
+                        // Ignore and clean the interrupt flag
+                        Thread.interrupted();
                     }
+                    waitLeft -= 50;
+                }
+                if (waitLeft == 0) {
+                    log.warn(sm.getString("endpoint.warn.unlockAcceptorFailed",
+                            acceptor.getThreadName()));
+                   // If the Acceptor is still running force
+                   // the hard socket close.
+                   if (serverSock != 0) {
+                       Socket.shutdown(serverSock, Socket.APR_SHUTDOWN_READ);
+                       serverSock = 0;
+                   }
                 }
             }
             for (int i = 0; i < pollers.length; i++) {
@@ -738,6 +723,11 @@ public class AprEndpoint extends AbstractEndpoint {
 
     // ------------------------------------------------------ Protected Methods
 
+    @Override
+    protected AbstractEndpoint.Acceptor createAcceptor() {
+        return new Acceptor();
+    }
+
 
     /**
      * Process the specified connection.
@@ -957,10 +947,11 @@ public class AprEndpoint extends AbstractEndpoint {
     /**
      * Server socket acceptor thread.
      */
-    protected class Acceptor extends Thread {
+    protected class Acceptor extends AbstractEndpoint.Acceptor {
 
         private final Log log = LogFactory.getLog(AprEndpoint.Acceptor.class);
 
+
         /**
          * The background thread that listens for incoming TCP/IP connections and
          * hands them off to an appropriate processor.
@@ -975,6 +966,7 @@ public class AprEndpoint extends AbstractEndpoint {
 
                 // Loop if endpoint is paused
                 while (paused && running) {
+                    state = AcceptorState.PAUSED;
                     try {
                         Thread.sleep(1000);
                     } catch (InterruptedException e) {
@@ -985,6 +977,8 @@ public class AprEndpoint extends AbstractEndpoint {
                 if (!running) {
                     break;
                 }
+                state = AcceptorState.RUNNING;
+
                 try {
                     //if we have reached max connections, wait
                     countUpOrAwaitConnection();
@@ -1036,13 +1030,10 @@ public class AprEndpoint extends AbstractEndpoint {
                         }
                     }
                 }
-
                 // The processor will recycle itself when it finishes
-
             }
-
+            state = AcceptorState.ENDED;
         }
-
     }
 
 

==================================================
NioEndpoint.java
index 4ec9ee4fbb..12af7bd860 100644
--- a/java/org/apache/tomcat/util/net/JIoEndpoint.java
+++ b/java/org/apache/tomcat/util/net/JIoEndpoint.java
@@ -75,13 +75,6 @@ public class JIoEndpoint extends AbstractEndpoint {
 
     // ------------------------------------------------------------- Properties
 
-    /**
-     * Acceptor thread count.
-     */
-    protected int acceptorThreadCount = 0;
-    public void setAcceptorThreadCount(int acceptorThreadCount) { this.acceptorThreadCount = acceptorThreadCount; }
-    public int getAcceptorThreadCount() { return acceptorThreadCount; }
-
     /**
      * Handling of accepted sockets.
      */
@@ -174,8 +167,7 @@ public class JIoEndpoint extends AbstractEndpoint {
     /**
      * Server socket acceptor thread.
      */
-    protected class Acceptor implements Runnable {
-
+    protected class Acceptor extends AbstractEndpoint.Acceptor {
 
         /**
          * The background thread that listens for incoming TCP/IP connections and
@@ -191,6 +183,7 @@ public class JIoEndpoint extends AbstractEndpoint {
 
                 // Loop if endpoint is paused
                 while (paused && running) {
+                    state = AcceptorState.PAUSED;
                     try {
                         Thread.sleep(1000);
                     } catch (InterruptedException e) {
@@ -201,6 +194,8 @@ public class JIoEndpoint extends AbstractEndpoint {
                 if (!running) {
                     break;
                 }
+                state = AcceptorState.RUNNING;
+
                 try {
                     //if we have reached max connections, wait
                     countUpOrAwaitConnection();
@@ -252,6 +247,7 @@ public class JIoEndpoint extends AbstractEndpoint {
                 }
                 // The processor will recycle itself when it finishes
             }
+            state = AcceptorState.ENDED;
         }
     }
 
@@ -405,14 +401,7 @@ public class JIoEndpoint extends AbstractEndpoint {
 
             initializeConnectionLatch();
 
-            // Start acceptor threads
-            for (int i = 0; i < acceptorThreadCount; i++) {
-                Thread acceptorThread = new Thread(new Acceptor(),
-                        getName() + "-Acceptor-" + i);
-                acceptorThread.setPriority(threadPriority);
-                acceptorThread.setDaemon(getDaemon());
-                acceptorThread.start();
-            }
+            startAcceptorThreads();
 
             // Start async timeout thread
             Thread timeoutThread = new Thread(new AsyncTimeout(),
@@ -457,6 +446,12 @@ public class JIoEndpoint extends AbstractEndpoint {
     }
 
 
+    @Override
+    protected AbstractEndpoint.Acceptor createAcceptor() {
+        return new Acceptor();
+    }
+
+
     /**
      * Configure the socket.
      */

==================================================
TomcatBaseTest.java
index 25f7d16d01..36a63bacd6 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -300,13 +300,6 @@ public class NioEndpoint extends AbstractEndpoint {
     }
 
 
-    /**
-     * Priority of the acceptor threads.
-     */
-    protected int acceptorThreadPriority = Thread.NORM_PRIORITY;
-    public void setAcceptorThreadPriority(int acceptorThreadPriority) { this.acceptorThreadPriority = acceptorThreadPriority; }
-    public int getAcceptorThreadPriority() { return acceptorThreadPriority; }
-
     /**
      * Priority of the poller threads.
      */
@@ -336,14 +329,6 @@ public class NioEndpoint extends AbstractEndpoint {
     public boolean getUsePolling() { return true; } // Always supported
 
 
-    /**
-     * Acceptor thread count.
-     */
-    protected int acceptorThreadCount = 1;
-    public void setAcceptorThreadCount(int acceptorThreadCount) { this.acceptorThreadCount = acceptorThreadCount; }
-    public int getAcceptorThreadCount() { return acceptorThreadCount; }
-
-
     /**
      * Poller thread count.
      */
@@ -536,13 +521,7 @@ public class NioEndpoint extends AbstractEndpoint {
                 pollerThread.start();
             }
 
-            // Start acceptor threads
-            for (int i = 0; i < acceptorThreadCount; i++) {
-                Thread acceptorThread = new Thread(new Acceptor(), getName() + "-Acceptor-" + i);
-                acceptorThread.setPriority(threadPriority);
-                acceptorThread.setDaemon(getDaemon());
-                acceptorThread.start();
-            }
+            startAcceptorThreads();
         }
     }
 
@@ -631,6 +610,12 @@ public class NioEndpoint extends AbstractEndpoint {
     }
 
 
+    @Override
+    protected AbstractEndpoint.Acceptor createAcceptor() {
+        return new Acceptor();
+    }
+
+
     /**
      * Process the specified connection.
      */
@@ -742,7 +727,7 @@ public class NioEndpoint extends AbstractEndpoint {
     /**
      * Server socket acceptor thread.
      */
-    protected class Acceptor implements Runnable {
+    protected class Acceptor extends AbstractEndpoint.Acceptor {
         /**
          * The background thread that listens for incoming TCP/IP connections and
          * hands them off to an appropriate processor.
@@ -757,6 +742,7 @@ public class NioEndpoint extends AbstractEndpoint {
 
                 // Loop if endpoint is paused
                 while (paused && running) {
+                    state = AcceptorState.PAUSED;
                     try {
                         Thread.sleep(1000);
                     } catch (InterruptedException e) {
@@ -767,6 +753,8 @@ public class NioEndpoint extends AbstractEndpoint {
                 if (!running) {
                     break;
                 }
+                state = AcceptorState.RUNNING;
+
                 try {
                     //if we have reached max connections, wait
                     countUpOrAwaitConnection();
@@ -829,6 +817,7 @@ public class NioEndpoint extends AbstractEndpoint {
                     log.error(sm.getString("endpoint.accept.fail"), t);
                 }
             }//while
+            state = AcceptorState.ENDED;
         }//run
     }
 

==================================================
