50a1d0b550e318572636b409e55a4e1329029932
==================================================
Update for April draft of servlet spec. Some 3.0 stuff that was complete will need to be re-done
==================================================
Mark Emlyn
==================================================
Thu Apr 23 16:14:59 2009 +0000
==================================================
AsyncContext.java
Update for April draft of servlet spec. Some 3.0 stuff that was complete will need to be re-done

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@767956 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AsyncListener.java
new file mode 100644
index 0000000000..691a6e35cf
--- /dev/null
+++ b/java/javax/servlet/AsyncContext.java
@@ -0,0 +1,66 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package javax.servlet;
+
+/**
+ * @since 3.0
+ * $Id$
+ * TODO SERVLET3
+ */
+public interface AsyncContext {
+    public static final String ASYNC_REQUEST_URI =
+        "javax.servlet.async.request_uri";
+    public static final String ASYNC_CONTEXT_PATH  =
+        "javax.servlet.async.context_path";
+    public static final String ASYNC_PATH_INFO =
+        "javax.servlet.async.path_info";
+    public static final String ASYNC_SERVLET_PATH =
+        "javax.servlet.async.servlet_path";
+    public static final String ASYNC_QUERY_STRING =
+        "javax.servlet.async.query_string";
+    
+    ServletRequest getRequest();
+    
+    ServletResponse getResponse();
+    
+    boolean hasOriginalRequestAndResponse();
+    
+    /**
+     * 
+     * @throws IllegalStateException
+     */
+    void dispatch();
+    
+    /**
+     * 
+     * @param path
+     * @throws IllegalStateException
+     */
+    void dispatch(String path);
+    
+    /**
+     * 
+     * @param context
+     * @param path
+     * @throws IllegalStateException
+     */
+    void dispatch(ServletContext context, String path);
+    
+    void complete();
+    
+    void start(Runnable run);
+}

==================================================
DispatcherType.java
index f618f4b26c..a5d74c4448 100644
--- a/java/javax/servlet/AsyncListener.java
+++ b/java/javax/servlet/AsyncListener.java
@@ -25,6 +25,6 @@ import java.util.EventListener;
  * TODO SERVLET3 - Add comments
  */
 public interface AsyncListener extends EventListener {
-    void onDoneAsync(AsyncEvent event) throws IOException;
+    void onComplete(AsyncEvent event) throws IOException;
     void onTimeout(AsyncEvent event) throws IOException;
 }

==================================================
FilterRegistration.java
index 2114cce560..0224fcb40e 100644
--- a/java/javax/servlet/DispatcherType.java
+++ b/java/javax/servlet/DispatcherType.java
@@ -24,5 +24,6 @@ public enum DispatcherType {
     FORWARD,
     INCLUDE,
     REQUEST,
+    ASYNC,
     ERROR
 }

==================================================
Registration.java
new file mode 100644
index 0000000000..bd1b54e41c
--- /dev/null
+++ b/java/javax/servlet/FilterRegistration.java
@@ -0,0 +1,53 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package javax.servlet;
+
+import java.util.EnumSet;
+
+/**
+ * @since 3.0
+ * $Id$
+ * TODO SERVLET3 - Add comments
+ */
+public interface FilterRegistration extends Registration {
+    
+    /**
+     * 
+     * @param dispatcherTypes
+     * @param isMatchAfter
+     * @param servletNames
+     * @throws IllegalArgumentException
+     * @throws IllegalStateException
+     */
+    public void addMappingForServletNames(EnumSet<DispatcherType> dispatcherTypes,
+            boolean isMatchAfter, String... servletNames);
+    
+    /**
+     * 
+     * @param dispatcherTypes
+     * @param isMatchAfter
+     * @param urlPatterns
+     * @throws IllegalArgumentException
+     * @throws IllegalStateException
+     */
+    public void addMappingForUrlPatterns(EnumSet<DispatcherType> dispatcherTypes,
+            boolean isMatchAfter, String... urlPatterns);
+
+    public static interface Dynamic
+    extends FilterRegistration, Registration.Dynamic {
+    }
+}

==================================================
RequestDispatcher.java
new file mode 100644
index 0000000000..a55c08edfb
--- /dev/null
+++ b/java/javax/servlet/Registration.java
@@ -0,0 +1,43 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package javax.servlet;
+
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * @since 3.0
+ * $Id$
+ * TODO SERVLET3 - Add comments
+ */
+public interface Registration {
+    
+    public boolean setInitParameter(String name, String value)
+    throws IllegalArgumentException, IllegalStateException;
+
+    public Set<String> setInitParameters(Map<String,String> initParameters)
+    throws IllegalArgumentException, IllegalStateException;
+
+    public interface Dynamic {
+        
+        public void setDescription(String description)
+        throws IllegalStateException;
+        
+        public void setAsyncSupported(boolean isAsyncSupported)
+        throws IllegalStateException;
+    }
+}

==================================================
ServletContainerInitializer.java
index a9e79b270c..273dc58476 100644
--- a/java/javax/servlet/RequestDispatcher.java
+++ b/java/javax/servlet/RequestDispatcher.java
@@ -43,7 +43,38 @@ import java.io.IOException;
  
 public interface RequestDispatcher {
 
-
+    public static final String ERROR_EXCEPTION =
+        "javax.servlet.error.exception";
+    public static final String ERROR_EXCEPTION_TYPE =
+        "javax.servlet.error.exception_type";
+    public static final String ERROR_MESSAGE =
+        "javax.servlet.error.message";
+    public static final String ERROR_REQUEST_URI =
+        "javax.servlet.error.request_uri";
+    public static final String ERROR_SERVLET_NAME =
+        "javax.servlet.error.servlet_name";
+    public static final String ERROR_STATUS_CODE =
+        "javax.servlet.error.status_code";
+    public static final String FORWARD_CONTEXT_PATH =
+        "javax.servlet.forward.context_path";
+    public static final String FORWARD_PATH_INFO =
+        "javax.servlet.forward.path_info";
+    public static final String FORWARD_QUERY_STRING =
+        "javax.servlet.forward.query_string";
+    public static final String FORWARD_REQUEST_URI =
+        "javax.servlet.forward.request_uri";
+    public static final String FORWARD_SERVLET_PATH =
+        "javax.servlet.forward.servlet_path";
+    public static final String INCLUDE_CONTEXT_PATH =
+        "javax.servlet.include.context_path";
+    public static final String INCLUDE_PATH_INFO =
+        "javax.servlet.include.path_info";
+    public static final String INCLUDE_QUERY_STRING =
+        "javax.servlet.include.query_string";
+    public static final String INCLUDE_REQUEST_URI =
+        "javax.servlet.include.request_uri";
+    public static final String INCLUDE_SERVLET_PATH =
+        "javax.servlet.include.servlet_path";
 
 
 

==================================================
ServletContext.java
similarity index 85%
rename from java/javax/servlet/AsyncDispatcher.java
rename to java/javax/servlet/ServletContainerInitializer.java
index e05cf6ee23..a0651e6f08 100644
--- a/java/javax/servlet/AsyncDispatcher.java
+++ b/java/javax/servlet/ServletContainerInitializer.java
@@ -18,9 +18,10 @@ package javax.servlet;
 
 /**
  * @since 3.0
+ * $Id$
  * TODO SERVLET3 - Add comments
  */
-public interface AsyncDispatcher {
-    void forward(ServletRequest request, ServletResponse response)
-            throws IllegalStateException;
+public interface ServletContainerInitializer {
+    public void onStartup(java.util.Set<java.lang.Class<?>> c,
+            ServletContext ctx);
 }

==================================================
ServletRegistration.java
index f7f5661662..205e9ff056 100644
--- a/java/javax/servlet/ServletContext.java
+++ b/java/javax/servlet/ServletContext.java
@@ -21,10 +21,8 @@ import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.EnumSet;
 import java.util.Enumeration;
-import java.util.Map;
 import java.util.Set;
 
-
 /**
  * 
  * Defines a set of methods that a servlet uses to communicate with its
@@ -57,6 +55,7 @@ import java.util.Set;
 
 public interface ServletContext {
 
+    public static final String TEMPDIR = "javax.servlet.context.tempdir";
 
     /**
      * Returns a <code>ServletContext</code> object that 
@@ -527,7 +526,17 @@ public interface ServletContext {
     public Enumeration<String> getInitParameterNames();
     
     
-
+    /**
+     * 
+     * @param name
+     * @param value
+     * @return
+     * @throws IllegalStateException
+     * @since Servlet 3.0
+     */
+    public boolean setInitParameter(String name, String value);
+    
+    
     /**
      * Returns the servlet container attribute with the given name, 
      * or <code>null</code> if there is no attribute by that name.
@@ -648,91 +657,118 @@ public interface ServletContext {
     /**
      * 
      * @param servletName
-     * @param description
      * @param className
-     * @param initParameters
-     * @param loadOnStartup
-     * @throws IllegalArgumentException If the servlet name already exists
      * @throws IllegalStateException    If the context has already been
      *                                  initialised
      * @since 3.0
      */
-    public void addServlet(String servletName, String description,
-            String className, Map<String,String> initParameters,
-            int loadOnStartup)
-            throws IllegalArgumentException, IllegalStateException;
+    public ServletRegistration.Dynamic addServlet(String servletName,
+            String className);
     
     
     /**
      * 
      * @param servletName
-     * @param urlPatterns
-     * @throws IllegalArgumentException If urlPatters is null or empty
+     * @param servlet
+     * @since 3.0
      * @throws IllegalStateException    If the context has already been
      *                                  initialised
+     */
+    public ServletRegistration.Dynamic addServlet(String servletName,
+            Servlet servlet);
+    
+    
+    /**
      * 
+     * @param servletName
+     * @param servletClass
      * @since 3.0
+     * @throws IllegalStateException    If the context has already been
+     *                                  initialised
      */
-    public void addServletMapping(String servletName, String[] urlPatterns)
-            throws IllegalArgumentException, IllegalStateException;
+    public ServletRegistration.Dynamic addServlet(String servletName,
+            Class<? extends Servlet> servletClass);
+    
+
+    /**
+     * 
+     * @param c
+     * @return
+     * @throws ServletException
+     * @since Servlet 3.0
+     */
+    public <T extends Servlet> T createServlet(Class<T> c)
+    throws ServletException;
+
+    
+    /**
+     * 
+     * @param servletName
+     * @return
+     * @since Servlet 3.0 
+     */
+    public ServletRegistration findServletRegistration(String servletName);
+
 
     /**
      * 
      * @param filterName
-     * @param description
      * @param className
-     * @param initParameters
-     * @throws IllegalArgumentException If the filter name already exists
      * @throws IllegalStateException    If the context has already been
      *                                  initialised
      * 
      * @since 3.0
      */
-    public void addFilter(String filterName, String description,
-            String className, Map<String,String> initParameters)
-            throws IllegalArgumentException, IllegalStateException;
+    public FilterRegistration.Dynamic  addFilter(String filterName,
+            String className);
+    
     
     /**
      * 
      * @param filterName
-     * @param dispatcherTypes
-     * @param isMatchAfter
-     * @param servletNames
-     * @throws IllegalArgumentException If servletNames is null or empty
+     * @param filter
      * @throws IllegalStateException    If the context has already been
      *                                  initialised
+     * 
      * @since 3.0
      */
-    public void addFilterMappingForServletNames(String filterName,
-            EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter,
-            String... servletNames)
-            throws IllegalArgumentException, IllegalStateException;
+    public FilterRegistration.Dynamic  addFilter(String filterName,
+            Filter filter);
+
     
     /**
      * 
      * @param filterName
-     * @param dispatcherTypes
-     * @param isMatchAfter
-     * @param urlPatterns
-4     *
+     * @param filterClass
+     * @throws IllegalStateException    If the context has already been
+     *                                  initialised
+     * 
      * @since 3.0
      */
-    public void addFilterMappingForUrlPatterns(String filterName,
-            EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter,
-            String... urlPatterns)
-            throws IllegalArgumentException, IllegalStateException;
+    public FilterRegistration.Dynamic  addFilter(String filterName,
+            Class<? extends Filter> filterClass);
     
 
     /**
      * 
-     * @param sessionCookieConfig
-     * @throws IllegalStateException    If the context has already been
-     *                                  initialised
-     * @since 3.0
+     * @param c
+     * @return
+     * @throws ServletException
+     * @since Servlet 3.0
      */
-    public void setSessionCookieConfig(SessionCookieConfig sessionCookieConfig)
-            throws IllegalStateException;
+    public <T extends Filter> T createFilter(Class<T> c)
+    throws ServletException;
+
     
+    /**
+     * 
+     * @param filterName
+     * @return
+     * @since Servlet 3.0 
+     */
+    public FilterRegistration findFilterRegistration(String filterName);
+
+
     /**
      * 
      * @return
@@ -769,11 +805,4 @@ public interface ServletContext {
      */
     public EnumSet<SessionTrackingMode> getEffectiveSessionTrackingModes();
     
-    /**
-     * 
-     * @param path
-     * @return
-     * @since 3.0
-     */
-    public AsyncDispatcher getAsyncDispatcher(String path);
 }

==================================================
ServletRequest.java
new file mode 100644
index 0000000000..da2157835a
--- /dev/null
+++ b/java/javax/servlet/ServletRegistration.java
@@ -0,0 +1,42 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package javax.servlet;
+
+import java.util.Set;
+
+/**
+ * @since 3.0
+ * $Id$
+ * TODO SERVLET3 - Add comments
+ */
+public interface ServletRegistration extends Registration {
+    
+    /**
+     * 
+     * @param urlPatterns
+     * @return
+     * @throws IllegalArgumentException if urlPattern is null or empty
+     * @throws IllegalStateException if the associated ServletContext has
+     *                                  already been initialised
+     */
+    public Set<String> addMapping(String... urlPatterns); 
+    
+    public static interface Dynmaic
+    extends ServletRegistration, Registration.Dynamic {
+        
+    }
+}

==================================================
ServletRequestWrapper.java
index a330989795..7045e687c1 100644
--- a/java/javax/servlet/ServletRequest.java
+++ b/java/javax/servlet/ServletRequest.java
@@ -608,17 +608,18 @@ public interface ServletRequest {
      *                                          this request
      * @since 3.0
      */
-    public void startAsync() throws java.lang.IllegalStateException;
+    public AsyncContext startAsync();
     
     /**
      * 
-     * @param runnable
+     * @param servletRequest
+     * @param servletResponse
      * @return
      * @throws java.lang.IllegalStateException
      * @since 3.0
      */
-    public void startAsync(Runnable runnable)
-            throws java.lang.IllegalStateException;
+    public AsyncContext startAsync(ServletRequest servletRequest,
+            ServletResponse servletResponse);
     
     /**
      * 
@@ -627,13 +628,6 @@ public interface ServletRequest {
      */
     public boolean isAsyncStarted();
     
-    /**
-     * 
-     * @throws IllegalStateException    If startAsync was never called
-     * @since 3.0
-     */
-    public void doneAsync() throws IllegalStateException;
-
     /**
      * 
      * @return
@@ -644,17 +638,17 @@ public interface ServletRequest {
     /**
      * 
      * @return
+     * @throws java.lang.IllegalStateException
      * @since 3.0
      */
-    public AsyncDispatcher getAsyncDispatcher();
+    public AsyncContext getAsyncContext();
 
     /**
      * 
-     * @param path
-     * @return
+     * @param listener
      * @since 3.0
      */
-    public AsyncDispatcher getAsyncDispatcher(String path);
+    public void addAsyncListener(AsyncListener listener);
 
     /**
      * 
@@ -666,5 +660,28 @@ public interface ServletRequest {
     public void addAsyncListener(AsyncListener listener,
             ServletRequest servletRequest, ServletResponse servletResponse);
     
+    /**
+     * 
+     * @param timeout
+     * @throws java.lang.IllegalStateException
+     * @since 3.0
+     */
+    public void setAsyncTimeout(long timeout);
+    
+    
+    /**
+     * 
+     * @return
+     * @since 3.0
+     */
+    public long getAsyncTimeout();
+
+    
+    /**
+     * 
+     * @return
+     * @since 3.0
+     */
+    public DispatcherType getDispatcherType();
 }
 

==================================================
ServletResponseWrapper.java
index 3f0d08338d..f86ead2d17 100644
--- a/java/javax/servlet/ServletRequestWrapper.java
+++ b/java/javax/servlet/ServletRequestWrapper.java
@@ -417,22 +417,24 @@ public class ServletRequestWrapper implements ServletRequest {
      * @throws java.lang.IllegalStateException
      * @since 3.0
      */
-    public void startAsync() throws java.lang.IllegalStateException {
-        request.startAsync();
+    public AsyncContext startAsync() {
+        return request.startAsync();
     }
     
     /**
      * The default behavior of this method is to return
      * startAsync(Runnable) on the wrapped request object.
      * 
-     * @param runnable
+     * @param servletRequest
+     * @param servletResponse
      * @return
      * @throws java.lang.IllegalStateException
      * @since 3.0
      */
-    public void startAsync(Runnable runnable)
+    public AsyncContext startAsync(ServletRequest servletRequest,
+            ServletResponse servletResponse)
             throws java.lang.IllegalStateException {
-        request.startAsync(runnable);
+        return request.startAsync(servletRequest, servletResponse);
     }
     
     /**
@@ -446,16 +448,6 @@ public class ServletRequestWrapper implements ServletRequest {
         return request.isAsyncStarted();
     }
 
-    /**
-     * The default behavior of this method is to return
-     * doneAsync() on the wrapped request object.
-     * @throws java.lang.IllegalStateException
-     * @since 3.0
-     */
-    public void doneAsync() throws IllegalStateException {
-        request.doneAsync();
-    }
-
     /**
      * The default behavior of this method is to return
      * isAsyncSupported() on the wrapped request object.
@@ -469,26 +461,26 @@ public class ServletRequestWrapper implements ServletRequest {
     
     /**
      * The default behavior of this method is to return
-     * getAsyncDispatcher() on the wrapped request object.
+     * getAsyncContext() on the wrapped request object.
      * 
      * @return
      * @since 3.0
      */
-    public AsyncDispatcher getAsyncDispatcher() {
-        return request.getAsyncDispatcher();
+    public AsyncContext getAsyncContext() {
+        return request.getAsyncContext();
     }
 
     /**
-     * The default behavior of this method is to return
-     * getAsyncDispatcher(path) on the wrapped request object.
+     * The default behavior of this method is to call
+     * addAsyncListener(AsyncListener) on the wrapped request object.
      * 
-     * @return
+     * @param listener
      * @since 3.0
      */
-    public AsyncDispatcher getAsyncDispatcher(String path) {
-        return request.getAsyncDispatcher(path);
+    public void addAsyncListener(AsyncListener listener) {
+        request.addAsyncListener(listener);
     }
-
+    
     /**
      * The default behavior of this method is to call
      * addAsyncListener(AsyncListener, ServletRequest, ServletResponse) on the
@@ -504,5 +496,65 @@ public class ServletRequestWrapper implements ServletRequest {
         request.addAsyncListener(listener, servletRequest, servletResponse);
     }
     
+    /**
+     * The default behavior of this method is to call
+     * setAsyncTimeout(long) on the wrapped request object.
+     * 
+     * @param listener
+     * @since 3.0
+     */
+    public void setAsyncTimeout(long timeout) {
+        request.setAsyncTimeout(timeout);
+    }
+    
+    /**
+     * The default behavior of this method is to call
+     * getAsyncTimeout() on the wrapped request object.
+     * 
+     * @since 3.0
+     */
+    public long getAsyncTimeout() {
+        return request.getAsyncTimeout();
+    }
+    
+    /**
+     * 
+     * @param listener
+     * @since 3.0
+     */
+    public boolean isWrapperFor(ServletRequest wrapped) {
+        if (request == wrapped) {
+            return true;
+        }
+        if (request instanceof ServletRequestWrapper) {
+            return ((ServletRequestWrapper)request).isWrapperFor(wrapped);
+        }
+        return false;
+    }
+    
+    /**
+     * 
+     * @param listener
+     * @since 3.0
+     */
+    public boolean isWrapperFor(Class<? extends ServletRequest> wrappedType) {
+        if (wrappedType.isAssignableFrom(request.getClass())) {
+            return true;
+        }
+        if (request instanceof ServletRequestWrapper) {
+            return ((ServletRequestWrapper)request).isWrapperFor(wrappedType);
+        }
+        return false;
+    }
+    
+    /**
+     * The default behavior of this method is to call
+     * getDispatcherType() on the wrapped request object.
+     * 
+     * @since 3.0
+     */
+    public DispatcherType getDispatcherType() {
+        return this.request.getDispatcherType();
+    }
 }
 

==================================================
SessionCookieConfig.java
index 9358ca71d8..371f123f3e 100644
--- a/java/javax/servlet/ServletResponseWrapper.java
+++ b/java/javax/servlet/ServletResponseWrapper.java
@@ -209,6 +209,36 @@ public class ServletResponseWrapper implements ServletResponse {
 	return this.response.getLocale();
     }
 
+    /**
+     * 
+     * @param listener
+     * @since 3.0
+     */
+    public boolean isWrapperFor(ServletResponse wrapped) {
+        if (response == wrapped) {
+            return true;
+        }
+        if (response instanceof ServletResponseWrapper) {
+            return ((ServletResponseWrapper)response).isWrapperFor(wrapped);
+        }
+        return false;
+    }
+    
+    /**
+     * 
+     * @param listener
+     * @since 3.0
+     */
+    public boolean isWrapperFor(Class<? extends ServletResponse> wrappedType) {
+        if (wrappedType.isAssignableFrom(response.getClass())) {
+            return true;
+        }
+        if (response instanceof ServletResponseWrapper) {
+            return ((ServletResponseWrapper)response).isWrapperFor(wrappedType);
+        }
+        return false;
+    }
+    
 
 }
 

==================================================
SessionTrackingMode.java
index 2347f020fb..526f0fa713 100644
--- a/java/javax/servlet/SessionCookieConfig.java
+++ b/java/javax/servlet/SessionCookieConfig.java
@@ -21,58 +21,69 @@ package javax.servlet;
  * @since 3.0
  * $Id$
  */
-public class SessionCookieConfig {
-    private String domain;
-    private String path;
-    private String comment;
-    private boolean httpOnly;
-    private boolean secure;
-
+public interface SessionCookieConfig {
+    
+    /**
+     * 
+     * @param name
+     * @throws IllegalStateException
+     */
+    public void setName(String name);
+    
+    public String getName();
+    
     /**
      * 
-     * @param domain      Domain to use for session cookies generated for a
-     *                    {@link ServletContext} in which this
-     *                    {@link SessionCookieConfig} has been set
-     * @param path        Path to use for session cookies generated for a
-     *                    {@link ServletContext} in which this
-     *                    {@link SessionCookieConfig} has been set. If null
-     *                    {@link ServletContext#getContextPath()} is used
-     * @param comment     Comment to use for session cookies generated for a
-     *                    {@link ServletContext} in which this
-     *                    {@link SessionCookieConfig} has been set
-     * @param isHttpOnly  HttpOnly flag to use for session cookies generated for
-     *                    a {@link ServletContext} in which this
-     *                    {@link SessionCookieConfig} has been set
-     * @param isSecure    If <code>true</code>, the cookie will always be marked
-     *                    as secure. If <code>false</code> the cookie will only
-     *                    be marked as secure if the request is secure.
+     * @param domain
+     * @throws IllegalStateException
      */
-    public SessionCookieConfig(String domain, String path, String comment,
-            boolean isHttpOnly, boolean isSecure) {
-        this.domain = domain;
-        this.path = path;
-        this.comment = comment;
-        this.httpOnly = isHttpOnly;
-        this.secure = isSecure;
-    }
+    public void setDomain(String domain);
     
-    public java.lang.String getDomain() {
-        return domain;
-    }
+    public String getDomain();
     
-    public java.lang.String getPath() {
-        return path;
-    }
+    /**
+     * 
+     * @param path
+     * @throws IllegalStateException
+     */
+    public void setPath(String path);
+    
+    public String getPath();
+    
+    /**
+     * 
+     * @param comment
+     * @throws IllegalStateException
+     */
+    public void setComment(String comment);
     
-    public java.lang.String getComment() {
-        return comment;
-    }
+    public String getComment();
+    
+    /**
+     * 
+     * @param httpOnly
+     * @throws IllegalStateException
+     */
+    public void setHttpOnly(boolean httpOnly);
+    
+    public boolean isHttpOnly();
+    
+    /**
+     * 
+     * @param secure
+     * @throws IllegalStateException
+     */
+    public void setSecure(boolean secure);
+    
+    public boolean isSecure();
+
+    /**
+     * 
+     * @param maxAge
+     * @throws IllegalStateException
+     */
+    public void setMaxAge(int MaxAge);
     
-    public boolean isHttpOnly() {
-        return httpOnly;
-    }
+    public int getHttpOnly();
     
-    public boolean isSecure() {
-        return secure;
-    }
 }

==================================================
HandlesTypes.java
index 878d4629cf..fcb49afc17 100644
--- a/java/javax/servlet/SessionTrackingMode.java
+++ b/java/javax/servlet/SessionTrackingMode.java
@@ -22,6 +22,6 @@ package javax.servlet;
  */
 public enum SessionTrackingMode {
     COOKIE,
-    SSL,
-    URL
+    URL,
+    SSL
 }

==================================================
MultipartConfig.java
similarity index 93%
rename from java/javax/servlet/annotation/WebServletContextListener.java
rename to java/javax/servlet/annotation/HandlesTypes.java
index 9dfb0e8979..3a48f3dd64 100644
--- a/java/javax/servlet/annotation/WebServletContextListener.java
+++ b/java/javax/servlet/annotation/HandlesTypes.java
@@ -16,11 +16,11 @@
  */
 package javax.servlet.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
-import java.lang.annotation.Documented;
 
 /**
  * @since 3.0
@@ -30,6 +30,6 @@ import java.lang.annotation.Documented;
 @Target({ElementType.TYPE})
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
-public @interface WebServletContextListener {
-    String description() default "";
+public @interface HandlesTypes {
+    Class<?>[] value();
 }

==================================================
WebFilter.java
new file mode 100644
index 0000000000..1ecb9bf182
--- /dev/null
+++ b/java/javax/servlet/annotation/MultipartConfig.java
@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.servlet.annotation;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * @since 3.0
+ * $Id$
+ * TODO SERVLET3
+ */
+@Target({ElementType.TYPE})
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+public @interface MultipartConfig {
+    String location() default "";
+    int maxFileSize() default 0;
+    int maxRequestSize() default 0;
+    int fileSizeThreshold() default 0;
+}

==================================================
WebInitParam.java
similarity index 91%
rename from java/javax/servlet/annotation/ServletFilter.java
rename to java/javax/servlet/annotation/WebFilter.java
index 82694f41a8..42f8eb5a0a 100644
--- a/java/javax/servlet/annotation/ServletFilter.java
+++ b/java/javax/servlet/annotation/WebFilter.java
@@ -32,16 +32,16 @@ import javax.servlet.DispatcherType;
 @Target({ElementType.TYPE})
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
-public @interface ServletFilter {
+public @interface WebFilter {
     String description() default "";
     String displayName() default "";
-    InitParam[] initParams() default {};
+    WebInitParam[] initParams() default {};
     String filterName() default "";
-    String icon() default "";
+    String smallIcon() default "";
+    String largeIcon() default "";
     String[] servletNames() default {};
     String[] value() default {};
     String[] urlPatterns() default {};
     DispatcherType[] dispatcherTypes() default {DispatcherType.REQUEST};
     boolean asyncSupported() default false;
-    long asyncTimeout() default 60000L;
 }

==================================================
WebListener.java
similarity index 97%
rename from java/javax/servlet/annotation/InitParam.java
rename to java/javax/servlet/annotation/WebInitParam.java
index 5460fe1b3c..f0c8cf16f7 100644
--- a/java/javax/servlet/annotation/InitParam.java
+++ b/java/javax/servlet/annotation/WebInitParam.java
@@ -30,7 +30,7 @@ import java.lang.annotation.Documented;
 @Target({ElementType.TYPE})
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
-public @interface InitParam {
+public @interface WebInitParam {
     String name();
     String value();
     String description() default "";

==================================================
WebServlet.java
new file mode 100644
index 0000000000..d4d198008f
--- /dev/null
+++ b/java/javax/servlet/annotation/WebListener.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package javax.servlet.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.lang.annotation.Documented;
+
+/**
+ * @since 3.0
+ * $Id$
+ * TODO SERVLET3
+ */
+@Target({ElementType.TYPE})
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+public @interface WebListener {
+    String description();
+}

==================================================
HttpServletRequest.java
index 9ca6eff7dc..d8593ea8fc 100644
--- a/java/javax/servlet/annotation/WebServlet.java
+++ b/java/javax/servlet/annotation/WebServlet.java
@@ -35,9 +35,9 @@ public @interface WebServlet {
     String[] value() default {};
     String[] urlPatterns() default {};
     int loadOnStartup() default -1;
-    InitParam[] initParams() default {};
+    WebInitParam[] initParams() default {};
     boolean asyncSupported() default false;
-    long asyncTimeout() default 60000L;
-    String icon() default "";
+    String smallIcon() default "";
+    String largeIcon() default "";
     String description() default "";
 }

==================================================
HttpServletRequestWrapper.java
index c247a1504a..1558466617 100644
--- a/java/javax/servlet/http/HttpServletRequest.java
+++ b/java/javax/servlet/http/HttpServletRequest.java
@@ -17,7 +17,10 @@
 
 package javax.servlet.http;
 
+import javax.servlet.ServletException;
 import javax.servlet.ServletRequest;
+
+import java.io.IOException;
 import java.util.Enumeration;
 
 /**
@@ -657,5 +660,51 @@ public interface HttpServletRequest extends ServletRequest {
     public boolean isRequestedSessionIdFromUrl();
 
 
+    /**
+     * 
+     * @param response
+     * @return
+     * @throws IOException
+     * @throws ServletException
+     * @since Servlet 3.0
+     */
+    public boolean login(HttpServletResponse response)
+    throws IOException, ServletException;
+    
+    
+    /**
+     * 
+     * @param username
+     * @param password
+     * @throws ServletException
+     * @since Servlet 3.0
+     */
+    public void login(java.lang.String username, String password)
+    throws ServletException;
     
+    
+    /**
+     * 
+     * @throws ServletException
+     * @since Servlet 3.0
+     */
+    public void logout() throws ServletException;
+    
+    
+    /**
+     * 
+     * @return
+     * @since Servlet 3.0
+     */
+    public Iterable<Part> getParts();
+    
+    
+    /**
+     * 
+     * @param name
+     * @return
+     * @throws IllegalArgumentException
+     * @since Servlet 3.0
+     */
+    public Part getPart(java.lang.String name);
 }

==================================================
HttpServletResponse.java
index 70f83e9b31..0839f20244 100644
--- a/java/javax/servlet/http/HttpServletRequestWrapper.java
+++ b/java/javax/servlet/http/HttpServletRequestWrapper.java
@@ -16,7 +16,10 @@
 */
 package javax.servlet.http;
 
+import javax.servlet.ServletException;
 import javax.servlet.ServletRequestWrapper;
+
+import java.io.IOException;
 import java.util.Enumeration;
 
 /**
@@ -259,6 +262,41 @@ public class HttpServletRequestWrapper extends ServletRequestWrapper implements
 	return this._getHttpServletRequest().isRequestedSessionIdFromUrl();
     }
 
+    /**
+     * @since Servlet 3.0
+     */
+    public boolean login(HttpServletResponse response)
+    throws IOException, ServletException {
+        return this._getHttpServletRequest().login(response);
+    }
+
+    /**
+     * @since Servlet 3.0
+     */
+    public void login(String username, String password) throws ServletException {
+        this._getHttpServletRequest().login(username, password);
+    }
+
+    /**
+     * @since Servlet 3.0
+     */
+    public void logout() throws ServletException {
+        this._getHttpServletRequest().logout();
+    }
+
+
+    /**
+     * @since Servlet 3.0
+     */
+    public Iterable<Part> getParts() {
+        return this._getHttpServletRequest().getParts();
+    }
+
+    /**
+     * @since Servlet 3.0
+     */
+    public Part getPart(String name) {
+        return this._getHttpServletRequest().getPart(name);
+    }
 
-    
 }

==================================================
HttpServletResponseWrapper.java
index 33502643d1..1df15c7e11 100644
--- a/java/javax/servlet/http/HttpServletResponse.java
+++ b/java/javax/servlet/http/HttpServletResponse.java
@@ -322,6 +322,40 @@ public interface HttpServletResponse extends ServletResponse {
     public void setStatus(int sc, String sm);
 
     
+    /**
+     * 
+     * @return
+     * @since Servlet 3.0
+     */
+    public int getStatus();
+    
+    
+    /**
+     * 
+     * @param name
+     * @return
+     * @since Servlet 3.0
+     */
+    public String getHeader(String name);
+    
+    
+    /**
+     * 
+     * @param name
+     * @return
+     * @since Servlet 3.0
+     */
+    public Iterable<String> getHeaders(String name);
+
+    
+    /**
+     * 
+     * @return
+     * @since Servlet 3.0
+     */
+    public Iterable<String> getHeaderNames();
+
+    
     /*
      * Server status codes; see RFC 2068.
      */

==================================================
HttpUtils.java
index b91823d88c..fe35971ead 100644
--- a/java/javax/servlet/http/HttpServletResponseWrapper.java
+++ b/java/javax/servlet/http/HttpServletResponseWrapper.java
@@ -195,5 +195,35 @@ public class HttpServletResponseWrapper extends ServletResponseWrapper implement
 	this._getHttpServletResponse().setStatus(sc, sm);
     }
 
-   
+
+    /**
+     * @since Servlet 3.0
+     */
+    public int getStatus() {
+        return this._getHttpServletResponse().getStatus();
+    }
+
+     
+    /**
+     * @since Servlet 3.0
+     */
+    public String getHeader(String name) {
+        return this._getHttpServletResponse().getHeader(name);
+    }
+
+    
+    /**
+     * @since Servlet 3.0
+     */
+    public Iterable<String> getHeaders(String name) {
+        return this._getHttpServletResponse().getHeaders(name);
+    }
+
+    /**
+     * @since Servlet 3.0
+     */
+    public Iterable<String> getHeaderNames() {
+        return this._getHttpServletResponse().getHeaderNames();
+    }
+
 }

==================================================
Part.java
new file mode 100644
index 0000000000..9ce22de79c
--- /dev/null
+++ b/java/javax/servlet/http/HttpUtils.java
@@ -0,0 +1,283 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package javax.servlet.http;
+
+import javax.servlet.ServletInputStream;
+import java.util.Hashtable;
+import java.util.ResourceBundle;
+import java.util.StringTokenizer;
+import java.io.IOException;
+
+/**
+ * @deprecated            As of Java(tm) Servlet API 2.3. 
+ *                        These methods were only useful
+ *                        with the default encoding and have been moved
+ *                        to the request interfaces.
+ *
+*/
+
+
+public class HttpUtils {
+
+    private static final String LSTRING_FILE =
+        "javax.servlet.http.LocalStrings";
+    private static ResourceBundle lStrings =
+        ResourceBundle.getBundle(LSTRING_FILE);
+        
+    
+    /**
+     * Constructs an empty <code>HttpUtils</code> object.
+     *
+     */
+    public HttpUtils() {
+        // NOOP
+    }
+
+
+    /**
+     *
+     * Parses a query string passed from the client to the
+     * server and builds a <code>HashTable</code> object
+     * with key-value pairs. 
+     * The query string should be in the form of a string
+     * packaged by the GET or POST method, that is, it
+     * should have key-value pairs in the form <i>key=value</i>,
+     * with each pair separated from the next by a &amp; character.
+     *
+     * <p>A key can appear more than once in the query string
+     * with different values. However, the key appears only once in 
+     * the hashtable, with its value being
+     * an array of strings containing the multiple values sent
+     * by the query string.
+     * 
+     * <p>The keys and values in the hashtable are stored in their
+     * decoded form, so
+     * any + characters are converted to spaces, and characters
+     * sent in hexadecimal notation (like <i>%xx</i>) are
+     * converted to ASCII characters.
+     *
+     * @param s                a string containing the query to be parsed
+     *
+     * @return                a <code>HashTable</code> object built
+     *                         from the parsed key-value pairs
+     *
+     * @exception IllegalArgumentException        if the query string 
+     *                                                is invalid
+     *
+     */
+    static public Hashtable<String,String[]> parseQueryString(String s) {
+
+        String valArray[] = null;
+        
+        if (s == null) {
+            throw new IllegalArgumentException();
+        }
+        Hashtable<String,String[]> ht = new Hashtable<String,String[]>();
+        StringBuffer sb = new StringBuffer();
+        StringTokenizer st = new StringTokenizer(s, "&");
+        while (st.hasMoreTokens()) {
+            String pair = st.nextToken();
+            int pos = pair.indexOf('=');
+            if (pos == -1) {
+                // XXX
+                // should give more detail about the illegal argument
+                throw new IllegalArgumentException();
+            }
+            String key = parseName(pair.substring(0, pos), sb);
+            String val = parseName(pair.substring(pos+1, pair.length()), sb);
+            if (ht.containsKey(key)) {
+                String oldVals[] = ht.get(key);
+                valArray = new String[oldVals.length + 1];
+                for (int i = 0; i < oldVals.length; i++) 
+                    valArray[i] = oldVals[i];
+                valArray[oldVals.length] = val;
+            } else {
+                valArray = new String[1];
+                valArray[0] = val;
+            }
+            ht.put(key, valArray);
+        }
+        return ht;
+    }
+
+
+    /**
+     *
+     * Parses data from an HTML form that the client sends to 
+     * the server using the HTTP POST method and the 
+     * <i>application/x-www-form-urlencoded</i> MIME type.
+     *
+     * <p>The data sent by the POST method contains key-value
+     * pairs. A key can appear more than once in the POST data
+     * with different values. However, the key appears only once in 
+     * the hashtable, with its value being
+     * an array of strings containing the multiple values sent
+     * by the POST method.
+     *
+     * <p>The keys and values in the hashtable are stored in their
+     * decoded form, so
+     * any + characters are converted to spaces, and characters
+     * sent in hexadecimal notation (like <i>%xx</i>) are
+     * converted to ASCII characters.
+     *
+     *
+     *
+     * @param len        an integer specifying the length,
+     *                        in characters, of the 
+     *                        <code>ServletInputStream</code>
+     *                        object that is also passed to this
+     *                        method
+     *
+     * @param in        the <code>ServletInputStream</code>
+     *                        object that contains the data sent
+     *                        from the client
+     * 
+     * @return                a <code>HashTable</code> object built
+     *                        from the parsed key-value pairs
+     *
+     *
+     * @exception IllegalArgumentException        if the data
+     *                        sent by the POST method is invalid
+     *
+     */
+    static public Hashtable<String,String[]> parsePostData(int len, 
+                                          ServletInputStream in) {
+        // XXX
+        // should a length of 0 be an IllegalArgumentException
+        
+        // cheap hack to return an empty hash
+        if (len <=0) 
+            return new Hashtable<String,String[]>();
+
+        if (in == null) {
+            throw new IllegalArgumentException();
+        }
+        
+        // Make sure we read the entire POSTed body.
+        byte[] postedBytes = new byte [len];
+        try {
+            int offset = 0;
+       
+            do {
+                int inputLen = in.read (postedBytes, offset, len - offset);
+                if (inputLen <= 0) {
+                    String msg = lStrings.getString("err.io.short_read");
+                    throw new IllegalArgumentException (msg);
+                }
+                offset += inputLen;
+            } while ((len - offset) > 0);
+
+        } catch (IOException e) {
+            throw new IllegalArgumentException(e.getMessage());
+        }
+
+        // XXX we shouldn't assume that the only kind of POST body
+        // is FORM data encoded using ASCII or ISO Latin/1 ... or
+        // that the body should always be treated as FORM data.
+        try {
+            String postedBody = new String(postedBytes, 0, len, "8859_1");
+            return parseQueryString(postedBody);
+        } catch (java.io.UnsupportedEncodingException e) {
+            // XXX function should accept an encoding parameter & throw this
+            // exception.  Otherwise throw something expected.
+            throw new IllegalArgumentException(e.getMessage());
+        }
+    }
+
+
+    /*
+     * Parse a name in the query string.
+     */
+    static private String parseName(String s, StringBuffer sb) {
+        sb.setLength(0);
+        for (int i = 0; i < s.length(); i++) {
+            char c = s.charAt(i); 
+            switch (c) {
+            case '+':
+                sb.append(' ');
+                break;
+            case '%':
+                try {
+                    sb.append((char) Integer.parseInt(s.substring(i+1, i+3), 
+                                                      16));
+                    i += 2;
+                } catch (NumberFormatException e) {
+                    // XXX
+                    // need to be more specific about illegal arg
+                    throw new IllegalArgumentException();
+                } catch (StringIndexOutOfBoundsException e) {
+                    String rest  = s.substring(i);
+                    sb.append(rest);
+                    if (rest.length()==2)
+                        i++;
+                }
+                
+                break;
+            default:
+                sb.append(c);
+                break;
+            }
+        }
+        return sb.toString();
+    }
+
+
+    /**
+     *
+     * Reconstructs the URL the client used to make the request,
+     * using information in the <code>HttpServletRequest</code> object.
+     * The returned URL contains a protocol, server name, port
+     * number, and server path, but it does not include query
+     * string parameters.
+     * 
+     * <p>Because this method returns a <code>StringBuffer</code>,
+     * not a string, you can modify the URL easily, for example,
+     * to append query parameters.
+     *
+     * <p>This method is useful for creating redirect messages
+     * and for reporting errors.
+     *
+     * @param req        a <code>HttpServletRequest</code> object
+     *                        containing the client's request
+     * 
+     * @return                a <code>StringBuffer</code> object containing
+     *                        the reconstructed URL
+     *
+     */
+    public static StringBuffer getRequestURL (HttpServletRequest req) {
+        StringBuffer url = new StringBuffer ();
+        String scheme = req.getScheme ();
+        int port = req.getServerPort ();
+        String urlPath = req.getRequestURI();
+        
+        url.append (scheme);                // http, https
+        url.append ("://");
+        url.append (req.getServerName ());
+        if ((scheme.equals ("http") && port != 80)
+                || (scheme.equals ("https") && port != 443)) {
+            url.append (':');
+            url.append (req.getServerPort ());
+        }
+
+        url.append(urlPath);
+        return url;
+    }
+}
+
+
+

==================================================
CoyoteAdapter.java
new file mode 100644
index 0000000000..5db774486c
--- /dev/null
+++ b/java/javax/servlet/http/Part.java
@@ -0,0 +1,35 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements.  See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License.  You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package javax.servlet.http;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * @since Servlet 3.0
+ */
+public interface Part {
+    public InputStream getInputStream() throws IOException;
+    public String getContentType();
+    public String getName();
+    public long getSize();
+    public void write(String fileName) throws IOException;
+    public void delete() throws IOException;
+    public String getHeader(String name);
+    public Iterable<String> getHeaders(String name);
+    public Iterable<String> getHeaderNames();
+}

==================================================
Request.java
index ad9995784a..3ce130d959 100644
--- a/java/org/apache/catalina/connector/CoyoteAdapter.java
+++ b/java/org/apache/catalina/connector/CoyoteAdapter.java
@@ -384,7 +384,7 @@ public class CoyoteAdapter
             req.serverName().setString(proxyName);
         }
 
-        // Parse session Id
+        // Parse session Id before decoding / removal of path params
         parseSessionId(req, request);
 
         // URI decoding

==================================================
RequestFacade.java
index ce572f22d7..ec536fe112 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -35,11 +35,13 @@ import java.util.TimeZone;
 import java.util.TreeMap;
 
 import javax.security.auth.Subject;
-import javax.servlet.AsyncDispatcher;
+import javax.servlet.AsyncContext;
 import javax.servlet.AsyncListener;
+import javax.servlet.DispatcherType;
 import javax.servlet.FilterChain;
 import javax.servlet.RequestDispatcher;
 import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 import javax.servlet.ServletInputStream;
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletRequestAttributeEvent;
@@ -49,7 +51,9 @@ import javax.servlet.SessionCookieConfig;
 import javax.servlet.SessionTrackingMode;
 import javax.servlet.http.Cookie;
 import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import javax.servlet.http.HttpSession;
+import javax.servlet.http.Part;
 
 import org.apache.tomcat.util.buf.B2CConverter;
 import org.apache.tomcat.util.buf.MessageBytes;
@@ -73,7 +77,6 @@ import org.apache.catalina.core.ApplicationFilterFactory;
 import org.apache.catalina.realm.GenericPrincipal;
 import org.apache.catalina.util.Enumerator;
 import org.apache.catalina.util.ParameterMap;
-import org.apache.catalina.util.RequestUtil;
 import org.apache.catalina.util.StringManager;
 import org.apache.catalina.util.StringParser;
 
@@ -1505,12 +1508,15 @@ public class Request
         return context.getServletContext();
      }
 
-    public void startAsync() throws IllegalStateException {
+    public AsyncContext startAsync() {
         // TODO SERVLET3
+        return null;
     }
 
-    public void startAsync(Runnable runnable) throws IllegalStateException {
+    public AsyncContext startAsync(ServletRequest request,
+            ServletResponse response) {
         // TODO SERVLET3
+        return null;
     }
 
     public boolean isAsyncStarted() {
@@ -1518,31 +1524,39 @@ public class Request
         return false;
     }
 
-    public void doneAsync() throws IllegalStateException {
-        // TODO SERVLET3
-    }
-
     public boolean isAsyncSupported() {
         // TODO SERVLET3
         return false;
     }
 
-    public AsyncDispatcher getAsyncDispatcher() {
+    public AsyncContext getAsyncContext() {
         // TODO SERVLET3
         return null;
     }
 
-    public AsyncDispatcher getAsyncDispatcher(String path) {
+    public void addAsyncListener(AsyncListener listener) {
         // TODO SERVLET3
-        return null;
     }
-    
 
     public void addAsyncListener(AsyncListener listener,
             ServletRequest servletRequest, ServletResponse servletResponse) {
         // TODO SERVLET3
     }
 
+    public void setAsyncTimeout(long timeout) {
+        // TODO SERVLET3
+    }
+    
+    public long getAsyncTimeout() {
+        // TODO SERVLET3
+        return 0;
+    }
+    
+    public DispatcherType getDispatcherType() {
+        // TODO SERVLET3
+        return null;
+    }
+
     // ---------------------------------------------------- HttpRequest Methods
 
 
@@ -2352,7 +2366,30 @@ public class Request
         return requestedSessionSSL;
     }
     
+    public boolean login(HttpServletResponse response) throws IOException {
+        // TODO Servlet 3
+        return false;
+    }
+    
+    public void login(String username, String password)
+    throws ServletException {
+        // TODO Servlet 3
+    }
+    
+    public void logout() throws ServletException {
+        // TODO Servlet 3
+    }
+    
+    public Iterable<Part> getParts() {
+        // TODO Servlet 3
+        return null;
+    }
     
+    public Part getPart(String name) throws IllegalArgumentException {
+        // TODO Servlet 3.0
+        return null;
+    }
+
     // ------------------------------------------------------ Protected Methods
 
 

==================================================
Response.java
index 7485f3bf1a..8768cacf40 100644
--- a/java/org/apache/catalina/connector/RequestFacade.java
+++ b/java/org/apache/catalina/connector/RequestFacade.java
@@ -26,16 +26,20 @@ import java.util.Enumeration;
 import java.util.Locale;
 import java.util.Map;
 
-import javax.servlet.AsyncDispatcher;
+import javax.servlet.AsyncContext;
 import javax.servlet.AsyncListener;
+import javax.servlet.DispatcherType;
 import javax.servlet.RequestDispatcher;
 import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 import javax.servlet.ServletInputStream;
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 import javax.servlet.http.Cookie;
 import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import javax.servlet.http.HttpSession;
+import javax.servlet.http.Part;
 
 import org.apache.catalina.Globals;
 import org.apache.catalina.util.StringManager;
@@ -948,13 +952,14 @@ public class RequestFacade implements HttpServletRequest {
     }
 
 
-    public void startAsync() throws IllegalStateException {
-        request.startAsync();
+    public AsyncContext startAsync() throws IllegalStateException {
+        return request.startAsync();
     }
 
 
-    public void startAsync(Runnable runnable) throws IllegalStateException {
-        request.startAsync(runnable);
+    public AsyncContext startAsync(ServletRequest request, ServletResponse response)
+    throws IllegalStateException {
+        return request.startAsync(request, response);
     }
 
 
@@ -963,32 +968,59 @@ public class RequestFacade implements HttpServletRequest {
     }
 
 
-    public void doneAsync() throws IllegalStateException {
-        request.doneAsync();
-    }
-
-    
     public boolean isAsyncSupported() {
         return request.isAsyncStarted();
     }
 
     
-    public AsyncDispatcher getAsyncDispatcher() {
-        return request.getAsyncDispatcher();
+    public void addAsyncListener(AsyncListener listener) {
+        request.addAsyncListener(listener);
     }
 
     
-    public AsyncDispatcher getAsyncDispatcher(String path) {
-        return request.getAsyncDispatcher(path);
+    public void addAsyncListener(AsyncListener listener, ServletRequest servletRequest, ServletResponse servletResponse) {
+        request.addAsyncListener(listener,servletRequest,servletResponse);
     }
 
+    public AsyncContext getAsyncContext() {
+        return request.getAsyncContext();
+    }
+
+    public long getAsyncTimeout() {
+        return request.getAsyncTimeout();
+    }
     
-    public void addAsyncListener(AsyncListener listener, ServletRequest servletRequest, ServletResponse servletResponse) {
-        request.addAsyncListener(listener,servletRequest,servletResponse);
+    public void setAsyncTimeout(long timeout) {
+        request.setAsyncTimeout(timeout);
+    }
+    
+    public DispatcherType getDispatcherType() {
+        return request.getDispatcherType();
+    }
+    
+    public boolean login(HttpServletResponse response) throws IOException {
+        return request.login(response);
     }
 
+    public void login(String username, String password)
+    throws ServletException {
+        login(username, password);
+    }
+    
+    public void logout() throws ServletException {
+        request.logout();
+    }
+    
+    public Iterable<Part> getParts() {
+        return request.getParts();
+    }
+    
+    public Part getPart(String name) {
+        return request.getPart(name);
+    }
 
     public boolean getAllowTrace() {
         return request.getConnector().getAllowTrace();
     }
+    
 }

==================================================
ResponseFacade.java
index 349b49d7c6..7c3e65e334 100644
--- a/java/org/apache/catalina/connector/Response.java
+++ b/java/org/apache/catalina/connector/Response.java
@@ -30,6 +30,7 @@ import java.security.PrivilegedExceptionAction;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Enumeration;
+import java.util.List;
 import java.util.Locale;
 import java.util.TimeZone;
 import java.util.Vector;
@@ -883,16 +884,15 @@ public class Response
 
 
     /**
-     * Return an array of all the header names set for this response, or
-     * a zero-length array if no headers have been set.
+     * Return an Iterable of all the header names set for this response.
      */
-    public String[] getHeaderNames() {
+    public Iterable<String> getHeaderNames() {
 
         MimeHeaders headers = coyoteResponse.getMimeHeaders();
         int n = headers.size();
-        String[] result = new String[n];
+        List<String> result = new ArrayList<String>(n);
         for (int i = 0; i < n; i++) {
-            result[i] = headers.getName(i).toString();
+            result.add(headers.getName(i).toString());
         }
         return result;
 
@@ -900,13 +900,12 @@ public class Response
 
 
     /**
-     * Return an array of all the header values associated with the
-     * specified header name, or an zero-length array if there are no such
-     * header values.
+     * Return an Iterable of all the header values associated with the
+     * specified header name.
      *
      * @param name Header name to look up
      */
-    public String[] getHeaderValues(String name) {
+    public Iterable<String> getHeaders(String name) {
 
         Enumeration<String> enumeration =
             coyoteResponse.getMimeHeaders().values(name);
@@ -914,10 +913,7 @@ public class Response
         while (enumeration.hasMoreElements()) {
             result.addElement(enumeration.nextElement());
         }
-        String[] resultArray = new String[result.size()];
-        result.copyInto(resultArray);
-        return resultArray;
-
+        return result;
     }
 
 

==================================================
ApplicationContext.java
index bc4e0a58da..bf15c87d18 100644
--- a/java/org/apache/catalina/connector/ResponseFacade.java
+++ b/java/org/apache/catalina/connector/ResponseFacade.java
@@ -553,4 +553,19 @@ public class ResponseFacade
         response.setCharacterEncoding(arg0);
     }
 
+    public int getStatus() {
+        return response.getStatus();
+    }
+    
+    public String getHeader(String name) {
+        return response.getHeader(name);
+    }
+    
+    public Iterable<String> getHeaderNames() {
+        return response.getHeaderNames();
+    }
+    
+    public Iterable<String> getHeaders(String name) {
+        return response.getHeaders(name);
+    }
 }

==================================================
ApplicationContextFacade.java
index eb0270065a..7a3a07129f 100644
--- a/java/org/apache/catalina/core/ApplicationContext.java
+++ b/java/org/apache/catalina/core/ApplicationContext.java
@@ -34,13 +34,15 @@ import java.util.concurrent.ConcurrentHashMap;
 import javax.naming.Binding;
 import javax.naming.NamingException;
 import javax.naming.directory.DirContext;
-import javax.servlet.AsyncDispatcher;
-import javax.servlet.DispatcherType;
+import javax.servlet.Filter;
+import javax.servlet.FilterRegistration;
 import javax.servlet.RequestDispatcher;
 import javax.servlet.Servlet;
 import javax.servlet.ServletContext;
 import javax.servlet.ServletContextAttributeEvent;
 import javax.servlet.ServletContextAttributeListener;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration;
 import javax.servlet.SessionCookieConfig;
 import javax.servlet.SessionTrackingMode;
 
@@ -48,8 +50,6 @@ import org.apache.catalina.Context;
 import org.apache.catalina.Host;
 import org.apache.catalina.Wrapper;
 import org.apache.catalina.deploy.ApplicationParameter;
-import org.apache.catalina.deploy.FilterDef;
-import org.apache.catalina.deploy.FilterMap;
 import org.apache.catalina.util.Enumerator;
 import org.apache.catalina.util.RequestUtil;
 import org.apache.catalina.util.ResourceSet;
@@ -838,144 +838,146 @@ public class ApplicationContext
     }
 
 
-    public void addFilter(String filterName, String description,
-            String className, Map<String, String> initParameters)
-            throws IllegalArgumentException, IllegalStateException {
+    public FilterRegistration.Dynamic addFilter(String filterName,
+            String className) throws IllegalStateException {
+        
+        if (context.initialized) {
+            //TODO Spec breaking enhancement to ignore this restriction
+            throw new IllegalStateException(
+                    sm.getString("applicationContext.addFilter.ise",
+                            getContextPath()));
+        }
         
         if (context.findFilterDef(filterName) != null) {
-            throw new IllegalArgumentException(sm.getString(
-                    "applicationContext.addFilter.iae", filterName,
-                    getContextPath()));
+            return null;
         }
 
+        // TODO Servlet 3
+        return null;
+    }
+
+    
+    public FilterRegistration.Dynamic addFilter(String filterName,
+            Filter filter) throws IllegalStateException {
+        
         if (context.initialized) {
             //TODO Spec breaking enhancement to ignore this restriction
             throw new IllegalStateException(
                     sm.getString("applicationContext.addFilter.ise",
                             getContextPath()));
         }
-        FilterDef filterDef = new FilterDef();
-        filterDef.setFilterName(filterName);
-        filterDef.setDescription(description);
-        filterDef.setFilterClass(className);
-        filterDef.getParameterMap().putAll(initParameters);
-        context.addFilterDef(filterDef);
+        
+        if (context.findFilterDef(filterName) != null) {
+            return null;
+        }
+
+        // TODO Servlet 3
+        return null;
     }
 
     
-    public void addServlet(String servletName, String description,
-            String className, Map<String, String> initParameters,
-            int loadOnStartup)
-            throws IllegalArgumentException, IllegalStateException {
+    public FilterRegistration.Dynamic addFilter(String filterName,
+            Class<? extends Filter> filterClass) throws IllegalStateException {
         
-        if (context.findFilterDef(servletName) != null) {
-            throw new IllegalArgumentException(sm.getString(
-                    "applicationContext.addServlet.iae", servletName,
-                    getContextPath()));
-        }
-
         if (context.initialized) {
             //TODO Spec breaking enhancement to ignore this restriction
             throw new IllegalStateException(
-                    sm.getString("applicationContext.addServlet.ise",
+                    sm.getString("applicationContext.addFilter.ise",
                             getContextPath()));
         }
-        Wrapper wrapper = context.createWrapper();
-        wrapper.setName(servletName);
-        // Description is ignored
-        wrapper.setServletClass(className);
-        for (Map.Entry<String,String> initParam : initParameters.entrySet()) {
-            wrapper.addInitParameter(initParam.getKey(), initParam.getValue());
+        
+        if (context.findFilterDef(filterName) != null) {
+            return null;
         }
-        wrapper.setLoadOnStartup(loadOnStartup);
-        context.addChild(wrapper);
+
+        // TODO Servlet 3
+        return null;
     }
 
+    
+    public <T extends Filter> T createFilter(Class<T> c)
+    throws ServletException {
+        // TODO Servlet 3
+        return null;
+    }
 
-    public void addFilterMappingForServletNames(String filterName,
-            EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter,
-            String... servletNames)
-            throws IllegalArgumentException, IllegalStateException {
-        
-        if (servletNames == null || servletNames.length == 0) {
-            throw new IllegalArgumentException(sm.getString(
-                    "applicationContext.addFilterMapping.iae.servlet"));
-        }
 
+    public FilterRegistration findFilterRegistration(String filterName) {
+        // TODO Servlet 3.0
+        return null;
+    }
+    
+    public ServletRegistration.Dynmaic addServlet(String servletName,
+            String className) throws IllegalStateException {
+        
         if (context.initialized) {
             //TODO Spec breaking enhancement to ignore this restriction
-            throw new IllegalStateException(sm.getString(
-                    "applicationContext.addFilterMapping.ise",
-                    getContextPath()));
-        }
-        FilterMap filterMap = new FilterMap(); 
-        for (String servletName : servletNames) {
-            filterMap.addServletName(servletName);
-        }
-        filterMap.setFilterName(filterName);
-        for (DispatcherType dispatcherType: dispatcherTypes) {
-            filterMap.setDispatcher(dispatcherType.name());
+            throw new IllegalStateException(
+                    sm.getString("applicationContext.addServlet.ise",
+                            getContextPath()));
         }
-        if (isMatchAfter) {
-            context.addFilterMap(filterMap);
-        } else {
-            context.addFilterMapBefore(filterMap);
+
+        if (context.findChild(servletName) != null) {
+            return null;
         }
+
+        // TODO Servlet 3
+        return null;
     }
 
 
-    public void addFilterMappingForUrlPatterns(String filterName,
-            EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter,
-            String... urlPatterns)
-            throws IllegalArgumentException, IllegalStateException {
-        
-        if (urlPatterns == null || urlPatterns.length == 0) {
-            throw new IllegalArgumentException(sm.getString(
-                    "applicationContext.addFilterMapping.iae.url",
-                    getContextPath()));
-        }
+    public ServletRegistration.Dynmaic addServlet(String servletName,
+            Servlet servlet) throws IllegalStateException {
         
         if (context.initialized) {
             //TODO Spec breaking enhancement to ignore this restriction
-            throw new IllegalStateException(sm.getString(
-                    "applicationContext.addFilterMapping.ise",
-                    getContextPath()));
-        }
-        FilterMap filterMap = new FilterMap(); 
-        for (String urlPattern : urlPatterns) {
-            filterMap.addURLPattern(urlPattern);
-        }
-        filterMap.setFilterName(filterName);
-        for (DispatcherType dispatcherType: dispatcherTypes) {
-            filterMap.setDispatcher(dispatcherType.name());
+            throw new IllegalStateException(
+                    sm.getString("applicationContext.addServlet.ise",
+                            getContextPath()));
         }
-        if (isMatchAfter) {
-            context.addFilterMap(filterMap);
-        } else {
-            context.addFilterMapBefore(filterMap);
+
+        if (context.findChild(servletName) != null) {
+            return null;
         }
-    }
 
+        // TODO Servlet 3
+        return null;
+    }
 
-    public void addServletMapping(String servletName, String[] urlPatterns)
-            throws IllegalArgumentException, IllegalStateException {
-        if (urlPatterns == null || urlPatterns.length == 0) {
-            throw new IllegalArgumentException(sm.getString(
-                    "applicationContext.addServletMapping.iae"));
-        }
+    
+    public ServletRegistration.Dynmaic addServlet(String servletName,
+            Class <? extends Servlet> servletClass)
+    throws IllegalStateException {
         
         if (context.initialized) {
             //TODO Spec breaking enhancement to ignore this restriction
-            throw new IllegalStateException(sm.getString(
-                    "applicationContext.addServletMapping.ise", getContextPath()));
+            throw new IllegalStateException(
+                    sm.getString("applicationContext.addServlet.ise",
+                            getContextPath()));
         }
-        for (String urlPattern : urlPatterns) {
-            boolean jspWildCard = ("*.jsp".equals(urlPattern));
-            context.addServletMapping(servletName, urlPattern, jspWildCard);
+
+        if (context.findChild(servletName) != null) {
+            return null;
         }
+
+        // TODO Servlet 3
+        return null;
     }
 
 
+    public <T extends Servlet> T createServlet(Class<T> c)
+    throws ServletException {
+        // TODO Servlet 3
+        return null;
+    }
+
+
+    public ServletRegistration findServletRegistration(String servletName) {
+        // TODO Servlet 3.0
+        return null;
+    }
+    
+
     /**
      * By default {@link SessionTrackingMode#URL} is always supported, {@link
      * SessionTrackingMode#COOKIE} is supported unless the <code>cookies</code>
@@ -1016,20 +1018,6 @@ public class ApplicationContext
     }
 
 
-    public void setSessionCookieConfig(SessionCookieConfig sessionCookieConfig)
-            throws IllegalArgumentException {
-        
-        if (context.initialized) {
-            //TODO Spec breaking enhancement to ignore this restriction
-            throw new IllegalStateException(sm.getString(
-                    "applicationContext.setSessionCookieConfig.ise",
-                    getContextPath()));
-        }
-
-        this.sessionCookieConfig = sessionCookieConfig;
-    }
-
-
     /**
      * @throws IllegalStateException if the context has already been initialised
      * @throws IllegalArgumentException If SSL is requested in combination with
@@ -1067,11 +1055,12 @@ public class ApplicationContext
     }
 
 
-    public AsyncDispatcher getAsyncDispatcher(String path) {
-        // TODO SERVLET 3
-        return null;
+    public boolean setInitParameter(String name, String value) {
+        // TODO Servlet 3
+        return false;
     }
     
+    
     // -------------------------------------------------------- Package Methods
     protected StandardContext getContext() {
         return this.context;

==================================================
DummyRequest.java
index 0e19938e81..b9ef75130a 100644
--- a/java/org/apache/catalina/core/ApplicationContextFacade.java
+++ b/java/org/apache/catalina/core/ApplicationContextFacade.java
@@ -30,15 +30,15 @@ import java.security.PrivilegedExceptionAction;
 import java.util.EnumSet;
 import java.util.Enumeration;
 import java.util.HashMap;
-import java.util.Map;
 import java.util.Set;
 
-import javax.servlet.AsyncDispatcher;
-import javax.servlet.DispatcherType;
+import javax.servlet.Filter;
+import javax.servlet.FilterRegistration;
 import javax.servlet.RequestDispatcher;
 import javax.servlet.Servlet;
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration;
 import javax.servlet.SessionCookieConfig;
 import javax.servlet.SessionTrackingMode;
 
@@ -388,69 +388,114 @@ public final class ApplicationContextFacade
     }
 
        
-    public void addFilter(String filterName, String description,
-            String className, Map<String, String> initParameters) {
+    public FilterRegistration.Dynamic addFilter(String filterName,
+            String className) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
-            doPrivileged("addFilter", new Object[]{filterName, description,
-                    className, initParameters});
+            return (FilterRegistration.Dynamic) doPrivileged(
+                    "addFilter", new Object[]{filterName, className});
         } else {
-            context.addFilter(filterName, description, className,
-                    initParameters);
+            return context.addFilter(filterName, className);
         }
     }
 
 
-    public void addFilterMappingForServletNames(String filterName,
-            EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter,
-            String... servletNames) {
+    public FilterRegistration.Dynamic addFilter(String filterName,
+            Filter filter) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
-            doPrivileged("addFilterMappingForServletNames",
-                    new Object[]{filterName, dispatcherTypes,
-                    Boolean.valueOf(isMatchAfter), servletNames});
+            return (FilterRegistration.Dynamic) doPrivileged(
+                    "addFilter", new Object[]{filterName, filter});
         } else {
-            context.addFilterMappingForServletNames(filterName, dispatcherTypes,
-                    isMatchAfter, servletNames);
+            return context.addFilter(filterName, filter);
         }
     }
 
 
-    public void addFilterMappingForUrlPatterns(String filterName,
-            EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter,
-            String... urlPatterns) {
+    public FilterRegistration.Dynamic addFilter(String filterName,
+            Class<? extends Filter> filterClass) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
-            doPrivileged("addFilterMappingForUrlPatterns",
-                    new Object[]{filterName, dispatcherTypes,
-                    Boolean.valueOf(isMatchAfter), urlPatterns});
+            return (FilterRegistration.Dynamic) doPrivileged(
+                    "addFilter", new Object[]{filterName, filterClass});
         } else {
-            context.addFilterMappingForUrlPatterns(filterName, dispatcherTypes,
-                    isMatchAfter, urlPatterns);
+            return context.addFilter(filterName, filterClass);
         }
     }
 
 
-    public void addServlet(String servletName, String description,
-            String className, Map<String, String> initParameters,
-            int loadOnStartup) {
+    public <T extends Filter> T createFilter(Class<T> c)
+    throws ServletException {
         if (SecurityUtil.isPackageProtectionEnabled()) {
-            doPrivileged("addServlet", new Object[]{servletName, description,
-                    className, initParameters, Integer.valueOf(loadOnStartup)});
+            return (T) doPrivileged(
+                    "createFilter", new Object[]{c});
         } else {
-            context.addServlet(servletName, description, className, initParameters,
-                    loadOnStartup);
+            return context.createFilter(c);
+        }
+    }
+
+
+    public FilterRegistration findFilterRegistration(String filterName) {
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            return (FilterRegistration) doPrivileged(
+                    "findFilterRegistration", new Object[]{filterName});
+        } else {
+            return context.findFilterRegistration(filterName);
         }
     }
     
     
-    public void addServletMapping(String servletName, String[] urlPatterns) {
+    public ServletRegistration.Dynmaic addServlet(String servletName,
+            String className) {
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            return (ServletRegistration.Dynmaic) doPrivileged(
+                    "addServlet", new Object[]{servletName, className});
+        } else {
+            return context.addServlet(servletName, className);
+        }
+    }
+
+
+    public ServletRegistration.Dynmaic addServlet(String servletName,
+            Servlet servlet) {
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            return (ServletRegistration.Dynmaic) doPrivileged(
+                    "addServlet", new Object[]{servletName, servlet});
+        } else {
+            return context.addServlet(servletName, servlet);
+        }
+    }
+
+
+    public ServletRegistration.Dynmaic addServlet(String servletName,
+            Class <? extends Servlet> servletClass) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
-            doPrivileged("addServletMapping",
-                    new Object[]{servletName, urlPatterns});
+            return (ServletRegistration.Dynmaic) doPrivileged(
+                    "addServlet", new Object[]{servletName, servletClass});
         } else {
-            context.addServletMapping(servletName, urlPatterns);
+            return context.addServlet(servletName, servletClass);
         }
     }
 
 
+    public <T extends Servlet> T createServlet(Class<T> c)
+    throws ServletException {
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            return (T) doPrivileged(
+                    "createServlet", new Object[]{c});
+        } else {
+            return context.createServlet(c);
+        }
+    }
+
+    
+    public ServletRegistration findServletRegistration(String servletName) {
+        if (SecurityUtil.isPackageProtectionEnabled()) {
+            return (ServletRegistration) doPrivileged(
+                    "findServletRegistration", new Object[]{servletName});
+        } else {
+            return context.findServletRegistration(servletName);
+        }
+    }
+    
+    
     public EnumSet<SessionTrackingMode> getDefaultSessionTrackingModes() {
         if (SecurityUtil.isPackageProtectionEnabled()) {
             return (EnumSet<SessionTrackingMode>)
@@ -481,16 +526,6 @@ public final class ApplicationContextFacade
     }
 
 
-    public void setSessionCookieConfig(SessionCookieConfig sessionCookieConfig) {
-        if (SecurityUtil.isPackageProtectionEnabled()) {
-            doPrivileged("setSessionCookieConfig",
-                    new Object[]{sessionCookieConfig});
-        } else {
-            context.setSessionCookieConfig(sessionCookieConfig);
-        }
-    }
-
-
     public void setSessionTrackingModes(
             EnumSet<SessionTrackingMode> sessionTrackingModes) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
@@ -502,13 +537,12 @@ public final class ApplicationContextFacade
     }
 
 
-    public AsyncDispatcher getAsyncDispatcher(String path) {
+    public boolean setInitParameter(String name, String value) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
-            return (AsyncDispatcher)
-                doPrivileged("getAsyncDispatcher",
-                        new Object[]{path});
+            return ((Boolean) doPrivileged("setInitParameter",
+                    new Object[]{name, value})).booleanValue();
         } else {
-            return context.getAsyncDispatcher(path);
+            return context.setInitParameter(name, value);
         }
     }
     

==================================================
DummyResponse.java
index a710396d59..444340370f 100644
--- a/java/org/apache/catalina/core/DummyRequest.java
+++ b/java/org/apache/catalina/core/DummyRequest.java
@@ -30,17 +30,21 @@ import java.util.Iterator;
 import java.util.Locale;
 import java.util.Map;
 
-import javax.servlet.AsyncDispatcher;
+import javax.servlet.AsyncContext;
 import javax.servlet.AsyncListener;
+import javax.servlet.DispatcherType;
 import javax.servlet.FilterChain;
 import javax.servlet.RequestDispatcher;
 import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 import javax.servlet.ServletInputStream;
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 import javax.servlet.http.Cookie;
 import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import javax.servlet.http.HttpSession;
+import javax.servlet.http.Part;
 
 import org.apache.catalina.Context;
 import org.apache.catalina.Host;
@@ -282,11 +286,23 @@ public class DummyRequest
             ServletResponse res) {}
     public ServletContext getServletContext() { return null; }
     public boolean isAsyncStarted() { return false; }
-    public void doneAsync() {}
     public boolean isAsyncSupported() { return false; }
-    public void startAsync() throws IllegalStateException {}
-    public void startAsync(Runnable runnable) throws IllegalStateException {}
-    public AsyncDispatcher getAsyncDispatcher() { return null; }
-    public AsyncDispatcher getAsyncDispatcher(String path) { return null; }
+    public AsyncContext startAsync() throws IllegalStateException {
+        return null;
+    }
+    public Part getPart(String name) { return null; }
+    public Iterable<Part> getParts() { return null; }
+    public boolean login(HttpServletResponse response)
+    throws IOException, ServletException { return false; }
+    public void login(String username, String password)
+    throws ServletException {}
+    public void logout() throws ServletException {}
+    public void addAsyncListener(AsyncListener listener) {}
+    public AsyncContext getAsyncContext() { return null; }
+    public long getAsyncTimeout() { return 0; }
+    public DispatcherType getDispatcherType() { return null; }
+    public void setAsyncTimeout(long timeout) {}
+    public AsyncContext startAsync(ServletRequest servletRequest,
+            ServletResponse servletResponse) { return null; }
 }
 

==================================================
AccessLogValve.java
index 9d3e2c21ac..858dca159f 100644
--- a/java/org/apache/catalina/core/LocalStrings.properties
+++ b/java/org/apache/catalina/core/LocalStrings.properties
@@ -13,15 +13,8 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-applicationContext.addFilter.iae=The filter name {0} already exists in context {1}
 applicationContext.addFilter.ise=Filters can not be added to context {0} as the context has been initialised
-applicationContext.addFilterMapping.iae.servlet=The list of servletNames provided was null or empty
-applicationContext.addFilterMapping.iae.url=The list of urlPatterns provided was null or empty
-applicationContext.addFilterMapping.ise=Filter mappings can not be added to context {0} as the context has been initialised
-applicationContext.addServlet.iae=The servlet name {0} already exists in context {1}
 applicationContext.addServlet.ise=Servlets can not be added to context {0} as the context has been initialised
-applicationContext.addServletMapping.iae=The list of urlPatterns provided was null or empty
-applicationContext.addServletMapping.ise=Servlet mappings can not be added to context {0} as the context has been initialised
 applicationContext.attributeEvent=Exception thrown by attributes event listener
 applicationContext.mapping.error=Error during mapping
 applicationContext.requestDispatcher.iae=Path {0} does not start with a "/" character

==================================================
ExtendedAccessLogValve.java
index ebdef23c5a..4fba7e807e 100644
--- a/java/org/apache/catalina/valves/AccessLogValve.java
+++ b/java/org/apache/catalina/valves/AccessLogValve.java
@@ -28,6 +28,7 @@ import java.net.InetAddress;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Date;
+import java.util.Iterator;
 import java.util.List;
 import java.util.TimeZone;
 
@@ -1284,16 +1285,15 @@ public class AccessLogValve
         public void addElement(StringBuffer buf, Date date, Request request,
                 Response response, long time) {
            if (null != response) {
-                String[] values = response.getHeaderValues(header);
-                if(values.length > 0) {
-                    for (int i = 0; i < values.length; i++) {
-                        String string = values[i];
-                        buf.append(string) ;
-                        if(i+1<values.length)
-                            buf.append(",");
+                Iterator<String> iter = response.getHeaders(header).iterator();
+                boolean first = true;
+                while (iter.hasNext()) {
+                    if (!first) {
+                        buf.append(",");
                     }
-                    return ;
+                    buf.append(iter.next());
                 }
+                return ;
             }
             buf.append("-");
         }

==================================================
RequestDumperValve.java
index 0a1d97de12..af052bb232 100644
--- a/java/org/apache/catalina/valves/ExtendedAccessLogValve.java
+++ b/java/org/apache/catalina/valves/ExtendedAccessLogValve.java
@@ -26,6 +26,7 @@ import java.net.URLEncoder;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Date;
+import java.util.Iterator;
 import java.util.List;
 import java.util.TimeZone;
 
@@ -346,19 +347,20 @@ public class ExtendedAccessLogValve
         
         public void addElement(StringBuffer buf, Date date, Request request,
                 Response response, long time) {
-           if (null != response) {
-                String[] values = response.getHeaderValues(header);
-                if(values.length > 0) {
+            if (null != response) {
+                Iterator<String> iter = response.getHeaders(header).iterator();
+                if (iter.hasNext()) {
                     StringBuffer buffer = new StringBuffer();
-                    for (int i = 0; i < values.length; i++) {
-                        String string = values[i];
-                        buffer.append(string) ;
-                        if(i+1<values.length)
+                    boolean first = true;
+                    while (iter.hasNext()) {
+                        if (!first) {
                             buffer.append(",");
+                        }
+                        buffer.append(iter.next());
                     }
                     buf.append(wrap(buffer.toString()));
-                    return ;
                 }
+                return ;
             }
             buf.append("-");
         }

==================================================
JspCServletContext.java
index 2500fa3796..423bd337c9 100644
--- a/java/org/apache/catalina/valves/RequestDumperValve.java
+++ b/java/org/apache/catalina/valves/RequestDumperValve.java
@@ -161,11 +161,11 @@ public class RequestDumperValve
                 rcookies[i].getValue() + "; domain=" +
                 rcookies[i].getDomain() + "; path=" + rcookies[i].getPath());
         }
-        String rhnames[] = response.getHeaderNames();
-        for (int i = 0; i < rhnames.length; i++) {
-            String rhvalues[] = response.getHeaderValues(rhnames[i]);
-            for (int j = 0; j < rhvalues.length; j++)
-                log.info("            header=" + rhnames[i] + "=" + rhvalues[j]);
+        Iterable<String> rhnames = response.getHeaderNames();
+        for (String rhname : rhnames) {
+            Iterable<String> rhvalues = response.getHeaders(rhname);
+            for (String rhvalue : rhvalues)
+                log.info("            header=" + rhname + "=" + rhvalue);
         }
         log.info("           message=" + response.getMessage());
         log.info("        remoteUser=" + request.getRemoteUser());

==================================================
