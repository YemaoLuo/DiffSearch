e20760b5a15066c006da2144b30ab61cc80581d3
==================================================
Clean-up - formatting. No functional change.
==================================================
Mark Thomas
==================================================
Thu Feb 23 16:46:44 2023 +0000
==================================================
ClientAbortException.java
Clean-up - formatting. No functional change.


==================================================
Connector.java
index fa469f96ee..ca40f014d6 100644
--- a/java/org/apache/catalina/connector/ClientAbortException.java
+++ b/java/org/apache/catalina/connector/ClientAbortException.java
@@ -19,8 +19,7 @@ package org.apache.catalina.connector;
 import java.io.IOException;
 
 /**
- * Extend IOException to identify it as being caused by an abort of a request by
- * a remote client.
+ * Extend IOException to identify it as being caused by an abort of a request by a remote client.
  *
  * @author Glenn L. Nielsen
  */
@@ -29,7 +28,7 @@ public final class ClientAbortException extends IOException {
     private static final long serialVersionUID = 1L;
 
 
-    //------------------------------------------------------------ Constructors
+    // ------------------------------------------------------------ Constructors
 
     /**
      * Construct a new ClientAbortException with no other information.
@@ -60,10 +59,9 @@ public final class ClientAbortException extends IOException {
 
 
     /**
-     * Construct a new ClientAbortException for the specified message
-     * and throwable.
+     * Construct a new ClientAbortException for the specified message and throwable.
      *
-     * @param message Message describing this exception
+     * @param message   Message describing this exception
      * @param throwable Throwable that caused this exception
      */
     public ClientAbortException(String message, Throwable throwable) {

==================================================
CoyoteAdapter.java
index ad6fde7d32..2a41b9e326 100644
--- a/java/org/apache/catalina/connector/Connector.java
+++ b/java/org/apache/catalina/connector/Connector.java
@@ -52,7 +52,7 @@ import org.apache.tomcat.util.res.StringManager;
  * @author Craig R. McClanahan
  * @author Remy Maucherat
  */
-public class Connector extends LifecycleMBeanBase  {
+public class Connector extends LifecycleMBeanBase {
 
     private static final Log log = LogFactory.getLog(Connector.class);
 
@@ -76,8 +76,7 @@ public class Connector extends LifecycleMBeanBase  {
         try {
             p = ProtocolHandler.create(protocol);
         } catch (Exception e) {
-            log.error(sm.getString(
-                    "coyoteConnector.protocolHandlerInstantiationFailed"), e);
+            log.error(sm.getString("coyoteConnector.protocolHandlerInstantiationFailed"), e);
         }
         if (p != null) {
             protocolHandler = p;
@@ -109,9 +108,8 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * If this is <code>true</code> the '\' character will be permitted as a
-     * path delimiter. If not specified, the default value of
-     * <code>false</code> will be used.
+     * If this is <code>true</code> the '\' character will be permitted as a path delimiter. If not specified, the
+     * default value of <code>false</code> will be used.
      */
     protected boolean allowBackslash = false;
 
@@ -135,15 +133,11 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * If this is <code>true</code> then a call to
-     * <code>Response.getWriter()</code> if no character encoding
-     * has been specified will result in subsequent calls to
-     * <code>Response.getCharacterEncoding()</code> returning
-     * <code>ISO-8859-1</code> and the <code>Content-Type</code> response header
-     * will include a <code>charset=ISO-8859-1</code> component.
-     * (SRV.15.2.22.1)
-     * If not specified, the default specification compliant value of
-     * <code>true</code> will be used.
+     * If this is <code>true</code> then a call to <code>Response.getWriter()</code> if no character encoding has been
+     * specified will result in subsequent calls to <code>Response.getCharacterEncoding()</code> returning
+     * <code>ISO-8859-1</code> and the <code>Content-Type</code> response header will include a
+     * <code>charset=ISO-8859-1</code> component. (SRV.15.2.22.1) If not specified, the default specification compliant
+     * value of <code>true</code> will be used.
      */
     protected boolean enforceEncodingInGetWriter = true;
 
@@ -155,29 +149,25 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * The server name to which we should pretend requests to this Connector
-     * were directed.  This is useful when operating Tomcat behind a proxy
-     * server, so that redirects get constructed accurately.  If not specified,
-     * the server name included in the <code>Host</code> header is used.
+     * The server name to which we should pretend requests to this Connector were directed. This is useful when
+     * operating Tomcat behind a proxy server, so that redirects get constructed accurately. If not specified, the
+     * server name included in the <code>Host</code> header is used.
      */
     protected String proxyName = null;
 
 
     /**
-     * The server port to which we should pretend requests to this Connector
-     * were directed.  This is useful when operating Tomcat behind a proxy
-     * server, so that redirects get constructed accurately.  If not specified,
-     * the port number specified by the <code>port</code> property is used.
+     * The server port to which we should pretend requests to this Connector were directed. This is useful when
+     * operating Tomcat behind a proxy server, so that redirects get constructed accurately. If not specified, the port
+     * number specified by the <code>port</code> property is used.
      */
     protected int proxyPort = 0;
 
 
     /**
-     * The flag that controls recycling of the facades of the request
-     * processing objects. If set to <code>true</code> the object facades
-     * will be discarded when the request is recycled. If the security
-     * manager is enabled, this setting is ignored and object facades are
-     * always discarded.
+     * The flag that controls recycling of the facades of the request processing objects. If set to <code>true</code>
+     * the object facades will be discarded when the request is recycled. If the security manager is enabled, this
+     * setting is ignored and object facades are always discarded.
      */
     protected boolean discardFacades = true;
 
@@ -189,15 +179,13 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * The request scheme that will be set on all requests received
-     * through this connector.
+     * The request scheme that will be set on all requests received through this connector.
      */
     protected String scheme = "http";
 
 
     /**
-     * The secure connection flag that will be set on all requests received
-     * through this connector.
+     * The secure connection flag that will be set on all requests received through this connector.
      */
     protected boolean secure = false;
 
@@ -209,34 +197,30 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * The maximum number of cookies permitted for a request. Use a value less
-     * than zero for no limit. Defaults to 200.
+     * The maximum number of cookies permitted for a request. Use a value less than zero for no limit. Defaults to 200.
      */
     private int maxCookieCount = 200;
 
     /**
-     * The maximum number of parameters (GET plus POST) which will be
-     * automatically parsed by the container. 10000 by default. A value of less
-     * than 0 means no limit.
+     * The maximum number of parameters (GET plus POST) which will be automatically parsed by the container. 10000 by
+     * default. A value of less than 0 means no limit.
      */
     protected int maxParameterCount = 10000;
 
     /**
-     * Maximum size of a POST which will be automatically parsed by the
-     * container. 2MB by default.
+     * Maximum size of a POST which will be automatically parsed by the container. 2MB by default.
      */
     protected int maxPostSize = 2 * 1024 * 1024;
 
 
     /**
-     * Maximum size of a POST which will be saved by the container
-     * during authentication. 4kB by default
+     * Maximum size of a POST which will be saved by the container during authentication. 4kB by default
      */
     protected int maxSavePostSize = 4 * 1024;
 
     /**
-     * Comma-separated list of HTTP methods that will be parsed according
-     * to POST-style rules for application/x-www-form-urlencoded request bodies.
+     * Comma-separated list of HTTP methods that will be parsed according to POST-style rules for
+     * application/x-www-form-urlencoded request bodies.
      */
     protected String parseBodyMethods = "POST";
 
@@ -253,8 +237,7 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * Coyote Protocol handler class name.
-     * See {@link #Connector()} for current default.
+     * Coyote Protocol handler class name. See {@link #Connector()} for current default.
      */
     protected final String protocolHandlerClassName;
 
@@ -304,6 +287,7 @@ public class Connector extends LifecycleMBeanBase  {
      * Return a property from the protocol handler.
      *
      * @param name the property name
+     *
      * @return the property value
      */
     public Object getProperty(String name) {
@@ -317,8 +301,9 @@ public class Connector extends LifecycleMBeanBase  {
     /**
      * Set a property on the protocol handler.
      *
-     * @param name the property name
+     * @param name  the property name
      * @param value the property value
+     *
      * @return <code>true</code> if the property was successfully set
      */
     public boolean setProperty(String name, String value) {
@@ -348,8 +333,7 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * @return <code>true</code> if backslash characters are allowed in URLs.
-     *   Default value is <code>false</code>.
+     * @return <code>true</code> if backslash characters are allowed in URLs. Default value is <code>false</code>.
      */
     public boolean getAllowBackslash() {
         return allowBackslash;
@@ -358,6 +342,7 @@ public class Connector extends LifecycleMBeanBase  {
 
     /**
      * Set the allowBackslash flag.
+     *
      * @param allowBackslash the new flag value
      */
     public void setAllowBackslash(boolean allowBackslash) {
@@ -366,8 +351,7 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * @return <code>true</code> if the TRACE method is allowed. Default value
-     *         is <code>false</code>.
+     * @return <code>true</code> if the TRACE method is allowed. Default value is <code>false</code>.
      */
     public boolean getAllowTrace() {
         return this.allowTrace;
@@ -398,7 +382,7 @@ public class Connector extends LifecycleMBeanBase  {
      * @param asyncTimeout The new timeout in ms.
      */
     public void setAsyncTimeout(long asyncTimeout) {
-        this.asyncTimeout= asyncTimeout;
+        this.asyncTimeout = asyncTimeout;
     }
 
 
@@ -412,6 +396,7 @@ public class Connector extends LifecycleMBeanBase  {
 
     /**
      * Set the recycling strategy for the object facades.
+     *
      * @param discardFacades the new value of the flag
      */
     public void setDiscardFacades(boolean discardFacades) {
@@ -438,8 +423,7 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * @return <code>true</code> if a default character encoding will be set
-     *   when calling Response.getWriter()
+     * @return <code>true</code> if a default character encoding will be set when calling Response.getWriter()
      */
     public boolean getEnforceEncodingInGetWriter() {
         return enforceEncodingInGetWriter;
@@ -448,6 +432,7 @@ public class Connector extends LifecycleMBeanBase  {
 
     /**
      * Set the enforceEncodingInGetWriter flag.
+     *
      * @param enforceEncodingInGetWriter the new flag value
      */
     public void setEnforceEncodingInGetWriter(boolean enforceEncodingInGetWriter) {
@@ -466,9 +451,8 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * @return the maximum number of parameters (GET plus POST) that will be
-     * automatically parsed by the container. A value of less than 0 means no
-     * limit.
+     * @return the maximum number of parameters (GET plus POST) that will be automatically parsed by the container. A
+     *             value of less than 0 means no limit.
      */
     public int getMaxParameterCount() {
         return maxParameterCount;
@@ -476,9 +460,8 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * Set the maximum number of parameters (GET plus POST) that will be
-     * automatically parsed by the container. A value of less than 0 means no
-     * limit.
+     * Set the maximum number of parameters (GET plus POST) that will be automatically parsed by the container. A value
+     * of less than 0 means no limit.
      *
      * @param maxParameterCount The new setting
      */
@@ -488,8 +471,7 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * @return the maximum size of a POST which will be automatically
-     * parsed by the container.
+     * @return the maximum size of a POST which will be automatically parsed by the container.
      */
     public int getMaxPostSize() {
         return maxPostSize;
@@ -497,11 +479,9 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * Set the maximum size of a POST which will be automatically
-     * parsed by the container.
+     * Set the maximum size of a POST which will be automatically parsed by the container.
      *
-     * @param maxPostSize The new maximum size in bytes of a POST which will
-     * be automatically parsed by the container
+     * @param maxPostSize The new maximum size in bytes of a POST which will be automatically parsed by the container
      */
     public void setMaxPostSize(int maxPostSize) {
         this.maxPostSize = maxPostSize;
@@ -509,8 +489,7 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * @return the maximum size of a POST which will be saved by the container
-     * during authentication.
+     * @return the maximum size of a POST which will be saved by the container during authentication.
      */
     public int getMaxSavePostSize() {
         return maxSavePostSize;
@@ -518,11 +497,10 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * Set the maximum size of a POST which will be saved by the container
-     * during authentication.
+     * Set the maximum size of a POST which will be saved by the container during authentication.
      *
-     * @param maxSavePostSize The new maximum size in bytes of a POST which will
-     * be saved by the container during authentication.
+     * @param maxSavePostSize The new maximum size in bytes of a POST which will be saved by the container during
+     *                            authentication.
      */
     public void setMaxSavePostSize(int maxSavePostSize) {
         this.maxSavePostSize = maxSavePostSize;
@@ -539,8 +517,7 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * Set list of HTTP methods which should allow body parameter
-     * parsing. This defaults to <code>POST</code>.
+     * Set list of HTTP methods which should allow body parameter parsing. This defaults to <code>POST</code>.
      *
      * @param methods Comma separated list of HTTP method names
      */
@@ -567,9 +544,8 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * @return the port number on which this connector is configured to listen
-     * for requests. The special value of 0 means select a random free port
-     * when the socket is bound.
+     * @return the port number on which this connector is configured to listen for requests. The special value of 0
+     *             means select a random free port when the socket is bound.
      */
     public int getPort() {
         // Try shortcut that should work for nearly all uses first as it does
@@ -629,9 +605,8 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * @return the port number on which this connector is listening to requests.
-     * If the special value for {@link #getPort} of zero is used then this method
-     * will report the actual port bound.
+     * @return the port number on which this connector is listening to requests. If the special value for
+     *             {@link #getPort} of zero is used then this method will report the actual port bound.
      */
     public int getLocalPort() {
         return ((Integer) getProperty("localPort")).intValue();
@@ -677,7 +652,7 @@ public class Connector extends LifecycleMBeanBase  {
      */
     public void setProxyName(String proxyName) {
 
-        if(proxyName != null && proxyName.length() > 0) {
+        if (proxyName != null && proxyName.length() > 0) {
             this.proxyName = proxyName;
         } else {
             this.proxyName = null;
@@ -704,9 +679,8 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * @return the port number to which a request should be redirected if
-     * it comes in on a non-SSL port and is subject to a security constraint
-     * with a transport guarantee that requires SSL.
+     * @return the port number to which a request should be redirected if it comes in on a non-SSL port and is subject
+     *             to a security constraint with a transport guarantee that requires SSL.
      */
     public int getRedirectPort() {
         return this.redirectPort;
@@ -729,8 +703,7 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * @return the scheme that will be assigned to requests received
-     * through this connector.  Default value is "http".
+     * @return the scheme that will be assigned to requests received through this connector. Default value is "http".
      */
     public String getScheme() {
         return this.scheme;
@@ -738,8 +711,7 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * Set the scheme that will be assigned to requests received through
-     * this connector.
+     * Set the scheme that will be assigned to requests received through this connector.
      *
      * @param scheme The new scheme
      */
@@ -749,8 +721,8 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * @return the secure connection flag that will be assigned to requests
-     * received through this connector.  Default value is "false".
+     * @return the secure connection flag that will be assigned to requests received through this connector. Default
+     *             value is "false".
      */
     public boolean getSecure() {
         return this.secure;
@@ -758,8 +730,7 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * Set the secure connection flag that will be assigned to requests
-     * received through this connector.
+     * Set the secure connection flag that will be assigned to requests received through this connector.
      *
      * @param secure The new secure connection flag
      */
@@ -770,8 +741,7 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * @return the name of character encoding to be used for the URI using the
-     * original case.
+     * @return the name of character encoding to be used for the URI using the original case.
      */
     public String getURIEncoding() {
         return uriCharset.name();
@@ -779,8 +749,7 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * @return The Charset to use to convert raw URI bytes (after %nn decoding)
-     *         to characters. This will never be null
+     * @return The Charset to use to convert raw URI bytes (after %nn decoding) to characters. This will never be null
      */
     public Charset getURICharset() {
         return uriCharset;
@@ -793,12 +762,12 @@ public class Connector extends LifecycleMBeanBase  {
      */
     public void setURIEncoding(String URIEncoding) {
         try {
-             Charset charset = B2CConverter.getCharset(URIEncoding);
-             if (!CharsetUtil.isAsciiSuperset(charset)) {
-                 log.error(sm.getString("coyoteConnector.notAsciiSuperset", URIEncoding, uriCharset.name()));
-                 return;
-             }
-             uriCharset = charset;
+            Charset charset = B2CConverter.getCharset(URIEncoding);
+            if (!CharsetUtil.isAsciiSuperset(charset)) {
+                log.error(sm.getString("coyoteConnector.notAsciiSuperset", URIEncoding, uriCharset.name()));
+                return;
+            }
+            uriCharset = charset;
         } catch (UnsupportedEncodingException e) {
             log.error(sm.getString("coyoteConnector.invalidEncoding", URIEncoding, uriCharset.name()), e);
         }
@@ -823,11 +792,10 @@ public class Connector extends LifecycleMBeanBase  {
     }
 
     /**
-     * Indicates whether the generation of an X-Powered-By response header for
-     * Servlet-generated responses is enabled or disabled for this Connector.
+     * Indicates whether the generation of an X-Powered-By response header for Servlet-generated responses is enabled or
+     * disabled for this Connector.
      *
-     * @return <code>true</code> if generation of X-Powered-By response header is enabled,
-     * false otherwise
+     * @return <code>true</code> if generation of X-Powered-By response header is enabled, false otherwise
      */
     public boolean getXpoweredBy() {
         return xpoweredBy;
@@ -835,12 +803,10 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * Enables or disables the generation of an X-Powered-By header (with value
-     * Servlet/2.5) for all servlet-generated responses returned by this
-     * Connector.
+     * Enables or disables the generation of an X-Powered-By header (with value Servlet/2.5) for all servlet-generated
+     * responses returned by this Connector.
      *
-     * @param xpoweredBy true if generation of X-Powered-By response header is
-     * to be enabled, false otherwise
+     * @param xpoweredBy true if generation of X-Powered-By response header is to be enabled, false otherwise
      */
     public void setXpoweredBy(boolean xpoweredBy) {
         this.xpoweredBy = xpoweredBy;
@@ -850,8 +816,8 @@ public class Connector extends LifecycleMBeanBase  {
     /**
      * Enable the use of IP-based virtual hosting.
      *
-     * @param useIPVHosts <code>true</code> if Hosts are identified by IP,
-     *                    <code>false</code> if Hosts are identified by name.
+     * @param useIPVHosts <code>true</code> if Hosts are identified by IP, <code>false</code> if Hosts are identified by
+     *                        name.
      */
     public void setUseIPVHosts(boolean useIPVHosts) {
         this.useIPVHosts = useIPVHosts;
@@ -925,8 +891,8 @@ public class Connector extends LifecycleMBeanBase  {
     // --------------------------------------------------------- Public Methods
 
     /**
-     * Create (or allocate) and return a Request object suitable for
-     * specifying the contents of a Request to the responsible Container.
+     * Create (or allocate) and return a Request object suitable for specifying the contents of a Request to the
+     * responsible Container.
      *
      * @return a new Servlet request object
      */
@@ -936,8 +902,8 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * Create (or allocate) and return a Response object suitable for
-     * receiving the contents of a Response from the responsible Container.
+     * Create (or allocate) and return a Response object suitable for receiving the contents of a Response from the
+     * responsible Container.
      *
      * @return a new Servlet response object
      */
@@ -1020,8 +986,7 @@ public class Connector extends LifecycleMBeanBase  {
         super.initInternal();
 
         if (protocolHandler == null) {
-            throw new LifecycleException(
-                    sm.getString("coyoteConnector.protocolHandlerInstantiationFailed"));
+            throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerInstantiationFailed"));
         }
 
         // Initialize adapter
@@ -1038,10 +1003,8 @@ public class Connector extends LifecycleMBeanBase  {
 
         if (AprStatus.isAprAvailable() && AprStatus.getUseOpenSSL() &&
                 protocolHandler instanceof AbstractHttp11Protocol) {
-            AbstractHttp11Protocol<?> jsseProtocolHandler =
-                    (AbstractHttp11Protocol<?>) protocolHandler;
-            if (jsseProtocolHandler.isSSLEnabled() &&
-                    jsseProtocolHandler.getSslImplementationName() == null) {
+            AbstractHttp11Protocol<?> jsseProtocolHandler = (AbstractHttp11Protocol<?>) protocolHandler;
+            if (jsseProtocolHandler.isSSLEnabled() && jsseProtocolHandler.getSslImplementationName() == null) {
                 // OpenSSL is compatible with the JSSE configuration, so use it if APR is available
                 jsseProtocolHandler.setSslImplementationName(OpenSSLImplementation.class.getName());
             }
@@ -1050,8 +1013,7 @@ public class Connector extends LifecycleMBeanBase  {
         try {
             protocolHandler.init();
         } catch (Exception e) {
-            throw new LifecycleException(
-                    sm.getString("coyoteConnector.protocolHandlerInitializationFailed"), e);
+            throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerInitializationFailed"), e);
         }
     }
 
@@ -1067,8 +1029,8 @@ public class Connector extends LifecycleMBeanBase  {
         // Validate settings before starting
         String id = (protocolHandler != null) ? protocolHandler.getId() : null;
         if (id == null && getPortWithOffset() < 0) {
-            throw new LifecycleException(sm.getString(
-                    "coyoteConnector.invalidPort", Integer.valueOf(getPortWithOffset())));
+            throw new LifecycleException(
+                    sm.getString("coyoteConnector.invalidPort", Integer.valueOf(getPortWithOffset())));
         }
 
         setState(LifecycleState.STARTING);
@@ -1076,8 +1038,7 @@ public class Connector extends LifecycleMBeanBase  {
         try {
             protocolHandler.start();
         } catch (Exception e) {
-            throw new LifecycleException(
-                    sm.getString("coyoteConnector.protocolHandlerStartFailed"), e);
+            throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerStartFailed"), e);
         }
     }
 
@@ -1097,8 +1058,7 @@ public class Connector extends LifecycleMBeanBase  {
                 protocolHandler.stop();
             }
         } catch (Exception e) {
-            throw new LifecycleException(
-                    sm.getString("coyoteConnector.protocolHandlerStopFailed"), e);
+            throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerStopFailed"), e);
         }
     }
 
@@ -1110,8 +1070,7 @@ public class Connector extends LifecycleMBeanBase  {
                 protocolHandler.destroy();
             }
         } catch (Exception e) {
-            throw new LifecycleException(
-                    sm.getString("coyoteConnector.protocolHandlerDestroyFailed"), e);
+            throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerDestroyFailed"), e);
         }
 
         if (getService() != null) {
@@ -1123,8 +1082,8 @@ public class Connector extends LifecycleMBeanBase  {
 
 
     /**
-     * Provide a useful toString() implementation as it may be used when logging
-     * Lifecycle errors to identify the component.
+     * Provide a useful toString() implementation as it may be used when logging Lifecycle errors to identify the
+     * component.
      */
     @Override
     public String toString() {
@@ -1149,7 +1108,7 @@ public class Connector extends LifecycleMBeanBase  {
     }
 
 
-    // -------------------- JMX registration  --------------------
+    // -------------------- JMX registration --------------------
 
     @Override
     protected String getDomainInternal() {

==================================================
CoyoteInputStream.java
index d13cefc327..54c3185cec 100644
--- a/java/org/apache/catalina/connector/CoyoteAdapter.java
+++ b/java/org/apache/catalina/connector/CoyoteAdapter.java
@@ -56,8 +56,7 @@ import org.apache.tomcat.util.res.StringManager;
 
 
 /**
- * Implementation of a request processor which delegates the processing to a
- * Coyote processor.
+ * Implementation of a request processor which delegates the processing to a Coyote processor.
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
@@ -68,19 +67,16 @@ public class CoyoteAdapter implements Adapter {
 
     // -------------------------------------------------------------- Constants
 
-    private static final String POWERED_BY = "Servlet/6.1 JSP/4.0 " +
-            "(" + ServerInfo.getServerInfo() + " Java/" +
-            System.getProperty("java.vm.vendor") + "/" +
-            System.getProperty("java.runtime.version") + ")";
+    private static final String POWERED_BY = "Servlet/6.1 JSP/4.0 " + "(" + ServerInfo.getServerInfo() + " Java/" +
+            System.getProperty("java.vm.vendor") + "/" + System.getProperty("java.runtime.version") + ")";
 
-    private static final EnumSet<SessionTrackingMode> SSL_ONLY =
-        EnumSet.of(SessionTrackingMode.SSL);
+    private static final EnumSet<SessionTrackingMode> SSL_ONLY = EnumSet.of(SessionTrackingMode.SSL);
 
     public static final int ADAPTER_NOTES = 1;
 
 
-    private static final ThreadLocal<String> THREAD_NAME =
-            ThreadLocal.withInitial(() -> Thread.currentThread().getName());
+    private static final ThreadLocal<String> THREAD_NAME = ThreadLocal
+            .withInitial(() -> Thread.currentThread().getName());
 
     // ----------------------------------------------------------- Constructors
 
@@ -116,8 +112,8 @@ public class CoyoteAdapter implements Adapter {
     // -------------------------------------------------------- Adapter Methods
 
     @Override
-    public boolean asyncDispatch(org.apache.coyote.Request req, org.apache.coyote.Response res,
-            SocketEvent status) throws Exception {
+    public boolean asyncDispatch(org.apache.coyote.Request req, org.apache.coyote.Response res, SocketEvent status)
+            throws Exception {
 
         Request request = (Request) req.getNote(ADAPTER_NOTES);
         Response response = (Response) res.getNote(ADAPTER_NOTES);
@@ -140,16 +136,16 @@ public class CoyoteAdapter implements Adapter {
                 response.setSuspended(false);
             }
 
-            if (status==SocketEvent.TIMEOUT) {
+            if (status == SocketEvent.TIMEOUT) {
                 if (!asyncConImpl.timeout()) {
                     asyncConImpl.setErrorState(null, false);
                 }
-            } else if (status==SocketEvent.ERROR) {
+            } else if (status == SocketEvent.ERROR) {
                 // An I/O error occurred on a non-container thread which means
                 // that the socket needs to be closed so set success to false to
                 // trigger a close
                 success = false;
-                Throwable t = (Throwable)req.getAttribute(RequestDispatcher.ERROR_EXCEPTION);
+                Throwable t = (Throwable) req.getAttribute(RequestDispatcher.ERROR_EXCEPTION);
                 Context context = request.getContext();
                 ClassLoader oldCL = null;
                 try {
@@ -177,8 +173,7 @@ public class CoyoteAdapter implements Adapter {
                     try {
                         oldCL = context.bind(null);
                         res.onWritePossible();
-                        if (request.isFinished() && req.sendAllDataReadEvent() &&
-                                readListener != null) {
+                        if (request.isFinished() && req.sendAllDataReadEvent() && readListener != null) {
                             readListener.onAllDataRead();
                         }
                         // User code may have swallowed an IOException
@@ -237,15 +232,12 @@ public class CoyoteAdapter implements Adapter {
             // Has an error occurred during async processing that needs to be
             // processed by the application's error page mechanism (or Tomcat's
             // if the application doesn't define one)?
-            if (!request.isAsyncDispatching() && request.isAsync() &&
-                    response.isErrorReportRequired()) {
-                connector.getService().getContainer().getPipeline().getFirst().invoke(
-                        request, response);
+            if (!request.isAsyncDispatching() && request.isAsync() && response.isErrorReportRequired()) {
+                connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
             }
 
             if (request.isAsyncDispatching()) {
-                connector.getService().getContainer().getPipeline().getFirst().invoke(
-                        request, response);
+                connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
                 Throwable t = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);
                 if (t != null) {
                     asyncConImpl.setErrorState(t, true);
@@ -266,7 +258,7 @@ public class CoyoteAdapter implements Adapter {
                     // Connection will be forcibly closed which will prevent
                     // completion happening at the usual point. Need to trigger
                     // call to onComplete() here.
-                    res.action(ActionCode.ASYNC_POST_PROCESS,  null);
+                    res.action(ActionCode.ASYNC_POST_PROCESS, null);
                 }
                 success = false;
             }
@@ -310,8 +302,7 @@ public class CoyoteAdapter implements Adapter {
 
 
     @Override
-    public void service(org.apache.coyote.Request req, org.apache.coyote.Response res)
-            throws Exception {
+    public void service(org.apache.coyote.Request req, org.apache.coyote.Response res) throws Exception {
 
         Request request = (Request) req.getNote(ADAPTER_NOTES);
         Response response = (Response) res.getNote(ADAPTER_NOTES);
@@ -350,12 +341,10 @@ public class CoyoteAdapter implements Adapter {
             // request parameters
             postParseSuccess = postParseRequest(req, request, res, response);
             if (postParseSuccess) {
-                //check valves if we support async
-                request.setAsyncSupported(
-                        connector.getService().getContainer().getPipeline().isAsyncSupported());
+                // check valves if we support async
+                request.setAsyncSupported(connector.getService().getContainer().getPipeline().isAsyncSupported());
                 // Calling the container
-                connector.getService().getContainer().getPipeline().getFirst().invoke(
-                        request, response);
+                connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
             }
             if (request.isAsync()) {
                 async = true;
@@ -374,8 +363,7 @@ public class CoyoteAdapter implements Adapter {
                     }
                 }
 
-                Throwable throwable =
-                        (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);
+                Throwable throwable = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);
 
                 // If an async request was started, is not going to end once
                 // this container thread finishes and an error occurred, trigger
@@ -398,7 +386,7 @@ public class CoyoteAdapter implements Adapter {
                 // Connection will be forcibly closed which will prevent
                 // completion happening at the usual point. Need to trigger
                 // call to onComplete() here.
-                res.action(ActionCode.ASYNC_POST_PROCESS,  null);
+                res.action(ActionCode.ASYNC_POST_PROCESS, null);
                 async = false;
             }
 
@@ -423,8 +411,7 @@ public class CoyoteAdapter implements Adapter {
                     if (host != null) {
                         host.logAccess(request, response, time, false);
                     } else {
-                        connector.getService().getContainer().logAccess(
-                                request, response, time, false);
+                        connector.getService().getContainer().logAccess(request, response, time, false);
                     }
                 }
             }
@@ -463,8 +450,7 @@ public class CoyoteAdapter implements Adapter {
 
 
     @Override
-    public void log(org.apache.coyote.Request req,
-            org.apache.coyote.Response res, long time) {
+    public void log(org.apache.coyote.Request req, org.apache.coyote.Response res, long time) {
 
         Request request = (Request) req.getNote(ADAPTER_NOTES);
         Response response = (Response) res.getNote(ADAPTER_NOTES);
@@ -520,8 +506,7 @@ public class CoyoteAdapter implements Adapter {
     }
 
     @Override
-    public void checkRecycled(org.apache.coyote.Request req,
-            org.apache.coyote.Response res) {
+    public void checkRecycled(org.apache.coyote.Request req, org.apache.coyote.Response res) {
         Request request = (Request) req.getNote(ADAPTER_NOTES);
         Response response = (Response) res.getNote(ADAPTER_NOTES);
         String messageKey = null;
@@ -537,16 +522,14 @@ public class CoyoteAdapter implements Adapter {
 
             if (connector.getState().isAvailable()) {
                 if (log.isInfoEnabled()) {
-                    log.info(sm.getString(messageKey),
-                            new RecycleRequiredException());
+                    log.info(sm.getString(messageKey), new RecycleRequiredException());
                 }
             } else {
                 // There may be some aborted requests.
                 // When connector shuts down, the request and response will not
                 // be reused, so there is no issue to warn about here.
                 if (log.isDebugEnabled()) {
-                    log.debug(sm.getString(messageKey),
-                            new RecycleRequiredException());
+                    log.debug(sm.getString(messageKey), new RecycleRequiredException());
                 }
             }
         }
@@ -562,25 +545,22 @@ public class CoyoteAdapter implements Adapter {
     // ------------------------------------------------------ Protected Methods
 
     /**
-     * Perform the necessary processing after the HTTP headers have been parsed
-     * to enable the request/response pair to be passed to the start of the
-     * container pipeline for processing.
+     * Perform the necessary processing after the HTTP headers have been parsed to enable the request/response pair to
+     * be passed to the start of the container pipeline for processing.
      *
      * @param req      The coyote request object
      * @param request  The catalina request object
      * @param res      The coyote response object
      * @param response The catalina response object
      *
-     * @return <code>true</code> if the request should be passed on to the start
-     *         of the container pipeline, otherwise <code>false</code>
+     * @return <code>true</code> if the request should be passed on to the start of the container pipeline, otherwise
+     *             <code>false</code>
      *
-     * @throws IOException If there is insufficient space in a buffer while
-     *                     processing headers
-     * @throws ServletException If the supported methods of the target servlet
-     *                          cannot be determined
+     * @throws IOException      If there is insufficient space in a buffer while processing headers
+     * @throws ServletException If the supported methods of the target servlet cannot be determined
      */
-    protected boolean postParseRequest(org.apache.coyote.Request req, Request request,
-            org.apache.coyote.Response res, Response response) throws IOException, ServletException {
+    protected boolean postParseRequest(org.apache.coyote.Request req, Request request, org.apache.coyote.Response res,
+            Response response) throws IOException, ServletException {
 
         // If the processor has set the scheme (AJP does this, HTTP does this if
         // SSL is enabled) use this to set the secure flag as well. If the
@@ -656,7 +636,8 @@ public class CoyoteAdapter implements Adapter {
                 // URI decoding
                 // %xx decoding of the URL
                 try {
-                    req.getURLDecoder().convert(decodedURI.getByteChunk(), connector.getEncodedSolidusHandlingInternal());
+                    req.getURLDecoder().convert(decodedURI.getByteChunk(),
+                            connector.getEncodedSolidusHandlingInternal());
                 } catch (IOException ioe) {
                     response.sendError(400, sm.getString("coyoteAdapter.invalidURIWithMessage", ioe.getMessage()));
                 }
@@ -671,14 +652,11 @@ public class CoyoteAdapter implements Adapter {
                     response.sendError(400, sm.getString("coyoteAdapter.invalidURI"));
                 }
             } else {
-                /* The URI is chars or String, and has been sent using an in-memory
-                 * protocol handler. The following assumptions are made:
-                 * - req.requestURI() has been set to the 'original' non-decoded,
-                 *   non-normalized URI
-                 * - req.decodedURI() has been set to the decoded, normalized form
-                 *   of req.requestURI()
-                 * - 'suspicious' URI filtering - if required - has already been
-                 *   performed
+                /*
+                 * The URI is chars or String, and has been sent using an in-memory protocol handler. The following
+                 * assumptions are made: - req.requestURI() has been set to the 'original' non-decoded, non-normalized
+                 * URI - req.decodedURI() has been set to the decoded, normalized form of req.requestURI() -
+                 * 'suspicious' URI filtering - if required - has already been performed
                  */
                 decodedURI.toChars();
                 // Remove all path parameters; any needed path parameter should be set
@@ -718,8 +696,7 @@ public class CoyoteAdapter implements Adapter {
 
         while (mapRequired) {
             // This will map the the latest version by default
-            connector.getService().getMapper().map(serverName, decodedURI,
-                    version, request.getMappingData());
+            connector.getService().getMapper().map(serverName, decodedURI, version, request.getMappingData());
 
             // If there is no context at this point, either this is a 404
             // because no ROOT context has been deployed or the URI was invalid
@@ -739,13 +716,10 @@ public class CoyoteAdapter implements Adapter {
             // (if any). Need to do this before we redirect in case we need to
             // include the session id in the redirect
             String sessionID;
-            if (request.getServletContext().getEffectiveSessionTrackingModes()
-                    .contains(SessionTrackingMode.URL)) {
+            if (request.getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.URL)) {
 
                 // Get the session ID if there was one
-                sessionID = request.getPathParameter(
-                        SessionConfig.getSessionUriParamName(
-                                request.getContext()));
+                sessionID = request.getPathParameter(SessionConfig.getSessionUriParamName(request.getContext()));
                 if (sessionID != null) {
                     request.setRequestedSessionId(sessionID);
                     request.setRequestedSessionURL(true);
@@ -822,16 +796,13 @@ public class CoyoteAdapter implements Adapter {
         // Possible redirect
         MessageBytes redirectPathMB = request.getMappingData().redirectPath;
         if (!redirectPathMB.isNull()) {
-            String redirectPath = URLEncoder.DEFAULT.encode(
-                    redirectPathMB.toString(), StandardCharsets.UTF_8);
+            String redirectPath = URLEncoder.DEFAULT.encode(redirectPathMB.toString(), StandardCharsets.UTF_8);
             String query = request.getQueryString();
             if (request.isRequestedSessionIdFromURL()) {
                 // This is not optimal, but as this is not very common, it
                 // shouldn't matter
-                redirectPath = redirectPath + ";" +
-                        SessionConfig.getSessionUriParamName(
-                            request.getContext()) +
-                    "=" + request.getRequestedSessionId();
+                redirectPath = redirectPath + ";" + SessionConfig.getSessionUriParamName(request.getContext()) + "=" +
+                        request.getRequestedSessionId();
             }
             if (query != null) {
                 // This is not optimal, but as this is not very common, it
@@ -844,8 +815,7 @@ public class CoyoteAdapter implements Adapter {
         }
 
         // Filter TRACE method
-        if (!connector.getAllowTrace()
-                && req.method().equalsIgnoreCase("TRACE")) {
+        if (!connector.getAllowTrace() && req.method().equalsIgnoreCase("TRACE")) {
             Wrapper wrapper = request.getWrapper();
             String header = null;
             if (wrapper != null) {
@@ -892,8 +862,7 @@ public class CoyoteAdapter implements Adapter {
                     }
                     // Custom authenticator that may not trigger authorization.
                     // Do the authorization here to make sure it is done.
-                    request.setUserPrincipal(
-                            request.getContext().getRealm().authenticate(username));
+                    request.setUserPrincipal(request.getContext().getRealm().authenticate(username));
                 }
                 // If the Authenticator is an instance of AuthenticatorBase then
                 // it will check req.getRemoteUserNeedsAuthorization() and
@@ -915,16 +884,14 @@ public class CoyoteAdapter implements Adapter {
 
 
     /**
-     * Extract the path parameters from the request. This assumes parameters are
-     * of the form /path;name=value;name2=value2/ etc. Currently only really
-     * interested in the session ID that will be in this form. Other parameters
-     * can safely be ignored.
+     * Extract the path parameters from the request. This assumes parameters are of the form
+     * /path;name=value;name2=value2/ etc. Currently only really interested in the session ID that will be in this form.
+     * Other parameters can safely be ignored.
      *
-     * @param req The Coyote request object
+     * @param req     The Coyote request object
      * @param request The Servlet request object
      */
-    protected void parsePathParameters(org.apache.coyote.Request req,
-            Request request) {
+    protected void parsePathParameters(org.apache.coyote.Request req, Request request) {
 
         // Process in bytes (this is default format so this is normally a NO-OP
         req.decodedURI().toBytes();
@@ -945,10 +912,8 @@ public class CoyoteAdapter implements Adapter {
         Charset charset = connector.getURICharset();
 
         if (log.isDebugEnabled()) {
-            log.debug(sm.getString("coyoteAdapter.debug", "uriBC",
-                    uriBC.toString()));
-            log.debug(sm.getString("coyoteAdapter.debug", "semicolon",
-                    String.valueOf(semicolon)));
+            log.debug(sm.getString("coyoteAdapter.debug", "uriBC", uriBC.toString()));
+            log.debug(sm.getString("coyoteAdapter.debug", "semicolon", String.valueOf(semicolon)));
             log.debug(sm.getString("coyoteAdapter.debug", "enc", charset.name()));
         }
 
@@ -958,38 +923,31 @@ public class CoyoteAdapter implements Adapter {
             int end = uriBC.getEnd();
 
             int pathParamStart = semicolon + 1;
-            int pathParamEnd = ByteChunk.findBytes(uriBC.getBuffer(),
-                    start + pathParamStart, end,
-                    new byte[] {';', '/'});
+            int pathParamEnd = ByteChunk.findBytes(uriBC.getBuffer(), start + pathParamStart, end,
+                    new byte[] { ';', '/' });
 
             String pv = null;
 
             if (pathParamEnd >= 0) {
                 if (charset != null) {
-                    pv = new String(uriBC.getBuffer(), start + pathParamStart,
-                                pathParamEnd - pathParamStart, charset);
+                    pv = new String(uriBC.getBuffer(), start + pathParamStart, pathParamEnd - pathParamStart, charset);
                 }
                 // Extract path param from decoded request URI
                 byte[] buf = uriBC.getBuffer();
                 for (int i = 0; i < end - start - pathParamEnd; i++) {
-                    buf[start + semicolon + i]
-                        = buf[start + i + pathParamEnd];
+                    buf[start + semicolon + i] = buf[start + i + pathParamEnd];
                 }
-                uriBC.setBytes(buf, start,
-                        end - start - pathParamEnd + semicolon);
+                uriBC.setBytes(buf, start, end - start - pathParamEnd + semicolon);
             } else {
                 if (charset != null) {
-                    pv = new String(uriBC.getBuffer(), start + pathParamStart,
-                                (end - start) - pathParamStart, charset);
+                    pv = new String(uriBC.getBuffer(), start + pathParamStart, (end - start) - pathParamStart, charset);
                 }
                 uriBC.setEnd(start + semicolon);
             }
 
             if (log.isDebugEnabled()) {
-                log.debug(sm.getString("coyoteAdapter.debug", "pathParamStart",
-                        String.valueOf(pathParamStart)));
-                log.debug(sm.getString("coyoteAdapter.debug", "pathParamEnd",
-                        String.valueOf(pathParamEnd)));
+                log.debug(sm.getString("coyoteAdapter.debug", "pathParamStart", String.valueOf(pathParamStart)));
+                log.debug(sm.getString("coyoteAdapter.debug", "pathParamEnd", String.valueOf(pathParamEnd)));
                 log.debug(sm.getString("coyoteAdapter.debug", "pv", pv));
             }
 
@@ -1000,12 +958,9 @@ public class CoyoteAdapter implements Adapter {
                     String value = pv.substring(equals + 1);
                     request.addPathParameter(name, value);
                     if (log.isDebugEnabled()) {
-                        log.debug(sm.getString("coyoteAdapter.debug", "equals",
-                                String.valueOf(equals)));
-                        log.debug(sm.getString("coyoteAdapter.debug", "name",
-                                name));
-                        log.debug(sm.getString("coyoteAdapter.debug", "value",
-                                value));
+                        log.debug(sm.getString("coyoteAdapter.debug", "equals", String.valueOf(equals)));
+                        log.debug(sm.getString("coyoteAdapter.debug", "name", name));
+                        log.debug(sm.getString("coyoteAdapter.debug", "value", value));
                     }
                 }
             }
@@ -1016,16 +971,14 @@ public class CoyoteAdapter implements Adapter {
 
 
     /**
-     * Look for SSL session ID if required. Only look for SSL Session ID if it
-     * is the only tracking method enabled.
+     * Look for SSL session ID if required. Only look for SSL Session ID if it is the only tracking method enabled.
      *
      * @param request The Servlet request object
      */
     protected void parseSessionSslId(Request request) {
         if (request.getRequestedSessionId() == null &&
-                SSL_ONLY.equals(request.getServletContext()
-                        .getEffectiveSessionTrackingModes()) &&
-                        request.connector.secure) {
+                SSL_ONLY.equals(request.getServletContext().getEffectiveSessionTrackingModes()) &&
+                request.connector.secure) {
             String sessionId = (String) request.getAttribute(SSLSupport.SESSION_ID_KEY);
             if (sessionId != null) {
                 request.setRequestedSessionId(sessionId);
@@ -1047,9 +1000,8 @@ public class CoyoteAdapter implements Adapter {
         // from a parent context with a session ID may be present which would
         // overwrite the valid session ID encoded in the URL
         Context context = request.getMappingData().context;
-        if (context != null && !context.getServletContext()
-                .getEffectiveSessionTrackingModes().contains(
-                        SessionTrackingMode.COOKIE)) {
+        if (context != null &&
+                !context.getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.COOKIE)) {
             return;
         }
 
@@ -1069,20 +1021,17 @@ public class CoyoteAdapter implements Adapter {
                 if (!request.isRequestedSessionIdFromCookie()) {
                     // Accept only the first session id cookie
                     convertMB(scookie.getValue());
-                    request.setRequestedSessionId
-                        (scookie.getValue().toString());
+                    request.setRequestedSessionId(scookie.getValue().toString());
                     request.setRequestedSessionCookie(true);
                     request.setRequestedSessionURL(false);
                     if (log.isDebugEnabled()) {
-                        log.debug(" Requested cookie session id is " +
-                            request.getRequestedSessionId());
+                        log.debug(" Requested cookie session id is " + request.getRequestedSessionId());
                     }
                 } else {
                     if (!request.isRequestedSessionIdValid()) {
                         // Replace the session id until one is valid
                         convertMB(scookie.getValue());
-                        request.setRequestedSessionId
-                            (scookie.getValue().toString());
+                        request.setRequestedSessionId(scookie.getValue().toString());
                     }
                 }
             }
@@ -1094,8 +1043,9 @@ public class CoyoteAdapter implements Adapter {
     /**
      * Character conversion of the URI.
      *
-     * @param uri MessageBytes object containing the URI
+     * @param uri     MessageBytes object containing the URI
      * @param request The Servlet request object
+     *
      * @throws IOException if a IO exception occurs sending an error to the client
      */
     protected void convertURI(MessageBytes uri, Request request) throws IOException {
@@ -1158,12 +1108,11 @@ public class CoyoteAdapter implements Adapter {
     /**
      * This method normalizes "\", "//", "/./" and "/../".
      *
-     * @param uriMB URI to be normalized
+     * @param uriMB          URI to be normalized
      * @param allowBackslash <code>true</code> if backslash characters are allowed in URLs
      *
-     * @return <code>false</code> if normalizing this URI would require going
-     *         above the root, or if the URI contains a null byte, otherwise
-     *         <code>true</code>
+     * @return <code>false</code> if normalizing this URI would require going above the root, or if the URI contains a
+     *             null byte, otherwise <code>true</code>
      */
     public static boolean normalize(MessageBytes uriMB, boolean allowBackslash) {
 
@@ -1215,9 +1164,7 @@ public class CoyoteAdapter implements Adapter {
         // Note: It is possible to extend the URI by 1 without any side effect
         // as the next character is a non-significant WS.
         if (((end - start) >= 2) && (b[end - 1] == (byte) '.')) {
-            if ((b[end - 2] == (byte) '/')
-                || ((b[end - 2] == (byte) '.')
-                    && (b[end - 3] == (byte) '/'))) {
+            if ((b[end - 2] == (byte) '/') || ((b[end - 2] == (byte) '.') && (b[end - 3] == (byte) '/'))) {
                 b[end] = (byte) '/';
                 end++;
                 appendedSlash = true;
@@ -1234,8 +1181,7 @@ public class CoyoteAdapter implements Adapter {
             if (index < 0) {
                 break;
             }
-            copyBytes(b, start + index, start + index + 2,
-                      end - start - index - 2);
+            copyBytes(b, start + index, start + index + 2, end - start - index - 2);
             end = end - 2;
             uriBC.setEnd(end);
         }
@@ -1253,13 +1199,12 @@ public class CoyoteAdapter implements Adapter {
                 return false;
             }
             int index2 = -1;
-            for (pos = start + index - 1; (pos >= 0) && (index2 < 0); pos --) {
+            for (pos = start + index - 1; (pos >= 0) && (index2 < 0); pos--) {
                 if (b[pos] == (byte) '/') {
                     index2 = pos;
                 }
             }
-            copyBytes(b, start + index2, start + index + 3,
-                      end - start - index - 3);
+            copyBytes(b, start + index2, start + index + 3, end - start - index - 3);
             end = end + index2 - index - 3;
             uriBC.setEnd(end);
             index = index2;
@@ -1267,8 +1212,8 @@ public class CoyoteAdapter implements Adapter {
 
         // If a slash was appended to help normalize "/." or "/.." then remove
         // any trailing "/" from the result unless the result is "/".
-        if (appendedSlash && end > 1 && b[end - 1]== '/') {
-            uriBC.setEnd(end -1);
+        if (appendedSlash && end > 1 && b[end - 1] == '/') {
+            uriBC.setEnd(end - 1);
         }
 
         return true;
@@ -1276,13 +1221,12 @@ public class CoyoteAdapter implements Adapter {
 
 
     /**
-     * Copy an array of bytes to a different position. Used during
-     * normalization.
+     * Copy an array of bytes to a different position. Used during normalization.
      *
-     * @param b The bytes that should be copied
+     * @param b    The bytes that should be copied
      * @param dest Destination offset
-     * @param src Source offset
-     * @param len Length
+     * @param src  Source offset
+     * @param len  Length
      */
     protected static void copyBytes(byte[] b, int dest, int src, int len) {
         System.arraycopy(b, src, b, dest, len);
@@ -1320,7 +1264,8 @@ public class CoyoteAdapter implements Adapter {
                 if (bytes[pos] == '.') {
                     dotCount++;
                     pos++;
-                } else if (pos + 2 < end && bytes[pos] == '%' && bytes[pos + 1] == '2' && (bytes[pos+2] == 'e' || bytes[pos+2] == 'E')) {
+                } else if (pos + 2 < end && bytes[pos] == '%' && bytes[pos + 1] == '2' &&
+                        (bytes[pos + 2] == 'e' || bytes[pos + 2] == 'E')) {
                     encodedDot = true;
                     dotCount++;
                     pos += 3;

==================================================
CoyoteOutputStream.java
index 952261e481..286eacf3f4 100644
--- a/java/org/apache/catalina/connector/CoyoteInputStream.java
+++ b/java/org/apache/catalina/connector/CoyoteInputStream.java
@@ -93,9 +93,7 @@ public class CoyoteInputStream extends ServletInputStream {
 
 
     /**
-     * Close the stream
-     * Since we re-cycle, we can't allow the call to super.close()
-     * which would permanently disable us.
+     * Close the stream Since we re-cycle, we can't allow the call to super.close() which would permanently disable us.
      */
     @Override
     public void close() throws IOException {

==================================================
CoyotePrincipal.java
index 218fb00aaf..c61eebf8e5 100644
--- a/java/org/apache/catalina/connector/CoyoteOutputStream.java
+++ b/java/org/apache/catalina/connector/CoyoteOutputStream.java
@@ -129,12 +129,10 @@ public class CoyoteOutputStream extends ServletOutputStream {
 
 
     /**
-     * Checks for concurrent writes which are not permitted. This object has no
-     * state information so the call chain is
+     * Checks for concurrent writes which are not permitted. This object has no state information so the call chain is
      * CoyoteOutputStream->OutputBuffer->CoyoteResponse.
      *
-     * @return <code>true</code> if this OutputStream is currently in
-     *         non-blocking mode.
+     * @return <code>true</code> if this OutputStream is currently in non-blocking mode.
      */
     private boolean checkNonBlockingWrite() {
         boolean nonBlocking = !ob.isBlocking();
@@ -146,12 +144,10 @@ public class CoyoteOutputStream extends ServletOutputStream {
 
 
     /**
-     * Checks to see if there is data left in the Coyote output buffers (NOT the
-     * servlet output buffer) and if so registers the associated socket for
-     * write so the buffers will be emptied. The container will take care of
-     * this. As far as the app is concerned, there is a non-blocking write in
-     * progress. It doesn't have visibility of whether the data is buffered in
-     * the socket buffer or the Coyote buffers.
+     * Checks to see if there is data left in the Coyote output buffers (NOT the servlet output buffer) and if so
+     * registers the associated socket for write so the buffers will be emptied. The container will take care of this.
+     * As far as the app is concerned, there is a non-blocking write in progress. It doesn't have visibility of whether
+     * the data is buffered in the socket buffer or the Coyote buffers.
      */
     private void checkRegisterForWrite() {
         ob.checkRegisterForWrite();

==================================================
CoyoteReader.java
index c20db11c9f..30b69252c6 100644
--- a/java/org/apache/catalina/connector/CoyotePrincipal.java
+++ b/java/org/apache/catalina/connector/CoyotePrincipal.java
@@ -20,8 +20,8 @@ import java.io.Serializable;
 import java.security.Principal;
 
 /**
- * Generic implementation of <strong>java.security.Principal</strong> that
- * is used to represent principals authenticated at the protocol handler level.
+ * Generic implementation of <strong>java.security.Principal</strong> that is used to represent principals authenticated
+ * at the protocol handler level.
  *
  * @author Remy Maucherat
  */
@@ -57,8 +57,7 @@ public class CoyotePrincipal implements Principal, Serializable {
 
 
     /**
-     * Return a String representation of this object, which exposes only
-     * information that should be public.
+     * Return a String representation of this object, which exposes only information that should be public.
      */
     @Override
     public String toString() {

==================================================
CoyoteWriter.java
index 45ce8f7938..194953cdaf 100644
--- a/java/org/apache/catalina/connector/CoyoteReader.java
+++ b/java/org/apache/catalina/connector/CoyoteReader.java
@@ -25,8 +25,7 @@ import java.io.IOException;
  *
  * @author Remy Maucherat
  */
-public class CoyoteReader
-    extends BufferedReader {
+public class CoyoteReader extends BufferedReader {
 
 
     // -------------------------------------------------------------- Constants
@@ -61,8 +60,7 @@ public class CoyoteReader
      * Prevent cloning the facade.
      */
     @Override
-    protected Object clone()
-        throws CloneNotSupportedException {
+    protected Object clone() throws CloneNotSupportedException {
         throw new CloneNotSupportedException();
     }
 
@@ -82,43 +80,37 @@ public class CoyoteReader
 
 
     @Override
-    public void close()
-        throws IOException {
+    public void close() throws IOException {
         ib.close();
     }
 
 
     @Override
-    public int read()
-        throws IOException {
+    public int read() throws IOException {
         return ib.read();
     }
 
 
     @Override
-    public int read(char[] cbuf)
-        throws IOException {
+    public int read(char[] cbuf) throws IOException {
         return ib.read(cbuf, 0, cbuf.length);
     }
 
 
     @Override
-    public int read(char[] cbuf, int off, int len)
-        throws IOException {
+    public int read(char[] cbuf, int off, int len) throws IOException {
         return ib.read(cbuf, off, len);
     }
 
 
     @Override
-    public long skip(long n)
-        throws IOException {
+    public long skip(long n) throws IOException {
         return ib.skip(n);
     }
 
 
     @Override
-    public boolean ready()
-        throws IOException {
+    public boolean ready() throws IOException {
         return ib.ready();
     }
 
@@ -130,26 +122,23 @@ public class CoyoteReader
 
 
     @Override
-    public void mark(int readAheadLimit)
-        throws IOException {
+    public void mark(int readAheadLimit) throws IOException {
         ib.mark(readAheadLimit);
     }
 
 
     @Override
-    public void reset()
-        throws IOException {
+    public void reset() throws IOException {
         ib.reset();
     }
 
 
     @Override
-    public String readLine()
-        throws IOException {
+    public String readLine() throws IOException {
 
         if (lineBuffer == null) {
             lineBuffer = new char[MAX_LINE_LENGTH];
-       }
+        }
 
         String result = null;
 
@@ -176,7 +165,7 @@ public class CoyoteReader
                         if (i == (pos + nRead - 1)) {
                             nextchar = (char) read();
                         } else {
-                            nextchar = lineBuffer[i+1];
+                            nextchar = lineBuffer[i + 1];
                         }
                         if (nextchar == LINE_SEP[1]) {
                             skip++;

==================================================
InputBuffer.java
index 2be8fb9eb9..6eef35949d 100644
--- a/java/org/apache/catalina/connector/CoyoteWriter.java
+++ b/java/org/apache/catalina/connector/CoyoteWriter.java
@@ -55,8 +55,7 @@ public class CoyoteWriter extends PrintWriter {
      * Prevent cloning the facade.
      */
     @Override
-    protected Object clone()
-        throws CloneNotSupportedException {
+    protected Object clone() throws CloneNotSupportedException {
         throw new CloneNotSupportedException();
     }
 
@@ -106,7 +105,7 @@ public class CoyoteWriter extends PrintWriter {
         // so the stream can be reused. We close ob.
         try {
             ob.close();
-        } catch (IOException ex ) {
+        } catch (IOException ex) {
             // Ignore
         }
         error = false;

==================================================
OutputBuffer.java
index 4512a8c0be..5aacb0663a 100644
--- a/java/org/apache/catalina/connector/InputBuffer.java
+++ b/java/org/apache/catalina/connector/InputBuffer.java
@@ -38,15 +38,13 @@ import org.apache.tomcat.util.net.ApplicationBufferHandler;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * The buffer used by Tomcat request. This is a derivative of the Tomcat 3.3
- * OutputBuffer, adapted to handle input instead of output. This allows
- * complete recycling of the facade objects (the ServletInputStream and the
+ * The buffer used by Tomcat request. This is a derivative of the Tomcat 3.3 OutputBuffer, adapted to handle input
+ * instead of output. This allows complete recycling of the facade objects (the ServletInputStream and the
  * BufferedReader).
  *
  * @author Remy Maucherat
  */
-public class InputBuffer extends Reader
-    implements ByteChunk.ByteInputChannel, ApplicationBufferHandler {
+public class InputBuffer extends Reader implements ByteChunk.ByteInputChannel, ApplicationBufferHandler {
 
     /**
      * The string manager for this package.
@@ -211,8 +209,7 @@ public class InputBuffer extends Reader
     public int available() {
         int available = availableInThisBuffer();
         if (available == 0) {
-            coyoteRequest.action(ActionCode.AVAILABLE,
-                    Boolean.valueOf(coyoteRequest.getReadListener() != null));
+            coyoteRequest.action(ActionCode.AVAILABLE, Boolean.valueOf(coyoteRequest.getReadListener() != null));
             available = (coyoteRequest.getAvailable() > 0) ? 1 : 0;
         }
         return available;
@@ -342,14 +339,14 @@ public class InputBuffer extends Reader
 
 
     /**
-     * Transfers bytes from the buffer to the specified ByteBuffer. After the
-     * operation the position of the ByteBuffer will be returned to the one
-     * before the operation, the limit will be the position incremented by
-     * the number of the transferred bytes.
+     * Transfers bytes from the buffer to the specified ByteBuffer. After the operation the position of the ByteBuffer
+     * will be returned to the one before the operation, the limit will be the position incremented by the number of the
+     * transferred bytes.
      *
      * @param to the ByteBuffer into which bytes are to be written.
-     * @return an integer specifying the actual number of bytes read, or -1 if
-     *         the end of the stream is reached
+     *
+     * @return an integer specifying the actual number of bytes read, or -1 if the end of the stream is reached
+     *
      * @throws IOException if an input or output exception has occurred
      */
     public int read(ByteBuffer to) throws IOException {
@@ -601,17 +598,17 @@ public class InputBuffer extends Reader
 
     private void makeSpace(int count) {
         int desiredSize = cb.limit() + count;
-        if(desiredSize > readLimit) {
+        if (desiredSize > readLimit) {
             desiredSize = readLimit;
         }
 
-        if(desiredSize <= cb.capacity()) {
+        if (desiredSize <= cb.capacity()) {
             return;
         }
 
         int newSize = 2 * cb.capacity();
-        if(desiredSize >= newSize) {
-            newSize= 2 * cb.capacity() + count;
+        if (desiredSize >= newSize) {
+            newSize = 2 * cb.capacity() + count;
         }
 
         if (newSize > readLimit) {

==================================================
Request.java
index cba68cee37..42e0ab8d7f 100644
--- a/java/org/apache/catalina/connector/OutputBuffer.java
+++ b/java/org/apache/catalina/connector/OutputBuffer.java
@@ -36,9 +36,8 @@ import org.apache.tomcat.util.buf.CharsetHolder;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * The buffer used by Tomcat response. This is a derivative of the Tomcat 3.3
- * OutputBuffer, with the removal of some of the state handling (which in
- * Coyote is mostly the Processor's responsibility).
+ * The buffer used by Tomcat response. This is a derivative of the Tomcat 3.3 OutputBuffer, with the removal of some of
+ * the state handling (which in Coyote is mostly the Processor's responsibility).
  *
  * @author Costin Manolache
  * @author Remy Maucherat
@@ -209,8 +208,7 @@ public class OutputBuffer extends Writer {
 
 
     /**
-     * Close the output buffer. This tries to calculate the response size if
-     * the response has not been committed yet.
+     * Close the output buffer. This tries to calculate the response size if the response has not been committed yet.
      *
      * @throws IOException An underlying IOException occurred
      */
@@ -270,6 +268,7 @@ public class OutputBuffer extends Writer {
      * Flush bytes or chars contained in the buffer.
      *
      * @param realFlush <code>true</code> if this should also cause a real network flush
+     *
      * @throws IOException An underlying IOException occurred
      */
     protected void doFlush(boolean realFlush) throws IOException {
@@ -309,8 +308,7 @@ public class OutputBuffer extends Writer {
     // ------------------------------------------------- Bytes Handling Methods
 
     /**
-     * Sends the buffer data to the client output, checking the
-     * state of Response and calling the right interceptors.
+     * Sends the buffer data to the client output, checking the state of Response and calling the right interceptors.
      *
      * @param buf the ByteBuffer to be written to the response
      *
@@ -571,7 +569,7 @@ public class OutputBuffer extends Writer {
     }
 
 
-    // --------------------  BufferedOutputStream compatibility
+    // -------------------- BufferedOutputStream compatibility
 
     public long getContentWritten() {
         return bytesWritten + charsWritten;
@@ -580,8 +578,7 @@ public class OutputBuffer extends Writer {
     /**
      * Has this buffer been used at all?
      *
-     * @return true if no chars or bytes have been added to the buffer since the
-     *         last call to {@link #recycle()}
+     * @return true if no chars or bytes have been added to the buffer since the last call to {@link #recycle()}
      */
     public boolean isNew() {
         return (bytesWritten == 0) && (charsWritten == 0);
@@ -621,8 +618,8 @@ public class OutputBuffer extends Writer {
 
 
     /*
-     * All the non-blocking write state information is held in the Response so
-     * it is visible / accessible to all the code that needs it.
+     * All the non-blocking write state information is held in the Response so it is visible / accessible to all the
+     * code that needs it.
      */
 
     public boolean isReady() {
@@ -649,6 +646,7 @@ public class OutputBuffer extends Writer {
      * @param src Bytes array
      * @param off Offset
      * @param len Length
+     *
      * @throws IOException Writing overflow data to the output channel failed
      */
     public void append(byte src[], int off, int len) throws IOException {
@@ -667,14 +665,16 @@ public class OutputBuffer extends Writer {
 
     /**
      * Add data to the buffer.
+     *
      * @param src Char array
      * @param off Offset
      * @param len Length
+     *
      * @throws IOException Writing overflow data to the output channel failed
      */
     public void append(char src[], int off, int len) throws IOException {
         // if we have limit and we're below
-        if(len <= cb.capacity() - cb.limit()) {
+        if (len <= cb.capacity() - cb.limit()) {
             transfer(src, off, len, cb);
             return;
         }
@@ -685,11 +685,11 @@ public class OutputBuffer extends Writer {
         // copy the first part, flush, then copy the second part - 1 write
         // and still have some space for more. We'll still have 2 writes, but
         // we write more on the first.
-        if(len + cb.limit() < 2 * cb.capacity()) {
-            /* If the request length exceeds the size of the output buffer,
-               flush the output buffer and then write the data directly.
-               We can't avoid 2 writes, but we can write more on the second
-            */
+        if (len + cb.limit() < 2 * cb.capacity()) {
+            /*
+             * If the request length exceeds the size of the output buffer, flush the output buffer and then write the
+             * data directly. We can't avoid 2 writes, but we can write more on the second
+             */
             int n = transfer(src, off, len, cb);
 
             flushCharBuffer();
@@ -826,13 +826,10 @@ public class OutputBuffer extends Writer {
     }
 
     private void toReadMode(Buffer buffer) {
-        buffer.limit(buffer.position())
-              .reset();
+        buffer.limit(buffer.position()).reset();
     }
 
     private void toWriteMode(Buffer buffer) {
-        buffer.mark()
-              .position(buffer.limit())
-              .limit(buffer.capacity());
+        buffer.mark().position(buffer.limit()).limit(buffer.capacity());
     }
 }

==================================================
RequestFacade.java
index 41fd4f62cb..c5bfa18d40 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -135,10 +135,9 @@ public class Request implements HttpServletRequest {
     /**
      * Create a new Request object associated with the given Connector.
      *
-     * @param connector The Connector with which this Request object will always
-     *                  be associated. In normal usage this must be non-null. In
-     *                  some test scenarios, it may be possible to use a null
-     *                  Connector without triggering an NPE.
+     * @param connector The Connector with which this Request object will always be associated. In normal usage this
+     *                      must be non-null. In some test scenarios, it may be possible to use a null Connector without
+     *                      triggering an NPE.
      */
     public Request(Connector connector) {
         this.connector = connector;
@@ -200,9 +199,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Flag that indicates if SSL attributes have been parsed to improve
-     * performance for applications (usually frameworks) that make multiple
-     * calls to {@link Request#getAttributeNames()}.
+     * Flag that indicates if SSL attributes have been parsed to improve performance for applications (usually
+     * frameworks) that make multiple calls to {@link Request#getAttributeNames()}.
      */
     protected boolean sslAttributesParsed = false;
 
@@ -214,8 +212,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Internal notes associated with this request by Catalina components
-     * and event listeners.
+     * Internal notes associated with this request by Catalina components and event listeners.
      */
     private final transient HashMap<String, Object> notes = new HashMap<>();
 
@@ -241,8 +238,7 @@ public class Request implements HttpServletRequest {
     /**
      * ServletInputStream.
      */
-    protected CoyoteInputStream inputStream =
-            new CoyoteInputStream(inputBuffer);
+    protected CoyoteInputStream inputStream = new CoyoteInputStream(inputBuffer);
 
 
     /**
@@ -276,15 +272,13 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Cookie headers parsed flag. Indicates that the cookie headers have been
-     * parsed into ServerCookies.
+     * Cookie headers parsed flag. Indicates that the cookie headers have been parsed into ServerCookies.
      */
     protected boolean cookiesParsed = false;
 
 
     /**
-     * Cookie parsed flag. Indicates that the ServerCookies have been converted
-     * into user facing Cookie objects.
+     * Cookie parsed flag. Indicates that the ServerCookies have been converted into user facing Cookie objects.
      */
     protected boolean cookiesConverted = false;
 
@@ -432,8 +426,7 @@ public class Request implements HttpServletRequest {
     }
 
     /**
-     * Release all object references, and initialize instance variables, in
-     * preparation for reuse of this object.
+     * Release all object references, and initialize instance variables, in preparation for reuse of this object.
      */
     public void recycle() {
 
@@ -448,7 +441,7 @@ public class Request implements HttpServletRequest {
         subject = null;
         parametersParsed = false;
         if (parts != null) {
-            for (Part part: parts) {
+            for (Part part : parts) {
                 try {
                     part.delete();
                 } catch (IOException ignored) {
@@ -503,7 +496,7 @@ public class Request implements HttpServletRequest {
         }
 
         asyncSupported = null;
-        if (asyncContext!=null) {
+        if (asyncContext != null) {
             asyncContext.recycle();
         }
         asyncContext = null;
@@ -555,9 +548,8 @@ public class Request implements HttpServletRequest {
     /**
      * Return the Context within which this Request is being processed.
      * <p>
-     * This is available as soon as the appropriate Context is identified.
-     * Note that availability of a Context allows <code>getContextPath()</code>
-     * to return a value, and thus enables parsing of the request URI.
+     * This is available as soon as the appropriate Context is identified. Note that availability of a Context allows
+     * <code>getContextPath()</code> to return a value, and thus enables parsing of the request URI.
      *
      * @return the Context mapped with the request
      */
@@ -568,8 +560,9 @@ public class Request implements HttpServletRequest {
 
     /**
      * Get the recycling strategy of the facade objects.
-     * @return the value of the flag as set on the connector, or
-     *   <code>true</code> if no connector is associated with this request
+     *
+     * @return the value of the flag as set on the connector, or <code>true</code> if no connector is associated with
+     *             this request
      */
     public boolean getDiscardFacades() {
         return (connector == null) ? true : connector.getDiscardFacades();
@@ -629,8 +622,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return the <code>ServletRequest</code> for which this object
-     * is the facade.  This method must be implemented by a subclass.
+     * @return the <code>ServletRequest</code> for which this object is the facade. This method must be implemented by a
+     *             subclass.
      */
     public HttpServletRequest getRequest() {
         if (facade == null) {
@@ -644,10 +637,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Set a wrapped HttpServletRequest to pass to the application. Components
-     * wishing to wrap the request should obtain the request via
-     * {@link #getRequest()}, wrap it and then call this method with the
-     * wrapped request.
+     * Set a wrapped HttpServletRequest to pass to the application. Components wishing to wrap the request should obtain
+     * the request via {@link #getRequest()}, wrap it and then call this method with the wrapped request.
      *
      * @param applicationRequest The wrapped request to pass to the application
      */
@@ -728,14 +719,13 @@ public class Request implements HttpServletRequest {
     // ------------------------------------------------- Request Public Methods
 
     /**
-     * Create and return a ServletInputStream to read the content
-     * associated with this Request.
+     * Create and return a ServletInputStream to read the content associated with this Request.
      *
      * @return the created input stream
+     *
      * @exception IOException if an input/output error occurs
      */
-    public ServletInputStream createInputStream()
-            throws IOException {
+    public ServletInputStream createInputStream() throws IOException {
         if (inputStream == null) {
             inputStream = new CoyoteInputStream(inputBuffer);
         }
@@ -744,8 +734,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Perform whatever actions are required to flush and close the input
-     * stream or reader, in a single operation.
+     * Perform whatever actions are required to flush and close the input stream or reader, in a single operation.
      *
      * @exception IOException if an input/output error occurs
      */
@@ -757,8 +746,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return the object bound with the specified name to the internal notes
-     * for this request, or <code>null</code> if no such binding exists.
+     * @return the object bound with the specified name to the internal notes for this request, or <code>null</code> if
+     *             no such binding exists.
      *
      * @param name Name of the note to be returned
      */
@@ -768,8 +757,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Remove any object bound to the specified name in the internal notes
-     * for this request.
+     * Remove any object bound to the specified name in the internal notes for this request.
      *
      * @param name Name of the note to be removed
      */
@@ -788,10 +776,10 @@ public class Request implements HttpServletRequest {
     }
 
     /**
-     * Bind an object to a specified name in the internal notes associated
-     * with this request, replacing any existing binding for this name.
+     * Bind an object to a specified name in the internal notes associated with this request, replacing any existing
+     * binding for this name.
      *
-     * @param name Name to which the object should be bound
+     * @param name  Name to which the object should be bound
      * @param value Object to be bound to the specified name
      */
     public void setNote(String name, Object value) {
@@ -810,8 +798,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Set the fully qualified name of the remote client associated with this
-     * Request.
+     * Set the fully qualified name of the remote client associated with this Request.
      *
      * @param remoteHost The remote host name
      */
@@ -821,8 +808,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Set the value to be returned by <code>isSecure()</code>
-     * for this Request.
+     * Set the value to be returned by <code>isSecure()</code> for this Request.
      *
      * @param secure The new isSecure value
      */
@@ -844,8 +830,7 @@ public class Request implements HttpServletRequest {
     // ------------------------------------------------- ServletRequest Methods
 
     /**
-     * @return the specified request attribute if it exists; otherwise, return
-     * <code>null</code>.
+     * @return the specified request attribute if it exists; otherwise, return <code>null</code>.
      *
      * @param name Name of the request attribute to return
      */
@@ -915,12 +900,10 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Return the names of all request attributes for this Request, or an
-     * empty <code>Enumeration</code> if there are none. Note that the attribute
-     * names returned will only be those for the attributes set via
-     * {@link #setAttribute(String, Object)}. Tomcat internal attributes will
-     * not be included although they are accessible via
-     * {@link #getAttribute(String)}. The Tomcat internal attributes include:
+     * Return the names of all request attributes for this Request, or an empty <code>Enumeration</code> if there are
+     * none. Note that the attribute names returned will only be those for the attributes set via
+     * {@link #setAttribute(String, Object)}. Tomcat internal attributes will not be included although they are
+     * accessible via {@link #getAttribute(String)}. The Tomcat internal attributes include:
      * <ul>
      * <li>{@link Globals#DISPATCHER_TYPE_ATTR}</li>
      * <li>{@link Globals#DISPATCHER_REQUEST_PATH_ATTR}</li>
@@ -932,13 +915,13 @@ public class Request implements HttpServletRequest {
      * <li>{@link Globals#SSL_SESSION_MGR_ATTR} (SSL connections only)</li>
      * <li>{@link Globals#PARAMETER_PARSE_FAILED_ATTR}</li>
      * </ul>
-     * The underlying connector may also expose request attributes. These all
-     * have names starting with "org.apache.tomcat" and include:
+     * The underlying connector may also expose request attributes. These all have names starting with
+     * "org.apache.tomcat" and include:
      * <ul>
      * <li>{@link Globals#SENDFILE_SUPPORTED_ATTR}</li>
      * </ul>
-     * Connector implementations may return some, all or none of these
-     * attributes and may also support additional attributes.
+     * Connector implementations may return some, all or none of these attributes and may also support additional
+     * attributes.
      *
      * @return the attribute names enumeration
      */
@@ -978,7 +961,7 @@ public class Request implements HttpServletRequest {
         if (charset == null) {
             Context context = getContext();
             if (context != null) {
-                charset = CharsetHolder.getInstance(context.getRequestCharacterEncoding()).getCharset() ;
+                charset = CharsetHolder.getInstance(context.getRequestCharacterEncoding()).getCharset();
             }
         }
 
@@ -1019,13 +1002,11 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return the servlet input stream for this Request.  The default
-     * implementation returns a servlet input stream created by
-     * <code>createInputStream()</code>.
+     * @return the servlet input stream for this Request. The default implementation returns a servlet input stream
+     *             created by <code>createInputStream()</code>.
      *
-     * @exception IllegalStateException if <code>getReader()</code> has
-     *  already been called for this request
-     * @exception IOException if an input/output error occurs
+     * @exception IllegalStateException if <code>getReader()</code> has already been called for this request
+     * @exception IOException           if an input/output error occurs
      */
     @Override
     public ServletInputStream getInputStream() throws IOException {
@@ -1044,10 +1025,9 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return the preferred Locale that the client will accept content in,
-     * based on the value for the first <code>Accept-Language</code> header
-     * that was encountered.  If the request did not specify a preferred
-     * language, the server's default Locale is returned.
+     * @return the preferred Locale that the client will accept content in, based on the value for the first
+     *             <code>Accept-Language</code> header that was encountered. If the request did not specify a preferred
+     *             language, the server's default Locale is returned.
      */
     @Override
     public Locale getLocale() {
@@ -1065,10 +1045,9 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return the set of preferred Locales that the client will accept
-     * content in, based on the values for any <code>Accept-Language</code>
-     * headers that were encountered.  If the request did not specify a
-     * preferred language, the server's default Locale is returned.
+     * @return the set of preferred Locales that the client will accept content in, based on the values for any
+     *             <code>Accept-Language</code> headers that were encountered. If the request did not specify a
+     *             preferred language, the server's default Locale is returned.
      */
     @Override
     public Enumeration<Locale> getLocales() {
@@ -1088,9 +1067,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return the value of the specified request parameter, if any; otherwise,
-     * return <code>null</code>.  If there is more than one value defined,
-     * return only the first one.
+     * @return the value of the specified request parameter, if any; otherwise, return <code>null</code>. If there is
+     *             more than one value defined, return only the first one.
      *
      * @param name Name of the desired request parameter
      */
@@ -1106,15 +1084,11 @@ public class Request implements HttpServletRequest {
     }
 
 
-
     /**
-     * Returns a <code>Map</code> of the parameters of this request.
-     * Request parameters are extra information sent with the request.
-     * For HTTP servlets, parameters are contained in the query string
-     * or posted form data.
+     * Returns a <code>Map</code> of the parameters of this request. Request parameters are extra information sent with
+     * the request. For HTTP servlets, parameters are contained in the query string or posted form data.
      *
-     * @return A <code>Map</code> containing parameter names as keys
-     *  and parameter values as map values.
+     * @return A <code>Map</code> containing parameter names as keys and parameter values as map values.
      */
     @Override
     public Map<String, String[]> getParameterMap() {
@@ -1153,8 +1127,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return the defined values for the specified request parameter, if any;
-     * otherwise, return <code>null</code>.
+     * @return the defined values for the specified request parameter, if any; otherwise, return <code>null</code>.
      *
      * @param name Name of the desired request parameter
      */
@@ -1180,14 +1153,13 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Read the Reader wrapping the input stream for this Request.  The
-     * default implementation wraps a <code>BufferedReader</code> around the
-     * servlet input stream returned by <code>createInputStream()</code>.
+     * Read the Reader wrapping the input stream for this Request. The default implementation wraps a
+     * <code>BufferedReader</code> around the servlet input stream returned by <code>createInputStream()</code>.
      *
      * @return a buffered reader for the request
-     * @exception IllegalStateException if <code>getInputStream()</code>
-     *  has already been called for this request
-     * @exception IOException if an input/output error occurs
+     *
+     * @exception IllegalStateException if <code>getInputStream()</code> has already been called for this request
+     * @exception IOException           if an input/output error occurs
      */
     @Override
     public BufferedReader getReader() throws IOException {
@@ -1266,11 +1238,10 @@ public class Request implements HttpServletRequest {
     }
 
     /**
-     * @return the Internet Protocol (IP) source port of the client
-     * or last proxy that sent the request.
+     * @return the Internet Protocol (IP) source port of the client or last proxy that sent the request.
      */
     @Override
-    public int getRemotePort(){
+    public int getRemotePort() {
         if (remotePort == -1) {
             coyoteRequest.action(ActionCode.REQ_REMOTEPORT_ATTRIBUTE, coyoteRequest);
             remotePort = coyoteRequest.getRemotePort();
@@ -1279,11 +1250,10 @@ public class Request implements HttpServletRequest {
     }
 
     /**
-     * @return the host name of the Internet Protocol (IP) interface on
-     * which the request was received.
+     * @return the host name of the Internet Protocol (IP) interface on which the request was received.
      */
     @Override
-    public String getLocalName(){
+    public String getLocalName() {
         if (localName == null) {
             coyoteRequest.action(ActionCode.REQ_LOCAL_NAME_ATTRIBUTE, coyoteRequest);
             localName = coyoteRequest.localName().toString();
@@ -1292,11 +1262,10 @@ public class Request implements HttpServletRequest {
     }
 
     /**
-     * @return the Internet Protocol (IP) address of the interface on
-     * which the request  was received.
+     * @return the Internet Protocol (IP) address of the interface on which the request was received.
      */
     @Override
-    public String getLocalAddr(){
+    public String getLocalAddr() {
         if (localAddr == null) {
             coyoteRequest.action(ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE, coyoteRequest);
             localAddr = coyoteRequest.localAddr().toString();
@@ -1306,12 +1275,11 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return the Internet Protocol (IP) port number of the interface
-     * on which the request was received.
+     * @return the Internet Protocol (IP) port number of the interface on which the request was received.
      */
     @Override
-    public int getLocalPort(){
-        if (localPort == -1){
+    public int getLocalPort() {
+        if (localPort == -1) {
             coyoteRequest.action(ActionCode.REQ_LOCALPORT_ATTRIBUTE, coyoteRequest);
             localPort = coyoteRequest.getLocalPort();
         }
@@ -1319,8 +1287,8 @@ public class Request implements HttpServletRequest {
     }
 
     /**
-     * @return a RequestDispatcher that wraps the resource at the specified
-     * path, which may be interpreted as relative to the current request path.
+     * @return a RequestDispatcher that wraps the resource at the specified path, which may be interpreted as relative
+     *             to the current request path.
      *
      * @param path Path of the resource to be wrapped
      */
@@ -1350,25 +1318,19 @@ public class Request implements HttpServletRequest {
         /*
          * Relative to what, exactly?
          *
-         * From the Servlet 4.0 Javadoc:
-         * - The pathname specified may be relative, although it cannot extend
-         *   outside the current servlet context.
-         * - If it is relative, it must be relative against the current servlet
+         * From the Servlet 4.0 Javadoc: - The pathname specified may be relative, although it cannot extend outside the
+         * current servlet context. - If it is relative, it must be relative against the current servlet
          *
-         * From Section 9.1 of the spec:
-         * - The servlet container uses information in the request object to
-         *   transform the given relative path against the current servlet to a
-         *   complete path.
+         * From Section 9.1 of the spec: - The servlet container uses information in the request object to transform the
+         * given relative path against the current servlet to a complete path.
          *
-         * It is undefined whether the requestURI is used or whether servletPath
-         * and pathInfo are used. Given that the RequestURI includes the
-         * contextPath (and extracting that is messy) , using the servletPath and
-         * pathInfo looks to be the more reasonable choice.
+         * It is undefined whether the requestURI is used or whether servletPath and pathInfo are used. Given that the
+         * RequestURI includes the contextPath (and extracting that is messy) , using the servletPath and pathInfo looks
+         * to be the more reasonable choice.
          */
 
         // Convert a request-relative path to a context-relative one
-        String servletPath = (String) getAttribute(
-                RequestDispatcher.INCLUDE_SERVLET_PATH);
+        String servletPath = (String) getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);
         if (servletPath == null) {
             servletPath = getServletPath();
         }
@@ -1387,8 +1349,7 @@ public class Request implements HttpServletRequest {
         String relative = null;
         if (context.getDispatchersUseEncodedPaths()) {
             if (pos >= 0) {
-                relative = URLEncoder.DEFAULT.encode(
-                        requestPath.substring(0, pos + 1), StandardCharsets.UTF_8) + path;
+                relative = URLEncoder.DEFAULT.encode(requestPath.substring(0, pos + 1), StandardCharsets.UTF_8) + path;
             } else {
                 relative = URLEncoder.DEFAULT.encode(requestPath, StandardCharsets.UTF_8) + path;
             }
@@ -1467,7 +1428,7 @@ public class Request implements HttpServletRequest {
     /**
      * Set the specified request attribute to the specified value.
      *
-     * @param name Name of the request attribute to set
+     * @param name  Name of the request attribute to set
      * @param value The associated value
      */
     @Override
@@ -1507,12 +1468,11 @@ public class Request implements HttpServletRequest {
     /**
      * Notify interested listeners that attribute has been assigned a value.
      *
-     * @param name Attribute name
-     * @param value New attribute value
+     * @param name     Attribute name
+     * @param value    New attribute value
      * @param oldValue Old attribute value
      */
-    private void notifyAttributeAssigned(String name, Object value,
-            Object oldValue) {
+    private void notifyAttributeAssigned(String name, Object value, Object oldValue) {
         Context context = getContext();
         if (context == null) {
             return;
@@ -1524,11 +1484,9 @@ public class Request implements HttpServletRequest {
         boolean replaced = (oldValue != null);
         ServletRequestAttributeEvent event = null;
         if (replaced) {
-            event = new ServletRequestAttributeEvent(
-                    context.getServletContext(), getRequest(), name, oldValue);
+            event = new ServletRequestAttributeEvent(context.getServletContext(), getRequest(), name, oldValue);
         } else {
-            event = new ServletRequestAttributeEvent(
-                    context.getServletContext(), getRequest(), name, value);
+            event = new ServletRequestAttributeEvent(context.getServletContext(), getRequest(), name, value);
         }
 
         for (Object o : listeners) {
@@ -1555,7 +1513,7 @@ public class Request implements HttpServletRequest {
     /**
      * Notify interested listeners that attribute has been removed.
      *
-     * @param name Attribute name
+     * @param name  Attribute name
      * @param value Attribute value
      */
     private void notifyAttributeRemoved(String name, Object value) {
@@ -1564,9 +1522,8 @@ public class Request implements HttpServletRequest {
         if ((listeners == null) || (listeners.length == 0)) {
             return;
         }
-        ServletRequestAttributeEvent event =
-                new ServletRequestAttributeEvent(context.getServletContext(),
-                        getRequest(), name, value);
+        ServletRequestAttributeEvent event = new ServletRequestAttributeEvent(context.getServletContext(), getRequest(),
+                name, value);
         for (Object o : listeners) {
             if (!(o instanceof ServletRequestAttributeListener)) {
                 continue;
@@ -1585,14 +1542,12 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Overrides the name of the character encoding used in the body of
-     * this request.  This method must be called prior to reading request
-     * parameters or reading input using <code>getReader()</code>.
+     * Overrides the name of the character encoding used in the body of this request. This method must be called prior
+     * to reading request parameters or reading input using <code>getReader()</code>.
      *
      * @param enc The character encoding to be used
      *
-     * @exception UnsupportedEncodingException if the specified encoding
-     *  is not supported
+     * @exception UnsupportedEncodingException if the specified encoding is not supported
      *
      * @since Servlet 2.3
      */
@@ -1626,21 +1581,18 @@ public class Request implements HttpServletRequest {
     @Override
     public ServletContext getServletContext() {
         return getContext().getServletContext();
-     }
+    }
 
     @Override
     public AsyncContext startAsync() {
-        return startAsync(getRequest(),response.getResponse());
+        return startAsync(getRequest(), response.getResponse());
     }
 
     @Override
-    public AsyncContext startAsync(ServletRequest request,
-            ServletResponse response) {
+    public AsyncContext startAsync(ServletRequest request, ServletResponse response) {
         if (!isAsyncSupported()) {
-            IllegalStateException ise =
-                    new IllegalStateException(sm.getString("request.asyncNotSupported"));
-            log.warn(sm.getString("coyoteRequest.noAsync",
-                    StringUtils.join(getNonAsyncClassNames())), ise);
+            IllegalStateException ise = new IllegalStateException(sm.getString("request.asyncNotSupported"));
+            log.warn(sm.getString("coyoteRequest.noAsync", StringUtils.join(getNonAsyncClassNames())), ise);
             throw ise;
         }
 
@@ -1649,7 +1601,7 @@ public class Request implements HttpServletRequest {
         }
 
         asyncContext.setStarted(getContext(), request, response,
-                request==getRequest() && response==getResponse().getResponse());
+                request == getRequest() && response == getResponse().getResponse());
         asyncContext.setTimeout(getConnector().getAsyncTimeout());
 
         return asyncContext;
@@ -1798,8 +1750,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Add a Locale to the set of preferred Locales for this Request.  The
-     * first added Locale will be the first one returned by getLocales().
+     * Add a Locale to the set of preferred Locales for this Request. The first added Locale will be the first one
+     * returned by getLocales().
      *
      * @param locale The new preferred Locale
      */
@@ -1827,9 +1779,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Set the authentication type used for this request, if any; otherwise
-     * set the type to <code>null</code>.  Typical values are "BASIC",
-     * "DIGEST", or "SSL".
+     * Set the authentication type used for this request, if any; otherwise set the type to <code>null</code>. Typical
+     * values are "BASIC", "DIGEST", or "SSL".
      *
      * @param type The authentication type used
      */
@@ -1839,9 +1790,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Set the path information for this Request.  This will normally be called
-     * when the associated Context is mapping the Request to a particular
-     * Wrapper.
+     * Set the path information for this Request. This will normally be called when the associated Context is mapping
+     * the Request to a particular Wrapper.
      *
      * @param path The path information
      */
@@ -1851,9 +1801,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Set a flag indicating whether or not the requested session ID for this
-     * request came in through a cookie.  This is normally called by the
-     * HTTP Connector, when it parses the request headers.
+     * Set a flag indicating whether or not the requested session ID for this request came in through a cookie. This is
+     * normally called by the HTTP Connector, when it parses the request headers.
      *
      * @param flag The new flag
      */
@@ -1865,8 +1814,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Set the requested session ID for this request.  This is normally called
-     * by the HTTP Connector, when it parses the request headers.
+     * Set the requested session ID for this request. This is normally called by the HTTP Connector, when it parses the
+     * request headers.
      *
      * @param id The new session id
      */
@@ -1878,9 +1827,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Set a flag indicating whether or not the requested session ID for this
-     * request came in through a URL.  This is normally called by the
-     * HTTP Connector, when it parses the request headers.
+     * Set a flag indicating whether or not the requested session ID for this request came in through a URL. This is
+     * normally called by the HTTP Connector, when it parses the request headers.
      *
      * @param flag The new flag
      */
@@ -1892,9 +1840,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Set a flag indicating whether or not the requested session ID for this
-     * request came in through SSL.  This is normally called by the
-     * HTTP Connector, when it parses the request headers.
+     * Set a flag indicating whether or not the requested session ID for this request came in through SSL. This is
+     * normally called by the HTTP Connector, when it parses the request headers.
      *
      * @param flag The new flag
      */
@@ -1926,9 +1873,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Set the Principal who has been authenticated for this Request.  This
-     * value is also used to calculate the value to be returned by the
-     * <code>getRemoteUser()</code> method.
+     * Set the Principal who has been authenticated for this Request. This value is also used to calculate the value to
+     * be returned by the <code>getRemoteUser()</code> method.
      *
      * @param principal The user Principal
      */
@@ -1974,8 +1920,8 @@ public class Request implements HttpServletRequest {
 
     @SuppressWarnings("unchecked")
     @Override
-    public <T extends HttpUpgradeHandler> T upgrade(
-            Class<T> httpUpgradeHandlerClass) throws java.io.IOException, ServletException {
+    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass)
+            throws java.io.IOException, ServletException {
         T handler;
         InstanceManager instanceManager = null;
         try {
@@ -1987,8 +1933,7 @@ public class Request implements HttpServletRequest {
                 instanceManager = getContext().getInstanceManager();
                 handler = (T) instanceManager.newInstance(httpUpgradeHandlerClass);
             }
-        } catch (ReflectiveOperationException | NamingException | IllegalArgumentException |
-                SecurityException e) {
+        } catch (ReflectiveOperationException | NamingException | IllegalArgumentException | SecurityException e) {
             throw new ServletException(e);
         }
         UpgradeToken upgradeToken = new UpgradeToken(handler, getContext(), instanceManager,
@@ -2036,9 +1981,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Return the portion of the request URI used to select the Context
-     * of the Request. The value returned is not decoded which also implies it
-     * is not normalised.
+     * Return the portion of the request URI used to select the Context of the Request. The value returned is not
+     * decoded which also implies it is not normalised.
      */
     @Override
     public String getContextPath() {
@@ -2106,8 +2050,8 @@ public class Request implements HttpServletRequest {
             }
         } else {
             // Should never happen
-            throw new IllegalStateException(sm.getString(
-                    "coyoteRequest.getContextPath.ise", canonicalContextPath, uri));
+            throw new IllegalStateException(
+                    sm.getString("coyoteRequest.getContextPath.ise", canonicalContextPath, uri));
         }
     }
 
@@ -2145,7 +2089,7 @@ public class Request implements HttpServletRequest {
             if (uri[pos] == '/') {
                 return pos;
             } else if (connector.getEncodedSolidusHandlingInternal() == EncodedSolidusHandling.DECODE &&
-                    uri[pos] == '%' && pos + 2 < len && uri[pos+1] == '2' &&
+                    uri[pos] == '%' && pos + 2 < len && uri[pos + 1] == '2' &&
                     (uri[pos + 2] == 'f' || uri[pos + 2] == 'F')) {
                 return pos;
             }
@@ -2156,9 +2100,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Return the set of Cookies received with this Request. Triggers parsing of
-     * the Cookie HTTP headers followed by conversion to Cookie objects if this
-     * has not already been performed.
+     * Return the set of Cookies received with this Request. Triggers parsing of the Cookie HTTP headers followed by
+     * conversion to Cookie objects if this has not already been performed.
      *
      * @return the array of cookies
      */
@@ -2172,9 +2115,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Return the server representation of the cookies associated with this
-     * request. Triggers parsing of the Cookie HTTP headers (but not conversion
-     * to Cookie objects) if the headers have not yet been parsed.
+     * Return the server representation of the cookies associated with this request. Triggers parsing of the Cookie HTTP
+     * headers (but not conversion to Cookie objects) if the headers have not yet been parsed.
      *
      * @return the server cookies
      */
@@ -2185,14 +2127,13 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Return the value of the specified date header, if any; otherwise
-     * return -1.
+     * Return the value of the specified date header, if any; otherwise return -1.
      *
      * @param name Name of the requested date header
+     *
      * @return the date as a long
      *
-     * @exception IllegalArgumentException if the specified header value
-     *  cannot be converted to a date
+     * @exception IllegalArgumentException if the specified header value cannot be converted to a date
      */
     @Override
     public long getDateHeader(String name) {
@@ -2213,10 +2154,10 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Return the first value of the specified header, if any; otherwise,
-     * return <code>null</code>
+     * Return the first value of the specified header, if any; otherwise, return <code>null</code>
      *
      * @param name Name of the requested header
+     *
      * @return the header value
      */
     @Override
@@ -2226,10 +2167,10 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Return all of the values of the specified header, if any; otherwise,
-     * return an empty enumeration.
+     * Return all of the values of the specified header, if any; otherwise, return an empty enumeration.
      *
      * @param name Name of the requested header
+     *
      * @return the enumeration with the header values
      */
     @Override
@@ -2248,14 +2189,13 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Return the value of the specified header as an integer, or -1 if there
-     * is no such header for this request.
+     * Return the value of the specified header as an integer, or -1 if there is no such header for this request.
      *
      * @param name Name of the requested header
+     *
      * @return the header value as an int
      *
-     * @exception IllegalArgumentException if the specified header value
-     *  cannot be converted to an integer
+     * @exception IllegalArgumentException if the specified header value cannot be converted to an integer
      */
     @Override
     public int getIntHeader(String name) {
@@ -2294,8 +2234,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return the extra path information for this request, translated
-     * to a real path.
+     * @return the extra path information for this request, translated to a real path.
      */
     @Override
     public String getPathTranslated() {
@@ -2323,8 +2262,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return the name of the remote user that has been authenticated
-     * for this Request.
+     * @return the name of the remote user that has been authenticated for this Request.
      */
     @Override
     public String getRemoteUser() {
@@ -2372,8 +2310,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return the portion of the request URI used to select the servlet
-     * that will process this request.
+     * @return the portion of the request URI used to select the servlet that will process this request.
      */
     @Override
     public String getServletPath() {
@@ -2382,8 +2319,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return the session associated with this Request, creating one
-     * if necessary.
+     * @return the session associated with this Request, creating one if necessary.
      */
     @Override
     public HttpSession getSession() {
@@ -2397,8 +2333,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return the session associated with this Request, creating one
-     * if necessary and requested.
+     * @return the session associated with this Request, creating one if necessary and requested.
      *
      * @param create Create a new session if one does not exist
      */
@@ -2414,8 +2349,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return <code>true</code> if the session identifier included in this
-     * request came from a cookie.
+     * @return <code>true</code> if the session identifier included in this request came from a cookie.
      */
     @Override
     public boolean isRequestedSessionIdFromCookie() {
@@ -2429,8 +2363,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return <code>true</code> if the session identifier included in this
-     * request came from the request URI.
+     * @return <code>true</code> if the session identifier included in this request came from the request URI.
      */
     @Override
     public boolean isRequestedSessionIdFromURL() {
@@ -2444,8 +2377,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return <code>true</code> if the session identifier included in this
-     * request identifies a valid session.
+     * @return <code>true</code> if the session identifier included in this request identifies a valid session.
      */
     @Override
     public boolean isRequestedSessionIdValid() {
@@ -2479,8 +2411,7 @@ public class Request implements HttpServletRequest {
                 for (int i = (getMappingData().contexts.length); i > 0; i--) {
                     Context ctxt = getMappingData().contexts[i - 1];
                     try {
-                        if (ctxt.getManager().findSession(requestedSessionId) !=
-                                null) {
+                        if (ctxt.getManager().findSession(requestedSessionId) != null) {
                             return true;
                         }
                     } catch (IOException e) {
@@ -2496,8 +2427,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return <code>true</code> if the authenticated user principal
-     * possesses the specified role name.
+     * @return <code>true</code> if the authenticated user principal possesses the specified role name.
      *
      * @param role Role name to be validated
      */
@@ -2551,8 +2481,7 @@ public class Request implements HttpServletRequest {
     @Override
     public Principal getUserPrincipal() {
         if (userPrincipal instanceof TomcatPrincipal) {
-            GSSCredential gssCredential =
-                    ((TomcatPrincipal) userPrincipal).getGssCredential();
+            GSSCredential gssCredential = ((TomcatPrincipal) userPrincipal).getGssCredential();
             if (gssCredential != null) {
                 int left = -1;
                 try {
@@ -2568,8 +2497,7 @@ public class Request implements HttpServletRequest {
                     // rare so it is caught and handled rather than avoided.
                     left = gssCredential.getRemainingLifetime();
                 } catch (GSSException | IllegalStateException e) {
-                    log.warn(sm.getString("coyoteRequest.gssLifetimeFail",
-                            userPrincipal.getName()), e);
+                    log.warn(sm.getString("coyoteRequest.gssLifetimeFail", userPrincipal.getName()), e);
                 }
                 // zero is expired. Exception above will mean left == -1
                 // Treat both as expired.
@@ -2592,8 +2520,7 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return the session associated with this Request, creating one
-     * if necessary.
+     * @return the session associated with this Request, creating one if necessary.
      */
     public Session getSessionInternal() {
         return doGetSession(true);
@@ -2601,12 +2528,11 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Change the ID of the session that this request is associated with. There
-     * are several things that may trigger an ID change. These include moving
-     * between nodes in a cluster and session fixation prevention during the
+     * Change the ID of the session that this request is associated with. There are several things that may trigger an
+     * ID change. These include moving between nodes in a cluster and session fixation prevention during the
      * authentication process.
      *
-     * @param newSessionId   The session to change the session ID for
+     * @param newSessionId The session to change the session ID for
      */
     public void changeSessionId(String newSessionId) {
         // This should only ever be called if there was an old session ID but
@@ -2617,15 +2543,12 @@ public class Request implements HttpServletRequest {
 
         Context context = getContext();
         if (context != null &&
-                !context.getServletContext()
-                        .getEffectiveSessionTrackingModes()
-                        .contains(SessionTrackingMode.COOKIE)) {
+                !context.getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.COOKIE)) {
             return;
         }
 
         if (response != null) {
-            Cookie newCookie = ApplicationSessionCookieConfig.createSessionCookie(context,
-                    newSessionId, isSecure());
+            Cookie newCookie = ApplicationSessionCookieConfig.createSessionCookie(context, newSessionId, isSecure());
             response.addSessionCookieInternal(newCookie);
         }
     }
@@ -2636,8 +2559,7 @@ public class Request implements HttpServletRequest {
 
         Session session = this.getSessionInternal(false);
         if (session == null) {
-            throw new IllegalStateException(
-                sm.getString("coyoteRequest.changeSessionId"));
+            throw new IllegalStateException(sm.getString("coyoteRequest.changeSessionId"));
         }
 
         Manager manager = this.getContext().getManager();
@@ -2649,8 +2571,7 @@ public class Request implements HttpServletRequest {
     }
 
     /**
-     * @return the session associated with this Request, creating one
-     * if necessary and requested.
+     * @return the session associated with this Request, creating one if necessary and requested.
      *
      * @param create Create a new session if one does not exist
      */
@@ -2668,8 +2589,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * @return <code>true</code> if an attempt has been made to read the request
-     *         body and all of the request body has been read.
+     * @return <code>true</code> if an attempt has been made to read the request body and all of the request body has
+     *             been read.
      */
     public boolean isFinished() {
         return coyoteRequest.isFinished();
@@ -2677,9 +2598,8 @@ public class Request implements HttpServletRequest {
 
 
     /**
-     * Check the configuration for aborted uploads and if configured to do so,
-     * disable the swallowing of any remaining input and close the connection
-     * once the response has been written.
+     * Check the configuration for aborted uploads and if configured to do so, disable the swallowing of any remaining
+     * input and close the connection once the response has been written.
      */
     protected void checkSwallowInput() {
         Context context = getContext();
@@ -2692,11 +2612,9 @@ public class Request implements HttpServletRequest {
      * {@inheritDoc}
      */
     @Override
-    public boolean authenticate(HttpServletResponse response)
-            throws IOException, ServletException {
+    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {
         if (response.isCommitted()) {
-            throw new IllegalStateException(
-                    sm.getString("coyoteRequest.authenticate.ise"));
+            throw new IllegalStateException(sm.getString("coyoteRequest.authenticate.ise"));
         }
 
         return getContext().getAuthenticator().authenticate(this, response);
@@ -2706,12 +2624,9 @@ public class Request implements HttpServletRequest {
      * {@inheritDoc}
      */
     @Override
-    public void login(String username, String password)
-            throws ServletException {
-        if (getAuthType() != null || getRemoteUser() != null ||
-                getUserPrincipal() != null) {
-            throw new ServletException(
-                    sm.getString("coyoteRequest.alreadyAuthenticated"));
+    public void login(String username, String password) throws ServletException {
+        if (getAuthType() != null || getRemoteUser() != null || getUserPrincipal() != null) {
+            throw new ServletException(sm.getString("coyoteRequest.alreadyAuthenticated"));
         }
 
         getContext().getAuthenticator().login(username, password, this);
@@ -2729,8 +2644,7 @@ public class Request implements HttpServletRequest {
      * {@inheritDoc}
      */
     @Override
-    public Collection<Part> getParts() throws IOException, IllegalStateException,
-            ServletException {
+    public Collection<Part> getParts() throws IOException, IllegalStateException, ServletException {
 
         parseParts(true);
 
@@ -2758,13 +2672,12 @@ public class Request implements HttpServletRequest {
         MultipartConfigElement mce = getWrapper().getMultipartConfigElement();
 
         if (mce == null) {
-            if(context.getAllowCasualMultipartParsing()) {
-                mce = new MultipartConfigElement(null, connector.getMaxPostSize(),
-                        connector.getMaxPostSize(), connector.getMaxPostSize());
+            if (context.getAllowCasualMultipartParsing()) {
+                mce = new MultipartConfigElement(null, connector.getMaxPostSize(), connector.getMaxPostSize(),
+                        connector.getMaxPostSize());
             } else {
                 if (explicit) {
-                    partsParseException = new IllegalStateException(
-                            sm.getString("coyoteRequest.noMultipartConfig"));
+                    partsParseException = new IllegalStateException(sm.getString("coyoteRequest.noMultipartConfig"));
                     return;
                 } else {
                     parts = Collections.emptyList();
@@ -2782,32 +2695,27 @@ public class Request implements HttpServletRequest {
             File location;
             String locationStr = mce.getLocation();
             if (locationStr == null || locationStr.length() == 0) {
-                location = ((File) context.getServletContext().getAttribute(
-                        ServletContext.TEMPDIR));
+                location = ((File) context.getServletContext().getAttribute(ServletContext.TEMPDIR));
             } else {
                 // If relative, it is relative to TEMPDIR
                 location = new File(locationStr);
                 if (!location.isAbsolute()) {
-                    location = new File(
-                            (File) context.getServletContext().getAttribute(ServletContext.TEMPDIR),
+                    location = new File((File) context.getServletContext().getAttribute(ServletContext.TEMPDIR),
                             locationStr).getAbsoluteFile();
                 }
             }
 
             if (!location.exists() && context.getCreateUploadTargets()) {
-                log.warn(sm.getString("coyoteRequest.uploadCreate",
-                        location.getAbsolutePath(), getMappingData().wrapper.getName()));
+                log.warn(sm.getString("coyoteRequest.uploadCreate", location.getAbsolutePath(),
+                        getMappingData().wrapper.getName()));
                 if (!location.mkdirs()) {
-                    log.warn(sm.getString("coyoteRequest.uploadCreateFail",
-                            location.getAbsolutePath()));
+                    log.warn(sm.getString("coyoteRequest.uploadCreateFail", location.getAbsolutePath()));
                 }
             }
 
             if (!location.isDirectory()) {
                 parameters.setParseFailedReason(FailReason.MULTIPART_CONFIG_INVALID);
-                partsParseException = new IOException(
-                        sm.getString("coyoteRequest.uploadLocationInvalid",
-                                location));
+                partsParseException = new IOException(sm.getString("coyoteRequest.uploadLocationInvalid", location));
                 return;
             }
 
@@ -2837,8 +2745,7 @@ public class Request implements HttpServletRequest {
 
             parts = new ArrayList<>();
             try {
-                List<FileItem> items =
-                        upload.parseRequest(new ServletRequestContext(this));
+                List<FileItem> items = upload.parseRequest(new ServletRequestContext(this));
                 int maxPostSize = getConnector().getMaxPostSize();
                 int postSize = 0;
                 Charset charset = getCharset();
@@ -2859,8 +2766,7 @@ public class Request implements HttpServletRequest {
                             postSize++;
                             if (postSize > maxPostSize) {
                                 parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);
-                                throw new IllegalStateException(sm.getString(
-                                        "coyoteRequest.maxPostSizeExceeded"));
+                                throw new IllegalStateException(sm.getString("coyoteRequest.maxPostSizeExceeded"));
                             }
                         }
                         String value = null;
@@ -2905,8 +2811,7 @@ public class Request implements HttpServletRequest {
      * {@inheritDoc}
      */
     @Override
-    public Part getPart(String name) throws IOException, IllegalStateException,
-            ServletException {
+    public Part getPart(String name) throws IOException, IllegalStateException, ServletException {
         for (Part part : getParts()) {
             if (name.equals(part.getName())) {
                 return part;
@@ -2937,7 +2842,7 @@ public class Request implements HttpServletRequest {
         // Return the requested session if it exists and is valid
         Manager manager = context.getManager();
         if (manager == null) {
-            return null;      // Sessions are not supported
+            return null; // Sessions are not supported
         }
         if (requestedSessionId != null) {
             try {
@@ -2963,8 +2868,8 @@ public class Request implements HttpServletRequest {
         if (!create) {
             return null;
         }
-        boolean trackModesIncludesCookie =
-                context.getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.COOKIE);
+        boolean trackModesIncludesCookie = context.getServletContext().getEffectiveSessionTrackingModes()
+                .contains(SessionTrackingMode.COOKIE);
         if (trackModesIncludesCookie && response.getResponse().isCommitted()) {
             throw new IllegalStateException(sm.getString("coyoteRequest.sessionCreateCommitted"));
         }
@@ -2975,17 +2880,15 @@ public class Request implements HttpServletRequest {
         if (requestedSessionSSL) {
             // If the session ID has been obtained from the SSL handshake then
             // use it.
-        } else if (("/".equals(context.getSessionCookiePath())
-                && isRequestedSessionIdFromCookie())) {
-            /* This is the common(ish) use case: using the same session ID with
-             * multiple web applications on the same host. Typically this is
-             * used by Portlet implementations. It only works if sessions are
-             * tracked via cookies. The cookie must have a path of "/" else it
-             * won't be provided for requests to all web applications.
+        } else if (("/".equals(context.getSessionCookiePath()) && isRequestedSessionIdFromCookie())) {
+            /*
+             * This is the common(ish) use case: using the same session ID with multiple web applications on the same
+             * host. Typically this is used by Portlet implementations. It only works if sessions are tracked via
+             * cookies. The cookie must have a path of "/" else it won't be provided for requests to all web
+             * applications.
              *
-             * Any session ID provided by the client should be for a session
-             * that already exists somewhere on the host. Check if the context
-             * is configured for this to be confirmed.
+             * Any session ID provided by the client should be for a session that already exists somewhere on the host.
+             * Check if the context is configured for this to be confirmed.
              */
             if (context.getValidateClientProvidedNewSessionId()) {
                 boolean found = false;
@@ -3014,8 +2917,8 @@ public class Request implements HttpServletRequest {
 
         // Creating a new session cookie based on that session
         if (session != null && trackModesIncludesCookie) {
-            Cookie cookie = ApplicationSessionCookieConfig.createSessionCookie(
-                    context, session.getIdInternal(), isSecure());
+            Cookie cookie = ApplicationSessionCookieConfig.createSessionCookie(context, session.getIdInternal(),
+                    isSecure());
 
             response.addSessionCookieInternal(cookie);
         }
@@ -3029,20 +2932,20 @@ public class Request implements HttpServletRequest {
     }
 
     protected String unescape(String s) {
-        if (s==null) {
+        if (s == null) {
             return null;
         }
         if (s.indexOf('\\') == -1) {
             return s;
         }
         StringBuilder buf = new StringBuilder();
-        for (int i=0; i<s.length(); i++) {
+        for (int i = 0; i < s.length(); i++) {
             char c = s.charAt(i);
-            if (c!='\\') {
+            if (c != '\\') {
                 buf.append(c);
             } else {
                 if (++i >= s.length()) {
-                    throw new IllegalArgumentException();//invalid escape, hence invalid cookie
+                    throw new IllegalArgumentException();// invalid escape, hence invalid cookie
                 }
                 c = s.charAt(i);
                 buf.append(c);
@@ -3064,8 +2967,8 @@ public class Request implements HttpServletRequest {
     }
 
     /**
-     * Parse cookies. This only parses the cookies into the memory efficient
-     * ServerCookies structure. It does not populate the Cookie objects.
+     * Parse cookies. This only parses the cookies into the memory efficient ServerCookies structure. It does not
+     * populate the Cookie objects.
      */
     protected void parseCookies() {
         if (cookiesParsed) {
@@ -3080,8 +2983,7 @@ public class Request implements HttpServletRequest {
     }
 
     /**
-     * Converts the parsed cookies (parsing the Cookie headers first if they
-     * have not been parsed) into Cookie objects.
+     * Converts the parsed cookies (parsing the Cookie headers first if they have not been parsed) into Cookie objects.
      */
     protected void convertCookies() {
         if (cookiesConverted) {
@@ -3101,21 +3003,21 @@ public class Request implements HttpServletRequest {
 
         cookies = new Cookie[count];
 
-        int idx=0;
+        int idx = 0;
         for (int i = 0; i < count; i++) {
             ServerCookie scookie = serverCookies.getCookie(i);
             try {
                 // We must unescape the '\\' escape character
-                Cookie cookie = new Cookie(scookie.getName().toString(),null);
+                Cookie cookie = new Cookie(scookie.getName().toString(), null);
                 scookie.getValue().getByteChunk().setCharset(getCookieProcessor().getCharset());
                 cookie.setValue(unescape(scookie.getValue().toString()));
                 cookies[idx++] = cookie;
-            } catch(IllegalArgumentException e) {
+            } catch (IllegalArgumentException e) {
                 // Ignore bad cookie
             }
         }
-        if( idx < count ) {
-            Cookie [] ncookies = new Cookie[idx];
+        if (idx < count) {
+            Cookie[] ncookies = new Cookie[idx];
             System.arraycopy(cookies, 0, ncookies, 0, idx);
             cookies = ncookies;
         }
@@ -3145,7 +3047,7 @@ public class Request implements HttpServletRequest {
                 parameters.setQueryStringCharset(charset);
             }
             // Note: If !useBodyEncodingForURI, the query string encoding is
-            //       that set towards the start of CoyoyeAdapter.service()
+            // that set towards the start of CoyoyeAdapter.service()
 
             parameters.handleQueryParameters();
 
@@ -3171,7 +3073,7 @@ public class Request implements HttpServletRequest {
                 return;
             }
 
-            if( !getConnector().isParseBodyMethod(getMethod()) ) {
+            if (!getConnector().isParseBodyMethod(getMethod())) {
                 success = true;
                 return;
             }
@@ -3188,8 +3090,7 @@ public class Request implements HttpServletRequest {
                 if ((maxPostSize >= 0) && (len > maxPostSize)) {
                     Context context = getContext();
                     if (context != null && context.getLogger().isDebugEnabled()) {
-                        context.getLogger().debug(
-                                sm.getString("coyoteRequest.postTooLarge"));
+                        context.getLogger().debug(sm.getString("coyoteRequest.postTooLarge"));
                     }
                     checkSwallowInput();
                     parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);
@@ -3213,15 +3114,13 @@ public class Request implements HttpServletRequest {
                     // Client disconnect
                     Context context = getContext();
                     if (context != null && context.getLogger().isDebugEnabled()) {
-                        context.getLogger().debug(
-                                sm.getString("coyoteRequest.parseParameters"), e);
+                        context.getLogger().debug(sm.getString("coyoteRequest.parseParameters"), e);
                     }
                     parameters.setParseFailedReason(FailReason.CLIENT_DISCONNECT);
                     return;
                 }
                 parameters.processParameters(formData, 0, len);
-            } else if ("chunked".equalsIgnoreCase(
-                    coyoteRequest.getHeader("transfer-encoding"))) {
+            } else if ("chunked".equalsIgnoreCase(coyoteRequest.getHeader("transfer-encoding"))) {
                 byte[] formData = null;
                 try {
                     formData = readChunkedPostBody();
@@ -3230,9 +3129,7 @@ public class Request implements HttpServletRequest {
                     parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);
                     Context context = getContext();
                     if (context != null && context.getLogger().isDebugEnabled()) {
-                        context.getLogger().debug(
-                                sm.getString("coyoteRequest.parseParameters"),
-                                ise);
+                        context.getLogger().debug(sm.getString("coyoteRequest.parseParameters"), ise);
                     }
                     return;
                 } catch (IOException e) {
@@ -3240,8 +3137,7 @@ public class Request implements HttpServletRequest {
                     parameters.setParseFailedReason(FailReason.CLIENT_DISCONNECT);
                     Context context = getContext();
                     if (context != null && context.getLogger().isDebugEnabled()) {
-                        context.getLogger().debug(
-                                sm.getString("coyoteRequest.parseParameters"), e);
+                        context.getLogger().debug(sm.getString("coyoteRequest.parseParameters"), e);
                     }
                     return;
                 }
@@ -3263,12 +3159,13 @@ public class Request implements HttpServletRequest {
      * Read post body in an array.
      *
      * @param body The bytes array in which the body will be read
-     * @param len The body length
+     * @param len  The body length
+     *
      * @return the bytes count that has been read
+     *
      * @throws IOException if an IO exception occurred
      */
-    protected int readPostBody(byte[] body, int len)
-            throws IOException {
+    protected int readPostBody(byte[] body, int len) throws IOException {
 
         int offset = 0;
         do {
@@ -3287,6 +3184,7 @@ public class Request implements HttpServletRequest {
      * Read chunked post body.
      *
      * @return the post body as a bytes array
+     *
      * @throws IOException if an IO exception occurred
      */
     protected byte[] readChunkedPostBody() throws IOException {
@@ -3297,12 +3195,10 @@ public class Request implements HttpServletRequest {
         int len = 0;
         while (len > -1) {
             len = getStream().read(buffer, 0, CACHED_POST_LEN);
-            if (connector.getMaxPostSize() >= 0 &&
-                    (body.getLength() + len) > connector.getMaxPostSize()) {
+            if (connector.getMaxPostSize() >= 0 && (body.getLength() + len) > connector.getMaxPostSize()) {
                 // Too much data
                 checkSwallowInput();
-                throw new IllegalStateException(
-                        sm.getString("coyoteRequest.chunkedPostTooLarge"));
+                throw new IllegalStateException(sm.getString("coyoteRequest.chunkedPostTooLarge"));
             }
             if (len > 0) {
                 body.append(buffer, 0, len);
@@ -3331,7 +3227,7 @@ public class Request implements HttpServletRequest {
 
         // Store the accumulated languages that have been requested in
         // a local collection, sorted by the quality value (so we can
-        // add Locales in descending order).  The values will be ArrayLists
+        // add Locales in descending order). The values will be ArrayLists
         // containing the corresponding Locales to be added
         TreeMap<Double, ArrayList<Locale>> locales = new TreeMap<>();
 
@@ -3355,7 +3251,7 @@ public class Request implements HttpServletRequest {
     /**
      * Parse accept-language header value.
      *
-     * @param value the header value
+     * @param value   the header value
      * @param locales the map that will hold the result
      */
     protected void parseLocalesHeader(String value, TreeMap<Double, ArrayList<Locale>> locales) {
@@ -3371,7 +3267,7 @@ public class Request implements HttpServletRequest {
 
         for (AcceptLanguage acceptLanguage : acceptLanguages) {
             // Add a new Locale to the list of Locales for this quality level
-            Double key = Double.valueOf(-acceptLanguage.getQuality());  // Reverse the order
+            Double key = Double.valueOf(-acceptLanguage.getQuality()); // Reverse the order
             locales.computeIfAbsent(key, k -> new ArrayList<>()).add(acceptLanguage.getLocale());
         }
     }
@@ -3391,117 +3287,106 @@ public class Request implements HttpServletRequest {
     private static final Map<String, SpecialAttributeAdapter> specialAttributes = new HashMap<>();
 
     static {
-        specialAttributes.put(Globals.DISPATCHER_TYPE_ATTR,
-                new SpecialAttributeAdapter() {
-                    @Override
-                    public Object get(Request request, String name) {
-                        return (request.internalDispatcherType == null) ? DispatcherType.REQUEST
-                                : request.internalDispatcherType;
-                    }
+        specialAttributes.put(Globals.DISPATCHER_TYPE_ATTR, new SpecialAttributeAdapter() {
+            @Override
+            public Object get(Request request, String name) {
+                return (request.internalDispatcherType == null) ? DispatcherType.REQUEST
+                        : request.internalDispatcherType;
+            }
 
-                    @Override
-                    public void set(Request request, String name, Object value) {
-                        request.internalDispatcherType = (DispatcherType) value;
-                    }
-                });
-        specialAttributes.put(Globals.DISPATCHER_REQUEST_PATH_ATTR,
-                new SpecialAttributeAdapter() {
-                    @Override
-                    public Object get(Request request, String name) {
-                        return (request.requestDispatcherPath == null) ? request
-                                .getRequestPathMB().toString()
-                                : request.requestDispatcherPath.toString();
-                    }
+            @Override
+            public void set(Request request, String name, Object value) {
+                request.internalDispatcherType = (DispatcherType) value;
+            }
+        });
+        specialAttributes.put(Globals.DISPATCHER_REQUEST_PATH_ATTR, new SpecialAttributeAdapter() {
+            @Override
+            public Object get(Request request, String name) {
+                return (request.requestDispatcherPath == null) ? request.getRequestPathMB().toString()
+                        : request.requestDispatcherPath.toString();
+            }
 
-                    @Override
-                    public void set(Request request, String name, Object value) {
-                        request.requestDispatcherPath = value;
-                    }
-                });
-        specialAttributes.put(Globals.ASYNC_SUPPORTED_ATTR,
-                new SpecialAttributeAdapter() {
-                    @Override
-                    public Object get(Request request, String name) {
-                        return request.asyncSupported;
-                    }
+            @Override
+            public void set(Request request, String name, Object value) {
+                request.requestDispatcherPath = value;
+            }
+        });
+        specialAttributes.put(Globals.ASYNC_SUPPORTED_ATTR, new SpecialAttributeAdapter() {
+            @Override
+            public Object get(Request request, String name) {
+                return request.asyncSupported;
+            }
 
-                    @Override
-                    public void set(Request request, String name, Object value) {
-                        Boolean oldValue = request.asyncSupported;
-                        request.asyncSupported = (Boolean)value;
-                        request.notifyAttributeAssigned(name, value, oldValue);
-                    }
-                });
-        specialAttributes.put(Globals.GSS_CREDENTIAL_ATTR,
-                new SpecialAttributeAdapter() {
-                    @Override
-                    public Object get(Request request, String name) {
-                        if (request.userPrincipal instanceof TomcatPrincipal) {
-                            return ((TomcatPrincipal) request.userPrincipal)
-                                    .getGssCredential();
-                        }
-                        return null;
-                    }
+            @Override
+            public void set(Request request, String name, Object value) {
+                Boolean oldValue = request.asyncSupported;
+                request.asyncSupported = (Boolean) value;
+                request.notifyAttributeAssigned(name, value, oldValue);
+            }
+        });
+        specialAttributes.put(Globals.GSS_CREDENTIAL_ATTR, new SpecialAttributeAdapter() {
+            @Override
+            public Object get(Request request, String name) {
+                if (request.userPrincipal instanceof TomcatPrincipal) {
+                    return ((TomcatPrincipal) request.userPrincipal).getGssCredential();
+                }
+                return null;
+            }
 
-                    @Override
-                    public void set(Request request, String name, Object value) {
-                        // NO-OP
-                    }
-                });
-        specialAttributes.put(Globals.PARAMETER_PARSE_FAILED_ATTR,
-                new SpecialAttributeAdapter() {
-                    @Override
-                    public Object get(Request request, String name) {
-                        if (request.getCoyoteRequest().getParameters()
-                                .isParseFailed()) {
-                            return Boolean.TRUE;
-                        }
-                        return null;
-                    }
+            @Override
+            public void set(Request request, String name, Object value) {
+                // NO-OP
+            }
+        });
+        specialAttributes.put(Globals.PARAMETER_PARSE_FAILED_ATTR, new SpecialAttributeAdapter() {
+            @Override
+            public Object get(Request request, String name) {
+                if (request.getCoyoteRequest().getParameters().isParseFailed()) {
+                    return Boolean.TRUE;
+                }
+                return null;
+            }
 
-                    @Override
-                    public void set(Request request, String name, Object value) {
-                        // NO-OP
-                    }
-                });
-        specialAttributes.put(Globals.PARAMETER_PARSE_FAILED_REASON_ATTR,
-                new SpecialAttributeAdapter() {
-                    @Override
-                    public Object get(Request request, String name) {
-                        return request.getCoyoteRequest().getParameters().getParseFailedReason();
-                    }
+            @Override
+            public void set(Request request, String name, Object value) {
+                // NO-OP
+            }
+        });
+        specialAttributes.put(Globals.PARAMETER_PARSE_FAILED_REASON_ATTR, new SpecialAttributeAdapter() {
+            @Override
+            public Object get(Request request, String name) {
+                return request.getCoyoteRequest().getParameters().getParseFailedReason();
+            }
 
-                    @Override
-                    public void set(Request request, String name, Object value) {
-                        // NO-OP
-                    }
-                });
-        specialAttributes.put(Globals.SENDFILE_SUPPORTED_ATTR,
-                new SpecialAttributeAdapter() {
-                    @Override
-                    public Object get(Request request, String name) {
-                        return Boolean.valueOf(
-                                request.getConnector().getProtocolHandler(
-                                        ).isSendfileSupported() && request.getCoyoteRequest().getSendfile());
-                    }
-                    @Override
-                    public void set(Request request, String name, Object value) {
-                        // NO-OP
-                    }
-                });
-        specialAttributes.put(Globals.REMOTE_IP_FILTER_SECURE,
-            new SpecialAttributeAdapter() {
-                @Override
-                public Object get(Request request, String name) {
-                    return Boolean.valueOf(request.isSecure());
-                }
+            @Override
+            public void set(Request request, String name, Object value) {
+                // NO-OP
+            }
+        });
+        specialAttributes.put(Globals.SENDFILE_SUPPORTED_ATTR, new SpecialAttributeAdapter() {
+            @Override
+            public Object get(Request request, String name) {
+                return Boolean.valueOf(request.getConnector().getProtocolHandler().isSendfileSupported() &&
+                        request.getCoyoteRequest().getSendfile());
+            }
 
-                @Override
-                public void set(Request request, String name, Object value) {
-                    if (value instanceof Boolean) {
-                        request.setSecure(((Boolean) value).booleanValue());
-                    }
+            @Override
+            public void set(Request request, String name, Object value) {
+                // NO-OP
+            }
+        });
+        specialAttributes.put(Globals.REMOTE_IP_FILTER_SECURE, new SpecialAttributeAdapter() {
+            @Override
+            public Object get(Request request, String name) {
+                return Boolean.valueOf(request.isSecure());
+            }
+
+            @Override
+            public void set(Request request, String name, Object value) {
+                if (value instanceof Boolean) {
+                    request.setSecure(((Boolean) value).booleanValue());
                 }
-            });
+            }
+        });
     }
 }

==================================================
Response.java
index 382dda04ba..f29aba048d 100644
--- a/java/org/apache/catalina/connector/RequestFacade.java
+++ b/java/org/apache/catalina/connector/RequestFacade.java
@@ -45,8 +45,7 @@ import jakarta.servlet.http.PushBuilder;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
- * Facade class that wraps a Coyote request object.
- * All methods are delegated to the wrapped request.
+ * Facade class that wraps a Coyote request object. All methods are delegated to the wrapped request.
  *
  * @author Craig R. McClanahan
  * @author Remy Maucherat
@@ -85,8 +84,7 @@ public class RequestFacade implements HttpServletRequest {
      * Prevent cloning the facade.
      */
     @Override
-    protected Object clone()
-        throws CloneNotSupportedException {
+    protected Object clone() throws CloneNotSupportedException {
         throw new CloneNotSupportedException();
     }
 
@@ -171,7 +169,7 @@ public class RequestFacade implements HttpServletRequest {
 
 
     @Override
-    public Map<String,String[]> getParameterMap() {
+    public Map<String, String[]> getParameterMap() {
         checkFacade();
         return request.getParameterMap();
     }
@@ -569,8 +567,8 @@ public class RequestFacade implements HttpServletRequest {
 
 
     @Override
-    public <T extends HttpUpgradeHandler> T upgrade(
-            Class<T> httpUpgradeHandlerClass) throws java.io.IOException, ServletException {
+    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass)
+            throws java.io.IOException, ServletException {
         checkFacade();
         return request.upgrade(httpUpgradeHandlerClass);
     }

==================================================
ResponseFacade.java
index e44076ed5b..9ba8a399c6 100644
--- a/java/org/apache/catalina/connector/Response.java
+++ b/java/org/apache/catalina/connector/Response.java
@@ -179,8 +179,8 @@ public class Response implements HttpServletResponse {
 
 
     /*
-     * Not strictly required but it makes generating HTTP/2 push requests a lot
-     * easier if these are retained until the response is recycled.
+     * Not strictly required but it makes generating HTTP/2 push requests a lot easier if these are retained until the
+     * response is recycled.
      */
     private final List<Cookie> cookies = new ArrayList<>();
 
@@ -190,8 +190,7 @@ public class Response implements HttpServletResponse {
     // --------------------------------------------------------- Public Methods
 
     /**
-     * Release all object references, and initialize instance variables, in
-     * preparation for reuse of this object.
+     * Release all object references, and initialize instance variables, in preparation for reuse of this object.
      */
     public void recycle() {
 
@@ -232,9 +231,8 @@ public class Response implements HttpServletResponse {
     // ------------------------------------------------------- Response Methods
 
     /**
-     * @return the number of bytes the application has actually written to the
-     * output stream. This excludes chunking, compression, etc. as well as
-     * headers.
+     * @return the number of bytes the application has actually written to the output stream. This excludes chunking,
+     *             compression, etc. as well as headers.
      */
     public long getContentWritten() {
         return outputBuffer.getContentWritten();
@@ -242,8 +240,9 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * @return the number of bytes the actually written to the socket. This
-     * includes chunking, compression, etc. but excludes headers.
+     * @return the number of bytes the actually written to the socket. This includes chunking, compression, etc. but
+     *             excludes headers.
+     *
      * @param flush if <code>true</code> will perform a buffer flush first
      */
     public long getBytesWritten(boolean flush) {
@@ -273,9 +272,8 @@ public class Response implements HttpServletResponse {
      * @return <code>true</code> if the application has committed the response
      */
     public boolean isAppCommitted() {
-        return this.appCommitted || isCommitted() || isSuspended()
-                || ((getContentLength() > 0)
-                    && (getContentWritten() >= getContentLength()));
+        return this.appCommitted || isCommitted() || isSuspended() ||
+                ((getContentLength() > 0) && (getContentWritten() >= getContentLength()));
     }
 
 
@@ -308,8 +306,7 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * @return the <code>ServletResponse</code> for which this object
-     * is the facade.
+     * @return the <code>ServletResponse</code> for which this object is the facade.
      */
     public HttpServletResponse getResponse() {
         if (facade == null) {
@@ -323,13 +320,10 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * Set a wrapped HttpServletResponse to pass to the application. Components
-     * wishing to wrap the response should obtain the response via
-     * {@link #getResponse()}, wrap it and then call this method with the
-     * wrapped response.
+     * Set a wrapped HttpServletResponse to pass to the application. Components wishing to wrap the response should
+     * obtain the response via {@link #getResponse()}, wrap it and then call this method with the wrapped response.
      *
-     * @param applicationResponse The wrapped response to pass to the
-     *        application
+     * @param applicationResponse The wrapped response to pass to the application
      */
     public void setResponse(HttpServletResponse applicationResponse) {
         // Check the wrapper wraps this request
@@ -405,8 +399,7 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * Perform whatever actions are required to flush and close the output
-     * stream or writer, in a single operation.
+     * Perform whatever actions are required to flush and close the output stream or writer, in a single operation.
      *
      * @exception IOException if an input/output error occurs
      */
@@ -425,8 +418,8 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * @return the content type that was set or calculated for this response,
-     * or <code>null</code> if no content type was set.
+     * @return the content type that was set or calculated for this response, or <code>null</code> if no content type
+     *             was set.
      */
     @Override
     public String getContentType() {
@@ -435,14 +428,12 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * Return a PrintWriter that can be used to render error messages,
-     * regardless of whether a stream or writer has already been acquired.
+     * Return a PrintWriter that can be used to render error messages, regardless of whether a stream or writer has
+     * already been acquired.
      *
-     * @return Writer which can be used for error reports. If the response is
-     * not an error report returned using sendError or triggered by an
-     * unexpected exception thrown during the servlet processing
-     * (and only in that case), null will be returned if the response stream
-     * has already been used.
+     * @return Writer which can be used for error reports. If the response is not an error report returned using
+     *             sendError or triggered by an unexpected exception thrown during the servlet processing (and only in
+     *             that case), null will be returned if the response stream has already been used.
      *
      * @exception IOException if an input/output error occurs
      */
@@ -506,17 +497,14 @@ public class Response implements HttpServletResponse {
     /**
      * @return the servlet output stream associated with this Response.
      *
-     * @exception IllegalStateException if <code>getWriter</code> has
-     *  already been called for this response
-     * @exception IOException if an input/output error occurs
+     * @exception IllegalStateException if <code>getWriter</code> has already been called for this response
+     * @exception IOException           if an input/output error occurs
      */
     @Override
-    public ServletOutputStream getOutputStream()
-        throws IOException {
+    public ServletOutputStream getOutputStream() throws IOException {
 
         if (usingWriter) {
-            throw new IllegalStateException
-                (sm.getString("coyoteResponse.getOutputStream.ise"));
+            throw new IllegalStateException(sm.getString("coyoteResponse.getOutputStream.ise"));
         }
 
         usingOutputStream = true;
@@ -540,31 +528,24 @@ public class Response implements HttpServletResponse {
     /**
      * @return the writer associated with this Response.
      *
-     * @exception IllegalStateException if <code>getOutputStream</code> has
-     *  already been called for this response
-     * @exception IOException if an input/output error occurs
+     * @exception IllegalStateException if <code>getOutputStream</code> has already been called for this response
+     * @exception IOException           if an input/output error occurs
      */
     @Override
-    public PrintWriter getWriter()
-        throws IOException {
+    public PrintWriter getWriter() throws IOException {
 
         if (usingOutputStream) {
-            throw new IllegalStateException
-                (sm.getString("coyoteResponse.getWriter.ise"));
+            throw new IllegalStateException(sm.getString("coyoteResponse.getWriter.ise"));
         }
 
         if (request.getConnector().getEnforceEncodingInGetWriter()) {
             /*
-             * If the response's character encoding has not been specified as
-             * described in <code>getCharacterEncoding</code> (i.e., the method
-             * just returns the default value <code>ISO-8859-1</code>),
-             * <code>getWriter</code> updates it to <code>ISO-8859-1</code>
-             * (with the effect that a subsequent call to getContentType() will
-             * include a charset=ISO-8859-1 component which will also be
-             * reflected in the Content-Type response header, thereby satisfying
-             * the Servlet spec requirement that containers must communicate the
-             * character encoding used for the servlet response's writer to the
-             * client).
+             * If the response's character encoding has not been specified as described in
+             * <code>getCharacterEncoding</code> (i.e., the method just returns the default value
+             * <code>ISO-8859-1</code>), <code>getWriter</code> updates it to <code>ISO-8859-1</code> (with the effect
+             * that a subsequent call to getContentType() will include a charset=ISO-8859-1 component which will also be
+             * reflected in the Content-Type response header, thereby satisfying the Servlet spec requirement that
+             * containers must communicate the character encoding used for the servlet response's writer to the client).
              */
             setCharacterEncoding(getCharacterEncoding());
         }
@@ -592,8 +573,7 @@ public class Response implements HttpServletResponse {
     /**
      * Clear any content written to the buffer.
      *
-     * @exception IllegalStateException if this response has already
-     *  been committed
+     * @exception IllegalStateException if this response has already been committed
      */
     @Override
     public void reset() {
@@ -613,8 +593,7 @@ public class Response implements HttpServletResponse {
     /**
      * Reset the data buffer but not any status or header information.
      *
-     * @exception IllegalStateException if the response has already
-     *  been committed
+     * @exception IllegalStateException if the response has already been committed
      */
     @Override
     public void resetBuffer() {
@@ -623,26 +602,23 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * Reset the data buffer and the using Writer/Stream flags but not any
-     * status or header information.
+     * Reset the data buffer and the using Writer/Stream flags but not any status or header information.
      *
-     * @param resetWriterStreamFlags <code>true</code> if the internal
-     *        <code>usingWriter</code>, <code>usingOutputStream</code>,
-     *        <code>isCharacterEncodingSet</code> flags should also be reset
+     * @param resetWriterStreamFlags <code>true</code> if the internal <code>usingWriter</code>,
+     *                                   <code>usingOutputStream</code>, <code>isCharacterEncodingSet</code> flags
+     *                                   should also be reset
      *
-     * @exception IllegalStateException if the response has already
-     *  been committed
+     * @exception IllegalStateException if the response has already been committed
      */
     public void resetBuffer(boolean resetWriterStreamFlags) {
 
         if (isCommitted()) {
-            throw new IllegalStateException
-                (sm.getString("coyoteResponse.resetBuffer.ise"));
+            throw new IllegalStateException(sm.getString("coyoteResponse.resetBuffer.ise"));
         }
 
         outputBuffer.reset(resetWriterStreamFlags);
 
-        if(resetWriterStreamFlags) {
+        if (resetWriterStreamFlags) {
             usingOutputStream = false;
             usingWriter = false;
             isCharacterEncodingSet = false;
@@ -656,15 +632,13 @@ public class Response implements HttpServletResponse {
      *
      * @param size The new buffer size
      *
-     * @exception IllegalStateException if this method is called after
-     *  output has been committed for this response
+     * @exception IllegalStateException if this method is called after output has been committed for this response
      */
     @Override
     public void setBufferSize(int size) {
 
         if (isCommitted() || !outputBuffer.isNew()) {
-            throw new IllegalStateException
-                (sm.getString("coyoteResponse.setBufferSize.ise"));
+            throw new IllegalStateException(sm.getString("coyoteResponse.setBufferSize.ise"));
         }
 
         outputBuffer.setBufferSize(size);
@@ -758,9 +732,8 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * Overrides the name of the character encoding used in the body
-     * of the request. This method must be called prior to reading
-     * request parameters or reading input using getReader().
+     * Overrides the name of the character encoding used in the body of the request. This method must be called prior to
+     * reading request parameters or reading input using getReader().
      *
      * @param encoding String containing the name of the character encoding.
      */
@@ -825,8 +798,7 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * Set the Locale that is appropriate for this response, including
-     * setting the appropriate character encoding.
+     * Set the Locale that is appropriate for this response, including setting the appropriate character encoding.
      *
      * @param locale The new locale
      */
@@ -909,8 +881,7 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * @return the error message that was set with <code>sendError()</code>
-     * for this Response.
+     * @return the error message that was set with <code>sendError()</code> for this Response.
      */
     public String getMessage() {
         return getCoyoteResponse().getMessage();
@@ -926,8 +897,7 @@ public class Response implements HttpServletResponse {
     // -------------------------------------------- HttpServletResponse Methods
 
     /**
-     * Add the specified Cookie to those that will be included with
-     * this Response.
+     * Add the specified Cookie to those that will be included with this Response.
      *
      * @param cookie Cookie to be added
      */
@@ -942,13 +912,12 @@ public class Response implements HttpServletResponse {
         cookies.add(cookie);
 
         String header = generateCookieString(cookie);
-        //if we reached here, no exception, cookie is valid
+        // if we reached here, no exception, cookie is valid
         addHeader("Set-Cookie", header, getContext().getCookieProcessor().getCharset());
     }
 
     /**
-     * Special method for adding a session cookie as we should be overriding
-     * any previous.
+     * Special method for adding a session cookie as we should be overriding any previous.
      *
      * @param cookie The new session cookie to add the response
      */
@@ -989,7 +958,7 @@ public class Response implements HttpServletResponse {
     /**
      * Add the specified date header to the specified value.
      *
-     * @param name Name of the header to set
+     * @param name  Name of the header to set
      * @param value Date value to be set
      */
     @Override
@@ -1015,7 +984,7 @@ public class Response implements HttpServletResponse {
     /**
      * Add the specified header to the specified value.
      *
-     * @param name Name of the header to set
+     * @param name  Name of the header to set
      * @param value Value to be set
      */
     @Override
@@ -1039,8 +1008,8 @@ public class Response implements HttpServletResponse {
             return;
         }
 
-        char cc=name.charAt(0);
-        if (cc=='C' || cc=='c') {
+        char cc = name.charAt(0);
+        if (cc == 'C' || cc == 'c') {
             if (checkSpecialHeader(name, value)) {
                 return;
             }
@@ -1051,12 +1020,10 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * An extended version of this exists in {@link org.apache.coyote.Response}.
-     * This check is required here to ensure that the usingWriter check in
-     * {@link #setContentType(String)} is applied since usingWriter is not
-     * visible to {@link org.apache.coyote.Response}
+     * An extended version of this exists in {@link org.apache.coyote.Response}. This check is required here to ensure
+     * that the usingWriter check in {@link #setContentType(String)} is applied since usingWriter is not visible to
+     * {@link org.apache.coyote.Response} Called from set/addHeader.
      *
-     * Called from set/addHeader.
      * @return <code>true</code> if the header is special, no need to set the header.
      */
     private boolean checkSpecialHeader(String name, String value) {
@@ -1071,7 +1038,7 @@ public class Response implements HttpServletResponse {
     /**
      * Add the specified integer header to the specified value.
      *
-     * @param name Name of the header to set
+     * @param name  Name of the header to set
      * @param value Integer value to be set
      */
     @Override
@@ -1099,19 +1066,20 @@ public class Response implements HttpServletResponse {
      * Has the specified header been set already in this response?
      *
      * @param name Name of the header to check
+     *
      * @return <code>true</code> if the header has been set
      */
     @Override
     public boolean containsHeader(String name) {
         // Need special handling for Content-Type and Content-Length due to
         // special handling of these in coyoteResponse
-        char cc=name.charAt(0);
-        if(cc=='C' || cc=='c') {
-            if(name.equalsIgnoreCase("Content-Type")) {
+        char cc = name.charAt(0);
+        if (cc == 'C' || cc == 'c') {
+            if (name.equalsIgnoreCase("Content-Type")) {
                 // Will return null if this has not been set
                 return (getCoyoteResponse().getContentType() != null);
             }
-            if(name.equalsIgnoreCase("Content-Length")) {
+            if (name.equalsIgnoreCase("Content-Length")) {
                 // -1 means not known and is not sent to client
                 return (getCoyoteResponse().getContentLengthLong() != -1);
             }
@@ -1134,10 +1102,10 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * Encode the session identifier associated with this response
-     * into the specified redirect URL, if necessary.
+     * Encode the session identifier associated with this response into the specified redirect URL, if necessary.
      *
      * @param url URL to be encoded
+     *
      * @return <code>true</code> if the URL was encoded
      */
     @Override
@@ -1151,10 +1119,10 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * Encode the session identifier associated with this response
-     * into the specified URL, if necessary.
+     * Encode the session identifier associated with this response into the specified URL, if necessary.
      *
      * @param url URL to be encoded
+     *
      * @return <code>true</code> if the URL was encoded
      */
     @Override
@@ -1186,9 +1154,8 @@ public class Response implements HttpServletResponse {
     /**
      * Send an acknowledgement of a request.
      *
-     * @param continueResponseTiming Indicates when the request for the ACK
-     *                               originated so it can be compared with the
-     *                               configured timing for ACK responses.
+     * @param continueResponseTiming Indicates when the request for the ACK originated so it can be compared with the
+     *                                   configured timing for ACK responses.
      *
      * @exception IOException if an input/output error occurs
      */
@@ -1208,14 +1175,12 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * Send an error response with the specified status and a
-     * default message.
+     * Send an error response with the specified status and a default message.
      *
      * @param status HTTP status code to send
      *
-     * @exception IllegalStateException if this response has
-     *  already been committed
-     * @exception IOException if an input/output error occurs
+     * @exception IllegalStateException if this response has already been committed
+     * @exception IOException           if an input/output error occurs
      */
     @Override
     public void sendError(int status) throws IOException {
@@ -1226,19 +1191,17 @@ public class Response implements HttpServletResponse {
     /**
      * Send an error response with the specified status and message.
      *
-     * @param status HTTP status code to send
+     * @param status  HTTP status code to send
      * @param message Corresponding message to send
      *
-     * @exception IllegalStateException if this response has
-     *  already been committed
-     * @exception IOException if an input/output error occurs
+     * @exception IllegalStateException if this response has already been committed
+     * @exception IOException           if an input/output error occurs
      */
     @Override
     public void sendError(int status, String message) throws IOException {
 
         if (isCommitted()) {
-            throw new IllegalStateException
-                (sm.getString("coyoteResponse.sendError.ise"));
+            throw new IllegalStateException(sm.getString("coyoteResponse.sendError.ise"));
         }
 
         // Ignore any call from an included servlet
@@ -1264,9 +1227,8 @@ public class Response implements HttpServletResponse {
      *
      * @param location Location URL to redirect to
      *
-     * @exception IllegalStateException if this response has
-     *  already been committed
-     * @exception IOException if an input/output error occurs
+     * @exception IllegalStateException if this response has already been committed
+     * @exception IOException           if an input/output error occurs
      */
     @Override
     public void sendRedirect(String location) throws IOException {
@@ -1275,12 +1237,12 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * Internal method that allows a redirect to be sent with a status other
-     * than {@link HttpServletResponse#SC_FOUND} (302). No attempt is made to
-     * validate the status code.
+     * Internal method that allows a redirect to be sent with a status other than {@link HttpServletResponse#SC_FOUND}
+     * (302). No attempt is made to validate the status code.
      *
      * @param location Location URL to redirect to
-     * @param status HTTP status code that will be sent
+     * @param status   HTTP status code that will be sent
+     *
      * @throws IOException an IO exception occurred
      */
     public void sendRedirect(String location, int status) throws IOException {
@@ -1314,8 +1276,7 @@ public class Response implements HttpServletResponse {
             setHeader("Location", locationUri);
             if (context != null && context.getSendRedirectBody()) {
                 PrintWriter writer = getWriter();
-                writer.print(sm.getString("coyoteResponse.sendRedirect.note",
-                        Escape.htmlElementContent(locationUri)));
+                writer.print(sm.getString("coyoteResponse.sendRedirect.note", Escape.htmlElementContent(locationUri)));
                 flushBuffer();
             }
         } catch (IllegalArgumentException e) {
@@ -1331,7 +1292,7 @@ public class Response implements HttpServletResponse {
     /**
      * Set the specified date header to the specified value.
      *
-     * @param name Name of the header to set
+     * @param name  Name of the header to set
      * @param value Date value to be set
      */
     @Override
@@ -1357,7 +1318,7 @@ public class Response implements HttpServletResponse {
     /**
      * Set the specified header to the specified value.
      *
-     * @param name Name of the header to set
+     * @param name  Name of the header to set
      * @param value Value to be set
      */
     @Override
@@ -1376,8 +1337,8 @@ public class Response implements HttpServletResponse {
             return;
         }
 
-        char cc=name.charAt(0);
-        if (cc=='C' || cc=='c') {
+        char cc = name.charAt(0);
+        if (cc == 'C' || cc == 'c') {
             if (checkSpecialHeader(name, value)) {
                 return;
             }
@@ -1390,7 +1351,7 @@ public class Response implements HttpServletResponse {
     /**
      * Set the specified integer header to the specified value.
      *
-     * @param name Name of the header to set
+     * @param name  Name of the header to set
      * @param value Integer value to be set
      */
     @Override
@@ -1438,17 +1399,16 @@ public class Response implements HttpServletResponse {
     // ------------------------------------------------------ Protected Methods
 
     /**
-     * Return <code>true</code> if the specified URL should be encoded with
-     * a session identifier.  This will be true if all of the following
-     * conditions are met:
+     * Return <code>true</code> if the specified URL should be encoded with a session identifier. This will be true if
+     * all of the following conditions are met:
      * <ul>
      * <li>The request we are responding to asked for a valid session
      * <li>The requested session ID was not received via a cookie
-     * <li>The specified URL points back to somewhere within the web
-     *     application that is responding to this request
+     * <li>The specified URL points back to somewhere within the web application that is responding to this request
      * </ul>
      *
      * @param location Absolute URL to be validated
+     *
      * @return <code>true</code> if the URL should be encoded
      */
     protected boolean isEncodeable(final String location) {
@@ -1473,8 +1433,7 @@ public class Response implements HttpServletResponse {
         }
 
         // Is URL encoding permitted
-        if (!hreq.getServletContext().getEffectiveSessionTrackingModes().
-                contains(SessionTrackingMode.URL)) {
+        if (!hreq.getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.URL)) {
             return false;
         }
 
@@ -1482,8 +1441,7 @@ public class Response implements HttpServletResponse {
     }
 
 
-    private static boolean doIsEncodeable(Context context, Request hreq, Session session,
-                                   String location) {
+    private static boolean doIsEncodeable(Context context, Request hreq, Session session, String location) {
         // Is this a valid absolute URL?
         URL url = null;
         try {
@@ -1526,9 +1484,8 @@ public class Response implements HttpServletResponse {
             if (!file.startsWith(contextPath)) {
                 return false;
             }
-            String tok = ";" + SessionConfig.getSessionUriParamName(context) + "=" +
-                    session.getIdInternal();
-            if( file.indexOf(tok, contextPath.length()) >= 0 ) {
+            String tok = ";" + SessionConfig.getSessionUriParamName(context) + "=" + session.getIdInternal();
+            if (file.indexOf(tok, contextPath.length()) >= 0) {
                 return false;
             }
         }
@@ -1540,15 +1497,15 @@ public class Response implements HttpServletResponse {
 
 
     /**
-     * Convert (if necessary) and return the absolute URL that represents the
-     * resource referenced by this possibly relative URL.  If this URL is
-     * already absolute, return it unchanged.
+     * Convert (if necessary) and return the absolute URL that represents the resource referenced by this possibly
+     * relative URL. If this URL is already absolute, return it unchanged.
      *
      * @param location URL to be (possibly) converted and then returned
+     *
      * @return the encoded URL
      *
-     * @exception IllegalArgumentException if a MalformedURLException is
-     *  thrown when converting the relative URL to an absolute one
+     * @exception IllegalArgumentException if a MalformedURLException is thrown when converting the relative URL to an
+     *                                         absolute one
      */
     protected String toAbsolute(String location) {
 
@@ -1584,8 +1541,7 @@ public class Response implements HttpServletResponse {
                 redirectURLCC.append(scheme, 0, scheme.length());
                 redirectURLCC.append("://", 0, 3);
                 redirectURLCC.append(name, 0, name.length());
-                if ((scheme.equals("http") && port != 80)
-                    || (scheme.equals("https") && port != 443)) {
+                if ((scheme.equals("http") && port != 80) || (scheme.equals("https") && port != 443)) {
                     redirectURLCC.append(':');
                     String portS = port + "";
                     redirectURLCC.append(portS, 0, portS.length());
@@ -1616,8 +1572,7 @@ public class Response implements HttpServletResponse {
     }
 
     /**
-     * Removes /./ and /../ sequences from absolute URLs.
-     * Code borrowed heavily from CoyoteAdapter.normalize()
+     * Removes /./ and /../ sequences from absolute URLs. Code borrowed heavily from CoyoteAdapter.normalize()
      *
      * @param cc the char chunk containing the chars to normalize
      */
@@ -1630,8 +1585,7 @@ public class Response implements HttpServletResponse {
         }
         char[] truncateCC = null;
         if (truncate > -1) {
-            truncateCC = Arrays.copyOfRange(cc.getBuffer(),
-                    cc.getStart() + truncate, cc.getEnd());
+            truncateCC = Arrays.copyOfRange(cc.getBuffer(), cc.getStart() + truncate, cc.getEnd());
             cc.setEnd(cc.getStart() + truncate);
         }
 
@@ -1663,8 +1617,7 @@ public class Response implements HttpServletResponse {
             if (index < 0) {
                 break;
             }
-            copyChars(c, start + index, start + index + 2,
-                      end - start - index - 2);
+            copyChars(c, start + index, start + index + 2, end - start - index - 2);
             end = end - 2;
             cc.setEnd(end);
         }
@@ -1682,13 +1635,12 @@ public class Response implements HttpServletResponse {
                 throw new IllegalArgumentException();
             }
             int index2 = -1;
-            for (pos = start + index - 1; (pos >= 0) && (index2 < 0); pos --) {
+            for (pos = start + index - 1; (pos >= 0) && (index2 < 0); pos--) {
                 if (c[pos] == (byte) '/') {
                     index2 = pos;
                 }
             }
-            copyChars(c, start + index2, start + index + 3,
-                      end - start - index - 3);
+            copyChars(c, start + index2, start + index + 3, end - start - index - 3);
             end = end + index2 - index - 3;
             cc.setEnd(end);
             index = index2;
@@ -1713,6 +1665,7 @@ public class Response implements HttpServletResponse {
      * Determine if an absolute URL has a path component.
      *
      * @param uri the URL that will be checked
+     *
      * @return <code>true</code> if the URL has a path
      */
     private boolean hasPath(String uri) {
@@ -1728,11 +1681,11 @@ public class Response implements HttpServletResponse {
     }
 
     /**
-     * Return the specified URL with the specified session identifier
-     * suitably encoded.
+     * Return the specified URL with the specified session identifier suitably encoded.
      *
-     * @param url URL to be encoded with the session id
+     * @param url       URL to be encoded with the session id
      * @param sessionId Session id to be included in the encoded URL
+     *
      * @return the encoded URL
      */
     protected String toEncoded(String url, String sessionId) {
@@ -1754,10 +1707,9 @@ public class Response implements HttpServletResponse {
             path = path.substring(0, pound);
         }
         StringBuilder sb = new StringBuilder(path);
-        if( sb.length() > 0 ) { // jsessionid can't be first.
+        if (sb.length() > 0) { // jsessionid can't be first.
             sb.append(';');
-            sb.append(SessionConfig.getSessionUriParamName(
-                    request.getContext()));
+            sb.append(SessionConfig.getSessionUriParamName(request.getContext()));
             sb.append('=');
             sb.append(sessionId);
         }

==================================================
