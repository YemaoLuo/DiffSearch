4d311a0c3df1272f480fe4e3c61a862f305742fc
==================================================
Pull out implementation specific processing that determines if keep-alive should be broken into a separate method.
==================================================
Mark Emlyn
==================================================
Mon Sep 5 15:03:51 2011 +0000
==================================================
AbstractHttp11Processor.java
Pull out implementation specific processing that determines if keep-alive should be broken into a separate method.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1165309 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http11AprProcessor.java
index 50e169995b..dd2e9d449b 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Processor.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Processor.java
@@ -47,6 +47,7 @@ import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketWrapper;
 import org.apache.tomcat.util.res.StringManager;
 
 public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
@@ -84,6 +85,14 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
      */
     protected boolean openSocket = false;
 
+
+    /**
+     * Flag that indicates that send file processing is in progress and that the
+     * socket should not be returned to the poller (where a poller is used).
+     */
+    protected boolean sendfileInProgress = false;
+
+
     /**
      * HTTP/1.1 flag.
      */
@@ -1303,7 +1312,18 @@ public abstract class AbstractHttp11Processor<S> extends AbstractProcessor<S> {
         }
 
     }
-    
+
+
+    /**
+     * Checks to see of the keep-alive loop should be broken, performing any
+     * processing (e.g. send file handling) that may have an impact on whether
+     * or not the keep-alive loop should be broken.
+     * @return
+     */
+    protected abstract boolean breakKeepAliveLoop(
+    		SocketWrapper<S> socketWrapper);
+
+
     public final void recycle() {
         getInputBuffer().recycle();
         getOutputBuffer().recycle();

==================================================
Http11NioProcessor.java
index d567e91bf8..ed8e21fb42 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -182,6 +182,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor<Long> {
         keepAlive = true;
         comet = false;
         openSocket = false;
+        sendfileInProgress = false;
 
         int soTimeout = endpoint.getSoTimeout();
 
@@ -190,7 +191,6 @@ public class Http11AprProcessor extends AbstractHttp11Processor<Long> {
         }
 
         boolean keptAlive = false;
-        boolean sendfileInProgress = false;
 
         long socketRef = socketWrapper.getSocket().longValue();
 
@@ -319,27 +319,8 @@ public class Http11AprProcessor extends AbstractHttp11Processor<Long> {
 
             rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
 
-            // Do sendfile as needed: add socket to sendfile and end
-            if (sendfileData != null && !error) {
-                sendfileData.socket = socketRef;
-                sendfileData.keepAlive = keepAlive;
-                if (!((AprEndpoint)endpoint).getSendfile().add(sendfileData)) {
-                    // Didn't send all of the data to sendfile.
-                    if (sendfileData.socket == 0) {
-                        // The socket is no longer set. Something went wrong.
-                        // Close the connection. Too late to set status code.
-                        if (log.isDebugEnabled()) {
-                            log.debug(sm.getString(
-                                    "http11processor.sendfile.error"));
-                        }
-                        error = true;
-                    } else {
-                        // The sendfile Poller will add the socket to the main
-                        // Poller once sendfile processing is complete
-                        sendfileInProgress = true;
-                    }
-                    break;
-                }
+            if (breakKeepAliveLoop(socketWrapper)) {
+            	break;
             }
         }
 
@@ -360,6 +341,34 @@ public class Http11AprProcessor extends AbstractHttp11Processor<Long> {
     }
 
 
+    @Override
+    protected boolean breakKeepAliveLoop(SocketWrapper<Long> socketWrapper) {
+        // Do sendfile as needed: add socket to sendfile and end
+        if (sendfileData != null && !error) {
+            sendfileData.socket = socketWrapper.getSocket().longValue();
+            sendfileData.keepAlive = keepAlive;
+            if (!((AprEndpoint)endpoint).getSendfile().add(sendfileData)) {
+                // Didn't send all of the data to sendfile.
+                if (sendfileData.socket == 0) {
+                    // The socket is no longer set. Something went wrong.
+                    // Close the connection. Too late to set status code.
+                    if (log.isDebugEnabled()) {
+                        log.debug(sm.getString(
+                                "http11processor.sendfile.error"));
+                    }
+                    error = true;
+                } else {
+                    // The sendfile Poller will add the socket to the main
+                    // Poller once sendfile processing is complete
+                    sendfileInProgress = true;
+                }
+                return true;
+            }
+        }
+        return false;
+    }
+
+
     @Override
     protected boolean disableKeepAlive() {
         return false;

==================================================
Http11Processor.java
index 1c004f4826..503b1329c3 100644
--- a/java/org/apache/coyote/http11/Http11NioProcessor.java
+++ b/java/org/apache/coyote/http11/Http11NioProcessor.java
@@ -211,6 +211,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
         keepAlive = true;
         comet = false;
         openSocket = false;
+        sendfileInProgress = false;
         
         int soTimeout = endpoint.getSoTimeout();
 
@@ -380,16 +381,8 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
 
             rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
 
-            // Do sendfile as needed: add socket to sendfile and end
-            if (sendfileData != null && !error) {
-                ((KeyAttachment) socketWrapper).setSendfileData(sendfileData);
-                sendfileData.keepAlive = keepAlive;
-                SelectionKey key = socketWrapper.getSocket().getIOChannel().keyFor(
-                        socketWrapper.getSocket().getPoller().getSelector());
-                //do the first write on this thread, might as well
-                openSocket = socketWrapper.getSocket().getPoller().processSendfile(key,
-                        (KeyAttachment) socketWrapper, true, true);
-                break;
+            if (breakKeepAliveLoop(socketWrapper)) {
+            	break;
             }
         }
 
@@ -401,7 +394,24 @@ public class Http11NioProcessor extends AbstractHttp11Processor<NioChannel> {
         } else {
             return (openSocket) ? (readComplete?SocketState.OPEN:SocketState.LONG) : SocketState.CLOSED;
         }
+    }
+
 
+    @Override
+    protected boolean breakKeepAliveLoop(
+    		SocketWrapper<NioChannel> socketWrapper) {
+        // Do sendfile as needed: add socket to sendfile and end
+        if (sendfileData != null && !error) {
+            ((KeyAttachment) socketWrapper).setSendfileData(sendfileData);
+            sendfileData.keepAlive = keepAlive;
+            SelectionKey key = socketWrapper.getSocket().getIOChannel().keyFor(
+                    socketWrapper.getSocket().getPoller().getSelector());
+            //do the first write on this thread, might as well
+            openSocket = socketWrapper.getSocket().getPoller().processSendfile(key,
+                    (KeyAttachment) socketWrapper, true, true);
+            return true;
+        }
+    	return false;
     }
 
 

==================================================
