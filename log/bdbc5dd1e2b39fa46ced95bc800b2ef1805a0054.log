bdbc5dd1e2b39fa46ced95bc800b2ef1805a0054
==================================================
Generics for o.a.c.tribes.transport.nio
==================================================
Mark Emlyn
==================================================
Wed Dec 24 15:37:17 2008 +0000
==================================================
NioReceiver.java
Generics for o.a.c.tribes.transport.nio
Fix some other Eclispe warnings (unused code etc)

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@729322 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ParallelNioSender.java
index a0837c0108..7a447610f1 100644
--- a/java/org/apache/catalina/tribes/transport/nio/NioReceiver.java
+++ b/java/org/apache/catalina/tribes/transport/nio/NioReceiver.java
@@ -18,7 +18,6 @@
 package org.apache.catalina.tribes.transport.nio;
 
 import java.io.IOException;
-import java.net.InetSocketAddress;
 import java.net.ServerSocket;
 import java.nio.channels.DatagramChannel;
 import java.nio.channels.SelectableChannel;
@@ -63,7 +62,7 @@ public class NioReceiver extends ReceiverBase implements Runnable, ChannelReceiv
     private ServerSocketChannel serverChannel = null;
     private DatagramChannel datagramChannel = null;
 
-    protected LinkedList events = new LinkedList();
+    protected LinkedList<Runnable> events = new LinkedList<Runnable>();
 //    private Object interestOpsMutex = new Object();
 
     public NioReceiver() {
@@ -133,7 +132,7 @@ public class NioReceiver extends ReceiverBase implements Runnable, ChannelReceiv
         selector = Selector.open();
         // set the port the server channel will listen to
         //serverSocket.bind(new InetSocketAddress(getBind(), getTcpListenPort()));
-        bind(serverSocket,getTcpListenPort(),getAutoBind());
+        bind(serverSocket,getPort(),getAutoBind());
         // set non-blocking mode for the listening socket
         serverChannel.configureBlocking(false);
         // register the ServerSocketChannel with the Selector
@@ -165,7 +164,7 @@ public class NioReceiver extends ReceiverBase implements Runnable, ChannelReceiv
         if ( events.size() == 0 ) return;
         synchronized (events) {
             Runnable r = null;
-            while ( (events.size() > 0) && (r = (Runnable)events.removeFirst()) != null ) {
+            while ( (events.size() > 0) && (r = events.removeFirst()) != null ) {
                 try {
                     if ( log.isTraceEnabled() ) log.trace("Processing event in selector:"+r);
                     r.run();
@@ -198,10 +197,10 @@ public class NioReceiver extends ReceiverBase implements Runnable, ChannelReceiv
         if ( (now-lastCheck) < getSelectorTimeout() ) return;
         //timeout
         Selector tmpsel = selector;
-        Set keys =  (isListening()&&tmpsel!=null)?tmpsel.keys():null;
+        Set<SelectionKey> keys =  (isListening()&&tmpsel!=null)?tmpsel.keys():null;
         if ( keys == null ) return;
-        for (Iterator iter = keys.iterator(); iter.hasNext(); ) {
-            SelectionKey key = (SelectionKey) iter.next();
+        for (Iterator<SelectionKey> iter = keys.iterator(); iter.hasNext(); ) {
+            SelectionKey key = iter.next();
             try {
 //                if (key.interestOps() == SelectionKey.OP_READ) {
 //                    //only timeout sockets that we are waiting for a read from
@@ -217,7 +216,7 @@ public class NioReceiver extends ReceiverBase implements Runnable, ChannelReceiv
                     ObjectReader ka = (ObjectReader) key.attachment();
                     if ( ka != null ) {
                         long delta = now - ka.getLastAccess();
-                        if (delta > (long) getTimeout() && (!ka.isAccessed())) {
+                        if (delta > getTimeout() && (!ka.isAccessed())) {
                             if (log.isWarnEnabled())
                                 log.warn("Channel key is registered, but has had no interest ops for the last "+getTimeout()+" ms. (cancelled:"+ka.isCancelled()+"):"+key+" last access:"+new java.sql.Timestamp(ka.getLastAccess())+" Possible cause: all threads used, perform thread dump");
                             ka.setLastAccess(now);
@@ -264,7 +263,7 @@ public class NioReceiver extends ReceiverBase implements Runnable, ChannelReceiv
             try {
                 events();
                 socketTimeouts();
-                int n = selector.select(getTcpSelectorTimeout());
+                int n = selector.select(getSelectorTimeout());
                 if (n == 0) {
                     //there is a good chance that we got here
                     //because the TcpReplicationThread called
@@ -279,10 +278,10 @@ public class NioReceiver extends ReceiverBase implements Runnable, ChannelReceiv
                     continue; // nothing to do
                 }
                 // get an iterator over the set of selected keys
-                Iterator it = (selector!=null)?selector.selectedKeys().iterator():null;
+                Iterator<SelectionKey> it = (selector!=null)?selector.selectedKeys().iterator():null;
                 // look at each key in the selected set
                 while (selector!=null && it.hasNext()) {
-                    SelectionKey key = (SelectionKey) it.next();
+                    SelectionKey key = it.next();
                     // Is a new connection coming in?
                     if (key.isAcceptable()) {
                         ServerSocketChannel server = (ServerSocketChannel) key.channel();
@@ -364,10 +363,10 @@ public class NioReceiver extends ReceiverBase implements Runnable, ChannelReceiv
         this.selector = null;
         if (selector==null) return;
         try {
-            Iterator it = selector.keys().iterator();
+            Iterator<SelectionKey> it = selector.keys().iterator();
             // look at each key in the selected set
             while (it.hasNext()) {
-                SelectionKey key = (SelectionKey)it.next();
+                SelectionKey key = it.next();
                 key.channel().close();
                 key.attach(null);
                 key.cancel();

==================================================
PooledParallelSender.java
index 7743ef3abc..b781c6d5eb 100644
--- a/java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java
+++ b/java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java
@@ -23,6 +23,7 @@ import java.nio.channels.Selector;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
+import java.util.Map.Entry;
 
 import org.apache.catalina.tribes.ChannelException;
 import org.apache.catalina.tribes.ChannelMessage;
@@ -52,7 +53,8 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
     protected static org.apache.juli.logging.Log log = org.apache.juli.logging.LogFactory.getLog(ParallelNioSender.class);
     protected long selectTimeout = 5000; //default 5 seconds, same as send timeout
     protected Selector selector;
-    protected HashMap nioSenders = new HashMap();
+    protected HashMap<Member, NioSender> nioSenders =
+        new HashMap<Member, NioSender>();
 
     public ParallelNioSender() throws IOException {
         selector = Selector.open();
@@ -120,9 +122,9 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
             return 0;
         }
 
-        Iterator it = selector.selectedKeys().iterator();
+        Iterator<SelectionKey> it = selector.selectedKeys().iterator();
         while (it.hasNext()) {
-            SelectionKey sk = (SelectionKey) it.next();
+            SelectionKey sk = it.next();
             it.remove();
             int readyOps = sk.readyOps();
             sk.interestOps(sk.interestOps() & ~readyOps);
@@ -211,21 +213,19 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
         ChannelException cx = null;
         NioSender[] result = new NioSender[destination.length];
         for ( int i=0; i<destination.length; i++ ) {
-            NioSender sender = (NioSender)nioSenders.get(destination[i]);
+            NioSender sender = nioSenders.get(destination[i]);
             try {
 
                 if (sender == null) {
                     sender = new NioSender();
-                    sender.transferProperties(this, sender);
+                    AbstractSender.transferProperties(this, sender);
                     nioSenders.put(destination[i], sender);
                 }
-                if (sender != null) {
-                    sender.reset();
-                    sender.setDestination(destination[i]);
-                    sender.setSelector(selector);
-                    sender.setUdpBased(isUdpBased());
-                    result[i] = sender;
-                }
+                sender.reset();
+                sender.setDestination(destination[i]);
+                sender.setSelector(selector);
+                sender.setUdpBased(isUdpBased());
+                result[i] = sender;
             }catch ( UnknownHostException x ) {
                 if (cx == null) cx = new ChannelException("Unable to setup NioSender.", x);
                 cx.addFaultyMember(destination[i], x);
@@ -247,7 +247,7 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
         for (int i=0; i<members.length; i++ ) {
             Member mbr = (Member)members[i];
             try {
-                NioSender sender = (NioSender)nioSenders.get(mbr);
+                NioSender sender = nioSenders.get(mbr);
                 sender.disconnect();
             }catch ( Exception e ) {
                 if ( x == null ) x = new ChannelException(e);
@@ -264,7 +264,7 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
 
     public void remove(Member member) {
         //disconnect senders
-        NioSender sender = (NioSender)nioSenders.remove(member);
+        NioSender sender = nioSenders.remove(member);
         if ( sender != null ) sender.disconnect();
     }
 
@@ -282,9 +282,9 @@ public class ParallelNioSender extends AbstractSender implements MultiPointSende
 
     public boolean keepalive() {
         boolean result = false;
-        for ( Iterator i = nioSenders.entrySet().iterator(); i.hasNext();  ) {
-            Map.Entry entry = (Map.Entry)i.next();
-            NioSender sender = (NioSender)entry.getValue();
+        for ( Iterator<Entry<Member, NioSender>> i = nioSenders.entrySet().iterator(); i.hasNext();  ) {
+            Map.Entry<Member, NioSender> entry = i.next();
+            NioSender sender = entry.getValue();
             if ( sender.keepalive() ) {
                 //nioSenders.remove(entry.getKey());
                 i.remove();

==================================================
