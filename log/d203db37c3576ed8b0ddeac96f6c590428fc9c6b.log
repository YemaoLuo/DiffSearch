d203db37c3576ed8b0ddeac96f6c590428fc9c6b
==================================================
More tab police
==================================================
Mark Emlyn
==================================================
Sat Jul 24 11:03:00 2010 +0000
==================================================
RequestInfo.java
More tab police

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@978845 13f79535-47bb-0310-9956-ffa450edef68



==================================================
AjpMessage.java
index 23c06c112e..5df4a4182d 100644
--- a/java/org/apache/coyote/RequestInfo.java
+++ b/java/org/apache/coyote/RequestInfo.java
@@ -52,7 +52,7 @@ public class RequestInfo  {
             this.global=global;
             global.addRequestProcessor( this );
         } else {
-        	if (this.global != null) {
+            if (this.global != null) {
                 this.global.removeRequestProcessor( this ); 
                 this.global = null;
             }

==================================================
SavedRequestInputFilter.java
index abb1c37511..f62c705f2b 100644
--- a/java/org/apache/coyote/ajp/AjpMessage.java
+++ b/java/org/apache/coyote/ajp/AjpMessage.java
@@ -144,7 +144,7 @@ public class AjpMessage {
     public void appendByte(int val) {
         buf[pos++] = (byte) val;
     }
-	
+
     
     /**
      * Append an int (4 bytes) to the message.
@@ -350,7 +350,7 @@ public class AjpMessage {
             log.error(sm.getString("ajpmessage.read", "" + length));
             return 0;
         }
-	
+
         if ((length == 0xFFFF) || (length == -1)) {
             return 0;
         }

==================================================
NamingContextBindingsEnumeration.java
index d6b2eda048..afe7467abb 100644
--- a/java/org/apache/coyote/http11/filters/SavedRequestInputFilter.java
+++ b/java/org/apache/coyote/http11/filters/SavedRequestInputFilter.java
@@ -29,9 +29,9 @@ import org.apache.tomcat.util.buf.ByteChunk;
  */
 public class SavedRequestInputFilter implements InputFilter {
 
-	/**
+    /**
      * The original request body.
-	 */
+     */
     protected ByteChunk input = null;
 
     /**
@@ -53,7 +53,7 @@ public class SavedRequestInputFilter implements InputFilter {
         if (chunk.getLimit() > 0 && chunk.getLimit() < input.getLength()) {
             writeLength = chunk.getLimit();
         } else {
-        	writeLength = input.getLength();
+            writeLength = input.getLength();
         }
         
         if(input.getOffset()>= input.getEnd())

==================================================
NamingContextEnumeration.java
index f73fcf7a73..3a618f8987 100644
--- a/java/org/apache/naming/NamingContextBindingsEnumeration.java
+++ b/java/org/apache/naming/NamingContextBindingsEnumeration.java
@@ -42,7 +42,7 @@ public class NamingContextBindingsEnumeration
 
     public NamingContextBindingsEnumeration(Iterator<NamingEntry> entries,
             Context ctx) {
-    	iterator = entries;
+        iterator = entries;
         this.ctx = ctx;
     }
 

==================================================
MailSessionFactory.java
index 1bf2e631d7..b1d9ed1569 100644
--- a/java/org/apache/naming/NamingContextEnumeration.java
+++ b/java/org/apache/naming/NamingContextEnumeration.java
@@ -39,7 +39,7 @@ public class NamingContextEnumeration
 
 
     public NamingContextEnumeration(Iterator<NamingEntry> entries) {
-    	iterator = entries;
+        iterator = entries;
     }
 
 

==================================================
SendMailFactory.java
index d525955321..69289bc65b 100644
--- a/java/org/apache/naming/factory/MailSessionFactory.java
+++ b/java/org/apache/naming/factory/MailSessionFactory.java
@@ -89,11 +89,10 @@ public class MailSessionFactory implements ObjectFactory {
      * @exception Exception if an error occurs during object creation
      */
     public Object getObjectInstance(Object refObj, Name name, Context context,
-				    Hashtable<?,?> env) throws Exception 
-    {
+            Hashtable<?,?> env) throws Exception {
 
         // Return null if we cannot create an object of the requested type
-	final Reference ref = (Reference) refObj;
+        final Reference ref = (Reference) refObj;
         if (!ref.getClassName().equals(factoryType))
             return (null);
 
@@ -103,7 +102,7 @@ public class MailSessionFactory implements ObjectFactory {
         //
         // Bugzilla 31288, 33077: add support for authentication.
         return AccessController.doPrivileged(new PrivilegedAction<Session>() {
-		public Session run() {
+                public Session run() {
 
                     // Create the JavaMail properties we will use
                     Properties props = new Properties();
@@ -148,10 +147,7 @@ public class MailSessionFactory implements ObjectFactory {
                     Session session = Session.getInstance(props, auth);
                     return (session);
 
-		}
-	    } );
-
+                }
+        } );
     }
-
-
 }

==================================================
DirContextURLConnection.java
index 5dcb5e5796..3f57441f51 100644
--- a/java/org/apache/naming/factory/SendMailFactory.java
+++ b/java/org/apache/naming/factory/SendMailFactory.java
@@ -77,51 +77,50 @@ public class SendMailFactory implements ObjectFactory
 {
     // The class name for the javamail MimeMessageDataSource
     protected final String DataSourceClassName = 
-	"javax.mail.internet.MimePartDataSource";
+        "javax.mail.internet.MimePartDataSource";
 
     public Object getObjectInstance(Object RefObj, Name Nm, Context Ctx,
-				    Hashtable<?,?> Env) throws Exception 
-    {
-	final Reference Ref = (Reference)RefObj;
+            Hashtable<?,?> Env) throws Exception {
+        final Reference Ref = (Reference)RefObj;
 
-	// Creation of the DataSource is wrapped inside a doPrivileged
-	// so that javamail can read its default properties without
-	// throwing Security Exceptions
-	if (Ref.getClassName().equals(DataSourceClassName)) {
-	    return AccessController.doPrivileged(
-	            new PrivilegedAction<MimePartDataSource>()
-	    {
-		public MimePartDataSource run() {
-        	    // set up the smtp session that will send the message
-	            Properties props = new Properties();
-		    // enumeration of all refaddr
-		    Enumeration<RefAddr> list = Ref.getAll();
-		    // current refaddr to be set
-		    RefAddr refaddr;
-	            // set transport to smtp
-	            props.put("mail.transport.protocol", "smtp");
+        // Creation of the DataSource is wrapped inside a doPrivileged
+        // so that javamail can read its default properties without
+        // throwing Security Exceptions
+        if (Ref.getClassName().equals(DataSourceClassName)) {
+            return AccessController.doPrivileged(
+                    new PrivilegedAction<MimePartDataSource>()
+            {
+                public MimePartDataSource run() {
+                    // set up the smtp session that will send the message
+                    Properties props = new Properties();
+                    // enumeration of all refaddr
+                    Enumeration<RefAddr> list = Ref.getAll();
+                    // current refaddr to be set
+                    RefAddr refaddr;
+                    // set transport to smtp
+                    props.put("mail.transport.protocol", "smtp");
 
-		    while (list.hasMoreElements()) {
-			refaddr = list.nextElement();
+                    while (list.hasMoreElements()) {
+                        refaddr = list.nextElement();
 
-			// set property
-			props.put(refaddr.getType(), refaddr.getContent());
-		    }
-		    MimeMessage message = new MimeMessage(
-			Session.getInstance(props));
-		    try {
-			String from = (String)Ref.get("mail.from").getContent();
-		        message.setFrom(new InternetAddress(from));
-		        message.setSubject("");
-		    } catch (Exception e) {}
-		    MimePartDataSource mds = new MimePartDataSource(
-			(MimePart)message);
-		    return mds;
-		}
-	    } );
-	}
-	else { // We can't create an instance of the DataSource
-	    return null;
-	}
+                        // set property
+                        props.put(refaddr.getType(), refaddr.getContent());
+                    }
+                    MimeMessage message = new MimeMessage(
+                        Session.getInstance(props));
+                    try {
+                        String from = (String)Ref.get("mail.from").getContent();
+                        message.setFrom(new InternetAddress(from));
+                        message.setSubject("");
+                    } catch (Exception e) {}
+                    MimePartDataSource mds = new MimePartDataSource(
+                        (MimePart)message);
+                    return mds;
+                }
+            } );
+        }
+        else { // We can't create an instance of the DataSource
+            return null;
+        }
     }
 }

==================================================
FileDirContext.java
index 33d3774b1c..428ec0223d 100644
--- a/java/org/apache/naming/resources/DirContextURLConnection.java
+++ b/java/org/apache/naming/resources/DirContextURLConnection.java
@@ -67,7 +67,7 @@ public class DirContextURLConnection
                 ("Directory context can't be null");
         if (org.apache.naming.Constants.IS_SECURITY_ENABLED) {
             this.permission = new JndiPermission(url.toString());
-	}
+    }
         this.context = context;
     }
     

==================================================
RecyclableNamingEnumeration.java
index d5e09e4deb..b69490871a 100644
--- a/java/org/apache/naming/resources/FileDirContext.java
+++ b/java/org/apache/naming/resources/FileDirContext.java
@@ -794,9 +794,9 @@ public class FileDirContext extends BaseDirContext {
         File file = new File(base, name);
         if (file.exists() && file.canRead()) {
 
-        	if (allowLinking)
-        		return file;
-        	
+            if (allowLinking)
+                return file;
+            
             // Check that this file belongs to our root path
             String canPath = null;
             try {

==================================================
WARDirContext.java
index f22a5515fa..83a184c589 100644
--- a/java/org/apache/naming/resources/RecyclableNamingEnumeration.java
+++ b/java/org/apache/naming/resources/RecyclableNamingEnumeration.java
@@ -105,7 +105,7 @@ public class RecyclableNamingEnumeration<E>
      * Recycle.
      */
     void recycle() {
-    	enumeration = entries.elements();
+        enumeration = entries.elements();
     }
 
 

==================================================
InstanceManager.java
index 37791794d6..b4e801c514 100644
--- a/java/org/apache/naming/resources/WARDirContext.java
+++ b/java/org/apache/naming/resources/WARDirContext.java
@@ -121,26 +121,26 @@ public class WARDirContext extends BaseDirContext {
     @Override
     public void setDocBase(String docBase) {
 
-	// Validate the format of the proposed document root
-	if (docBase == null)
-	    throw new IllegalArgumentException
-		(sm.getString("resources.null"));
-	if (!(docBase.endsWith(".war")))
-	    throw new IllegalArgumentException
-		(sm.getString("warResources.notWar"));
-
-	// Calculate a File object referencing this document base directory
-	File base = new File(docBase);
-
-	// Validate that the document base is an existing directory
-	if (!base.exists() || !base.canRead() || base.isDirectory())
-	    throw new IllegalArgumentException
-		(sm.getString("warResources.invalidWar", docBase));
+        // Validate the format of the proposed document root
+        if (docBase == null)
+            throw new IllegalArgumentException
+                (sm.getString("resources.null"));
+        if (!(docBase.endsWith(".war")))
+            throw new IllegalArgumentException
+                (sm.getString("warResources.notWar"));
+
+        // Calculate a File object referencing this document base directory
+        File base = new File(docBase);
+
+        // Validate that the document base is an existing directory
+        if (!base.exists() || !base.canRead() || base.isDirectory())
+            throw new IllegalArgumentException
+                (sm.getString("warResources.invalidWar", docBase));
         try {
             this.base = new ZipFile(base);
         } catch (Exception e) {
-	    throw new IllegalArgumentException
-		(sm.getString("warResources.invalidWar", e.getMessage()));
+            throw new IllegalArgumentException
+                (sm.getString("warResources.invalidWar", e.getMessage()));
         }
         super.setDocBase(docBase);
 

==================================================
IntrospectionUtils.java
index 2afc21c838..fcb20bd56a 100644
--- a/java/org/apache/tomcat/InstanceManager.java
+++ b/java/org/apache/tomcat/InstanceManager.java
@@ -30,16 +30,16 @@ import javax.naming.NamingException;
 public interface InstanceManager {
 
     public Object newInstance(String className)
-    	throws IllegalAccessException, InvocationTargetException, NamingException, 
-    		InstantiationException, ClassNotFoundException;
+        throws IllegalAccessException, InvocationTargetException, NamingException, 
+            InstantiationException, ClassNotFoundException;
 
     public Object newInstance(String fqcn, ClassLoader classLoader) 
-    	throws IllegalAccessException, InvocationTargetException, NamingException, 
-    		InstantiationException, ClassNotFoundException;
+        throws IllegalAccessException, InvocationTargetException, NamingException, 
+            InstantiationException, ClassNotFoundException;
 
     public void newInstance(Object o) 
-		throws IllegalAccessException, InvocationTargetException, NamingException;
+        throws IllegalAccessException, InvocationTargetException, NamingException;
 
     public void destroyInstance(Object o)
-    	throws IllegalAccessException, InvocationTargetException;
+        throws IllegalAccessException, InvocationTargetException;
 }

==================================================
Constants.java
index 33bc176d38..83ac8e87ad 100644
--- a/java/org/apache/tomcat/util/IntrospectionUtils.java
+++ b/java/org/apache/tomcat/util/IntrospectionUtils.java
@@ -48,7 +48,7 @@ public final class IntrospectionUtils {
         Method executeM = null;
         Class<?> c = proxy.getClass();
         Class<?> params[] = new Class[0];
-        //	params[0]=args.getClass();
+        // params[0]=args.getClass();
         executeM = findMethod(c, method, params);
         if (executeM == null) {
             throw new RuntimeException("No execute in " + proxy.getClass());
@@ -164,7 +164,7 @@ public final class IntrospectionUtils {
         StringTokenizer st = new StringTokenizer(cpath, pathSep);
         while (st.hasMoreTokens()) {
             String path = st.nextToken();
-            //	    log( "path " + path );
+            // log( "path " + path );
             if (path.endsWith(jarName)) {
                 home = path.substring(0, path.length() - jarName.length());
                 try {

==================================================
AnnotationDefault.java
index 2c8ad49ba7..c4fca620bb 100644
--- a/java/org/apache/tomcat/util/bcel/Constants.java
+++ b/java/org/apache/tomcat/util/bcel/Constants.java
@@ -494,26 +494,26 @@ public interface Constants {
 
   /** Attributes and their corresponding names.
    */
-  public static final byte ATTR_UNKNOWN                       			= -1;
-  public static final byte ATTR_SOURCE_FILE                   			= 0;
-  public static final byte ATTR_CONSTANT_VALUE                			= 1;
-  public static final byte ATTR_CODE                          			= 2;
-  public static final byte ATTR_EXCEPTIONS                    			= 3;
-  public static final byte ATTR_LINE_NUMBER_TABLE             			= 4;
-  public static final byte ATTR_LOCAL_VARIABLE_TABLE          			= 5;
-  public static final byte ATTR_INNER_CLASSES                 			= 6;
-  public static final byte ATTR_SYNTHETIC                     			= 7;
-  public static final byte ATTR_DEPRECATED                    			= 8;
-  public static final byte ATTR_PMG                           			= 9;
-  public static final byte ATTR_SIGNATURE                     			= 10;
-  public static final byte ATTR_STACK_MAP                     			= 11;
-  public static final byte ATTR_RUNTIME_VISIBLE_ANNOTATIONS    			= 12;
-  public static final byte ATTR_RUNTIMEIN_VISIBLE_ANNOTATIONS  			= 13;
-  public static final byte ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS 	= 14;
+  public static final byte ATTR_UNKNOWN                                 = -1;
+  public static final byte ATTR_SOURCE_FILE                             = 0;
+  public static final byte ATTR_CONSTANT_VALUE                          = 1;
+  public static final byte ATTR_CODE                                    = 2;
+  public static final byte ATTR_EXCEPTIONS                              = 3;
+  public static final byte ATTR_LINE_NUMBER_TABLE                       = 4;
+  public static final byte ATTR_LOCAL_VARIABLE_TABLE                    = 5;
+  public static final byte ATTR_INNER_CLASSES                           = 6;
+  public static final byte ATTR_SYNTHETIC                               = 7;
+  public static final byte ATTR_DEPRECATED                              = 8;
+  public static final byte ATTR_PMG                                     = 9;
+  public static final byte ATTR_SIGNATURE                               = 10;
+  public static final byte ATTR_STACK_MAP                               = 11;
+  public static final byte ATTR_RUNTIME_VISIBLE_ANNOTATIONS             = 12;
+  public static final byte ATTR_RUNTIMEIN_VISIBLE_ANNOTATIONS           = 13;
+  public static final byte ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS   = 14;
   public static final byte ATTR_RUNTIMEIN_VISIBLE_PARAMETER_ANNOTATIONS = 15;
   public static final byte ATTR_ANNOTATION_DEFAULT                      = 16;
   public static final byte ATTR_LOCAL_VARIABLE_TYPE_TABLE               = 17;
-  public static final byte ATTR_ENCLOSING_METHOD                      	= 18;
+  public static final byte ATTR_ENCLOSING_METHOD                        = 18;
   public static final byte ATTR_STACK_MAP_TABLE                         = 19;
 
   public static final short KNOWN_ATTRIBUTES = 20;

==================================================
AnnotationElementValue.java
index eef8e16d98..f1099a9e29 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/AnnotationDefault.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/AnnotationDefault.java
@@ -31,63 +31,63 @@ import org.apache.tomcat.util.bcel.Constants;
  */
 public class AnnotationDefault extends Attribute
 {
-	ElementValue default_value;
+    ElementValue default_value;
 
-	/**
-	 * @param annotation_type
-	 *            the subclass type of the annotation
-	 * @param name_index
-	 *            Index pointing to the name <em>Code</em>
-	 * @param length
-	 *            Content length in bytes
-	 * @param file
-	 *            Input stream
-	 * @param constant_pool
-	 *            Array of constants
-	 */
-	public AnnotationDefault(int name_index, int length,
-			DataInputStream file, ConstantPool constant_pool)
-			throws IOException
-	{
-		this(name_index, length, (ElementValue) null,
-				constant_pool);
-		default_value = ElementValue.readElementValue(file, constant_pool);
-	}
+    /**
+     * @param annotation_type
+     *            the subclass type of the annotation
+     * @param name_index
+     *            Index pointing to the name <em>Code</em>
+     * @param length
+     *            Content length in bytes
+     * @param file
+     *            Input stream
+     * @param constant_pool
+     *            Array of constants
+     */
+    public AnnotationDefault(int name_index, int length,
+            DataInputStream file, ConstantPool constant_pool)
+            throws IOException
+    {
+        this(name_index, length, (ElementValue) null,
+                constant_pool);
+        default_value = ElementValue.readElementValue(file, constant_pool);
+    }
 
-	/**
-	 * @param annotation_type
-	 *            the subclass type of the annotation
-	 * @param name_index
-	 *            Index pointing to the name <em>Code</em>
-	 * @param length
-	 *            Content length in bytes
-	 * @param defaultValue
-	 *            the annotation's default value
-	 * @param constant_pool
-	 *            Array of constants
-	 */
-	public AnnotationDefault(int name_index, int length,
-			ElementValue defaultValue, ConstantPool constant_pool)
-	{
-		super(Constants.ATTR_ANNOTATION_DEFAULT, name_index, length, constant_pool);
-		setDefaultValue(defaultValue);
-	}
+    /**
+     * @param annotation_type
+     *            the subclass type of the annotation
+     * @param name_index
+     *            Index pointing to the name <em>Code</em>
+     * @param length
+     *            Content length in bytes
+     * @param defaultValue
+     *            the annotation's default value
+     * @param constant_pool
+     *            Array of constants
+     */
+    public AnnotationDefault(int name_index, int length,
+            ElementValue defaultValue, ConstantPool constant_pool)
+    {
+        super(Constants.ATTR_ANNOTATION_DEFAULT, name_index, length, constant_pool);
+        setDefaultValue(defaultValue);
+    }
 
-	/**
-	 * @param defaultValue
-	 *            the default value of this methodinfo's annotation
-	 */
-	public final void setDefaultValue(ElementValue defaultValue)
-	{
-		default_value = defaultValue;
-	}
+    /**
+     * @param defaultValue
+     *            the default value of this methodinfo's annotation
+     */
+    public final void setDefaultValue(ElementValue defaultValue)
+    {
+        default_value = defaultValue;
+    }
 
-	
+    
 
-	public Attribute copy(ConstantPool _constant_pool)
-	{
-		throw new RuntimeException("Not implemented yet!");
-	}
+    public Attribute copy(ConstantPool _constant_pool)
+    {
+        throw new RuntimeException("Not implemented yet!");
+    }
 
     public final void dump(DataOutputStream dos) throws IOException
     {

==================================================
AnnotationEntry.java
index 007e24f928..d0ff611793 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/AnnotationElementValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/AnnotationElementValue.java
@@ -22,39 +22,39 @@ import java.io.IOException;
 
 public class AnnotationElementValue extends ElementValue
 {
-	// For annotation element values, this is the annotation
-	private AnnotationEntry annotationEntry;
+    // For annotation element values, this is the annotation
+    private AnnotationEntry annotationEntry;
 
-	public AnnotationElementValue(int type, AnnotationEntry annotationEntry,
-			ConstantPool cpool)
-	{
-		super(type, cpool);
-		if (type != ANNOTATION)
-			throw new RuntimeException(
-					"Only element values of type annotation can be built with this ctor - type specified: " + type);
-		this.annotationEntry = annotationEntry;
-	}
+    public AnnotationElementValue(int type, AnnotationEntry annotationEntry,
+            ConstantPool cpool)
+    {
+        super(type, cpool);
+        if (type != ANNOTATION)
+            throw new RuntimeException(
+                    "Only element values of type annotation can be built with this ctor - type specified: " + type);
+        this.annotationEntry = annotationEntry;
+    }
 
-	public void dump(DataOutputStream dos) throws IOException
-	{
-		dos.writeByte(type); // u1 type of value (ANNOTATION == '@')
-		annotationEntry.dump(dos);
-	}
+    public void dump(DataOutputStream dos) throws IOException
+    {
+        dos.writeByte(type); // u1 type of value (ANNOTATION == '@')
+        annotationEntry.dump(dos);
+    }
 
-	public String stringifyValue()
-	{
-		StringBuffer sb = new StringBuffer();
-		sb.append(annotationEntry.toString());
-		return sb.toString();
-	}
+    public String stringifyValue()
+    {
+        StringBuffer sb = new StringBuffer();
+        sb.append(annotationEntry.toString());
+        return sb.toString();
+    }
 
-	public String toString()
-	{
-		return stringifyValue();
-	}
+    public String toString()
+    {
+        return stringifyValue();
+    }
 
-	public AnnotationEntry getAnnotationEntry()
-	{
-		return annotationEntry;
-	}
+    public AnnotationEntry getAnnotationEntry()
+    {
+        return annotationEntry;
+    }
 }

==================================================
Annotations.java
index ed02e8a84c..ad8137ba4c 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java
@@ -55,19 +55,15 @@ public class AnnotationEntry implements Constants, Serializable {
     
     public static AnnotationEntry read(DataInputStream file, ConstantPool constant_pool, boolean isRuntimeVisible) throws IOException 
     {
-    	AnnotationEntry annotationEntry = new AnnotationEntry(file.readUnsignedShort(), constant_pool, isRuntimeVisible);
-    	annotationEntry.num_element_value_pairs = (file.readUnsignedShort());
-    	annotationEntry.element_value_pairs = new ArrayList();
+        AnnotationEntry annotationEntry = new AnnotationEntry(file.readUnsignedShort(), constant_pool, isRuntimeVisible);
+        annotationEntry.num_element_value_pairs = (file.readUnsignedShort());
+        annotationEntry.element_value_pairs = new ArrayList();
         for (int i = 0; i < annotationEntry.num_element_value_pairs; i++) {
-        	annotationEntry.element_value_pairs.add(new ElementValuePair(file.readUnsignedShort(), ElementValue.readElementValue(file, constant_pool), constant_pool));
+            annotationEntry.element_value_pairs.add(new ElementValuePair(file.readUnsignedShort(), ElementValue.readElementValue(file, constant_pool), constant_pool));
         }
         return annotationEntry;
     }
 
-
-    
-
-
     /**
      * @return the annotation type name
      */
@@ -76,36 +72,24 @@ public class AnnotationEntry implements Constants, Serializable {
         c = (ConstantUtf8) constant_pool.getConstant(type_index, CONSTANT_Utf8);
         return c.getBytes();
     }
-    
-    
-
-
-    
-
 
     /**
      * @return the element value pairs in this annotation entry
      */
     public ElementValuePair[] getElementValuePairs() {
-    	// TOFO return List
+        // TOFO return List
         return (ElementValuePair[]) element_value_pairs.toArray(new ElementValuePair[element_value_pairs.size()]);
     }
 
 
-	public void dump(DataOutputStream dos) throws IOException
-	{
-		dos.writeShort(type_index);	// u2 index of type name in cpool
-		dos.writeShort(element_value_pairs.size()); // u2 element_value pair count
-		for (int i = 0 ; i<element_value_pairs.size();i++) {
-			ElementValuePair envp = (ElementValuePair) element_value_pairs.get(i);
-			envp.dump(dos);
-		}
-	}
-
-
-	
-
-	
+    public void dump(DataOutputStream dos) throws IOException
+    {
+        dos.writeShort(type_index);    // u2 index of type name in cpool
+        dos.writeShort(element_value_pairs.size()); // u2 element_value pair count
+        for (int i = 0 ; i<element_value_pairs.size();i++) {
+            ElementValuePair envp = (ElementValuePair) element_value_pairs.get(i);
+            envp.dump(dos);
+        }
+    }
 
-	
 }

==================================================
ArrayElementValue.java
index 24c928f492..6cba6edbfc 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Annotations.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Annotations.java
@@ -98,9 +98,9 @@ public abstract class Annotations extends Attribute {
     
     
     protected void writeAnnotations(DataOutputStream dos) throws IOException
-	{
-		dos.writeShort(annotation_table_length);
-		for (int i = 0; i < annotation_table_length; i++)
-			annotation_table[i].dump(dos);
-	}
+    {
+        dos.writeShort(annotation_table_length);
+        for (int i = 0; i < annotation_table_length; i++)
+            annotation_table[i].dump(dos);
+    }
 }

==================================================
Attribute.java
index 1b6015d8b5..8e9d31b3a1 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ArrayElementValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ArrayElementValue.java
@@ -22,60 +22,60 @@ import java.io.IOException;
 
 public class ArrayElementValue extends ElementValue
 {
-	// For array types, this is the array
-	private ElementValue[] evalues;
+    // For array types, this is the array
+    private ElementValue[] evalues;
 
-	public String toString()
-	{
-		StringBuffer sb = new StringBuffer();
-		sb.append("{");
-		for (int i = 0; i < evalues.length; i++)
-		{
-			sb.append(evalues[i].toString());
-			if ((i + 1) < evalues.length)
-				sb.append(",");
-		}
-		sb.append("}");
-		return sb.toString();
-	}
+    public String toString()
+    {
+        StringBuffer sb = new StringBuffer();
+        sb.append("{");
+        for (int i = 0; i < evalues.length; i++)
+        {
+            sb.append(evalues[i].toString());
+            if ((i + 1) < evalues.length)
+                sb.append(",");
+        }
+        sb.append("}");
+        return sb.toString();
+    }
 
-	public ArrayElementValue(int type, ElementValue[] datums, ConstantPool cpool)
-	{
-		super(type, cpool);
-		if (type != ARRAY)
-			throw new RuntimeException(
-					"Only element values of type array can be built with this ctor - type specified: " + type);
-		this.evalues = datums;
-	}
+    public ArrayElementValue(int type, ElementValue[] datums, ConstantPool cpool)
+    {
+        super(type, cpool);
+        if (type != ARRAY)
+            throw new RuntimeException(
+                    "Only element values of type array can be built with this ctor - type specified: " + type);
+        this.evalues = datums;
+    }
 
-	public void dump(DataOutputStream dos) throws IOException
-	{
-		dos.writeByte(type); // u1 type of value (ARRAY == '[')
-		dos.writeShort(evalues.length);
-		for (int i = 0; i < evalues.length; i++)
-		{
-			evalues[i].dump(dos);
-		}
-	}
+    public void dump(DataOutputStream dos) throws IOException
+    {
+        dos.writeByte(type); // u1 type of value (ARRAY == '[')
+        dos.writeShort(evalues.length);
+        for (int i = 0; i < evalues.length; i++)
+        {
+            evalues[i].dump(dos);
+        }
+    }
 
-	public String stringifyValue()
-	{
-		StringBuffer sb = new StringBuffer();
-		sb.append("[");
-		for (int i = 0; i < evalues.length; i++)
-		{
-			sb.append(evalues[i].stringifyValue());
-			if ((i + 1) < evalues.length)
-				sb.append(",");
-		}
-		sb.append("]");
-		return sb.toString();
-	}
+    public String stringifyValue()
+    {
+        StringBuffer sb = new StringBuffer();
+        sb.append("[");
+        for (int i = 0; i < evalues.length; i++)
+        {
+            sb.append(evalues[i].stringifyValue());
+            if ((i + 1) < evalues.length)
+                sb.append(",");
+        }
+        sb.append("]");
+        return sb.toString();
+    }
 
-	public ElementValue[] getElementValuesArray()
-	{
-		return evalues;
-	}
+    public ElementValue[] getElementValuesArray()
+    {
+        return evalues;
+    }
 
-	
+    
 }

==================================================
ClassElementValue.java
index 57e3f4e5d0..6677bb56ff 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/Attribute.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/Attribute.java
@@ -50,202 +50,202 @@ import org.apache.tomcat.util.bcel.classfile.ConstantUtf8;
  */
 public abstract class Attribute implements Cloneable, Serializable
 {
-	protected int name_index; // Points to attribute name in constant pool
-
-	protected int length; // Content length of attribute field
-
-	protected byte tag; // Tag to distiguish subclasses
-
-	protected ConstantPool constant_pool;
-
-	protected Attribute(byte tag, int name_index, int length,
-			ConstantPool constant_pool)
-	{
-		this.tag = tag;
-		this.name_index = name_index;
-		this.length = length;
-		this.constant_pool = constant_pool;
-	}
-
-	/**
-	 * Dump attribute to file stream in binary format.
-	 * 
-	 * @param file
-	 *            Output file stream
-	 * @throws IOException
-	 */
-	public void dump(DataOutputStream file) throws IOException
-	{
-		file.writeShort(name_index);
-		file.writeInt(length);
-	}
-
-	private static Map readers = new HashMap();
-
-	
-
-	
-
-	/*
-	 * Class method reads one attribute from the input data stream. This method
-	 * must not be accessible from the outside. It is called by the Field and
-	 * Method constructor methods.
-	 * 
-	 * @see Field
-	 * @see Method @param file Input stream @param constant_pool Array of
-	 *      constants @return Attribute @throws IOException @throws
-	 *      ClassFormatException
-	 */
-	public static final Attribute readAttribute(DataInputStream file,
-			ConstantPool constant_pool) throws IOException,
-			ClassFormatException
-	{
-		ConstantUtf8 c;
-		String name;
-		int name_index;
-		int length;
-		byte tag = Constants.ATTR_UNKNOWN; // Unknown attribute
-		// Get class name from constant pool via `name_index' indirection
-		name_index = file.readUnsignedShort();
-		c = (ConstantUtf8) constant_pool.getConstant(name_index,
-				Constants.CONSTANT_Utf8);
-		name = c.getBytes();
-		// Length of data in bytes
-		length = file.readInt();
-		// Compare strings to find known attribute
-		// System.out.println(name);
-		for (byte i = 0; i < Constants.KNOWN_ATTRIBUTES; i++)
-		{
-			if (name.equals(Constants.ATTRIBUTE_NAMES[i]))
-			{
-				tag = i; // found!
-				break;
-			}
-		}
-		// Call proper constructor, depending on `tag'
-		switch (tag)
-		{
-		case Constants.ATTR_UNKNOWN:
-			AttributeReader r = (AttributeReader) readers.get(name);
-			if (r != null)
-			{
-				return r.createAttribute(name_index, length, file,
-						constant_pool);
-			}
-			return new Unknown(name_index, length, file, constant_pool);
-		case Constants.ATTR_CONSTANT_VALUE:
-			return new ConstantValue(name_index, length, file, constant_pool);
-		case Constants.ATTR_SOURCE_FILE:
-			return new SourceFile(name_index, length, file, constant_pool);
-		case Constants.ATTR_CODE:
-			return new Code(name_index, length, file, constant_pool);
-		case Constants.ATTR_EXCEPTIONS:
-			return new ExceptionTable(name_index, length, file, constant_pool);
-		case Constants.ATTR_LINE_NUMBER_TABLE:
-			return new LineNumberTable(name_index, length, file, constant_pool);
-		case Constants.ATTR_LOCAL_VARIABLE_TABLE:
-			return new LocalVariableTable(name_index, length, file,
-					constant_pool);
-		case Constants.ATTR_INNER_CLASSES:
-			return new InnerClasses(name_index, length, file, constant_pool);
-		case Constants.ATTR_SYNTHETIC:
-			return new Synthetic(name_index, length, file, constant_pool);
-		case Constants.ATTR_DEPRECATED:
-			return new Deprecated(name_index, length, file, constant_pool);
-		case Constants.ATTR_PMG:
-			return new PMGClass(name_index, length, file, constant_pool);
-		case Constants.ATTR_SIGNATURE:
-			return new Signature(name_index, length, file, constant_pool);
-		case Constants.ATTR_STACK_MAP:
-			return new StackMap(name_index, length, file, constant_pool);
-		case Constants.ATTR_RUNTIME_VISIBLE_ANNOTATIONS:
-			return new RuntimeVisibleAnnotations(name_index, length, file,
-					constant_pool);
-		case Constants.ATTR_RUNTIMEIN_VISIBLE_ANNOTATIONS:
-			return new RuntimeInvisibleAnnotations(name_index, length, file,
-					constant_pool);
-		case Constants.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS:
-			return new RuntimeVisibleParameterAnnotations(name_index, length,
-					file, constant_pool);
-		case Constants.ATTR_RUNTIMEIN_VISIBLE_PARAMETER_ANNOTATIONS:
-			return new RuntimeInvisibleParameterAnnotations(name_index, length,
-					file, constant_pool);
-		case Constants.ATTR_ANNOTATION_DEFAULT:
-			return new AnnotationDefault(name_index, length, file,
-					constant_pool);
-		case Constants.ATTR_LOCAL_VARIABLE_TYPE_TABLE:
-			return new LocalVariableTypeTable(name_index, length, file,
-					constant_pool);
-		case Constants.ATTR_ENCLOSING_METHOD:
-			return new EnclosingMethod(name_index, length, file, constant_pool);
-		case Constants.ATTR_STACK_MAP_TABLE:
-			return new StackMapTable(name_index, length, file, constant_pool);
-		default: // Never reached
-			throw new IllegalStateException("Unrecognized attribute type tag parsed: " + tag);
-		}
-	}
-
-	/**
-	 * @return Name of attribute
-	 */
-	public String getName()
-	{
-		ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(name_index,
-				Constants.CONSTANT_Utf8);
-		return c.getBytes();
-	}
-
-	
-
-	
-
-	
-
-	
-
-	/**
-	 * @return Tag of attribute, i.e., its type. Value may not be altered, thus
-	 *         there is no setTag() method.
-	 */
-	public final byte getTag()
-	{
-		return tag;
-	}
-
-	
-
-	
-
-	/**
-	 * Use copy() if you want to have a deep copy(), i.e., with all references
-	 * copied correctly.
-	 * 
-	 * @return shallow copy of this attribute
-	 */
-	public Object clone()
-	{
-		Object o = null;
-		try
-		{
-			o = super.clone();
-		}
-		catch (CloneNotSupportedException e)
-		{
-			e.printStackTrace(); // Never occurs
-		}
-		return o;
-	}
-
-	/**
-	 * @return deep copy of this attribute
-	 */
-	public abstract Attribute copy(ConstantPool _constant_pool);
-
-	/**
-	 * @return attribute name.
-	 */
-	public String toString()
-	{
-		return Constants.ATTRIBUTE_NAMES[tag];
-	}
+    protected int name_index; // Points to attribute name in constant pool
+
+    protected int length; // Content length of attribute field
+
+    protected byte tag; // Tag to distiguish subclasses
+
+    protected ConstantPool constant_pool;
+
+    protected Attribute(byte tag, int name_index, int length,
+            ConstantPool constant_pool)
+    {
+        this.tag = tag;
+        this.name_index = name_index;
+        this.length = length;
+        this.constant_pool = constant_pool;
+    }
+
+    /**
+     * Dump attribute to file stream in binary format.
+     * 
+     * @param file
+     *            Output file stream
+     * @throws IOException
+     */
+    public void dump(DataOutputStream file) throws IOException
+    {
+        file.writeShort(name_index);
+        file.writeInt(length);
+    }
+
+    private static Map readers = new HashMap();
+
+    
+
+    
+
+    /*
+     * Class method reads one attribute from the input data stream. This method
+     * must not be accessible from the outside. It is called by the Field and
+     * Method constructor methods.
+     * 
+     * @see Field
+     * @see Method @param file Input stream @param constant_pool Array of
+     *      constants @return Attribute @throws IOException @throws
+     *      ClassFormatException
+     */
+    public static final Attribute readAttribute(DataInputStream file,
+            ConstantPool constant_pool) throws IOException,
+            ClassFormatException
+    {
+        ConstantUtf8 c;
+        String name;
+        int name_index;
+        int length;
+        byte tag = Constants.ATTR_UNKNOWN; // Unknown attribute
+        // Get class name from constant pool via `name_index' indirection
+        name_index = file.readUnsignedShort();
+        c = (ConstantUtf8) constant_pool.getConstant(name_index,
+                Constants.CONSTANT_Utf8);
+        name = c.getBytes();
+        // Length of data in bytes
+        length = file.readInt();
+        // Compare strings to find known attribute
+        // System.out.println(name);
+        for (byte i = 0; i < Constants.KNOWN_ATTRIBUTES; i++)
+        {
+            if (name.equals(Constants.ATTRIBUTE_NAMES[i]))
+            {
+                tag = i; // found!
+                break;
+            }
+        }
+        // Call proper constructor, depending on `tag'
+        switch (tag)
+        {
+        case Constants.ATTR_UNKNOWN:
+            AttributeReader r = (AttributeReader) readers.get(name);
+            if (r != null)
+            {
+                return r.createAttribute(name_index, length, file,
+                        constant_pool);
+            }
+            return new Unknown(name_index, length, file, constant_pool);
+        case Constants.ATTR_CONSTANT_VALUE:
+            return new ConstantValue(name_index, length, file, constant_pool);
+        case Constants.ATTR_SOURCE_FILE:
+            return new SourceFile(name_index, length, file, constant_pool);
+        case Constants.ATTR_CODE:
+            return new Code(name_index, length, file, constant_pool);
+        case Constants.ATTR_EXCEPTIONS:
+            return new ExceptionTable(name_index, length, file, constant_pool);
+        case Constants.ATTR_LINE_NUMBER_TABLE:
+            return new LineNumberTable(name_index, length, file, constant_pool);
+        case Constants.ATTR_LOCAL_VARIABLE_TABLE:
+            return new LocalVariableTable(name_index, length, file,
+                    constant_pool);
+        case Constants.ATTR_INNER_CLASSES:
+            return new InnerClasses(name_index, length, file, constant_pool);
+        case Constants.ATTR_SYNTHETIC:
+            return new Synthetic(name_index, length, file, constant_pool);
+        case Constants.ATTR_DEPRECATED:
+            return new Deprecated(name_index, length, file, constant_pool);
+        case Constants.ATTR_PMG:
+            return new PMGClass(name_index, length, file, constant_pool);
+        case Constants.ATTR_SIGNATURE:
+            return new Signature(name_index, length, file, constant_pool);
+        case Constants.ATTR_STACK_MAP:
+            return new StackMap(name_index, length, file, constant_pool);
+        case Constants.ATTR_RUNTIME_VISIBLE_ANNOTATIONS:
+            return new RuntimeVisibleAnnotations(name_index, length, file,
+                    constant_pool);
+        case Constants.ATTR_RUNTIMEIN_VISIBLE_ANNOTATIONS:
+            return new RuntimeInvisibleAnnotations(name_index, length, file,
+                    constant_pool);
+        case Constants.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS:
+            return new RuntimeVisibleParameterAnnotations(name_index, length,
+                    file, constant_pool);
+        case Constants.ATTR_RUNTIMEIN_VISIBLE_PARAMETER_ANNOTATIONS:
+            return new RuntimeInvisibleParameterAnnotations(name_index, length,
+                    file, constant_pool);
+        case Constants.ATTR_ANNOTATION_DEFAULT:
+            return new AnnotationDefault(name_index, length, file,
+                    constant_pool);
+        case Constants.ATTR_LOCAL_VARIABLE_TYPE_TABLE:
+            return new LocalVariableTypeTable(name_index, length, file,
+                    constant_pool);
+        case Constants.ATTR_ENCLOSING_METHOD:
+            return new EnclosingMethod(name_index, length, file, constant_pool);
+        case Constants.ATTR_STACK_MAP_TABLE:
+            return new StackMapTable(name_index, length, file, constant_pool);
+        default: // Never reached
+            throw new IllegalStateException("Unrecognized attribute type tag parsed: " + tag);
+        }
+    }
+
+    /**
+     * @return Name of attribute
+     */
+    public String getName()
+    {
+        ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(name_index,
+                Constants.CONSTANT_Utf8);
+        return c.getBytes();
+    }
+
+    
+
+    
+
+    
+
+    
+
+    /**
+     * @return Tag of attribute, i.e., its type. Value may not be altered, thus
+     *         there is no setTag() method.
+     */
+    public final byte getTag()
+    {
+        return tag;
+    }
+
+    
+
+    
+
+    /**
+     * Use copy() if you want to have a deep copy(), i.e., with all references
+     * copied correctly.
+     * 
+     * @return shallow copy of this attribute
+     */
+    public Object clone()
+    {
+        Object o = null;
+        try
+        {
+            o = super.clone();
+        }
+        catch (CloneNotSupportedException e)
+        {
+            e.printStackTrace(); // Never occurs
+        }
+        return o;
+    }
+
+    /**
+     * @return deep copy of this attribute
+     */
+    public abstract Attribute copy(ConstantPool _constant_pool);
+
+    /**
+     * @return attribute name.
+     */
+    public String toString()
+    {
+        return Constants.ATTRIBUTE_NAMES[tag];
+    }
 }

==================================================
ClassFormatException.java
index 8d54720ebf..1ede032d15 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ClassElementValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ClassElementValue.java
@@ -23,31 +23,31 @@ import org.apache.tomcat.util.bcel.Constants;
 
 public class ClassElementValue extends ElementValue
 {
-	// For primitive types and string type, this points to the value entry in
-	// the cpool
-	// For 'class' this points to the class entry in the cpool
-	private int idx;
+    // For primitive types and string type, this points to the value entry in
+    // the cpool
+    // For 'class' this points to the class entry in the cpool
+    private int idx;
 
-	public ClassElementValue(int type, int idx, ConstantPool cpool)
-	{
-		super(type, cpool);
-		this.idx = idx;
-	}
+    public ClassElementValue(int type, int idx, ConstantPool cpool)
+    {
+        super(type, cpool);
+        this.idx = idx;
+    }
 
-	
+    
 
-	
+    
 
-	public String stringifyValue()
-	{
-		ConstantUtf8 cu8 = (ConstantUtf8) cpool.getConstant(idx,
-				Constants.CONSTANT_Utf8);
-		return cu8.getBytes();
-	}
+    public String stringifyValue()
+    {
+        ConstantUtf8 cu8 = (ConstantUtf8) cpool.getConstant(idx,
+                Constants.CONSTANT_Utf8);
+        return cu8.getBytes();
+    }
 
-	public void dump(DataOutputStream dos) throws IOException
-	{
-		dos.writeByte(type); // u1 kind of value
-		dos.writeShort(idx);
-	}
+    public void dump(DataOutputStream dos) throws IOException
+    {
+        dos.writeByte(type); // u1 kind of value
+        dos.writeShort(idx);
+    }
 }

==================================================
ClassParser.java
index 89f334087f..6b4aea7a48 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ClassFormatException.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ClassFormatException.java
@@ -37,6 +37,6 @@ public class ClassFormatException extends RuntimeException {
     }
     
     public ClassFormatException(String s, Throwable initCause) {
-    	super(s, initCause);
+        super(s, initCause);
     }
 }

==================================================
ElementValue.java
index 02ee9e2df6..a1e0ddc9be 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ClassParser.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ClassParser.java
@@ -139,23 +139,23 @@ public final class ClassParser {
             //        byte[] buf = new byte[bytes];
             //        file.read(buf);
             //        if(!(is_zip && (buf.length == 1))) {
-            //  	System.err.println("WARNING: Trailing garbage at end of " + file_name);
-            //  	System.err.println(bytes + " extra bytes: " + Utility.toHexString(buf));
+            //          System.err.println("WARNING: Trailing garbage at end of " + file_name);
+            //          System.err.println(bytes + " extra bytes: " + Utility.toHexString(buf));
             //        }
             //      }
         } finally {
             // Read everything of interest, so close the file
             if (fileOwned) {
-            	try {
-	                if (file != null) {
-	                    file.close();
-	                }
-	                if (zip != null) {
-	                    zip.close();
-	                }
-            	} catch (IOException ioe) {
-            		//ignore close exceptions
-            	}
+                try {
+                    if (file != null) {
+                        file.close();
+                    }
+                    if (zip != null) {
+                        zip.close();
+                    }
+                } catch (IOException ioe) {
+                    //ignore close exceptions
+                }
             }
         }
         // Return the information we have gathered in a new object

==================================================
ElementValuePair.java
index 030c5b79d2..272003634c 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ElementValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ElementValue.java
@@ -28,108 +28,108 @@ import java.io.IOException;
  */
 public abstract class ElementValue
 {
-	protected int type;
-
-	protected ConstantPool cpool;
-
-	public String toString()
-	{
-		return stringifyValue();
-	}
-
-	protected ElementValue(int type, ConstantPool cpool)
-	{
-		this.type = type;
-		this.cpool = cpool;
-	}
-
-	
-
-	public abstract String stringifyValue();
-
-	public abstract void dump(DataOutputStream dos) throws IOException;
-
-	public static final int STRING = 's';
-
-	public static final int ENUM_CONSTANT = 'e';
-
-	public static final int CLASS = 'c';
-
-	public static final int ANNOTATION = '@';
-
-	public static final int ARRAY = '[';
-
-	public static final int PRIMITIVE_INT = 'I';
-
-	public static final int PRIMITIVE_BYTE = 'B';
-
-	public static final int PRIMITIVE_CHAR = 'C';
-
-	public static final int PRIMITIVE_DOUBLE = 'D';
-
-	public static final int PRIMITIVE_FLOAT = 'F';
-
-	public static final int PRIMITIVE_LONG = 'J';
-
-	public static final int PRIMITIVE_SHORT = 'S';
-
-	public static final int PRIMITIVE_BOOLEAN = 'Z';
-
-	public static ElementValue readElementValue(DataInputStream dis,
-			ConstantPool cpool) throws IOException
-	{
-		byte type = dis.readByte();
-		switch (type)
-		{
-		case 'B': // byte
-			return new SimpleElementValue(PRIMITIVE_BYTE, dis
-					.readUnsignedShort(), cpool);
-		case 'C': // char
-			return new SimpleElementValue(PRIMITIVE_CHAR, dis
-					.readUnsignedShort(), cpool);
-		case 'D': // double
-			return new SimpleElementValue(PRIMITIVE_DOUBLE, dis
-					.readUnsignedShort(), cpool);
-		case 'F': // float
-			return new SimpleElementValue(PRIMITIVE_FLOAT, dis
-					.readUnsignedShort(), cpool);
-		case 'I': // int
-			return new SimpleElementValue(PRIMITIVE_INT, dis
-					.readUnsignedShort(), cpool);
-		case 'J': // long
-			return new SimpleElementValue(PRIMITIVE_LONG, dis
-					.readUnsignedShort(), cpool);
-		case 'S': // short
-			return new SimpleElementValue(PRIMITIVE_SHORT, dis
-					.readUnsignedShort(), cpool);
-		case 'Z': // boolean
-			return new SimpleElementValue(PRIMITIVE_BOOLEAN, dis
-					.readUnsignedShort(), cpool);
-		case 's': // String
-			return new SimpleElementValue(STRING, dis.readUnsignedShort(),
-					cpool);
-		case 'e': // Enum constant
-			return new EnumElementValue(ENUM_CONSTANT, dis.readUnsignedShort(),
-					dis.readUnsignedShort(), cpool);
-		case 'c': // Class
-			return new ClassElementValue(CLASS, dis.readUnsignedShort(), cpool);
-		case '@': // Annotation
-			// TODO isRuntimeVisible
-			return new AnnotationElementValue(ANNOTATION, AnnotationEntry.read(
-					dis, cpool, false), cpool);
-		case '[': // Array
-			int numArrayVals = dis.readUnsignedShort();
-			ElementValue[] evalues = new ElementValue[numArrayVals];
-			for (int j = 0; j < numArrayVals; j++)
-			{
-				evalues[j] = ElementValue.readElementValue(dis, cpool);
-			}
-			return new ArrayElementValue(ARRAY, evalues, cpool);
-		default:
-			throw new RuntimeException(
-					"Unexpected element value kind in annotation: " + type);
-		}
-	}
-
-	
+    protected int type;
+
+    protected ConstantPool cpool;
+
+    public String toString()
+    {
+        return stringifyValue();
+    }
+
+    protected ElementValue(int type, ConstantPool cpool)
+    {
+        this.type = type;
+        this.cpool = cpool;
+    }
+
+    
+
+    public abstract String stringifyValue();
+
+    public abstract void dump(DataOutputStream dos) throws IOException;
+
+    public static final int STRING = 's';
+
+    public static final int ENUM_CONSTANT = 'e';
+
+    public static final int CLASS = 'c';
+
+    public static final int ANNOTATION = '@';
+
+    public static final int ARRAY = '[';
+
+    public static final int PRIMITIVE_INT = 'I';
+
+    public static final int PRIMITIVE_BYTE = 'B';
+
+    public static final int PRIMITIVE_CHAR = 'C';
+
+    public static final int PRIMITIVE_DOUBLE = 'D';
+
+    public static final int PRIMITIVE_FLOAT = 'F';
+
+    public static final int PRIMITIVE_LONG = 'J';
+
+    public static final int PRIMITIVE_SHORT = 'S';
+
+    public static final int PRIMITIVE_BOOLEAN = 'Z';
+
+    public static ElementValue readElementValue(DataInputStream dis,
+            ConstantPool cpool) throws IOException
+    {
+        byte type = dis.readByte();
+        switch (type)
+        {
+        case 'B': // byte
+            return new SimpleElementValue(PRIMITIVE_BYTE, dis
+                    .readUnsignedShort(), cpool);
+        case 'C': // char
+            return new SimpleElementValue(PRIMITIVE_CHAR, dis
+                    .readUnsignedShort(), cpool);
+        case 'D': // double
+            return new SimpleElementValue(PRIMITIVE_DOUBLE, dis
+                    .readUnsignedShort(), cpool);
+        case 'F': // float
+            return new SimpleElementValue(PRIMITIVE_FLOAT, dis
+                    .readUnsignedShort(), cpool);
+        case 'I': // int
+            return new SimpleElementValue(PRIMITIVE_INT, dis
+                    .readUnsignedShort(), cpool);
+        case 'J': // long
+            return new SimpleElementValue(PRIMITIVE_LONG, dis
+                    .readUnsignedShort(), cpool);
+        case 'S': // short
+            return new SimpleElementValue(PRIMITIVE_SHORT, dis
+                    .readUnsignedShort(), cpool);
+        case 'Z': // boolean
+            return new SimpleElementValue(PRIMITIVE_BOOLEAN, dis
+                    .readUnsignedShort(), cpool);
+        case 's': // String
+            return new SimpleElementValue(STRING, dis.readUnsignedShort(),
+                    cpool);
+        case 'e': // Enum constant
+            return new EnumElementValue(ENUM_CONSTANT, dis.readUnsignedShort(),
+                    dis.readUnsignedShort(), cpool);
+        case 'c': // Class
+            return new ClassElementValue(CLASS, dis.readUnsignedShort(), cpool);
+        case '@': // Annotation
+            // TODO isRuntimeVisible
+            return new AnnotationElementValue(ANNOTATION, AnnotationEntry.read(
+                    dis, cpool, false), cpool);
+        case '[': // Array
+            int numArrayVals = dis.readUnsignedShort();
+            ElementValue[] evalues = new ElementValue[numArrayVals];
+            for (int j = 0; j < numArrayVals; j++)
+            {
+                evalues[j] = ElementValue.readElementValue(dis, cpool);
+            }
+            return new ArrayElementValue(ARRAY, evalues, cpool);
+        default:
+            throw new RuntimeException(
+                    "Unexpected element value kind in annotation: " + type);
+        }
+    }
+
+    
 }

==================================================
EnclosingMethod.java
index e1e97dbdd0..f8e5a33878 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ElementValuePair.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ElementValuePair.java
@@ -30,38 +30,38 @@ import org.apache.tomcat.util.bcel.Constants;
  */
 public class ElementValuePair
 {
-	private ElementValue elementValue;
+    private ElementValue elementValue;
 
-	private ConstantPool constantPool;
+    private ConstantPool constantPool;
 
-	private int elementNameIndex;
+    private int elementNameIndex;
 
-	public ElementValuePair(int elementNameIndex, ElementValue elementValue,
-			ConstantPool constantPool)
-	{
-		this.elementValue = elementValue;
-		this.elementNameIndex = elementNameIndex;
-		this.constantPool = constantPool;
-	}
+    public ElementValuePair(int elementNameIndex, ElementValue elementValue,
+            ConstantPool constantPool)
+    {
+        this.elementValue = elementValue;
+        this.elementNameIndex = elementNameIndex;
+        this.constantPool = constantPool;
+    }
 
-	public String getNameString()
-	{
-		ConstantUtf8 c = (ConstantUtf8) constantPool.getConstant(
-				elementNameIndex, Constants.CONSTANT_Utf8);
-		return c.getBytes();
-	}
+    public String getNameString()
+    {
+        ConstantUtf8 c = (ConstantUtf8) constantPool.getConstant(
+                elementNameIndex, Constants.CONSTANT_Utf8);
+        return c.getBytes();
+    }
 
-	public final ElementValue getValue()
-	{
-		return elementValue;
-	}
+    public final ElementValue getValue()
+    {
+        return elementValue;
+    }
 
-	
+    
 
-	
-	
-	protected void dump(DataOutputStream dos) throws IOException {
-		dos.writeShort(elementNameIndex); // u2 name of the element
-		elementValue.dump(dos);
-	}
+    
+    
+    protected void dump(DataOutputStream dos) throws IOException {
+        dos.writeShort(elementNameIndex); // u2 name of the element
+        elementValue.dump(dos);
+    }
 }

==================================================
EnumElementValue.java
index 9cb29b92b8..9814f1c0b0 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/EnclosingMethod.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/EnclosingMethod.java
@@ -27,41 +27,41 @@ import org.apache.tomcat.util.bcel.Constants;
  * anonymous classes and ... there can be only one.
  */
 public class EnclosingMethod extends Attribute {
-	
-	// Pointer to the CONSTANT_Class_info structure representing the 
-	// innermost class that encloses the declaration of the current class.
-	private int classIndex;
-	
-	// If the current class is not immediately enclosed by a method or 
-	// constructor, then the value of the method_index item must be zero.  
-	// Otherwise, the value of the  method_index item must point to a 
-	// CONSTANT_NameAndType_info structure representing the name and the 
-	// type of a method in the class referenced by the class we point 
-	// to in the class_index.  *It is the compiler responsibility* to 
-	// ensure that the method identified by this index is the closest 
-	// lexically enclosing method that includes the local/anonymous class.
-	private int methodIndex;
+    
+    // Pointer to the CONSTANT_Class_info structure representing the 
+    // innermost class that encloses the declaration of the current class.
+    private int classIndex;
+    
+    // If the current class is not immediately enclosed by a method or 
+    // constructor, then the value of the method_index item must be zero.  
+    // Otherwise, the value of the  method_index item must point to a 
+    // CONSTANT_NameAndType_info structure representing the name and the 
+    // type of a method in the class referenced by the class we point 
+    // to in the class_index.  *It is the compiler responsibility* to 
+    // ensure that the method identified by this index is the closest 
+    // lexically enclosing method that includes the local/anonymous class.
+    private int methodIndex;
 
-	// Ctors - and code to read an attribute in.
-	public EnclosingMethod(int nameIndex, int len, DataInputStream dis, ConstantPool cpool) throws IOException {
-		this(nameIndex, len, dis.readUnsignedShort(), dis.readUnsignedShort(), cpool);
-	}
+    // Ctors - and code to read an attribute in.
+    public EnclosingMethod(int nameIndex, int len, DataInputStream dis, ConstantPool cpool) throws IOException {
+        this(nameIndex, len, dis.readUnsignedShort(), dis.readUnsignedShort(), cpool);
+    }
 
-	private EnclosingMethod(int nameIndex, int len, int classIdx,int methodIdx, ConstantPool cpool) {
-	    super(Constants.ATTR_ENCLOSING_METHOD, nameIndex, len, cpool);
-	    classIndex  = classIdx;
-	    methodIndex = methodIdx;
-	}
+    private EnclosingMethod(int nameIndex, int len, int classIdx,int methodIdx, ConstantPool cpool) {
+        super(Constants.ATTR_ENCLOSING_METHOD, nameIndex, len, cpool);
+        classIndex  = classIdx;
+        methodIndex = methodIdx;
+    }
 
-	public Attribute copy(ConstantPool constant_pool) {
-		throw new RuntimeException("Not implemented yet!");
-		// is this next line sufficient?
-		// return (EnclosingMethod)clone();
-	}
-	
+    public Attribute copy(ConstantPool constant_pool) {
+        throw new RuntimeException("Not implemented yet!");
+        // is this next line sufficient?
+        // return (EnclosingMethod)clone();
+    }
+    
     public final void dump(DataOutputStream file) throws IOException {
-	    super.dump(file);
-	    file.writeShort(classIndex);
-	    file.writeShort(methodIndex);
+        super.dump(file);
+        file.writeShort(classIndex);
+        file.writeShort(methodIndex);
     }    
 }

==================================================
JavaClass.java
index 999be89a18..f437d30959 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/EnumElementValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/EnumElementValue.java
@@ -23,41 +23,34 @@ import org.apache.tomcat.util.bcel.Constants;
 
 public class EnumElementValue extends ElementValue
 {
-	// For enum types, these two indices point to the type and value
-	private int typeIdx;
+    // For enum types, these two indices point to the type and value
+    private int typeIdx;
+
+    private int valueIdx;
+
+    public EnumElementValue(int type, int typeIdx, int valueIdx,
+            ConstantPool cpool)
+    {
+        super(type, cpool);
+        if (type != ENUM_CONSTANT)
+            throw new RuntimeException(
+                    "Only element values of type enum can be built with this ctor - type specified: " + type);
+        this.typeIdx = typeIdx;
+        this.valueIdx = valueIdx;
+    }
+
+    public void dump(DataOutputStream dos) throws IOException
+    {
+        dos.writeByte(type); // u1 type of value (ENUM_CONSTANT == 'e')
+        dos.writeShort(typeIdx); // u2
+        dos.writeShort(valueIdx); // u2
+    }
+
+    public String stringifyValue()
+    {
+        ConstantUtf8 cu8 = (ConstantUtf8) cpool.getConstant(valueIdx,
+                Constants.CONSTANT_Utf8);
+        return cu8.getBytes();
+    }
 
-	private int valueIdx;
-
-	public EnumElementValue(int type, int typeIdx, int valueIdx,
-			ConstantPool cpool)
-	{
-		super(type, cpool);
-		if (type != ENUM_CONSTANT)
-			throw new RuntimeException(
-					"Only element values of type enum can be built with this ctor - type specified: " + type);
-		this.typeIdx = typeIdx;
-		this.valueIdx = valueIdx;
-	}
-
-	public void dump(DataOutputStream dos) throws IOException
-	{
-		dos.writeByte(type); // u1 type of value (ENUM_CONSTANT == 'e')
-		dos.writeShort(typeIdx); // u2
-		dos.writeShort(valueIdx); // u2
-	}
-
-	public String stringifyValue()
-	{
-		ConstantUtf8 cu8 = (ConstantUtf8) cpool.getConstant(valueIdx,
-				Constants.CONSTANT_Utf8);
-		return cu8.getBytes();
-	}
-
-	
-
-	
-
-	
-
-	
 }

==================================================
LocalVariableTypeTable.java
index e0afce260b..15befb500a 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/JavaClass.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/JavaClass.java
@@ -177,23 +177,24 @@ public class JavaClass extends AccessFlags implements Cloneable, Comparable {
     }
     
     public AnnotationEntry[] getAnnotationEntries() {
-      	if (annotationsOutOfDate) { 
-      		// Find attributes that contain annotation data
-      		Attribute[] attrs = getAttributes();
-      		List accumulatedAnnotations = new ArrayList();
-      		for (int i = 0; i < attrs.length; i++) {
-    			Attribute attribute = attrs[i];
-    			if (attribute instanceof Annotations) {				
-    				Annotations runtimeAnnotations = (Annotations)attribute;
-    				for(int j = 0; j < runtimeAnnotations.getAnnotationEntries().length; j++)
-    					accumulatedAnnotations.add(runtimeAnnotations.getAnnotationEntries()[j]);
-    			}
-    		}
-      		annotations = (AnnotationEntry[])accumulatedAnnotations.toArray(new AnnotationEntry[accumulatedAnnotations.size()]);
-      		annotationsOutOfDate = false;
-      	}
-      	return annotations;
-      }
+        if (annotationsOutOfDate) { 
+            // Find attributes that contain annotation data
+            Attribute[] attrs = getAttributes();
+            List accumulatedAnnotations = new ArrayList();
+            for (int i = 0; i < attrs.length; i++) {
+                Attribute attribute = attrs[i];
+                if (attribute instanceof Annotations) {
+                    Annotations runtimeAnnotations = (Annotations)attribute;
+                    for(int j = 0; j < runtimeAnnotations.getAnnotationEntries().length; j++)
+                        accumulatedAnnotations.add(runtimeAnnotations.getAnnotationEntries()[j]);
+                }
+            }
+            annotations = (AnnotationEntry[])accumulatedAnnotations.toArray(new AnnotationEntry[accumulatedAnnotations.size()]);
+            annotationsOutOfDate = false;
+        }
+        return annotations;
+    }
+
     /**
      * @return Class name.
      */
@@ -237,9 +238,9 @@ public class JavaClass extends AccessFlags implements Cloneable, Comparable {
         }
         AnnotationEntry[] annotations = getAnnotationEntries();
         if (annotations!=null && annotations.length>0) {
-        	buf.append("\nAnnotation(s):\n");
-        	for (int i=0; i<annotations.length; i++) 
-        		buf.append(indent(annotations[i]));
+            buf.append("\nAnnotation(s):\n");
+            for (int i=0; i<annotations.length; i++) 
+                buf.append(indent(annotations[i]));
         }
         if (fields.length > 0) {
             buf.append("\n").append(fields.length).append(" fields:\n");

==================================================
ParameterAnnotationEntry.java
index 739e7240f0..0607a98db9 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/LocalVariableTypeTable.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/LocalVariableTypeTable.java
@@ -22,16 +22,16 @@ import  java.io.*;
 // The new table is used when generic types are about...
 
 //LocalVariableTable_attribute {
-//	   u2 attribute_name_index;
-//	   u4 attribute_length;
-//	   u2 local_variable_table_length;
-//	   {  u2 start_pc;
-//	      u2 length;
-//	      u2 name_index;
-//	      u2 descriptor_index;
-//	      u2 index;
-//	   } local_variable_table[local_variable_table_length];
-//	 }
+//     u2 attribute_name_index;
+//     u4 attribute_length;
+//     u2 local_variable_table_length;
+//     {  u2 start_pc;
+//        u2 length;
+//        u2 name_index;
+//        u2 descriptor_index;
+//        u2 index;
+//     } local_variable_table[local_variable_table_length];
+//   }
 
 //LocalVariableTypeTable_attribute {
 //    u2 attribute_name_index;
@@ -51,8 +51,8 @@ public class LocalVariableTypeTable extends Attribute {
   private LocalVariable[] local_variable_type_table;        // variables
 
   public LocalVariableTypeTable(int name_index, int length,
-			    LocalVariable[] local_variable_table,
-			    ConstantPool    constant_pool)
+                                LocalVariable[] local_variable_table,
+                                ConstantPool    constant_pool)
   {
     super(Constants.ATTR_LOCAL_VARIABLE_TYPE_TABLE, name_index, length, constant_pool);
     setLocalVariableTable(local_variable_table);

==================================================
RuntimeInvisibleAnnotations.java
index eea482b389..4a1c63cf87 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/ParameterAnnotationEntry.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/ParameterAnnotationEntry.java
@@ -43,7 +43,7 @@ public class ParameterAnnotationEntry implements Constants {
         annotation_table_length = (file.readUnsignedShort());
         annotation_table = new AnnotationEntry[annotation_table_length];
         for (int i = 0; i < annotation_table_length; i++) {
-//        	 TODO isRuntimeVisible
+            // TODO isRuntimeVisible
             annotation_table[i] = AnnotationEntry.read(file, constant_pool, false);
         }
     }

==================================================
RuntimeVisibleAnnotations.java
index e14c23e107..2d138f23cc 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/RuntimeInvisibleAnnotations.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/RuntimeInvisibleAnnotations.java
@@ -32,36 +32,36 @@ import org.apache.tomcat.util.bcel.Constants;
  */
 public class RuntimeInvisibleAnnotations extends Annotations
 {
-	/**
-	 * @param name_index
-	 *            Index pointing to the name <em>Code</em>
-	 * @param length
-	 *            Content length in bytes
-	 * @param file
-	 *            Input stream
-	 * @param constant_pool
-	 *            Array of constants
-	 */
-	RuntimeInvisibleAnnotations(int name_index, int length,
-			DataInputStream file, ConstantPool constant_pool)
-			throws IOException
-	{
-		super(Constants.ATTR_RUNTIMEIN_VISIBLE_ANNOTATIONS, name_index, length,
-				file, constant_pool, false);
-	}
+    /**
+     * @param name_index
+     *            Index pointing to the name <em>Code</em>
+     * @param length
+     *            Content length in bytes
+     * @param file
+     *            Input stream
+     * @param constant_pool
+     *            Array of constants
+     */
+    RuntimeInvisibleAnnotations(int name_index, int length,
+                                DataInputStream file, ConstantPool constant_pool)
+                                throws IOException
+    {
+        super(Constants.ATTR_RUNTIMEIN_VISIBLE_ANNOTATIONS, name_index, length,
+                file, constant_pool, false);
+    }
 
-	/**
-	 * @return deep copy of this attribute
-	 */
-	public Attribute copy(ConstantPool constant_pool)
-	{
-		Annotations c = (Annotations) clone();
-		return c;
-	}
+    /**
+     * @return deep copy of this attribute
+     */
+    public Attribute copy(ConstantPool constant_pool)
+    {
+        Annotations c = (Annotations) clone();
+        return c;
+    }
 
-	public final void dump(DataOutputStream dos) throws IOException
-	{
-		super.dump(dos);
-		writeAnnotations(dos);
-	}
+    public final void dump(DataOutputStream dos) throws IOException
+    {
+        super.dump(dos);
+        writeAnnotations(dos);
+    }
 }

==================================================
SimpleElementValue.java
index 419281763f..f1d684ec0d 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/RuntimeVisibleAnnotations.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/RuntimeVisibleAnnotations.java
@@ -32,36 +32,36 @@ import org.apache.tomcat.util.bcel.Constants;
  */
 public class RuntimeVisibleAnnotations extends Annotations
 {
-	/**
-	 * @param name_index
-	 *            Index pointing to the name <em>Code</em>
-	 * @param length
-	 *            Content length in bytes
-	 * @param file
-	 *            Input stream
-	 * @param constant_pool
-	 *            Array of constants
-	 */
-	public RuntimeVisibleAnnotations(int name_index, int length,
-			DataInputStream file, ConstantPool constant_pool)
-			throws IOException
-	{
-		super(Constants.ATTR_RUNTIME_VISIBLE_ANNOTATIONS, name_index, length,
-				file, constant_pool, true);
-	}
+    /**
+     * @param name_index
+     *            Index pointing to the name <em>Code</em>
+     * @param length
+     *            Content length in bytes
+     * @param file
+     *            Input stream
+     * @param constant_pool
+     *            Array of constants
+     */
+    public RuntimeVisibleAnnotations(int name_index, int length,
+            DataInputStream file, ConstantPool constant_pool)
+            throws IOException
+    {
+        super(Constants.ATTR_RUNTIME_VISIBLE_ANNOTATIONS, name_index, length,
+                file, constant_pool, true);
+    }
 
-	/**
-	 * @return deep copy of this attribute
-	 */
-	public Attribute copy(ConstantPool constant_pool)
-	{
-		Annotations c = (Annotations) clone();
-		return c;
-	}
+    /**
+     * @return deep copy of this attribute
+     */
+    public Attribute copy(ConstantPool constant_pool)
+    {
+        Annotations c = (Annotations) clone();
+        return c;
+    }
 
-	public final void dump(DataOutputStream dos) throws IOException
-	{
-		super.dump(dos);
-		writeAnnotations(dos);
-	}
+    public final void dump(DataOutputStream dos) throws IOException
+    {
+        super.dump(dos);
+        writeAnnotations(dos);
+    }
 }

==================================================
StackMapTableEntry.java
index 0618271d43..ecd354a65c 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/SimpleElementValue.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/SimpleElementValue.java
@@ -23,118 +23,99 @@ import org.apache.tomcat.util.bcel.Constants;
 
 public class SimpleElementValue extends ElementValue
 {
-	private int index;
-
-	public SimpleElementValue(int type, int index, ConstantPool cpool)
-	{
-		super(type, cpool);
-		this.index = index;
-	}
-
-	/**
-	 * @return Value entry index in the cpool
-	 */
-	public int getIndex()
-	{
-		return index;
-	}
-
-	
-
-	
-
-	
-
-	
-
-	
-
-	
-
-	
-
-	
-
-	
-
-	
-
-	public String toString()
-	{
-		return stringifyValue();
-	}
-
-	// Whatever kind of value it is, return it as a string
-	public String stringifyValue()
-	{
-		switch (type)
-		{
-		case PRIMITIVE_INT:
-			ConstantInteger c = (ConstantInteger) cpool.getConstant(getIndex(),
-					Constants.CONSTANT_Integer);
-			return Integer.toString(c.getBytes());
-		case PRIMITIVE_LONG:
-			ConstantLong j = (ConstantLong) cpool.getConstant(getIndex(),
-					Constants.CONSTANT_Long);
-			return Long.toString(j.getBytes());
-		case PRIMITIVE_DOUBLE:
-			ConstantDouble d = (ConstantDouble) cpool.getConstant(getIndex(),
-					Constants.CONSTANT_Double);
-			return Double.toString(d.getBytes());
-		case PRIMITIVE_FLOAT:
-			ConstantFloat f = (ConstantFloat) cpool.getConstant(getIndex(),
-					Constants.CONSTANT_Float);
-			return Float.toString(f.getBytes());
-		case PRIMITIVE_SHORT:
-			ConstantInteger s = (ConstantInteger) cpool.getConstant(getIndex(),
-					Constants.CONSTANT_Integer);
-			return Integer.toString(s.getBytes());
-		case PRIMITIVE_BYTE:
-			ConstantInteger b = (ConstantInteger) cpool.getConstant(getIndex(),
-					Constants.CONSTANT_Integer);
-			return Integer.toString(b.getBytes());
-		case PRIMITIVE_CHAR:
-			ConstantInteger ch = (ConstantInteger) cpool.getConstant(
-					getIndex(), Constants.CONSTANT_Integer);
-			return String.valueOf((char)ch.getBytes());
-		case PRIMITIVE_BOOLEAN:
-			ConstantInteger bo = (ConstantInteger) cpool.getConstant(
-					getIndex(), Constants.CONSTANT_Integer);
-			if (bo.getBytes() == 0)
-				return "false";
-			if (bo.getBytes() != 0)
-				return "true";
-		case STRING:
-			ConstantUtf8 cu8 = (ConstantUtf8) cpool.getConstant(getIndex(),
-					Constants.CONSTANT_Utf8);
-			return cu8.getBytes();
-		default:
-			throw new RuntimeException(
-					"SimpleElementValue class does not know how to stringify type "
-							+ type);
-		}
-	}
-
-	public void dump(DataOutputStream dos) throws IOException
-	{
-		dos.writeByte(type); // u1 kind of value
-		switch (type)
-		{
-		case PRIMITIVE_INT:
-		case PRIMITIVE_BYTE:
-		case PRIMITIVE_CHAR:
-		case PRIMITIVE_FLOAT:
-		case PRIMITIVE_LONG:
-		case PRIMITIVE_BOOLEAN:
-		case PRIMITIVE_SHORT:
-		case PRIMITIVE_DOUBLE:
-		case STRING:
-			dos.writeShort(getIndex());
-			break;
-		default:
-			throw new RuntimeException(
-					"SimpleElementValue doesnt know how to write out type "
-							+ type);
-		}
-	}
+    private int index;
+
+    public SimpleElementValue(int type, int index, ConstantPool cpool)
+    {
+        super(type, cpool);
+        this.index = index;
+    }
+
+    /**
+     * @return Value entry index in the cpool
+     */
+    public int getIndex()
+    {
+        return index;
+    }
+    
+
+    public String toString()
+    {
+        return stringifyValue();
+    }
+
+    // Whatever kind of value it is, return it as a string
+    public String stringifyValue()
+    {
+        switch (type)
+        {
+        case PRIMITIVE_INT:
+            ConstantInteger c = (ConstantInteger) cpool.getConstant(getIndex(),
+                    Constants.CONSTANT_Integer);
+            return Integer.toString(c.getBytes());
+        case PRIMITIVE_LONG:
+            ConstantLong j = (ConstantLong) cpool.getConstant(getIndex(),
+                    Constants.CONSTANT_Long);
+            return Long.toString(j.getBytes());
+        case PRIMITIVE_DOUBLE:
+            ConstantDouble d = (ConstantDouble) cpool.getConstant(getIndex(),
+                    Constants.CONSTANT_Double);
+            return Double.toString(d.getBytes());
+        case PRIMITIVE_FLOAT:
+            ConstantFloat f = (ConstantFloat) cpool.getConstant(getIndex(),
+                    Constants.CONSTANT_Float);
+            return Float.toString(f.getBytes());
+        case PRIMITIVE_SHORT:
+            ConstantInteger s = (ConstantInteger) cpool.getConstant(getIndex(),
+                    Constants.CONSTANT_Integer);
+            return Integer.toString(s.getBytes());
+        case PRIMITIVE_BYTE:
+            ConstantInteger b = (ConstantInteger) cpool.getConstant(getIndex(),
+                    Constants.CONSTANT_Integer);
+            return Integer.toString(b.getBytes());
+        case PRIMITIVE_CHAR:
+            ConstantInteger ch = (ConstantInteger) cpool.getConstant(
+                    getIndex(), Constants.CONSTANT_Integer);
+            return String.valueOf((char)ch.getBytes());
+        case PRIMITIVE_BOOLEAN:
+            ConstantInteger bo = (ConstantInteger) cpool.getConstant(
+                    getIndex(), Constants.CONSTANT_Integer);
+            if (bo.getBytes() == 0)
+                return "false";
+            if (bo.getBytes() != 0)
+                return "true";
+        case STRING:
+            ConstantUtf8 cu8 = (ConstantUtf8) cpool.getConstant(getIndex(),
+                    Constants.CONSTANT_Utf8);
+            return cu8.getBytes();
+        default:
+            throw new RuntimeException(
+                    "SimpleElementValue class does not know how to stringify type "
+                            + type);
+        }
+    }
+
+    public void dump(DataOutputStream dos) throws IOException
+    {
+        dos.writeByte(type); // u1 kind of value
+        switch (type)
+        {
+        case PRIMITIVE_INT:
+        case PRIMITIVE_BYTE:
+        case PRIMITIVE_CHAR:
+        case PRIMITIVE_FLOAT:
+        case PRIMITIVE_LONG:
+        case PRIMITIVE_BOOLEAN:
+        case PRIMITIVE_SHORT:
+        case PRIMITIVE_DOUBLE:
+        case STRING:
+            dos.writeShort(getIndex());
+            break;
+        default:
+            throw new RuntimeException(
+                    "SimpleElementValue doesnt know how to write out type "
+                            + type);
+        }
+    }
 }

==================================================
C2BConverter.java
index 88d8df0e8c..bf65638102 100644
--- a/java/org/apache/tomcat/util/bcel/classfile/StackMapTableEntry.java
+++ b/java/org/apache/tomcat/util/bcel/classfile/StackMapTableEntry.java
@@ -35,7 +35,7 @@ import org.apache.tomcat.util.bcel.Constants;
  */
 public final class StackMapTableEntry implements Cloneable {
 
-	private int frame_type;
+    private int frame_type;
     private int byte_code_offset_delta;
     private int number_of_locals;
     private StackMapType[] types_of_locals;
@@ -52,43 +52,43 @@ public final class StackMapTableEntry implements Cloneable {
         this(file.read(), -1, -1, null, -1, null);
         
         if (frame_type >= Constants.SAME_FRAME && frame_type <= Constants.SAME_FRAME_MAX) {
-        	byte_code_offset_delta = frame_type - Constants.SAME_FRAME;
+            byte_code_offset_delta = frame_type - Constants.SAME_FRAME;
         } else if (frame_type >= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME && frame_type <= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {
-        	byte_code_offset_delta = frame_type - Constants.SAME_LOCALS_1_STACK_ITEM_FRAME;
-        	number_of_stack_items = 1;
-        	types_of_stack_items = new StackMapType[1];
-        	types_of_stack_items[0] = new StackMapType(file, constant_pool);
+            byte_code_offset_delta = frame_type - Constants.SAME_LOCALS_1_STACK_ITEM_FRAME;
+            number_of_stack_items = 1;
+            types_of_stack_items = new StackMapType[1];
+            types_of_stack_items[0] = new StackMapType(file, constant_pool);
         } else if (frame_type == Constants.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
-        	byte_code_offset_delta = file.readShort();
-        	number_of_stack_items = 1;
-        	types_of_stack_items = new StackMapType[1];
-        	types_of_stack_items[0] = new StackMapType(file, constant_pool);
+            byte_code_offset_delta = file.readShort();
+            number_of_stack_items = 1;
+            types_of_stack_items = new StackMapType[1];
+            types_of_stack_items[0] = new StackMapType(file, constant_pool);
         } else if (frame_type >= Constants.CHOP_FRAME && frame_type <= Constants.CHOP_FRAME_MAX) {
-        	byte_code_offset_delta = file.readShort();
+            byte_code_offset_delta = file.readShort();
         } else if (frame_type == Constants.SAME_FRAME_EXTENDED) {
-        	byte_code_offset_delta = file.readShort();
+            byte_code_offset_delta = file.readShort();
         } else if (frame_type >= Constants.APPEND_FRAME && frame_type <= Constants.APPEND_FRAME_MAX) {
-        	byte_code_offset_delta = file.readShort();
-        	number_of_locals = frame_type - 251;
-        	types_of_locals = new StackMapType[number_of_locals];
-        	for (int i = 0; i < number_of_locals; i++) {
-        		types_of_locals[i] = new StackMapType(file, constant_pool);
-        	}        	
+            byte_code_offset_delta = file.readShort();
+            number_of_locals = frame_type - 251;
+            types_of_locals = new StackMapType[number_of_locals];
+            for (int i = 0; i < number_of_locals; i++) {
+                types_of_locals[i] = new StackMapType(file, constant_pool);
+            }            
         } else if (frame_type == Constants.FULL_FRAME) {        
-        	byte_code_offset_delta = file.readShort();
-        	number_of_locals = file.readShort();
-        	types_of_locals = new StackMapType[number_of_locals];
-        	for (int i = 0; i < number_of_locals; i++) {
-        		types_of_locals[i] = new StackMapType(file, constant_pool);
-        	}
-        	number_of_stack_items = file.readShort();
-        	types_of_stack_items = new StackMapType[number_of_stack_items];
-        	for (int i = 0; i < number_of_stack_items; i++) {
-        		types_of_stack_items[i] = new StackMapType(file, constant_pool);
-        	}
+            byte_code_offset_delta = file.readShort();
+            number_of_locals = file.readShort();
+            types_of_locals = new StackMapType[number_of_locals];
+            for (int i = 0; i < number_of_locals; i++) {
+                types_of_locals[i] = new StackMapType(file, constant_pool);
+            }
+            number_of_stack_items = file.readShort();
+            types_of_stack_items = new StackMapType[number_of_stack_items];
+            for (int i = 0; i < number_of_stack_items; i++) {
+                types_of_stack_items[i] = new StackMapType(file, constant_pool);
+            }
         } else {
-        	/* Can't happen */
-        	throw new ClassFormatException ("Invalid frame type found while parsing stack map table: " + frame_type);
+            /* Can't happen */
+            throw new ClassFormatException ("Invalid frame type found while parsing stack map table: " + frame_type);
         }
     }
 
@@ -96,7 +96,7 @@ public final class StackMapTableEntry implements Cloneable {
     public StackMapTableEntry(int tag, int byte_code_offset_delta, int number_of_locals,
             StackMapType[] types_of_locals, int number_of_stack_items,
             StackMapType[] types_of_stack_items) {
-    	this.frame_type = tag;
+        this.frame_type = tag;
         this.byte_code_offset_delta = byte_code_offset_delta;
         this.number_of_locals = number_of_locals;
         this.types_of_locals = types_of_locals;
@@ -112,21 +112,21 @@ public final class StackMapTableEntry implements Cloneable {
      * @throws IOException
      */
     public final void dump( DataOutputStream file ) throws IOException {
-    	file.write(frame_type);
-    	if (frame_type >= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME && frame_type <= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {
-        	types_of_stack_items[0].dump(file);
+        file.write(frame_type);
+        if (frame_type >= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME && frame_type <= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {
+            types_of_stack_items[0].dump(file);
         } else if (frame_type == Constants.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
-        	file.write(byte_code_offset_delta);
-        	types_of_stack_items[0].dump(file);
+            file.write(byte_code_offset_delta);
+            types_of_stack_items[0].dump(file);
         } else if (frame_type >= Constants.CHOP_FRAME && frame_type <= Constants.CHOP_FRAME_MAX) {
-        	file.write(byte_code_offset_delta);
+            file.write(byte_code_offset_delta);
         } else if (frame_type == Constants.SAME_FRAME_EXTENDED) {
-        	file.write(byte_code_offset_delta);
+            file.write(byte_code_offset_delta);
         } else if (frame_type >= Constants.APPEND_FRAME && frame_type <= Constants.APPEND_FRAME_MAX) {
-        	file.write(byte_code_offset_delta);
-        	for (int i = 0; i < number_of_locals; i++) {
-        		types_of_locals[i].dump(file);
-        	}        	
+            file.write(byte_code_offset_delta);
+            for (int i = 0; i < number_of_locals; i++) {
+                types_of_locals[i].dump(file);
+            }            
         } else if (frame_type == Constants.FULL_FRAME) {        
             file.writeShort(byte_code_offset_delta);
             file.writeShort(number_of_locals);
@@ -138,8 +138,8 @@ public final class StackMapTableEntry implements Cloneable {
                 types_of_stack_items[i].dump(file);
             }
         } else {
-        	/* Can't happen */
-        	throw new ClassFormatException ("Invalid Stack map table tag: " + frame_type);
+            /* Can't happen */
+            throw new ClassFormatException ("Invalid Stack map table tag: " + frame_type);
         }
     }
 
@@ -151,21 +151,21 @@ public final class StackMapTableEntry implements Cloneable {
         StringBuffer buf = new StringBuffer(64);
         buf.append("(");
         if (frame_type >= Constants.SAME_FRAME && frame_type <= Constants.SAME_FRAME_MAX) {
-        	buf.append("SAME");
+            buf.append("SAME");
         } else if (frame_type >= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME && frame_type <= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {
-        	buf.append("SAME_LOCALS_1_STACK");
+            buf.append("SAME_LOCALS_1_STACK");
         } else if (frame_type == Constants.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
-        	buf.append("SAME_LOCALS_1_STACK_EXTENDED");
+            buf.append("SAME_LOCALS_1_STACK_EXTENDED");
         } else if (frame_type >= Constants.CHOP_FRAME && frame_type <= Constants.CHOP_FRAME_MAX) {
-        	buf.append("CHOP "+(251-frame_type));
+            buf.append("CHOP "+(251-frame_type));
         } else if (frame_type == Constants.SAME_FRAME_EXTENDED) {
-        	buf.append("SAME_EXTENDED");
+            buf.append("SAME_EXTENDED");
         } else if (frame_type >= Constants.APPEND_FRAME && frame_type <= Constants.APPEND_FRAME_MAX) {
-        	buf.append("APPEND "+(frame_type-251));
+            buf.append("APPEND "+(frame_type-251));
         } else if (frame_type == Constants.FULL_FRAME) {        
-        	buf.append("FULL");
+            buf.append("FULL");
         } else {
-        	buf.append("UNKNOWN");
+            buf.append("UNKNOWN");
         }
         buf.append(", offset delta=").append(byte_code_offset_delta);
         if (number_of_locals > 0) {

==================================================
MessageBytes.java
index 35ab8c0289..d75c6b1cba 100644
--- a/java/org/apache/tomcat/util/buf/C2BConverter.java
+++ b/java/org/apache/tomcat/util/buf/C2BConverter.java
@@ -42,20 +42,20 @@ public final class C2BConverter {
     /** Create a converter, with bytes going to a byte buffer
      */
     public C2BConverter(ByteChunk output, String encoding) throws IOException {
-	this.bb=output;
-	ios=new IntermediateOutputStream( output );
-	conv=new WriteConvertor( ios, encoding );
+        this.bb=output;
+        ios=new IntermediateOutputStream( output );
+        conv=new WriteConvertor( ios, encoding );
         this.enc=encoding;
     }
 
     /** Create a converter
      */
     public C2BConverter(String encoding) throws IOException {
-	this( new ByteChunk(1024), encoding );
+        this( new ByteChunk(1024), encoding );
     }
 
     public ByteChunk getByteChunk() {
-	return bb;
+        return bb;
     }
 
     public String getEncoding() {
@@ -63,40 +63,40 @@ public final class C2BConverter {
     }
 
     public void setByteChunk(ByteChunk bb) {
-	this.bb=bb;
-	ios.setByteChunk( bb );
+        this.bb=bb;
+        ios.setByteChunk( bb );
     }
 
     /** Reset the internal state, empty the buffers.
      *  The encoding remain in effect, the internal buffers remain allocated.
      */
     public  final void recycle() {
-	conv.recycle();
-	bb.recycle();
+        conv.recycle();
+        bb.recycle();
     }
 
     /** Generate the bytes using the specified encoding
      */
     public  final void convert(char c[], int off, int len ) throws IOException {
-	conv.write( c, off, len );
+        conv.write( c, off, len );
     }
 
     /** Generate the bytes using the specified encoding
      */
     public  final void convert(String s, int off, int len ) throws IOException {
-	conv.write( s, off, len );
+        conv.write( s, off, len );
     }
 
     /** Generate the bytes using the specified encoding
      */
     public  final void convert(String s ) throws IOException {
-	conv.write( s );
+        conv.write( s );
     }
 
     /** Generate the bytes using the specified encoding
      */
     public  final void convert(char c ) throws IOException {
-	conv.write( c );
+        conv.write( c );
     }
 
     /** Convert a message bytes chars to bytes
@@ -131,7 +131,7 @@ public final class C2BConverter {
      *  byte[]
      */
     public  final void flushBuffer() throws IOException {
-	conv.flush();
+        conv.flush();
     }
 
 }
@@ -160,7 +160,7 @@ public final class C2BConverter {
  *  overhead too.
  * 
  */
- final class	WriteConvertor extends OutputStreamWriter {
+ final class WriteConvertor extends OutputStreamWriter {
     // stream with flush() and close(). overridden.
     private IntermediateOutputStream ios;
     
@@ -169,18 +169,18 @@ public final class C2BConverter {
     /** Create a converter.
      */
     public WriteConvertor( IntermediateOutputStream out, String enc )
-	throws UnsupportedEncodingException
+        throws UnsupportedEncodingException
     {
-	super( out, enc );
-	ios=out;
+        super( out, enc );
+        ios=out;
     }
     
     /** Overridden - will do nothing but reset internal state.
      */
     @Override
     public  final void close() throws IOException {
-	// NOTHING
-	// Calling super.close() would reset out and cb.
+        // NOTHING
+        // Calling super.close() would reset out and cb.
     }
     
     /**
@@ -188,28 +188,28 @@ public final class C2BConverter {
      */ 
     @Override
     public  final void flush() throws IOException {
-	// Will flushBuffer and out()
-	// flushBuffer put any remaining chars in the byte[] 
-	super.flush();
+        // Will flushBuffer and out()
+        // flushBuffer put any remaining chars in the byte[] 
+        super.flush();
     }
     
     @Override
     public  final void write(char cbuf[], int off, int len) throws IOException {
-	// will do the conversion and call write on the output stream
-	super.write( cbuf, off, len );
+        // will do the conversion and call write on the output stream
+        super.write( cbuf, off, len );
     }
     
     /** Reset the buffer
      */
     public  final void recycle() {
-	ios.disable();
-	try {
-	    //	    System.out.println("Reseting writer");
-	    flush();
-	} catch( Exception ex ) {
-	    ex.printStackTrace();
-	}
-	ios.enable();
+        ios.disable();
+        try {
+            // System.out.println("Reseting writer");
+            flush();
+        } catch( Exception ex ) {
+            ex.printStackTrace();
+        }
+        ios.enable();
     }
     
 }
@@ -226,50 +226,50 @@ final class IntermediateOutputStream extends OutputStream {
     private boolean enabled=true;
     
     public IntermediateOutputStream(ByteChunk tbuff) {
-	    this.tbuff=tbuff;
+        this.tbuff=tbuff;
     }
     
     @Override
     public  final void close() throws IOException {
-	// shouldn't be called - we filter it out in writer
-	throw new IOException("close() called - shouldn't happen ");
+        // shouldn't be called - we filter it out in writer
+        throw new IOException("close() called - shouldn't happen ");
     }
     
     @Override
     public  final void flush() throws IOException {
-	// nothing - write will go directly to the buffer,
-	// we don't keep any state
+        // nothing - write will go directly to the buffer,
+        // we don't keep any state
     }
     
     @Override
     public  final  void write(byte cbuf[], int off, int len) throws IOException {
-	// will do the conversion and call write on the output stream
-	if( enabled ) {
-	    tbuff.append( cbuf, off, len );
-	}
+        // will do the conversion and call write on the output stream
+        if( enabled ) {
+            tbuff.append( cbuf, off, len );
+        }
     }
     
     @Override
     public  final void write( int i ) throws IOException {
-	throw new IOException("write( int ) called - shouldn't happen ");
+        throw new IOException("write( int ) called - shouldn't happen ");
     }
 
     // -------------------- Internal methods --------------------
 
     void setByteChunk( ByteChunk bb ) {
-	tbuff=bb;
+        tbuff=bb;
     }
     
     /** Temporary disable - this is used to recycle the converter without
      *  generating an output if the buffers were not flushed
      */
     final void disable() {
-	enabled=false;
+        enabled=false;
     }
 
     /** Reenable - used to recycle the converter
      */
     final void enable() {
-	enabled=true;
+        enabled=true;
     }
 }

==================================================
FactoryCreateRule.java
index 73744a5015..a11256911b 100644
--- a/java/org/apache/tomcat/util/buf/MessageBytes.java
+++ b/java/org/apache/tomcat/util/buf/MessageBytes.java
@@ -73,36 +73,36 @@ public final class MessageBytes implements Cloneable, Serializable {
     /** Construct a new MessageBytes instance
      */
     public static MessageBytes newInstance() {
-	return factory.newInstance();
+        return factory.newInstance();
     }
 
     public MessageBytes getClone() {
-	try {
-	    return (MessageBytes)this.clone();
-	} catch( Exception ex) {
-	    return null;
-	}
+        try {
+            return (MessageBytes)this.clone();
+        } catch( Exception ex) {
+            return null;
+        }
     }
 
     public boolean isNull() {
-//		should we check also hasStrValue ???
-		return byteC.isNull() && charC.isNull() && ! hasStrValue;
-	// bytes==null && strValue==null;
+        // should we check also hasStrValue ???
+        return byteC.isNull() && charC.isNull() && ! hasStrValue;
+        // bytes==null && strValue==null;
     }
     
     /**
      * Resets the message bytes to an uninitialized (NULL) state.
      */
     public void recycle() {
-	type=T_NULL;
-	byteC.recycle();
-	charC.recycle();
+        type=T_NULL;
+        byteC.recycle();
+        charC.recycle();
 
-	strValue=null;
+        strValue=null;
 
-	hasStrValue=false;
-	hasHashCode=false;
-	hasIntValue=false;
+        hasStrValue=false;
+        hasHashCode=false;
+        hasIntValue=false;
     hasLongValue=false;
     }
 
@@ -128,12 +128,12 @@ public final class MessageBytes implements Cloneable, Serializable {
      *  If no encoding is set, we'll use 8859-1.
      */
     public void setEncoding( String enc ) {
-	if( !byteC.isNull() ) {
-	    // if the encoding changes we need to reset the conversion results
-	    charC.recycle();
-	    hasStrValue=false;
-	}
-	byteC.setEncoding(enc);
+        if( !byteC.isNull() ) {
+            // if the encoding changes we need to reset the conversion results
+            charC.recycle();
+            hasStrValue=false;
+        }
+        byteC.setEncoding(enc);
     }
 
     /** 
@@ -153,16 +153,16 @@ public final class MessageBytes implements Cloneable, Serializable {
     }
 
     /** Remove the cached string value. Use it after a conversion on the
-     *	byte[] or after the encoding is changed
+     *  byte[] or after the encoding is changed
      *  XXX Is this needed ?
      */
     public void resetStringValue() {
-	if( type != T_STR ) {
-	    // If this was created as a byte[] or char[], we remove
-	    // the old string value
-	    hasStrValue=false;
-	    strValue=null;
-	}
+        if( type != T_STR ) {
+            // If this was created as a byte[] or char[], we remove
+            // the old string value
+            hasStrValue=false;
+            strValue=null;
+        }
     }
 
     /** 
@@ -208,7 +208,7 @@ public final class MessageBytes implements Cloneable, Serializable {
      *  T_STR, T_BYTES, T_CHARS or T_NULL
      */
     public int getType() {
-	return type;
+        return type;
     }
     
     /**
@@ -216,7 +216,7 @@ public final class MessageBytes implements Cloneable, Serializable {
      * Valid only if T_BYTES or after a conversion was made.
      */
     public ByteChunk getByteChunk() {
-	return byteC;
+        return byteC;
     }
 
     /**
@@ -224,7 +224,7 @@ public final class MessageBytes implements Cloneable, Serializable {
      * Valid only if T_CHARS or after a conversion was made.
      */
     public CharChunk getCharChunk() {
-	return charC;
+        return charC;
     }
 
     /**
@@ -232,7 +232,7 @@ public final class MessageBytes implements Cloneable, Serializable {
      * Valid only if T_STR or after a conversion was made.
      */
     public String getString() {
-	return strValue;
+        return strValue;
     }
 
     /** Do a char->byte conversion.
@@ -252,15 +252,15 @@ public final class MessageBytes implements Cloneable, Serializable {
      *  XXX Not optimized - it converts to String first.
      */
     public void toChars() {
-	if( ! charC.isNull() ) {
+        if( ! charC.isNull() ) {
             type=T_CHARS;
-	    return;
-	}
-	// inefficient
-	toString();
+            return;
+        }
+        // inefficient
+        toString();
         type=T_CHARS;
-	char cc[]=strValue.toCharArray();
-	charC.setChars(cc, 0, cc.length);
+        char cc[]=strValue.toCharArray();
+        charC.setChars(cc, 0, cc.length);
     }
     
 
@@ -270,16 +270,16 @@ public final class MessageBytes implements Cloneable, Serializable {
      * in chars.
      */
     public int getLength() {
-	if(type==T_BYTES)
-	    return byteC.getLength();
-	if(type==T_CHARS) {
-	    return charC.getLength();
-	}
-	if(type==T_STR)
-	    return strValue.length();
-	toString();
-	if( strValue==null ) return 0;
-	return strValue.length();
+        if(type==T_BYTES)
+            return byteC.getLength();
+        if(type==T_CHARS) {
+            return charC.getLength();
+        }
+        if(type==T_STR)
+            return strValue.length();
+        toString();
+        if( strValue==null ) return 0;
+        return strValue.length();
     }
 
     // -------------------- equals --------------------
@@ -290,17 +290,17 @@ public final class MessageBytes implements Cloneable, Serializable {
      * @return true if the comparison succeeded, false otherwise
      */
     public boolean equals(String s) {
-	switch (type) {
-	case T_STR:
-	    if( strValue==null && s!=null) return false;
-	    return strValue.equals( s );
-	case T_CHARS:
-	    return charC.equals( s );
-	case T_BYTES:
-	    return byteC.equals( s );
-	default:
-	    return false;
-	}
+        switch (type) {
+        case T_STR:
+            if( strValue==null && s!=null) return false;
+            return strValue.equals( s );
+        case T_CHARS:
+            return charC.equals( s );
+        case T_BYTES:
+            return byteC.equals( s );
+        default:
+            return false;
+        }
     }
 
     /**
@@ -309,49 +309,49 @@ public final class MessageBytes implements Cloneable, Serializable {
      * @return true if the comparison succeeded, false otherwise
      */
     public boolean equalsIgnoreCase(String s) {
-	switch (type) {
-	case T_STR:
-	    if( strValue==null && s!=null) return false;
-	    return strValue.equalsIgnoreCase( s );
-	case T_CHARS:
-	    return charC.equalsIgnoreCase( s );
-	case T_BYTES:
-	    return byteC.equalsIgnoreCase( s );
-	default:
-	    return false;
-	}
+        switch (type) {
+        case T_STR:
+            if( strValue==null && s!=null) return false;
+            return strValue.equalsIgnoreCase( s );
+        case T_CHARS:
+            return charC.equalsIgnoreCase( s );
+        case T_BYTES:
+            return byteC.equalsIgnoreCase( s );
+        default:
+            return false;
+        }
     }
 
     public boolean equals(MessageBytes mb) {
-	switch (type) {
-	case T_STR:
-	    return mb.equals( strValue );
-	}
-
-	if( mb.type != T_CHARS &&
-	    mb.type!= T_BYTES ) {
-	    // it's a string or int/date string value
-	    return equals( mb.toString() );
-	}
-
-	// mb is either CHARS or BYTES.
-	// this is either CHARS or BYTES
-	// Deal with the 4 cases ( in fact 3, one is symmetric)
-	
-	if( mb.type == T_CHARS && type==T_CHARS ) {
-	    return charC.equals( mb.charC );
-	} 
-	if( mb.type==T_BYTES && type== T_BYTES ) {
-	    return byteC.equals( mb.byteC );
-	}
-	if( mb.type== T_CHARS && type== T_BYTES ) {
-	    return byteC.equals( mb.charC );
-	}
-	if( mb.type== T_BYTES && type== T_CHARS ) {
-	    return mb.byteC.equals( charC );
-	}
-	// can't happen
-	return true;
+        switch (type) {
+        case T_STR:
+            return mb.equals( strValue );
+        }
+
+        if( mb.type != T_CHARS &&
+            mb.type!= T_BYTES ) {
+            // it's a string or int/date string value
+            return equals( mb.toString() );
+        }
+
+        // mb is either CHARS or BYTES.
+        // this is either CHARS or BYTES
+        // Deal with the 4 cases ( in fact 3, one is symmetric)
+        
+        if( mb.type == T_CHARS && type==T_CHARS ) {
+            return charC.equals( mb.charC );
+        } 
+        if( mb.type==T_BYTES && type== T_BYTES ) {
+            return byteC.equals( mb.byteC );
+        }
+        if( mb.type== T_CHARS && type== T_BYTES ) {
+            return byteC.equals( mb.charC );
+        }
+        if( mb.type== T_BYTES && type== T_CHARS ) {
+            return mb.byteC.equals( charC );
+        }
+        // can't happen
+        return true;
     }
 
     
@@ -360,16 +360,16 @@ public final class MessageBytes implements Cloneable, Serializable {
      * @param s the string
      */
     public boolean startsWith(String s) {
-	switch (type) {
-	case T_STR:
-	    return strValue.startsWith( s );
-	case T_CHARS:
-	    return charC.startsWith( s );
-	case T_BYTES:
-	    return byteC.startsWith( s );
-	default:
-	    return false;
-	}
+        switch (type) {
+        case T_STR:
+            return strValue.startsWith( s );
+        case T_CHARS:
+            return charC.startsWith( s );
+        case T_BYTES:
+            return byteC.startsWith( s );
+        default:
+            return false;
+        }
     }
 
     /**
@@ -378,25 +378,25 @@ public final class MessageBytes implements Cloneable, Serializable {
      * @param pos The start position
      */
     public boolean startsWithIgnoreCase(String s, int pos) {
-	switch (type) {
-	case T_STR:
-	    if( strValue==null ) return false;
-	    if( strValue.length() < pos + s.length() ) return false;
-	    
-	    for( int i=0; i<s.length(); i++ ) {
-		if( Ascii.toLower( s.charAt( i ) ) !=
-		    Ascii.toLower( strValue.charAt( pos + i ))) {
-		    return false;
-		}
-	    }
-	    return true;
-	case T_CHARS:
-	    return charC.startsWithIgnoreCase( s, pos );
-	case T_BYTES:
-	    return byteC.startsWithIgnoreCase( s, pos );
-	default:
-	    return false;
-	}
+        switch (type) {
+        case T_STR:
+            if( strValue==null ) return false;
+            if( strValue.length() < pos + s.length() ) return false;
+            
+            for( int i=0; i<s.length(); i++ ) {
+                if( Ascii.toLower( s.charAt( i ) ) !=
+                    Ascii.toLower( strValue.charAt( pos + i ))) {
+                    return false;
+                }
+            }
+            return true;
+        case T_CHARS:
+            return charC.startsWithIgnoreCase( s, pos );
+        case T_BYTES:
+            return byteC.startsWithIgnoreCase( s, pos );
+        default:
+            return false;
+        }
     }
 
     
@@ -415,45 +415,45 @@ public final class MessageBytes implements Cloneable, Serializable {
 
     // normal hash. 
     private int hash() {
-	int code=0;
-	switch (type) {
-	case T_STR:
-	    // We need to use the same hash function
-	    for (int i = 0; i < strValue.length(); i++) {
-		code = code * 37 + strValue.charAt( i );
-	    }
-	    return code;
-	case T_CHARS:
-	    return charC.hash();
-	case T_BYTES:
-	    return byteC.hash();
-	default:
-	    return 0;
-	}
+        int code=0;
+        switch (type) {
+        case T_STR:
+            // We need to use the same hash function
+            for (int i = 0; i < strValue.length(); i++) {
+                code = code * 37 + strValue.charAt( i );
+            }
+            return code;
+        case T_CHARS:
+            return charC.hash();
+        case T_BYTES:
+            return byteC.hash();
+        default:
+            return 0;
+        }
     }
 
     public int indexOf(char c) {
-	return indexOf( c, 0);
+        return indexOf( c, 0);
     }
 
     // Inefficient initial implementation. Will be replaced on the next
     // round of tune-up
     public int indexOf(String s, int starting) {
-	toString();
-	return strValue.indexOf( s, starting );
+        toString();
+        return strValue.indexOf( s, starting );
     }
     
     // Inefficient initial implementation. Will be replaced on the next
     // round of tune-up
     public int indexOf(String s) {
-	return indexOf( s, 0 );
+        return indexOf( s, 0 );
     }
     
     public int indexOfIgnoreCase(String s, int starting) {
-	toString();
-	String upper=strValue.toUpperCase(Locale.ENGLISH);
-	String sU=s.toUpperCase(Locale.ENGLISH);
-	return upper.indexOf( sU, starting );
+        toString();
+        String upper=strValue.toUpperCase(Locale.ENGLISH);
+        String sU=s.toUpperCase(Locale.ENGLISH);
+        return upper.indexOf( sU, starting );
     }
     
     /**
@@ -462,16 +462,16 @@ public final class MessageBytes implements Cloneable, Serializable {
      * @param starting The start position
      */
     public int indexOf(char c, int starting) {
-	switch (type) {
-	case T_STR:
-	    return strValue.indexOf( c, starting );
-	case T_CHARS:
-	    return charC.indexOf( c, starting);
-	case T_BYTES:
-	    return byteC.indexOf( c, starting );
-	default:
-	    return -1;
-	}
+        switch (type) {
+        case T_STR:
+            return strValue.indexOf( c, starting );
+        case T_CHARS:
+            return charC.indexOf( c, starting);
+        case T_BYTES:
+            return byteC.indexOf( c, starting );
+        default:
+            return -1;
+        }
     }
 
     /** Copy the src into this MessageBytes, allocating more space if
@@ -479,25 +479,25 @@ public final class MessageBytes implements Cloneable, Serializable {
      */
     public void duplicate( MessageBytes src ) throws IOException
     {
-	switch( src.getType() ) {
-	case MessageBytes.T_BYTES:
-	    type=T_BYTES;
-	    ByteChunk bc=src.getByteChunk();
-	    byteC.allocate( 2 * bc.getLength(), -1 );
-	    byteC.append( bc );
-	    break;
-	case MessageBytes.T_CHARS:
-	    type=T_CHARS;
-	    CharChunk cc=src.getCharChunk();
-	    charC.allocate( 2 * cc.getLength(), -1 );
-	    charC.append( cc );
-	    break;
-	case MessageBytes.T_STR:
-	    type=T_STR;
-	    String sc=src.getString();
-	    this.setString( sc );
-	    break;
-	}
+        switch( src.getType() ) {
+        case MessageBytes.T_BYTES:
+            type=T_BYTES;
+            ByteChunk bc=src.getByteChunk();
+            byteC.allocate( 2 * bc.getLength(), -1 );
+            byteC.append( bc );
+            break;
+        case MessageBytes.T_CHARS:
+            type=T_CHARS;
+            CharChunk cc=src.getCharChunk();
+            charC.allocate( 2 * cc.getLength(), -1 );
+            charC.append( cc );
+            break;
+        case MessageBytes.T_STR:
+            type=T_STR;
+            String sc=src.getString();
+            this.setString( sc );
+            break;
+        }
     }
 
     // -------------------- Deprecated code --------------------
@@ -598,18 +598,18 @@ public final class MessageBytes implements Cloneable, Serializable {
      */ 
     public int getInt() 
     {
-	if( hasIntValue )
-	    return intValue;
-	
-	switch (type) {
-	case T_BYTES:
-	    intValue=byteC.getInt();
-	    break;
-	default:
-	    intValue=Integer.parseInt(toString());
-	}
-	hasIntValue=true;
-	return intValue;
+        if( hasIntValue )
+            return intValue;
+        
+        switch (type) {
+        case T_BYTES:
+            intValue=byteC.getInt();
+            break;
+        default:
+            intValue=Integer.parseInt(toString());
+        }
+        hasIntValue=true;
+        return intValue;
     }
 
     // Used for headers conversion
@@ -637,14 +637,14 @@ public final class MessageBytes implements Cloneable, Serializable {
     private static MessageBytesFactory factory=new MessageBytesFactory();
 
     public static void setFactory( MessageBytesFactory mbf ) {
-	factory=mbf;
+        factory=mbf;
     }
     
     public static class MessageBytesFactory {
-	protected MessageBytesFactory() {
-	}
-	public MessageBytes newInstance() {
-	    return new MessageBytes();
-	}
+        protected MessageBytesFactory() {
+        }
+        public MessageBytes newInstance() {
+            return new MessageBytes();
+        }
     }
 }

==================================================
WithDefaultsRulesWrapper.java
index c1153564a9..04aa80d723 100644
--- a/java/org/apache/tomcat/util/digester/FactoryCreateRule.java
+++ b/java/org/apache/tomcat/util/digester/FactoryCreateRule.java
@@ -308,7 +308,7 @@ public class FactoryCreateRule extends Rule {
         
         // check if object was created 
         // this only happens if an exception was thrown and we're ignoring them
-        if (	
+        if (
                 ignoreCreateExceptions &&
                 exceptionIgnoredStack != null &&
                 !(exceptionIgnoredStack.empty())) {

==================================================
CookieSupport.java
index 5156d3fb21..201e76900b 100644
--- a/java/org/apache/tomcat/util/digester/WithDefaultsRulesWrapper.java
+++ b/java/org/apache/tomcat/util/digester/WithDefaultsRulesWrapper.java
@@ -103,7 +103,7 @@ public class WithDefaultsRulesWrapper implements Rules {
     /** Gets Rule's which will be fired when the wrapped implementation returns no matches */
     public List<Rule> getDefaults() {
         return defaultRules;
-    }	
+    }
     
     // --------------------------------------------------------- Public Methods
     
@@ -114,7 +114,7 @@ public class WithDefaultsRulesWrapper implements Rules {
      */
     public List<Rule> match(String namespaceURI, String pattern) {
         List<Rule> matches = wrappedRules.match(namespaceURI, pattern);
-        if (matches ==  null || matches.isEmpty()) {	
+        if (matches ==  null || matches.isEmpty()) {
             // a little bit of defensive programming
             return new ArrayList<Rule>(defaultRules);
         }
@@ -156,5 +156,5 @@ public class WithDefaultsRulesWrapper implements Rules {
     public void add(String pattern, Rule rule) {
         wrappedRules.add(pattern, rule);
         allRules.add(rule);
-    }	
+    }
 }

==================================================
BaseModelMBean.java
index 1aed473620..53906073dd 100644
--- a/java/org/apache/tomcat/util/http/CookieSupport.java
+++ b/java/org/apache/tomcat/util/http/CookieSupport.java
@@ -24,7 +24,6 @@ package org.apache.tomcat.util.http;
  */
 public final class CookieSupport {
 
-	
     // --------------------------------------------------------------- Constants
     /**
      * If set to true, we parse cookies strictly according to the servlet,

==================================================
DefaultServerSocketFactory.java
index 3441d62108..8cf3677f01 100644
--- a/java/org/apache/tomcat/util/modeler/BaseModelMBean.java
+++ b/java/org/apache/tomcat/util/modeler/BaseModelMBean.java
@@ -1139,40 +1139,40 @@ public class BaseModelMBean implements DynamicMBean, MBeanRegistration, ModelMBe
     }
 
     static class MethodKey {
-	private String name;
-	private String[] signature;
-
-	MethodKey(String name, String[] signature) {
-	    this.name = name;
-	    if(signature == null) {
-		signature = new String[0];
-	    }
-	    this.signature = signature;
-	}
-
-	@Override
-    public boolean equals(Object other) {
-	    if(!(other instanceof MethodKey)) {
-		return false;
-	    }
-	    MethodKey omk = (MethodKey)other;
-	    if(!name.equals(omk.name)) {
-		return false;
-	    }
-	    if(signature.length != omk.signature.length) {
-		return false;
-	    }
-	    for(int i=0; i < signature.length; i++) {
-		if(!signature[i].equals(omk.signature[i])) {
-		    return false;
-		}
-	    }
-	    return true;
-	}
-
-	@Override
-    public int hashCode() {
-	    return name.hashCode();
-	}
+        private String name;
+        private String[] signature;
+
+        MethodKey(String name, String[] signature) {
+            this.name = name;
+            if(signature == null) {
+                signature = new String[0];
+            }
+            this.signature = signature;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            if(!(other instanceof MethodKey)) {
+                return false;
+            }
+            MethodKey omk = (MethodKey)other;
+            if(!name.equals(omk.name)) {
+                return false;
+            }
+            if(signature.length != omk.signature.length) {
+                return false;
+            }
+            for(int i=0; i < signature.length; i++) {
+                if(!signature[i].equals(omk.signature[i])) {
+                    return false;
+                }
+            }
+            return true;
+        }
+
+        @Override
+        public int hashCode() {
+            return name.hashCode();
+        }
     }
 }

==================================================
JIoEndpoint.java
index aeb77a2efd..0b92300047 100644
--- a/java/org/apache/tomcat/util/net/DefaultServerSocketFactory.java
+++ b/java/org/apache/tomcat/util/net/DefaultServerSocketFactory.java
@@ -61,15 +61,14 @@ class DefaultServerSocketFactory extends ServerSocketFactory {
  
     @Override
     public Socket acceptSocket(ServerSocket socket)
- 	throws IOException {
- 	return socket.accept();
+            throws IOException {
+        return socket.accept();
     }
  
     @Override
     public void handshake(Socket sock)
- 	throws IOException {
+        throws IOException {
         // NOOP
     }
- 	    
         
- }
+}

==================================================
NioBlockingSelector.java
index b20a2d8f36..f393c5d76e 100644
--- a/java/org/apache/tomcat/util/net/JIoEndpoint.java
+++ b/java/org/apache/tomcat/util/net/JIoEndpoint.java
@@ -242,44 +242,44 @@ public class JIoEndpoint extends AbstractEndpoint {
 
         public void run() {
             boolean launch = false;
-        	try {
-        	    
-        	    if (!socket.processing.compareAndSet(false, true)) {
-        	        log.error("Unable to process socket. Invalid state.");
-        	        return;
-        	    }
-        	    
-        	    SocketState state = SocketState.OPEN;
-        	    // Process the request from this socket
-        	    if ( (!socket.isInitialized()) && (!setSocketOptions(socket.getSocket())) ) { 
-        	        state = SocketState.CLOSED;
-        	    }
-        	    socket.setInitialized(true);
-
-        	    if ( (state != SocketState.CLOSED) ) {
-        	        state = (status==null)?handler.process(socket):handler.process(socket,status);
-        	    }
-        	    if (state == SocketState.CLOSED) {
-        	        // Close socket
-        	        if (log.isTraceEnabled()) {
-        	            log.trace("Closing socket:"+socket);
-        	        }
-        	        try {
-        	            socket.getSocket().close();
-        	        } catch (IOException e) {
-        	            // Ignore
-        	        }
-        	    } else if (state == SocketState.OPEN){
-        	        socket.setKeptAlive(true);
-        	        socket.access();
-        	        //keepalive connection
-        	        //TODO - servlet3 check async status, we may just be in a hold pattern
-        	        launch = true;
-        	    } else if (state == SocketState.LONG) {
-        	        socket.access();
-        	        waitingRequests.add(socket);
-        	    }
-        	} finally {
+            try {
+                
+                if (!socket.processing.compareAndSet(false, true)) {
+                    log.error("Unable to process socket. Invalid state.");
+                    return;
+                }
+                
+                SocketState state = SocketState.OPEN;
+                // Process the request from this socket
+                if ( (!socket.isInitialized()) && (!setSocketOptions(socket.getSocket())) ) { 
+                    state = SocketState.CLOSED;
+                }
+                socket.setInitialized(true);
+
+                if ( (state != SocketState.CLOSED) ) {
+                    state = (status==null)?handler.process(socket):handler.process(socket,status);
+                }
+                if (state == SocketState.CLOSED) {
+                    // Close socket
+                    if (log.isTraceEnabled()) {
+                        log.trace("Closing socket:"+socket);
+                    }
+                    try {
+                        socket.getSocket().close();
+                    } catch (IOException e) {
+                        // Ignore
+                    }
+                } else if (state == SocketState.OPEN){
+                    socket.setKeptAlive(true);
+                    socket.access();
+                    //keepalive connection
+                    //TODO - servlet3 check async status, we may just be in a hold pattern
+                    launch = true;
+                } else if (state == SocketState.LONG) {
+                    socket.access();
+                    waitingRequests.add(socket);
+                }
+            } finally {
                 socket.processing.set(false);
                 if (launch) getExecutor().execute(new SocketProcessor(socket));
                 socket = null;

==================================================
SSLImplementation.java
index 8a157ffc28..5bd10ac380 100644
--- a/java/org/apache/tomcat/util/net/NioBlockingSelector.java
+++ b/java/org/apache/tomcat/util/net/NioBlockingSelector.java
@@ -266,13 +266,13 @@ public class NioBlockingSelector {
                             if (SelectionKey.OP_READ==(ops&SelectionKey.OP_READ))countDown(key.getReadLatch());
                         } else {
                             if (sk.isValid()) {
-                            	sk.interestOps(sk.interestOps() & (~ops));
-                            	if (SelectionKey.OP_WRITE==(ops&SelectionKey.OP_WRITE)) countDown(key.getWriteLatch());
-                            	if (SelectionKey.OP_READ==(ops&SelectionKey.OP_READ))countDown(key.getReadLatch());
-                            	if (sk.interestOps()==0) {
-                            	    sk.cancel();
-                            	    sk.attach(null);
-                            	}
+                                sk.interestOps(sk.interestOps() & (~ops));
+                                if (SelectionKey.OP_WRITE==(ops&SelectionKey.OP_WRITE)) countDown(key.getWriteLatch());
+                                if (SelectionKey.OP_READ==(ops&SelectionKey.OP_READ))countDown(key.getReadLatch());
+                                if (sk.interestOps()==0) {
+                                    sk.cancel();
+                                    sk.attach(null);
+                                }
                             }else {
                                 sk.cancel();
                                 sk.attach(null);

==================================================
ServerSocketFactory.java
index 0627ef77bf..fed3078856 100644
--- a/java/org/apache/tomcat/util/net/SSLImplementation.java
+++ b/java/org/apache/tomcat/util/net/SSLImplementation.java
@@ -23,65 +23,66 @@ import javax.net.ssl.SSLSession;
 
 /* SSLImplementation:
 
-   Abstract factory and base class for all SSL implementations.
+ Abstract factory and base class for all SSL implementations.
 
-   @author EKR
-*/
+ @author EKR
+ */
 abstract public class SSLImplementation {
-    private static final org.apache.juli.logging.Log logger =
-        org.apache.juli.logging.LogFactory.getLog(SSLImplementation.class);
+    private static final org.apache.juli.logging.Log logger = org.apache.juli.logging.LogFactory
+            .getLog(SSLImplementation.class);
 
     // The default implementations in our search path
-    private static final String JSSEImplementationClass=
-	"org.apache.tomcat.util.net.jsse.JSSEImplementation";
-    
-    private static final String[] implementations=
-    {
-        JSSEImplementationClass
-    };
-
-    public static SSLImplementation getInstance() throws ClassNotFoundException
-    {
-	for(int i=0;i<implementations.length;i++){
-	    try {
-               SSLImplementation impl=
-		    getInstance(implementations[i]);
-		return impl;
-	    } catch (Exception e) {
-		if(logger.isTraceEnabled()) 
-		    logger.trace("Error creating " + implementations[i],e);
-	    }
-	}
-
-	// If we can't instantiate any of these
-	throw new ClassNotFoundException("Can't find any SSL implementation");
+    private static final String JSSEImplementationClass =
+        "org.apache.tomcat.util.net.jsse.JSSEImplementation";
+
+    private static final String[] implementations = { JSSEImplementationClass };
+
+    public static SSLImplementation getInstance() throws ClassNotFoundException {
+        for (int i = 0; i < implementations.length; i++) {
+            try {
+                SSLImplementation impl = getInstance(implementations[i]);
+                return impl;
+            } catch (Exception e) {
+                if (logger.isTraceEnabled())
+                    logger.trace("Error creating " + implementations[i], e);
+            }
+        }
+
+        // If we can't instantiate any of these
+        throw new ClassNotFoundException("Can't find any SSL implementation");
     }
 
     public static SSLImplementation getInstance(String className)
-	throws ClassNotFoundException
-    {
-	if(className==null) return getInstance();
-
-	try {
-	    // Workaround for the J2SE 1.4.x classloading problem (under Solaris).
-	    // Class.forName(..) fails without creating class using new.
-	    // This is an ugly workaround. 
-	    if( JSSEImplementationClass.equals(className) ) {
-		return new org.apache.tomcat.util.net.jsse.JSSEImplementation();
-	    }
-	    Class<?> clazz=Class.forName(className);
-	    return (SSLImplementation)clazz.newInstance();
-	} catch (Exception e){
-	    if(logger.isDebugEnabled())
-		logger.debug("Error loading SSL Implementation "
-			     +className, e);
-	    throw new ClassNotFoundException("Error loading SSL Implementation "
-				      +className+ " :" +e.toString());
-	}
+            throws ClassNotFoundException {
+        if (className == null)
+            return getInstance();
+
+        try {
+            // Workaround for the J2SE 1.4.x classloading problem (under
+            // Solaris).
+            // Class.forName(..) fails without creating class using new.
+            // This is an ugly workaround.
+            if (JSSEImplementationClass.equals(className)) {
+                return new org.apache.tomcat.util.net.jsse.JSSEImplementation();
+            }
+            Class<?> clazz = Class.forName(className);
+            return (SSLImplementation) clazz.newInstance();
+        } catch (Exception e) {
+            if (logger.isDebugEnabled())
+                logger
+                        .debug("Error loading SSL Implementation " + className,
+                                e);
+            throw new ClassNotFoundException(
+                    "Error loading SSL Implementation " + className + " :"
+                            + e.toString());
+        }
     }
 
     abstract public String getImplementationName();
+
     abstract public ServerSocketFactory getServerSocketFactory();
+
     abstract public SSLSupport getSSLSupport(Socket sock);
+
     abstract public SSLSupport getSSLSupport(SSLSession session);
-}    
+}

==================================================
JSSESocketFactory.java
index c8f20ae86f..d87223cd3c 100644
--- a/java/org/apache/tomcat/util/net/ServerSocketFactory.java
+++ b/java/org/apache/tomcat/util/net/ServerSocketFactory.java
@@ -24,151 +24,152 @@ import java.net.Socket;
 import java.util.Hashtable;
 
 /**
- * This class creates server sockets.  It may be subclassed by other
- * factories, which create particular types of server sockets.  This
- * provides a general framework for the addition of public socket-level
- * functionality.  It it is the server side analogue of a socket factory,
- * and similarly provides a way to capture a variety of policies related
- * to the sockets being constructed.
- *
- * <P> Like socket factories, Server Socket factory instances have two
- * categories of methods.  First are methods used to create sockets.
- * Second are methods which set properties used in the production of
- * sockets, such as networking options.  There is also an environment
- * specific default server socket factory; frameworks will often use
- * their own customized factory.
- * 
- * <P><hr><em> It may be desirable to move this interface into the
+ * This class creates server sockets. It may be subclassed by other factories,
+ * which create particular types of server sockets. This provides a general
+ * framework for the addition of public socket-level functionality. It it is the
+ * server side analogue of a socket factory, and similarly provides a way to
+ * capture a variety of policies related to the sockets being constructed.
+ * <P>
+ * Like socket factories, Server Socket factory instances have two categories of
+ * methods. First are methods used to create sockets. Second are methods which
+ * set properties used in the production of sockets, such as networking options.
+ * There is also an environment specific default server socket factory;
+ * frameworks will often use their own customized factory.
+ * <P>
+ * <hr>
+ * <em> It may be desirable to move this interface into the
  * <b>java.net</b> package, so that is not an extension but the preferred
  * interface.  Should this be serializable, making it a JavaBean which can
  * be saved along with its networking configuration?
- * </em>   
- *
+ * </em>
+ * 
  * @author db@eng.sun.com
  * @author Harish Prabandham
  */
 public abstract class ServerSocketFactory implements Cloneable {
 
     //
-    // NOTE:  JDK 1.1 bug in class GC, this can get collected
+    // NOTE: JDK 1.1 bug in class GC, this can get collected
     // even though it's always accessible via getDefault().
     //
 
     private static ServerSocketFactory theFactory;
-    protected Hashtable<String, Object> attributes =
-        new Hashtable<String, Object>();
+    protected Hashtable<String, Object> attributes = new Hashtable<String, Object>();
 
     /**
      * Constructor is used only by subclasses.
      */
-
-    protected ServerSocketFactory () {
+    protected ServerSocketFactory() {
         /* NOTHING */
     }
 
-    /** General mechanism to pass attributes from the
-     *  ServerConnector to the socket factory.
-     *
-     *  Note that the "preferred" mechanism is to
-     *  use bean setters and explicit methods, but
-     *  this allows easy configuration via server.xml
-     *  or simple Properties
+    /**
+     * General mechanism to pass attributes from the ServerConnector to the
+     * socket factory. Note that the "preferred" mechanism is to use bean
+     * setters and explicit methods, but this allows easy configuration via
+     * server.xml or simple Properties
      */
-    public void setAttribute( String name, Object value ) {
-	if( name!=null && value !=null)
-	    attributes.put( name, value );
+    public void setAttribute(String name, Object value) {
+        if (name != null && value != null)
+            attributes.put(name, value);
     }
-    
+
     /**
      * Returns a copy of the environment's default socket factory.
      */
-    public static synchronized ServerSocketFactory getDefault () {
+    public static synchronized ServerSocketFactory getDefault() {
         //
-        // optimize typical case:  no synch needed
+        // optimize typical case: no synch needed
         //
 
         if (theFactory == null) {
             //
             // Different implementations of this method could
-            // work rather differently.  For example, driving
+            // work rather differently. For example, driving
             // this from a system property, or using a different
             // implementation than JavaSoft's.
             //
 
-            theFactory = new DefaultServerSocketFactory ();
+            theFactory = new DefaultServerSocketFactory();
         }
 
         try {
-            return (ServerSocketFactory) theFactory.clone ();
+            return (ServerSocketFactory) theFactory.clone();
         } catch (CloneNotSupportedException e) {
-            throw new RuntimeException (e.getMessage ());
+            throw new RuntimeException(e.getMessage());
         }
     }
 
     /**
-     * Returns a server socket which uses all network interfaces on
-     * the host, and is bound to a the specified port.  The socket is
-     * configured with the socket options (such as accept timeout)
+     * Returns a server socket which uses all network interfaces on the host,
+     * and is bound to a the specified port. The socket is configured with the
+     * socket options (such as accept timeout) given to this factory.
+     * 
+     * @param port
+     *            the port to listen to
+     * @exception IOException
+     *                for networking errors
+     * @exception InstantiationException
+     *                for construction errors
+     */
+    public abstract ServerSocket createSocket(int port) throws IOException,
+            InstantiationException;
+
+    /**
+     * Returns a server socket which uses all network interfaces on the host, is
+     * bound to a the specified port, and uses the specified connection backlog.
+     * The socket is configured with the socket options (such as accept timeout)
      * given to this factory.
-     *
-     * @param port the port to listen to
-     * @exception IOException for networking errors
-     * @exception InstantiationException for construction errors
+     * 
+     * @param port
+     *            the port to listen to
+     * @param backlog
+     *            how many connections are queued
+     * @exception IOException
+     *                for networking errors
+     * @exception InstantiationException
+     *                for construction errors
      */
-    public abstract ServerSocket createSocket (int port)
-    throws IOException, InstantiationException;
+    public abstract ServerSocket createSocket(int port, int backlog)
+            throws IOException, InstantiationException;
 
     /**
-     * Returns a server socket which uses all network interfaces on
-     * the host, is bound to a the specified port, and uses the 
-     * specified connection backlog.  The socket is configured with
-     * the socket options (such as accept timeout) given to this factory.
-     *
-     * @param port the port to listen to
-     * @param backlog how many connections are queued
-     * @exception IOException for networking errors
-     * @exception InstantiationException for construction errors
+     * Returns a server socket which uses only the specified network interface
+     * on the local host, is bound to a the specified port, and uses the
+     * specified connection backlog. The socket is configured with the socket
+     * options (such as accept timeout) given to this factory.
+     * 
+     * @param port
+     *            the port to listen to
+     * @param backlog
+     *            how many connections are queued
+     * @param ifAddress
+     *            the network interface address to use
+     * @exception IOException
+     *                for networking errors
+     * @exception InstantiationException
+     *                for construction errors
      */
+    public abstract ServerSocket createSocket(int port, int backlog,
+            InetAddress ifAddress) throws IOException, InstantiationException;
 
-    public abstract ServerSocket createSocket (int port, int backlog)
-    throws IOException, InstantiationException;
+    public void initSocket(Socket s) {
+    }
 
     /**
-     * Returns a server socket which uses only the specified network
-     * interface on the local host, is bound to a the specified port,
-     * and uses the specified connection backlog.  The socket is configured
-     * with the socket options (such as accept timeout) given to this factory.
-     *
-     * @param port the port to listen to
-     * @param backlog how many connections are queued
-     * @param ifAddress the network interface address to use
-     * @exception IOException for networking errors
-     * @exception InstantiationException for construction errors
+     * Wrapper function for accept(). This allows us to trap and translate
+     * exceptions if necessary
+     * 
+     * @exception IOException
+     *                ;
      */
+    public abstract Socket acceptSocket(ServerSocket socket) throws IOException;
 
-    public abstract ServerSocket createSocket (int port,
-        int backlog, InetAddress ifAddress)
-    throws IOException, InstantiationException;
-
-    public void initSocket( Socket s ) {
-    }
- 
-     /**
-       Wrapper function for accept(). This allows us to trap and
-       translate exceptions if necessary
- 
-       @exception IOException;
-     */ 
-     public abstract Socket acceptSocket(ServerSocket socket)
- 	throws IOException;
- 
-     /**
-       Extra function to initiate the handshake. Sometimes necessary
-       for SSL
- 
-       @exception IOException;
-     */ 
-     public abstract void handshake(Socket sock)
- 	throws IOException;
+    /**
+     * Extra function to initiate the handshake. Sometimes necessary for SSL
+     * 
+     * @exception IOException
+     *                ;
+     */
+    public abstract void handshake(Socket sock) throws IOException;
 }
-

==================================================
