de0e6e1e1df5106a514f9d1c1df672b9d63c2bd5
==================================================
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=48668
==================================================
Konstantin Kolinko
==================================================
Sun Mar 7 02:43:12 2010 +0000
==================================================
Compiler.java
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=48668
Fix remaining issues in BZ48668
The idea behind this change is to make ELParser aware about isDeferredAsLiteral option.
Before this change ELParser was used to parse an attribute regardless of isELIgnored or isDeferredSyntaxAllowedAsLiteral values. With this change we do not use ELParser when isELIgnored is true and ELParser does not parse '#{' in expressions when isDeferredSyntaxAllowedAsLiteral is true.
It simplified the code in many places.
Also, servlet specification version from web.xml and JSP specification version from TLD file are now taken into account when determining the default values for isELIgnored and isDeferredSyntaxAllowedAsLiteral. As far as I understand the code, previously only isELIgnored was determined by the servlet specification version.

TstParser.java, bug48668a.jsp:
I reenabled the tests that now pass with these changes applied.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@919914 13f79535-47bb-0310-9956-ffa450edef68



==================================================
ELParser.java
index 1b79f9eb87..93287814b2 100644
--- a/java/org/apache/jasper/compiler/Compiler.java
+++ b/java/org/apache/jasper/compiler/Compiler.java
@@ -152,6 +152,20 @@ public abstract class Compiler {
                     JspUtil.booleanValue(
                             jspProperty.isErrorOnUndeclaredNamespace()));
         }
+        if (ctxt.getTagInfo() != null) {
+            try {
+                double libraryVersion = Double.parseDouble(ctxt.getTagInfo()
+                        .getTagLibrary().getRequiredVersion());
+                if (libraryVersion < 2.0) {
+                    pageInfo.setELIgnored(true);
+                }
+                if (libraryVersion < 2.1) {
+                    pageInfo.setDeferredSyntaxAllowedAsLiteral(true);
+                }
+            } catch (NumberFormatException ex) {
+                // ignored
+            }
+        }
 
         ctxt.checkOutputDir();
         String javaFileName = ctxt.getServletJavaFileName();

==================================================
JspConfig.java
index ce17448d30..4a64b5603e 100644
--- a/java/org/apache/jasper/compiler/ELParser.java
+++ b/java/org/apache/jasper/compiler/ELParser.java
@@ -45,13 +45,16 @@ public class ELParser {
 
     private boolean escapeBS; // is '\' an escape char in text outside EL?
 
+    private final boolean isDeferredSyntaxAllowedAsLiteral;
+
     private static final String reservedWords[] = { "and", "div", "empty",
             "eq", "false", "ge", "gt", "instanceof", "le", "lt", "mod", "ne",
             "not", "null", "or", "true" };
 
-    public ELParser(String expression) {
+    public ELParser(String expression, boolean isDeferredSyntaxAllowedAsLiteral) {
         index = 0;
         this.expression = expression;
+        this.isDeferredSyntaxAllowedAsLiteral = isDeferredSyntaxAllowedAsLiteral;
         expr = new ELNode.Nodes();
     }
 
@@ -61,10 +64,14 @@ public class ELParser {
      * @param expression
      *            The input expression string of the form Char* ('${' Char*
      *            '}')* Char*
+     * @param isDeferredSyntaxAllowedAsLiteral
+     *                      Are deferred expressions treated as literals?
      * @return Parsed EL expression in ELNode.Nodes
      */
-    public static ELNode.Nodes parse(String expression) {
-        ELParser parser = new ELParser(expression);
+    public static ELNode.Nodes parse(String expression,
+            boolean isDeferredSyntaxAllowedAsLiteral) {
+        ELParser parser = new ELParser(expression,
+                isDeferredSyntaxAllowedAsLiteral);
         while (parser.hasNextChar()) {
             String text = parser.skipUntilEL();
             if (text.length() > 0) {
@@ -188,11 +195,13 @@ public class ELParser {
                     buf.append('\\');
                     if (!escapeBS)
                         prev = '\\';
-                } else if (ch == '$' || ch == '#') {
+                } else if (ch == '$'
+                        || (!isDeferredSyntaxAllowedAsLiteral && ch == '#')) {
                     buf.append(ch);
                 }
                 // else error!
-            } else if (prev == '$' || prev == '#') {
+            } else if (prev == '$'
+                    || (!isDeferredSyntaxAllowedAsLiteral && prev == '#')) {
                 if (ch == '{') {
                     this.type = prev;
                     prev = 0;
@@ -201,7 +210,8 @@ public class ELParser {
                 buf.append(prev);
                 prev = 0;
             }
-            if (ch == '\\' || ch == '$' || ch == '#') {
+            if (ch == '\\' || ch == '$'
+                    || (!isDeferredSyntaxAllowedAsLiteral && ch == '#')) {
                 prev = ch;
             } else {
                 buf.append(ch);

==================================================
Validator.java
index 944cda60ee..7024b3d5ef 100644
--- a/java/org/apache/jasper/compiler/JspConfig.java
+++ b/java/org/apache/jasper/compiler/JspConfig.java
@@ -45,14 +45,14 @@ public class JspConfig {
     private ServletContext ctxt;
     private volatile boolean initialized = false;
 
-    private String defaultIsXml = null;		// unspecified
+    private final static String defaultIsXml = null;		// unspecified
     private String defaultIsELIgnored = null;	// unspecified
-    private String defaultIsScriptingInvalid = null;
+    private final static String defaultIsScriptingInvalid = null;
     private String defaultDeferedSyntaxAllowedAsLiteral = null;
-    private String defaultTrimDirectiveWhitespaces = null;
-    private String defaultDefaultContentType = null;
-    private String defaultBuffer = null;
-    private String defaultErrorOnUndeclaredNamespace = "false";
+    private final static String defaultTrimDirectiveWhitespaces = null;
+    private final static String defaultDefaultContentType = null;
+    private final static String defaultBuffer = null;
+    private final static String defaultErrorOnUndeclaredNamespace = "false";
     private JspProperty defaultJspProperty;
 
     public JspConfig(ServletContext ctxt) {
@@ -87,8 +87,12 @@ public class JspConfig {
             if (webApp == null
                     || getVersion(webApp) < 2.4) {
                 defaultIsELIgnored = "true";
+                defaultDeferedSyntaxAllowedAsLiteral = "true";
                 return;
             }
+            if (getVersion(webApp) < 2.5) {
+                defaultDeferedSyntaxAllowedAsLiteral = "true";
+            }
             TreeNode jspConfig = webApp.findChild("jsp-config");
             if (jspConfig == null) {
                 return;

==================================================
TestParser.java
index e48b112761..0ca8b0f0d1 100644
--- a/java/org/apache/jasper/resources/LocalStrings.properties
+++ b/java/org/apache/jasper/resources/LocalStrings.properties
@@ -372,6 +372,7 @@ jsp.error.prolog_pagedir_encoding_mismatch=Page-encoding specified in XML prolog
 jsp.error.prolog_config_encoding_mismatch=Page-encoding specified in XML prolog ({0}) is different from that specified in jsp-property-group ({1})
 jsp.error.attribute.custom.non_rt_with_expr=According to TLD or attribute directive in tag file, attribute {0} does not accept any expressions
 jsp.error.attribute.standard.non_rt_with_expr=The {0} attribute of the {1} standard action does not accept any expressions
+jsp.error.attribute.deferredmix=Cannot use both ${} and #{} EL expressions in the same attribute value
 jsp.error.scripting.variable.missing_name=Unable to determine scripting variable name from attribute {0}
 jasper.error.emptybodycontent.nonempty=According to TLD, tag {0} must be empty, but is not
 jsp.error.tagfile.nameNotUnique=The value of {0} and the value of {1} in line {2} are the same.

==================================================
