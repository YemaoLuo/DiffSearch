e45117fd14f987c3c7199d1e87c26a02e8fec0e7
==================================================
Refactor JSSE/OpenSSL integration to avoid use of finalize()
==================================================
Mark Thomas
==================================================
Mon Aug 23 12:01:14 2021 +0100
==================================================
OpenSSLContext.java
Refactor JSSE/OpenSSL integration to avoid use of finalize()


==================================================
OpenSSLEngine.java
index 7e6d19846f..0ecc6f2997 100644
--- a/java/org/apache/tomcat/util/net/openssl/OpenSSLContext.java
+++ b/java/org/apache/tomcat/util/net/openssl/OpenSSLContext.java
@@ -16,6 +16,8 @@
  */
 package org.apache.tomcat.util.net.openssl;
 
+import java.lang.ref.Cleaner;
+import java.lang.ref.Cleaner.Cleanable;
 import java.nio.charset.StandardCharsets;
 import java.security.PrivateKey;
 import java.security.SecureRandom;
@@ -27,7 +29,6 @@ import java.util.Arrays;
 import java.util.Base64;
 import java.util.Iterator;
 import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
 
 import javax.net.ssl.KeyManager;
 import javax.net.ssl.SSLEngine;
@@ -76,27 +77,27 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
         }
     }
 
+    private static final Cleaner cleaner = Cleaner.create();
+
     private final SSLHostConfig sslHostConfig;
     private final SSLHostConfigCertificate certificate;
     private final List<String> negotiableProtocols;
-    private final long aprPool;
-    private final AtomicInteger aprPoolDestroyed = new AtomicInteger(0);
-    // OpenSSLConfCmd context
-    protected final long cctx;
-    // SSL context
-    protected final long ctx;
 
     private OpenSSLSessionContext sessionContext;
     private X509TrustManager x509TrustManager;
     private String enabledProtocol;
     private boolean initialized = false;
 
+    private final OpenSSLState state;
+    private final Cleanable cleanable;
 
     public OpenSSLContext(SSLHostConfigCertificate certificate, List<String> negotiableProtocols)
             throws SSLException {
         this.sslHostConfig = certificate.getSSLHostConfig();
         this.certificate = certificate;
-        aprPool = Pool.create(0);
+        long aprPool = Pool.create(0);
+        long cctx = 0;
+        long ctx = 0;
         boolean success = false;
         try {
             // Create OpenSSLConfCmd context if used
@@ -114,8 +115,6 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                 } catch (Exception e) {
                     throw new SSLException(sm.getString("openssl.errMakeConf"), e);
                 }
-            } else {
-                cctx = 0;
             }
             sslHostConfig.setOpenSslConfContext(Long.valueOf(cctx));
 
@@ -163,6 +162,20 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
         } catch(Exception e) {
             throw new SSLException(sm.getString("openssl.errorSSLCtxInit"), e);
         } finally {
+            state = new OpenSSLState(aprPool, cctx, ctx);
+            /*
+             * When an SSLHostConfig is replaced at runtime, it is not possible to
+             * call destroy() on the associated OpenSSLContext since it is likely
+             * that there will be in-progress connections using the OpenSSLContext.
+             * A reference chain has been deliberately established (see
+             * OpenSSLSessionContext) to ensure that the OpenSSLContext remains
+             * ineligible for GC while those connections are alive. Once those
+             * connections complete, the OpenSSLContext will become eligible for GC
+             * and this method will ensure that the associated native resources are
+             * cleaned up.
+             */
+            cleanable = cleaner.register(this, state);
+
             if (!success) {
                 destroy();
             }
@@ -182,20 +195,10 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
 
     @Override
     public synchronized void destroy() {
-        // Guard against multiple destroyPools() calls triggered by construction exception and finalize() later
-        if (aprPoolDestroyed.compareAndSet(0, 1)) {
-            if (ctx != 0) {
-                SSLContext.free(ctx);
-            }
-            if (cctx != 0) {
-                SSLConf.free(cctx);
-            }
-            if (aprPool != 0) {
-                Pool.destroy(aprPool);
-            }
-        }
+        cleanable.clean();
     }
 
+
     /**
      * Setup the SSL_CTX.
      *
@@ -213,35 +216,35 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
         }
         try {
             if (sslHostConfig.getInsecureRenegotiation()) {
-                SSLContext.setOptions(ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
+                SSLContext.setOptions(state.ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
             } else {
-                SSLContext.clearOptions(ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
+                SSLContext.clearOptions(state.ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
             }
 
             // Use server's preference order for ciphers (rather than
             // client's)
             if (sslHostConfig.getHonorCipherOrder()) {
-                SSLContext.setOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
+                SSLContext.setOptions(state.ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
             } else {
-                SSLContext.clearOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
+                SSLContext.clearOptions(state.ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
             }
 
             // Disable compression if requested
             if (sslHostConfig.getDisableCompression()) {
-                SSLContext.setOptions(ctx, SSL.SSL_OP_NO_COMPRESSION);
+                SSLContext.setOptions(state.ctx, SSL.SSL_OP_NO_COMPRESSION);
             } else {
-                SSLContext.clearOptions(ctx, SSL.SSL_OP_NO_COMPRESSION);
+                SSLContext.clearOptions(state.ctx, SSL.SSL_OP_NO_COMPRESSION);
             }
 
             // Disable TLS Session Tickets (RFC4507) to protect perfect forward secrecy
             if (sslHostConfig.getDisableSessionTickets()) {
-                SSLContext.setOptions(ctx, SSL.SSL_OP_NO_TICKET);
+                SSLContext.setOptions(state.ctx, SSL.SSL_OP_NO_TICKET);
             } else {
-                SSLContext.clearOptions(ctx, SSL.SSL_OP_NO_TICKET);
+                SSLContext.clearOptions(state.ctx, SSL.SSL_OP_NO_TICKET);
             }
 
             // List the ciphers that the client is permitted to negotiate
-            SSLContext.setCipherSuite(ctx, sslHostConfig.getCiphers());
+            SSLContext.setCipherSuite(state.ctx, sslHostConfig.getCiphers());
 
             if (certificate.getCertificateFile() == null) {
                 certificate.setCertificateKeyManager(OpenSSLUtil.chooseKeyManager(kms));
@@ -265,12 +268,12 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                 value = SSL.SSL_CVERIFY_REQUIRE;
                 break;
             }
-            SSLContext.setVerify(ctx, value, sslHostConfig.getCertificateVerificationDepth());
+            SSLContext.setVerify(state.ctx, value, sslHostConfig.getCertificateVerificationDepth());
 
             if (tms != null) {
                 // Client certificate verification based on custom trust managers
                 x509TrustManager = chooseTrustManager(tms);
-                SSLContext.setCertVerifyCallback(ctx, new CertificateVerifier() {
+                SSLContext.setCertVerifyCallback(state.ctx, new CertificateVerifier() {
                     @Override
                     public boolean verify(long ssl, byte[][] chain, String auth) {
                         X509Certificate[] peerCerts = certificates(chain);
@@ -288,14 +291,14 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                 // by the server during the handshake to allow the client choosing
                 // an acceptable certificate
                 for (X509Certificate caCert : x509TrustManager.getAcceptedIssuers()) {
-                    SSLContext.addClientCACertificateRaw(ctx, caCert.getEncoded());
+                    SSLContext.addClientCACertificateRaw(state.ctx, caCert.getEncoded());
                     if (log.isDebugEnabled()) {
                         log.debug(sm.getString("openssl.addedClientCaCert", caCert.toString()));
                     }
                 }
             } else {
                 // Client certificate verification based on trusted CA files and dirs
-                SSLContext.setCACertificate(ctx,
+                SSLContext.setCACertificate(state.ctx,
                         SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificateFile()),
                         SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificatePath()));
             }
@@ -304,19 +307,19 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                 List<String> protocols = new ArrayList<>(negotiableProtocols);
                 protocols.add("http/1.1");
                 String[] protocolsArray = protocols.toArray(new String[0]);
-                SSLContext.setAlpnProtos(ctx, protocolsArray, SSL.SSL_SELECTOR_FAILURE_NO_ADVERTISE);
-                SSLContext.setNpnProtos(ctx, protocolsArray, SSL.SSL_SELECTOR_FAILURE_NO_ADVERTISE);
+                SSLContext.setAlpnProtos(state.ctx, protocolsArray, SSL.SSL_SELECTOR_FAILURE_NO_ADVERTISE);
+                SSLContext.setNpnProtos(state.ctx, protocolsArray, SSL.SSL_SELECTOR_FAILURE_NO_ADVERTISE);
             }
 
             // Apply OpenSSLConfCmd if used
             OpenSSLConf openSslConf = sslHostConfig.getOpenSslConf();
-            if (openSslConf != null && cctx != 0) {
+            if (openSslConf != null && state.cctx != 0) {
                 // Check OpenSSLConfCmd if used
                 if (log.isDebugEnabled()) {
                     log.debug(sm.getString("openssl.checkConf"));
                 }
                 try {
-                    if (!openSslConf.check(cctx)) {
+                    if (!openSslConf.check(state.cctx)) {
                         log.error(sm.getString("openssl.errCheckConf"));
                         throw new Exception(sm.getString("openssl.errCheckConf"));
                     }
@@ -327,7 +330,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                     log.debug(sm.getString("openssl.applyConf"));
                 }
                 try {
-                    if (!openSslConf.apply(cctx, ctx)) {
+                    if (!openSslConf.apply(state.cctx, state.ctx)) {
                         log.error(sm.getString("openssl.errApplyConf"));
                         throw new SSLException(sm.getString("openssl.errApplyConf"));
                     }
@@ -335,7 +338,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                     throw new SSLException(sm.getString("openssl.errApplyConf"), e);
                 }
                 // Reconfigure the enabled protocols
-                int opts = SSLContext.getOptions(ctx);
+                int opts = SSLContext.getOptions(state.ctx);
                 List<String> enabled = new ArrayList<>();
                 // Seems like there is no way to explicitly disable SSLv2Hello
                 // in OpenSSL so it is always enabled
@@ -358,7 +361,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
                 sslHostConfig.setEnabledProtocols(
                         enabled.toArray(new String[0]));
                 // Reconfigure the enabled ciphers
-                sslHostConfig.setEnabledCiphers(SSLContext.getCiphers(ctx));
+                sslHostConfig.setEnabledCiphers(SSLContext.getCiphers(state.ctx));
             }
 
             sessionContext = new OpenSSLSessionContext(this);
@@ -366,7 +369,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
             // this is set so always set it in case an app is configured to
             // require it
             sessionContext.setSessionIdContext(SSLContext.DEFAULT_SESSION_ID_CONTEXT);
-            sslHostConfig.setOpenSslContext(Long.valueOf(ctx));
+            sslHostConfig.setOpenSslContext(Long.valueOf(state.ctx));
             initialized = true;
         } catch (Exception e) {
             log.warn(sm.getString("openssl.errorSSLCtxInit"), e);
@@ -379,15 +382,15 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
         // Load Server key and certificate
         if (certificate.getCertificateFile() != null) {
             // Set certificate
-            SSLContext.setCertificate(ctx,
+            SSLContext.setCertificate(state.ctx,
                     SSLHostConfig.adjustRelativePath(certificate.getCertificateFile()),
                     SSLHostConfig.adjustRelativePath(certificate.getCertificateKeyFile()),
                     certificate.getCertificateKeyPassword(), getCertificateIndex(certificate));
             // Set certificate chain file
-            SSLContext.setCertificateChainFile(ctx,
+            SSLContext.setCertificateChainFile(state.ctx,
                     SSLHostConfig.adjustRelativePath(certificate.getCertificateChainFile()), false);
             // Set revocation
-            SSLContext.setCARevocation(ctx,
+            SSLContext.setCARevocation(state.ctx,
                     SSLHostConfig.adjustRelativePath(
                             sslHostConfig.getCertificateRevocationListFile()),
                     SSLHostConfig.adjustRelativePath(
@@ -407,11 +410,11 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
             StringBuilder sb = new StringBuilder(BEGIN_KEY);
             sb.append(Base64.getMimeEncoder(64, new byte[] {'\n'}).encodeToString(key.getEncoded()));
             sb.append(END_KEY);
-            SSLContext.setCertificateRaw(ctx, chain[0].getEncoded(),
+            SSLContext.setCertificateRaw(state.ctx, chain[0].getEncoded(),
                     sb.toString().getBytes(StandardCharsets.US_ASCII),
                     getCertificateIndex(certificate));
             for (int i = 1; i < chain.length; i++) {
-                SSLContext.addChainCertificateRaw(ctx, chain[i].getEncoded());
+                SSLContext.addChainCertificateRaw(state.ctx, chain[i].getEncoded());
             }
         }
     }
@@ -480,7 +483,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
 
 
     long getSSLContextID() {
-        return ctx;
+        return state.ctx;
     }
 
 
@@ -491,7 +494,7 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
 
     @Override
     public SSLEngine createSSLEngine() {
-        return new OpenSSLEngine(ctx, defaultProtocol, false, sessionContext,
+        return new OpenSSLEngine(cleaner, state.ctx, defaultProtocol, false, sessionContext,
                 (negotiableProtocols != null && negotiableProtocols.size() > 0), initialized,
                 sslHostConfig.getCertificateVerificationDepth(),
                 sslHostConfig.getCertificateVerification() == CertificateVerification.OPTIONAL_NO_CA);
@@ -534,23 +537,32 @@ public class OpenSSLContext implements org.apache.tomcat.util.net.SSLContext {
         return acceptedCerts;
     }
 
-    @Override
-    protected void finalize() throws Throwable {
-        /*
-         * When an SSLHostConfig is replaced at runtime, it is not possible to
-         * call destroy() on the associated OpenSSLContext since it is likely
-         * that there will be in-progress connections using the OpenSSLContext.
-         * A reference chain has been deliberately established (see
-         * OpenSSLSessionContext) to ensure that the OpenSSLContext remains
-         * ineligible for GC while those connections are alive. Once those
-         * connections complete, the OpenSSLContext will become eligible for GC
-         * and this method will ensure that the associated native resources are
-         * cleaned up.
-         */
-        try {
-            destroy();
-        } finally {
-            super.finalize();
+
+    private static class OpenSSLState implements Runnable {
+
+        final long aprPool;
+        // OpenSSLConfCmd context
+        final long cctx;
+        // SSL context
+        final long ctx;
+
+        private OpenSSLState(long aprPool, long cctx, long ctx) {
+            this.aprPool = aprPool;
+            this.cctx = cctx;
+            this.ctx = ctx;
+        }
+
+        @Override
+        public void run() {
+            if (ctx != 0) {
+                SSLContext.free(ctx);
+            }
+            if (cctx != 0) {
+                SSLConf.free(cctx);
+            }
+            if (aprPool != 0) {
+                Pool.destroy(aprPool);
+            }
         }
     }
 }

==================================================
