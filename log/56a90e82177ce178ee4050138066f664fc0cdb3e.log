56a90e82177ce178ee4050138066f664fc0cdb3e
==================================================
Property renames
==================================================
Mark Thomas
==================================================
Wed May 27 12:29:20 2020 +0100
==================================================
SSLHostConfig.java
index 71a353cf11..45994913c2 100644
--- a/java/org/apache/tomcat/util/net/LocalStrings_zh_CN.properties
+++ b/java/org/apache/tomcat/util/net/LocalStrings_zh_CN.properties
@@ -135,11 +135,6 @@ endpoint.warn.noRemotePort=无法确定 socket [{0}] 的远程端口
 endpoint.warn.noUtilityExecutor=没有公共的executor 被设置时,创建一个.
 endpoint.warn.unlockAcceptorFailed=接收器线程[{0}]解锁失败。强制硬套接字关闭。
 
-jsse.invalid_truststore_password=提供的信任存储密码无法用于解锁和/或验证信任存储。正在重试使用空密码访问信任存储，该密码将跳过验证。
-jsse.keystore_load_failed=由于{2}，无法加载路径为{1}]的密钥库类型{0}]
-jsse.ssl3=SSLv3 已显式启用。 已知该协议是不安全。
-jsse.tls13.auth=JSSE TLS 1.3实现不支持初始握手后的身份验证，因此与可选的客户端身份验证不兼容
-
 nioBlockingSelector.keyNotRegistered=密钥不再注册
 nioBlockingSelector.possibleLeak=可能的密钥泄漏，正在取消终结器中的密钥
 nioBlockingSelector.processingError=处理选择键操作时出错
@@ -158,6 +153,7 @@ socket.sslreneg=重新协商SSL连接时出现异常
 sslHostConfig.certificate.notype=指定了多个证书，并且至少有一个证书缺少必需的属性类型
 sslHostConfig.certificateVerificationInvalid=证书认证值[{0}]未识别
 sslHostConfig.fileNotFound=配置文件 [{0}] 不存在
+sslHostConfig.invalid_truststore_password=提供的信任存储密码无法用于解锁和/或验证信任存储。正在重试使用空密码访问信任存储，该密码将跳过验证。
 sslHostConfig.mismatch=属性[{0}]是在名为[{1}]的SSLHostConfig 上设置的，用于[{2}]配置语法，但SSLHostConfig 正与[{3}]配置语法一起使用
 sslHostConfig.opensslconf.null=(:忽略设置空OpenSSLConf 的尝试
 sslHostConfig.prefix_missing=协议[{0}]已添加到名为[{1}]的SSLHostConfig 上的协议列表中。检查是否缺少一个+/-前缀。
@@ -167,5 +163,8 @@ sslHostConfigCertificate.mismatch=属性[{0}]是在名为[{1}]的SSLHostConfigCe
 sslImplementation.cnfe=无法为类 [{0}] 创建SSLImplementation
 
 sslUtilBase.active=活跃的[{0}]是：[{1}]
+sslUtilBase.keystore_load_failed=由于{2}，无法加载路径为{1}]的密钥库类型{0}]
 sslUtilBase.noneSupported=SSL引擎不支持指定的[{0}]：[{1}]
 sslUtilBase.skipped=某些指定的[{0}]不受SSL引擎支持，已被跳过：[{1}]
+sslUtilBase.ssl3=SSLv3 已显式启用。 已知该协议是不安全。
+sslUtilBase.tls13.auth=JSSE TLS 1.3实现不支持初始握手后的身份验证，因此与可选的客户端身份验证不兼容

==================================================
SSLUtilBase.java
index c3ac26ee20..734b2132e8 100644
--- a/java/org/apache/tomcat/util/net/SSLHostConfig.java
+++ b/java/org/apache/tomcat/util/net/SSLHostConfig.java
@@ -641,7 +641,7 @@ public class SSLHostConfig implements Serializable {
                     Throwable cause = ioe.getCause();
                     if (cause instanceof UnrecoverableKeyException) {
                         // Log a warning we had a password issue
-                        log.warn(sm.getString("jsse.invalid_truststore_password"),
+                        log.warn(sm.getString("sslHostConfig.invalid_truststore_password"),
                                 cause);
                         // Re-try
                         result = SSLUtilBase.getStore(getTruststoreType(), getTruststoreProvider(),

==================================================
JSSEUtil.java
index 5cd7943ac0..936fbc0b35 100644
--- a/java/org/apache/tomcat/util/net/SSLUtilBase.java
+++ b/java/org/apache/tomcat/util/net/SSLUtilBase.java
@@ -108,14 +108,14 @@ public abstract class SSLUtilBase implements SSLUtil {
         List<String> enabledProtocols =
                 getEnabled("protocols", getLog(), warnTls13, configuredProtocols, implementedProtocols);
         if (enabledProtocols.contains("SSLv3")) {
-            log.warn(sm.getString("jsse.ssl3"));
+            log.warn(sm.getString("sslUtilBase.ssl3"));
         }
         this.enabledProtocols = enabledProtocols.toArray(new String[0]);
 
         if (enabledProtocols.contains(Constants.SSL_PROTO_TLSv1_3) &&
                 sslHostConfig.getCertificateVerification() == CertificateVerification.OPTIONAL &&
                 !isTls13RenegAuthAvailable() && warnTls13) {
-            log.warn(sm.getString("jsse.tls13.auth"));
+            log.warn(sm.getString("sslUtilBase.tls13.auth"));
         }
 
         // Calculate the enabled ciphers
@@ -222,7 +222,7 @@ public abstract class SSLUtilBase implements SSLUtil {
             // Re-throw. Caller will catch and log as required
             throw ioe;
         } catch(Exception ex) {
-            String msg = sm.getString("jsse.keystore_load_failed", type, path,
+            String msg = sm.getString("sslUtilBase.keystore_load_failed", type, path,
                     ex.getMessage());
             log.error(msg, ex);
             throw new IOException(msg);

==================================================
PEMFile.java
index 2e152c2ff1..fbf0da5ce1 100644
--- a/java/org/apache/tomcat/util/net/jsse/LocalStrings_zh_CN.properties
+++ b/java/org/apache/tomcat/util/net/jsse/LocalStrings_zh_CN.properties
@@ -14,22 +14,22 @@
 # limitations under the License.
 
 jsse.alias_no_key_entry=别名[{0}]不标识密钥项
-jsse.excludeProtocol=此JRE支持的SSL协议[{0}]已从Tomcat可用的协议中排除
 jsse.invalidTrustManagerClassName=提供的trustManagerClassName[{0}]未实现javax.net.ssl.TrustManager
 jsse.noCertFile=使用SSL连接器时必须定义SSLHostConfig属性certificateFile
-jsse.noDefaultProtocols=无法确定sslEnabledProtocols的默认值。设置显式值以确保连接器可以启动。
 jsse.noKeys=在密钥存储中找不到私钥的别名
 jsse.openssl.effectiveCiphers=使用的密码：[{0}]
 jsse.openssl.unknownElement=密码字符串中的未知元素：[{0}]。
-jsse.pemParseError=无法从 [{0}] 解析 key
 
 jsseSupport.certTranslationError=错误的转换证书[{0}]
 jsseSupport.clientCertError=尝试从客户端获取证书时出错
 
+jsseUtil.excludeProtocol=此JRE支持的SSL协议[{0}]已从Tomcat可用的协议中排除
 jsseUtil.noCrlSupport=truststoreProvider [{0}]不支持certificateRevocationFile配置选项
+jsseUtil.noDefaultProtocols=无法确定sslEnabledProtocols的默认值。设置显式值以确保连接器可以启动。
 jsseUtil.noVerificationDepth=truststoreProvider[{0}]不支持CertificationDepth配置选项
 jsseUtil.trustedCertNotChecked=未检查别名为{0}的受信任证书的有效日期，因为该证书属于未知类型
 jsseUtil.trustedCertNotValid=由于[{2}]，别名为[{0}]且DN [{1}]的可信证书无效。 将接受由此可信证书签署的证书
 
 pemFile.noMultiPrimes=PKCS#1证书是多素数格式的，Java不提供从该格式构造RSA私钥对象的API
 pemFile.notValidRFC5915=提供的key文件不符合RFC 5915
+pemFile.parseError=无法从 [{0}] 解析 key

==================================================
