ab552fd3fbdfc8091b5338c3129c3472e882d9bf
==================================================
Code cleanup (format). No functional change.
==================================================
Mark Thomas
==================================================
Tue Jan 24 09:57:08 2023 +0000
==================================================
Arrays.java
Code cleanup (format). No functional change.


==================================================
ExceptionUtils.java
index dfe79bd481..9998f6e5d4 100644
--- a/java/org/apache/catalina/tribes/util/Arrays.java
+++ b/java/org/apache/catalina/tribes/util/Arrays.java
@@ -31,38 +31,38 @@ public class Arrays {
     protected static final StringManager sm = StringManager.getManager(Arrays.class);
 
     public static boolean contains(byte[] source, int srcoffset, byte[] key, int keyoffset, int length) {
-        if ( srcoffset < 0 || srcoffset >= source.length) {
+        if (srcoffset < 0 || srcoffset >= source.length) {
             throw new ArrayIndexOutOfBoundsException(sm.getString("arrays.srcoffset.outOfBounds"));
         }
-        if ( keyoffset < 0 || keyoffset >= key.length) {
+        if (keyoffset < 0 || keyoffset >= key.length) {
             throw new ArrayIndexOutOfBoundsException(sm.getString("arrays.keyoffset.outOfBounds"));
         }
-        if ( length > (key.length-keyoffset) ) {
+        if (length > (key.length - keyoffset)) {
             throw new ArrayIndexOutOfBoundsException(sm.getString("arrays.length.outOfBounds"));
         }
-        //we don't have enough data to validate it
-        if ( length > (source.length-srcoffset) ) {
+        // we don't have enough data to validate it
+        if (length > (source.length - srcoffset)) {
             return false;
         }
         boolean match = true;
         int pos = keyoffset;
-        for ( int i=srcoffset; match && i<length; i++ ) {
+        for (int i = srcoffset; match && i < length; i++) {
             match = (source[i] == key[pos++]);
         }
         return match;
     }
 
     public static String toString(byte[] data) {
-        return toString(data,0,data!=null?data.length:0);
+        return toString(data, 0, data != null ? data.length : 0);
     }
 
     public static String toString(byte[] data, int offset, int length) {
-        return toString(data,offset,length,false);
+        return toString(data, offset, length, false);
     }
 
     public static String toString(byte[] data, int offset, int length, boolean unsigned) {
         StringBuilder buf = new StringBuilder("{");
-        if ( data != null && length > 0 ) {
+        if (data != null && length > 0) {
             int i = offset;
             if (unsigned) {
                 buf.append(data[i++] & 0xff);
@@ -81,12 +81,12 @@ public class Arrays {
     }
 
     public static String toString(Object[] data) {
-        return toString(data,0,data!=null?data.length:0);
+        return toString(data, 0, data != null ? data.length : 0);
     }
 
     public static String toString(Object[] data, int offset, int length) {
         StringBuilder buf = new StringBuilder("{");
-        if ( data != null && length > 0 ) {
+        if (data != null && length > 0) {
             buf.append(data[offset++]);
             for (int i = offset; i < length; i++) {
                 buf.append(", ").append(data[i]);
@@ -97,12 +97,12 @@ public class Arrays {
     }
 
     public static String toNameString(Member[] data) {
-        return toNameString(data,0,data!=null?data.length:0);
+        return toNameString(data, 0, data != null ? data.length : 0);
     }
 
     public static String toNameString(Member[] data, int offset, int length) {
         StringBuilder buf = new StringBuilder("{");
-        if ( data != null && length > 0 ) {
+        if (data != null && length > 0) {
             buf.append(data[offset++].getName());
             for (int i = offset; i < length; i++) {
                 buf.append(", ").append(data[i].getName());
@@ -129,13 +129,13 @@ public class Arrays {
     }
 
     public static boolean equals(byte[] o1, byte[] o2) {
-        return java.util.Arrays.equals(o1,o2);
+        return java.util.Arrays.equals(o1, o2);
     }
 
     public static boolean equals(Object[] o1, Object[] o2) {
         boolean result = o1.length == o2.length;
-        if ( result ) {
-            for (int i=0; i<o1.length && result; i++ ) {
+        if (result) {
+            for (int i = 0; i < o1.length && result; i++) {
                 result = o1[i].equals(o2[i]);
             }
         }
@@ -145,7 +145,7 @@ public class Arrays {
     public static boolean sameMembers(Member[] m1, Member[] m2) {
         AbsoluteOrder.absoluteOrder(m1);
         AbsoluteOrder.absoluteOrder(m2);
-        return equals(m1,m2);
+        return equals(m1, m2);
     }
 
     public static Member[] merge(Member[] m1, Member[] m2) {
@@ -183,7 +183,7 @@ public class Arrays {
     }
 
     public static Member[] remove(Member[] all, Member remove) {
-        return extract(all,new Member[] {remove});
+        return extract(all, new Member[] { remove });
     }
 
     public static Member[] extract(Member[] all, Member[] remove) {
@@ -197,8 +197,8 @@ public class Arrays {
 
     public static int indexOf(Member member, Member[] members) {
         int result = -1;
-        for (int i=0; (result==-1) && (i<members.length); i++ ) {
-            if ( member.equals(members[i]) ) {
+        for (int i = 0; (result == -1) && (i < members.length); i++) {
+            if (member.equals(members[i])) {
                 result = i;
             }
         }
@@ -206,9 +206,9 @@ public class Arrays {
     }
 
     public static int nextIndex(Member member, Member[] members) {
-        int idx = indexOf(member,members)+1;
-        if (idx >= members.length ) {
-            idx = ((members.length>0)?0:-1);
+        int idx = indexOf(member, members) + 1;
+        if (idx >= members.length) {
+            idx = ((members.length > 0) ? 0 : -1);
         }
 
         return idx;
@@ -227,15 +227,15 @@ public class Arrays {
     }
 
     public static byte[] fromString(String value) {
-        if ( value == null ) {
+        if (value == null) {
             return null;
         }
-        if ( !value.startsWith("{") ) {
+        if (!value.startsWith("{")) {
             throw new RuntimeException(sm.getString("arrays.malformed.arrays"));
         }
-        StringTokenizer t = new StringTokenizer(value,"{,}",false);
+        StringTokenizer t = new StringTokenizer(value, "{,}", false);
         byte[] result = new byte[t.countTokens()];
-        for (int i=0; i<result.length; i++ ) {
+        for (int i = 0; i < result.length; i++) {
             result[i] = Byte.parseByte(t.nextToken());
         }
         return result;

==================================================
ExecutorFactory.java
index 9c74a15e6d..c352e3c39f 100644
--- a/java/org/apache/catalina/tribes/util/ExceptionUtils.java
+++ b/java/org/apache/catalina/tribes/util/ExceptionUtils.java
@@ -22,8 +22,8 @@ package org.apache.catalina.tribes.util;
 public class ExceptionUtils {
 
     /**
-     * Checks whether the supplied Throwable is one that needs to be
-     * rethrown and swallows all others.
+     * Checks whether the supplied Throwable is one that needs to be rethrown and swallows all others.
+     *
      * @param t the Throwable to check
      */
     public static void handleThrowable(Throwable t) {

==================================================
Jre14Compat.java
index b0d1e597fa..f14fd9dd1a 100644
--- a/java/org/apache/catalina/tribes/util/ExecutorFactory.java
+++ b/java/org/apache/catalina/tribes/util/ExecutorFactory.java
@@ -30,37 +30,42 @@ public class ExecutorFactory {
 
     public static ExecutorService newThreadPool(int minThreads, int maxThreads, long maxIdleTime, TimeUnit unit) {
         TaskQueue taskqueue = new TaskQueue();
-        ThreadPoolExecutor service = new TribesThreadPoolExecutor(minThreads, maxThreads, maxIdleTime, unit,taskqueue);
+        ThreadPoolExecutor service = new TribesThreadPoolExecutor(minThreads, maxThreads, maxIdleTime, unit, taskqueue);
         taskqueue.setParent(service);
         return service;
     }
 
-    public static ExecutorService newThreadPool(int minThreads, int maxThreads, long maxIdleTime, TimeUnit unit, ThreadFactory threadFactory) {
+    public static ExecutorService newThreadPool(int minThreads, int maxThreads, long maxIdleTime, TimeUnit unit,
+            ThreadFactory threadFactory) {
         TaskQueue taskqueue = new TaskQueue();
-        ThreadPoolExecutor service = new TribesThreadPoolExecutor(minThreads, maxThreads, maxIdleTime, unit,taskqueue, threadFactory);
+        ThreadPoolExecutor service = new TribesThreadPoolExecutor(minThreads, maxThreads, maxIdleTime, unit, taskqueue,
+                threadFactory);
         taskqueue.setParent(service);
         return service;
     }
 
     // ---------------------------------------------- TribesThreadPoolExecutor Inner Class
     private static class TribesThreadPoolExecutor extends ThreadPoolExecutor {
-        public TribesThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
+        public TribesThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,
+                BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
             super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
             prestartAllCoreThreads();
         }
 
-        public TribesThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory,
-                RejectedExecutionHandler handler) {
+        public TribesThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,
+                BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
             super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
             prestartAllCoreThreads();
         }
 
-        public TribesThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
+        public TribesThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,
+                BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
             super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
             prestartAllCoreThreads();
         }
 
-        public TribesThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
+        public TribesThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,
+                BlockingQueue<Runnable> workQueue) {
             super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
             prestartAllCoreThreads();
         }
@@ -71,7 +76,7 @@ public class ExecutorFactory {
                 super.execute(command);
             } catch (RejectedExecutionException rx) {
                 if (super.getQueue() instanceof TaskQueue) {
-                    TaskQueue queue = (TaskQueue)super.getQueue();
+                    TaskQueue queue = (TaskQueue) super.getQueue();
                     if (!queue.force(command)) {
                         throw new RejectedExecutionException(sm.getString("executorFactory.queue.full"));
                     }
@@ -80,7 +85,7 @@ public class ExecutorFactory {
         }
     }
 
-     // ---------------------------------------------- TaskQueue Inner Class
+    // ---------------------------------------------- TaskQueue Inner Class
     private static class TaskQueue extends LinkedBlockingQueue<Runnable> {
         private static final long serialVersionUID = 1L;
 
@@ -104,24 +109,24 @@ public class ExecutorFactory {
 
         @Override
         public boolean offer(Runnable o) {
-            //we can't do any checks
-            if (parent==null) {
+            // we can't do any checks
+            if (parent == null) {
                 return super.offer(o);
             }
-            //we are maxed out on threads, simply queue the object
+            // we are maxed out on threads, simply queue the object
             if (parent.getPoolSize() == parent.getMaximumPoolSize()) {
                 return super.offer(o);
             }
-            //we have idle threads, just add it to the queue
-            //this is an approximation, so it could use some tuning
-            if (parent.getActiveCount()<(parent.getPoolSize())) {
+            // we have idle threads, just add it to the queue
+            // this is an approximation, so it could use some tuning
+            if (parent.getActiveCount() < (parent.getPoolSize())) {
                 return super.offer(o);
             }
-            //if we have less threads than maximum force creation of a new thread
-            if (parent.getPoolSize()<parent.getMaximumPoolSize()) {
+            // if we have less threads than maximum force creation of a new thread
+            if (parent.getPoolSize() < parent.getMaximumPoolSize()) {
                 return false;
             }
-            //if we reached here, we need to add it to the queue
+            // if we reached here, we need to add it to the queue
             return super.offer(o);
         }
     }

==================================================
JreCompat.java
index 1fb58a0a28..ad155e6b8e 100644
--- a/java/org/apache/catalina/tribes/util/Jre14Compat.java
+++ b/java/org/apache/catalina/tribes/util/Jre14Compat.java
@@ -52,8 +52,7 @@ public class Jre14Compat extends JreCompat {
     @Override
     public void setSocketoptionIpMulticastLoop(MulticastSocket socket, boolean enabled) throws IOException {
         /*
-         *  Java < 14, a value of true means loopback is disabled. Java 14+ a
-         *  value of true means loopback is enabled.
+         * Java < 14, a value of true means loopback is disabled. Java 14+ a value of true means loopback is enabled.
          */
         socket.setOption(StandardSocketOptions.IP_MULTICAST_LOOP, Boolean.valueOf(enabled));
     }

==================================================
Logs.java
index 2374ed1e2f..563675da39 100644
--- a/java/org/apache/catalina/tribes/util/JreCompat.java
+++ b/java/org/apache/catalina/tribes/util/JreCompat.java
@@ -21,9 +21,8 @@ import java.net.MulticastSocket;
 import java.net.StandardSocketOptions;
 
 /**
- * This is the base implementation class for JRE compatibility and provides an
- * implementation based on Java 11. Sub-classes may extend this class and provide
- * alternative implementations for later JRE versions
+ * This is the base implementation class for JRE compatibility and provides an implementation based on Java 11.
+ * Sub-classes may extend this class and provide alternative implementations for later JRE versions
  */
 public class JreCompat {
 
@@ -49,8 +48,7 @@ public class JreCompat {
 
     public void setSocketoptionIpMulticastLoop(MulticastSocket socket, boolean enabled) throws IOException {
         /*
-         *  Java < 14, a value of true means loopback is disabled. Java 14+ a
-         *  value of true means loopback is enabled.
+         * Java < 14, a value of true means loopback is disabled. Java 14+ a value of true means loopback is enabled.
          */
         socket.setOption(StandardSocketOptions.IP_MULTICAST_LOOP, Boolean.valueOf(!enabled));
     }

==================================================
StringManager.java
index 112e8cf8f5..1c1933b93b 100644
--- a/java/org/apache/catalina/tribes/util/Logs.java
+++ b/java/org/apache/catalina/tribes/util/Logs.java
@@ -18,6 +18,7 @@ package org.apache.catalina.tribes.util;
 
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
+
 /**
  * Simple class that holds references to global loggers
  */

==================================================
TcclThreadFactory.java
index 0a60c94366..32a69e6e39 100644
--- a/java/org/apache/catalina/tribes/util/StringManager.java
+++ b/java/org/apache/catalina/tribes/util/StringManager.java
@@ -27,27 +27,22 @@ import java.util.ResourceBundle;
 
 
 /**
- * An internationalization / localization helper class which reduces
- * the bother of handling ResourceBundles and takes care of the
- * common cases of message formatting which otherwise require the
- * creation of Object arrays and such.
- *
- * <p>The StringManager operates on a package basis. One StringManager
- * per package can be created and accessed via the getManager method
- * call.
- *
- * <p>The StringManager will look for a ResourceBundle named by
- * the package name given plus the suffix of "LocalStrings". In
- * practice, this means that the localized information will be contained
- * in a LocalStrings.properties file located in the package
- * directory of the classpath.
- *
- * <p>Please see the documentation for java.util.ResourceBundle for
- * more information.
+ * An internationalization / localization helper class which reduces the bother of handling ResourceBundles and takes
+ * care of the common cases of message formatting which otherwise require the creation of Object arrays and such.
+ * <p>
+ * The StringManager operates on a package basis. One StringManager per package can be created and accessed via the
+ * getManager method call.
+ * <p>
+ * The StringManager will look for a ResourceBundle named by the package name given plus the suffix of "LocalStrings".
+ * In practice, this means that the localized information will be contained in a LocalStrings.properties file located in
+ * the package directory of the classpath.
+ * <p>
+ * Please see the documentation for java.util.ResourceBundle for more information.
  *
  * @author James Duncan Davidson [duncan@eng.sun.com]
  * @author James Todd [gonzo@eng.sun.com]
  * @author Mel Martinez [mmartinez@g1440.com]
+ *
  * @see java.util.ResourceBundle
  */
 public class StringManager {
@@ -62,10 +57,8 @@ public class StringManager {
 
 
     /**
-     * Creates a new StringManager for a given package. This is a
-     * private method and all access to it is arbitrated by the
-     * static getManager method call so that only one StringManager
-     * per package will be created.
+     * Creates a new StringManager for a given package. This is a private method and all access to it is arbitrated by
+     * the static getManager method call so that only one StringManager per package will be created.
      *
      * @param packageName Name of package to create StringManager for.
      */
@@ -103,18 +96,16 @@ public class StringManager {
 
 
     /**
-     * Get a string from the underlying resource bundle or return null if the
-     * String is not found.
+     * Get a string from the underlying resource bundle or return null if the String is not found.
      *
      * @param key to desired resource String
      *
-     * @return resource String matching <i>key</i> from underlying bundle or
-     *         null if not found.
+     * @return resource String matching <i>key</i> from underlying bundle or null if not found.
      *
      * @throws IllegalArgumentException if <i>key</i> is null
      */
     public String getString(String key) {
-        if (key == null){
+        if (key == null) {
             String msg = "key may not have a null value";
             throw new IllegalArgumentException(msg);
         }
@@ -127,17 +118,17 @@ public class StringManager {
                 str = bundle.getString(key);
             }
         } catch (MissingResourceException mre) {
-            //bad: shouldn't mask an exception the following way:
-            //   str = "[cannot find message associated with key '" + key +
-            //         "' due to " + mre + "]";
-            //     because it hides the fact that the String was missing
-            //     from the calling code.
-            //good: could just throw the exception (or wrap it in another)
-            //      but that would probably cause much havoc on existing
-            //      code.
-            //better: consistent with container pattern to
-            //      simply return null.  Calling code can then do
-            //      a null check.
+            // bad: shouldn't mask an exception the following way:
+            // str = "[cannot find message associated with key '" + key +
+            // "' due to " + mre + "]";
+            // because it hides the fact that the String was missing
+            // from the calling code.
+            // good: could just throw the exception (or wrap it in another)
+            // but that would probably cause much havoc on existing
+            // code.
+            // better: consistent with container pattern to
+            // simply return null. Calling code can then do
+            // a null check.
             str = null;
         }
 
@@ -146,8 +137,7 @@ public class StringManager {
 
 
     /**
-     * Get a string from the underlying resource bundle and format
-     * it with the given set of arguments.
+     * Get a string from the underlying resource bundle and format it with the given set of arguments.
      *
      * @param key  The key for the required message
      * @param args The values to insert into the message
@@ -180,13 +170,12 @@ public class StringManager {
     // STATIC SUPPORT METHODS
     // --------------------------------------------------------------
 
-    private static final Map<String, Map<Locale,StringManager>> managers = new HashMap<>();
+    private static final Map<String, Map<Locale, StringManager>> managers = new HashMap<>();
 
 
     /**
-     * The StringManager will be returned for the package in which the class is
-     * located. If a manager for that package already exists, it will be reused,
-     * else a new StringManager will be created and returned.
+     * The StringManager will be returned for the package in which the class is located. If a manager for that package
+     * already exists, it will be reused, else a new StringManager will be created and returned.
      *
      * @param clazz The class for which to retrieve the StringManager
      *
@@ -198,8 +187,8 @@ public class StringManager {
 
 
     /**
-     * If a manager for a package already exists, it will be reused, else a new
-     * StringManager will be created and returned.
+     * If a manager for a package already exists, it will be reused, else a new StringManager will be created and
+     * returned.
      *
      * @param packageName The package name
      *
@@ -211,32 +200,29 @@ public class StringManager {
 
 
     /**
-     * If a manager for a package/Locale combination already exists, it will be
-     * reused, else a new StringManager will be created and returned.
+     * If a manager for a package/Locale combination already exists, it will be reused, else a new StringManager will be
+     * created and returned.
      *
      * @param packageName The package name
      * @param locale      The Locale
      *
      * @return The StringManager for a particular package and Locale
      */
-    public static final synchronized StringManager getManager(
-            String packageName, Locale locale) {
+    public static final synchronized StringManager getManager(String packageName, Locale locale) {
 
-        Map<Locale,StringManager> map = managers.get(packageName);
+        Map<Locale, StringManager> map = managers.get(packageName);
         if (map == null) {
             /*
-             * Don't want the HashMap to be expanded beyond LOCALE_CACHE_SIZE.
-             * Expansion occurs when size() exceeds capacity. Therefore keep
-             * size at or below capacity.
-             * removeEldestEntry() executes after insertion therefore the test
-             * for removal needs to use one less than the maximum desired size
+             * Don't want the HashMap to be expanded beyond LOCALE_CACHE_SIZE. Expansion occurs when size() exceeds
+             * capacity. Therefore keep size at or below capacity. removeEldestEntry() executes after insertion
+             * therefore the test for removal needs to use one less than the maximum desired size
              *
              */
             map = new LinkedHashMap<>(LOCALE_CACHE_SIZE, 1, true) {
                 private static final long serialVersionUID = 1L;
+
                 @Override
-                protected boolean removeEldestEntry(
-                        Map.Entry<Locale,StringManager> eldest) {
+                protected boolean removeEldestEntry(Map.Entry<Locale, StringManager> eldest) {
                     if (size() > (LOCALE_CACHE_SIZE - 1)) {
                         return true;
                     }
@@ -256,16 +242,14 @@ public class StringManager {
 
 
     /**
-     * Retrieve the StringManager for a list of Locales. The first StringManager
-     * found will be returned.
+     * Retrieve the StringManager for a list of Locales. The first StringManager found will be returned.
      *
-     * @param packageName The package for which the StringManager is required
+     * @param packageName      The package for which the StringManager is required
      * @param requestedLocales the list of Locales
      *
      * @return the found StringManager or the default StringManager
      */
-    public static StringManager getManager(String packageName,
-            Enumeration<Locale> requestedLocales) {
+    public static StringManager getManager(String packageName, Enumeration<Locale> requestedLocales) {
         while (requestedLocales.hasMoreElements()) {
             Locale locale = requestedLocales.nextElement();
             StringManager result = getManager(packageName, locale);

==================================================
UUIDGenerator.java
index 4fbbc44069..9d52fc363c 100644
--- a/java/org/apache/catalina/tribes/util/TcclThreadFactory.java
+++ b/java/org/apache/catalina/tribes/util/TcclThreadFactory.java
@@ -20,11 +20,9 @@ import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
- * ThreadFactory implementation that creates threads with the thread context
- * class loader set to the class loader that loaded this factory. It is intended
- * to be used when tasks may be passed to executors when the web application
- * class loader is set as the thread context class loader, such as in async
- * session replication.
+ * ThreadFactory implementation that creates threads with the thread context class loader set to the class loader that
+ * loaded this factory. It is intended to be used when tasks may be passed to executors when the web application class
+ * loader is set as the thread context class loader, such as in async session replication.
  */
 public class TcclThreadFactory implements ThreadFactory {
 

==================================================
