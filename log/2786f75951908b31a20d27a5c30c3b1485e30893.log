2786f75951908b31a20d27a5c30c3b1485e30893
==================================================
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=56636
==================================================
Mark Emlyn
==================================================
Wed Jun 18 10:33:26 2014 +0000
==================================================
ELProcessor.java
Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=56636
Correct various issues in method signature matching

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1603402 13f79535-47bb-0310-9956-ffa450edef68



==================================================
TestELProcessor.java
index 7f3cc97a20..d29d4f49b9 100644
--- a/java/javax/el/ELProcessor.java
+++ b/java/javax/el/ELProcessor.java
@@ -18,12 +18,28 @@ package javax.el;
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
+import java.util.HashSet;
+import java.util.Set;
 
 /**
  * @since EL 3.0
  */
 public class ELProcessor {
 
+    private static final Set<String> PRIMITIVES = new HashSet<>();
+    static {
+        PRIMITIVES.add("boolean");
+        PRIMITIVES.add("byte");
+        PRIMITIVES.add("char");
+        PRIMITIVES.add("double");
+        PRIMITIVES.add("float");
+        PRIMITIVES.add("int");
+        PRIMITIVES.add("long");
+        PRIMITIVES.add("short");
+    }
+
+    private static final String[] EMPTY_STRING_ARRAY = new String[0];
+
     private final ELManager manager = new ELManager();
     private final ELContext context = manager.getELContext();
     private final ExpressionFactory factory = ELManager.getExpressionFactory();
@@ -97,6 +113,15 @@ public class ELProcessor {
             }
             if (method.getName().equals(sig.getName())) {
                 if (sig.getParamTypeNames() == null) {
+                    // Only a name provided, no signature so map the first
+                    // method declared
+                    manager.mapFunction(prefix, function, method);
+                    return;
+                }
+                if (sig.getParamTypeNames().length != method.getParameterTypes().length) {
+                    continue;
+                }
+                if (sig.getParamTypeNames().length == 0) {
                     manager.mapFunction(prefix, function, method);
                     return;
                 } else {
@@ -174,7 +199,22 @@ public class ELProcessor {
                 name = methodName.trim();
                 parameterTypeNames = null;
             } else {
-                name = methodName.substring(0, paramIndex -1).trim();
+                String returnTypeAndName = methodName.substring(0, paramIndex).trim();
+                // Assume that the return type and the name are separated by
+                // whitespace. Given the use of trim() above, there should only
+                // be one sequence of whitespace characters.
+                int wsPos = -1;
+                for (int i = 0; i < returnTypeAndName.length(); i++) {
+                    if (Character.isWhitespace(returnTypeAndName.charAt(i))) {
+                        wsPos = i;
+                        break;
+                    }
+                }
+                if (wsPos == -1) {
+                    throw new NoSuchMethodException();
+                }
+                name = returnTypeAndName.substring(wsPos).trim();
+
                 String paramString = methodName.substring(paramIndex).trim();
                 // We know the params start with '(', check they end with ')'
                 if (!paramString.endsWith(")")) {
@@ -183,26 +223,31 @@ public class ELProcessor {
                             paramString, methodName, className));
                 }
                 // Trim '(' and ')'
-                paramString =
-                        paramString.substring(1, paramString.length() - 1);
-                parameterTypeNames = paramString.split(",");
-                ImportHandler importHandler = context.getImportHandler();
-                for (int i = 0; i < parameterTypeNames.length; i++) {
-                    parameterTypeNames[i] = parameterTypeNames[i].trim();
-                    if (!parameterTypeNames[i].contains(".")) {
-                        Class<?> clazz = importHandler.resolveClass(
-                                parameterTypeNames[i]);
-                        if (clazz == null) {
-                            throw new NoSuchMethodException(Util.message(
-                                    context,
-                                    "elProcessor.defineFunctionInvalidParameterTypeName",
-                                    parameterTypeNames[i], methodName,
-                                    className));
+                paramString = paramString.substring(1, paramString.length() - 1).trim();
+                if (paramString.length() == 0) {
+                    parameterTypeNames = EMPTY_STRING_ARRAY;
+                } else {
+                    parameterTypeNames = paramString.split(",");
+                    ImportHandler importHandler = context.getImportHandler();
+                    for (int i = 0; i < parameterTypeNames.length; i++) {
+                        String parameterTypeName = parameterTypeNames[i].trim();
+                        if (!PRIMITIVES.contains(parameterTypeName) &&
+                                !parameterTypeName.contains(".")) {
+                            Class<?> clazz = importHandler.resolveClass(
+                                    parameterTypeName);
+                            if (clazz == null) {
+                                throw new NoSuchMethodException(Util.message(
+                                        context,
+                                        "elProcessor.defineFunctionInvalidParameterTypeName",
+                                        parameterTypeNames[i], methodName,
+                                        className));
+                            }
+                            parameterTypeNames[i] = clazz.getName();
                         }
-                        parameterTypeNames[i] = clazz.getName();
                     }
                 }
             }
+
         }
 
         public String getName() {

==================================================
TesterFunctions.java
index b51a41e37d..b86c2e3256 100644
--- a/test/javax/el/TestELProcessor.java
+++ b/test/javax/el/TestELProcessor.java
@@ -62,6 +62,44 @@ public class TestELProcessor {
     }
 
 
+    @Test
+    public void testDefineFunctionMethod02() throws Exception {
+        ELProcessor elp = new ELProcessor();
+        elp.defineFunction("fn", "test", "java.lang.Integer", "Integer valueOf(int)");
+        Assert.assertEquals(Integer.valueOf(1), elp.eval("fn:test(1)"));
+    }
+
+
+    @Test
+    public void testDefineFunctionMethod03() throws Exception {
+        TesterFunctions.resetCallList();
+        ELProcessor elp = new ELProcessor();
+        elp.defineFunction("fn", "test", "javax.el.TesterFunctions", "void doIt()");
+        elp.eval("fn:test()");
+        Assert.assertEquals("A", TesterFunctions.getCallList());
+    }
+
+
+    @Test
+    public void testDefineFunctionMethod04() throws Exception {
+        TesterFunctions.resetCallList();
+        ELProcessor elp = new ELProcessor();
+        elp.defineFunction("fn", "test", "javax.el.TesterFunctions", "void doIt(int)");
+        elp.eval("fn:test(5)");
+        Assert.assertEquals("B", TesterFunctions.getCallList());
+    }
+
+
+    @Test
+    public void testDefineFunctionMethod05() throws Exception {
+        TesterFunctions.resetCallList();
+        ELProcessor elp = new ELProcessor();
+        elp.defineFunction("fn", "test", "javax.el.TesterFunctions", "void doIt(Integer)");
+        elp.eval("fn:test(null)");
+        Assert.assertEquals("C", TesterFunctions.getCallList());
+    }
+
+
     @Test
     public void testDefineFunctionName01() throws Exception {
         ELProcessor elp = new ELProcessor();

==================================================
