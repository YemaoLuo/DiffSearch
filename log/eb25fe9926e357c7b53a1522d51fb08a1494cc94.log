eb25fe9926e357c7b53a1522d51fb08a1494cc94
==================================================
Ensure the application will start even if replication map fails to start.
==================================================
Keiichi Fujino
==================================================
Tue Jul 2 08:11:52 2013 +0000
==================================================
AbstractReplicatedMap.java
Ensure the application will start even if replication map fails to start.

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1498820 13f79535-47bb-0310-9956-ffa450edef68



==================================================
LazyReplicatedMap.java
index d344b7097e..ebcb562354 100644
--- a/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
+++ b/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java
@@ -172,9 +172,10 @@ public abstract class AbstractReplicatedMap<K,V>
                                  int initialCapacity,
                                  float loadFactor,
                                  int channelSendOptions,
-                                 ClassLoader[] cls) {
+                                 ClassLoader[] cls,
+                                 boolean terminate) {
         innerMap = new ConcurrentHashMap<>(initialCapacity, loadFactor, 15);
-        init(owner, channel, mapContextName, timeout, channelSendOptions, cls);
+        init(owner, channel, mapContextName, timeout, channelSendOptions, cls, terminate);
 
     }
 
@@ -198,7 +199,8 @@ public abstract class AbstractReplicatedMap<K,V>
      * @param channelSendOptions int
      * @param cls ClassLoader[]
      */
-    protected void init(MapOwner owner, Channel channel, String mapContextName, long timeout, int channelSendOptions,ClassLoader[] cls) {
+    protected void init(MapOwner owner, Channel channel, String mapContextName,
+            long timeout, int channelSendOptions,ClassLoader[] cls, boolean terminate) {
         log.info("Initializing AbstractReplicatedMap with context name:"+mapContextName);
         this.mapOwner = owner;
         this.externalLoaders = cls;
@@ -228,11 +230,13 @@ public abstract class AbstractReplicatedMap<K,V>
             broadcast(MapMessage.MSG_START, true);
         } catch (ChannelException x) {
             log.warn("Unable to send map start message.");
-            // remove listener from channel
-            this.rpcChannel.breakdown();
-            this.channel.removeChannelListener(this);
-            this.channel.removeMembershipListener(this);
-            throw new RuntimeException("Unable to start replicated map.",x);
+            if (terminate) {
+                // remove listener from channel
+                this.rpcChannel.breakdown();
+                this.channel.removeChannelListener(this);
+                this.channel.removeMembershipListener(this);
+                throw new RuntimeException("Unable to start replicated map.",x);
+            }
         }
     }
 

==================================================
ReplicatedMap.java
index 230e580ae3..0545a16ffc 100644
--- a/java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java
+++ b/java/org/apache/catalina/tribes/tipis/LazyReplicatedMap.java
@@ -80,7 +80,7 @@ public class LazyReplicatedMap<K,V> extends AbstractReplicatedMap<K,V> {
          * @param loadFactor float - load factor, see HashMap
          */
         public LazyReplicatedMap(MapOwner owner, Channel channel, long timeout, String mapContextName, int initialCapacity, float loadFactor, ClassLoader[] cls) {
-            super(owner,channel,timeout,mapContextName,initialCapacity,loadFactor, Channel.SEND_OPTIONS_DEFAULT,cls);
+            super(owner,channel,timeout,mapContextName,initialCapacity,loadFactor, Channel.SEND_OPTIONS_DEFAULT,cls, true);
         }
 
         /**
@@ -91,7 +91,7 @@ public class LazyReplicatedMap<K,V> extends AbstractReplicatedMap<K,V> {
          * @param initialCapacity int - the size of this map, see HashMap
          */
         public LazyReplicatedMap(MapOwner owner, Channel channel, long timeout, String mapContextName, int initialCapacity, ClassLoader[] cls) {
-            super(owner, channel,timeout,mapContextName,initialCapacity, AbstractReplicatedMap.DEFAULT_LOAD_FACTOR, Channel.SEND_OPTIONS_DEFAULT, cls);
+            super(owner, channel,timeout,mapContextName,initialCapacity, AbstractReplicatedMap.DEFAULT_LOAD_FACTOR, Channel.SEND_OPTIONS_DEFAULT, cls, true);
         }
 
         /**
@@ -101,7 +101,19 @@ public class LazyReplicatedMap<K,V> extends AbstractReplicatedMap<K,V> {
          * @param mapContextName String - unique name for this map, to allow multiple maps per channel
          */
         public LazyReplicatedMap(MapOwner owner, Channel channel, long timeout, String mapContextName, ClassLoader[] cls) {
-            super(owner, channel,timeout,mapContextName, AbstractReplicatedMap.DEFAULT_INITIAL_CAPACITY,AbstractReplicatedMap.DEFAULT_LOAD_FACTOR,Channel.SEND_OPTIONS_DEFAULT, cls);
+            super(owner, channel,timeout,mapContextName, AbstractReplicatedMap.DEFAULT_INITIAL_CAPACITY,AbstractReplicatedMap.DEFAULT_LOAD_FACTOR,Channel.SEND_OPTIONS_DEFAULT, cls, true);
+        }
+
+        /**
+         * Creates a new map
+         * @param channel The channel to use for communication
+         * @param timeout long - timeout for RPC messags
+         * @param mapContextName String - unique name for this map, to allow multiple maps per channel
+         * @param terminate boolean - Flag for whether to terminate this map that failed to start.
+         */
+        public LazyReplicatedMap(MapOwner owner, Channel channel, long timeout, String mapContextName, ClassLoader[] cls, boolean terminate) {
+            super(owner, channel,timeout,mapContextName, AbstractReplicatedMap.DEFAULT_INITIAL_CAPACITY,
+                    AbstractReplicatedMap.DEFAULT_LOAD_FACTOR,Channel.SEND_OPTIONS_DEFAULT, cls, terminate);
         }
 
 

==================================================
