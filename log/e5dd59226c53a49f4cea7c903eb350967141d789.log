e5dd59226c53a49f4cea7c903eb350967141d789
==================================================
Yet more protocol alignment (with an eye to aligning with AJP)
==================================================
Mark Emlyn
==================================================
Fri Jul 8 16:19:28 2011 +0000
==================================================
Http11AprProtocol.java
Yet more protocol alignment (with an eye to aligning with AJP)

git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1144375 13f79535-47bb-0310-9956-ffa450edef68



==================================================
Http11NioProtocol.java
index 27f306aaed..b8ae0a84d9 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -265,15 +265,9 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
 
                 if (state == SocketState.LONG) {
                     // In the middle of processing a request/response. Keep the
-                    // socket associated with the processor.
-                    connections.put(socket.getSocket(), processor);
-
-                    if (processor.isAsync()) {
-                        socket.setAsync(true);
-                    } else if (processor.comet) {
-                        ((AprEndpoint) proto.endpoint).getCometPoller().add(
-                                socket.getSocket().longValue());
-                    }
+                    // socket associated with the processor. Exact requirements
+                    // depend on type of long poll
+                    longPoll(socket, processor);
                 } else if (state == SocketState.OPEN){
                     // In keep-alive but between requests. OK to recycle
                     // processor. Continue to poll for the next request.
@@ -300,8 +294,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
                 // any other exception or error is odd. Here we log it
                 // with "ERROR" level, so it will show up even on
                 // less-than-verbose logs.
-                Http11AprProtocol.log.error(
-                        sm.getString("http11protocol.proto.error"), e);
+                log.error(sm.getString("http11protocol.proto.error"), e);
             }
             release(socket, processor, true, false);
             return SocketState.CLOSED;
@@ -313,6 +306,18 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
             // NOOP for APR
         }
 
+        private void longPoll(SocketWrapper<Long> socket,
+                Http11AprProcessor processor) {
+            connections.put(socket.getSocket(), processor);
+
+            if (processor.isAsync()) {
+                socket.setAsync(true);
+            } else if (processor.comet) {
+                ((AprEndpoint) proto.endpoint).getCometPoller().add(
+                        socket.getSocket().longValue());
+            }
+        }
+
         protected Http11AprProcessor createProcessor() {
             Http11AprProcessor processor = new Http11AprProcessor(
                     proto.getMaxHttpHeaderSize(), (AprEndpoint)proto.endpoint,

==================================================
Http11Protocol.java
index b02d16b939..0711d72225 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -280,22 +280,9 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
 
                 if (state == SocketState.LONG) {
                     // In the middle of processing a request/response. Keep the
-                    // socket associated with the processor.
-                    connections.put(socket, processor);
-                    
-                    if (processor.isAsync()) {
-                        socket.setAsync(true);
-                    } else {
-                        // Either:
-                        //  - this is comet request
-                        //  - the request line/headers have not been completely
-                        //    read
-                        SelectionKey key = socket.getSocket().getIOChannel().keyFor(
-                                socket.getSocket().getPoller().getSelector());
-                        key.interestOps(SelectionKey.OP_READ);
-                        ((KeyAttachment) socket).interestOps(
-                                SelectionKey.OP_READ);
-                    }
+                    // socket associated with the processor. Exact requirements
+                    // depend on type of long poll
+                    longPoll(socket, processor);
                 } else if (state == SocketState.OPEN){
                     // In keep-alive but between requests. OK to recycle
                     // processor. Continue to poll for the next request.
@@ -343,6 +330,25 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
 
         }
 
+        private void longPoll(SocketWrapper<NioChannel> socket,
+                Http11NioProcessor processor) {
+            connections.put(socket, processor);
+            
+            if (processor.isAsync()) {
+                socket.setAsync(true);
+            } else {
+                // Either:
+                //  - this is comet request
+                //  - the request line/headers have not been completely
+                //    read
+                SelectionKey key = socket.getSocket().getIOChannel().keyFor(
+                        socket.getSocket().getPoller().getSelector());
+                key.interestOps(SelectionKey.OP_READ);
+                ((KeyAttachment) socket).interestOps(
+                        SelectionKey.OP_READ);
+            }
+        }
+
         public Http11NioProcessor createProcessor() {
             Http11NioProcessor processor = new Http11NioProcessor(
                     proto.getMaxHttpHeaderSize(), (NioEndpoint)proto.endpoint,

==================================================
